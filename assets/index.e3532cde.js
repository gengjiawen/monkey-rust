(async () => {
  var _a2, _b2, _c2, _d2, _e, _f, _g2, _h2, _i, _j2, _k2, _l, _m2, _n2, _o2, _p2, _q2;
  function u_(t, e) {
    for (var n = 0; n < e.length; n++) {
      const r = e[n];
      if (typeof r != "string" && !Array.isArray(r)) {
        for (const i in r)
          if (i !== "default" && !(i in t)) {
            const o = Object.getOwnPropertyDescriptor(r, i);
            o && Object.defineProperty(t, i, o.get ? o : {
              enumerable: true,
              get: () => r[i]
            });
          }
      }
    }
    return Object.freeze(Object.defineProperty(t, Symbol.toStringTag, {
      value: "Module"
    }));
  }
  (function() {
    const e = document.createElement("link").relList;
    if (e && e.supports && e.supports("modulepreload"))
      return;
    for (const i of document.querySelectorAll('link[rel="modulepreload"]'))
      r(i);
    new MutationObserver((i) => {
      for (const o of i)
        if (o.type === "childList")
          for (const s of o.addedNodes)
            s.tagName === "LINK" && s.rel === "modulepreload" && r(s);
    }).observe(document, {
      childList: true,
      subtree: true
    });
    function n(i) {
      const o = {};
      return i.integrity && (o.integrity = i.integrity), i.referrerpolicy && (o.referrerPolicy = i.referrerpolicy), i.crossorigin === "use-credentials" ? o.credentials = "include" : i.crossorigin === "anonymous" ? o.credentials = "omit" : o.credentials = "same-origin", o;
    }
    function r(i) {
      if (i.ep)
        return;
      i.ep = true;
      const o = n(i);
      fetch(i.href, o);
    }
  })();
  var Ao = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
  function f_(t) {
    return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, "default") ? t.default : t;
  }
  var z = {
    exports: {}
  }, Ie = {};
  var qu = Symbol.for("react.element"), h_ = Symbol.for("react.portal"), d_ = Symbol.for("react.fragment"), p_ = Symbol.for("react.strict_mode"), m_ = Symbol.for("react.profiler"), g_ = Symbol.for("react.provider"), v_ = Symbol.for("react.context"), y_ = Symbol.for("react.forward_ref"), b_ = Symbol.for("react.suspense"), x_ = Symbol.for("react.memo"), S_ = Symbol.for("react.lazy"), uS = Symbol.iterator;
  function w_(t) {
    return t === null || typeof t != "object" ? null : (t = uS && t[uS] || t["@@iterator"], typeof t == "function" ? t : null);
  }
  var fM = {
    isMounted: function() {
      return false;
    },
    enqueueForceUpdate: function() {
    },
    enqueueReplaceState: function() {
    },
    enqueueSetState: function() {
    }
  }, hM = Object.assign, dM = {};
  function kl(t, e, n) {
    this.props = t, this.context = e, this.refs = dM, this.updater = n || fM;
  }
  kl.prototype.isReactComponent = {};
  kl.prototype.setState = function(t, e) {
    if (typeof t != "object" && typeof t != "function" && t != null)
      throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
    this.updater.enqueueSetState(this, t, e, "setState");
  };
  kl.prototype.forceUpdate = function(t) {
    this.updater.enqueueForceUpdate(this, t, "forceUpdate");
  };
  function pM() {
  }
  pM.prototype = kl.prototype;
  function _1(t, e, n) {
    this.props = t, this.context = e, this.refs = dM, this.updater = n || fM;
  }
  var D1 = _1.prototype = new pM();
  D1.constructor = _1;
  hM(D1, kl.prototype);
  D1.isPureReactComponent = true;
  var fS = Array.isArray, mM = Object.prototype.hasOwnProperty, I1 = {
    current: null
  }, gM = {
    key: true,
    ref: true,
    __self: true,
    __source: true
  };
  function vM(t, e, n) {
    var r, i = {}, o = null, s = null;
    if (e != null)
      for (r in e.ref !== void 0 && (s = e.ref), e.key !== void 0 && (o = "" + e.key), e)
        mM.call(e, r) && !gM.hasOwnProperty(r) && (i[r] = e[r]);
    var a = arguments.length - 2;
    if (a === 1)
      i.children = n;
    else if (1 < a) {
      for (var l = Array(a), c = 0; c < a; c++)
        l[c] = arguments[c + 2];
      i.children = l;
    }
    if (t && t.defaultProps)
      for (r in a = t.defaultProps, a)
        i[r] === void 0 && (i[r] = a[r]);
    return {
      $$typeof: qu,
      type: t,
      key: o,
      ref: s,
      props: i,
      _owner: I1.current
    };
  }
  function k_(t, e) {
    return {
      $$typeof: qu,
      type: t.type,
      key: e,
      ref: t.ref,
      props: t.props,
      _owner: t._owner
    };
  }
  function B1(t) {
    return typeof t == "object" && t !== null && t.$$typeof === qu;
  }
  function C_(t) {
    var e = {
      "=": "=0",
      ":": "=2"
    };
    return "$" + t.replace(/[=:]/g, function(n) {
      return e[n];
    });
  }
  var hS = /\/+/g;
  function Tg(t, e) {
    return typeof t == "object" && t !== null && t.key != null ? C_("" + t.key) : e.toString(36);
  }
  function Uh(t, e, n, r, i) {
    var o = typeof t;
    (o === "undefined" || o === "boolean") && (t = null);
    var s = false;
    if (t === null)
      s = true;
    else
      switch (o) {
        case "string":
        case "number":
          s = true;
          break;
        case "object":
          switch (t.$$typeof) {
            case qu:
            case h_:
              s = true;
          }
      }
    if (s)
      return s = t, i = i(s), t = r === "" ? "." + Tg(s, 0) : r, fS(i) ? (n = "", t != null && (n = t.replace(hS, "$&/") + "/"), Uh(i, e, n, "", function(c) {
        return c;
      })) : i != null && (B1(i) && (i = k_(i, n + (!i.key || s && s.key === i.key ? "" : ("" + i.key).replace(hS, "$&/") + "/") + t)), e.push(i)), 1;
    if (s = 0, r = r === "" ? "." : r + ":", fS(t))
      for (var a = 0; a < t.length; a++) {
        o = t[a];
        var l = r + Tg(o, a);
        s += Uh(o, e, n, l, i);
      }
    else if (l = w_(t), typeof l == "function")
      for (t = l.call(t), a = 0; !(o = t.next()).done; )
        o = o.value, l = r + Tg(o, a++), s += Uh(o, e, n, l, i);
    else if (o === "object")
      throw e = String(t), Error("Objects are not valid as a React child (found: " + (e === "[object Object]" ? "object with keys {" + Object.keys(t).join(", ") + "}" : e) + "). If you meant to render a collection of children, use an array instead.");
    return s;
  }
  function jf(t, e, n) {
    if (t == null)
      return t;
    var r = [], i = 0;
    return Uh(t, r, "", "", function(o) {
      return e.call(n, o, i++);
    }), r;
  }
  function T_(t) {
    if (t._status === -1) {
      var e = t._result;
      e = e(), e.then(function(n) {
        (t._status === 0 || t._status === -1) && (t._status = 1, t._result = n);
      }, function(n) {
        (t._status === 0 || t._status === -1) && (t._status = 2, t._result = n);
      }), t._status === -1 && (t._status = 0, t._result = e);
    }
    if (t._status === 1)
      return t._result.default;
    throw t._result;
  }
  var Mn = {
    current: null
  }, Kh = {
    transition: null
  }, M_ = {
    ReactCurrentDispatcher: Mn,
    ReactCurrentBatchConfig: Kh,
    ReactCurrentOwner: I1
  };
  Ie.Children = {
    map: jf,
    forEach: function(t, e, n) {
      jf(t, function() {
        e.apply(this, arguments);
      }, n);
    },
    count: function(t) {
      var e = 0;
      return jf(t, function() {
        e++;
      }), e;
    },
    toArray: function(t) {
      return jf(t, function(e) {
        return e;
      }) || [];
    },
    only: function(t) {
      if (!B1(t))
        throw Error("React.Children.only expected to receive a single React element child.");
      return t;
    }
  };
  Ie.Component = kl;
  Ie.Fragment = d_;
  Ie.Profiler = m_;
  Ie.PureComponent = _1;
  Ie.StrictMode = p_;
  Ie.Suspense = b_;
  Ie.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = M_;
  Ie.cloneElement = function(t, e, n) {
    if (t == null)
      throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + t + ".");
    var r = hM({}, t.props), i = t.key, o = t.ref, s = t._owner;
    if (e != null) {
      if (e.ref !== void 0 && (o = e.ref, s = I1.current), e.key !== void 0 && (i = "" + e.key), t.type && t.type.defaultProps)
        var a = t.type.defaultProps;
      for (l in e)
        mM.call(e, l) && !gM.hasOwnProperty(l) && (r[l] = e[l] === void 0 && a !== void 0 ? a[l] : e[l]);
    }
    var l = arguments.length - 2;
    if (l === 1)
      r.children = n;
    else if (1 < l) {
      a = Array(l);
      for (var c = 0; c < l; c++)
        a[c] = arguments[c + 2];
      r.children = a;
    }
    return {
      $$typeof: qu,
      type: t.type,
      key: i,
      ref: o,
      props: r,
      _owner: s
    };
  };
  Ie.createContext = function(t) {
    return t = {
      $$typeof: v_,
      _currentValue: t,
      _currentValue2: t,
      _threadCount: 0,
      Provider: null,
      Consumer: null,
      _defaultValue: null,
      _globalName: null
    }, t.Provider = {
      $$typeof: g_,
      _context: t
    }, t.Consumer = t;
  };
  Ie.createElement = vM;
  Ie.createFactory = function(t) {
    var e = vM.bind(null, t);
    return e.type = t, e;
  };
  Ie.createRef = function() {
    return {
      current: null
    };
  };
  Ie.forwardRef = function(t) {
    return {
      $$typeof: y_,
      render: t
    };
  };
  Ie.isValidElement = B1;
  Ie.lazy = function(t) {
    return {
      $$typeof: S_,
      _payload: {
        _status: -1,
        _result: t
      },
      _init: T_
    };
  };
  Ie.memo = function(t, e) {
    return {
      $$typeof: x_,
      type: t,
      compare: e === void 0 ? null : e
    };
  };
  Ie.startTransition = function(t) {
    var e = Kh.transition;
    Kh.transition = {};
    try {
      t();
    } finally {
      Kh.transition = e;
    }
  };
  Ie.unstable_act = function() {
    throw Error("act(...) is not supported in production builds of React.");
  };
  Ie.useCallback = function(t, e) {
    return Mn.current.useCallback(t, e);
  };
  Ie.useContext = function(t) {
    return Mn.current.useContext(t);
  };
  Ie.useDebugValue = function() {
  };
  Ie.useDeferredValue = function(t) {
    return Mn.current.useDeferredValue(t);
  };
  Ie.useEffect = function(t, e) {
    return Mn.current.useEffect(t, e);
  };
  Ie.useId = function() {
    return Mn.current.useId();
  };
  Ie.useImperativeHandle = function(t, e, n) {
    return Mn.current.useImperativeHandle(t, e, n);
  };
  Ie.useInsertionEffect = function(t, e) {
    return Mn.current.useInsertionEffect(t, e);
  };
  Ie.useLayoutEffect = function(t, e) {
    return Mn.current.useLayoutEffect(t, e);
  };
  Ie.useMemo = function(t, e) {
    return Mn.current.useMemo(t, e);
  };
  Ie.useReducer = function(t, e, n) {
    return Mn.current.useReducer(t, e, n);
  };
  Ie.useRef = function(t) {
    return Mn.current.useRef(t);
  };
  Ie.useState = function(t) {
    return Mn.current.useState(t);
  };
  Ie.useSyncExternalStore = function(t, e, n) {
    return Mn.current.useSyncExternalStore(t, e, n);
  };
  Ie.useTransition = function() {
    return Mn.current.useTransition();
  };
  Ie.version = "18.2.0";
  (function(t) {
    t.exports = Ie;
  })(z);
  const jp = f_(z.exports), dS = u_({
    __proto__: null,
    default: jp
  }, [
    z.exports
  ]);
  var ov = {}, Wp = {
    exports: {}
  }, Zn = {}, yM = {
    exports: {}
  }, bM = {};
  (function(t) {
    function e(V, oe) {
      var de = V.length;
      V.push(oe);
      e:
        for (; 0 < de; ) {
          var Se = de - 1 >>> 1, ve = V[Se];
          if (0 < i(ve, oe))
            V[Se] = oe, V[de] = ve, de = Se;
          else
            break e;
        }
    }
    function n(V) {
      return V.length === 0 ? null : V[0];
    }
    function r(V) {
      if (V.length === 0)
        return null;
      var oe = V[0], de = V.pop();
      if (de !== oe) {
        V[0] = de;
        e:
          for (var Se = 0, ve = V.length, le = ve >>> 1; Se < le; ) {
            var re = 2 * (Se + 1) - 1, se = V[re], _e2 = re + 1, yt = V[_e2];
            if (0 > i(se, de))
              _e2 < ve && 0 > i(yt, se) ? (V[Se] = yt, V[_e2] = de, Se = _e2) : (V[Se] = se, V[re] = de, Se = re);
            else if (_e2 < ve && 0 > i(yt, de))
              V[Se] = yt, V[_e2] = de, Se = _e2;
            else
              break e;
          }
      }
      return oe;
    }
    function i(V, oe) {
      var de = V.sortIndex - oe.sortIndex;
      return de !== 0 ? de : V.id - oe.id;
    }
    if (typeof performance == "object" && typeof performance.now == "function") {
      var o = performance;
      t.unstable_now = function() {
        return o.now();
      };
    } else {
      var s = Date, a = s.now();
      t.unstable_now = function() {
        return s.now() - a;
      };
    }
    var l = [], c = [], u = 1, h = null, p = 3, v = false, y = false, x = false, T = typeof setTimeout == "function" ? setTimeout : null, w = typeof clearTimeout == "function" ? clearTimeout : null, k = typeof setImmediate < "u" ? setImmediate : null;
    typeof navigator < "u" && navigator.scheduling !== void 0 && navigator.scheduling.isInputPending !== void 0 && navigator.scheduling.isInputPending.bind(navigator.scheduling);
    function C(V) {
      for (var oe = n(c); oe !== null; ) {
        if (oe.callback === null)
          r(c);
        else if (oe.startTime <= V)
          r(c), oe.sortIndex = oe.expirationTime, e(l, oe);
        else
          break;
        oe = n(c);
      }
    }
    function P(V) {
      if (x = false, C(V), !y)
        if (n(l) !== null)
          y = true, Re(R);
        else {
          var oe = n(c);
          oe !== null && ee(P, oe.startTime - V);
        }
    }
    function R(V, oe) {
      y = false, x && (x = false, w(F), F = -1), v = true;
      var de = p;
      try {
        for (C(oe), h = n(l); h !== null && (!(h.expirationTime > oe) || V && !te()); ) {
          var Se = h.callback;
          if (typeof Se == "function") {
            h.callback = null, p = h.priorityLevel;
            var ve = Se(h.expirationTime <= oe);
            oe = t.unstable_now(), typeof ve == "function" ? h.callback = ve : h === n(l) && r(l), C(oe);
          } else
            r(l);
          h = n(l);
        }
        if (h !== null)
          var le = true;
        else {
          var re = n(c);
          re !== null && ee(P, re.startTime - oe), le = false;
        }
        return le;
      } finally {
        h = null, p = de, v = false;
      }
    }
    var L = false, _ = null, F = -1, K = 5, Y = -1;
    function te() {
      return !(t.unstable_now() - Y < K);
    }
    function ne() {
      if (_ !== null) {
        var V = t.unstable_now();
        Y = V;
        var oe = true;
        try {
          oe = _(true, V);
        } finally {
          oe ? ae() : (L = false, _ = null);
        }
      } else
        L = false;
    }
    var ae;
    if (typeof k == "function")
      ae = function() {
        k(ne);
      };
    else if (typeof MessageChannel < "u") {
      var ye = new MessageChannel(), Ce = ye.port2;
      ye.port1.onmessage = ne, ae = function() {
        Ce.postMessage(null);
      };
    } else
      ae = function() {
        T(ne, 0);
      };
    function Re(V) {
      _ = V, L || (L = true, ae());
    }
    function ee(V, oe) {
      F = T(function() {
        V(t.unstable_now());
      }, oe);
    }
    t.unstable_IdlePriority = 5, t.unstable_ImmediatePriority = 1, t.unstable_LowPriority = 4, t.unstable_NormalPriority = 3, t.unstable_Profiling = null, t.unstable_UserBlockingPriority = 2, t.unstable_cancelCallback = function(V) {
      V.callback = null;
    }, t.unstable_continueExecution = function() {
      y || v || (y = true, Re(R));
    }, t.unstable_forceFrameRate = function(V) {
      0 > V || 125 < V ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : K = 0 < V ? Math.floor(1e3 / V) : 5;
    }, t.unstable_getCurrentPriorityLevel = function() {
      return p;
    }, t.unstable_getFirstCallbackNode = function() {
      return n(l);
    }, t.unstable_next = function(V) {
      switch (p) {
        case 1:
        case 2:
        case 3:
          var oe = 3;
          break;
        default:
          oe = p;
      }
      var de = p;
      p = oe;
      try {
        return V();
      } finally {
        p = de;
      }
    }, t.unstable_pauseExecution = function() {
    }, t.unstable_requestPaint = function() {
    }, t.unstable_runWithPriority = function(V, oe) {
      switch (V) {
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
          break;
        default:
          V = 3;
      }
      var de = p;
      p = V;
      try {
        return oe();
      } finally {
        p = de;
      }
    }, t.unstable_scheduleCallback = function(V, oe, de) {
      var Se = t.unstable_now();
      switch (typeof de == "object" && de !== null ? (de = de.delay, de = typeof de == "number" && 0 < de ? Se + de : Se) : de = Se, V) {
        case 1:
          var ve = -1;
          break;
        case 2:
          ve = 250;
          break;
        case 5:
          ve = 1073741823;
          break;
        case 4:
          ve = 1e4;
          break;
        default:
          ve = 5e3;
      }
      return ve = de + ve, V = {
        id: u++,
        callback: oe,
        priorityLevel: V,
        startTime: de,
        expirationTime: ve,
        sortIndex: -1
      }, de > Se ? (V.sortIndex = de, e(c, V), n(l) === null && V === n(c) && (x ? (w(F), F = -1) : x = true, ee(P, de - Se))) : (V.sortIndex = ve, e(l, V), y || v || (y = true, Re(R))), V;
    }, t.unstable_shouldYield = te, t.unstable_wrapCallback = function(V) {
      var oe = p;
      return function() {
        var de = p;
        p = oe;
        try {
          return V.apply(this, arguments);
        } finally {
          p = de;
        }
      };
    };
  })(bM);
  (function(t) {
    t.exports = bM;
  })(yM);
  var xM = z.exports, Jn = yM.exports;
  function Z(t) {
    for (var e = "https://reactjs.org/docs/error-decoder.html?invariant=" + t, n = 1; n < arguments.length; n++)
      e += "&args[]=" + encodeURIComponent(arguments[n]);
    return "Minified React error #" + t + "; visit " + e + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
  }
  var SM = /* @__PURE__ */ new Set(), ru = {};
  function Xs(t, e) {
    el(t, e), el(t + "Capture", e);
  }
  function el(t, e) {
    for (ru[t] = e, t = 0; t < e.length; t++)
      SM.add(e[t]);
  }
  var Gi = !(typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u"), sv = Object.prototype.hasOwnProperty, A_ = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/, pS = {}, mS = {};
  function E_(t) {
    return sv.call(mS, t) ? true : sv.call(pS, t) ? false : A_.test(t) ? mS[t] = true : (pS[t] = true, false);
  }
  function P_(t, e, n, r) {
    if (n !== null && n.type === 0)
      return false;
    switch (typeof e) {
      case "function":
      case "symbol":
        return true;
      case "boolean":
        return r ? false : n !== null ? !n.acceptsBooleans : (t = t.toLowerCase().slice(0, 5), t !== "data-" && t !== "aria-");
      default:
        return false;
    }
  }
  function O_(t, e, n, r) {
    if (e === null || typeof e > "u" || P_(t, e, n, r))
      return true;
    if (r)
      return false;
    if (n !== null)
      switch (n.type) {
        case 3:
          return !e;
        case 4:
          return e === false;
        case 5:
          return isNaN(e);
        case 6:
          return isNaN(e) || 1 > e;
      }
    return false;
  }
  function An(t, e, n, r, i, o, s) {
    this.acceptsBooleans = e === 2 || e === 3 || e === 4, this.attributeName = r, this.attributeNamespace = i, this.mustUseProperty = n, this.propertyName = t, this.type = e, this.sanitizeURL = o, this.removeEmptyString = s;
  }
  var nn = {};
  "children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(t) {
    nn[t] = new An(t, 0, false, t, null, false, false);
  });
  [
    [
      "acceptCharset",
      "accept-charset"
    ],
    [
      "className",
      "class"
    ],
    [
      "htmlFor",
      "for"
    ],
    [
      "httpEquiv",
      "http-equiv"
    ]
  ].forEach(function(t) {
    var e = t[0];
    nn[e] = new An(e, 1, false, t[1], null, false, false);
  });
  [
    "contentEditable",
    "draggable",
    "spellCheck",
    "value"
  ].forEach(function(t) {
    nn[t] = new An(t, 2, false, t.toLowerCase(), null, false, false);
  });
  [
    "autoReverse",
    "externalResourcesRequired",
    "focusable",
    "preserveAlpha"
  ].forEach(function(t) {
    nn[t] = new An(t, 2, false, t, null, false, false);
  });
  "allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(t) {
    nn[t] = new An(t, 3, false, t.toLowerCase(), null, false, false);
  });
  [
    "checked",
    "multiple",
    "muted",
    "selected"
  ].forEach(function(t) {
    nn[t] = new An(t, 3, true, t, null, false, false);
  });
  [
    "capture",
    "download"
  ].forEach(function(t) {
    nn[t] = new An(t, 4, false, t, null, false, false);
  });
  [
    "cols",
    "rows",
    "size",
    "span"
  ].forEach(function(t) {
    nn[t] = new An(t, 6, false, t, null, false, false);
  });
  [
    "rowSpan",
    "start"
  ].forEach(function(t) {
    nn[t] = new An(t, 5, false, t.toLowerCase(), null, false, false);
  });
  var N1 = /[\-:]([a-z])/g;
  function $1(t) {
    return t[1].toUpperCase();
  }
  "accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(t) {
    var e = t.replace(N1, $1);
    nn[e] = new An(e, 1, false, t, null, false, false);
  });
  "xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(t) {
    var e = t.replace(N1, $1);
    nn[e] = new An(e, 1, false, t, "http://www.w3.org/1999/xlink", false, false);
  });
  [
    "xml:base",
    "xml:lang",
    "xml:space"
  ].forEach(function(t) {
    var e = t.replace(N1, $1);
    nn[e] = new An(e, 1, false, t, "http://www.w3.org/XML/1998/namespace", false, false);
  });
  [
    "tabIndex",
    "crossOrigin"
  ].forEach(function(t) {
    nn[t] = new An(t, 1, false, t.toLowerCase(), null, false, false);
  });
  nn.xlinkHref = new An("xlinkHref", 1, false, "xlink:href", "http://www.w3.org/1999/xlink", true, false);
  [
    "src",
    "href",
    "action",
    "formAction"
  ].forEach(function(t) {
    nn[t] = new An(t, 1, false, t.toLowerCase(), null, true, true);
  });
  function z1(t, e, n, r) {
    var i = nn.hasOwnProperty(e) ? nn[e] : null;
    (i !== null ? i.type !== 0 : r || !(2 < e.length) || e[0] !== "o" && e[0] !== "O" || e[1] !== "n" && e[1] !== "N") && (O_(e, n, i, r) && (n = null), r || i === null ? E_(e) && (n === null ? t.removeAttribute(e) : t.setAttribute(e, "" + n)) : i.mustUseProperty ? t[i.propertyName] = n === null ? i.type === 3 ? false : "" : n : (e = i.attributeName, r = i.attributeNamespace, n === null ? t.removeAttribute(e) : (i = i.type, n = i === 3 || i === 4 && n === true ? "" : "" + n, r ? t.setAttributeNS(r, e, n) : t.setAttribute(e, n))));
  }
  var io = xM.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, Wf = Symbol.for("react.element"), da = Symbol.for("react.portal"), pa = Symbol.for("react.fragment"), F1 = Symbol.for("react.strict_mode"), av = Symbol.for("react.profiler"), wM = Symbol.for("react.provider"), kM = Symbol.for("react.context"), V1 = Symbol.for("react.forward_ref"), lv = Symbol.for("react.suspense"), cv = Symbol.for("react.suspense_list"), H1 = Symbol.for("react.memo"), yo = Symbol.for("react.lazy"), CM = Symbol.for("react.offscreen"), gS = Symbol.iterator;
  function Ul(t) {
    return t === null || typeof t != "object" ? null : (t = gS && t[gS] || t["@@iterator"], typeof t == "function" ? t : null);
  }
  var vt = Object.assign, Mg;
  function fc(t) {
    if (Mg === void 0)
      try {
        throw Error();
      } catch (n) {
        var e = n.stack.trim().match(/\n( *(at )?)/);
        Mg = e && e[1] || "";
      }
    return `
` + Mg + t;
  }
  var Ag = false;
  function Eg(t, e) {
    if (!t || Ag)
      return "";
    Ag = true;
    var n = Error.prepareStackTrace;
    Error.prepareStackTrace = void 0;
    try {
      if (e)
        if (e = function() {
          throw Error();
        }, Object.defineProperty(e.prototype, "props", {
          set: function() {
            throw Error();
          }
        }), typeof Reflect == "object" && Reflect.construct) {
          try {
            Reflect.construct(e, []);
          } catch (c) {
            var r = c;
          }
          Reflect.construct(t, [], e);
        } else {
          try {
            e.call();
          } catch (c) {
            r = c;
          }
          t.call(e.prototype);
        }
      else {
        try {
          throw Error();
        } catch (c) {
          r = c;
        }
        t();
      }
    } catch (c) {
      if (c && r && typeof c.stack == "string") {
        for (var i = c.stack.split(`
`), o = r.stack.split(`
`), s = i.length - 1, a = o.length - 1; 1 <= s && 0 <= a && i[s] !== o[a]; )
          a--;
        for (; 1 <= s && 0 <= a; s--, a--)
          if (i[s] !== o[a]) {
            if (s !== 1 || a !== 1)
              do
                if (s--, a--, 0 > a || i[s] !== o[a]) {
                  var l = `
` + i[s].replace(" at new ", " at ");
                  return t.displayName && l.includes("<anonymous>") && (l = l.replace("<anonymous>", t.displayName)), l;
                }
              while (1 <= s && 0 <= a);
            break;
          }
      }
    } finally {
      Ag = false, Error.prepareStackTrace = n;
    }
    return (t = t ? t.displayName || t.name : "") ? fc(t) : "";
  }
  function R_(t) {
    switch (t.tag) {
      case 5:
        return fc(t.type);
      case 16:
        return fc("Lazy");
      case 13:
        return fc("Suspense");
      case 19:
        return fc("SuspenseList");
      case 0:
      case 2:
      case 15:
        return t = Eg(t.type, false), t;
      case 11:
        return t = Eg(t.type.render, false), t;
      case 1:
        return t = Eg(t.type, true), t;
      default:
        return "";
    }
  }
  function uv(t) {
    if (t == null)
      return null;
    if (typeof t == "function")
      return t.displayName || t.name || null;
    if (typeof t == "string")
      return t;
    switch (t) {
      case pa:
        return "Fragment";
      case da:
        return "Portal";
      case av:
        return "Profiler";
      case F1:
        return "StrictMode";
      case lv:
        return "Suspense";
      case cv:
        return "SuspenseList";
    }
    if (typeof t == "object")
      switch (t.$$typeof) {
        case kM:
          return (t.displayName || "Context") + ".Consumer";
        case wM:
          return (t._context.displayName || "Context") + ".Provider";
        case V1:
          var e = t.render;
          return t = t.displayName, t || (t = e.displayName || e.name || "", t = t !== "" ? "ForwardRef(" + t + ")" : "ForwardRef"), t;
        case H1:
          return e = t.displayName || null, e !== null ? e : uv(t.type) || "Memo";
        case yo:
          e = t._payload, t = t._init;
          try {
            return uv(t(e));
          } catch {
          }
      }
    return null;
  }
  function L_(t) {
    var e = t.type;
    switch (t.tag) {
      case 24:
        return "Cache";
      case 9:
        return (e.displayName || "Context") + ".Consumer";
      case 10:
        return (e._context.displayName || "Context") + ".Provider";
      case 18:
        return "DehydratedFragment";
      case 11:
        return t = e.render, t = t.displayName || t.name || "", e.displayName || (t !== "" ? "ForwardRef(" + t + ")" : "ForwardRef");
      case 7:
        return "Fragment";
      case 5:
        return e;
      case 4:
        return "Portal";
      case 3:
        return "Root";
      case 6:
        return "Text";
      case 16:
        return uv(e);
      case 8:
        return e === F1 ? "StrictMode" : "Mode";
      case 22:
        return "Offscreen";
      case 12:
        return "Profiler";
      case 21:
        return "Scope";
      case 13:
        return "Suspense";
      case 19:
        return "SuspenseList";
      case 25:
        return "TracingMarker";
      case 1:
      case 0:
      case 17:
      case 2:
      case 14:
      case 15:
        if (typeof e == "function")
          return e.displayName || e.name || null;
        if (typeof e == "string")
          return e;
    }
    return null;
  }
  function Uo(t) {
    switch (typeof t) {
      case "boolean":
      case "number":
      case "string":
      case "undefined":
        return t;
      case "object":
        return t;
      default:
        return "";
    }
  }
  function TM(t) {
    var e = t.type;
    return (t = t.nodeName) && t.toLowerCase() === "input" && (e === "checkbox" || e === "radio");
  }
  function __(t) {
    var e = TM(t) ? "checked" : "value", n = Object.getOwnPropertyDescriptor(t.constructor.prototype, e), r = "" + t[e];
    if (!t.hasOwnProperty(e) && typeof n < "u" && typeof n.get == "function" && typeof n.set == "function") {
      var i = n.get, o = n.set;
      return Object.defineProperty(t, e, {
        configurable: true,
        get: function() {
          return i.call(this);
        },
        set: function(s) {
          r = "" + s, o.call(this, s);
        }
      }), Object.defineProperty(t, e, {
        enumerable: n.enumerable
      }), {
        getValue: function() {
          return r;
        },
        setValue: function(s) {
          r = "" + s;
        },
        stopTracking: function() {
          t._valueTracker = null, delete t[e];
        }
      };
    }
  }
  function Uf(t) {
    t._valueTracker || (t._valueTracker = __(t));
  }
  function MM(t) {
    if (!t)
      return false;
    var e = t._valueTracker;
    if (!e)
      return true;
    var n = e.getValue(), r = "";
    return t && (r = TM(t) ? t.checked ? "true" : "false" : t.value), t = r, t !== n ? (e.setValue(t), true) : false;
  }
  function Ld(t) {
    if (t = t || (typeof document < "u" ? document : void 0), typeof t > "u")
      return null;
    try {
      return t.activeElement || t.body;
    } catch {
      return t.body;
    }
  }
  function fv(t, e) {
    var n = e.checked;
    return vt({}, e, {
      defaultChecked: void 0,
      defaultValue: void 0,
      value: void 0,
      checked: n ?? t._wrapperState.initialChecked
    });
  }
  function vS(t, e) {
    var n = e.defaultValue == null ? "" : e.defaultValue, r = e.checked != null ? e.checked : e.defaultChecked;
    n = Uo(e.value != null ? e.value : n), t._wrapperState = {
      initialChecked: r,
      initialValue: n,
      controlled: e.type === "checkbox" || e.type === "radio" ? e.checked != null : e.value != null
    };
  }
  function AM(t, e) {
    e = e.checked, e != null && z1(t, "checked", e, false);
  }
  function hv(t, e) {
    AM(t, e);
    var n = Uo(e.value), r = e.type;
    if (n != null)
      r === "number" ? (n === 0 && t.value === "" || t.value != n) && (t.value = "" + n) : t.value !== "" + n && (t.value = "" + n);
    else if (r === "submit" || r === "reset") {
      t.removeAttribute("value");
      return;
    }
    e.hasOwnProperty("value") ? dv(t, e.type, n) : e.hasOwnProperty("defaultValue") && dv(t, e.type, Uo(e.defaultValue)), e.checked == null && e.defaultChecked != null && (t.defaultChecked = !!e.defaultChecked);
  }
  function yS(t, e, n) {
    if (e.hasOwnProperty("value") || e.hasOwnProperty("defaultValue")) {
      var r = e.type;
      if (!(r !== "submit" && r !== "reset" || e.value !== void 0 && e.value !== null))
        return;
      e = "" + t._wrapperState.initialValue, n || e === t.value || (t.value = e), t.defaultValue = e;
    }
    n = t.name, n !== "" && (t.name = ""), t.defaultChecked = !!t._wrapperState.initialChecked, n !== "" && (t.name = n);
  }
  function dv(t, e, n) {
    (e !== "number" || Ld(t.ownerDocument) !== t) && (n == null ? t.defaultValue = "" + t._wrapperState.initialValue : t.defaultValue !== "" + n && (t.defaultValue = "" + n));
  }
  var hc = Array.isArray;
  function Ba(t, e, n, r) {
    if (t = t.options, e) {
      e = {};
      for (var i = 0; i < n.length; i++)
        e["$" + n[i]] = true;
      for (n = 0; n < t.length; n++)
        i = e.hasOwnProperty("$" + t[n].value), t[n].selected !== i && (t[n].selected = i), i && r && (t[n].defaultSelected = true);
    } else {
      for (n = "" + Uo(n), e = null, i = 0; i < t.length; i++) {
        if (t[i].value === n) {
          t[i].selected = true, r && (t[i].defaultSelected = true);
          return;
        }
        e !== null || t[i].disabled || (e = t[i]);
      }
      e !== null && (e.selected = true);
    }
  }
  function pv(t, e) {
    if (e.dangerouslySetInnerHTML != null)
      throw Error(Z(91));
    return vt({}, e, {
      value: void 0,
      defaultValue: void 0,
      children: "" + t._wrapperState.initialValue
    });
  }
  function bS(t, e) {
    var n = e.value;
    if (n == null) {
      if (n = e.children, e = e.defaultValue, n != null) {
        if (e != null)
          throw Error(Z(92));
        if (hc(n)) {
          if (1 < n.length)
            throw Error(Z(93));
          n = n[0];
        }
        e = n;
      }
      e == null && (e = ""), n = e;
    }
    t._wrapperState = {
      initialValue: Uo(n)
    };
  }
  function EM(t, e) {
    var n = Uo(e.value), r = Uo(e.defaultValue);
    n != null && (n = "" + n, n !== t.value && (t.value = n), e.defaultValue == null && t.defaultValue !== n && (t.defaultValue = n)), r != null && (t.defaultValue = "" + r);
  }
  function xS(t) {
    var e = t.textContent;
    e === t._wrapperState.initialValue && e !== "" && e !== null && (t.value = e);
  }
  function PM(t) {
    switch (t) {
      case "svg":
        return "http://www.w3.org/2000/svg";
      case "math":
        return "http://www.w3.org/1998/Math/MathML";
      default:
        return "http://www.w3.org/1999/xhtml";
    }
  }
  function mv(t, e) {
    return t == null || t === "http://www.w3.org/1999/xhtml" ? PM(e) : t === "http://www.w3.org/2000/svg" && e === "foreignObject" ? "http://www.w3.org/1999/xhtml" : t;
  }
  var Kf, OM = function(t) {
    return typeof MSApp < "u" && MSApp.execUnsafeLocalFunction ? function(e, n, r, i) {
      MSApp.execUnsafeLocalFunction(function() {
        return t(e, n, r, i);
      });
    } : t;
  }(function(t, e) {
    if (t.namespaceURI !== "http://www.w3.org/2000/svg" || "innerHTML" in t)
      t.innerHTML = e;
    else {
      for (Kf = Kf || document.createElement("div"), Kf.innerHTML = "<svg>" + e.valueOf().toString() + "</svg>", e = Kf.firstChild; t.firstChild; )
        t.removeChild(t.firstChild);
      for (; e.firstChild; )
        t.appendChild(e.firstChild);
    }
  });
  function iu(t, e) {
    if (e) {
      var n = t.firstChild;
      if (n && n === t.lastChild && n.nodeType === 3) {
        n.nodeValue = e;
        return;
      }
    }
    t.textContent = e;
  }
  var Mc = {
    animationIterationCount: true,
    aspectRatio: true,
    borderImageOutset: true,
    borderImageSlice: true,
    borderImageWidth: true,
    boxFlex: true,
    boxFlexGroup: true,
    boxOrdinalGroup: true,
    columnCount: true,
    columns: true,
    flex: true,
    flexGrow: true,
    flexPositive: true,
    flexShrink: true,
    flexNegative: true,
    flexOrder: true,
    gridArea: true,
    gridRow: true,
    gridRowEnd: true,
    gridRowSpan: true,
    gridRowStart: true,
    gridColumn: true,
    gridColumnEnd: true,
    gridColumnSpan: true,
    gridColumnStart: true,
    fontWeight: true,
    lineClamp: true,
    lineHeight: true,
    opacity: true,
    order: true,
    orphans: true,
    tabSize: true,
    widows: true,
    zIndex: true,
    zoom: true,
    fillOpacity: true,
    floodOpacity: true,
    stopOpacity: true,
    strokeDasharray: true,
    strokeDashoffset: true,
    strokeMiterlimit: true,
    strokeOpacity: true,
    strokeWidth: true
  }, D_ = [
    "Webkit",
    "ms",
    "Moz",
    "O"
  ];
  Object.keys(Mc).forEach(function(t) {
    D_.forEach(function(e) {
      e = e + t.charAt(0).toUpperCase() + t.substring(1), Mc[e] = Mc[t];
    });
  });
  function RM(t, e, n) {
    return e == null || typeof e == "boolean" || e === "" ? "" : n || typeof e != "number" || e === 0 || Mc.hasOwnProperty(t) && Mc[t] ? ("" + e).trim() : e + "px";
  }
  function LM(t, e) {
    t = t.style;
    for (var n in e)
      if (e.hasOwnProperty(n)) {
        var r = n.indexOf("--") === 0, i = RM(n, e[n], r);
        n === "float" && (n = "cssFloat"), r ? t.setProperty(n, i) : t[n] = i;
      }
  }
  var I_ = vt({
    menuitem: true
  }, {
    area: true,
    base: true,
    br: true,
    col: true,
    embed: true,
    hr: true,
    img: true,
    input: true,
    keygen: true,
    link: true,
    meta: true,
    param: true,
    source: true,
    track: true,
    wbr: true
  });
  function gv(t, e) {
    if (e) {
      if (I_[t] && (e.children != null || e.dangerouslySetInnerHTML != null))
        throw Error(Z(137, t));
      if (e.dangerouslySetInnerHTML != null) {
        if (e.children != null)
          throw Error(Z(60));
        if (typeof e.dangerouslySetInnerHTML != "object" || !("__html" in e.dangerouslySetInnerHTML))
          throw Error(Z(61));
      }
      if (e.style != null && typeof e.style != "object")
        throw Error(Z(62));
    }
  }
  function vv(t, e) {
    if (t.indexOf("-") === -1)
      return typeof e.is == "string";
    switch (t) {
      case "annotation-xml":
      case "color-profile":
      case "font-face":
      case "font-face-src":
      case "font-face-uri":
      case "font-face-format":
      case "font-face-name":
      case "missing-glyph":
        return false;
      default:
        return true;
    }
  }
  var yv = null;
  function j1(t) {
    return t = t.target || t.srcElement || window, t.correspondingUseElement && (t = t.correspondingUseElement), t.nodeType === 3 ? t.parentNode : t;
  }
  var bv = null, Na = null, $a = null;
  function SS(t) {
    if (t = Xu(t)) {
      if (typeof bv != "function")
        throw Error(Z(280));
      var e = t.stateNode;
      e && (e = Yp(e), bv(t.stateNode, t.type, e));
    }
  }
  function _M(t) {
    Na ? $a ? $a.push(t) : $a = [
      t
    ] : Na = t;
  }
  function DM() {
    if (Na) {
      var t = Na, e = $a;
      if ($a = Na = null, SS(t), e)
        for (t = 0; t < e.length; t++)
          SS(e[t]);
    }
  }
  function IM(t, e) {
    return t(e);
  }
  function BM() {
  }
  var Pg = false;
  function NM(t, e, n) {
    if (Pg)
      return t(e, n);
    Pg = true;
    try {
      return IM(t, e, n);
    } finally {
      Pg = false, (Na !== null || $a !== null) && (BM(), DM());
    }
  }
  function ou(t, e) {
    var n = t.stateNode;
    if (n === null)
      return null;
    var r = Yp(n);
    if (r === null)
      return null;
    n = r[e];
    e:
      switch (e) {
        case "onClick":
        case "onClickCapture":
        case "onDoubleClick":
        case "onDoubleClickCapture":
        case "onMouseDown":
        case "onMouseDownCapture":
        case "onMouseMove":
        case "onMouseMoveCapture":
        case "onMouseUp":
        case "onMouseUpCapture":
        case "onMouseEnter":
          (r = !r.disabled) || (t = t.type, r = !(t === "button" || t === "input" || t === "select" || t === "textarea")), t = !r;
          break e;
        default:
          t = false;
      }
    if (t)
      return null;
    if (n && typeof n != "function")
      throw Error(Z(231, e, typeof n));
    return n;
  }
  var xv = false;
  if (Gi)
    try {
      var Kl = {};
      Object.defineProperty(Kl, "passive", {
        get: function() {
          xv = true;
        }
      }), window.addEventListener("test", Kl, Kl), window.removeEventListener("test", Kl, Kl);
    } catch {
      xv = false;
    }
  function B_(t, e, n, r, i, o, s, a, l) {
    var c = Array.prototype.slice.call(arguments, 3);
    try {
      e.apply(n, c);
    } catch (u) {
      this.onError(u);
    }
  }
  var Ac = false, _d = null, Dd = false, Sv = null, N_ = {
    onError: function(t) {
      Ac = true, _d = t;
    }
  };
  function $_(t, e, n, r, i, o, s, a, l) {
    Ac = false, _d = null, B_.apply(N_, arguments);
  }
  function z_(t, e, n, r, i, o, s, a, l) {
    if ($_.apply(this, arguments), Ac) {
      if (Ac) {
        var c = _d;
        Ac = false, _d = null;
      } else
        throw Error(Z(198));
      Dd || (Dd = true, Sv = c);
    }
  }
  function Qs(t) {
    var e = t, n = t;
    if (t.alternate)
      for (; e.return; )
        e = e.return;
    else {
      t = e;
      do
        e = t, (e.flags & 4098) !== 0 && (n = e.return), t = e.return;
      while (t);
    }
    return e.tag === 3 ? n : null;
  }
  function $M(t) {
    if (t.tag === 13) {
      var e = t.memoizedState;
      if (e === null && (t = t.alternate, t !== null && (e = t.memoizedState)), e !== null)
        return e.dehydrated;
    }
    return null;
  }
  function wS(t) {
    if (Qs(t) !== t)
      throw Error(Z(188));
  }
  function F_(t) {
    var e = t.alternate;
    if (!e) {
      if (e = Qs(t), e === null)
        throw Error(Z(188));
      return e !== t ? null : t;
    }
    for (var n = t, r = e; ; ) {
      var i = n.return;
      if (i === null)
        break;
      var o = i.alternate;
      if (o === null) {
        if (r = i.return, r !== null) {
          n = r;
          continue;
        }
        break;
      }
      if (i.child === o.child) {
        for (o = i.child; o; ) {
          if (o === n)
            return wS(i), t;
          if (o === r)
            return wS(i), e;
          o = o.sibling;
        }
        throw Error(Z(188));
      }
      if (n.return !== r.return)
        n = i, r = o;
      else {
        for (var s = false, a = i.child; a; ) {
          if (a === n) {
            s = true, n = i, r = o;
            break;
          }
          if (a === r) {
            s = true, r = i, n = o;
            break;
          }
          a = a.sibling;
        }
        if (!s) {
          for (a = o.child; a; ) {
            if (a === n) {
              s = true, n = o, r = i;
              break;
            }
            if (a === r) {
              s = true, r = o, n = i;
              break;
            }
            a = a.sibling;
          }
          if (!s)
            throw Error(Z(189));
        }
      }
      if (n.alternate !== r)
        throw Error(Z(190));
    }
    if (n.tag !== 3)
      throw Error(Z(188));
    return n.stateNode.current === n ? t : e;
  }
  function zM(t) {
    return t = F_(t), t !== null ? FM(t) : null;
  }
  function FM(t) {
    if (t.tag === 5 || t.tag === 6)
      return t;
    for (t = t.child; t !== null; ) {
      var e = FM(t);
      if (e !== null)
        return e;
      t = t.sibling;
    }
    return null;
  }
  var VM = Jn.unstable_scheduleCallback, kS = Jn.unstable_cancelCallback, V_ = Jn.unstable_shouldYield, H_ = Jn.unstable_requestPaint, Mt = Jn.unstable_now, j_ = Jn.unstable_getCurrentPriorityLevel, W1 = Jn.unstable_ImmediatePriority, HM = Jn.unstable_UserBlockingPriority, Id = Jn.unstable_NormalPriority, W_ = Jn.unstable_LowPriority, jM = Jn.unstable_IdlePriority, Up = null, xi = null;
  function U_(t) {
    if (xi && typeof xi.onCommitFiberRoot == "function")
      try {
        xi.onCommitFiberRoot(Up, t, void 0, (t.current.flags & 128) === 128);
      } catch {
      }
  }
  var Fr = Math.clz32 ? Math.clz32 : G_, K_ = Math.log, q_ = Math.LN2;
  function G_(t) {
    return t >>>= 0, t === 0 ? 32 : 31 - (K_(t) / q_ | 0) | 0;
  }
  var qf = 64, Gf = 4194304;
  function dc(t) {
    switch (t & -t) {
      case 1:
        return 1;
      case 2:
        return 2;
      case 4:
        return 4;
      case 8:
        return 8;
      case 16:
        return 16;
      case 32:
        return 32;
      case 64:
      case 128:
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
        return t & 4194240;
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
      case 67108864:
        return t & 130023424;
      case 134217728:
        return 134217728;
      case 268435456:
        return 268435456;
      case 536870912:
        return 536870912;
      case 1073741824:
        return 1073741824;
      default:
        return t;
    }
  }
  function Bd(t, e) {
    var n = t.pendingLanes;
    if (n === 0)
      return 0;
    var r = 0, i = t.suspendedLanes, o = t.pingedLanes, s = n & 268435455;
    if (s !== 0) {
      var a = s & ~i;
      a !== 0 ? r = dc(a) : (o &= s, o !== 0 && (r = dc(o)));
    } else
      s = n & ~i, s !== 0 ? r = dc(s) : o !== 0 && (r = dc(o));
    if (r === 0)
      return 0;
    if (e !== 0 && e !== r && (e & i) === 0 && (i = r & -r, o = e & -e, i >= o || i === 16 && (o & 4194240) !== 0))
      return e;
    if ((r & 4) !== 0 && (r |= n & 16), e = t.entangledLanes, e !== 0)
      for (t = t.entanglements, e &= r; 0 < e; )
        n = 31 - Fr(e), i = 1 << n, r |= t[n], e &= ~i;
    return r;
  }
  function Y_(t, e) {
    switch (t) {
      case 1:
      case 2:
      case 4:
        return e + 250;
      case 8:
      case 16:
      case 32:
      case 64:
      case 128:
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
        return e + 5e3;
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
      case 67108864:
        return -1;
      case 134217728:
      case 268435456:
      case 536870912:
      case 1073741824:
        return -1;
      default:
        return -1;
    }
  }
  function X_(t, e) {
    for (var n = t.suspendedLanes, r = t.pingedLanes, i = t.expirationTimes, o = t.pendingLanes; 0 < o; ) {
      var s = 31 - Fr(o), a = 1 << s, l = i[s];
      l === -1 ? ((a & n) === 0 || (a & r) !== 0) && (i[s] = Y_(a, e)) : l <= e && (t.expiredLanes |= a), o &= ~a;
    }
  }
  function wv(t) {
    return t = t.pendingLanes & -1073741825, t !== 0 ? t : t & 1073741824 ? 1073741824 : 0;
  }
  function WM() {
    var t = qf;
    return qf <<= 1, (qf & 4194240) === 0 && (qf = 64), t;
  }
  function Og(t) {
    for (var e = [], n = 0; 31 > n; n++)
      e.push(t);
    return e;
  }
  function Gu(t, e, n) {
    t.pendingLanes |= e, e !== 536870912 && (t.suspendedLanes = 0, t.pingedLanes = 0), t = t.eventTimes, e = 31 - Fr(e), t[e] = n;
  }
  function Q_(t, e) {
    var n = t.pendingLanes & ~e;
    t.pendingLanes = e, t.suspendedLanes = 0, t.pingedLanes = 0, t.expiredLanes &= e, t.mutableReadLanes &= e, t.entangledLanes &= e, e = t.entanglements;
    var r = t.eventTimes;
    for (t = t.expirationTimes; 0 < n; ) {
      var i = 31 - Fr(n), o = 1 << i;
      e[i] = 0, r[i] = -1, t[i] = -1, n &= ~o;
    }
  }
  function U1(t, e) {
    var n = t.entangledLanes |= e;
    for (t = t.entanglements; n; ) {
      var r = 31 - Fr(n), i = 1 << r;
      i & e | t[r] & e && (t[r] |= e), n &= ~i;
    }
  }
  var Ye = 0;
  function UM(t) {
    return t &= -t, 1 < t ? 4 < t ? (t & 268435455) !== 0 ? 16 : 536870912 : 4 : 1;
  }
  var KM, K1, qM, GM, YM, kv = false, Yf = [], Bo = null, No = null, $o = null, su = /* @__PURE__ */ new Map(), au = /* @__PURE__ */ new Map(), ko = [], J_ = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");
  function CS(t, e) {
    switch (t) {
      case "focusin":
      case "focusout":
        Bo = null;
        break;
      case "dragenter":
      case "dragleave":
        No = null;
        break;
      case "mouseover":
      case "mouseout":
        $o = null;
        break;
      case "pointerover":
      case "pointerout":
        su.delete(e.pointerId);
        break;
      case "gotpointercapture":
      case "lostpointercapture":
        au.delete(e.pointerId);
    }
  }
  function ql(t, e, n, r, i, o) {
    return t === null || t.nativeEvent !== o ? (t = {
      blockedOn: e,
      domEventName: n,
      eventSystemFlags: r,
      nativeEvent: o,
      targetContainers: [
        i
      ]
    }, e !== null && (e = Xu(e), e !== null && K1(e)), t) : (t.eventSystemFlags |= r, e = t.targetContainers, i !== null && e.indexOf(i) === -1 && e.push(i), t);
  }
  function Z_(t, e, n, r, i) {
    switch (e) {
      case "focusin":
        return Bo = ql(Bo, t, e, n, r, i), true;
      case "dragenter":
        return No = ql(No, t, e, n, r, i), true;
      case "mouseover":
        return $o = ql($o, t, e, n, r, i), true;
      case "pointerover":
        var o = i.pointerId;
        return su.set(o, ql(su.get(o) || null, t, e, n, r, i)), true;
      case "gotpointercapture":
        return o = i.pointerId, au.set(o, ql(au.get(o) || null, t, e, n, r, i)), true;
    }
    return false;
  }
  function XM(t) {
    var e = Cs(t.target);
    if (e !== null) {
      var n = Qs(e);
      if (n !== null) {
        if (e = n.tag, e === 13) {
          if (e = $M(n), e !== null) {
            t.blockedOn = e, YM(t.priority, function() {
              qM(n);
            });
            return;
          }
        } else if (e === 3 && n.stateNode.current.memoizedState.isDehydrated) {
          t.blockedOn = n.tag === 3 ? n.stateNode.containerInfo : null;
          return;
        }
      }
    }
    t.blockedOn = null;
  }
  function qh(t) {
    if (t.blockedOn !== null)
      return false;
    for (var e = t.targetContainers; 0 < e.length; ) {
      var n = Cv(t.domEventName, t.eventSystemFlags, e[0], t.nativeEvent);
      if (n === null) {
        n = t.nativeEvent;
        var r = new n.constructor(n.type, n);
        yv = r, n.target.dispatchEvent(r), yv = null;
      } else
        return e = Xu(n), e !== null && K1(e), t.blockedOn = n, false;
      e.shift();
    }
    return true;
  }
  function TS(t, e, n) {
    qh(t) && n.delete(e);
  }
  function eD() {
    kv = false, Bo !== null && qh(Bo) && (Bo = null), No !== null && qh(No) && (No = null), $o !== null && qh($o) && ($o = null), su.forEach(TS), au.forEach(TS);
  }
  function Gl(t, e) {
    t.blockedOn === e && (t.blockedOn = null, kv || (kv = true, Jn.unstable_scheduleCallback(Jn.unstable_NormalPriority, eD)));
  }
  function lu(t) {
    function e(i) {
      return Gl(i, t);
    }
    if (0 < Yf.length) {
      Gl(Yf[0], t);
      for (var n = 1; n < Yf.length; n++) {
        var r = Yf[n];
        r.blockedOn === t && (r.blockedOn = null);
      }
    }
    for (Bo !== null && Gl(Bo, t), No !== null && Gl(No, t), $o !== null && Gl($o, t), su.forEach(e), au.forEach(e), n = 0; n < ko.length; n++)
      r = ko[n], r.blockedOn === t && (r.blockedOn = null);
    for (; 0 < ko.length && (n = ko[0], n.blockedOn === null); )
      XM(n), n.blockedOn === null && ko.shift();
  }
  var za = io.ReactCurrentBatchConfig, Nd = true;
  function tD(t, e, n, r) {
    var i = Ye, o = za.transition;
    za.transition = null;
    try {
      Ye = 1, q1(t, e, n, r);
    } finally {
      Ye = i, za.transition = o;
    }
  }
  function nD(t, e, n, r) {
    var i = Ye, o = za.transition;
    za.transition = null;
    try {
      Ye = 4, q1(t, e, n, r);
    } finally {
      Ye = i, za.transition = o;
    }
  }
  function q1(t, e, n, r) {
    if (Nd) {
      var i = Cv(t, e, n, r);
      if (i === null)
        Fg(t, e, r, $d, n), CS(t, r);
      else if (Z_(i, t, e, n, r))
        r.stopPropagation();
      else if (CS(t, r), e & 4 && -1 < J_.indexOf(t)) {
        for (; i !== null; ) {
          var o = Xu(i);
          if (o !== null && KM(o), o = Cv(t, e, n, r), o === null && Fg(t, e, r, $d, n), o === i)
            break;
          i = o;
        }
        i !== null && r.stopPropagation();
      } else
        Fg(t, e, r, null, n);
    }
  }
  var $d = null;
  function Cv(t, e, n, r) {
    if ($d = null, t = j1(r), t = Cs(t), t !== null)
      if (e = Qs(t), e === null)
        t = null;
      else if (n = e.tag, n === 13) {
        if (t = $M(e), t !== null)
          return t;
        t = null;
      } else if (n === 3) {
        if (e.stateNode.current.memoizedState.isDehydrated)
          return e.tag === 3 ? e.stateNode.containerInfo : null;
        t = null;
      } else
        e !== t && (t = null);
    return $d = t, null;
  }
  function QM(t) {
    switch (t) {
      case "cancel":
      case "click":
      case "close":
      case "contextmenu":
      case "copy":
      case "cut":
      case "auxclick":
      case "dblclick":
      case "dragend":
      case "dragstart":
      case "drop":
      case "focusin":
      case "focusout":
      case "input":
      case "invalid":
      case "keydown":
      case "keypress":
      case "keyup":
      case "mousedown":
      case "mouseup":
      case "paste":
      case "pause":
      case "play":
      case "pointercancel":
      case "pointerdown":
      case "pointerup":
      case "ratechange":
      case "reset":
      case "resize":
      case "seeked":
      case "submit":
      case "touchcancel":
      case "touchend":
      case "touchstart":
      case "volumechange":
      case "change":
      case "selectionchange":
      case "textInput":
      case "compositionstart":
      case "compositionend":
      case "compositionupdate":
      case "beforeblur":
      case "afterblur":
      case "beforeinput":
      case "blur":
      case "fullscreenchange":
      case "focus":
      case "hashchange":
      case "popstate":
      case "select":
      case "selectstart":
        return 1;
      case "drag":
      case "dragenter":
      case "dragexit":
      case "dragleave":
      case "dragover":
      case "mousemove":
      case "mouseout":
      case "mouseover":
      case "pointermove":
      case "pointerout":
      case "pointerover":
      case "scroll":
      case "toggle":
      case "touchmove":
      case "wheel":
      case "mouseenter":
      case "mouseleave":
      case "pointerenter":
      case "pointerleave":
        return 4;
      case "message":
        switch (j_()) {
          case W1:
            return 1;
          case HM:
            return 4;
          case Id:
          case W_:
            return 16;
          case jM:
            return 536870912;
          default:
            return 16;
        }
      default:
        return 16;
    }
  }
  var Eo = null, G1 = null, Gh = null;
  function JM() {
    if (Gh)
      return Gh;
    var t, e = G1, n = e.length, r, i = "value" in Eo ? Eo.value : Eo.textContent, o = i.length;
    for (t = 0; t < n && e[t] === i[t]; t++)
      ;
    var s = n - t;
    for (r = 1; r <= s && e[n - r] === i[o - r]; r++)
      ;
    return Gh = i.slice(t, 1 < r ? 1 - r : void 0);
  }
  function Yh(t) {
    var e = t.keyCode;
    return "charCode" in t ? (t = t.charCode, t === 0 && e === 13 && (t = 13)) : t = e, t === 10 && (t = 13), 32 <= t || t === 13 ? t : 0;
  }
  function Xf() {
    return true;
  }
  function MS() {
    return false;
  }
  function er(t) {
    function e(n, r, i, o, s) {
      this._reactName = n, this._targetInst = i, this.type = r, this.nativeEvent = o, this.target = s, this.currentTarget = null;
      for (var a in t)
        t.hasOwnProperty(a) && (n = t[a], this[a] = n ? n(o) : o[a]);
      return this.isDefaultPrevented = (o.defaultPrevented != null ? o.defaultPrevented : o.returnValue === false) ? Xf : MS, this.isPropagationStopped = MS, this;
    }
    return vt(e.prototype, {
      preventDefault: function() {
        this.defaultPrevented = true;
        var n = this.nativeEvent;
        n && (n.preventDefault ? n.preventDefault() : typeof n.returnValue != "unknown" && (n.returnValue = false), this.isDefaultPrevented = Xf);
      },
      stopPropagation: function() {
        var n = this.nativeEvent;
        n && (n.stopPropagation ? n.stopPropagation() : typeof n.cancelBubble != "unknown" && (n.cancelBubble = true), this.isPropagationStopped = Xf);
      },
      persist: function() {
      },
      isPersistent: Xf
    }), e;
  }
  var Cl = {
    eventPhase: 0,
    bubbles: 0,
    cancelable: 0,
    timeStamp: function(t) {
      return t.timeStamp || Date.now();
    },
    defaultPrevented: 0,
    isTrusted: 0
  }, Y1 = er(Cl), Yu = vt({}, Cl, {
    view: 0,
    detail: 0
  }), rD = er(Yu), Rg, Lg, Yl, Kp = vt({}, Yu, {
    screenX: 0,
    screenY: 0,
    clientX: 0,
    clientY: 0,
    pageX: 0,
    pageY: 0,
    ctrlKey: 0,
    shiftKey: 0,
    altKey: 0,
    metaKey: 0,
    getModifierState: X1,
    button: 0,
    buttons: 0,
    relatedTarget: function(t) {
      return t.relatedTarget === void 0 ? t.fromElement === t.srcElement ? t.toElement : t.fromElement : t.relatedTarget;
    },
    movementX: function(t) {
      return "movementX" in t ? t.movementX : (t !== Yl && (Yl && t.type === "mousemove" ? (Rg = t.screenX - Yl.screenX, Lg = t.screenY - Yl.screenY) : Lg = Rg = 0, Yl = t), Rg);
    },
    movementY: function(t) {
      return "movementY" in t ? t.movementY : Lg;
    }
  }), AS = er(Kp), iD = vt({}, Kp, {
    dataTransfer: 0
  }), oD = er(iD), sD = vt({}, Yu, {
    relatedTarget: 0
  }), _g = er(sD), aD = vt({}, Cl, {
    animationName: 0,
    elapsedTime: 0,
    pseudoElement: 0
  }), lD = er(aD), cD = vt({}, Cl, {
    clipboardData: function(t) {
      return "clipboardData" in t ? t.clipboardData : window.clipboardData;
    }
  }), uD = er(cD), fD = vt({}, Cl, {
    data: 0
  }), ES = er(fD), hD = {
    Esc: "Escape",
    Spacebar: " ",
    Left: "ArrowLeft",
    Up: "ArrowUp",
    Right: "ArrowRight",
    Down: "ArrowDown",
    Del: "Delete",
    Win: "OS",
    Menu: "ContextMenu",
    Apps: "ContextMenu",
    Scroll: "ScrollLock",
    MozPrintableKey: "Unidentified"
  }, dD = {
    8: "Backspace",
    9: "Tab",
    12: "Clear",
    13: "Enter",
    16: "Shift",
    17: "Control",
    18: "Alt",
    19: "Pause",
    20: "CapsLock",
    27: "Escape",
    32: " ",
    33: "PageUp",
    34: "PageDown",
    35: "End",
    36: "Home",
    37: "ArrowLeft",
    38: "ArrowUp",
    39: "ArrowRight",
    40: "ArrowDown",
    45: "Insert",
    46: "Delete",
    112: "F1",
    113: "F2",
    114: "F3",
    115: "F4",
    116: "F5",
    117: "F6",
    118: "F7",
    119: "F8",
    120: "F9",
    121: "F10",
    122: "F11",
    123: "F12",
    144: "NumLock",
    145: "ScrollLock",
    224: "Meta"
  }, pD = {
    Alt: "altKey",
    Control: "ctrlKey",
    Meta: "metaKey",
    Shift: "shiftKey"
  };
  function mD(t) {
    var e = this.nativeEvent;
    return e.getModifierState ? e.getModifierState(t) : (t = pD[t]) ? !!e[t] : false;
  }
  function X1() {
    return mD;
  }
  var gD = vt({}, Yu, {
    key: function(t) {
      if (t.key) {
        var e = hD[t.key] || t.key;
        if (e !== "Unidentified")
          return e;
      }
      return t.type === "keypress" ? (t = Yh(t), t === 13 ? "Enter" : String.fromCharCode(t)) : t.type === "keydown" || t.type === "keyup" ? dD[t.keyCode] || "Unidentified" : "";
    },
    code: 0,
    location: 0,
    ctrlKey: 0,
    shiftKey: 0,
    altKey: 0,
    metaKey: 0,
    repeat: 0,
    locale: 0,
    getModifierState: X1,
    charCode: function(t) {
      return t.type === "keypress" ? Yh(t) : 0;
    },
    keyCode: function(t) {
      return t.type === "keydown" || t.type === "keyup" ? t.keyCode : 0;
    },
    which: function(t) {
      return t.type === "keypress" ? Yh(t) : t.type === "keydown" || t.type === "keyup" ? t.keyCode : 0;
    }
  }), vD = er(gD), yD = vt({}, Kp, {
    pointerId: 0,
    width: 0,
    height: 0,
    pressure: 0,
    tangentialPressure: 0,
    tiltX: 0,
    tiltY: 0,
    twist: 0,
    pointerType: 0,
    isPrimary: 0
  }), PS = er(yD), bD = vt({}, Yu, {
    touches: 0,
    targetTouches: 0,
    changedTouches: 0,
    altKey: 0,
    metaKey: 0,
    ctrlKey: 0,
    shiftKey: 0,
    getModifierState: X1
  }), xD = er(bD), SD = vt({}, Cl, {
    propertyName: 0,
    elapsedTime: 0,
    pseudoElement: 0
  }), wD = er(SD), kD = vt({}, Kp, {
    deltaX: function(t) {
      return "deltaX" in t ? t.deltaX : "wheelDeltaX" in t ? -t.wheelDeltaX : 0;
    },
    deltaY: function(t) {
      return "deltaY" in t ? t.deltaY : "wheelDeltaY" in t ? -t.wheelDeltaY : "wheelDelta" in t ? -t.wheelDelta : 0;
    },
    deltaZ: 0,
    deltaMode: 0
  }), CD = er(kD), TD = [
    9,
    13,
    27,
    32
  ], Q1 = Gi && "CompositionEvent" in window, Ec = null;
  Gi && "documentMode" in document && (Ec = document.documentMode);
  var MD = Gi && "TextEvent" in window && !Ec, ZM = Gi && (!Q1 || Ec && 8 < Ec && 11 >= Ec), OS = String.fromCharCode(32), RS = false;
  function e2(t, e) {
    switch (t) {
      case "keyup":
        return TD.indexOf(e.keyCode) !== -1;
      case "keydown":
        return e.keyCode !== 229;
      case "keypress":
      case "mousedown":
      case "focusout":
        return true;
      default:
        return false;
    }
  }
  function t2(t) {
    return t = t.detail, typeof t == "object" && "data" in t ? t.data : null;
  }
  var ma = false;
  function AD(t, e) {
    switch (t) {
      case "compositionend":
        return t2(e);
      case "keypress":
        return e.which !== 32 ? null : (RS = true, OS);
      case "textInput":
        return t = e.data, t === OS && RS ? null : t;
      default:
        return null;
    }
  }
  function ED(t, e) {
    if (ma)
      return t === "compositionend" || !Q1 && e2(t, e) ? (t = JM(), Gh = G1 = Eo = null, ma = false, t) : null;
    switch (t) {
      case "paste":
        return null;
      case "keypress":
        if (!(e.ctrlKey || e.altKey || e.metaKey) || e.ctrlKey && e.altKey) {
          if (e.char && 1 < e.char.length)
            return e.char;
          if (e.which)
            return String.fromCharCode(e.which);
        }
        return null;
      case "compositionend":
        return ZM && e.locale !== "ko" ? null : e.data;
      default:
        return null;
    }
  }
  var PD = {
    color: true,
    date: true,
    datetime: true,
    "datetime-local": true,
    email: true,
    month: true,
    number: true,
    password: true,
    range: true,
    search: true,
    tel: true,
    text: true,
    time: true,
    url: true,
    week: true
  };
  function LS(t) {
    var e = t && t.nodeName && t.nodeName.toLowerCase();
    return e === "input" ? !!PD[t.type] : e === "textarea";
  }
  function n2(t, e, n, r) {
    _M(r), e = zd(e, "onChange"), 0 < e.length && (n = new Y1("onChange", "change", null, n, r), t.push({
      event: n,
      listeners: e
    }));
  }
  var Pc = null, cu = null;
  function OD(t) {
    d2(t, 0);
  }
  function qp(t) {
    var e = ya(t);
    if (MM(e))
      return t;
  }
  function RD(t, e) {
    if (t === "change")
      return e;
  }
  var r2 = false;
  if (Gi) {
    var Dg;
    if (Gi) {
      var Ig = "oninput" in document;
      if (!Ig) {
        var _S = document.createElement("div");
        _S.setAttribute("oninput", "return;"), Ig = typeof _S.oninput == "function";
      }
      Dg = Ig;
    } else
      Dg = false;
    r2 = Dg && (!document.documentMode || 9 < document.documentMode);
  }
  function DS() {
    Pc && (Pc.detachEvent("onpropertychange", i2), cu = Pc = null);
  }
  function i2(t) {
    if (t.propertyName === "value" && qp(cu)) {
      var e = [];
      n2(e, cu, t, j1(t)), NM(OD, e);
    }
  }
  function LD(t, e, n) {
    t === "focusin" ? (DS(), Pc = e, cu = n, Pc.attachEvent("onpropertychange", i2)) : t === "focusout" && DS();
  }
  function _D(t) {
    if (t === "selectionchange" || t === "keyup" || t === "keydown")
      return qp(cu);
  }
  function DD(t, e) {
    if (t === "click")
      return qp(e);
  }
  function ID(t, e) {
    if (t === "input" || t === "change")
      return qp(e);
  }
  function BD(t, e) {
    return t === e && (t !== 0 || 1 / t === 1 / e) || t !== t && e !== e;
  }
  var Ur = typeof Object.is == "function" ? Object.is : BD;
  function uu(t, e) {
    if (Ur(t, e))
      return true;
    if (typeof t != "object" || t === null || typeof e != "object" || e === null)
      return false;
    var n = Object.keys(t), r = Object.keys(e);
    if (n.length !== r.length)
      return false;
    for (r = 0; r < n.length; r++) {
      var i = n[r];
      if (!sv.call(e, i) || !Ur(t[i], e[i]))
        return false;
    }
    return true;
  }
  function IS(t) {
    for (; t && t.firstChild; )
      t = t.firstChild;
    return t;
  }
  function BS(t, e) {
    var n = IS(t);
    t = 0;
    for (var r; n; ) {
      if (n.nodeType === 3) {
        if (r = t + n.textContent.length, t <= e && r >= e)
          return {
            node: n,
            offset: e - t
          };
        t = r;
      }
      e: {
        for (; n; ) {
          if (n.nextSibling) {
            n = n.nextSibling;
            break e;
          }
          n = n.parentNode;
        }
        n = void 0;
      }
      n = IS(n);
    }
  }
  function o2(t, e) {
    return t && e ? t === e ? true : t && t.nodeType === 3 ? false : e && e.nodeType === 3 ? o2(t, e.parentNode) : "contains" in t ? t.contains(e) : t.compareDocumentPosition ? !!(t.compareDocumentPosition(e) & 16) : false : false;
  }
  function s2() {
    for (var t = window, e = Ld(); e instanceof t.HTMLIFrameElement; ) {
      try {
        var n = typeof e.contentWindow.location.href == "string";
      } catch {
        n = false;
      }
      if (n)
        t = e.contentWindow;
      else
        break;
      e = Ld(t.document);
    }
    return e;
  }
  function J1(t) {
    var e = t && t.nodeName && t.nodeName.toLowerCase();
    return e && (e === "input" && (t.type === "text" || t.type === "search" || t.type === "tel" || t.type === "url" || t.type === "password") || e === "textarea" || t.contentEditable === "true");
  }
  function ND(t) {
    var e = s2(), n = t.focusedElem, r = t.selectionRange;
    if (e !== n && n && n.ownerDocument && o2(n.ownerDocument.documentElement, n)) {
      if (r !== null && J1(n)) {
        if (e = r.start, t = r.end, t === void 0 && (t = e), "selectionStart" in n)
          n.selectionStart = e, n.selectionEnd = Math.min(t, n.value.length);
        else if (t = (e = n.ownerDocument || document) && e.defaultView || window, t.getSelection) {
          t = t.getSelection();
          var i = n.textContent.length, o = Math.min(r.start, i);
          r = r.end === void 0 ? o : Math.min(r.end, i), !t.extend && o > r && (i = r, r = o, o = i), i = BS(n, o);
          var s = BS(n, r);
          i && s && (t.rangeCount !== 1 || t.anchorNode !== i.node || t.anchorOffset !== i.offset || t.focusNode !== s.node || t.focusOffset !== s.offset) && (e = e.createRange(), e.setStart(i.node, i.offset), t.removeAllRanges(), o > r ? (t.addRange(e), t.extend(s.node, s.offset)) : (e.setEnd(s.node, s.offset), t.addRange(e)));
        }
      }
      for (e = [], t = n; t = t.parentNode; )
        t.nodeType === 1 && e.push({
          element: t,
          left: t.scrollLeft,
          top: t.scrollTop
        });
      for (typeof n.focus == "function" && n.focus(), n = 0; n < e.length; n++)
        t = e[n], t.element.scrollLeft = t.left, t.element.scrollTop = t.top;
    }
  }
  var $D = Gi && "documentMode" in document && 11 >= document.documentMode, ga = null, Tv = null, Oc = null, Mv = false;
  function NS(t, e, n) {
    var r = n.window === n ? n.document : n.nodeType === 9 ? n : n.ownerDocument;
    Mv || ga == null || ga !== Ld(r) || (r = ga, "selectionStart" in r && J1(r) ? r = {
      start: r.selectionStart,
      end: r.selectionEnd
    } : (r = (r.ownerDocument && r.ownerDocument.defaultView || window).getSelection(), r = {
      anchorNode: r.anchorNode,
      anchorOffset: r.anchorOffset,
      focusNode: r.focusNode,
      focusOffset: r.focusOffset
    }), Oc && uu(Oc, r) || (Oc = r, r = zd(Tv, "onSelect"), 0 < r.length && (e = new Y1("onSelect", "select", null, e, n), t.push({
      event: e,
      listeners: r
    }), e.target = ga)));
  }
  function Qf(t, e) {
    var n = {};
    return n[t.toLowerCase()] = e.toLowerCase(), n["Webkit" + t] = "webkit" + e, n["Moz" + t] = "moz" + e, n;
  }
  var va = {
    animationend: Qf("Animation", "AnimationEnd"),
    animationiteration: Qf("Animation", "AnimationIteration"),
    animationstart: Qf("Animation", "AnimationStart"),
    transitionend: Qf("Transition", "TransitionEnd")
  }, Bg = {}, a2 = {};
  Gi && (a2 = document.createElement("div").style, "AnimationEvent" in window || (delete va.animationend.animation, delete va.animationiteration.animation, delete va.animationstart.animation), "TransitionEvent" in window || delete va.transitionend.transition);
  function Gp(t) {
    if (Bg[t])
      return Bg[t];
    if (!va[t])
      return t;
    var e = va[t], n;
    for (n in e)
      if (e.hasOwnProperty(n) && n in a2)
        return Bg[t] = e[n];
    return t;
  }
  var l2 = Gp("animationend"), c2 = Gp("animationiteration"), u2 = Gp("animationstart"), f2 = Gp("transitionend"), h2 = /* @__PURE__ */ new Map(), $S = "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");
  function Zo(t, e) {
    h2.set(t, e), Xs(e, [
      t
    ]);
  }
  for (var Ng = 0; Ng < $S.length; Ng++) {
    var $g = $S[Ng], zD = $g.toLowerCase(), FD = $g[0].toUpperCase() + $g.slice(1);
    Zo(zD, "on" + FD);
  }
  Zo(l2, "onAnimationEnd");
  Zo(c2, "onAnimationIteration");
  Zo(u2, "onAnimationStart");
  Zo("dblclick", "onDoubleClick");
  Zo("focusin", "onFocus");
  Zo("focusout", "onBlur");
  Zo(f2, "onTransitionEnd");
  el("onMouseEnter", [
    "mouseout",
    "mouseover"
  ]);
  el("onMouseLeave", [
    "mouseout",
    "mouseover"
  ]);
  el("onPointerEnter", [
    "pointerout",
    "pointerover"
  ]);
  el("onPointerLeave", [
    "pointerout",
    "pointerover"
  ]);
  Xs("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" "));
  Xs("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" "));
  Xs("onBeforeInput", [
    "compositionend",
    "keypress",
    "textInput",
    "paste"
  ]);
  Xs("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" "));
  Xs("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" "));
  Xs("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" "));
  var pc = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "), VD = new Set("cancel close invalid load scroll toggle".split(" ").concat(pc));
  function zS(t, e, n) {
    var r = t.type || "unknown-event";
    t.currentTarget = n, z_(r, e, void 0, t), t.currentTarget = null;
  }
  function d2(t, e) {
    e = (e & 4) !== 0;
    for (var n = 0; n < t.length; n++) {
      var r = t[n], i = r.event;
      r = r.listeners;
      e: {
        var o = void 0;
        if (e)
          for (var s = r.length - 1; 0 <= s; s--) {
            var a = r[s], l = a.instance, c = a.currentTarget;
            if (a = a.listener, l !== o && i.isPropagationStopped())
              break e;
            zS(i, a, c), o = l;
          }
        else
          for (s = 0; s < r.length; s++) {
            if (a = r[s], l = a.instance, c = a.currentTarget, a = a.listener, l !== o && i.isPropagationStopped())
              break e;
            zS(i, a, c), o = l;
          }
      }
    }
    if (Dd)
      throw t = Sv, Dd = false, Sv = null, t;
  }
  function ot(t, e) {
    var n = e[Rv];
    n === void 0 && (n = e[Rv] = /* @__PURE__ */ new Set());
    var r = t + "__bubble";
    n.has(r) || (p2(e, t, 2, false), n.add(r));
  }
  function zg(t, e, n) {
    var r = 0;
    e && (r |= 4), p2(n, t, r, e);
  }
  var Jf = "_reactListening" + Math.random().toString(36).slice(2);
  function fu(t) {
    if (!t[Jf]) {
      t[Jf] = true, SM.forEach(function(n) {
        n !== "selectionchange" && (VD.has(n) || zg(n, false, t), zg(n, true, t));
      });
      var e = t.nodeType === 9 ? t : t.ownerDocument;
      e === null || e[Jf] || (e[Jf] = true, zg("selectionchange", false, e));
    }
  }
  function p2(t, e, n, r) {
    switch (QM(e)) {
      case 1:
        var i = tD;
        break;
      case 4:
        i = nD;
        break;
      default:
        i = q1;
    }
    n = i.bind(null, e, n, t), i = void 0, !xv || e !== "touchstart" && e !== "touchmove" && e !== "wheel" || (i = true), r ? i !== void 0 ? t.addEventListener(e, n, {
      capture: true,
      passive: i
    }) : t.addEventListener(e, n, true) : i !== void 0 ? t.addEventListener(e, n, {
      passive: i
    }) : t.addEventListener(e, n, false);
  }
  function Fg(t, e, n, r, i) {
    var o = r;
    if ((e & 1) === 0 && (e & 2) === 0 && r !== null)
      e:
        for (; ; ) {
          if (r === null)
            return;
          var s = r.tag;
          if (s === 3 || s === 4) {
            var a = r.stateNode.containerInfo;
            if (a === i || a.nodeType === 8 && a.parentNode === i)
              break;
            if (s === 4)
              for (s = r.return; s !== null; ) {
                var l = s.tag;
                if ((l === 3 || l === 4) && (l = s.stateNode.containerInfo, l === i || l.nodeType === 8 && l.parentNode === i))
                  return;
                s = s.return;
              }
            for (; a !== null; ) {
              if (s = Cs(a), s === null)
                return;
              if (l = s.tag, l === 5 || l === 6) {
                r = o = s;
                continue e;
              }
              a = a.parentNode;
            }
          }
          r = r.return;
        }
    NM(function() {
      var c = o, u = j1(n), h = [];
      e: {
        var p = h2.get(t);
        if (p !== void 0) {
          var v = Y1, y = t;
          switch (t) {
            case "keypress":
              if (Yh(n) === 0)
                break e;
            case "keydown":
            case "keyup":
              v = vD;
              break;
            case "focusin":
              y = "focus", v = _g;
              break;
            case "focusout":
              y = "blur", v = _g;
              break;
            case "beforeblur":
            case "afterblur":
              v = _g;
              break;
            case "click":
              if (n.button === 2)
                break e;
            case "auxclick":
            case "dblclick":
            case "mousedown":
            case "mousemove":
            case "mouseup":
            case "mouseout":
            case "mouseover":
            case "contextmenu":
              v = AS;
              break;
            case "drag":
            case "dragend":
            case "dragenter":
            case "dragexit":
            case "dragleave":
            case "dragover":
            case "dragstart":
            case "drop":
              v = oD;
              break;
            case "touchcancel":
            case "touchend":
            case "touchmove":
            case "touchstart":
              v = xD;
              break;
            case l2:
            case c2:
            case u2:
              v = lD;
              break;
            case f2:
              v = wD;
              break;
            case "scroll":
              v = rD;
              break;
            case "wheel":
              v = CD;
              break;
            case "copy":
            case "cut":
            case "paste":
              v = uD;
              break;
            case "gotpointercapture":
            case "lostpointercapture":
            case "pointercancel":
            case "pointerdown":
            case "pointermove":
            case "pointerout":
            case "pointerover":
            case "pointerup":
              v = PS;
          }
          var x = (e & 4) !== 0, T = !x && t === "scroll", w = x ? p !== null ? p + "Capture" : null : p;
          x = [];
          for (var k = c, C; k !== null; ) {
            C = k;
            var P = C.stateNode;
            if (C.tag === 5 && P !== null && (C = P, w !== null && (P = ou(k, w), P != null && x.push(hu(k, P, C)))), T)
              break;
            k = k.return;
          }
          0 < x.length && (p = new v(p, y, null, n, u), h.push({
            event: p,
            listeners: x
          }));
        }
      }
      if ((e & 7) === 0) {
        e: {
          if (p = t === "mouseover" || t === "pointerover", v = t === "mouseout" || t === "pointerout", p && n !== yv && (y = n.relatedTarget || n.fromElement) && (Cs(y) || y[Yi]))
            break e;
          if ((v || p) && (p = u.window === u ? u : (p = u.ownerDocument) ? p.defaultView || p.parentWindow : window, v ? (y = n.relatedTarget || n.toElement, v = c, y = y ? Cs(y) : null, y !== null && (T = Qs(y), y !== T || y.tag !== 5 && y.tag !== 6) && (y = null)) : (v = null, y = c), v !== y)) {
            if (x = AS, P = "onMouseLeave", w = "onMouseEnter", k = "mouse", (t === "pointerout" || t === "pointerover") && (x = PS, P = "onPointerLeave", w = "onPointerEnter", k = "pointer"), T = v == null ? p : ya(v), C = y == null ? p : ya(y), p = new x(P, k + "leave", v, n, u), p.target = T, p.relatedTarget = C, P = null, Cs(u) === c && (x = new x(w, k + "enter", y, n, u), x.target = C, x.relatedTarget = T, P = x), T = P, v && y)
              t: {
                for (x = v, w = y, k = 0, C = x; C; C = aa(C))
                  k++;
                for (C = 0, P = w; P; P = aa(P))
                  C++;
                for (; 0 < k - C; )
                  x = aa(x), k--;
                for (; 0 < C - k; )
                  w = aa(w), C--;
                for (; k--; ) {
                  if (x === w || w !== null && x === w.alternate)
                    break t;
                  x = aa(x), w = aa(w);
                }
                x = null;
              }
            else
              x = null;
            v !== null && FS(h, p, v, x, false), y !== null && T !== null && FS(h, T, y, x, true);
          }
        }
        e: {
          if (p = c ? ya(c) : window, v = p.nodeName && p.nodeName.toLowerCase(), v === "select" || v === "input" && p.type === "file")
            var R = RD;
          else if (LS(p))
            if (r2)
              R = ID;
            else {
              R = _D;
              var L = LD;
            }
          else
            (v = p.nodeName) && v.toLowerCase() === "input" && (p.type === "checkbox" || p.type === "radio") && (R = DD);
          if (R && (R = R(t, c))) {
            n2(h, R, n, u);
            break e;
          }
          L && L(t, p, c), t === "focusout" && (L = p._wrapperState) && L.controlled && p.type === "number" && dv(p, "number", p.value);
        }
        switch (L = c ? ya(c) : window, t) {
          case "focusin":
            (LS(L) || L.contentEditable === "true") && (ga = L, Tv = c, Oc = null);
            break;
          case "focusout":
            Oc = Tv = ga = null;
            break;
          case "mousedown":
            Mv = true;
            break;
          case "contextmenu":
          case "mouseup":
          case "dragend":
            Mv = false, NS(h, n, u);
            break;
          case "selectionchange":
            if ($D)
              break;
          case "keydown":
          case "keyup":
            NS(h, n, u);
        }
        var _;
        if (Q1)
          e: {
            switch (t) {
              case "compositionstart":
                var F = "onCompositionStart";
                break e;
              case "compositionend":
                F = "onCompositionEnd";
                break e;
              case "compositionupdate":
                F = "onCompositionUpdate";
                break e;
            }
            F = void 0;
          }
        else
          ma ? e2(t, n) && (F = "onCompositionEnd") : t === "keydown" && n.keyCode === 229 && (F = "onCompositionStart");
        F && (ZM && n.locale !== "ko" && (ma || F !== "onCompositionStart" ? F === "onCompositionEnd" && ma && (_ = JM()) : (Eo = u, G1 = "value" in Eo ? Eo.value : Eo.textContent, ma = true)), L = zd(c, F), 0 < L.length && (F = new ES(F, t, null, n, u), h.push({
          event: F,
          listeners: L
        }), _ ? F.data = _ : (_ = t2(n), _ !== null && (F.data = _)))), (_ = MD ? AD(t, n) : ED(t, n)) && (c = zd(c, "onBeforeInput"), 0 < c.length && (u = new ES("onBeforeInput", "beforeinput", null, n, u), h.push({
          event: u,
          listeners: c
        }), u.data = _));
      }
      d2(h, e);
    });
  }
  function hu(t, e, n) {
    return {
      instance: t,
      listener: e,
      currentTarget: n
    };
  }
  function zd(t, e) {
    for (var n = e + "Capture", r = []; t !== null; ) {
      var i = t, o = i.stateNode;
      i.tag === 5 && o !== null && (i = o, o = ou(t, n), o != null && r.unshift(hu(t, o, i)), o = ou(t, e), o != null && r.push(hu(t, o, i))), t = t.return;
    }
    return r;
  }
  function aa(t) {
    if (t === null)
      return null;
    do
      t = t.return;
    while (t && t.tag !== 5);
    return t || null;
  }
  function FS(t, e, n, r, i) {
    for (var o = e._reactName, s = []; n !== null && n !== r; ) {
      var a = n, l = a.alternate, c = a.stateNode;
      if (l !== null && l === r)
        break;
      a.tag === 5 && c !== null && (a = c, i ? (l = ou(n, o), l != null && s.unshift(hu(n, l, a))) : i || (l = ou(n, o), l != null && s.push(hu(n, l, a)))), n = n.return;
    }
    s.length !== 0 && t.push({
      event: e,
      listeners: s
    });
  }
  var HD = /\r\n?/g, jD = /\u0000|\uFFFD/g;
  function VS(t) {
    return (typeof t == "string" ? t : "" + t).replace(HD, `
`).replace(jD, "");
  }
  function Zf(t, e, n) {
    if (e = VS(e), VS(t) !== e && n)
      throw Error(Z(425));
  }
  function Fd() {
  }
  var Av = null, Ev = null;
  function Pv(t, e) {
    return t === "textarea" || t === "noscript" || typeof e.children == "string" || typeof e.children == "number" || typeof e.dangerouslySetInnerHTML == "object" && e.dangerouslySetInnerHTML !== null && e.dangerouslySetInnerHTML.__html != null;
  }
  var Ov = typeof setTimeout == "function" ? setTimeout : void 0, WD = typeof clearTimeout == "function" ? clearTimeout : void 0, HS = typeof Promise == "function" ? Promise : void 0, UD = typeof queueMicrotask == "function" ? queueMicrotask : typeof HS < "u" ? function(t) {
    return HS.resolve(null).then(t).catch(KD);
  } : Ov;
  function KD(t) {
    setTimeout(function() {
      throw t;
    });
  }
  function Vg(t, e) {
    var n = e, r = 0;
    do {
      var i = n.nextSibling;
      if (t.removeChild(n), i && i.nodeType === 8)
        if (n = i.data, n === "/$") {
          if (r === 0) {
            t.removeChild(i), lu(e);
            return;
          }
          r--;
        } else
          n !== "$" && n !== "$?" && n !== "$!" || r++;
      n = i;
    } while (n);
    lu(e);
  }
  function zo(t) {
    for (; t != null; t = t.nextSibling) {
      var e = t.nodeType;
      if (e === 1 || e === 3)
        break;
      if (e === 8) {
        if (e = t.data, e === "$" || e === "$!" || e === "$?")
          break;
        if (e === "/$")
          return null;
      }
    }
    return t;
  }
  function jS(t) {
    t = t.previousSibling;
    for (var e = 0; t; ) {
      if (t.nodeType === 8) {
        var n = t.data;
        if (n === "$" || n === "$!" || n === "$?") {
          if (e === 0)
            return t;
          e--;
        } else
          n === "/$" && e++;
      }
      t = t.previousSibling;
    }
    return null;
  }
  var Tl = Math.random().toString(36).slice(2), di = "__reactFiber$" + Tl, du = "__reactProps$" + Tl, Yi = "__reactContainer$" + Tl, Rv = "__reactEvents$" + Tl, qD = "__reactListeners$" + Tl, GD = "__reactHandles$" + Tl;
  function Cs(t) {
    var e = t[di];
    if (e)
      return e;
    for (var n = t.parentNode; n; ) {
      if (e = n[Yi] || n[di]) {
        if (n = e.alternate, e.child !== null || n !== null && n.child !== null)
          for (t = jS(t); t !== null; ) {
            if (n = t[di])
              return n;
            t = jS(t);
          }
        return e;
      }
      t = n, n = t.parentNode;
    }
    return null;
  }
  function Xu(t) {
    return t = t[di] || t[Yi], !t || t.tag !== 5 && t.tag !== 6 && t.tag !== 13 && t.tag !== 3 ? null : t;
  }
  function ya(t) {
    if (t.tag === 5 || t.tag === 6)
      return t.stateNode;
    throw Error(Z(33));
  }
  function Yp(t) {
    return t[du] || null;
  }
  var Lv = [], ba = -1;
  function es(t) {
    return {
      current: t
    };
  }
  function lt(t) {
    0 > ba || (t.current = Lv[ba], Lv[ba] = null, ba--);
  }
  function nt(t, e) {
    ba++, Lv[ba] = t.current, t.current = e;
  }
  var Ko = {}, pn = es(Ko), $n = es(false), $s = Ko;
  function tl(t, e) {
    var n = t.type.contextTypes;
    if (!n)
      return Ko;
    var r = t.stateNode;
    if (r && r.__reactInternalMemoizedUnmaskedChildContext === e)
      return r.__reactInternalMemoizedMaskedChildContext;
    var i = {}, o;
    for (o in n)
      i[o] = e[o];
    return r && (t = t.stateNode, t.__reactInternalMemoizedUnmaskedChildContext = e, t.__reactInternalMemoizedMaskedChildContext = i), i;
  }
  function zn(t) {
    return t = t.childContextTypes, t != null;
  }
  function Vd() {
    lt($n), lt(pn);
  }
  function WS(t, e, n) {
    if (pn.current !== Ko)
      throw Error(Z(168));
    nt(pn, e), nt($n, n);
  }
  function m2(t, e, n) {
    var r = t.stateNode;
    if (e = e.childContextTypes, typeof r.getChildContext != "function")
      return n;
    r = r.getChildContext();
    for (var i in r)
      if (!(i in e))
        throw Error(Z(108, L_(t) || "Unknown", i));
    return vt({}, n, r);
  }
  function Hd(t) {
    return t = (t = t.stateNode) && t.__reactInternalMemoizedMergedChildContext || Ko, $s = pn.current, nt(pn, t), nt($n, $n.current), true;
  }
  function US(t, e, n) {
    var r = t.stateNode;
    if (!r)
      throw Error(Z(169));
    n ? (t = m2(t, e, $s), r.__reactInternalMemoizedMergedChildContext = t, lt($n), lt(pn), nt(pn, t)) : lt($n), nt($n, n);
  }
  var Ni = null, Xp = false, Hg = false;
  function g2(t) {
    Ni === null ? Ni = [
      t
    ] : Ni.push(t);
  }
  function YD(t) {
    Xp = true, g2(t);
  }
  function ts() {
    if (!Hg && Ni !== null) {
      Hg = true;
      var t = 0, e = Ye;
      try {
        var n = Ni;
        for (Ye = 1; t < n.length; t++) {
          var r = n[t];
          do
            r = r(true);
          while (r !== null);
        }
        Ni = null, Xp = false;
      } catch (i) {
        throw Ni !== null && (Ni = Ni.slice(t + 1)), VM(W1, ts), i;
      } finally {
        Ye = e, Hg = false;
      }
    }
    return null;
  }
  var xa = [], Sa = 0, jd = null, Wd = 0, fr = [], hr = 0, zs = null, Hi = 1, ji = "";
  function vs(t, e) {
    xa[Sa++] = Wd, xa[Sa++] = jd, jd = t, Wd = e;
  }
  function v2(t, e, n) {
    fr[hr++] = Hi, fr[hr++] = ji, fr[hr++] = zs, zs = t;
    var r = Hi;
    t = ji;
    var i = 32 - Fr(r) - 1;
    r &= ~(1 << i), n += 1;
    var o = 32 - Fr(e) + i;
    if (30 < o) {
      var s = i - i % 5;
      o = (r & (1 << s) - 1).toString(32), r >>= s, i -= s, Hi = 1 << 32 - Fr(e) + i | n << i | r, ji = o + t;
    } else
      Hi = 1 << o | n << i | r, ji = t;
  }
  function Z1(t) {
    t.return !== null && (vs(t, 1), v2(t, 1, 0));
  }
  function eb(t) {
    for (; t === jd; )
      jd = xa[--Sa], xa[Sa] = null, Wd = xa[--Sa], xa[Sa] = null;
    for (; t === zs; )
      zs = fr[--hr], fr[hr] = null, ji = fr[--hr], fr[hr] = null, Hi = fr[--hr], fr[hr] = null;
  }
  var Gn = null, Kn = null, ft = false, Nr = null;
  function y2(t, e) {
    var n = pr(5, null, null, 0);
    n.elementType = "DELETED", n.stateNode = e, n.return = t, e = t.deletions, e === null ? (t.deletions = [
      n
    ], t.flags |= 16) : e.push(n);
  }
  function KS(t, e) {
    switch (t.tag) {
      case 5:
        var n = t.type;
        return e = e.nodeType !== 1 || n.toLowerCase() !== e.nodeName.toLowerCase() ? null : e, e !== null ? (t.stateNode = e, Gn = t, Kn = zo(e.firstChild), true) : false;
      case 6:
        return e = t.pendingProps === "" || e.nodeType !== 3 ? null : e, e !== null ? (t.stateNode = e, Gn = t, Kn = null, true) : false;
      case 13:
        return e = e.nodeType !== 8 ? null : e, e !== null ? (n = zs !== null ? {
          id: Hi,
          overflow: ji
        } : null, t.memoizedState = {
          dehydrated: e,
          treeContext: n,
          retryLane: 1073741824
        }, n = pr(18, null, null, 0), n.stateNode = e, n.return = t, t.child = n, Gn = t, Kn = null, true) : false;
      default:
        return false;
    }
  }
  function _v(t) {
    return (t.mode & 1) !== 0 && (t.flags & 128) === 0;
  }
  function Dv(t) {
    if (ft) {
      var e = Kn;
      if (e) {
        var n = e;
        if (!KS(t, e)) {
          if (_v(t))
            throw Error(Z(418));
          e = zo(n.nextSibling);
          var r = Gn;
          e && KS(t, e) ? y2(r, n) : (t.flags = t.flags & -4097 | 2, ft = false, Gn = t);
        }
      } else {
        if (_v(t))
          throw Error(Z(418));
        t.flags = t.flags & -4097 | 2, ft = false, Gn = t;
      }
    }
  }
  function qS(t) {
    for (t = t.return; t !== null && t.tag !== 5 && t.tag !== 3 && t.tag !== 13; )
      t = t.return;
    Gn = t;
  }
  function eh(t) {
    if (t !== Gn)
      return false;
    if (!ft)
      return qS(t), ft = true, false;
    var e;
    if ((e = t.tag !== 3) && !(e = t.tag !== 5) && (e = t.type, e = e !== "head" && e !== "body" && !Pv(t.type, t.memoizedProps)), e && (e = Kn)) {
      if (_v(t))
        throw b2(), Error(Z(418));
      for (; e; )
        y2(t, e), e = zo(e.nextSibling);
    }
    if (qS(t), t.tag === 13) {
      if (t = t.memoizedState, t = t !== null ? t.dehydrated : null, !t)
        throw Error(Z(317));
      e: {
        for (t = t.nextSibling, e = 0; t; ) {
          if (t.nodeType === 8) {
            var n = t.data;
            if (n === "/$") {
              if (e === 0) {
                Kn = zo(t.nextSibling);
                break e;
              }
              e--;
            } else
              n !== "$" && n !== "$!" && n !== "$?" || e++;
          }
          t = t.nextSibling;
        }
        Kn = null;
      }
    } else
      Kn = Gn ? zo(t.stateNode.nextSibling) : null;
    return true;
  }
  function b2() {
    for (var t = Kn; t; )
      t = zo(t.nextSibling);
  }
  function nl() {
    Kn = Gn = null, ft = false;
  }
  function tb(t) {
    Nr === null ? Nr = [
      t
    ] : Nr.push(t);
  }
  var XD = io.ReactCurrentBatchConfig;
  function Dr(t, e) {
    if (t && t.defaultProps) {
      e = vt({}, e), t = t.defaultProps;
      for (var n in t)
        e[n] === void 0 && (e[n] = t[n]);
      return e;
    }
    return e;
  }
  var Ud = es(null), Kd = null, wa = null, nb = null;
  function rb() {
    nb = wa = Kd = null;
  }
  function ib(t) {
    var e = Ud.current;
    lt(Ud), t._currentValue = e;
  }
  function Iv(t, e, n) {
    for (; t !== null; ) {
      var r = t.alternate;
      if ((t.childLanes & e) !== e ? (t.childLanes |= e, r !== null && (r.childLanes |= e)) : r !== null && (r.childLanes & e) !== e && (r.childLanes |= e), t === n)
        break;
      t = t.return;
    }
  }
  function Fa(t, e) {
    Kd = t, nb = wa = null, t = t.dependencies, t !== null && t.firstContext !== null && ((t.lanes & e) !== 0 && (In = true), t.firstContext = null);
  }
  function wr(t) {
    var e = t._currentValue;
    if (nb !== t)
      if (t = {
        context: t,
        memoizedValue: e,
        next: null
      }, wa === null) {
        if (Kd === null)
          throw Error(Z(308));
        wa = t, Kd.dependencies = {
          lanes: 0,
          firstContext: t
        };
      } else
        wa = wa.next = t;
    return e;
  }
  var Ts = null;
  function ob(t) {
    Ts === null ? Ts = [
      t
    ] : Ts.push(t);
  }
  function x2(t, e, n, r) {
    var i = e.interleaved;
    return i === null ? (n.next = n, ob(e)) : (n.next = i.next, i.next = n), e.interleaved = n, Xi(t, r);
  }
  function Xi(t, e) {
    t.lanes |= e;
    var n = t.alternate;
    for (n !== null && (n.lanes |= e), n = t, t = t.return; t !== null; )
      t.childLanes |= e, n = t.alternate, n !== null && (n.childLanes |= e), n = t, t = t.return;
    return n.tag === 3 ? n.stateNode : null;
  }
  var bo = false;
  function sb(t) {
    t.updateQueue = {
      baseState: t.memoizedState,
      firstBaseUpdate: null,
      lastBaseUpdate: null,
      shared: {
        pending: null,
        interleaved: null,
        lanes: 0
      },
      effects: null
    };
  }
  function S2(t, e) {
    t = t.updateQueue, e.updateQueue === t && (e.updateQueue = {
      baseState: t.baseState,
      firstBaseUpdate: t.firstBaseUpdate,
      lastBaseUpdate: t.lastBaseUpdate,
      shared: t.shared,
      effects: t.effects
    });
  }
  function Ui(t, e) {
    return {
      eventTime: t,
      lane: e,
      tag: 0,
      payload: null,
      callback: null,
      next: null
    };
  }
  function Fo(t, e, n) {
    var r = t.updateQueue;
    if (r === null)
      return null;
    if (r = r.shared, (je & 2) !== 0) {
      var i = r.pending;
      return i === null ? e.next = e : (e.next = i.next, i.next = e), r.pending = e, Xi(t, n);
    }
    return i = r.interleaved, i === null ? (e.next = e, ob(r)) : (e.next = i.next, i.next = e), r.interleaved = e, Xi(t, n);
  }
  function Xh(t, e, n) {
    if (e = e.updateQueue, e !== null && (e = e.shared, (n & 4194240) !== 0)) {
      var r = e.lanes;
      r &= t.pendingLanes, n |= r, e.lanes = n, U1(t, n);
    }
  }
  function GS(t, e) {
    var n = t.updateQueue, r = t.alternate;
    if (r !== null && (r = r.updateQueue, n === r)) {
      var i = null, o = null;
      if (n = n.firstBaseUpdate, n !== null) {
        do {
          var s = {
            eventTime: n.eventTime,
            lane: n.lane,
            tag: n.tag,
            payload: n.payload,
            callback: n.callback,
            next: null
          };
          o === null ? i = o = s : o = o.next = s, n = n.next;
        } while (n !== null);
        o === null ? i = o = e : o = o.next = e;
      } else
        i = o = e;
      n = {
        baseState: r.baseState,
        firstBaseUpdate: i,
        lastBaseUpdate: o,
        shared: r.shared,
        effects: r.effects
      }, t.updateQueue = n;
      return;
    }
    t = n.lastBaseUpdate, t === null ? n.firstBaseUpdate = e : t.next = e, n.lastBaseUpdate = e;
  }
  function qd(t, e, n, r) {
    var i = t.updateQueue;
    bo = false;
    var o = i.firstBaseUpdate, s = i.lastBaseUpdate, a = i.shared.pending;
    if (a !== null) {
      i.shared.pending = null;
      var l = a, c = l.next;
      l.next = null, s === null ? o = c : s.next = c, s = l;
      var u = t.alternate;
      u !== null && (u = u.updateQueue, a = u.lastBaseUpdate, a !== s && (a === null ? u.firstBaseUpdate = c : a.next = c, u.lastBaseUpdate = l));
    }
    if (o !== null) {
      var h = i.baseState;
      s = 0, u = c = l = null, a = o;
      do {
        var p = a.lane, v = a.eventTime;
        if ((r & p) === p) {
          u !== null && (u = u.next = {
            eventTime: v,
            lane: 0,
            tag: a.tag,
            payload: a.payload,
            callback: a.callback,
            next: null
          });
          e: {
            var y = t, x = a;
            switch (p = e, v = n, x.tag) {
              case 1:
                if (y = x.payload, typeof y == "function") {
                  h = y.call(v, h, p);
                  break e;
                }
                h = y;
                break e;
              case 3:
                y.flags = y.flags & -65537 | 128;
              case 0:
                if (y = x.payload, p = typeof y == "function" ? y.call(v, h, p) : y, p == null)
                  break e;
                h = vt({}, h, p);
                break e;
              case 2:
                bo = true;
            }
          }
          a.callback !== null && a.lane !== 0 && (t.flags |= 64, p = i.effects, p === null ? i.effects = [
            a
          ] : p.push(a));
        } else
          v = {
            eventTime: v,
            lane: p,
            tag: a.tag,
            payload: a.payload,
            callback: a.callback,
            next: null
          }, u === null ? (c = u = v, l = h) : u = u.next = v, s |= p;
        if (a = a.next, a === null) {
          if (a = i.shared.pending, a === null)
            break;
          p = a, a = p.next, p.next = null, i.lastBaseUpdate = p, i.shared.pending = null;
        }
      } while (1);
      if (u === null && (l = h), i.baseState = l, i.firstBaseUpdate = c, i.lastBaseUpdate = u, e = i.shared.interleaved, e !== null) {
        i = e;
        do
          s |= i.lane, i = i.next;
        while (i !== e);
      } else
        o === null && (i.shared.lanes = 0);
      Vs |= s, t.lanes = s, t.memoizedState = h;
    }
  }
  function YS(t, e, n) {
    if (t = e.effects, e.effects = null, t !== null)
      for (e = 0; e < t.length; e++) {
        var r = t[e], i = r.callback;
        if (i !== null) {
          if (r.callback = null, r = n, typeof i != "function")
            throw Error(Z(191, i));
          i.call(r);
        }
      }
  }
  var w2 = new xM.Component().refs;
  function Bv(t, e, n, r) {
    e = t.memoizedState, n = n(r, e), n = n == null ? e : vt({}, e, n), t.memoizedState = n, t.lanes === 0 && (t.updateQueue.baseState = n);
  }
  var Qp = {
    isMounted: function(t) {
      return (t = t._reactInternals) ? Qs(t) === t : false;
    },
    enqueueSetState: function(t, e, n) {
      t = t._reactInternals;
      var r = wn(), i = Ho(t), o = Ui(r, i);
      o.payload = e, n != null && (o.callback = n), e = Fo(t, o, i), e !== null && (Vr(e, t, i, r), Xh(e, t, i));
    },
    enqueueReplaceState: function(t, e, n) {
      t = t._reactInternals;
      var r = wn(), i = Ho(t), o = Ui(r, i);
      o.tag = 1, o.payload = e, n != null && (o.callback = n), e = Fo(t, o, i), e !== null && (Vr(e, t, i, r), Xh(e, t, i));
    },
    enqueueForceUpdate: function(t, e) {
      t = t._reactInternals;
      var n = wn(), r = Ho(t), i = Ui(n, r);
      i.tag = 2, e != null && (i.callback = e), e = Fo(t, i, r), e !== null && (Vr(e, t, r, n), Xh(e, t, r));
    }
  };
  function XS(t, e, n, r, i, o, s) {
    return t = t.stateNode, typeof t.shouldComponentUpdate == "function" ? t.shouldComponentUpdate(r, o, s) : e.prototype && e.prototype.isPureReactComponent ? !uu(n, r) || !uu(i, o) : true;
  }
  function k2(t, e, n) {
    var r = false, i = Ko, o = e.contextType;
    return typeof o == "object" && o !== null ? o = wr(o) : (i = zn(e) ? $s : pn.current, r = e.contextTypes, o = (r = r != null) ? tl(t, i) : Ko), e = new e(n, o), t.memoizedState = e.state !== null && e.state !== void 0 ? e.state : null, e.updater = Qp, t.stateNode = e, e._reactInternals = t, r && (t = t.stateNode, t.__reactInternalMemoizedUnmaskedChildContext = i, t.__reactInternalMemoizedMaskedChildContext = o), e;
  }
  function QS(t, e, n, r) {
    t = e.state, typeof e.componentWillReceiveProps == "function" && e.componentWillReceiveProps(n, r), typeof e.UNSAFE_componentWillReceiveProps == "function" && e.UNSAFE_componentWillReceiveProps(n, r), e.state !== t && Qp.enqueueReplaceState(e, e.state, null);
  }
  function Nv(t, e, n, r) {
    var i = t.stateNode;
    i.props = n, i.state = t.memoizedState, i.refs = w2, sb(t);
    var o = e.contextType;
    typeof o == "object" && o !== null ? i.context = wr(o) : (o = zn(e) ? $s : pn.current, i.context = tl(t, o)), i.state = t.memoizedState, o = e.getDerivedStateFromProps, typeof o == "function" && (Bv(t, e, o, n), i.state = t.memoizedState), typeof e.getDerivedStateFromProps == "function" || typeof i.getSnapshotBeforeUpdate == "function" || typeof i.UNSAFE_componentWillMount != "function" && typeof i.componentWillMount != "function" || (e = i.state, typeof i.componentWillMount == "function" && i.componentWillMount(), typeof i.UNSAFE_componentWillMount == "function" && i.UNSAFE_componentWillMount(), e !== i.state && Qp.enqueueReplaceState(i, i.state, null), qd(t, n, i, r), i.state = t.memoizedState), typeof i.componentDidMount == "function" && (t.flags |= 4194308);
  }
  function Xl(t, e, n) {
    if (t = n.ref, t !== null && typeof t != "function" && typeof t != "object") {
      if (n._owner) {
        if (n = n._owner, n) {
          if (n.tag !== 1)
            throw Error(Z(309));
          var r = n.stateNode;
        }
        if (!r)
          throw Error(Z(147, t));
        var i = r, o = "" + t;
        return e !== null && e.ref !== null && typeof e.ref == "function" && e.ref._stringRef === o ? e.ref : (e = function(s) {
          var a = i.refs;
          a === w2 && (a = i.refs = {}), s === null ? delete a[o] : a[o] = s;
        }, e._stringRef = o, e);
      }
      if (typeof t != "string")
        throw Error(Z(284));
      if (!n._owner)
        throw Error(Z(290, t));
    }
    return t;
  }
  function th(t, e) {
    throw t = Object.prototype.toString.call(e), Error(Z(31, t === "[object Object]" ? "object with keys {" + Object.keys(e).join(", ") + "}" : t));
  }
  function JS(t) {
    var e = t._init;
    return e(t._payload);
  }
  function C2(t) {
    function e(w, k) {
      if (t) {
        var C = w.deletions;
        C === null ? (w.deletions = [
          k
        ], w.flags |= 16) : C.push(k);
      }
    }
    function n(w, k) {
      if (!t)
        return null;
      for (; k !== null; )
        e(w, k), k = k.sibling;
      return null;
    }
    function r(w, k) {
      for (w = /* @__PURE__ */ new Map(); k !== null; )
        k.key !== null ? w.set(k.key, k) : w.set(k.index, k), k = k.sibling;
      return w;
    }
    function i(w, k) {
      return w = jo(w, k), w.index = 0, w.sibling = null, w;
    }
    function o(w, k, C) {
      return w.index = C, t ? (C = w.alternate, C !== null ? (C = C.index, C < k ? (w.flags |= 2, k) : C) : (w.flags |= 2, k)) : (w.flags |= 1048576, k);
    }
    function s(w) {
      return t && w.alternate === null && (w.flags |= 2), w;
    }
    function a(w, k, C, P) {
      return k === null || k.tag !== 6 ? (k = Yg(C, w.mode, P), k.return = w, k) : (k = i(k, C), k.return = w, k);
    }
    function l(w, k, C, P) {
      var R = C.type;
      return R === pa ? u(w, k, C.props.children, P, C.key) : k !== null && (k.elementType === R || typeof R == "object" && R !== null && R.$$typeof === yo && JS(R) === k.type) ? (P = i(k, C.props), P.ref = Xl(w, k, C), P.return = w, P) : (P = nd(C.type, C.key, C.props, null, w.mode, P), P.ref = Xl(w, k, C), P.return = w, P);
    }
    function c(w, k, C, P) {
      return k === null || k.tag !== 4 || k.stateNode.containerInfo !== C.containerInfo || k.stateNode.implementation !== C.implementation ? (k = Xg(C, w.mode, P), k.return = w, k) : (k = i(k, C.children || []), k.return = w, k);
    }
    function u(w, k, C, P, R) {
      return k === null || k.tag !== 7 ? (k = Ls(C, w.mode, P, R), k.return = w, k) : (k = i(k, C), k.return = w, k);
    }
    function h(w, k, C) {
      if (typeof k == "string" && k !== "" || typeof k == "number")
        return k = Yg("" + k, w.mode, C), k.return = w, k;
      if (typeof k == "object" && k !== null) {
        switch (k.$$typeof) {
          case Wf:
            return C = nd(k.type, k.key, k.props, null, w.mode, C), C.ref = Xl(w, null, k), C.return = w, C;
          case da:
            return k = Xg(k, w.mode, C), k.return = w, k;
          case yo:
            var P = k._init;
            return h(w, P(k._payload), C);
        }
        if (hc(k) || Ul(k))
          return k = Ls(k, w.mode, C, null), k.return = w, k;
        th(w, k);
      }
      return null;
    }
    function p(w, k, C, P) {
      var R = k !== null ? k.key : null;
      if (typeof C == "string" && C !== "" || typeof C == "number")
        return R !== null ? null : a(w, k, "" + C, P);
      if (typeof C == "object" && C !== null) {
        switch (C.$$typeof) {
          case Wf:
            return C.key === R ? l(w, k, C, P) : null;
          case da:
            return C.key === R ? c(w, k, C, P) : null;
          case yo:
            return R = C._init, p(w, k, R(C._payload), P);
        }
        if (hc(C) || Ul(C))
          return R !== null ? null : u(w, k, C, P, null);
        th(w, C);
      }
      return null;
    }
    function v(w, k, C, P, R) {
      if (typeof P == "string" && P !== "" || typeof P == "number")
        return w = w.get(C) || null, a(k, w, "" + P, R);
      if (typeof P == "object" && P !== null) {
        switch (P.$$typeof) {
          case Wf:
            return w = w.get(P.key === null ? C : P.key) || null, l(k, w, P, R);
          case da:
            return w = w.get(P.key === null ? C : P.key) || null, c(k, w, P, R);
          case yo:
            var L = P._init;
            return v(w, k, C, L(P._payload), R);
        }
        if (hc(P) || Ul(P))
          return w = w.get(C) || null, u(k, w, P, R, null);
        th(k, P);
      }
      return null;
    }
    function y(w, k, C, P) {
      for (var R = null, L = null, _ = k, F = k = 0, K = null; _ !== null && F < C.length; F++) {
        _.index > F ? (K = _, _ = null) : K = _.sibling;
        var Y = p(w, _, C[F], P);
        if (Y === null) {
          _ === null && (_ = K);
          break;
        }
        t && _ && Y.alternate === null && e(w, _), k = o(Y, k, F), L === null ? R = Y : L.sibling = Y, L = Y, _ = K;
      }
      if (F === C.length)
        return n(w, _), ft && vs(w, F), R;
      if (_ === null) {
        for (; F < C.length; F++)
          _ = h(w, C[F], P), _ !== null && (k = o(_, k, F), L === null ? R = _ : L.sibling = _, L = _);
        return ft && vs(w, F), R;
      }
      for (_ = r(w, _); F < C.length; F++)
        K = v(_, w, F, C[F], P), K !== null && (t && K.alternate !== null && _.delete(K.key === null ? F : K.key), k = o(K, k, F), L === null ? R = K : L.sibling = K, L = K);
      return t && _.forEach(function(te) {
        return e(w, te);
      }), ft && vs(w, F), R;
    }
    function x(w, k, C, P) {
      var R = Ul(C);
      if (typeof R != "function")
        throw Error(Z(150));
      if (C = R.call(C), C == null)
        throw Error(Z(151));
      for (var L = R = null, _ = k, F = k = 0, K = null, Y = C.next(); _ !== null && !Y.done; F++, Y = C.next()) {
        _.index > F ? (K = _, _ = null) : K = _.sibling;
        var te = p(w, _, Y.value, P);
        if (te === null) {
          _ === null && (_ = K);
          break;
        }
        t && _ && te.alternate === null && e(w, _), k = o(te, k, F), L === null ? R = te : L.sibling = te, L = te, _ = K;
      }
      if (Y.done)
        return n(w, _), ft && vs(w, F), R;
      if (_ === null) {
        for (; !Y.done; F++, Y = C.next())
          Y = h(w, Y.value, P), Y !== null && (k = o(Y, k, F), L === null ? R = Y : L.sibling = Y, L = Y);
        return ft && vs(w, F), R;
      }
      for (_ = r(w, _); !Y.done; F++, Y = C.next())
        Y = v(_, w, F, Y.value, P), Y !== null && (t && Y.alternate !== null && _.delete(Y.key === null ? F : Y.key), k = o(Y, k, F), L === null ? R = Y : L.sibling = Y, L = Y);
      return t && _.forEach(function(ne) {
        return e(w, ne);
      }), ft && vs(w, F), R;
    }
    function T(w, k, C, P) {
      if (typeof C == "object" && C !== null && C.type === pa && C.key === null && (C = C.props.children), typeof C == "object" && C !== null) {
        switch (C.$$typeof) {
          case Wf:
            e: {
              for (var R = C.key, L = k; L !== null; ) {
                if (L.key === R) {
                  if (R = C.type, R === pa) {
                    if (L.tag === 7) {
                      n(w, L.sibling), k = i(L, C.props.children), k.return = w, w = k;
                      break e;
                    }
                  } else if (L.elementType === R || typeof R == "object" && R !== null && R.$$typeof === yo && JS(R) === L.type) {
                    n(w, L.sibling), k = i(L, C.props), k.ref = Xl(w, L, C), k.return = w, w = k;
                    break e;
                  }
                  n(w, L);
                  break;
                } else
                  e(w, L);
                L = L.sibling;
              }
              C.type === pa ? (k = Ls(C.props.children, w.mode, P, C.key), k.return = w, w = k) : (P = nd(C.type, C.key, C.props, null, w.mode, P), P.ref = Xl(w, k, C), P.return = w, w = P);
            }
            return s(w);
          case da:
            e: {
              for (L = C.key; k !== null; ) {
                if (k.key === L)
                  if (k.tag === 4 && k.stateNode.containerInfo === C.containerInfo && k.stateNode.implementation === C.implementation) {
                    n(w, k.sibling), k = i(k, C.children || []), k.return = w, w = k;
                    break e;
                  } else {
                    n(w, k);
                    break;
                  }
                else
                  e(w, k);
                k = k.sibling;
              }
              k = Xg(C, w.mode, P), k.return = w, w = k;
            }
            return s(w);
          case yo:
            return L = C._init, T(w, k, L(C._payload), P);
        }
        if (hc(C))
          return y(w, k, C, P);
        if (Ul(C))
          return x(w, k, C, P);
        th(w, C);
      }
      return typeof C == "string" && C !== "" || typeof C == "number" ? (C = "" + C, k !== null && k.tag === 6 ? (n(w, k.sibling), k = i(k, C), k.return = w, w = k) : (n(w, k), k = Yg(C, w.mode, P), k.return = w, w = k), s(w)) : n(w, k);
    }
    return T;
  }
  var rl = C2(true), T2 = C2(false), Qu = {}, Si = es(Qu), pu = es(Qu), mu = es(Qu);
  function Ms(t) {
    if (t === Qu)
      throw Error(Z(174));
    return t;
  }
  function ab(t, e) {
    switch (nt(mu, e), nt(pu, t), nt(Si, Qu), t = e.nodeType, t) {
      case 9:
      case 11:
        e = (e = e.documentElement) ? e.namespaceURI : mv(null, "");
        break;
      default:
        t = t === 8 ? e.parentNode : e, e = t.namespaceURI || null, t = t.tagName, e = mv(e, t);
    }
    lt(Si), nt(Si, e);
  }
  function il() {
    lt(Si), lt(pu), lt(mu);
  }
  function M2(t) {
    Ms(mu.current);
    var e = Ms(Si.current), n = mv(e, t.type);
    e !== n && (nt(pu, t), nt(Si, n));
  }
  function lb(t) {
    pu.current === t && (lt(Si), lt(pu));
  }
  var mt = es(0);
  function Gd(t) {
    for (var e = t; e !== null; ) {
      if (e.tag === 13) {
        var n = e.memoizedState;
        if (n !== null && (n = n.dehydrated, n === null || n.data === "$?" || n.data === "$!"))
          return e;
      } else if (e.tag === 19 && e.memoizedProps.revealOrder !== void 0) {
        if ((e.flags & 128) !== 0)
          return e;
      } else if (e.child !== null) {
        e.child.return = e, e = e.child;
        continue;
      }
      if (e === t)
        break;
      for (; e.sibling === null; ) {
        if (e.return === null || e.return === t)
          return null;
        e = e.return;
      }
      e.sibling.return = e.return, e = e.sibling;
    }
    return null;
  }
  var jg = [];
  function cb() {
    for (var t = 0; t < jg.length; t++)
      jg[t]._workInProgressVersionPrimary = null;
    jg.length = 0;
  }
  var Qh = io.ReactCurrentDispatcher, Wg = io.ReactCurrentBatchConfig, Fs = 0, gt = null, _t = null, Vt = null, Yd = false, Rc = false, gu = 0, QD = 0;
  function sn() {
    throw Error(Z(321));
  }
  function ub(t, e) {
    if (e === null)
      return false;
    for (var n = 0; n < e.length && n < t.length; n++)
      if (!Ur(t[n], e[n]))
        return false;
    return true;
  }
  function fb(t, e, n, r, i, o) {
    if (Fs = o, gt = e, e.memoizedState = null, e.updateQueue = null, e.lanes = 0, Qh.current = t === null || t.memoizedState === null ? tI : nI, t = n(r, i), Rc) {
      o = 0;
      do {
        if (Rc = false, gu = 0, 25 <= o)
          throw Error(Z(301));
        o += 1, Vt = _t = null, e.updateQueue = null, Qh.current = rI, t = n(r, i);
      } while (Rc);
    }
    if (Qh.current = Xd, e = _t !== null && _t.next !== null, Fs = 0, Vt = _t = gt = null, Yd = false, e)
      throw Error(Z(300));
    return t;
  }
  function hb() {
    var t = gu !== 0;
    return gu = 0, t;
  }
  function ai() {
    var t = {
      memoizedState: null,
      baseState: null,
      baseQueue: null,
      queue: null,
      next: null
    };
    return Vt === null ? gt.memoizedState = Vt = t : Vt = Vt.next = t, Vt;
  }
  function kr() {
    if (_t === null) {
      var t = gt.alternate;
      t = t !== null ? t.memoizedState : null;
    } else
      t = _t.next;
    var e = Vt === null ? gt.memoizedState : Vt.next;
    if (e !== null)
      Vt = e, _t = t;
    else {
      if (t === null)
        throw Error(Z(310));
      _t = t, t = {
        memoizedState: _t.memoizedState,
        baseState: _t.baseState,
        baseQueue: _t.baseQueue,
        queue: _t.queue,
        next: null
      }, Vt === null ? gt.memoizedState = Vt = t : Vt = Vt.next = t;
    }
    return Vt;
  }
  function vu(t, e) {
    return typeof e == "function" ? e(t) : e;
  }
  function Ug(t) {
    var e = kr(), n = e.queue;
    if (n === null)
      throw Error(Z(311));
    n.lastRenderedReducer = t;
    var r = _t, i = r.baseQueue, o = n.pending;
    if (o !== null) {
      if (i !== null) {
        var s = i.next;
        i.next = o.next, o.next = s;
      }
      r.baseQueue = i = o, n.pending = null;
    }
    if (i !== null) {
      o = i.next, r = r.baseState;
      var a = s = null, l = null, c = o;
      do {
        var u = c.lane;
        if ((Fs & u) === u)
          l !== null && (l = l.next = {
            lane: 0,
            action: c.action,
            hasEagerState: c.hasEagerState,
            eagerState: c.eagerState,
            next: null
          }), r = c.hasEagerState ? c.eagerState : t(r, c.action);
        else {
          var h = {
            lane: u,
            action: c.action,
            hasEagerState: c.hasEagerState,
            eagerState: c.eagerState,
            next: null
          };
          l === null ? (a = l = h, s = r) : l = l.next = h, gt.lanes |= u, Vs |= u;
        }
        c = c.next;
      } while (c !== null && c !== o);
      l === null ? s = r : l.next = a, Ur(r, e.memoizedState) || (In = true), e.memoizedState = r, e.baseState = s, e.baseQueue = l, n.lastRenderedState = r;
    }
    if (t = n.interleaved, t !== null) {
      i = t;
      do
        o = i.lane, gt.lanes |= o, Vs |= o, i = i.next;
      while (i !== t);
    } else
      i === null && (n.lanes = 0);
    return [
      e.memoizedState,
      n.dispatch
    ];
  }
  function Kg(t) {
    var e = kr(), n = e.queue;
    if (n === null)
      throw Error(Z(311));
    n.lastRenderedReducer = t;
    var r = n.dispatch, i = n.pending, o = e.memoizedState;
    if (i !== null) {
      n.pending = null;
      var s = i = i.next;
      do
        o = t(o, s.action), s = s.next;
      while (s !== i);
      Ur(o, e.memoizedState) || (In = true), e.memoizedState = o, e.baseQueue === null && (e.baseState = o), n.lastRenderedState = o;
    }
    return [
      o,
      r
    ];
  }
  function A2() {
  }
  function E2(t, e) {
    var n = gt, r = kr(), i = e(), o = !Ur(r.memoizedState, i);
    if (o && (r.memoizedState = i, In = true), r = r.queue, db(R2.bind(null, n, r, t), [
      t
    ]), r.getSnapshot !== e || o || Vt !== null && Vt.memoizedState.tag & 1) {
      if (n.flags |= 2048, yu(9, O2.bind(null, n, r, i, e), void 0, null), jt === null)
        throw Error(Z(349));
      (Fs & 30) !== 0 || P2(n, e, i);
    }
    return i;
  }
  function P2(t, e, n) {
    t.flags |= 16384, t = {
      getSnapshot: e,
      value: n
    }, e = gt.updateQueue, e === null ? (e = {
      lastEffect: null,
      stores: null
    }, gt.updateQueue = e, e.stores = [
      t
    ]) : (n = e.stores, n === null ? e.stores = [
      t
    ] : n.push(t));
  }
  function O2(t, e, n, r) {
    e.value = n, e.getSnapshot = r, L2(e) && _2(t);
  }
  function R2(t, e, n) {
    return n(function() {
      L2(e) && _2(t);
    });
  }
  function L2(t) {
    var e = t.getSnapshot;
    t = t.value;
    try {
      var n = e();
      return !Ur(t, n);
    } catch {
      return true;
    }
  }
  function _2(t) {
    var e = Xi(t, 1);
    e !== null && Vr(e, t, 1, -1);
  }
  function ZS(t) {
    var e = ai();
    return typeof t == "function" && (t = t()), e.memoizedState = e.baseState = t, t = {
      pending: null,
      interleaved: null,
      lanes: 0,
      dispatch: null,
      lastRenderedReducer: vu,
      lastRenderedState: t
    }, e.queue = t, t = t.dispatch = eI.bind(null, gt, t), [
      e.memoizedState,
      t
    ];
  }
  function yu(t, e, n, r) {
    return t = {
      tag: t,
      create: e,
      destroy: n,
      deps: r,
      next: null
    }, e = gt.updateQueue, e === null ? (e = {
      lastEffect: null,
      stores: null
    }, gt.updateQueue = e, e.lastEffect = t.next = t) : (n = e.lastEffect, n === null ? e.lastEffect = t.next = t : (r = n.next, n.next = t, t.next = r, e.lastEffect = t)), t;
  }
  function D2() {
    return kr().memoizedState;
  }
  function Jh(t, e, n, r) {
    var i = ai();
    gt.flags |= t, i.memoizedState = yu(1 | e, n, void 0, r === void 0 ? null : r);
  }
  function Jp(t, e, n, r) {
    var i = kr();
    r = r === void 0 ? null : r;
    var o = void 0;
    if (_t !== null) {
      var s = _t.memoizedState;
      if (o = s.destroy, r !== null && ub(r, s.deps)) {
        i.memoizedState = yu(e, n, o, r);
        return;
      }
    }
    gt.flags |= t, i.memoizedState = yu(1 | e, n, o, r);
  }
  function ew(t, e) {
    return Jh(8390656, 8, t, e);
  }
  function db(t, e) {
    return Jp(2048, 8, t, e);
  }
  function I2(t, e) {
    return Jp(4, 2, t, e);
  }
  function B2(t, e) {
    return Jp(4, 4, t, e);
  }
  function N2(t, e) {
    if (typeof e == "function")
      return t = t(), e(t), function() {
        e(null);
      };
    if (e != null)
      return t = t(), e.current = t, function() {
        e.current = null;
      };
  }
  function $2(t, e, n) {
    return n = n != null ? n.concat([
      t
    ]) : null, Jp(4, 4, N2.bind(null, e, t), n);
  }
  function pb() {
  }
  function z2(t, e) {
    var n = kr();
    e = e === void 0 ? null : e;
    var r = n.memoizedState;
    return r !== null && e !== null && ub(e, r[1]) ? r[0] : (n.memoizedState = [
      t,
      e
    ], t);
  }
  function F2(t, e) {
    var n = kr();
    e = e === void 0 ? null : e;
    var r = n.memoizedState;
    return r !== null && e !== null && ub(e, r[1]) ? r[0] : (t = t(), n.memoizedState = [
      t,
      e
    ], t);
  }
  function V2(t, e, n) {
    return (Fs & 21) === 0 ? (t.baseState && (t.baseState = false, In = true), t.memoizedState = n) : (Ur(n, e) || (n = WM(), gt.lanes |= n, Vs |= n, t.baseState = true), e);
  }
  function JD(t, e) {
    var n = Ye;
    Ye = n !== 0 && 4 > n ? n : 4, t(true);
    var r = Wg.transition;
    Wg.transition = {};
    try {
      t(false), e();
    } finally {
      Ye = n, Wg.transition = r;
    }
  }
  function H2() {
    return kr().memoizedState;
  }
  function ZD(t, e, n) {
    var r = Ho(t);
    if (n = {
      lane: r,
      action: n,
      hasEagerState: false,
      eagerState: null,
      next: null
    }, j2(t))
      W2(e, n);
    else if (n = x2(t, e, n, r), n !== null) {
      var i = wn();
      Vr(n, t, r, i), U2(n, e, r);
    }
  }
  function eI(t, e, n) {
    var r = Ho(t), i = {
      lane: r,
      action: n,
      hasEagerState: false,
      eagerState: null,
      next: null
    };
    if (j2(t))
      W2(e, i);
    else {
      var o = t.alternate;
      if (t.lanes === 0 && (o === null || o.lanes === 0) && (o = e.lastRenderedReducer, o !== null))
        try {
          var s = e.lastRenderedState, a = o(s, n);
          if (i.hasEagerState = true, i.eagerState = a, Ur(a, s)) {
            var l = e.interleaved;
            l === null ? (i.next = i, ob(e)) : (i.next = l.next, l.next = i), e.interleaved = i;
            return;
          }
        } catch {
        } finally {
        }
      n = x2(t, e, i, r), n !== null && (i = wn(), Vr(n, t, r, i), U2(n, e, r));
    }
  }
  function j2(t) {
    var e = t.alternate;
    return t === gt || e !== null && e === gt;
  }
  function W2(t, e) {
    Rc = Yd = true;
    var n = t.pending;
    n === null ? e.next = e : (e.next = n.next, n.next = e), t.pending = e;
  }
  function U2(t, e, n) {
    if ((n & 4194240) !== 0) {
      var r = e.lanes;
      r &= t.pendingLanes, n |= r, e.lanes = n, U1(t, n);
    }
  }
  var Xd = {
    readContext: wr,
    useCallback: sn,
    useContext: sn,
    useEffect: sn,
    useImperativeHandle: sn,
    useInsertionEffect: sn,
    useLayoutEffect: sn,
    useMemo: sn,
    useReducer: sn,
    useRef: sn,
    useState: sn,
    useDebugValue: sn,
    useDeferredValue: sn,
    useTransition: sn,
    useMutableSource: sn,
    useSyncExternalStore: sn,
    useId: sn,
    unstable_isNewReconciler: false
  }, tI = {
    readContext: wr,
    useCallback: function(t, e) {
      return ai().memoizedState = [
        t,
        e === void 0 ? null : e
      ], t;
    },
    useContext: wr,
    useEffect: ew,
    useImperativeHandle: function(t, e, n) {
      return n = n != null ? n.concat([
        t
      ]) : null, Jh(4194308, 4, N2.bind(null, e, t), n);
    },
    useLayoutEffect: function(t, e) {
      return Jh(4194308, 4, t, e);
    },
    useInsertionEffect: function(t, e) {
      return Jh(4, 2, t, e);
    },
    useMemo: function(t, e) {
      var n = ai();
      return e = e === void 0 ? null : e, t = t(), n.memoizedState = [
        t,
        e
      ], t;
    },
    useReducer: function(t, e, n) {
      var r = ai();
      return e = n !== void 0 ? n(e) : e, r.memoizedState = r.baseState = e, t = {
        pending: null,
        interleaved: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: t,
        lastRenderedState: e
      }, r.queue = t, t = t.dispatch = ZD.bind(null, gt, t), [
        r.memoizedState,
        t
      ];
    },
    useRef: function(t) {
      var e = ai();
      return t = {
        current: t
      }, e.memoizedState = t;
    },
    useState: ZS,
    useDebugValue: pb,
    useDeferredValue: function(t) {
      return ai().memoizedState = t;
    },
    useTransition: function() {
      var t = ZS(false), e = t[0];
      return t = JD.bind(null, t[1]), ai().memoizedState = t, [
        e,
        t
      ];
    },
    useMutableSource: function() {
    },
    useSyncExternalStore: function(t, e, n) {
      var r = gt, i = ai();
      if (ft) {
        if (n === void 0)
          throw Error(Z(407));
        n = n();
      } else {
        if (n = e(), jt === null)
          throw Error(Z(349));
        (Fs & 30) !== 0 || P2(r, e, n);
      }
      i.memoizedState = n;
      var o = {
        value: n,
        getSnapshot: e
      };
      return i.queue = o, ew(R2.bind(null, r, o, t), [
        t
      ]), r.flags |= 2048, yu(9, O2.bind(null, r, o, n, e), void 0, null), n;
    },
    useId: function() {
      var t = ai(), e = jt.identifierPrefix;
      if (ft) {
        var n = ji, r = Hi;
        n = (r & ~(1 << 32 - Fr(r) - 1)).toString(32) + n, e = ":" + e + "R" + n, n = gu++, 0 < n && (e += "H" + n.toString(32)), e += ":";
      } else
        n = QD++, e = ":" + e + "r" + n.toString(32) + ":";
      return t.memoizedState = e;
    },
    unstable_isNewReconciler: false
  }, nI = {
    readContext: wr,
    useCallback: z2,
    useContext: wr,
    useEffect: db,
    useImperativeHandle: $2,
    useInsertionEffect: I2,
    useLayoutEffect: B2,
    useMemo: F2,
    useReducer: Ug,
    useRef: D2,
    useState: function() {
      return Ug(vu);
    },
    useDebugValue: pb,
    useDeferredValue: function(t) {
      var e = kr();
      return V2(e, _t.memoizedState, t);
    },
    useTransition: function() {
      var t = Ug(vu)[0], e = kr().memoizedState;
      return [
        t,
        e
      ];
    },
    useMutableSource: A2,
    useSyncExternalStore: E2,
    useId: H2,
    unstable_isNewReconciler: false
  }, rI = {
    readContext: wr,
    useCallback: z2,
    useContext: wr,
    useEffect: db,
    useImperativeHandle: $2,
    useInsertionEffect: I2,
    useLayoutEffect: B2,
    useMemo: F2,
    useReducer: Kg,
    useRef: D2,
    useState: function() {
      return Kg(vu);
    },
    useDebugValue: pb,
    useDeferredValue: function(t) {
      var e = kr();
      return _t === null ? e.memoizedState = t : V2(e, _t.memoizedState, t);
    },
    useTransition: function() {
      var t = Kg(vu)[0], e = kr().memoizedState;
      return [
        t,
        e
      ];
    },
    useMutableSource: A2,
    useSyncExternalStore: E2,
    useId: H2,
    unstable_isNewReconciler: false
  };
  function ol(t, e) {
    try {
      var n = "", r = e;
      do
        n += R_(r), r = r.return;
      while (r);
      var i = n;
    } catch (o) {
      i = `
Error generating stack: ` + o.message + `
` + o.stack;
    }
    return {
      value: t,
      source: e,
      stack: i,
      digest: null
    };
  }
  function qg(t, e, n) {
    return {
      value: t,
      source: null,
      stack: n ?? null,
      digest: e ?? null
    };
  }
  function $v(t, e) {
    try {
      console.error(e.value);
    } catch (n) {
      setTimeout(function() {
        throw n;
      });
    }
  }
  var iI = typeof WeakMap == "function" ? WeakMap : Map;
  function K2(t, e, n) {
    n = Ui(-1, n), n.tag = 3, n.payload = {
      element: null
    };
    var r = e.value;
    return n.callback = function() {
      Jd || (Jd = true, Gv = r), $v(t, e);
    }, n;
  }
  function q2(t, e, n) {
    n = Ui(-1, n), n.tag = 3;
    var r = t.type.getDerivedStateFromError;
    if (typeof r == "function") {
      var i = e.value;
      n.payload = function() {
        return r(i);
      }, n.callback = function() {
        $v(t, e);
      };
    }
    var o = t.stateNode;
    return o !== null && typeof o.componentDidCatch == "function" && (n.callback = function() {
      $v(t, e), typeof r != "function" && (Vo === null ? Vo = /* @__PURE__ */ new Set([
        this
      ]) : Vo.add(this));
      var s = e.stack;
      this.componentDidCatch(e.value, {
        componentStack: s !== null ? s : ""
      });
    }), n;
  }
  function tw(t, e, n) {
    var r = t.pingCache;
    if (r === null) {
      r = t.pingCache = new iI();
      var i = /* @__PURE__ */ new Set();
      r.set(e, i);
    } else
      i = r.get(e), i === void 0 && (i = /* @__PURE__ */ new Set(), r.set(e, i));
    i.has(n) || (i.add(n), t = yI.bind(null, t, e, n), e.then(t, t));
  }
  function nw(t) {
    do {
      var e;
      if ((e = t.tag === 13) && (e = t.memoizedState, e = e !== null ? e.dehydrated !== null : true), e)
        return t;
      t = t.return;
    } while (t !== null);
    return null;
  }
  function rw(t, e, n, r, i) {
    return (t.mode & 1) === 0 ? (t === e ? t.flags |= 65536 : (t.flags |= 128, n.flags |= 131072, n.flags &= -52805, n.tag === 1 && (n.alternate === null ? n.tag = 17 : (e = Ui(-1, 1), e.tag = 2, Fo(n, e, 1))), n.lanes |= 1), t) : (t.flags |= 65536, t.lanes = i, t);
  }
  var oI = io.ReactCurrentOwner, In = false;
  function bn(t, e, n, r) {
    e.child = t === null ? T2(e, null, n, r) : rl(e, t.child, n, r);
  }
  function iw(t, e, n, r, i) {
    n = n.render;
    var o = e.ref;
    return Fa(e, i), r = fb(t, e, n, r, o, i), n = hb(), t !== null && !In ? (e.updateQueue = t.updateQueue, e.flags &= -2053, t.lanes &= ~i, Qi(t, e, i)) : (ft && n && Z1(e), e.flags |= 1, bn(t, e, r, i), e.child);
  }
  function ow(t, e, n, r, i) {
    if (t === null) {
      var o = n.type;
      return typeof o == "function" && !wb(o) && o.defaultProps === void 0 && n.compare === null && n.defaultProps === void 0 ? (e.tag = 15, e.type = o, G2(t, e, o, r, i)) : (t = nd(n.type, null, r, e, e.mode, i), t.ref = e.ref, t.return = e, e.child = t);
    }
    if (o = t.child, (t.lanes & i) === 0) {
      var s = o.memoizedProps;
      if (n = n.compare, n = n !== null ? n : uu, n(s, r) && t.ref === e.ref)
        return Qi(t, e, i);
    }
    return e.flags |= 1, t = jo(o, r), t.ref = e.ref, t.return = e, e.child = t;
  }
  function G2(t, e, n, r, i) {
    if (t !== null) {
      var o = t.memoizedProps;
      if (uu(o, r) && t.ref === e.ref)
        if (In = false, e.pendingProps = r = o, (t.lanes & i) !== 0)
          (t.flags & 131072) !== 0 && (In = true);
        else
          return e.lanes = t.lanes, Qi(t, e, i);
    }
    return zv(t, e, n, r, i);
  }
  function Y2(t, e, n) {
    var r = e.pendingProps, i = r.children, o = t !== null ? t.memoizedState : null;
    if (r.mode === "hidden")
      if ((e.mode & 1) === 0)
        e.memoizedState = {
          baseLanes: 0,
          cachePool: null,
          transitions: null
        }, nt(Ca, Wn), Wn |= n;
      else {
        if ((n & 1073741824) === 0)
          return t = o !== null ? o.baseLanes | n : n, e.lanes = e.childLanes = 1073741824, e.memoizedState = {
            baseLanes: t,
            cachePool: null,
            transitions: null
          }, e.updateQueue = null, nt(Ca, Wn), Wn |= t, null;
        e.memoizedState = {
          baseLanes: 0,
          cachePool: null,
          transitions: null
        }, r = o !== null ? o.baseLanes : n, nt(Ca, Wn), Wn |= r;
      }
    else
      o !== null ? (r = o.baseLanes | n, e.memoizedState = null) : r = n, nt(Ca, Wn), Wn |= r;
    return bn(t, e, i, n), e.child;
  }
  function X2(t, e) {
    var n = e.ref;
    (t === null && n !== null || t !== null && t.ref !== n) && (e.flags |= 512, e.flags |= 2097152);
  }
  function zv(t, e, n, r, i) {
    var o = zn(n) ? $s : pn.current;
    return o = tl(e, o), Fa(e, i), n = fb(t, e, n, r, o, i), r = hb(), t !== null && !In ? (e.updateQueue = t.updateQueue, e.flags &= -2053, t.lanes &= ~i, Qi(t, e, i)) : (ft && r && Z1(e), e.flags |= 1, bn(t, e, n, i), e.child);
  }
  function sw(t, e, n, r, i) {
    if (zn(n)) {
      var o = true;
      Hd(e);
    } else
      o = false;
    if (Fa(e, i), e.stateNode === null)
      Zh(t, e), k2(e, n, r), Nv(e, n, r, i), r = true;
    else if (t === null) {
      var s = e.stateNode, a = e.memoizedProps;
      s.props = a;
      var l = s.context, c = n.contextType;
      typeof c == "object" && c !== null ? c = wr(c) : (c = zn(n) ? $s : pn.current, c = tl(e, c));
      var u = n.getDerivedStateFromProps, h = typeof u == "function" || typeof s.getSnapshotBeforeUpdate == "function";
      h || typeof s.UNSAFE_componentWillReceiveProps != "function" && typeof s.componentWillReceiveProps != "function" || (a !== r || l !== c) && QS(e, s, r, c), bo = false;
      var p = e.memoizedState;
      s.state = p, qd(e, r, s, i), l = e.memoizedState, a !== r || p !== l || $n.current || bo ? (typeof u == "function" && (Bv(e, n, u, r), l = e.memoizedState), (a = bo || XS(e, n, a, r, p, l, c)) ? (h || typeof s.UNSAFE_componentWillMount != "function" && typeof s.componentWillMount != "function" || (typeof s.componentWillMount == "function" && s.componentWillMount(), typeof s.UNSAFE_componentWillMount == "function" && s.UNSAFE_componentWillMount()), typeof s.componentDidMount == "function" && (e.flags |= 4194308)) : (typeof s.componentDidMount == "function" && (e.flags |= 4194308), e.memoizedProps = r, e.memoizedState = l), s.props = r, s.state = l, s.context = c, r = a) : (typeof s.componentDidMount == "function" && (e.flags |= 4194308), r = false);
    } else {
      s = e.stateNode, S2(t, e), a = e.memoizedProps, c = e.type === e.elementType ? a : Dr(e.type, a), s.props = c, h = e.pendingProps, p = s.context, l = n.contextType, typeof l == "object" && l !== null ? l = wr(l) : (l = zn(n) ? $s : pn.current, l = tl(e, l));
      var v = n.getDerivedStateFromProps;
      (u = typeof v == "function" || typeof s.getSnapshotBeforeUpdate == "function") || typeof s.UNSAFE_componentWillReceiveProps != "function" && typeof s.componentWillReceiveProps != "function" || (a !== h || p !== l) && QS(e, s, r, l), bo = false, p = e.memoizedState, s.state = p, qd(e, r, s, i);
      var y = e.memoizedState;
      a !== h || p !== y || $n.current || bo ? (typeof v == "function" && (Bv(e, n, v, r), y = e.memoizedState), (c = bo || XS(e, n, c, r, p, y, l) || false) ? (u || typeof s.UNSAFE_componentWillUpdate != "function" && typeof s.componentWillUpdate != "function" || (typeof s.componentWillUpdate == "function" && s.componentWillUpdate(r, y, l), typeof s.UNSAFE_componentWillUpdate == "function" && s.UNSAFE_componentWillUpdate(r, y, l)), typeof s.componentDidUpdate == "function" && (e.flags |= 4), typeof s.getSnapshotBeforeUpdate == "function" && (e.flags |= 1024)) : (typeof s.componentDidUpdate != "function" || a === t.memoizedProps && p === t.memoizedState || (e.flags |= 4), typeof s.getSnapshotBeforeUpdate != "function" || a === t.memoizedProps && p === t.memoizedState || (e.flags |= 1024), e.memoizedProps = r, e.memoizedState = y), s.props = r, s.state = y, s.context = l, r = c) : (typeof s.componentDidUpdate != "function" || a === t.memoizedProps && p === t.memoizedState || (e.flags |= 4), typeof s.getSnapshotBeforeUpdate != "function" || a === t.memoizedProps && p === t.memoizedState || (e.flags |= 1024), r = false);
    }
    return Fv(t, e, n, r, o, i);
  }
  function Fv(t, e, n, r, i, o) {
    X2(t, e);
    var s = (e.flags & 128) !== 0;
    if (!r && !s)
      return i && US(e, n, false), Qi(t, e, o);
    r = e.stateNode, oI.current = e;
    var a = s && typeof n.getDerivedStateFromError != "function" ? null : r.render();
    return e.flags |= 1, t !== null && s ? (e.child = rl(e, t.child, null, o), e.child = rl(e, null, a, o)) : bn(t, e, a, o), e.memoizedState = r.state, i && US(e, n, true), e.child;
  }
  function Q2(t) {
    var e = t.stateNode;
    e.pendingContext ? WS(t, e.pendingContext, e.pendingContext !== e.context) : e.context && WS(t, e.context, false), ab(t, e.containerInfo);
  }
  function aw(t, e, n, r, i) {
    return nl(), tb(i), e.flags |= 256, bn(t, e, n, r), e.child;
  }
  var Vv = {
    dehydrated: null,
    treeContext: null,
    retryLane: 0
  };
  function Hv(t) {
    return {
      baseLanes: t,
      cachePool: null,
      transitions: null
    };
  }
  function J2(t, e, n) {
    var r = e.pendingProps, i = mt.current, o = false, s = (e.flags & 128) !== 0, a;
    if ((a = s) || (a = t !== null && t.memoizedState === null ? false : (i & 2) !== 0), a ? (o = true, e.flags &= -129) : (t === null || t.memoizedState !== null) && (i |= 1), nt(mt, i & 1), t === null)
      return Dv(e), t = e.memoizedState, t !== null && (t = t.dehydrated, t !== null) ? ((e.mode & 1) === 0 ? e.lanes = 1 : t.data === "$!" ? e.lanes = 8 : e.lanes = 1073741824, null) : (s = r.children, t = r.fallback, o ? (r = e.mode, o = e.child, s = {
        mode: "hidden",
        children: s
      }, (r & 1) === 0 && o !== null ? (o.childLanes = 0, o.pendingProps = s) : o = tm(s, r, 0, null), t = Ls(t, r, n, null), o.return = e, t.return = e, o.sibling = t, e.child = o, e.child.memoizedState = Hv(n), e.memoizedState = Vv, t) : mb(e, s));
    if (i = t.memoizedState, i !== null && (a = i.dehydrated, a !== null))
      return sI(t, e, s, r, a, i, n);
    if (o) {
      o = r.fallback, s = e.mode, i = t.child, a = i.sibling;
      var l = {
        mode: "hidden",
        children: r.children
      };
      return (s & 1) === 0 && e.child !== i ? (r = e.child, r.childLanes = 0, r.pendingProps = l, e.deletions = null) : (r = jo(i, l), r.subtreeFlags = i.subtreeFlags & 14680064), a !== null ? o = jo(a, o) : (o = Ls(o, s, n, null), o.flags |= 2), o.return = e, r.return = e, r.sibling = o, e.child = r, r = o, o = e.child, s = t.child.memoizedState, s = s === null ? Hv(n) : {
        baseLanes: s.baseLanes | n,
        cachePool: null,
        transitions: s.transitions
      }, o.memoizedState = s, o.childLanes = t.childLanes & ~n, e.memoizedState = Vv, r;
    }
    return o = t.child, t = o.sibling, r = jo(o, {
      mode: "visible",
      children: r.children
    }), (e.mode & 1) === 0 && (r.lanes = n), r.return = e, r.sibling = null, t !== null && (n = e.deletions, n === null ? (e.deletions = [
      t
    ], e.flags |= 16) : n.push(t)), e.child = r, e.memoizedState = null, r;
  }
  function mb(t, e) {
    return e = tm({
      mode: "visible",
      children: e
    }, t.mode, 0, null), e.return = t, t.child = e;
  }
  function nh(t, e, n, r) {
    return r !== null && tb(r), rl(e, t.child, null, n), t = mb(e, e.pendingProps.children), t.flags |= 2, e.memoizedState = null, t;
  }
  function sI(t, e, n, r, i, o, s) {
    if (n)
      return e.flags & 256 ? (e.flags &= -257, r = qg(Error(Z(422))), nh(t, e, s, r)) : e.memoizedState !== null ? (e.child = t.child, e.flags |= 128, null) : (o = r.fallback, i = e.mode, r = tm({
        mode: "visible",
        children: r.children
      }, i, 0, null), o = Ls(o, i, s, null), o.flags |= 2, r.return = e, o.return = e, r.sibling = o, e.child = r, (e.mode & 1) !== 0 && rl(e, t.child, null, s), e.child.memoizedState = Hv(s), e.memoizedState = Vv, o);
    if ((e.mode & 1) === 0)
      return nh(t, e, s, null);
    if (i.data === "$!") {
      if (r = i.nextSibling && i.nextSibling.dataset, r)
        var a = r.dgst;
      return r = a, o = Error(Z(419)), r = qg(o, r, void 0), nh(t, e, s, r);
    }
    if (a = (s & t.childLanes) !== 0, In || a) {
      if (r = jt, r !== null) {
        switch (s & -s) {
          case 4:
            i = 2;
            break;
          case 16:
            i = 8;
            break;
          case 64:
          case 128:
          case 256:
          case 512:
          case 1024:
          case 2048:
          case 4096:
          case 8192:
          case 16384:
          case 32768:
          case 65536:
          case 131072:
          case 262144:
          case 524288:
          case 1048576:
          case 2097152:
          case 4194304:
          case 8388608:
          case 16777216:
          case 33554432:
          case 67108864:
            i = 32;
            break;
          case 536870912:
            i = 268435456;
            break;
          default:
            i = 0;
        }
        i = (i & (r.suspendedLanes | s)) !== 0 ? 0 : i, i !== 0 && i !== o.retryLane && (o.retryLane = i, Xi(t, i), Vr(r, t, i, -1));
      }
      return Sb(), r = qg(Error(Z(421))), nh(t, e, s, r);
    }
    return i.data === "$?" ? (e.flags |= 128, e.child = t.child, e = bI.bind(null, t), i._reactRetry = e, null) : (t = o.treeContext, Kn = zo(i.nextSibling), Gn = e, ft = true, Nr = null, t !== null && (fr[hr++] = Hi, fr[hr++] = ji, fr[hr++] = zs, Hi = t.id, ji = t.overflow, zs = e), e = mb(e, r.children), e.flags |= 4096, e);
  }
  function lw(t, e, n) {
    t.lanes |= e;
    var r = t.alternate;
    r !== null && (r.lanes |= e), Iv(t.return, e, n);
  }
  function Gg(t, e, n, r, i) {
    var o = t.memoizedState;
    o === null ? t.memoizedState = {
      isBackwards: e,
      rendering: null,
      renderingStartTime: 0,
      last: r,
      tail: n,
      tailMode: i
    } : (o.isBackwards = e, o.rendering = null, o.renderingStartTime = 0, o.last = r, o.tail = n, o.tailMode = i);
  }
  function Z2(t, e, n) {
    var r = e.pendingProps, i = r.revealOrder, o = r.tail;
    if (bn(t, e, r.children, n), r = mt.current, (r & 2) !== 0)
      r = r & 1 | 2, e.flags |= 128;
    else {
      if (t !== null && (t.flags & 128) !== 0)
        e:
          for (t = e.child; t !== null; ) {
            if (t.tag === 13)
              t.memoizedState !== null && lw(t, n, e);
            else if (t.tag === 19)
              lw(t, n, e);
            else if (t.child !== null) {
              t.child.return = t, t = t.child;
              continue;
            }
            if (t === e)
              break e;
            for (; t.sibling === null; ) {
              if (t.return === null || t.return === e)
                break e;
              t = t.return;
            }
            t.sibling.return = t.return, t = t.sibling;
          }
      r &= 1;
    }
    if (nt(mt, r), (e.mode & 1) === 0)
      e.memoizedState = null;
    else
      switch (i) {
        case "forwards":
          for (n = e.child, i = null; n !== null; )
            t = n.alternate, t !== null && Gd(t) === null && (i = n), n = n.sibling;
          n = i, n === null ? (i = e.child, e.child = null) : (i = n.sibling, n.sibling = null), Gg(e, false, i, n, o);
          break;
        case "backwards":
          for (n = null, i = e.child, e.child = null; i !== null; ) {
            if (t = i.alternate, t !== null && Gd(t) === null) {
              e.child = i;
              break;
            }
            t = i.sibling, i.sibling = n, n = i, i = t;
          }
          Gg(e, true, n, null, o);
          break;
        case "together":
          Gg(e, false, null, null, void 0);
          break;
        default:
          e.memoizedState = null;
      }
    return e.child;
  }
  function Zh(t, e) {
    (e.mode & 1) === 0 && t !== null && (t.alternate = null, e.alternate = null, e.flags |= 2);
  }
  function Qi(t, e, n) {
    if (t !== null && (e.dependencies = t.dependencies), Vs |= e.lanes, (n & e.childLanes) === 0)
      return null;
    if (t !== null && e.child !== t.child)
      throw Error(Z(153));
    if (e.child !== null) {
      for (t = e.child, n = jo(t, t.pendingProps), e.child = n, n.return = e; t.sibling !== null; )
        t = t.sibling, n = n.sibling = jo(t, t.pendingProps), n.return = e;
      n.sibling = null;
    }
    return e.child;
  }
  function aI(t, e, n) {
    switch (e.tag) {
      case 3:
        Q2(e), nl();
        break;
      case 5:
        M2(e);
        break;
      case 1:
        zn(e.type) && Hd(e);
        break;
      case 4:
        ab(e, e.stateNode.containerInfo);
        break;
      case 10:
        var r = e.type._context, i = e.memoizedProps.value;
        nt(Ud, r._currentValue), r._currentValue = i;
        break;
      case 13:
        if (r = e.memoizedState, r !== null)
          return r.dehydrated !== null ? (nt(mt, mt.current & 1), e.flags |= 128, null) : (n & e.child.childLanes) !== 0 ? J2(t, e, n) : (nt(mt, mt.current & 1), t = Qi(t, e, n), t !== null ? t.sibling : null);
        nt(mt, mt.current & 1);
        break;
      case 19:
        if (r = (n & e.childLanes) !== 0, (t.flags & 128) !== 0) {
          if (r)
            return Z2(t, e, n);
          e.flags |= 128;
        }
        if (i = e.memoizedState, i !== null && (i.rendering = null, i.tail = null, i.lastEffect = null), nt(mt, mt.current), r)
          break;
        return null;
      case 22:
      case 23:
        return e.lanes = 0, Y2(t, e, n);
    }
    return Qi(t, e, n);
  }
  var eA, jv, tA, nA;
  eA = function(t, e) {
    for (var n = e.child; n !== null; ) {
      if (n.tag === 5 || n.tag === 6)
        t.appendChild(n.stateNode);
      else if (n.tag !== 4 && n.child !== null) {
        n.child.return = n, n = n.child;
        continue;
      }
      if (n === e)
        break;
      for (; n.sibling === null; ) {
        if (n.return === null || n.return === e)
          return;
        n = n.return;
      }
      n.sibling.return = n.return, n = n.sibling;
    }
  };
  jv = function() {
  };
  tA = function(t, e, n, r) {
    var i = t.memoizedProps;
    if (i !== r) {
      t = e.stateNode, Ms(Si.current);
      var o = null;
      switch (n) {
        case "input":
          i = fv(t, i), r = fv(t, r), o = [];
          break;
        case "select":
          i = vt({}, i, {
            value: void 0
          }), r = vt({}, r, {
            value: void 0
          }), o = [];
          break;
        case "textarea":
          i = pv(t, i), r = pv(t, r), o = [];
          break;
        default:
          typeof i.onClick != "function" && typeof r.onClick == "function" && (t.onclick = Fd);
      }
      gv(n, r);
      var s;
      n = null;
      for (c in i)
        if (!r.hasOwnProperty(c) && i.hasOwnProperty(c) && i[c] != null)
          if (c === "style") {
            var a = i[c];
            for (s in a)
              a.hasOwnProperty(s) && (n || (n = {}), n[s] = "");
          } else
            c !== "dangerouslySetInnerHTML" && c !== "children" && c !== "suppressContentEditableWarning" && c !== "suppressHydrationWarning" && c !== "autoFocus" && (ru.hasOwnProperty(c) ? o || (o = []) : (o = o || []).push(c, null));
      for (c in r) {
        var l = r[c];
        if (a = i == null ? void 0 : i[c], r.hasOwnProperty(c) && l !== a && (l != null || a != null))
          if (c === "style")
            if (a) {
              for (s in a)
                !a.hasOwnProperty(s) || l && l.hasOwnProperty(s) || (n || (n = {}), n[s] = "");
              for (s in l)
                l.hasOwnProperty(s) && a[s] !== l[s] && (n || (n = {}), n[s] = l[s]);
            } else
              n || (o || (o = []), o.push(c, n)), n = l;
          else
            c === "dangerouslySetInnerHTML" ? (l = l ? l.__html : void 0, a = a ? a.__html : void 0, l != null && a !== l && (o = o || []).push(c, l)) : c === "children" ? typeof l != "string" && typeof l != "number" || (o = o || []).push(c, "" + l) : c !== "suppressContentEditableWarning" && c !== "suppressHydrationWarning" && (ru.hasOwnProperty(c) ? (l != null && c === "onScroll" && ot("scroll", t), o || a === l || (o = [])) : (o = o || []).push(c, l));
      }
      n && (o = o || []).push("style", n);
      var c = o;
      (e.updateQueue = c) && (e.flags |= 4);
    }
  };
  nA = function(t, e, n, r) {
    n !== r && (e.flags |= 4);
  };
  function Ql(t, e) {
    if (!ft)
      switch (t.tailMode) {
        case "hidden":
          e = t.tail;
          for (var n = null; e !== null; )
            e.alternate !== null && (n = e), e = e.sibling;
          n === null ? t.tail = null : n.sibling = null;
          break;
        case "collapsed":
          n = t.tail;
          for (var r = null; n !== null; )
            n.alternate !== null && (r = n), n = n.sibling;
          r === null ? e || t.tail === null ? t.tail = null : t.tail.sibling = null : r.sibling = null;
      }
  }
  function an(t) {
    var e = t.alternate !== null && t.alternate.child === t.child, n = 0, r = 0;
    if (e)
      for (var i = t.child; i !== null; )
        n |= i.lanes | i.childLanes, r |= i.subtreeFlags & 14680064, r |= i.flags & 14680064, i.return = t, i = i.sibling;
    else
      for (i = t.child; i !== null; )
        n |= i.lanes | i.childLanes, r |= i.subtreeFlags, r |= i.flags, i.return = t, i = i.sibling;
    return t.subtreeFlags |= r, t.childLanes = n, e;
  }
  function lI(t, e, n) {
    var r = e.pendingProps;
    switch (eb(e), e.tag) {
      case 2:
      case 16:
      case 15:
      case 0:
      case 11:
      case 7:
      case 8:
      case 12:
      case 9:
      case 14:
        return an(e), null;
      case 1:
        return zn(e.type) && Vd(), an(e), null;
      case 3:
        return r = e.stateNode, il(), lt($n), lt(pn), cb(), r.pendingContext && (r.context = r.pendingContext, r.pendingContext = null), (t === null || t.child === null) && (eh(e) ? e.flags |= 4 : t === null || t.memoizedState.isDehydrated && (e.flags & 256) === 0 || (e.flags |= 1024, Nr !== null && (Qv(Nr), Nr = null))), jv(t, e), an(e), null;
      case 5:
        lb(e);
        var i = Ms(mu.current);
        if (n = e.type, t !== null && e.stateNode != null)
          tA(t, e, n, r, i), t.ref !== e.ref && (e.flags |= 512, e.flags |= 2097152);
        else {
          if (!r) {
            if (e.stateNode === null)
              throw Error(Z(166));
            return an(e), null;
          }
          if (t = Ms(Si.current), eh(e)) {
            r = e.stateNode, n = e.type;
            var o = e.memoizedProps;
            switch (r[di] = e, r[du] = o, t = (e.mode & 1) !== 0, n) {
              case "dialog":
                ot("cancel", r), ot("close", r);
                break;
              case "iframe":
              case "object":
              case "embed":
                ot("load", r);
                break;
              case "video":
              case "audio":
                for (i = 0; i < pc.length; i++)
                  ot(pc[i], r);
                break;
              case "source":
                ot("error", r);
                break;
              case "img":
              case "image":
              case "link":
                ot("error", r), ot("load", r);
                break;
              case "details":
                ot("toggle", r);
                break;
              case "input":
                vS(r, o), ot("invalid", r);
                break;
              case "select":
                r._wrapperState = {
                  wasMultiple: !!o.multiple
                }, ot("invalid", r);
                break;
              case "textarea":
                bS(r, o), ot("invalid", r);
            }
            gv(n, o), i = null;
            for (var s in o)
              if (o.hasOwnProperty(s)) {
                var a = o[s];
                s === "children" ? typeof a == "string" ? r.textContent !== a && (o.suppressHydrationWarning !== true && Zf(r.textContent, a, t), i = [
                  "children",
                  a
                ]) : typeof a == "number" && r.textContent !== "" + a && (o.suppressHydrationWarning !== true && Zf(r.textContent, a, t), i = [
                  "children",
                  "" + a
                ]) : ru.hasOwnProperty(s) && a != null && s === "onScroll" && ot("scroll", r);
              }
            switch (n) {
              case "input":
                Uf(r), yS(r, o, true);
                break;
              case "textarea":
                Uf(r), xS(r);
                break;
              case "select":
              case "option":
                break;
              default:
                typeof o.onClick == "function" && (r.onclick = Fd);
            }
            r = i, e.updateQueue = r, r !== null && (e.flags |= 4);
          } else {
            s = i.nodeType === 9 ? i : i.ownerDocument, t === "http://www.w3.org/1999/xhtml" && (t = PM(n)), t === "http://www.w3.org/1999/xhtml" ? n === "script" ? (t = s.createElement("div"), t.innerHTML = "<script><\/script>", t = t.removeChild(t.firstChild)) : typeof r.is == "string" ? t = s.createElement(n, {
              is: r.is
            }) : (t = s.createElement(n), n === "select" && (s = t, r.multiple ? s.multiple = true : r.size && (s.size = r.size))) : t = s.createElementNS(t, n), t[di] = e, t[du] = r, eA(t, e, false, false), e.stateNode = t;
            e: {
              switch (s = vv(n, r), n) {
                case "dialog":
                  ot("cancel", t), ot("close", t), i = r;
                  break;
                case "iframe":
                case "object":
                case "embed":
                  ot("load", t), i = r;
                  break;
                case "video":
                case "audio":
                  for (i = 0; i < pc.length; i++)
                    ot(pc[i], t);
                  i = r;
                  break;
                case "source":
                  ot("error", t), i = r;
                  break;
                case "img":
                case "image":
                case "link":
                  ot("error", t), ot("load", t), i = r;
                  break;
                case "details":
                  ot("toggle", t), i = r;
                  break;
                case "input":
                  vS(t, r), i = fv(t, r), ot("invalid", t);
                  break;
                case "option":
                  i = r;
                  break;
                case "select":
                  t._wrapperState = {
                    wasMultiple: !!r.multiple
                  }, i = vt({}, r, {
                    value: void 0
                  }), ot("invalid", t);
                  break;
                case "textarea":
                  bS(t, r), i = pv(t, r), ot("invalid", t);
                  break;
                default:
                  i = r;
              }
              gv(n, i), a = i;
              for (o in a)
                if (a.hasOwnProperty(o)) {
                  var l = a[o];
                  o === "style" ? LM(t, l) : o === "dangerouslySetInnerHTML" ? (l = l ? l.__html : void 0, l != null && OM(t, l)) : o === "children" ? typeof l == "string" ? (n !== "textarea" || l !== "") && iu(t, l) : typeof l == "number" && iu(t, "" + l) : o !== "suppressContentEditableWarning" && o !== "suppressHydrationWarning" && o !== "autoFocus" && (ru.hasOwnProperty(o) ? l != null && o === "onScroll" && ot("scroll", t) : l != null && z1(t, o, l, s));
                }
              switch (n) {
                case "input":
                  Uf(t), yS(t, r, false);
                  break;
                case "textarea":
                  Uf(t), xS(t);
                  break;
                case "option":
                  r.value != null && t.setAttribute("value", "" + Uo(r.value));
                  break;
                case "select":
                  t.multiple = !!r.multiple, o = r.value, o != null ? Ba(t, !!r.multiple, o, false) : r.defaultValue != null && Ba(t, !!r.multiple, r.defaultValue, true);
                  break;
                default:
                  typeof i.onClick == "function" && (t.onclick = Fd);
              }
              switch (n) {
                case "button":
                case "input":
                case "select":
                case "textarea":
                  r = !!r.autoFocus;
                  break e;
                case "img":
                  r = true;
                  break e;
                default:
                  r = false;
              }
            }
            r && (e.flags |= 4);
          }
          e.ref !== null && (e.flags |= 512, e.flags |= 2097152);
        }
        return an(e), null;
      case 6:
        if (t && e.stateNode != null)
          nA(t, e, t.memoizedProps, r);
        else {
          if (typeof r != "string" && e.stateNode === null)
            throw Error(Z(166));
          if (n = Ms(mu.current), Ms(Si.current), eh(e)) {
            if (r = e.stateNode, n = e.memoizedProps, r[di] = e, (o = r.nodeValue !== n) && (t = Gn, t !== null))
              switch (t.tag) {
                case 3:
                  Zf(r.nodeValue, n, (t.mode & 1) !== 0);
                  break;
                case 5:
                  t.memoizedProps.suppressHydrationWarning !== true && Zf(r.nodeValue, n, (t.mode & 1) !== 0);
              }
            o && (e.flags |= 4);
          } else
            r = (n.nodeType === 9 ? n : n.ownerDocument).createTextNode(r), r[di] = e, e.stateNode = r;
        }
        return an(e), null;
      case 13:
        if (lt(mt), r = e.memoizedState, t === null || t.memoizedState !== null && t.memoizedState.dehydrated !== null) {
          if (ft && Kn !== null && (e.mode & 1) !== 0 && (e.flags & 128) === 0)
            b2(), nl(), e.flags |= 98560, o = false;
          else if (o = eh(e), r !== null && r.dehydrated !== null) {
            if (t === null) {
              if (!o)
                throw Error(Z(318));
              if (o = e.memoizedState, o = o !== null ? o.dehydrated : null, !o)
                throw Error(Z(317));
              o[di] = e;
            } else
              nl(), (e.flags & 128) === 0 && (e.memoizedState = null), e.flags |= 4;
            an(e), o = false;
          } else
            Nr !== null && (Qv(Nr), Nr = null), o = true;
          if (!o)
            return e.flags & 65536 ? e : null;
        }
        return (e.flags & 128) !== 0 ? (e.lanes = n, e) : (r = r !== null, r !== (t !== null && t.memoizedState !== null) && r && (e.child.flags |= 8192, (e.mode & 1) !== 0 && (t === null || (mt.current & 1) !== 0 ? It === 0 && (It = 3) : Sb())), e.updateQueue !== null && (e.flags |= 4), an(e), null);
      case 4:
        return il(), jv(t, e), t === null && fu(e.stateNode.containerInfo), an(e), null;
      case 10:
        return ib(e.type._context), an(e), null;
      case 17:
        return zn(e.type) && Vd(), an(e), null;
      case 19:
        if (lt(mt), o = e.memoizedState, o === null)
          return an(e), null;
        if (r = (e.flags & 128) !== 0, s = o.rendering, s === null)
          if (r)
            Ql(o, false);
          else {
            if (It !== 0 || t !== null && (t.flags & 128) !== 0)
              for (t = e.child; t !== null; ) {
                if (s = Gd(t), s !== null) {
                  for (e.flags |= 128, Ql(o, false), r = s.updateQueue, r !== null && (e.updateQueue = r, e.flags |= 4), e.subtreeFlags = 0, r = n, n = e.child; n !== null; )
                    o = n, t = r, o.flags &= 14680066, s = o.alternate, s === null ? (o.childLanes = 0, o.lanes = t, o.child = null, o.subtreeFlags = 0, o.memoizedProps = null, o.memoizedState = null, o.updateQueue = null, o.dependencies = null, o.stateNode = null) : (o.childLanes = s.childLanes, o.lanes = s.lanes, o.child = s.child, o.subtreeFlags = 0, o.deletions = null, o.memoizedProps = s.memoizedProps, o.memoizedState = s.memoizedState, o.updateQueue = s.updateQueue, o.type = s.type, t = s.dependencies, o.dependencies = t === null ? null : {
                      lanes: t.lanes,
                      firstContext: t.firstContext
                    }), n = n.sibling;
                  return nt(mt, mt.current & 1 | 2), e.child;
                }
                t = t.sibling;
              }
            o.tail !== null && Mt() > sl && (e.flags |= 128, r = true, Ql(o, false), e.lanes = 4194304);
          }
        else {
          if (!r)
            if (t = Gd(s), t !== null) {
              if (e.flags |= 128, r = true, n = t.updateQueue, n !== null && (e.updateQueue = n, e.flags |= 4), Ql(o, true), o.tail === null && o.tailMode === "hidden" && !s.alternate && !ft)
                return an(e), null;
            } else
              2 * Mt() - o.renderingStartTime > sl && n !== 1073741824 && (e.flags |= 128, r = true, Ql(o, false), e.lanes = 4194304);
          o.isBackwards ? (s.sibling = e.child, e.child = s) : (n = o.last, n !== null ? n.sibling = s : e.child = s, o.last = s);
        }
        return o.tail !== null ? (e = o.tail, o.rendering = e, o.tail = e.sibling, o.renderingStartTime = Mt(), e.sibling = null, n = mt.current, nt(mt, r ? n & 1 | 2 : n & 1), e) : (an(e), null);
      case 22:
      case 23:
        return xb(), r = e.memoizedState !== null, t !== null && t.memoizedState !== null !== r && (e.flags |= 8192), r && (e.mode & 1) !== 0 ? (Wn & 1073741824) !== 0 && (an(e), e.subtreeFlags & 6 && (e.flags |= 8192)) : an(e), null;
      case 24:
        return null;
      case 25:
        return null;
    }
    throw Error(Z(156, e.tag));
  }
  function cI(t, e) {
    switch (eb(e), e.tag) {
      case 1:
        return zn(e.type) && Vd(), t = e.flags, t & 65536 ? (e.flags = t & -65537 | 128, e) : null;
      case 3:
        return il(), lt($n), lt(pn), cb(), t = e.flags, (t & 65536) !== 0 && (t & 128) === 0 ? (e.flags = t & -65537 | 128, e) : null;
      case 5:
        return lb(e), null;
      case 13:
        if (lt(mt), t = e.memoizedState, t !== null && t.dehydrated !== null) {
          if (e.alternate === null)
            throw Error(Z(340));
          nl();
        }
        return t = e.flags, t & 65536 ? (e.flags = t & -65537 | 128, e) : null;
      case 19:
        return lt(mt), null;
      case 4:
        return il(), null;
      case 10:
        return ib(e.type._context), null;
      case 22:
      case 23:
        return xb(), null;
      case 24:
        return null;
      default:
        return null;
    }
  }
  var rh = false, fn = false, uI = typeof WeakSet == "function" ? WeakSet : Set, ge = null;
  function ka(t, e) {
    var n = t.ref;
    if (n !== null)
      if (typeof n == "function")
        try {
          n(null);
        } catch (r) {
          St(t, e, r);
        }
      else
        n.current = null;
  }
  function Wv(t, e, n) {
    try {
      n();
    } catch (r) {
      St(t, e, r);
    }
  }
  var cw = false;
  function fI(t, e) {
    if (Av = Nd, t = s2(), J1(t)) {
      if ("selectionStart" in t)
        var n = {
          start: t.selectionStart,
          end: t.selectionEnd
        };
      else
        e: {
          n = (n = t.ownerDocument) && n.defaultView || window;
          var r = n.getSelection && n.getSelection();
          if (r && r.rangeCount !== 0) {
            n = r.anchorNode;
            var i = r.anchorOffset, o = r.focusNode;
            r = r.focusOffset;
            try {
              n.nodeType, o.nodeType;
            } catch {
              n = null;
              break e;
            }
            var s = 0, a = -1, l = -1, c = 0, u = 0, h = t, p = null;
            t:
              for (; ; ) {
                for (var v; h !== n || i !== 0 && h.nodeType !== 3 || (a = s + i), h !== o || r !== 0 && h.nodeType !== 3 || (l = s + r), h.nodeType === 3 && (s += h.nodeValue.length), (v = h.firstChild) !== null; )
                  p = h, h = v;
                for (; ; ) {
                  if (h === t)
                    break t;
                  if (p === n && ++c === i && (a = s), p === o && ++u === r && (l = s), (v = h.nextSibling) !== null)
                    break;
                  h = p, p = h.parentNode;
                }
                h = v;
              }
            n = a === -1 || l === -1 ? null : {
              start: a,
              end: l
            };
          } else
            n = null;
        }
      n = n || {
        start: 0,
        end: 0
      };
    } else
      n = null;
    for (Ev = {
      focusedElem: t,
      selectionRange: n
    }, Nd = false, ge = e; ge !== null; )
      if (e = ge, t = e.child, (e.subtreeFlags & 1028) !== 0 && t !== null)
        t.return = e, ge = t;
      else
        for (; ge !== null; ) {
          e = ge;
          try {
            var y = e.alternate;
            if ((e.flags & 1024) !== 0)
              switch (e.tag) {
                case 0:
                case 11:
                case 15:
                  break;
                case 1:
                  if (y !== null) {
                    var x = y.memoizedProps, T = y.memoizedState, w = e.stateNode, k = w.getSnapshotBeforeUpdate(e.elementType === e.type ? x : Dr(e.type, x), T);
                    w.__reactInternalSnapshotBeforeUpdate = k;
                  }
                  break;
                case 3:
                  var C = e.stateNode.containerInfo;
                  C.nodeType === 1 ? C.textContent = "" : C.nodeType === 9 && C.documentElement && C.removeChild(C.documentElement);
                  break;
                case 5:
                case 6:
                case 4:
                case 17:
                  break;
                default:
                  throw Error(Z(163));
              }
          } catch (P) {
            St(e, e.return, P);
          }
          if (t = e.sibling, t !== null) {
            t.return = e.return, ge = t;
            break;
          }
          ge = e.return;
        }
    return y = cw, cw = false, y;
  }
  function Lc(t, e, n) {
    var r = e.updateQueue;
    if (r = r !== null ? r.lastEffect : null, r !== null) {
      var i = r = r.next;
      do {
        if ((i.tag & t) === t) {
          var o = i.destroy;
          i.destroy = void 0, o !== void 0 && Wv(e, n, o);
        }
        i = i.next;
      } while (i !== r);
    }
  }
  function Zp(t, e) {
    if (e = e.updateQueue, e = e !== null ? e.lastEffect : null, e !== null) {
      var n = e = e.next;
      do {
        if ((n.tag & t) === t) {
          var r = n.create;
          n.destroy = r();
        }
        n = n.next;
      } while (n !== e);
    }
  }
  function Uv(t) {
    var e = t.ref;
    if (e !== null) {
      var n = t.stateNode;
      switch (t.tag) {
        case 5:
          t = n;
          break;
        default:
          t = n;
      }
      typeof e == "function" ? e(t) : e.current = t;
    }
  }
  function rA(t) {
    var e = t.alternate;
    e !== null && (t.alternate = null, rA(e)), t.child = null, t.deletions = null, t.sibling = null, t.tag === 5 && (e = t.stateNode, e !== null && (delete e[di], delete e[du], delete e[Rv], delete e[qD], delete e[GD])), t.stateNode = null, t.return = null, t.dependencies = null, t.memoizedProps = null, t.memoizedState = null, t.pendingProps = null, t.stateNode = null, t.updateQueue = null;
  }
  function iA(t) {
    return t.tag === 5 || t.tag === 3 || t.tag === 4;
  }
  function uw(t) {
    e:
      for (; ; ) {
        for (; t.sibling === null; ) {
          if (t.return === null || iA(t.return))
            return null;
          t = t.return;
        }
        for (t.sibling.return = t.return, t = t.sibling; t.tag !== 5 && t.tag !== 6 && t.tag !== 18; ) {
          if (t.flags & 2 || t.child === null || t.tag === 4)
            continue e;
          t.child.return = t, t = t.child;
        }
        if (!(t.flags & 2))
          return t.stateNode;
      }
  }
  function Kv(t, e, n) {
    var r = t.tag;
    if (r === 5 || r === 6)
      t = t.stateNode, e ? n.nodeType === 8 ? n.parentNode.insertBefore(t, e) : n.insertBefore(t, e) : (n.nodeType === 8 ? (e = n.parentNode, e.insertBefore(t, n)) : (e = n, e.appendChild(t)), n = n._reactRootContainer, n != null || e.onclick !== null || (e.onclick = Fd));
    else if (r !== 4 && (t = t.child, t !== null))
      for (Kv(t, e, n), t = t.sibling; t !== null; )
        Kv(t, e, n), t = t.sibling;
  }
  function qv(t, e, n) {
    var r = t.tag;
    if (r === 5 || r === 6)
      t = t.stateNode, e ? n.insertBefore(t, e) : n.appendChild(t);
    else if (r !== 4 && (t = t.child, t !== null))
      for (qv(t, e, n), t = t.sibling; t !== null; )
        qv(t, e, n), t = t.sibling;
  }
  var Gt = null, Ir = false;
  function ho(t, e, n) {
    for (n = n.child; n !== null; )
      oA(t, e, n), n = n.sibling;
  }
  function oA(t, e, n) {
    if (xi && typeof xi.onCommitFiberUnmount == "function")
      try {
        xi.onCommitFiberUnmount(Up, n);
      } catch {
      }
    switch (n.tag) {
      case 5:
        fn || ka(n, e);
      case 6:
        var r = Gt, i = Ir;
        Gt = null, ho(t, e, n), Gt = r, Ir = i, Gt !== null && (Ir ? (t = Gt, n = n.stateNode, t.nodeType === 8 ? t.parentNode.removeChild(n) : t.removeChild(n)) : Gt.removeChild(n.stateNode));
        break;
      case 18:
        Gt !== null && (Ir ? (t = Gt, n = n.stateNode, t.nodeType === 8 ? Vg(t.parentNode, n) : t.nodeType === 1 && Vg(t, n), lu(t)) : Vg(Gt, n.stateNode));
        break;
      case 4:
        r = Gt, i = Ir, Gt = n.stateNode.containerInfo, Ir = true, ho(t, e, n), Gt = r, Ir = i;
        break;
      case 0:
      case 11:
      case 14:
      case 15:
        if (!fn && (r = n.updateQueue, r !== null && (r = r.lastEffect, r !== null))) {
          i = r = r.next;
          do {
            var o = i, s = o.destroy;
            o = o.tag, s !== void 0 && ((o & 2) !== 0 || (o & 4) !== 0) && Wv(n, e, s), i = i.next;
          } while (i !== r);
        }
        ho(t, e, n);
        break;
      case 1:
        if (!fn && (ka(n, e), r = n.stateNode, typeof r.componentWillUnmount == "function"))
          try {
            r.props = n.memoizedProps, r.state = n.memoizedState, r.componentWillUnmount();
          } catch (a) {
            St(n, e, a);
          }
        ho(t, e, n);
        break;
      case 21:
        ho(t, e, n);
        break;
      case 22:
        n.mode & 1 ? (fn = (r = fn) || n.memoizedState !== null, ho(t, e, n), fn = r) : ho(t, e, n);
        break;
      default:
        ho(t, e, n);
    }
  }
  function fw(t) {
    var e = t.updateQueue;
    if (e !== null) {
      t.updateQueue = null;
      var n = t.stateNode;
      n === null && (n = t.stateNode = new uI()), e.forEach(function(r) {
        var i = xI.bind(null, t, r);
        n.has(r) || (n.add(r), r.then(i, i));
      });
    }
  }
  function Rr(t, e) {
    var n = e.deletions;
    if (n !== null)
      for (var r = 0; r < n.length; r++) {
        var i = n[r];
        try {
          var o = t, s = e, a = s;
          e:
            for (; a !== null; ) {
              switch (a.tag) {
                case 5:
                  Gt = a.stateNode, Ir = false;
                  break e;
                case 3:
                  Gt = a.stateNode.containerInfo, Ir = true;
                  break e;
                case 4:
                  Gt = a.stateNode.containerInfo, Ir = true;
                  break e;
              }
              a = a.return;
            }
          if (Gt === null)
            throw Error(Z(160));
          oA(o, s, i), Gt = null, Ir = false;
          var l = i.alternate;
          l !== null && (l.return = null), i.return = null;
        } catch (c) {
          St(i, e, c);
        }
      }
    if (e.subtreeFlags & 12854)
      for (e = e.child; e !== null; )
        sA(e, t), e = e.sibling;
  }
  function sA(t, e) {
    var n = t.alternate, r = t.flags;
    switch (t.tag) {
      case 0:
      case 11:
      case 14:
      case 15:
        if (Rr(e, t), ei(t), r & 4) {
          try {
            Lc(3, t, t.return), Zp(3, t);
          } catch (x) {
            St(t, t.return, x);
          }
          try {
            Lc(5, t, t.return);
          } catch (x) {
            St(t, t.return, x);
          }
        }
        break;
      case 1:
        Rr(e, t), ei(t), r & 512 && n !== null && ka(n, n.return);
        break;
      case 5:
        if (Rr(e, t), ei(t), r & 512 && n !== null && ka(n, n.return), t.flags & 32) {
          var i = t.stateNode;
          try {
            iu(i, "");
          } catch (x) {
            St(t, t.return, x);
          }
        }
        if (r & 4 && (i = t.stateNode, i != null)) {
          var o = t.memoizedProps, s = n !== null ? n.memoizedProps : o, a = t.type, l = t.updateQueue;
          if (t.updateQueue = null, l !== null)
            try {
              a === "input" && o.type === "radio" && o.name != null && AM(i, o), vv(a, s);
              var c = vv(a, o);
              for (s = 0; s < l.length; s += 2) {
                var u = l[s], h = l[s + 1];
                u === "style" ? LM(i, h) : u === "dangerouslySetInnerHTML" ? OM(i, h) : u === "children" ? iu(i, h) : z1(i, u, h, c);
              }
              switch (a) {
                case "input":
                  hv(i, o);
                  break;
                case "textarea":
                  EM(i, o);
                  break;
                case "select":
                  var p = i._wrapperState.wasMultiple;
                  i._wrapperState.wasMultiple = !!o.multiple;
                  var v = o.value;
                  v != null ? Ba(i, !!o.multiple, v, false) : p !== !!o.multiple && (o.defaultValue != null ? Ba(i, !!o.multiple, o.defaultValue, true) : Ba(i, !!o.multiple, o.multiple ? [] : "", false));
              }
              i[du] = o;
            } catch (x) {
              St(t, t.return, x);
            }
        }
        break;
      case 6:
        if (Rr(e, t), ei(t), r & 4) {
          if (t.stateNode === null)
            throw Error(Z(162));
          i = t.stateNode, o = t.memoizedProps;
          try {
            i.nodeValue = o;
          } catch (x) {
            St(t, t.return, x);
          }
        }
        break;
      case 3:
        if (Rr(e, t), ei(t), r & 4 && n !== null && n.memoizedState.isDehydrated)
          try {
            lu(e.containerInfo);
          } catch (x) {
            St(t, t.return, x);
          }
        break;
      case 4:
        Rr(e, t), ei(t);
        break;
      case 13:
        Rr(e, t), ei(t), i = t.child, i.flags & 8192 && (o = i.memoizedState !== null, i.stateNode.isHidden = o, !o || i.alternate !== null && i.alternate.memoizedState !== null || (yb = Mt())), r & 4 && fw(t);
        break;
      case 22:
        if (u = n !== null && n.memoizedState !== null, t.mode & 1 ? (fn = (c = fn) || u, Rr(e, t), fn = c) : Rr(e, t), ei(t), r & 8192) {
          if (c = t.memoizedState !== null, (t.stateNode.isHidden = c) && !u && (t.mode & 1) !== 0)
            for (ge = t, u = t.child; u !== null; ) {
              for (h = ge = u; ge !== null; ) {
                switch (p = ge, v = p.child, p.tag) {
                  case 0:
                  case 11:
                  case 14:
                  case 15:
                    Lc(4, p, p.return);
                    break;
                  case 1:
                    ka(p, p.return);
                    var y = p.stateNode;
                    if (typeof y.componentWillUnmount == "function") {
                      r = p, n = p.return;
                      try {
                        e = r, y.props = e.memoizedProps, y.state = e.memoizedState, y.componentWillUnmount();
                      } catch (x) {
                        St(r, n, x);
                      }
                    }
                    break;
                  case 5:
                    ka(p, p.return);
                    break;
                  case 22:
                    if (p.memoizedState !== null) {
                      dw(h);
                      continue;
                    }
                }
                v !== null ? (v.return = p, ge = v) : dw(h);
              }
              u = u.sibling;
            }
          e:
            for (u = null, h = t; ; ) {
              if (h.tag === 5) {
                if (u === null) {
                  u = h;
                  try {
                    i = h.stateNode, c ? (o = i.style, typeof o.setProperty == "function" ? o.setProperty("display", "none", "important") : o.display = "none") : (a = h.stateNode, l = h.memoizedProps.style, s = l != null && l.hasOwnProperty("display") ? l.display : null, a.style.display = RM("display", s));
                  } catch (x) {
                    St(t, t.return, x);
                  }
                }
              } else if (h.tag === 6) {
                if (u === null)
                  try {
                    h.stateNode.nodeValue = c ? "" : h.memoizedProps;
                  } catch (x) {
                    St(t, t.return, x);
                  }
              } else if ((h.tag !== 22 && h.tag !== 23 || h.memoizedState === null || h === t) && h.child !== null) {
                h.child.return = h, h = h.child;
                continue;
              }
              if (h === t)
                break e;
              for (; h.sibling === null; ) {
                if (h.return === null || h.return === t)
                  break e;
                u === h && (u = null), h = h.return;
              }
              u === h && (u = null), h.sibling.return = h.return, h = h.sibling;
            }
        }
        break;
      case 19:
        Rr(e, t), ei(t), r & 4 && fw(t);
        break;
      case 21:
        break;
      default:
        Rr(e, t), ei(t);
    }
  }
  function ei(t) {
    var e = t.flags;
    if (e & 2) {
      try {
        e: {
          for (var n = t.return; n !== null; ) {
            if (iA(n)) {
              var r = n;
              break e;
            }
            n = n.return;
          }
          throw Error(Z(160));
        }
        switch (r.tag) {
          case 5:
            var i = r.stateNode;
            r.flags & 32 && (iu(i, ""), r.flags &= -33);
            var o = uw(t);
            qv(t, o, i);
            break;
          case 3:
          case 4:
            var s = r.stateNode.containerInfo, a = uw(t);
            Kv(t, a, s);
            break;
          default:
            throw Error(Z(161));
        }
      } catch (l) {
        St(t, t.return, l);
      }
      t.flags &= -3;
    }
    e & 4096 && (t.flags &= -4097);
  }
  function hI(t, e, n) {
    ge = t, aA(t);
  }
  function aA(t, e, n) {
    for (var r = (t.mode & 1) !== 0; ge !== null; ) {
      var i = ge, o = i.child;
      if (i.tag === 22 && r) {
        var s = i.memoizedState !== null || rh;
        if (!s) {
          var a = i.alternate, l = a !== null && a.memoizedState !== null || fn;
          a = rh;
          var c = fn;
          if (rh = s, (fn = l) && !c)
            for (ge = i; ge !== null; )
              s = ge, l = s.child, s.tag === 22 && s.memoizedState !== null ? pw(i) : l !== null ? (l.return = s, ge = l) : pw(i);
          for (; o !== null; )
            ge = o, aA(o), o = o.sibling;
          ge = i, rh = a, fn = c;
        }
        hw(t);
      } else
        (i.subtreeFlags & 8772) !== 0 && o !== null ? (o.return = i, ge = o) : hw(t);
    }
  }
  function hw(t) {
    for (; ge !== null; ) {
      var e = ge;
      if ((e.flags & 8772) !== 0) {
        var n = e.alternate;
        try {
          if ((e.flags & 8772) !== 0)
            switch (e.tag) {
              case 0:
              case 11:
              case 15:
                fn || Zp(5, e);
                break;
              case 1:
                var r = e.stateNode;
                if (e.flags & 4 && !fn)
                  if (n === null)
                    r.componentDidMount();
                  else {
                    var i = e.elementType === e.type ? n.memoizedProps : Dr(e.type, n.memoizedProps);
                    r.componentDidUpdate(i, n.memoizedState, r.__reactInternalSnapshotBeforeUpdate);
                  }
                var o = e.updateQueue;
                o !== null && YS(e, o, r);
                break;
              case 3:
                var s = e.updateQueue;
                if (s !== null) {
                  if (n = null, e.child !== null)
                    switch (e.child.tag) {
                      case 5:
                        n = e.child.stateNode;
                        break;
                      case 1:
                        n = e.child.stateNode;
                    }
                  YS(e, s, n);
                }
                break;
              case 5:
                var a = e.stateNode;
                if (n === null && e.flags & 4) {
                  n = a;
                  var l = e.memoizedProps;
                  switch (e.type) {
                    case "button":
                    case "input":
                    case "select":
                    case "textarea":
                      l.autoFocus && n.focus();
                      break;
                    case "img":
                      l.src && (n.src = l.src);
                  }
                }
                break;
              case 6:
                break;
              case 4:
                break;
              case 12:
                break;
              case 13:
                if (e.memoizedState === null) {
                  var c = e.alternate;
                  if (c !== null) {
                    var u = c.memoizedState;
                    if (u !== null) {
                      var h = u.dehydrated;
                      h !== null && lu(h);
                    }
                  }
                }
                break;
              case 19:
              case 17:
              case 21:
              case 22:
              case 23:
              case 25:
                break;
              default:
                throw Error(Z(163));
            }
          fn || e.flags & 512 && Uv(e);
        } catch (p) {
          St(e, e.return, p);
        }
      }
      if (e === t) {
        ge = null;
        break;
      }
      if (n = e.sibling, n !== null) {
        n.return = e.return, ge = n;
        break;
      }
      ge = e.return;
    }
  }
  function dw(t) {
    for (; ge !== null; ) {
      var e = ge;
      if (e === t) {
        ge = null;
        break;
      }
      var n = e.sibling;
      if (n !== null) {
        n.return = e.return, ge = n;
        break;
      }
      ge = e.return;
    }
  }
  function pw(t) {
    for (; ge !== null; ) {
      var e = ge;
      try {
        switch (e.tag) {
          case 0:
          case 11:
          case 15:
            var n = e.return;
            try {
              Zp(4, e);
            } catch (l) {
              St(e, n, l);
            }
            break;
          case 1:
            var r = e.stateNode;
            if (typeof r.componentDidMount == "function") {
              var i = e.return;
              try {
                r.componentDidMount();
              } catch (l) {
                St(e, i, l);
              }
            }
            var o = e.return;
            try {
              Uv(e);
            } catch (l) {
              St(e, o, l);
            }
            break;
          case 5:
            var s = e.return;
            try {
              Uv(e);
            } catch (l) {
              St(e, s, l);
            }
        }
      } catch (l) {
        St(e, e.return, l);
      }
      if (e === t) {
        ge = null;
        break;
      }
      var a = e.sibling;
      if (a !== null) {
        a.return = e.return, ge = a;
        break;
      }
      ge = e.return;
    }
  }
  var dI = Math.ceil, Qd = io.ReactCurrentDispatcher, gb = io.ReactCurrentOwner, br = io.ReactCurrentBatchConfig, je = 0, jt = null, Rt = null, tn = 0, Wn = 0, Ca = es(0), It = 0, bu = null, Vs = 0, em = 0, vb = 0, _c = null, Rn = null, yb = 0, sl = 1 / 0, Bi = null, Jd = false, Gv = null, Vo = null, ih = false, Po = null, Zd = 0, Dc = 0, Yv = null, ed = -1, td = 0;
  function wn() {
    return (je & 6) !== 0 ? Mt() : ed !== -1 ? ed : ed = Mt();
  }
  function Ho(t) {
    return (t.mode & 1) === 0 ? 1 : (je & 2) !== 0 && tn !== 0 ? tn & -tn : XD.transition !== null ? (td === 0 && (td = WM()), td) : (t = Ye, t !== 0 || (t = window.event, t = t === void 0 ? 16 : QM(t.type)), t);
  }
  function Vr(t, e, n, r) {
    if (50 < Dc)
      throw Dc = 0, Yv = null, Error(Z(185));
    Gu(t, n, r), ((je & 2) === 0 || t !== jt) && (t === jt && ((je & 2) === 0 && (em |= n), It === 4 && Co(t, tn)), Fn(t, r), n === 1 && je === 0 && (e.mode & 1) === 0 && (sl = Mt() + 500, Xp && ts()));
  }
  function Fn(t, e) {
    var n = t.callbackNode;
    X_(t, e);
    var r = Bd(t, t === jt ? tn : 0);
    if (r === 0)
      n !== null && kS(n), t.callbackNode = null, t.callbackPriority = 0;
    else if (e = r & -r, t.callbackPriority !== e) {
      if (n != null && kS(n), e === 1)
        t.tag === 0 ? YD(mw.bind(null, t)) : g2(mw.bind(null, t)), UD(function() {
          (je & 6) === 0 && ts();
        }), n = null;
      else {
        switch (UM(r)) {
          case 1:
            n = W1;
            break;
          case 4:
            n = HM;
            break;
          case 16:
            n = Id;
            break;
          case 536870912:
            n = jM;
            break;
          default:
            n = Id;
        }
        n = mA(n, lA.bind(null, t));
      }
      t.callbackPriority = e, t.callbackNode = n;
    }
  }
  function lA(t, e) {
    if (ed = -1, td = 0, (je & 6) !== 0)
      throw Error(Z(327));
    var n = t.callbackNode;
    if (Va() && t.callbackNode !== n)
      return null;
    var r = Bd(t, t === jt ? tn : 0);
    if (r === 0)
      return null;
    if ((r & 30) !== 0 || (r & t.expiredLanes) !== 0 || e)
      e = ep(t, r);
    else {
      e = r;
      var i = je;
      je |= 2;
      var o = uA();
      (jt !== t || tn !== e) && (Bi = null, sl = Mt() + 500, Rs(t, e));
      do
        try {
          gI();
          break;
        } catch (a) {
          cA(t, a);
        }
      while (1);
      rb(), Qd.current = o, je = i, Rt !== null ? e = 0 : (jt = null, tn = 0, e = It);
    }
    if (e !== 0) {
      if (e === 2 && (i = wv(t), i !== 0 && (r = i, e = Xv(t, i))), e === 1)
        throw n = bu, Rs(t, 0), Co(t, r), Fn(t, Mt()), n;
      if (e === 6)
        Co(t, r);
      else {
        if (i = t.current.alternate, (r & 30) === 0 && !pI(i) && (e = ep(t, r), e === 2 && (o = wv(t), o !== 0 && (r = o, e = Xv(t, o))), e === 1))
          throw n = bu, Rs(t, 0), Co(t, r), Fn(t, Mt()), n;
        switch (t.finishedWork = i, t.finishedLanes = r, e) {
          case 0:
          case 1:
            throw Error(Z(345));
          case 2:
            ys(t, Rn, Bi);
            break;
          case 3:
            if (Co(t, r), (r & 130023424) === r && (e = yb + 500 - Mt(), 10 < e)) {
              if (Bd(t, 0) !== 0)
                break;
              if (i = t.suspendedLanes, (i & r) !== r) {
                wn(), t.pingedLanes |= t.suspendedLanes & i;
                break;
              }
              t.timeoutHandle = Ov(ys.bind(null, t, Rn, Bi), e);
              break;
            }
            ys(t, Rn, Bi);
            break;
          case 4:
            if (Co(t, r), (r & 4194240) === r)
              break;
            for (e = t.eventTimes, i = -1; 0 < r; ) {
              var s = 31 - Fr(r);
              o = 1 << s, s = e[s], s > i && (i = s), r &= ~o;
            }
            if (r = i, r = Mt() - r, r = (120 > r ? 120 : 480 > r ? 480 : 1080 > r ? 1080 : 1920 > r ? 1920 : 3e3 > r ? 3e3 : 4320 > r ? 4320 : 1960 * dI(r / 1960)) - r, 10 < r) {
              t.timeoutHandle = Ov(ys.bind(null, t, Rn, Bi), r);
              break;
            }
            ys(t, Rn, Bi);
            break;
          case 5:
            ys(t, Rn, Bi);
            break;
          default:
            throw Error(Z(329));
        }
      }
    }
    return Fn(t, Mt()), t.callbackNode === n ? lA.bind(null, t) : null;
  }
  function Xv(t, e) {
    var n = _c;
    return t.current.memoizedState.isDehydrated && (Rs(t, e).flags |= 256), t = ep(t, e), t !== 2 && (e = Rn, Rn = n, e !== null && Qv(e)), t;
  }
  function Qv(t) {
    Rn === null ? Rn = t : Rn.push.apply(Rn, t);
  }
  function pI(t) {
    for (var e = t; ; ) {
      if (e.flags & 16384) {
        var n = e.updateQueue;
        if (n !== null && (n = n.stores, n !== null))
          for (var r = 0; r < n.length; r++) {
            var i = n[r], o = i.getSnapshot;
            i = i.value;
            try {
              if (!Ur(o(), i))
                return false;
            } catch {
              return false;
            }
          }
      }
      if (n = e.child, e.subtreeFlags & 16384 && n !== null)
        n.return = e, e = n;
      else {
        if (e === t)
          break;
        for (; e.sibling === null; ) {
          if (e.return === null || e.return === t)
            return true;
          e = e.return;
        }
        e.sibling.return = e.return, e = e.sibling;
      }
    }
    return true;
  }
  function Co(t, e) {
    for (e &= ~vb, e &= ~em, t.suspendedLanes |= e, t.pingedLanes &= ~e, t = t.expirationTimes; 0 < e; ) {
      var n = 31 - Fr(e), r = 1 << n;
      t[n] = -1, e &= ~r;
    }
  }
  function mw(t) {
    if ((je & 6) !== 0)
      throw Error(Z(327));
    Va();
    var e = Bd(t, 0);
    if ((e & 1) === 0)
      return Fn(t, Mt()), null;
    var n = ep(t, e);
    if (t.tag !== 0 && n === 2) {
      var r = wv(t);
      r !== 0 && (e = r, n = Xv(t, r));
    }
    if (n === 1)
      throw n = bu, Rs(t, 0), Co(t, e), Fn(t, Mt()), n;
    if (n === 6)
      throw Error(Z(345));
    return t.finishedWork = t.current.alternate, t.finishedLanes = e, ys(t, Rn, Bi), Fn(t, Mt()), null;
  }
  function bb(t, e) {
    var n = je;
    je |= 1;
    try {
      return t(e);
    } finally {
      je = n, je === 0 && (sl = Mt() + 500, Xp && ts());
    }
  }
  function Hs(t) {
    Po !== null && Po.tag === 0 && (je & 6) === 0 && Va();
    var e = je;
    je |= 1;
    var n = br.transition, r = Ye;
    try {
      if (br.transition = null, Ye = 1, t)
        return t();
    } finally {
      Ye = r, br.transition = n, je = e, (je & 6) === 0 && ts();
    }
  }
  function xb() {
    Wn = Ca.current, lt(Ca);
  }
  function Rs(t, e) {
    t.finishedWork = null, t.finishedLanes = 0;
    var n = t.timeoutHandle;
    if (n !== -1 && (t.timeoutHandle = -1, WD(n)), Rt !== null)
      for (n = Rt.return; n !== null; ) {
        var r = n;
        switch (eb(r), r.tag) {
          case 1:
            r = r.type.childContextTypes, r != null && Vd();
            break;
          case 3:
            il(), lt($n), lt(pn), cb();
            break;
          case 5:
            lb(r);
            break;
          case 4:
            il();
            break;
          case 13:
            lt(mt);
            break;
          case 19:
            lt(mt);
            break;
          case 10:
            ib(r.type._context);
            break;
          case 22:
          case 23:
            xb();
        }
        n = n.return;
      }
    if (jt = t, Rt = t = jo(t.current, null), tn = Wn = e, It = 0, bu = null, vb = em = Vs = 0, Rn = _c = null, Ts !== null) {
      for (e = 0; e < Ts.length; e++)
        if (n = Ts[e], r = n.interleaved, r !== null) {
          n.interleaved = null;
          var i = r.next, o = n.pending;
          if (o !== null) {
            var s = o.next;
            o.next = i, r.next = s;
          }
          n.pending = r;
        }
      Ts = null;
    }
    return t;
  }
  function cA(t, e) {
    do {
      var n = Rt;
      try {
        if (rb(), Qh.current = Xd, Yd) {
          for (var r = gt.memoizedState; r !== null; ) {
            var i = r.queue;
            i !== null && (i.pending = null), r = r.next;
          }
          Yd = false;
        }
        if (Fs = 0, Vt = _t = gt = null, Rc = false, gu = 0, gb.current = null, n === null || n.return === null) {
          It = 1, bu = e, Rt = null;
          break;
        }
        e: {
          var o = t, s = n.return, a = n, l = e;
          if (e = tn, a.flags |= 32768, l !== null && typeof l == "object" && typeof l.then == "function") {
            var c = l, u = a, h = u.tag;
            if ((u.mode & 1) === 0 && (h === 0 || h === 11 || h === 15)) {
              var p = u.alternate;
              p ? (u.updateQueue = p.updateQueue, u.memoizedState = p.memoizedState, u.lanes = p.lanes) : (u.updateQueue = null, u.memoizedState = null);
            }
            var v = nw(s);
            if (v !== null) {
              v.flags &= -257, rw(v, s, a, o, e), v.mode & 1 && tw(o, c, e), e = v, l = c;
              var y = e.updateQueue;
              if (y === null) {
                var x = /* @__PURE__ */ new Set();
                x.add(l), e.updateQueue = x;
              } else
                y.add(l);
              break e;
            } else {
              if ((e & 1) === 0) {
                tw(o, c, e), Sb();
                break e;
              }
              l = Error(Z(426));
            }
          } else if (ft && a.mode & 1) {
            var T = nw(s);
            if (T !== null) {
              (T.flags & 65536) === 0 && (T.flags |= 256), rw(T, s, a, o, e), tb(ol(l, a));
              break e;
            }
          }
          o = l = ol(l, a), It !== 4 && (It = 2), _c === null ? _c = [
            o
          ] : _c.push(o), o = s;
          do {
            switch (o.tag) {
              case 3:
                o.flags |= 65536, e &= -e, o.lanes |= e;
                var w = K2(o, l, e);
                GS(o, w);
                break e;
              case 1:
                a = l;
                var k = o.type, C = o.stateNode;
                if ((o.flags & 128) === 0 && (typeof k.getDerivedStateFromError == "function" || C !== null && typeof C.componentDidCatch == "function" && (Vo === null || !Vo.has(C)))) {
                  o.flags |= 65536, e &= -e, o.lanes |= e;
                  var P = q2(o, a, e);
                  GS(o, P);
                  break e;
                }
            }
            o = o.return;
          } while (o !== null);
        }
        hA(n);
      } catch (R) {
        e = R, Rt === n && n !== null && (Rt = n = n.return);
        continue;
      }
      break;
    } while (1);
  }
  function uA() {
    var t = Qd.current;
    return Qd.current = Xd, t === null ? Xd : t;
  }
  function Sb() {
    (It === 0 || It === 3 || It === 2) && (It = 4), jt === null || (Vs & 268435455) === 0 && (em & 268435455) === 0 || Co(jt, tn);
  }
  function ep(t, e) {
    var n = je;
    je |= 2;
    var r = uA();
    (jt !== t || tn !== e) && (Bi = null, Rs(t, e));
    do
      try {
        mI();
        break;
      } catch (i) {
        cA(t, i);
      }
    while (1);
    if (rb(), je = n, Qd.current = r, Rt !== null)
      throw Error(Z(261));
    return jt = null, tn = 0, It;
  }
  function mI() {
    for (; Rt !== null; )
      fA(Rt);
  }
  function gI() {
    for (; Rt !== null && !V_(); )
      fA(Rt);
  }
  function fA(t) {
    var e = pA(t.alternate, t, Wn);
    t.memoizedProps = t.pendingProps, e === null ? hA(t) : Rt = e, gb.current = null;
  }
  function hA(t) {
    var e = t;
    do {
      var n = e.alternate;
      if (t = e.return, (e.flags & 32768) === 0) {
        if (n = lI(n, e, Wn), n !== null) {
          Rt = n;
          return;
        }
      } else {
        if (n = cI(n, e), n !== null) {
          n.flags &= 32767, Rt = n;
          return;
        }
        if (t !== null)
          t.flags |= 32768, t.subtreeFlags = 0, t.deletions = null;
        else {
          It = 6, Rt = null;
          return;
        }
      }
      if (e = e.sibling, e !== null) {
        Rt = e;
        return;
      }
      Rt = e = t;
    } while (e !== null);
    It === 0 && (It = 5);
  }
  function ys(t, e, n) {
    var r = Ye, i = br.transition;
    try {
      br.transition = null, Ye = 1, vI(t, e, n, r);
    } finally {
      br.transition = i, Ye = r;
    }
    return null;
  }
  function vI(t, e, n, r) {
    do
      Va();
    while (Po !== null);
    if ((je & 6) !== 0)
      throw Error(Z(327));
    n = t.finishedWork;
    var i = t.finishedLanes;
    if (n === null)
      return null;
    if (t.finishedWork = null, t.finishedLanes = 0, n === t.current)
      throw Error(Z(177));
    t.callbackNode = null, t.callbackPriority = 0;
    var o = n.lanes | n.childLanes;
    if (Q_(t, o), t === jt && (Rt = jt = null, tn = 0), (n.subtreeFlags & 2064) === 0 && (n.flags & 2064) === 0 || ih || (ih = true, mA(Id, function() {
      return Va(), null;
    })), o = (n.flags & 15990) !== 0, (n.subtreeFlags & 15990) !== 0 || o) {
      o = br.transition, br.transition = null;
      var s = Ye;
      Ye = 1;
      var a = je;
      je |= 4, gb.current = null, fI(t, n), sA(n, t), ND(Ev), Nd = !!Av, Ev = Av = null, t.current = n, hI(n), H_(), je = a, Ye = s, br.transition = o;
    } else
      t.current = n;
    if (ih && (ih = false, Po = t, Zd = i), o = t.pendingLanes, o === 0 && (Vo = null), U_(n.stateNode), Fn(t, Mt()), e !== null)
      for (r = t.onRecoverableError, n = 0; n < e.length; n++)
        i = e[n], r(i.value, {
          componentStack: i.stack,
          digest: i.digest
        });
    if (Jd)
      throw Jd = false, t = Gv, Gv = null, t;
    return (Zd & 1) !== 0 && t.tag !== 0 && Va(), o = t.pendingLanes, (o & 1) !== 0 ? t === Yv ? Dc++ : (Dc = 0, Yv = t) : Dc = 0, ts(), null;
  }
  function Va() {
    if (Po !== null) {
      var t = UM(Zd), e = br.transition, n = Ye;
      try {
        if (br.transition = null, Ye = 16 > t ? 16 : t, Po === null)
          var r = false;
        else {
          if (t = Po, Po = null, Zd = 0, (je & 6) !== 0)
            throw Error(Z(331));
          var i = je;
          for (je |= 4, ge = t.current; ge !== null; ) {
            var o = ge, s = o.child;
            if ((ge.flags & 16) !== 0) {
              var a = o.deletions;
              if (a !== null) {
                for (var l = 0; l < a.length; l++) {
                  var c = a[l];
                  for (ge = c; ge !== null; ) {
                    var u = ge;
                    switch (u.tag) {
                      case 0:
                      case 11:
                      case 15:
                        Lc(8, u, o);
                    }
                    var h = u.child;
                    if (h !== null)
                      h.return = u, ge = h;
                    else
                      for (; ge !== null; ) {
                        u = ge;
                        var p = u.sibling, v = u.return;
                        if (rA(u), u === c) {
                          ge = null;
                          break;
                        }
                        if (p !== null) {
                          p.return = v, ge = p;
                          break;
                        }
                        ge = v;
                      }
                  }
                }
                var y = o.alternate;
                if (y !== null) {
                  var x = y.child;
                  if (x !== null) {
                    y.child = null;
                    do {
                      var T = x.sibling;
                      x.sibling = null, x = T;
                    } while (x !== null);
                  }
                }
                ge = o;
              }
            }
            if ((o.subtreeFlags & 2064) !== 0 && s !== null)
              s.return = o, ge = s;
            else
              e:
                for (; ge !== null; ) {
                  if (o = ge, (o.flags & 2048) !== 0)
                    switch (o.tag) {
                      case 0:
                      case 11:
                      case 15:
                        Lc(9, o, o.return);
                    }
                  var w = o.sibling;
                  if (w !== null) {
                    w.return = o.return, ge = w;
                    break e;
                  }
                  ge = o.return;
                }
          }
          var k = t.current;
          for (ge = k; ge !== null; ) {
            s = ge;
            var C = s.child;
            if ((s.subtreeFlags & 2064) !== 0 && C !== null)
              C.return = s, ge = C;
            else
              e:
                for (s = k; ge !== null; ) {
                  if (a = ge, (a.flags & 2048) !== 0)
                    try {
                      switch (a.tag) {
                        case 0:
                        case 11:
                        case 15:
                          Zp(9, a);
                      }
                    } catch (R) {
                      St(a, a.return, R);
                    }
                  if (a === s) {
                    ge = null;
                    break e;
                  }
                  var P = a.sibling;
                  if (P !== null) {
                    P.return = a.return, ge = P;
                    break e;
                  }
                  ge = a.return;
                }
          }
          if (je = i, ts(), xi && typeof xi.onPostCommitFiberRoot == "function")
            try {
              xi.onPostCommitFiberRoot(Up, t);
            } catch {
            }
          r = true;
        }
        return r;
      } finally {
        Ye = n, br.transition = e;
      }
    }
    return false;
  }
  function gw(t, e, n) {
    e = ol(n, e), e = K2(t, e, 1), t = Fo(t, e, 1), e = wn(), t !== null && (Gu(t, 1, e), Fn(t, e));
  }
  function St(t, e, n) {
    if (t.tag === 3)
      gw(t, t, n);
    else
      for (; e !== null; ) {
        if (e.tag === 3) {
          gw(e, t, n);
          break;
        } else if (e.tag === 1) {
          var r = e.stateNode;
          if (typeof e.type.getDerivedStateFromError == "function" || typeof r.componentDidCatch == "function" && (Vo === null || !Vo.has(r))) {
            t = ol(n, t), t = q2(e, t, 1), e = Fo(e, t, 1), t = wn(), e !== null && (Gu(e, 1, t), Fn(e, t));
            break;
          }
        }
        e = e.return;
      }
  }
  function yI(t, e, n) {
    var r = t.pingCache;
    r !== null && r.delete(e), e = wn(), t.pingedLanes |= t.suspendedLanes & n, jt === t && (tn & n) === n && (It === 4 || It === 3 && (tn & 130023424) === tn && 500 > Mt() - yb ? Rs(t, 0) : vb |= n), Fn(t, e);
  }
  function dA(t, e) {
    e === 0 && ((t.mode & 1) === 0 ? e = 1 : (e = Gf, Gf <<= 1, (Gf & 130023424) === 0 && (Gf = 4194304)));
    var n = wn();
    t = Xi(t, e), t !== null && (Gu(t, e, n), Fn(t, n));
  }
  function bI(t) {
    var e = t.memoizedState, n = 0;
    e !== null && (n = e.retryLane), dA(t, n);
  }
  function xI(t, e) {
    var n = 0;
    switch (t.tag) {
      case 13:
        var r = t.stateNode, i = t.memoizedState;
        i !== null && (n = i.retryLane);
        break;
      case 19:
        r = t.stateNode;
        break;
      default:
        throw Error(Z(314));
    }
    r !== null && r.delete(e), dA(t, n);
  }
  var pA;
  pA = function(t, e, n) {
    if (t !== null)
      if (t.memoizedProps !== e.pendingProps || $n.current)
        In = true;
      else {
        if ((t.lanes & n) === 0 && (e.flags & 128) === 0)
          return In = false, aI(t, e, n);
        In = (t.flags & 131072) !== 0;
      }
    else
      In = false, ft && (e.flags & 1048576) !== 0 && v2(e, Wd, e.index);
    switch (e.lanes = 0, e.tag) {
      case 2:
        var r = e.type;
        Zh(t, e), t = e.pendingProps;
        var i = tl(e, pn.current);
        Fa(e, n), i = fb(null, e, r, t, i, n);
        var o = hb();
        return e.flags |= 1, typeof i == "object" && i !== null && typeof i.render == "function" && i.$$typeof === void 0 ? (e.tag = 1, e.memoizedState = null, e.updateQueue = null, zn(r) ? (o = true, Hd(e)) : o = false, e.memoizedState = i.state !== null && i.state !== void 0 ? i.state : null, sb(e), i.updater = Qp, e.stateNode = i, i._reactInternals = e, Nv(e, r, t, n), e = Fv(null, e, r, true, o, n)) : (e.tag = 0, ft && o && Z1(e), bn(null, e, i, n), e = e.child), e;
      case 16:
        r = e.elementType;
        e: {
          switch (Zh(t, e), t = e.pendingProps, i = r._init, r = i(r._payload), e.type = r, i = e.tag = wI(r), t = Dr(r, t), i) {
            case 0:
              e = zv(null, e, r, t, n);
              break e;
            case 1:
              e = sw(null, e, r, t, n);
              break e;
            case 11:
              e = iw(null, e, r, t, n);
              break e;
            case 14:
              e = ow(null, e, r, Dr(r.type, t), n);
              break e;
          }
          throw Error(Z(306, r, ""));
        }
        return e;
      case 0:
        return r = e.type, i = e.pendingProps, i = e.elementType === r ? i : Dr(r, i), zv(t, e, r, i, n);
      case 1:
        return r = e.type, i = e.pendingProps, i = e.elementType === r ? i : Dr(r, i), sw(t, e, r, i, n);
      case 3:
        e: {
          if (Q2(e), t === null)
            throw Error(Z(387));
          r = e.pendingProps, o = e.memoizedState, i = o.element, S2(t, e), qd(e, r, null, n);
          var s = e.memoizedState;
          if (r = s.element, o.isDehydrated)
            if (o = {
              element: r,
              isDehydrated: false,
              cache: s.cache,
              pendingSuspenseBoundaries: s.pendingSuspenseBoundaries,
              transitions: s.transitions
            }, e.updateQueue.baseState = o, e.memoizedState = o, e.flags & 256) {
              i = ol(Error(Z(423)), e), e = aw(t, e, r, n, i);
              break e;
            } else if (r !== i) {
              i = ol(Error(Z(424)), e), e = aw(t, e, r, n, i);
              break e;
            } else
              for (Kn = zo(e.stateNode.containerInfo.firstChild), Gn = e, ft = true, Nr = null, n = T2(e, null, r, n), e.child = n; n; )
                n.flags = n.flags & -3 | 4096, n = n.sibling;
          else {
            if (nl(), r === i) {
              e = Qi(t, e, n);
              break e;
            }
            bn(t, e, r, n);
          }
          e = e.child;
        }
        return e;
      case 5:
        return M2(e), t === null && Dv(e), r = e.type, i = e.pendingProps, o = t !== null ? t.memoizedProps : null, s = i.children, Pv(r, i) ? s = null : o !== null && Pv(r, o) && (e.flags |= 32), X2(t, e), bn(t, e, s, n), e.child;
      case 6:
        return t === null && Dv(e), null;
      case 13:
        return J2(t, e, n);
      case 4:
        return ab(e, e.stateNode.containerInfo), r = e.pendingProps, t === null ? e.child = rl(e, null, r, n) : bn(t, e, r, n), e.child;
      case 11:
        return r = e.type, i = e.pendingProps, i = e.elementType === r ? i : Dr(r, i), iw(t, e, r, i, n);
      case 7:
        return bn(t, e, e.pendingProps, n), e.child;
      case 8:
        return bn(t, e, e.pendingProps.children, n), e.child;
      case 12:
        return bn(t, e, e.pendingProps.children, n), e.child;
      case 10:
        e: {
          if (r = e.type._context, i = e.pendingProps, o = e.memoizedProps, s = i.value, nt(Ud, r._currentValue), r._currentValue = s, o !== null)
            if (Ur(o.value, s)) {
              if (o.children === i.children && !$n.current) {
                e = Qi(t, e, n);
                break e;
              }
            } else
              for (o = e.child, o !== null && (o.return = e); o !== null; ) {
                var a = o.dependencies;
                if (a !== null) {
                  s = o.child;
                  for (var l = a.firstContext; l !== null; ) {
                    if (l.context === r) {
                      if (o.tag === 1) {
                        l = Ui(-1, n & -n), l.tag = 2;
                        var c = o.updateQueue;
                        if (c !== null) {
                          c = c.shared;
                          var u = c.pending;
                          u === null ? l.next = l : (l.next = u.next, u.next = l), c.pending = l;
                        }
                      }
                      o.lanes |= n, l = o.alternate, l !== null && (l.lanes |= n), Iv(o.return, n, e), a.lanes |= n;
                      break;
                    }
                    l = l.next;
                  }
                } else if (o.tag === 10)
                  s = o.type === e.type ? null : o.child;
                else if (o.tag === 18) {
                  if (s = o.return, s === null)
                    throw Error(Z(341));
                  s.lanes |= n, a = s.alternate, a !== null && (a.lanes |= n), Iv(s, n, e), s = o.sibling;
                } else
                  s = o.child;
                if (s !== null)
                  s.return = o;
                else
                  for (s = o; s !== null; ) {
                    if (s === e) {
                      s = null;
                      break;
                    }
                    if (o = s.sibling, o !== null) {
                      o.return = s.return, s = o;
                      break;
                    }
                    s = s.return;
                  }
                o = s;
              }
          bn(t, e, i.children, n), e = e.child;
        }
        return e;
      case 9:
        return i = e.type, r = e.pendingProps.children, Fa(e, n), i = wr(i), r = r(i), e.flags |= 1, bn(t, e, r, n), e.child;
      case 14:
        return r = e.type, i = Dr(r, e.pendingProps), i = Dr(r.type, i), ow(t, e, r, i, n);
      case 15:
        return G2(t, e, e.type, e.pendingProps, n);
      case 17:
        return r = e.type, i = e.pendingProps, i = e.elementType === r ? i : Dr(r, i), Zh(t, e), e.tag = 1, zn(r) ? (t = true, Hd(e)) : t = false, Fa(e, n), k2(e, r, i), Nv(e, r, i, n), Fv(null, e, r, true, t, n);
      case 19:
        return Z2(t, e, n);
      case 22:
        return Y2(t, e, n);
    }
    throw Error(Z(156, e.tag));
  };
  function mA(t, e) {
    return VM(t, e);
  }
  function SI(t, e, n, r) {
    this.tag = t, this.key = n, this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null, this.index = 0, this.ref = null, this.pendingProps = e, this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null, this.mode = r, this.subtreeFlags = this.flags = 0, this.deletions = null, this.childLanes = this.lanes = 0, this.alternate = null;
  }
  function pr(t, e, n, r) {
    return new SI(t, e, n, r);
  }
  function wb(t) {
    return t = t.prototype, !(!t || !t.isReactComponent);
  }
  function wI(t) {
    if (typeof t == "function")
      return wb(t) ? 1 : 0;
    if (t != null) {
      if (t = t.$$typeof, t === V1)
        return 11;
      if (t === H1)
        return 14;
    }
    return 2;
  }
  function jo(t, e) {
    var n = t.alternate;
    return n === null ? (n = pr(t.tag, e, t.key, t.mode), n.elementType = t.elementType, n.type = t.type, n.stateNode = t.stateNode, n.alternate = t, t.alternate = n) : (n.pendingProps = e, n.type = t.type, n.flags = 0, n.subtreeFlags = 0, n.deletions = null), n.flags = t.flags & 14680064, n.childLanes = t.childLanes, n.lanes = t.lanes, n.child = t.child, n.memoizedProps = t.memoizedProps, n.memoizedState = t.memoizedState, n.updateQueue = t.updateQueue, e = t.dependencies, n.dependencies = e === null ? null : {
      lanes: e.lanes,
      firstContext: e.firstContext
    }, n.sibling = t.sibling, n.index = t.index, n.ref = t.ref, n;
  }
  function nd(t, e, n, r, i, o) {
    var s = 2;
    if (r = t, typeof t == "function")
      wb(t) && (s = 1);
    else if (typeof t == "string")
      s = 5;
    else
      e:
        switch (t) {
          case pa:
            return Ls(n.children, i, o, e);
          case F1:
            s = 8, i |= 8;
            break;
          case av:
            return t = pr(12, n, e, i | 2), t.elementType = av, t.lanes = o, t;
          case lv:
            return t = pr(13, n, e, i), t.elementType = lv, t.lanes = o, t;
          case cv:
            return t = pr(19, n, e, i), t.elementType = cv, t.lanes = o, t;
          case CM:
            return tm(n, i, o, e);
          default:
            if (typeof t == "object" && t !== null)
              switch (t.$$typeof) {
                case wM:
                  s = 10;
                  break e;
                case kM:
                  s = 9;
                  break e;
                case V1:
                  s = 11;
                  break e;
                case H1:
                  s = 14;
                  break e;
                case yo:
                  s = 16, r = null;
                  break e;
              }
            throw Error(Z(130, t == null ? t : typeof t, ""));
        }
    return e = pr(s, n, e, i), e.elementType = t, e.type = r, e.lanes = o, e;
  }
  function Ls(t, e, n, r) {
    return t = pr(7, t, r, e), t.lanes = n, t;
  }
  function tm(t, e, n, r) {
    return t = pr(22, t, r, e), t.elementType = CM, t.lanes = n, t.stateNode = {
      isHidden: false
    }, t;
  }
  function Yg(t, e, n) {
    return t = pr(6, t, null, e), t.lanes = n, t;
  }
  function Xg(t, e, n) {
    return e = pr(4, t.children !== null ? t.children : [], t.key, e), e.lanes = n, e.stateNode = {
      containerInfo: t.containerInfo,
      pendingChildren: null,
      implementation: t.implementation
    }, e;
  }
  function kI(t, e, n, r, i) {
    this.tag = e, this.containerInfo = t, this.finishedWork = this.pingCache = this.current = this.pendingChildren = null, this.timeoutHandle = -1, this.callbackNode = this.pendingContext = this.context = null, this.callbackPriority = 0, this.eventTimes = Og(0), this.expirationTimes = Og(-1), this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0, this.entanglements = Og(0), this.identifierPrefix = r, this.onRecoverableError = i, this.mutableSourceEagerHydrationData = null;
  }
  function kb(t, e, n, r, i, o, s, a, l) {
    return t = new kI(t, e, n, a, l), e === 1 ? (e = 1, o === true && (e |= 8)) : e = 0, o = pr(3, null, null, e), t.current = o, o.stateNode = t, o.memoizedState = {
      element: r,
      isDehydrated: n,
      cache: null,
      transitions: null,
      pendingSuspenseBoundaries: null
    }, sb(o), t;
  }
  function CI(t, e, n) {
    var r = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null;
    return {
      $$typeof: da,
      key: r == null ? null : "" + r,
      children: t,
      containerInfo: e,
      implementation: n
    };
  }
  function gA(t) {
    if (!t)
      return Ko;
    t = t._reactInternals;
    e: {
      if (Qs(t) !== t || t.tag !== 1)
        throw Error(Z(170));
      var e = t;
      do {
        switch (e.tag) {
          case 3:
            e = e.stateNode.context;
            break e;
          case 1:
            if (zn(e.type)) {
              e = e.stateNode.__reactInternalMemoizedMergedChildContext;
              break e;
            }
        }
        e = e.return;
      } while (e !== null);
      throw Error(Z(171));
    }
    if (t.tag === 1) {
      var n = t.type;
      if (zn(n))
        return m2(t, n, e);
    }
    return e;
  }
  function vA(t, e, n, r, i, o, s, a, l) {
    return t = kb(n, r, true, t, i, o, s, a, l), t.context = gA(null), n = t.current, r = wn(), i = Ho(n), o = Ui(r, i), o.callback = e ?? null, Fo(n, o, i), t.current.lanes = i, Gu(t, i, r), Fn(t, r), t;
  }
  function nm(t, e, n, r) {
    var i = e.current, o = wn(), s = Ho(i);
    return n = gA(n), e.context === null ? e.context = n : e.pendingContext = n, e = Ui(o, s), e.payload = {
      element: t
    }, r = r === void 0 ? null : r, r !== null && (e.callback = r), t = Fo(i, e, s), t !== null && (Vr(t, i, s, o), Xh(t, i, s)), s;
  }
  function tp(t) {
    if (t = t.current, !t.child)
      return null;
    switch (t.child.tag) {
      case 5:
        return t.child.stateNode;
      default:
        return t.child.stateNode;
    }
  }
  function vw(t, e) {
    if (t = t.memoizedState, t !== null && t.dehydrated !== null) {
      var n = t.retryLane;
      t.retryLane = n !== 0 && n < e ? n : e;
    }
  }
  function Cb(t, e) {
    vw(t, e), (t = t.alternate) && vw(t, e);
  }
  function TI() {
    return null;
  }
  var yA = typeof reportError == "function" ? reportError : function(t) {
    console.error(t);
  };
  function Tb(t) {
    this._internalRoot = t;
  }
  rm.prototype.render = Tb.prototype.render = function(t) {
    var e = this._internalRoot;
    if (e === null)
      throw Error(Z(409));
    nm(t, e, null, null);
  };
  rm.prototype.unmount = Tb.prototype.unmount = function() {
    var t = this._internalRoot;
    if (t !== null) {
      this._internalRoot = null;
      var e = t.containerInfo;
      Hs(function() {
        nm(null, t, null, null);
      }), e[Yi] = null;
    }
  };
  function rm(t) {
    this._internalRoot = t;
  }
  rm.prototype.unstable_scheduleHydration = function(t) {
    if (t) {
      var e = GM();
      t = {
        blockedOn: null,
        target: t,
        priority: e
      };
      for (var n = 0; n < ko.length && e !== 0 && e < ko[n].priority; n++)
        ;
      ko.splice(n, 0, t), n === 0 && XM(t);
    }
  };
  function Mb(t) {
    return !(!t || t.nodeType !== 1 && t.nodeType !== 9 && t.nodeType !== 11);
  }
  function im(t) {
    return !(!t || t.nodeType !== 1 && t.nodeType !== 9 && t.nodeType !== 11 && (t.nodeType !== 8 || t.nodeValue !== " react-mount-point-unstable "));
  }
  function yw() {
  }
  function MI(t, e, n, r, i) {
    if (i) {
      if (typeof r == "function") {
        var o = r;
        r = function() {
          var c = tp(s);
          o.call(c);
        };
      }
      var s = vA(e, r, t, 0, null, false, false, "", yw);
      return t._reactRootContainer = s, t[Yi] = s.current, fu(t.nodeType === 8 ? t.parentNode : t), Hs(), s;
    }
    for (; i = t.lastChild; )
      t.removeChild(i);
    if (typeof r == "function") {
      var a = r;
      r = function() {
        var c = tp(l);
        a.call(c);
      };
    }
    var l = kb(t, 0, false, null, null, false, false, "", yw);
    return t._reactRootContainer = l, t[Yi] = l.current, fu(t.nodeType === 8 ? t.parentNode : t), Hs(function() {
      nm(e, l, n, r);
    }), l;
  }
  function om(t, e, n, r, i) {
    var o = n._reactRootContainer;
    if (o) {
      var s = o;
      if (typeof i == "function") {
        var a = i;
        i = function() {
          var l = tp(s);
          a.call(l);
        };
      }
      nm(e, s, t, i);
    } else
      s = MI(n, e, t, i, r);
    return tp(s);
  }
  KM = function(t) {
    switch (t.tag) {
      case 3:
        var e = t.stateNode;
        if (e.current.memoizedState.isDehydrated) {
          var n = dc(e.pendingLanes);
          n !== 0 && (U1(e, n | 1), Fn(e, Mt()), (je & 6) === 0 && (sl = Mt() + 500, ts()));
        }
        break;
      case 13:
        Hs(function() {
          var r = Xi(t, 1);
          if (r !== null) {
            var i = wn();
            Vr(r, t, 1, i);
          }
        }), Cb(t, 1);
    }
  };
  K1 = function(t) {
    if (t.tag === 13) {
      var e = Xi(t, 134217728);
      if (e !== null) {
        var n = wn();
        Vr(e, t, 134217728, n);
      }
      Cb(t, 134217728);
    }
  };
  qM = function(t) {
    if (t.tag === 13) {
      var e = Ho(t), n = Xi(t, e);
      if (n !== null) {
        var r = wn();
        Vr(n, t, e, r);
      }
      Cb(t, e);
    }
  };
  GM = function() {
    return Ye;
  };
  YM = function(t, e) {
    var n = Ye;
    try {
      return Ye = t, e();
    } finally {
      Ye = n;
    }
  };
  bv = function(t, e, n) {
    switch (e) {
      case "input":
        if (hv(t, n), e = n.name, n.type === "radio" && e != null) {
          for (n = t; n.parentNode; )
            n = n.parentNode;
          for (n = n.querySelectorAll("input[name=" + JSON.stringify("" + e) + '][type="radio"]'), e = 0; e < n.length; e++) {
            var r = n[e];
            if (r !== t && r.form === t.form) {
              var i = Yp(r);
              if (!i)
                throw Error(Z(90));
              MM(r), hv(r, i);
            }
          }
        }
        break;
      case "textarea":
        EM(t, n);
        break;
      case "select":
        e = n.value, e != null && Ba(t, !!n.multiple, e, false);
    }
  };
  IM = bb;
  BM = Hs;
  var AI = {
    usingClientEntryPoint: false,
    Events: [
      Xu,
      ya,
      Yp,
      _M,
      DM,
      bb
    ]
  }, Jl = {
    findFiberByHostInstance: Cs,
    bundleType: 0,
    version: "18.2.0",
    rendererPackageName: "react-dom"
  }, EI = {
    bundleType: Jl.bundleType,
    version: Jl.version,
    rendererPackageName: Jl.rendererPackageName,
    rendererConfig: Jl.rendererConfig,
    overrideHookState: null,
    overrideHookStateDeletePath: null,
    overrideHookStateRenamePath: null,
    overrideProps: null,
    overridePropsDeletePath: null,
    overridePropsRenamePath: null,
    setErrorHandler: null,
    setSuspenseHandler: null,
    scheduleUpdate: null,
    currentDispatcherRef: io.ReactCurrentDispatcher,
    findHostInstanceByFiber: function(t) {
      return t = zM(t), t === null ? null : t.stateNode;
    },
    findFiberByHostInstance: Jl.findFiberByHostInstance || TI,
    findHostInstancesForRefresh: null,
    scheduleRefresh: null,
    scheduleRoot: null,
    setRefreshHandler: null,
    getCurrentFiber: null,
    reconcilerVersion: "18.2.0-next-9e3b772b8-20220608"
  };
  if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u") {
    var oh = __REACT_DEVTOOLS_GLOBAL_HOOK__;
    if (!oh.isDisabled && oh.supportsFiber)
      try {
        Up = oh.inject(EI), xi = oh;
      } catch {
      }
  }
  Zn.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = AI;
  Zn.createPortal = function(t, e) {
    var n = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null;
    if (!Mb(e))
      throw Error(Z(200));
    return CI(t, e, null, n);
  };
  Zn.createRoot = function(t, e) {
    if (!Mb(t))
      throw Error(Z(299));
    var n = false, r = "", i = yA;
    return e != null && (e.unstable_strictMode === true && (n = true), e.identifierPrefix !== void 0 && (r = e.identifierPrefix), e.onRecoverableError !== void 0 && (i = e.onRecoverableError)), e = kb(t, 1, false, null, null, n, false, r, i), t[Yi] = e.current, fu(t.nodeType === 8 ? t.parentNode : t), new Tb(e);
  };
  Zn.findDOMNode = function(t) {
    if (t == null)
      return null;
    if (t.nodeType === 1)
      return t;
    var e = t._reactInternals;
    if (e === void 0)
      throw typeof t.render == "function" ? Error(Z(188)) : (t = Object.keys(t).join(","), Error(Z(268, t)));
    return t = zM(e), t = t === null ? null : t.stateNode, t;
  };
  Zn.flushSync = function(t) {
    return Hs(t);
  };
  Zn.hydrate = function(t, e, n) {
    if (!im(e))
      throw Error(Z(200));
    return om(null, t, e, true, n);
  };
  Zn.hydrateRoot = function(t, e, n) {
    if (!Mb(t))
      throw Error(Z(405));
    var r = n != null && n.hydratedSources || null, i = false, o = "", s = yA;
    if (n != null && (n.unstable_strictMode === true && (i = true), n.identifierPrefix !== void 0 && (o = n.identifierPrefix), n.onRecoverableError !== void 0 && (s = n.onRecoverableError)), e = vA(e, null, t, 1, n ?? null, i, false, o, s), t[Yi] = e.current, fu(t), r)
      for (t = 0; t < r.length; t++)
        n = r[t], i = n._getVersion, i = i(n._source), e.mutableSourceEagerHydrationData == null ? e.mutableSourceEagerHydrationData = [
          n,
          i
        ] : e.mutableSourceEagerHydrationData.push(n, i);
    return new rm(e);
  };
  Zn.render = function(t, e, n) {
    if (!im(e))
      throw Error(Z(200));
    return om(null, t, e, false, n);
  };
  Zn.unmountComponentAtNode = function(t) {
    if (!im(t))
      throw Error(Z(40));
    return t._reactRootContainer ? (Hs(function() {
      om(null, null, t, false, function() {
        t._reactRootContainer = null, t[Yi] = null;
      });
    }), true) : false;
  };
  Zn.unstable_batchedUpdates = bb;
  Zn.unstable_renderSubtreeIntoContainer = function(t, e, n, r) {
    if (!im(n))
      throw Error(Z(200));
    if (t == null || t._reactInternals === void 0)
      throw Error(Z(38));
    return om(t, e, n, false, r);
  };
  Zn.version = "18.2.0-next-9e3b772b8-20220608";
  (function(t) {
    function e() {
      if (!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function"))
        try {
          __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(e);
        } catch (n) {
          console.error(n);
        }
    }
    e(), t.exports = Zn;
  })(Wp);
  var bw = Wp.exports;
  ov.createRoot = bw.createRoot, ov.hydrateRoot = bw.hydrateRoot;
  function PI() {
    return Boolean(globalThis == null ? void 0 : globalThis.document);
  }
  function OI(t, ...e) {
    if (t == null)
      throw new TypeError("Cannot convert undefined or null to object");
    const n = {
      ...t
    };
    for (const r of e)
      if (r != null)
        for (const i in r)
          !Object.prototype.hasOwnProperty.call(r, i) || (i in n && delete n[i], n[i] = r[i]);
    return n;
  }
  const RI = (t) => t ? "" : void 0;
  function LI(t) {
    return Array.isArray(t);
  }
  function Hr(t) {
    const e = typeof t;
    return t != null && (e === "object" || e === "function") && !LI(t);
  }
  function _I(t) {
    const e = t == null ? 0 : t.length;
    return e ? t[e - 1] : void 0;
  }
  function DI(t) {
    const e = parseFloat(t.toString()), n = t.toString().replace(String(e), "");
    return {
      unitless: !n,
      value: e,
      unit: n
    };
  }
  function Jv(t) {
    if (t == null)
      return t;
    const { unitless: e } = DI(t);
    return e || typeof t == "number" ? `${t}px` : t;
  }
  const bA = (t, e) => parseInt(t[1], 10) > parseInt(e[1], 10) ? 1 : -1, Ab = (t) => Object.fromEntries(Object.entries(t).sort(bA));
  function xw(t) {
    const e = Ab(t);
    return Object.assign(Object.values(e), e);
  }
  function II(t) {
    const e = Object.keys(Ab(t));
    return new Set(e);
  }
  function Sw(t) {
    if (!t)
      return t;
    t = Jv(t) ?? t;
    const e = -0.02;
    return typeof t == "number" ? `${t + e}` : t.replace(/(\d+\.?\d*)/u, (n) => `${parseFloat(n) + e}`);
  }
  function mc(t, e) {
    const n = [
      "@media screen"
    ];
    return t && n.push("and", `(min-width: ${Jv(t)})`), e && n.push("and", `(max-width: ${Jv(e)})`), n.join(" ");
  }
  function BI(t) {
    if (!t)
      return null;
    t.base = t.base ?? "0px";
    const e = xw(t), n = Object.entries(t).sort(bA).map(([o, s], a, l) => {
      let [, c] = l[a + 1] ?? [];
      return c = parseFloat(c) > 0 ? Sw(c) : void 0, {
        _minW: Sw(s),
        breakpoint: o,
        minW: s,
        maxW: c,
        maxWQuery: mc(null, c),
        minWQuery: mc(s),
        minMaxQuery: mc(s, c)
      };
    }), r = II(t), i = Array.from(r.values());
    return {
      keys: r,
      normalized: e,
      isResponsive(o) {
        const s = Object.keys(o);
        return s.length > 0 && s.every((a) => r.has(a));
      },
      asObject: Ab(t),
      asArray: xw(t),
      details: n,
      get(o) {
        return n.find((s) => s.breakpoint === o);
      },
      media: [
        null,
        ...e.map((o) => mc(o)).slice(1)
      ],
      toArrayValue(o) {
        if (!Hr(o))
          throw new Error("toArrayValue: value must be an object");
        const s = i.map((a) => o[a] ?? null);
        for (; _I(s) === null; )
          s.pop();
        return s;
      },
      toObjectValue(o) {
        if (!Array.isArray(o))
          throw new Error("toObjectValue: value must be an array");
        return o.reduce((s, a, l) => {
          const c = i[l];
          return c != null && a != null && (s[c] = a), s;
        }, {});
      }
    };
  }
  function Zv(...t) {
    return function(n) {
      t.some((r) => (r == null ? void 0 : r(n), n == null ? void 0 : n.defaultPrevented));
    };
  }
  function NI(t) {
    return z.exports.Children.toArray(t).filter((e) => z.exports.isValidElement(e));
  }
  function $I(t) {
    const e = Object.assign({}, t);
    for (let n in e)
      e[n] === void 0 && delete e[n];
    return e;
  }
  function zI(t, e) {
    return `${t} returned \`undefined\`. Seems you forgot to wrap component within ${e}`;
  }
  function Ei(t = {}) {
    const { name: e, strict: n = true, hookName: r = "useContext", providerName: i = "Provider", errorMessage: o, defaultValue: s } = t, a = z.exports.createContext(s);
    a.displayName = e;
    function l() {
      var _a3;
      const c = z.exports.useContext(a);
      if (!c && n) {
        const u = new Error(o ?? zI(r, i));
        throw u.name = "ContextError", (_a3 = Error.captureStackTrace) == null ? void 0 : _a3.call(Error, u, l), u;
      }
      return c;
    }
    return [
      a.Provider,
      l,
      a
    ];
  }
  const Gr = (...t) => t.filter(Boolean).join(" ");
  function FI(t, e, n, r) {
    const i = typeof e == "string" ? e.split(".") : [
      e
    ];
    for (r = 0; r < i.length && t; r += 1)
      t = t[i[r]];
    return t === void 0 ? n : t;
  }
  const VI = (t) => {
    const e = /* @__PURE__ */ new WeakMap();
    return (r, i, o, s) => {
      if (typeof r > "u")
        return t(r, i, o);
      e.has(r) || e.set(r, /* @__PURE__ */ new Map());
      const a = e.get(r);
      if (a.has(i))
        return a.get(i);
      const l = t(r, i, o, s);
      return a.set(i, l), l;
    };
  }, xA = VI(FI), HI = (t) => t.default || t;
  function jI(t) {
    const { wasSelected: e, enabled: n, isSelected: r, mode: i = "unmount" } = t;
    return !!(!n || r || i === "keepMounted" && e);
  }
  function WI(t, e = []) {
    const n = Object.assign({}, t);
    for (const r of e)
      r in n && delete n[r];
    return n;
  }
  function UI(t, e) {
    const n = {};
    for (const r of e)
      r in t && (n[r] = t[r]);
    return n;
  }
  const KI = (t) => typeof t == "function";
  function vi(t, ...e) {
    return KI(t) ? t(...e) : t;
  }
  function qI(t, ...e) {
    const n = Object.getOwnPropertyDescriptors(t), r = Object.keys(n), i = (s) => {
      const a = {};
      for (let l = 0; l < s.length; l++) {
        const c = s[l];
        n[c] && (Object.defineProperty(a, c, n[c]), delete n[c]);
      }
      return a;
    }, o = (s) => i(Array.isArray(s) ? s : r.filter(s));
    return e.map(o).concat(i(r));
  }
  function ww(t, e, n = {}) {
    const { stop: r, getKey: i } = n;
    function o(s, a = []) {
      if (Hr(s) || Array.isArray(s)) {
        const l = {};
        for (const [c, u] of Object.entries(s)) {
          const h = (i == null ? void 0 : i(c)) ?? c, p = [
            ...a,
            h
          ];
          if (r == null ? void 0 : r(s, p))
            return e(s, a);
          l[h] = o(u, p);
        }
        return l;
      }
      return e(s, a);
    }
    return o(t);
  }
  var ey = {
    exports: {}
  };
  (function(t, e) {
    var n = 200, r = "__lodash_hash_undefined__", i = 800, o = 16, s = 9007199254740991, a = "[object Arguments]", l = "[object Array]", c = "[object AsyncFunction]", u = "[object Boolean]", h = "[object Date]", p = "[object Error]", v = "[object Function]", y = "[object GeneratorFunction]", x = "[object Map]", T = "[object Number]", w = "[object Null]", k = "[object Object]", C = "[object Proxy]", P = "[object RegExp]", R = "[object Set]", L = "[object String]", _ = "[object Undefined]", F = "[object WeakMap]", K = "[object ArrayBuffer]", Y = "[object DataView]", te = "[object Float32Array]", ne = "[object Float64Array]", ae = "[object Int8Array]", ye = "[object Int16Array]", Ce = "[object Int32Array]", Re = "[object Uint8Array]", ee = "[object Uint8ClampedArray]", V = "[object Uint16Array]", oe = "[object Uint32Array]", de = /[\\^$.*+?()[\]{}|]/g, Se = /^\[object .+?Constructor\]$/, ve = /^(?:0|[1-9]\d*)$/, le = {};
    le[te] = le[ne] = le[ae] = le[ye] = le[Ce] = le[Re] = le[ee] = le[V] = le[oe] = true, le[a] = le[l] = le[K] = le[u] = le[Y] = le[h] = le[p] = le[v] = le[x] = le[T] = le[k] = le[P] = le[R] = le[L] = le[F] = false;
    var re = typeof Ao == "object" && Ao && Ao.Object === Object && Ao, se = typeof self == "object" && self && self.Object === Object && self, _e2 = re || se || Function("return this")(), yt = e && !e.nodeType && e, En = yt && true && t && !t.nodeType && t, so = En && En.exports === yt, Qr = so && re.process, ao = function() {
      try {
        var O = En && En.require && En.require("util").types;
        return O || Qr && Qr.binding && Qr.binding("util");
      } catch {
      }
    }(), Ll = ao && ao.isTypedArray;
    function gf(O, B, U) {
      switch (U.length) {
        case 0:
          return O.call(B);
        case 1:
          return O.call(B, U[0]);
        case 2:
          return O.call(B, U[0], U[1]);
        case 3:
          return O.call(B, U[0], U[1], U[2]);
      }
      return O.apply(B, U);
    }
    function vf(O, B) {
      for (var U = -1, pe = Array(O); ++U < O; )
        pe[U] = B(U);
      return pe;
    }
    function Et(O) {
      return function(B) {
        return O(B);
      };
    }
    function Xm(O, B) {
      return O == null ? void 0 : O[B];
    }
    function nr(O, B) {
      return function(U) {
        return O(B(U));
      };
    }
    var Qm = Array.prototype, Jm = Function.prototype, os = Object.prototype, Pr = _e2["__core-js_shared__"], vn = Jm.toString, Or = os.hasOwnProperty, _l2 = function() {
      var O = /[^.]+$/.exec(Pr && Pr.keys && Pr.keys.IE_PROTO || "");
      return O ? "Symbol(src)_1." + O : "";
    }(), Zs = os.toString, Zm = vn.call(Object), lo = RegExp("^" + vn.call(Or).replace(de, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"), ea = so ? _e2.Buffer : void 0, $t = _e2.Symbol, ss = _e2.Uint8Array, dt = ea ? ea.allocUnsafe : void 0, yf = nr(Object.getPrototypeOf, Object), bf = Object.create, eg = os.propertyIsEnumerable, xf = Qm.splice, ze = $t ? $t.toStringTag : void 0, Kt = function() {
      try {
        var O = De(Object, "defineProperty");
        return O({}, "", {}), O;
      } catch {
      }
    }(), ct = ea ? ea.isBuffer : void 0, zt = Math.max, Jr = Date.now, Dl = De(_e2, "Map"), bt = De(Object, "create"), Il = function() {
      function O() {
      }
      return function(B) {
        if (!_i2(B))
          return {};
        if (bf)
          return bf(B);
        O.prototype = B;
        var U = new O();
        return O.prototype = void 0, U;
      };
    }();
    function Ri(O) {
      var B = -1, U = O == null ? 0 : O.length;
      for (this.clear(); ++B < U; ) {
        var pe = O[B];
        this.set(pe[0], pe[1]);
      }
    }
    function tg() {
      this.__data__ = bt ? bt(null) : {}, this.size = 0;
    }
    function Sf(O) {
      var B = this.has(O) && delete this.__data__[O];
      return this.size -= B ? 1 : 0, B;
    }
    function wf(O) {
      var B = this.__data__;
      if (bt) {
        var U = B[O];
        return U === r ? void 0 : U;
      }
      return Or.call(B, O) ? B[O] : void 0;
    }
    function ng(O) {
      var B = this.__data__;
      return bt ? B[O] !== void 0 : Or.call(B, O);
    }
    function rg(O, B) {
      var U = this.__data__;
      return this.size += this.has(O) ? 0 : 1, U[O] = bt && B === void 0 ? r : B, this;
    }
    Ri.prototype.clear = tg, Ri.prototype.delete = Sf, Ri.prototype.get = wf, Ri.prototype.has = ng, Ri.prototype.set = rg;
    function rr(O) {
      var B = -1, U = O == null ? 0 : O.length;
      for (this.clear(); ++B < U; ) {
        var pe = O[B];
        this.set(pe[0], pe[1]);
      }
    }
    function ig() {
      this.__data__ = [], this.size = 0;
    }
    function co(O) {
      var B = this.__data__, U = Pn(B, O);
      if (U < 0)
        return false;
      var pe = B.length - 1;
      return U == pe ? B.pop() : xf.call(B, U, 1), --this.size, true;
    }
    function Bl(O) {
      var B = this.__data__, U = Pn(B, O);
      return U < 0 ? void 0 : B[U][1];
    }
    function og(O) {
      return Pn(this.__data__, O) > -1;
    }
    function ir(O, B) {
      var U = this.__data__, pe = Pn(U, O);
      return pe < 0 ? (++this.size, U.push([
        O,
        B
      ])) : U[pe][1] = B, this;
    }
    rr.prototype.clear = ig, rr.prototype.delete = co, rr.prototype.get = Bl, rr.prototype.has = og, rr.prototype.set = ir;
    function uo(O) {
      var B = -1, U = O == null ? 0 : O.length;
      for (this.clear(); ++B < U; ) {
        var pe = O[B];
        this.set(pe[0], pe[1]);
      }
    }
    function sg() {
      this.size = 0, this.__data__ = {
        hash: new Ri(),
        map: new (Dl || rr)(),
        string: new Ri()
      };
    }
    function or(O) {
      var B = on(this, O).delete(O);
      return this.size -= B ? 1 : 0, B;
    }
    function Nl(O) {
      return on(this, O).get(O);
    }
    function ag(O) {
      return on(this, O).has(O);
    }
    function kf(O, B) {
      var U = on(this, O), pe = U.size;
      return U.set(O, B), this.size += U.size == pe ? 0 : 1, this;
    }
    uo.prototype.clear = sg, uo.prototype.delete = or, uo.prototype.get = Nl, uo.prototype.has = ag, uo.prototype.set = kf;
    function Li(O) {
      var B = this.__data__ = new rr(O);
      this.size = B.size;
    }
    function lg() {
      this.__data__ = new rr(), this.size = 0;
    }
    function Cf(O) {
      var B = this.__data__, U = B.delete(O);
      return this.size = B.size, U;
    }
    function cg(O) {
      return this.__data__.get(O);
    }
    function Tf(O) {
      return this.__data__.has(O);
    }
    function ug(O, B) {
      var U = this.__data__;
      if (U instanceof rr) {
        var pe = U.__data__;
        if (!Dl || pe.length < n - 1)
          return pe.push([
            O,
            B
          ]), this.size = ++U.size, this;
        U = this.__data__ = new uo(pe);
      }
      return U.set(O, B), this.size = U.size, this;
    }
    Li.prototype.clear = lg, Li.prototype.delete = Cf, Li.prototype.get = cg, Li.prototype.has = Tf, Li.prototype.set = ug;
    function Mf(O, B) {
      var U = Ft(O), pe = !U && oa(O), f = !U && !pe && sa(O), d = !U && !pe && !f && zf(O), m = U || pe || f || d, g = m ? vf(O.length, String) : [], b = g.length;
      for (var S in O)
        (B || Or.call(O, S)) && !(m && (S == "length" || f && (S == "offset" || S == "parent") || d && (S == "buffer" || S == "byteLength" || S == "byteOffset") || If(S, b))) && g.push(S);
      return g;
    }
    function as(O, B, U) {
      (U !== void 0 && !ia(O[B], U) || U === void 0 && !(B in O)) && $l(O, B, U);
    }
    function fg(O, B, U) {
      var pe = O[B];
      (!(Or.call(O, B) && ia(pe, U)) || U === void 0 && !(B in O)) && $l(O, B, U);
    }
    function Pn(O, B) {
      for (var U = O.length; U--; )
        if (ia(O[U][0], B))
          return U;
      return -1;
    }
    function $l(O, B, U) {
      B == "__proto__" && Kt ? Kt(O, B, {
        configurable: true,
        enumerable: true,
        value: U,
        writable: true
      }) : O[B] = U;
    }
    var Af = Df();
    function ls(O) {
      return O == null ? O === void 0 ? _ : w : ze && ze in Object(O) ? bg(O) : Sg(O);
    }
    function Ef(O) {
      return fs(O) && ls(O) == a;
    }
    function Pf(O) {
      if (!_i2(O) || us(O))
        return false;
      var B = Hl(O) ? lo : Se;
      return B.test(Nf(O));
    }
    function hg(O) {
      return fs(O) && $f(O.length) && !!le[ls(O)];
    }
    function dg(O) {
      if (!_i2(O))
        return Bf(O);
      var B = na(O), U = [];
      for (var pe in O)
        pe == "constructor" && (B || !Or.call(O, pe)) || U.push(pe);
      return U;
    }
    function On(O, B, U, pe, f) {
      O !== B && Af(B, function(d, m) {
        if (f || (f = new Li()), _i2(d))
          pg(O, B, m, U, On, pe, f);
        else {
          var g = pe ? pe(zl(O, m), d, m + "", O, B, f) : void 0;
          g === void 0 && (g = d), as(O, m, g);
        }
      }, jl);
    }
    function pg(O, B, U, pe, f, d, m) {
      var g = zl(O, U), b = zl(B, U), S = m.get(b);
      if (S) {
        as(O, U, S);
        return;
      }
      var M = d ? d(g, b, U + "", O, B, m) : void 0, A = M === void 0;
      if (A) {
        var E = Ft(b), I = !E && sa(b), D = !E && !I && zf(b);
        M = b, E || I || D ? Ft(g) ? M = g : Zr(g) ? M = vg(g) : I ? (A = false, M = Rf(b, true)) : D ? (A = false, M = Lf(b, true)) : M = [] : wg(b) || oa(b) ? (M = g, oa(g) ? M = kg(g) : (!_i2(g) || Hl(g)) && (M = ta(b))) : A = false;
      }
      A && (m.set(b, M), f(M, b, pe, d, m), m.delete(b)), as(O, U, M);
    }
    function mg(O, B) {
      return Fl(fo(O, B, Wl), O + "");
    }
    var Of = Kt ? function(O, B) {
      return Kt(O, "toString", {
        configurable: true,
        enumerable: false,
        value: Vf(B),
        writable: true
      });
    } : Wl;
    function Rf(O, B) {
      if (B)
        return O.slice();
      var U = O.length, pe = dt ? dt(U) : new O.constructor(U);
      return O.copy(pe), pe;
    }
    function gg(O) {
      var B = new O.constructor(O.byteLength);
      return new ss(B).set(new ss(O)), B;
    }
    function Lf(O, B) {
      var U = B ? gg(O.buffer) : O.buffer;
      return new O.constructor(U, O.byteOffset, O.length);
    }
    function vg(O, B) {
      var U = -1, pe = O.length;
      for (B || (B = Array(pe)); ++U < pe; )
        B[U] = O[U];
      return B;
    }
    function _f2(O, B, U, pe) {
      var f = !U;
      U || (U = {});
      for (var d = -1, m = B.length; ++d < m; ) {
        var g = B[d], b = pe ? pe(U[g], O[g], g, U, O) : void 0;
        b === void 0 && (b = O[g]), f ? $l(U, g, b) : fg(U, g, b);
      }
      return U;
    }
    function yg(O) {
      return mg(function(B, U) {
        var pe = -1, f = U.length, d = f > 1 ? U[f - 1] : void 0, m = f > 2 ? U[2] : void 0;
        for (d = O.length > 3 && typeof d == "function" ? (f--, d) : void 0, m && cs(U[0], U[1], m) && (d = f < 3 ? void 0 : d, f = 1), B = Object(B); ++pe < f; ) {
          var g = U[pe];
          g && O(B, g, pe, d);
        }
        return B;
      });
    }
    function Df(O) {
      return function(B, U, pe) {
        for (var f = -1, d = Object(B), m = pe(B), g = m.length; g--; ) {
          var b = m[O ? g : ++f];
          if (U(d[b], b, d) === false)
            break;
        }
        return B;
      };
    }
    function on(O, B) {
      var U = O.__data__;
      return xg(B) ? U[typeof B == "string" ? "string" : "hash"] : U.map;
    }
    function De(O, B) {
      var U = Xm(O, B);
      return Pf(U) ? U : void 0;
    }
    function bg(O) {
      var B = Or.call(O, ze), U = O[ze];
      try {
        O[ze] = void 0;
        var pe = true;
      } catch {
      }
      var f = Zs.call(O);
      return pe && (B ? O[ze] = U : delete O[ze]), f;
    }
    function ta(O) {
      return typeof O.constructor == "function" && !na(O) ? Il(yf(O)) : {};
    }
    function If(O, B) {
      var U = typeof O;
      return B = B ?? s, !!B && (U == "number" || U != "symbol" && ve.test(O)) && O > -1 && O % 1 == 0 && O < B;
    }
    function cs(O, B, U) {
      if (!_i2(U))
        return false;
      var pe = typeof B;
      return (pe == "number" ? Vl(U) && If(B, U.length) : pe == "string" && B in U) ? ia(U[B], O) : false;
    }
    function xg(O) {
      var B = typeof O;
      return B == "string" || B == "number" || B == "symbol" || B == "boolean" ? O !== "__proto__" : O === null;
    }
    function us(O) {
      return !!_l2 && _l2 in O;
    }
    function na(O) {
      var B = O && O.constructor, U = typeof B == "function" && B.prototype || os;
      return O === U;
    }
    function Bf(O) {
      var B = [];
      if (O != null)
        for (var U in Object(O))
          B.push(U);
      return B;
    }
    function Sg(O) {
      return Zs.call(O);
    }
    function fo(O, B, U) {
      return B = zt(B === void 0 ? O.length - 1 : B, 0), function() {
        for (var pe = arguments, f = -1, d = zt(pe.length - B, 0), m = Array(d); ++f < d; )
          m[f] = pe[B + f];
        f = -1;
        for (var g = Array(B + 1); ++f < B; )
          g[f] = pe[f];
        return g[B] = U(m), gf(O, this, g);
      };
    }
    function zl(O, B) {
      if (!(B === "constructor" && typeof O[B] == "function") && B != "__proto__")
        return O[B];
    }
    var Fl = ra(Of);
    function ra(O) {
      var B = 0, U = 0;
      return function() {
        var pe = Jr(), f = o - (pe - U);
        if (U = pe, f > 0) {
          if (++B >= i)
            return arguments[0];
        } else
          B = 0;
        return O.apply(void 0, arguments);
      };
    }
    function Nf(O) {
      if (O != null) {
        try {
          return vn.call(O);
        } catch {
        }
        try {
          return O + "";
        } catch {
        }
      }
      return "";
    }
    function ia(O, B) {
      return O === B || O !== O && B !== B;
    }
    var oa = Ef(function() {
      return arguments;
    }()) ? Ef : function(O) {
      return fs(O) && Or.call(O, "callee") && !eg.call(O, "callee");
    }, Ft = Array.isArray;
    function Vl(O) {
      return O != null && $f(O.length) && !Hl(O);
    }
    function Zr(O) {
      return fs(O) && Vl(O);
    }
    var sa = ct || Hf;
    function Hl(O) {
      if (!_i2(O))
        return false;
      var B = ls(O);
      return B == v || B == y || B == c || B == C;
    }
    function $f(O) {
      return typeof O == "number" && O > -1 && O % 1 == 0 && O <= s;
    }
    function _i2(O) {
      var B = typeof O;
      return O != null && (B == "object" || B == "function");
    }
    function fs(O) {
      return O != null && typeof O == "object";
    }
    function wg(O) {
      if (!fs(O) || ls(O) != k)
        return false;
      var B = yf(O);
      if (B === null)
        return true;
      var U = Or.call(B, "constructor") && B.constructor;
      return typeof U == "function" && U instanceof U && vn.call(U) == Zm;
    }
    var zf = Ll ? Et(Ll) : hg;
    function kg(O) {
      return _f2(O, jl(O));
    }
    function jl(O) {
      return Vl(O) ? Mf(O, true) : dg(O);
    }
    var Ff = yg(function(O, B, U, pe) {
      On(O, B, U, pe);
    });
    function Vf(O) {
      return function() {
        return O;
      };
    }
    function Wl(O) {
      return O;
    }
    function Hf() {
      return false;
    }
    t.exports = Ff;
  })(ey, ey.exports);
  const yi = ey.exports;
  function rd(t, e = []) {
    const n = z.exports.useRef(t);
    return z.exports.useEffect(() => {
      n.current = t;
    }), z.exports.useCallback((...r) => {
      var _a3;
      return (_a3 = n.current) == null ? void 0 : _a3.call(n, ...r);
    }, e);
  }
  function GI(t) {
    const { value: e, defaultValue: n, onChange: r, shouldUpdate: i = (p, v) => p !== v } = t, o = rd(r), s = rd(i), [a, l] = z.exports.useState(n), c = e !== void 0, u = c ? e : a, h = rd((p) => {
      const y = typeof p == "function" ? p(u) : p;
      !s(u, y) || (c || l(y), o(y));
    }, [
      c,
      o,
      u,
      s
    ]);
    return [
      u,
      h
    ];
  }
  const ty = Boolean(globalThis == null ? void 0 : globalThis.document) ? z.exports.useLayoutEffect : z.exports.useEffect, kw = (t, e) => {
    const n = z.exports.useRef(false), r = z.exports.useRef(false);
    z.exports.useEffect(() => {
      if (n.current && r.current)
        return t();
      r.current = true;
    }, e), z.exports.useEffect(() => (n.current = true, () => {
      n.current = false;
    }), []);
  };
  function YI(t, e) {
    if (t != null) {
      if (typeof t == "function") {
        t(e);
        return;
      }
      try {
        t.current = e;
      } catch {
        throw new Error(`Cannot assign value '${e}' to ref '${t}'`);
      }
    }
  }
  function Eb(...t) {
    return (e) => {
      t.forEach((n) => {
        YI(n, e);
      });
    };
  }
  function XI(t, e) {
    const n = rd(t);
    z.exports.useEffect(() => {
      if (e == null)
        return;
      let r = null;
      return r = window.setTimeout(() => {
        n();
      }, e), () => {
        r && window.clearTimeout(r);
      };
    }, [
      e,
      n
    ]);
  }
  const Lt = {
    open: (t, e) => `${t}[data-open], ${t}[open], ${t}[data-state=open] ${e}`,
    closed: (t, e) => `${t}[data-closed], ${t}[data-state=closed] ${e}`,
    hover: (t, e) => `${t}:hover ${e}, ${t}[data-hover] ${e}`,
    focus: (t, e) => `${t}:focus ${e}, ${t}[data-focus] ${e}`,
    focusVisible: (t, e) => `${t}:focus-visible ${e}`,
    focusWithin: (t, e) => `${t}:focus-within ${e}`,
    active: (t, e) => `${t}:active ${e}, ${t}[data-active] ${e}`,
    disabled: (t, e) => `${t}:disabled ${e}, ${t}[data-disabled] ${e}`,
    invalid: (t, e) => `${t}:invalid ${e}, ${t}[data-invalid] ${e}`,
    checked: (t, e) => `${t}:checked ${e}, ${t}[data-checked] ${e}`,
    indeterminate: (t, e) => `${t}:indeterminate ${e}, ${t}[aria-checked=mixed] ${e}, ${t}[data-indeterminate] ${e}`,
    readOnly: (t, e) => `${t}:read-only ${e}, ${t}[readonly] ${e}, ${t}[data-read-only] ${e}`,
    expanded: (t, e) => `${t}:read-only ${e}, ${t}[aria-expanded=true] ${e}, ${t}[data-expanded] ${e}`,
    placeholderShown: (t, e) => `${t}:placeholder-shown ${e}`
  }, ti = (t) => SA((e) => t(e, "&"), "[role=group]", "[data-group]", ".group"), Di = (t) => SA((e) => t(e, "~ &"), "[data-peer]", ".peer"), SA = (t, ...e) => e.map(t).join(", "), sm = {
    _hover: "&:hover, &[data-hover]",
    _active: "&:active, &[data-active]",
    _focus: "&:focus, &[data-focus]",
    _highlighted: "&[data-highlighted]",
    _focusWithin: "&:focus-within, &[data-focus-within]",
    _focusVisible: "&:focus-visible, &[data-focus-visible]",
    _disabled: "&:disabled, &[disabled], &[aria-disabled=true], &[data-disabled]",
    _readOnly: "&[aria-readonly=true], &[readonly], &[data-readonly]",
    _before: "&::before",
    _after: "&::after",
    _empty: "&:empty, &[data-empty]",
    _expanded: "&[aria-expanded=true], &[data-expanded], &[data-state=expanded]",
    _checked: "&[aria-checked=true], &[data-checked], &[data-state=checked]",
    _grabbed: "&[aria-grabbed=true], &[data-grabbed]",
    _pressed: "&[aria-pressed=true], &[data-pressed]",
    _invalid: "&[aria-invalid=true], &[data-invalid]",
    _valid: "&[data-valid], &[data-state=valid]",
    _loading: "&[data-loading], &[aria-busy=true]",
    _selected: "&[aria-selected=true], &[data-selected]",
    _hidden: "&[hidden], &[data-hidden]",
    _autofill: "&:-webkit-autofill",
    _even: "&:nth-of-type(even)",
    _odd: "&:nth-of-type(odd)",
    _first: "&:first-of-type",
    _firstLetter: "&::first-letter",
    _last: "&:last-of-type",
    _notFirst: "&:not(:first-of-type)",
    _notLast: "&:not(:last-of-type)",
    _visited: "&:visited",
    _activeLink: "&[aria-current=page]",
    _activeStep: "&[aria-current=step]",
    _indeterminate: "&:indeterminate, &[aria-checked=mixed], &[data-indeterminate], &[data-state=indeterminate]",
    _groupOpen: ti(Lt.open),
    _groupClosed: ti(Lt.closed),
    _groupHover: ti(Lt.hover),
    _peerHover: Di(Lt.hover),
    _groupFocus: ti(Lt.focus),
    _peerFocus: Di(Lt.focus),
    _groupFocusVisible: ti(Lt.focusVisible),
    _peerFocusVisible: Di(Lt.focusVisible),
    _groupActive: ti(Lt.active),
    _peerActive: Di(Lt.active),
    _groupDisabled: ti(Lt.disabled),
    _peerDisabled: Di(Lt.disabled),
    _groupInvalid: ti(Lt.invalid),
    _peerInvalid: Di(Lt.invalid),
    _groupChecked: ti(Lt.checked),
    _peerChecked: Di(Lt.checked),
    _groupFocusWithin: ti(Lt.focusWithin),
    _peerFocusWithin: Di(Lt.focusWithin),
    _peerPlaceholderShown: Di(Lt.placeholderShown),
    _placeholder: "&::placeholder, &[data-placeholder]",
    _placeholderShown: "&:placeholder-shown, &[data-placeholder-shown]",
    _fullScreen: "&:fullscreen, &[data-fullscreen]",
    _selection: "&::selection",
    _rtl: "[dir=rtl] &, &[dir=rtl]",
    _ltr: "[dir=ltr] &, &[dir=ltr]",
    _mediaDark: "@media (prefers-color-scheme: dark)",
    _mediaReduceMotion: "@media (prefers-reduced-motion: reduce)",
    _dark: ".chakra-ui-dark &:not([data-theme]),[data-theme=dark] &:not([data-theme]),&[data-theme=dark]",
    _light: ".chakra-ui-light &:not([data-theme]),[data-theme=light] &:not([data-theme]),&[data-theme=light]",
    _horizontal: "&[data-orientation=horizontal]",
    _vertical: "&[data-orientation=vertical]",
    _open: "&[data-open], &[open], &[data-state=open]",
    _closed: "&[data-closed], &[data-state=closed]",
    _complete: "&[data-complete]",
    _incomplete: "&[data-incomplete]",
    _current: "&[data-current]"
  }, wA = Object.keys(sm), QI = (t) => /!(important)?$/.test(t), Cw = (t) => typeof t == "string" ? t.replace(/!(important)?$/, "").trim() : t, JI = (t, e) => (n) => {
    const r = String(e), i = QI(r), o = Cw(r), s = t ? `${t}.${o}` : o;
    let a = Hr(n.__cssMap) && s in n.__cssMap ? n.__cssMap[s].varRef : e;
    return a = Cw(a), i ? `${a} !important` : a;
  };
  function Pb(t) {
    const { scale: e, transform: n, compose: r } = t;
    return (o, s) => {
      const a = JI(e, o)(s);
      let l = (n == null ? void 0 : n(a, s)) ?? a;
      return r && (l = r(l, s)), l;
    };
  }
  const sh = (...t) => (e) => t.reduce((n, r) => r(n), e);
  function lr(t, e) {
    return (n) => {
      const r = {
        property: n,
        scale: t
      };
      return r.transform = Pb({
        scale: t,
        transform: e
      }), r;
    };
  }
  const ZI = ({ rtl: t, ltr: e }) => (n) => n.direction === "rtl" ? t : e;
  function eB(t) {
    const { property: e, scale: n, transform: r } = t;
    return {
      scale: n,
      property: ZI(e),
      transform: n ? Pb({
        scale: n,
        compose: r
      }) : r
    };
  }
  const kA = [
    "rotate(var(--chakra-rotate, 0))",
    "scaleX(var(--chakra-scale-x, 1))",
    "scaleY(var(--chakra-scale-y, 1))",
    "skewX(var(--chakra-skew-x, 0))",
    "skewY(var(--chakra-skew-y, 0))"
  ];
  function tB() {
    return [
      "translateX(var(--chakra-translate-x, 0))",
      "translateY(var(--chakra-translate-y, 0))",
      ...kA
    ].join(" ");
  }
  function nB() {
    return [
      "translate3d(var(--chakra-translate-x, 0), var(--chakra-translate-y, 0), 0)",
      ...kA
    ].join(" ");
  }
  const rB = {
    "--chakra-blur": "var(--chakra-empty,/*!*/ /*!*/)",
    "--chakra-brightness": "var(--chakra-empty,/*!*/ /*!*/)",
    "--chakra-contrast": "var(--chakra-empty,/*!*/ /*!*/)",
    "--chakra-grayscale": "var(--chakra-empty,/*!*/ /*!*/)",
    "--chakra-hue-rotate": "var(--chakra-empty,/*!*/ /*!*/)",
    "--chakra-invert": "var(--chakra-empty,/*!*/ /*!*/)",
    "--chakra-saturate": "var(--chakra-empty,/*!*/ /*!*/)",
    "--chakra-sepia": "var(--chakra-empty,/*!*/ /*!*/)",
    "--chakra-drop-shadow": "var(--chakra-empty,/*!*/ /*!*/)",
    filter: [
      "var(--chakra-blur)",
      "var(--chakra-brightness)",
      "var(--chakra-contrast)",
      "var(--chakra-grayscale)",
      "var(--chakra-hue-rotate)",
      "var(--chakra-invert)",
      "var(--chakra-saturate)",
      "var(--chakra-sepia)",
      "var(--chakra-drop-shadow)"
    ].join(" ")
  }, iB = {
    backdropFilter: [
      "var(--chakra-backdrop-blur)",
      "var(--chakra-backdrop-brightness)",
      "var(--chakra-backdrop-contrast)",
      "var(--chakra-backdrop-grayscale)",
      "var(--chakra-backdrop-hue-rotate)",
      "var(--chakra-backdrop-invert)",
      "var(--chakra-backdrop-opacity)",
      "var(--chakra-backdrop-saturate)",
      "var(--chakra-backdrop-sepia)"
    ].join(" "),
    "--chakra-backdrop-blur": "var(--chakra-empty,/*!*/ /*!*/)",
    "--chakra-backdrop-brightness": "var(--chakra-empty,/*!*/ /*!*/)",
    "--chakra-backdrop-contrast": "var(--chakra-empty,/*!*/ /*!*/)",
    "--chakra-backdrop-grayscale": "var(--chakra-empty,/*!*/ /*!*/)",
    "--chakra-backdrop-hue-rotate": "var(--chakra-empty,/*!*/ /*!*/)",
    "--chakra-backdrop-invert": "var(--chakra-empty,/*!*/ /*!*/)",
    "--chakra-backdrop-opacity": "var(--chakra-empty,/*!*/ /*!*/)",
    "--chakra-backdrop-saturate": "var(--chakra-empty,/*!*/ /*!*/)",
    "--chakra-backdrop-sepia": "var(--chakra-empty,/*!*/ /*!*/)"
  };
  function oB(t) {
    return {
      "--chakra-ring-offset-shadow": "var(--chakra-ring-inset) 0 0 0 var(--chakra-ring-offset-width) var(--chakra-ring-offset-color)",
      "--chakra-ring-shadow": "var(--chakra-ring-inset) 0 0 0 calc(var(--chakra-ring-width) + var(--chakra-ring-offset-width)) var(--chakra-ring-color)",
      "--chakra-ring-width": t,
      boxShadow: [
        "var(--chakra-ring-offset-shadow)",
        "var(--chakra-ring-shadow)",
        "var(--chakra-shadow, 0 0 #0000)"
      ].join(", ")
    };
  }
  const sB = {
    "row-reverse": {
      space: "--chakra-space-x-reverse",
      divide: "--chakra-divide-x-reverse"
    },
    "column-reverse": {
      space: "--chakra-space-y-reverse",
      divide: "--chakra-divide-y-reverse"
    }
  }, ny = {
    "to-t": "to top",
    "to-tr": "to top right",
    "to-r": "to right",
    "to-br": "to bottom right",
    "to-b": "to bottom",
    "to-bl": "to bottom left",
    "to-l": "to left",
    "to-tl": "to top left"
  }, aB = new Set(Object.values(ny)), ry = /* @__PURE__ */ new Set([
    "none",
    "-moz-initial",
    "inherit",
    "initial",
    "revert",
    "unset"
  ]), lB = (t) => t.trim();
  function cB(t, e) {
    if (t == null || ry.has(t))
      return t;
    if (!(iy(t) || ry.has(t)))
      return `url('${t}')`;
    const i = /(^[a-z-A-Z]+)\((.*)\)/g.exec(t), o = i == null ? void 0 : i[1], s = i == null ? void 0 : i[2];
    if (!o || !s)
      return t;
    const a = o.includes("-gradient") ? o : `${o}-gradient`, [l, ...c] = s.split(",").map(lB).filter(Boolean);
    if ((c == null ? void 0 : c.length) === 0)
      return t;
    const u = l in ny ? ny[l] : l;
    c.unshift(u);
    const h = c.map((p) => {
      if (aB.has(p))
        return p;
      const v = p.indexOf(" "), [y, x] = v !== -1 ? [
        p.substr(0, v),
        p.substr(v + 1)
      ] : [
        p
      ], T = iy(x) ? x : x && x.split(" "), w = `colors.${y}`, k = w in e.__cssMap ? e.__cssMap[w].varRef : y;
      return T ? [
        k,
        ...Array.isArray(T) ? T : [
          T
        ]
      ].join(" ") : k;
    });
    return `${a}(${h.join(", ")})`;
  }
  const iy = (t) => typeof t == "string" && t.includes("(") && t.includes(")"), uB = (t, e) => cB(t, e ?? {});
  function fB(t) {
    return /^var\(--.+\)$/.test(t);
  }
  const hB = (t) => {
    const e = parseFloat(t.toString()), n = t.toString().replace(String(e), "");
    return {
      unitless: !n,
      value: e,
      unit: n
    };
  }, ni = (t) => (e) => `${t}(${e})`, Be = {
    filter(t) {
      return t !== "auto" ? t : rB;
    },
    backdropFilter(t) {
      return t !== "auto" ? t : iB;
    },
    ring(t) {
      return oB(Be.px(t));
    },
    bgClip(t) {
      return t === "text" ? {
        color: "transparent",
        backgroundClip: "text"
      } : {
        backgroundClip: t
      };
    },
    transform(t) {
      return t === "auto" ? tB() : t === "auto-gpu" ? nB() : t;
    },
    vh(t) {
      return t === "$100vh" ? "var(--chakra-vh)" : t;
    },
    px(t) {
      if (t == null)
        return t;
      const { unitless: e } = hB(t);
      return e || typeof t == "number" ? `${t}px` : t;
    },
    fraction(t) {
      return typeof t != "number" || t > 1 ? t : `${t * 100}%`;
    },
    float(t, e) {
      const n = {
        left: "right",
        right: "left"
      };
      return e.direction === "rtl" ? n[t] : t;
    },
    degree(t) {
      if (fB(t) || t == null)
        return t;
      const e = typeof t == "string" && !t.endsWith("deg");
      return typeof t == "number" || e ? `${t}deg` : t;
    },
    gradient: uB,
    blur: ni("blur"),
    opacity: ni("opacity"),
    brightness: ni("brightness"),
    contrast: ni("contrast"),
    dropShadow: ni("drop-shadow"),
    grayscale: ni("grayscale"),
    hueRotate: (t) => ni("hue-rotate")(Be.degree(t)),
    invert: ni("invert"),
    saturate: ni("saturate"),
    sepia: ni("sepia"),
    bgImage(t) {
      return t == null || iy(t) || ry.has(t) ? t : `url(${t})`;
    },
    outline(t) {
      const e = String(t) === "0" || String(t) === "none";
      return t !== null && e ? {
        outline: "2px solid transparent",
        outlineOffset: "2px"
      } : {
        outline: t
      };
    },
    flexDirection(t) {
      const { space: e, divide: n } = sB[t] ?? {}, r = {
        flexDirection: t
      };
      return e && (r[e] = 1), n && (r[n] = 1), r;
    }
  }, N = {
    borderWidths: lr("borderWidths"),
    borderStyles: lr("borderStyles"),
    colors: lr("colors"),
    borders: lr("borders"),
    gradients: lr("gradients", Be.gradient),
    radii: lr("radii", Be.px),
    space: lr("space", sh(Be.vh, Be.px)),
    spaceT: lr("space", sh(Be.vh, Be.px)),
    degreeT(t) {
      return {
        property: t,
        transform: Be.degree
      };
    },
    prop(t, e, n) {
      return {
        property: t,
        scale: e,
        ...e && {
          transform: Pb({
            scale: e,
            transform: n
          })
        }
      };
    },
    propT(t, e) {
      return {
        property: t,
        transform: e
      };
    },
    sizes: lr("sizes", sh(Be.vh, Be.px)),
    sizesT: lr("sizes", sh(Be.vh, Be.fraction)),
    shadows: lr("shadows"),
    logical: eB,
    blur: lr("blur", Be.blur)
  }, id = {
    background: N.colors("background"),
    backgroundColor: N.colors("backgroundColor"),
    backgroundImage: N.gradients("backgroundImage"),
    backgroundSize: true,
    backgroundPosition: true,
    backgroundRepeat: true,
    backgroundAttachment: true,
    backgroundClip: {
      transform: Be.bgClip
    },
    bgSize: N.prop("backgroundSize"),
    bgPosition: N.prop("backgroundPosition"),
    bg: N.colors("background"),
    bgColor: N.colors("backgroundColor"),
    bgPos: N.prop("backgroundPosition"),
    bgRepeat: N.prop("backgroundRepeat"),
    bgAttachment: N.prop("backgroundAttachment"),
    bgGradient: N.gradients("backgroundImage"),
    bgClip: {
      transform: Be.bgClip
    }
  };
  Object.assign(id, {
    bgImage: id.backgroundImage,
    bgImg: id.backgroundImage
  });
  const We = {
    border: N.borders("border"),
    borderWidth: N.borderWidths("borderWidth"),
    borderStyle: N.borderStyles("borderStyle"),
    borderColor: N.colors("borderColor"),
    borderRadius: N.radii("borderRadius"),
    borderTop: N.borders("borderTop"),
    borderBlockStart: N.borders("borderBlockStart"),
    borderTopLeftRadius: N.radii("borderTopLeftRadius"),
    borderStartStartRadius: N.logical({
      scale: "radii",
      property: {
        ltr: "borderTopLeftRadius",
        rtl: "borderTopRightRadius"
      }
    }),
    borderEndStartRadius: N.logical({
      scale: "radii",
      property: {
        ltr: "borderBottomLeftRadius",
        rtl: "borderBottomRightRadius"
      }
    }),
    borderTopRightRadius: N.radii("borderTopRightRadius"),
    borderStartEndRadius: N.logical({
      scale: "radii",
      property: {
        ltr: "borderTopRightRadius",
        rtl: "borderTopLeftRadius"
      }
    }),
    borderEndEndRadius: N.logical({
      scale: "radii",
      property: {
        ltr: "borderBottomRightRadius",
        rtl: "borderBottomLeftRadius"
      }
    }),
    borderRight: N.borders("borderRight"),
    borderInlineEnd: N.borders("borderInlineEnd"),
    borderBottom: N.borders("borderBottom"),
    borderBlockEnd: N.borders("borderBlockEnd"),
    borderBottomLeftRadius: N.radii("borderBottomLeftRadius"),
    borderBottomRightRadius: N.radii("borderBottomRightRadius"),
    borderLeft: N.borders("borderLeft"),
    borderInlineStart: {
      property: "borderInlineStart",
      scale: "borders"
    },
    borderInlineStartRadius: N.logical({
      scale: "radii",
      property: {
        ltr: [
          "borderTopLeftRadius",
          "borderBottomLeftRadius"
        ],
        rtl: [
          "borderTopRightRadius",
          "borderBottomRightRadius"
        ]
      }
    }),
    borderInlineEndRadius: N.logical({
      scale: "radii",
      property: {
        ltr: [
          "borderTopRightRadius",
          "borderBottomRightRadius"
        ],
        rtl: [
          "borderTopLeftRadius",
          "borderBottomLeftRadius"
        ]
      }
    }),
    borderX: N.borders([
      "borderLeft",
      "borderRight"
    ]),
    borderInline: N.borders("borderInline"),
    borderY: N.borders([
      "borderTop",
      "borderBottom"
    ]),
    borderBlock: N.borders("borderBlock"),
    borderTopWidth: N.borderWidths("borderTopWidth"),
    borderBlockStartWidth: N.borderWidths("borderBlockStartWidth"),
    borderTopColor: N.colors("borderTopColor"),
    borderBlockStartColor: N.colors("borderBlockStartColor"),
    borderTopStyle: N.borderStyles("borderTopStyle"),
    borderBlockStartStyle: N.borderStyles("borderBlockStartStyle"),
    borderBottomWidth: N.borderWidths("borderBottomWidth"),
    borderBlockEndWidth: N.borderWidths("borderBlockEndWidth"),
    borderBottomColor: N.colors("borderBottomColor"),
    borderBlockEndColor: N.colors("borderBlockEndColor"),
    borderBottomStyle: N.borderStyles("borderBottomStyle"),
    borderBlockEndStyle: N.borderStyles("borderBlockEndStyle"),
    borderLeftWidth: N.borderWidths("borderLeftWidth"),
    borderInlineStartWidth: N.borderWidths("borderInlineStartWidth"),
    borderLeftColor: N.colors("borderLeftColor"),
    borderInlineStartColor: N.colors("borderInlineStartColor"),
    borderLeftStyle: N.borderStyles("borderLeftStyle"),
    borderInlineStartStyle: N.borderStyles("borderInlineStartStyle"),
    borderRightWidth: N.borderWidths("borderRightWidth"),
    borderInlineEndWidth: N.borderWidths("borderInlineEndWidth"),
    borderRightColor: N.colors("borderRightColor"),
    borderInlineEndColor: N.colors("borderInlineEndColor"),
    borderRightStyle: N.borderStyles("borderRightStyle"),
    borderInlineEndStyle: N.borderStyles("borderInlineEndStyle"),
    borderTopRadius: N.radii([
      "borderTopLeftRadius",
      "borderTopRightRadius"
    ]),
    borderBottomRadius: N.radii([
      "borderBottomLeftRadius",
      "borderBottomRightRadius"
    ]),
    borderLeftRadius: N.radii([
      "borderTopLeftRadius",
      "borderBottomLeftRadius"
    ]),
    borderRightRadius: N.radii([
      "borderTopRightRadius",
      "borderBottomRightRadius"
    ])
  };
  Object.assign(We, {
    rounded: We.borderRadius,
    roundedTop: We.borderTopRadius,
    roundedTopLeft: We.borderTopLeftRadius,
    roundedTopRight: We.borderTopRightRadius,
    roundedTopStart: We.borderStartStartRadius,
    roundedTopEnd: We.borderStartEndRadius,
    roundedBottom: We.borderBottomRadius,
    roundedBottomLeft: We.borderBottomLeftRadius,
    roundedBottomRight: We.borderBottomRightRadius,
    roundedBottomStart: We.borderEndStartRadius,
    roundedBottomEnd: We.borderEndEndRadius,
    roundedLeft: We.borderLeftRadius,
    roundedRight: We.borderRightRadius,
    roundedStart: We.borderInlineStartRadius,
    roundedEnd: We.borderInlineEndRadius,
    borderStart: We.borderInlineStart,
    borderEnd: We.borderInlineEnd,
    borderTopStartRadius: We.borderStartStartRadius,
    borderTopEndRadius: We.borderStartEndRadius,
    borderBottomStartRadius: We.borderEndStartRadius,
    borderBottomEndRadius: We.borderEndEndRadius,
    borderStartRadius: We.borderInlineStartRadius,
    borderEndRadius: We.borderInlineEndRadius,
    borderStartWidth: We.borderInlineStartWidth,
    borderEndWidth: We.borderInlineEndWidth,
    borderStartColor: We.borderInlineStartColor,
    borderEndColor: We.borderInlineEndColor,
    borderStartStyle: We.borderInlineStartStyle,
    borderEndStyle: We.borderInlineEndStyle
  });
  const dB = {
    color: N.colors("color"),
    textColor: N.colors("color"),
    fill: N.colors("fill"),
    stroke: N.colors("stroke"),
    accentColor: N.colors("accentColor"),
    textFillColor: N.colors("textFillColor")
  }, np = {
    alignItems: true,
    alignContent: true,
    justifyItems: true,
    justifyContent: true,
    flexWrap: true,
    flexDirection: {
      transform: Be.flexDirection
    },
    flex: true,
    flexFlow: true,
    flexGrow: true,
    flexShrink: true,
    flexBasis: N.sizes("flexBasis"),
    justifySelf: true,
    alignSelf: true,
    order: true,
    placeItems: true,
    placeContent: true,
    placeSelf: true,
    gap: N.space("gap"),
    rowGap: N.space("rowGap"),
    columnGap: N.space("columnGap")
  };
  Object.assign(np, {
    flexDir: np.flexDirection
  });
  const cr = {
    width: N.sizesT("width"),
    inlineSize: N.sizesT("inlineSize"),
    height: N.sizes("height"),
    blockSize: N.sizes("blockSize"),
    boxSize: N.sizes([
      "width",
      "height"
    ]),
    minWidth: N.sizes("minWidth"),
    minInlineSize: N.sizes("minInlineSize"),
    minHeight: N.sizes("minHeight"),
    minBlockSize: N.sizes("minBlockSize"),
    maxWidth: N.sizes("maxWidth"),
    maxInlineSize: N.sizes("maxInlineSize"),
    maxHeight: N.sizes("maxHeight"),
    maxBlockSize: N.sizes("maxBlockSize"),
    overflow: true,
    overflowX: true,
    overflowY: true,
    overscrollBehavior: true,
    overscrollBehaviorX: true,
    overscrollBehaviorY: true,
    display: true,
    aspectRatio: true,
    hideFrom: {
      scale: "breakpoints",
      transform: (t, e) => {
        var _a3, _b3;
        return {
          [`@media screen and (min-width: ${((_b3 = (_a3 = e.__breakpoints) == null ? void 0 : _a3.get(t)) == null ? void 0 : _b3.minW) ?? t})`]: {
            display: "none"
          }
        };
      }
    },
    hideBelow: {
      scale: "breakpoints",
      transform: (t, e) => {
        var _a3, _b3;
        return {
          [`@media screen and (max-width: ${((_b3 = (_a3 = e.__breakpoints) == null ? void 0 : _a3.get(t)) == null ? void 0 : _b3._minW) ?? t})`]: {
            display: "none"
          }
        };
      }
    },
    verticalAlign: true,
    boxSizing: true,
    boxDecorationBreak: true,
    float: N.propT("float", Be.float),
    objectFit: true,
    objectPosition: true,
    visibility: true,
    isolation: true
  };
  Object.assign(cr, {
    w: cr.width,
    h: cr.height,
    minW: cr.minWidth,
    maxW: cr.maxWidth,
    minH: cr.minHeight,
    maxH: cr.maxHeight,
    overscroll: cr.overscrollBehavior,
    overscrollX: cr.overscrollBehaviorX,
    overscrollY: cr.overscrollBehaviorY
  });
  const pB = {
    filter: {
      transform: Be.filter
    },
    blur: N.blur("--chakra-blur"),
    brightness: N.propT("--chakra-brightness", Be.brightness),
    contrast: N.propT("--chakra-contrast", Be.contrast),
    hueRotate: N.propT("--chakra-hue-rotate", Be.hueRotate),
    invert: N.propT("--chakra-invert", Be.invert),
    saturate: N.propT("--chakra-saturate", Be.saturate),
    dropShadow: N.propT("--chakra-drop-shadow", Be.dropShadow),
    backdropFilter: {
      transform: Be.backdropFilter
    },
    backdropBlur: N.blur("--chakra-backdrop-blur"),
    backdropBrightness: N.propT("--chakra-backdrop-brightness", Be.brightness),
    backdropContrast: N.propT("--chakra-backdrop-contrast", Be.contrast),
    backdropHueRotate: N.propT("--chakra-backdrop-hue-rotate", Be.hueRotate),
    backdropInvert: N.propT("--chakra-backdrop-invert", Be.invert),
    backdropSaturate: N.propT("--chakra-backdrop-saturate", Be.saturate)
  }, mB = {
    ring: {
      transform: Be.ring
    },
    ringColor: N.colors("--chakra-ring-color"),
    ringOffset: N.prop("--chakra-ring-offset-width"),
    ringOffsetColor: N.colors("--chakra-ring-offset-color"),
    ringInset: N.prop("--chakra-ring-inset")
  }, gB = {
    appearance: true,
    cursor: true,
    resize: true,
    userSelect: true,
    pointerEvents: true,
    outline: {
      transform: Be.outline
    },
    outlineOffset: true,
    outlineColor: N.colors("outlineColor")
  }, CA = {
    gridGap: N.space("gridGap"),
    gridColumnGap: N.space("gridColumnGap"),
    gridRowGap: N.space("gridRowGap"),
    gridColumn: true,
    gridRow: true,
    gridAutoFlow: true,
    gridAutoColumns: true,
    gridColumnStart: true,
    gridColumnEnd: true,
    gridRowStart: true,
    gridRowEnd: true,
    gridAutoRows: true,
    gridTemplate: true,
    gridTemplateColumns: true,
    gridTemplateRows: true,
    gridTemplateAreas: true,
    gridArea: true
  };
  function vB(t, e, n, r) {
    const i = typeof e == "string" ? e.split(".") : [
      e
    ];
    for (r = 0; r < i.length && t; r += 1)
      t = t[i[r]];
    return t === void 0 ? n : t;
  }
  const yB = (t) => {
    const e = /* @__PURE__ */ new WeakMap();
    return (r, i, o, s) => {
      if (typeof r > "u")
        return t(r, i, o);
      e.has(r) || e.set(r, /* @__PURE__ */ new Map());
      const a = e.get(r);
      if (a.has(i))
        return a.get(i);
      const l = t(r, i, o, s);
      return a.set(i, l), l;
    };
  }, bB = yB(vB), xB = {
    border: "0px",
    clip: "rect(0, 0, 0, 0)",
    width: "1px",
    height: "1px",
    margin: "-1px",
    padding: "0px",
    overflow: "hidden",
    whiteSpace: "nowrap",
    position: "absolute"
  }, SB = {
    position: "static",
    width: "auto",
    height: "auto",
    clip: "auto",
    padding: "0",
    margin: "0",
    overflow: "visible",
    whiteSpace: "normal"
  }, Qg = (t, e, n) => {
    const r = {}, i = bB(t, e, {});
    for (const o in i)
      o in n && n[o] != null || (r[o] = i[o]);
    return r;
  }, wB = {
    srOnly: {
      transform(t) {
        return t === true ? xB : t === "focusable" ? SB : {};
      }
    },
    layerStyle: {
      processResult: true,
      transform: (t, e, n) => Qg(e, `layerStyles.${t}`, n)
    },
    textStyle: {
      processResult: true,
      transform: (t, e, n) => Qg(e, `textStyles.${t}`, n)
    },
    apply: {
      processResult: true,
      transform: (t, e, n) => Qg(e, t, n)
    }
  }, Ic = {
    position: true,
    pos: N.prop("position"),
    zIndex: N.prop("zIndex", "zIndices"),
    inset: N.spaceT("inset"),
    insetX: N.spaceT([
      "left",
      "right"
    ]),
    insetInline: N.spaceT("insetInline"),
    insetY: N.spaceT([
      "top",
      "bottom"
    ]),
    insetBlock: N.spaceT("insetBlock"),
    top: N.spaceT("top"),
    insetBlockStart: N.spaceT("insetBlockStart"),
    bottom: N.spaceT("bottom"),
    insetBlockEnd: N.spaceT("insetBlockEnd"),
    left: N.spaceT("left"),
    insetInlineStart: N.logical({
      scale: "space",
      property: {
        ltr: "left",
        rtl: "right"
      }
    }),
    right: N.spaceT("right"),
    insetInlineEnd: N.logical({
      scale: "space",
      property: {
        ltr: "right",
        rtl: "left"
      }
    })
  };
  Object.assign(Ic, {
    insetStart: Ic.insetInlineStart,
    insetEnd: Ic.insetInlineEnd
  });
  const oy = {
    boxShadow: N.shadows("boxShadow"),
    mixBlendMode: true,
    blendMode: N.prop("mixBlendMode"),
    backgroundBlendMode: true,
    bgBlendMode: N.prop("backgroundBlendMode"),
    opacity: true
  };
  Object.assign(oy, {
    shadow: oy.boxShadow
  });
  const st = {
    margin: N.spaceT("margin"),
    marginTop: N.spaceT("marginTop"),
    marginBlockStart: N.spaceT("marginBlockStart"),
    marginRight: N.spaceT("marginRight"),
    marginInlineEnd: N.spaceT("marginInlineEnd"),
    marginBottom: N.spaceT("marginBottom"),
    marginBlockEnd: N.spaceT("marginBlockEnd"),
    marginLeft: N.spaceT("marginLeft"),
    marginInlineStart: N.spaceT("marginInlineStart"),
    marginX: N.spaceT([
      "marginInlineStart",
      "marginInlineEnd"
    ]),
    marginInline: N.spaceT("marginInline"),
    marginY: N.spaceT([
      "marginTop",
      "marginBottom"
    ]),
    marginBlock: N.spaceT("marginBlock"),
    padding: N.space("padding"),
    paddingTop: N.space("paddingTop"),
    paddingBlockStart: N.space("paddingBlockStart"),
    paddingRight: N.space("paddingRight"),
    paddingBottom: N.space("paddingBottom"),
    paddingBlockEnd: N.space("paddingBlockEnd"),
    paddingLeft: N.space("paddingLeft"),
    paddingInlineStart: N.space("paddingInlineStart"),
    paddingInlineEnd: N.space("paddingInlineEnd"),
    paddingX: N.space([
      "paddingInlineStart",
      "paddingInlineEnd"
    ]),
    paddingInline: N.space("paddingInline"),
    paddingY: N.space([
      "paddingTop",
      "paddingBottom"
    ]),
    paddingBlock: N.space("paddingBlock")
  };
  Object.assign(st, {
    m: st.margin,
    mt: st.marginTop,
    mr: st.marginRight,
    me: st.marginInlineEnd,
    marginEnd: st.marginInlineEnd,
    mb: st.marginBottom,
    ml: st.marginLeft,
    ms: st.marginInlineStart,
    marginStart: st.marginInlineStart,
    mx: st.marginX,
    my: st.marginY,
    p: st.padding,
    pt: st.paddingTop,
    py: st.paddingY,
    px: st.paddingX,
    pb: st.paddingBottom,
    pl: st.paddingLeft,
    ps: st.paddingInlineStart,
    paddingStart: st.paddingInlineStart,
    pr: st.paddingRight,
    pe: st.paddingInlineEnd,
    paddingEnd: st.paddingInlineEnd
  });
  const kB = {
    scrollBehavior: true,
    scrollSnapAlign: true,
    scrollSnapStop: true,
    scrollSnapType: true,
    scrollMargin: N.spaceT("scrollMargin"),
    scrollMarginTop: N.spaceT("scrollMarginTop"),
    scrollMarginBottom: N.spaceT("scrollMarginBottom"),
    scrollMarginLeft: N.spaceT("scrollMarginLeft"),
    scrollMarginRight: N.spaceT("scrollMarginRight"),
    scrollMarginX: N.spaceT([
      "scrollMarginLeft",
      "scrollMarginRight"
    ]),
    scrollMarginY: N.spaceT([
      "scrollMarginTop",
      "scrollMarginBottom"
    ]),
    scrollPadding: N.spaceT("scrollPadding"),
    scrollPaddingTop: N.spaceT("scrollPaddingTop"),
    scrollPaddingBottom: N.spaceT("scrollPaddingBottom"),
    scrollPaddingLeft: N.spaceT("scrollPaddingLeft"),
    scrollPaddingRight: N.spaceT("scrollPaddingRight"),
    scrollPaddingX: N.spaceT([
      "scrollPaddingLeft",
      "scrollPaddingRight"
    ]),
    scrollPaddingY: N.spaceT([
      "scrollPaddingTop",
      "scrollPaddingBottom"
    ])
  }, CB = {
    fontFamily: N.prop("fontFamily", "fonts"),
    fontSize: N.prop("fontSize", "fontSizes", Be.px),
    fontWeight: N.prop("fontWeight", "fontWeights"),
    lineHeight: N.prop("lineHeight", "lineHeights"),
    letterSpacing: N.prop("letterSpacing", "letterSpacings"),
    textAlign: true,
    fontStyle: true,
    textIndent: true,
    wordBreak: true,
    overflowWrap: true,
    textOverflow: true,
    textTransform: true,
    whiteSpace: true,
    isTruncated: {
      transform(t) {
        if (t === true)
          return {
            overflow: "hidden",
            textOverflow: "ellipsis",
            whiteSpace: "nowrap"
          };
      }
    },
    noOfLines: {
      static: {
        overflow: "hidden",
        textOverflow: "ellipsis",
        display: "-webkit-box",
        WebkitBoxOrient: "vertical",
        WebkitLineClamp: "var(--chakra-line-clamp)"
      },
      property: "--chakra-line-clamp"
    }
  }, TB = {
    textDecorationColor: N.colors("textDecorationColor"),
    textDecoration: true,
    textDecor: {
      property: "textDecoration"
    },
    textDecorationLine: true,
    textDecorationStyle: true,
    textDecorationThickness: true,
    textUnderlineOffset: true,
    textShadow: N.shadows("textShadow")
  }, MB = {
    clipPath: true,
    transform: N.propT("transform", Be.transform),
    transformOrigin: true,
    translateX: N.spaceT("--chakra-translate-x"),
    translateY: N.spaceT("--chakra-translate-y"),
    skewX: N.degreeT("--chakra-skew-x"),
    skewY: N.degreeT("--chakra-skew-y"),
    scaleX: N.prop("--chakra-scale-x"),
    scaleY: N.prop("--chakra-scale-y"),
    scale: N.prop([
      "--chakra-scale-x",
      "--chakra-scale-y"
    ]),
    rotate: N.degreeT("--chakra-rotate")
  }, AB = {
    listStyleType: true,
    listStylePosition: true,
    listStylePos: N.prop("listStylePosition"),
    listStyleImage: true,
    listStyleImg: N.prop("listStyleImage")
  }, EB = {
    transition: true,
    transitionDelay: true,
    animation: true,
    willChange: true,
    transitionDuration: N.prop("transitionDuration", "transition.duration"),
    transitionProperty: N.prop("transitionProperty", "transition.property"),
    transitionTimingFunction: N.prop("transitionTimingFunction", "transition.easing")
  }, Ob = yi({}, id, We, dB, np, cr, pB, mB, gB, CA, wB, Ic, oy, st, kB, CB, TB, MB, AB, EB);
  Object.assign({}, st, cr, np, CA, Ic);
  const PB = [
    ...Object.keys(Ob),
    ...wA
  ], OB = {
    ...Ob,
    ...sm
  }, RB = (t) => t in OB, LB = (t) => (e) => {
    if (!e.__breakpoints)
      return t;
    const { isResponsive: n, toArrayValue: r, media: i } = e.__breakpoints, o = {};
    for (const s in t) {
      let a = vi(t[s], e);
      if (a == null)
        continue;
      if (a = Hr(a) && n(a) ? r(a) : a, !Array.isArray(a)) {
        o[s] = a;
        continue;
      }
      const l = a.slice(0, i.length).length;
      for (let c = 0; c < l; c += 1) {
        const u = i == null ? void 0 : i[c];
        if (!u) {
          o[s] = a[c];
          continue;
        }
        o[u] = o[u] || {}, a[c] != null && (o[u][s] = a[c]);
      }
    }
    return o;
  };
  function _B(t) {
    const e = [];
    let n = "", r = false;
    for (let i = 0; i < t.length; i++) {
      const o = t[i];
      o === "(" ? (r = true, n += o) : o === ")" ? (r = false, n += o) : o === "," && !r ? (e.push(n), n = "") : n += o;
    }
    return n = n.trim(), n && e.push(n), e;
  }
  function DB(t) {
    return /^var\(--.+\)$/.test(t);
  }
  const IB = (t, e) => t.startsWith("--") && typeof e == "string" && !DB(e), BB = (t, e) => {
    if (e == null)
      return e;
    const n = (s) => {
      var _a3, _b3;
      return (_b3 = (_a3 = t.__cssMap) == null ? void 0 : _a3[s]) == null ? void 0 : _b3.varRef;
    }, r = (s) => n(s) ?? s, [i, o] = _B(e);
    return e = n(i) ?? r(o) ?? r(e), e;
  };
  function NB(t) {
    const { configs: e = {}, pseudos: n = {}, theme: r } = t, i = (o, s = false) => {
      var _a3;
      const a = vi(o, r), l = LB(a)(r);
      let c = {};
      for (let u in l) {
        const h = l[u];
        let p = vi(h, r);
        u in n && (u = n[u]), IB(u, p) && (p = BB(r, p));
        let v = e[u];
        if (v === true && (v = {
          property: u
        }), Hr(p)) {
          c[u] = c[u] ?? {}, c[u] = yi({}, c[u], i(p, true));
          continue;
        }
        let y = ((_a3 = v == null ? void 0 : v.transform) == null ? void 0 : _a3.call(v, p, r, a)) ?? p;
        y = (v == null ? void 0 : v.processResult) ? i(y, true) : y;
        const x = vi(v == null ? void 0 : v.property, r);
        if (!s && (v == null ? void 0 : v.static)) {
          const T = vi(v.static, r);
          c = yi({}, c, T);
        }
        if (x && Array.isArray(x)) {
          for (const T of x)
            c[T] = y;
          continue;
        }
        if (x) {
          x === "&" && Hr(y) ? c = yi({}, c, y) : c[x] = y;
          continue;
        }
        if (Hr(y)) {
          c = yi({}, c, y);
          continue;
        }
        c[u] = y;
      }
      return c;
    };
    return i;
  }
  const TA = (t) => (e) => NB({
    theme: e,
    pseudos: sm,
    configs: Ob
  })(t);
  function it(t) {
    return {
      definePartsStyle(e) {
        return e;
      },
      defineMultiStyleConfig(e) {
        return {
          parts: t,
          ...e
        };
      }
    };
  }
  function $B(t, e) {
    if (Array.isArray(t))
      return t;
    if (Hr(t))
      return e(t);
    if (t != null)
      return [
        t
      ];
  }
  function zB(t, e) {
    for (let n = e + 1; n < t.length; n++)
      if (t[n] != null)
        return n;
    return -1;
  }
  function FB(t) {
    const e = t.__breakpoints;
    return function(r, i, o, s) {
      var _a3, _b3;
      if (!e)
        return;
      const a = {}, l = $B(o, e.toArrayValue);
      if (!l)
        return a;
      const c = l.length, u = c === 1, h = !!r.parts;
      for (let p = 0; p < c; p++) {
        const v = e.details[p], y = e.details[zB(l, p)], x = mc(v.minW, y == null ? void 0 : y._minW), T = vi((_a3 = r[i]) == null ? void 0 : _a3[l[p]], s);
        if (!!T) {
          if (h) {
            (_b3 = r.parts) == null ? void 0 : _b3.forEach((w) => {
              yi(a, {
                [w]: u ? T[w] : {
                  [x]: T[w]
                }
              });
            });
            continue;
          }
          if (!h) {
            u ? yi(a, T) : a[x] = T;
            continue;
          }
          a[x] = T;
        }
      }
      return a;
    };
  }
  function VB(t) {
    return (e) => {
      const { variant: n, size: r, theme: i } = e, o = FB(i);
      return yi({}, vi(t.baseStyle ?? {}, e), o(t, "sizes", r, e), o(t, "variants", n, e));
    };
  }
  function am(t) {
    return WI(t, [
      "styleConfig",
      "size",
      "variant",
      "colorScheme"
    ]);
  }
  function MA(t) {
    return Hr(t) && t.reference ? t.reference : String(t);
  }
  const lm = (t, ...e) => e.map(MA).join(` ${t} `).replace(/calc/g, ""), Tw = (...t) => `calc(${lm("+", ...t)})`, Mw = (...t) => `calc(${lm("-", ...t)})`, sy = (...t) => `calc(${lm("*", ...t)})`, Aw = (...t) => `calc(${lm("/", ...t)})`, Ew = (t) => {
    const e = MA(t);
    return e != null && !Number.isNaN(parseFloat(e)) ? String(e).startsWith("-") ? String(e).slice(1) : `-${e}` : sy(e, -1);
  }, $i = Object.assign((t) => ({
    add: (...e) => $i(Tw(t, ...e)),
    subtract: (...e) => $i(Mw(t, ...e)),
    multiply: (...e) => $i(sy(t, ...e)),
    divide: (...e) => $i(Aw(t, ...e)),
    negate: () => $i(Ew(t)),
    toString: () => t.toString()
  }), {
    add: Tw,
    subtract: Mw,
    multiply: sy,
    divide: Aw,
    negate: Ew
  });
  function HB(t, e = "-") {
    return t.replace(/\s+/g, e);
  }
  function jB(t) {
    const e = HB(t.toString());
    return UB(WB(e));
  }
  function WB(t) {
    return t.includes("\\.") ? t : !Number.isInteger(parseFloat(t.toString())) ? t.replace(".", "\\.") : t;
  }
  function UB(t) {
    return t.replace(/[!-,/:-@[-^`{-~]/g, "\\$&");
  }
  function KB(t, e = "") {
    return [
      e,
      t
    ].filter(Boolean).join("-");
  }
  function qB(t, e) {
    return `var(${t}${e ? `, ${e}` : ""})`;
  }
  function GB(t, e = "") {
    return jB(`--${KB(t, e)}`);
  }
  function ke(t, e, n) {
    const r = GB(t, n);
    return {
      variable: r,
      reference: qB(r, e)
    };
  }
  function YB(t, e) {
    const n = {};
    for (const r of e) {
      if (Array.isArray(r)) {
        const [i, o] = r;
        n[i] = ke(`${t}-${i}`, o);
        continue;
      }
      n[r] = ke(`${t}-${r}`);
    }
    return n;
  }
  const XB = [
    "colors",
    "borders",
    "borderWidths",
    "borderStyles",
    "fonts",
    "fontSizes",
    "fontWeights",
    "gradients",
    "letterSpacings",
    "lineHeights",
    "radii",
    "space",
    "shadows",
    "sizes",
    "zIndices",
    "transition",
    "blur",
    "breakpoints"
  ];
  function QB(t) {
    return UI(t, XB);
  }
  function JB(t) {
    return t.semanticTokens;
  }
  function ZB(t) {
    const { __cssMap: e, __cssVars: n, __breakpoints: r, ...i } = t;
    return i;
  }
  function eN(t) {
    const e = QB(t), n = JB(t), r = (o) => wA.includes(o) || o === "default", i = {};
    return ww(e, (o, s) => {
      o != null && (i[s.join(".")] = {
        isSemantic: false,
        value: o
      });
    }), ww(n, (o, s) => {
      o != null && (i[s.join(".")] = {
        isSemantic: true,
        value: o
      });
    }, {
      stop: (o) => Object.keys(o).every(r)
    }), i;
  }
  function Pw(t, e) {
    return ke(String(t).replace(/\./g, "-"), void 0, e);
  }
  function tN(t) {
    var _a3;
    const e = eN(t), n = (_a3 = t.config) == null ? void 0 : _a3.cssVarPrefix;
    let r = {};
    const i = {};
    function o(s, a) {
      const c = [
        String(s).split(".")[0],
        a
      ].join(".");
      if (!e[c])
        return a;
      const { reference: h } = Pw(c, n);
      return h;
    }
    for (const [s, a] of Object.entries(e)) {
      const { isSemantic: l, value: c } = a, { variable: u, reference: h } = Pw(s, n);
      if (!l) {
        if (s.startsWith("space")) {
          const v = s.split("."), [y, ...x] = v, T = `${y}.-${x.join(".")}`, w = $i.negate(c), k = $i.negate(h);
          i[T] = {
            value: w,
            var: u,
            varRef: k
          };
        }
        r[u] = c, i[s] = {
          value: c,
          var: u,
          varRef: h
        };
        continue;
      }
      const p = Hr(c) ? c : {
        default: c
      };
      r = yi(r, Object.entries(p).reduce((v, [y, x]) => {
        if (!x)
          return v;
        const T = o(s, `${x}`);
        if (y === "default")
          return v[u] = T, v;
        const w = (sm == null ? void 0 : sm[y]) ?? y;
        return v[w] = {
          [u]: T
        }, v;
      }, {})), i[s] = {
        value: h,
        var: u,
        varRef: h
      };
    }
    return {
      cssVars: r,
      cssMap: i
    };
  }
  function nN(t) {
    const e = ZB(t), { cssMap: n, cssVars: r } = tN(e);
    return Object.assign(e, {
      __cssVars: {
        ...{
          "--chakra-ring-inset": "var(--chakra-empty,/*!*/ /*!*/)",
          "--chakra-ring-offset-width": "0px",
          "--chakra-ring-offset-color": "#fff",
          "--chakra-ring-color": "rgba(66, 153, 225, 0.6)",
          "--chakra-ring-offset-shadow": "0 0 #0000",
          "--chakra-ring-shadow": "0 0 #0000",
          "--chakra-space-x-reverse": "0",
          "--chakra-space-y-reverse": "0"
        },
        ...r
      },
      __cssMap: n,
      __breakpoints: BI(e.breakpoints)
    }), e;
  }
  function Ge(t, e = {}) {
    let n = false;
    function r() {
      if (!n) {
        n = true;
        return;
      }
      throw new Error("[anatomy] .part(...) should only be called once. Did you mean to use .extend(...) ?");
    }
    function i(...u) {
      r();
      for (const h of u)
        e[h] = l(h);
      return Ge(t, e);
    }
    function o(...u) {
      for (const h of u)
        h in e || (e[h] = l(h));
      return Ge(t, e);
    }
    function s() {
      return Object.fromEntries(Object.entries(e).map(([h, p]) => [
        h,
        p.selector
      ]));
    }
    function a() {
      return Object.fromEntries(Object.entries(e).map(([h, p]) => [
        h,
        p.className
      ]));
    }
    function l(u) {
      const v = `chakra-${([
        "container",
        "root"
      ].includes(u ?? "") ? [
        t
      ] : [
        t,
        u
      ]).filter(Boolean).join("__")}`;
      return {
        className: v,
        selector: `.${v}`,
        toString: () => u
      };
    }
    return {
      parts: i,
      toPart: l,
      extend: o,
      selectors: s,
      classnames: a,
      get keys() {
        return Object.keys(e);
      },
      __type: {}
    };
  }
  const rN = Ge("accordion").parts("root", "container", "button", "panel", "icon"), iN = Ge("alert").parts("title", "description", "container", "icon", "spinner"), oN = Ge("avatar").parts("label", "badge", "container", "excessLabel", "group"), sN = Ge("breadcrumb").parts("link", "item", "container", "separator");
  Ge("button").parts();
  const aN = Ge("checkbox").parts("control", "icon", "container", "label");
  Ge("progress").parts("track", "filledTrack", "label");
  const lN = Ge("drawer").parts("overlay", "dialogContainer", "dialog", "header", "closeButton", "body", "footer"), cN = Ge("editable").parts("preview", "input", "textarea"), uN = Ge("form").parts("container", "requiredIndicator", "helperText"), fN = Ge("formError").parts("text", "icon"), hN = Ge("input").parts("addon", "field", "element", "group"), dN = Ge("list").parts("container", "item", "icon"), pN = Ge("menu").parts("button", "list", "item", "groupTitle", "icon", "command", "divider"), mN = Ge("modal").parts("overlay", "dialogContainer", "dialog", "header", "closeButton", "body", "footer"), gN = Ge("numberinput").parts("root", "field", "stepperGroup", "stepper");
  Ge("pininput").parts("field");
  const vN = Ge("popover").parts("content", "header", "body", "footer", "popper", "arrow", "closeButton"), yN = Ge("progress").parts("label", "filledTrack", "track"), bN = Ge("radio").parts("container", "control", "label"), xN = Ge("select").parts("field", "icon"), SN = Ge("slider").parts("container", "track", "thumb", "filledTrack", "mark"), wN = Ge("stat").parts("container", "label", "helpText", "number", "icon"), kN = Ge("switch").parts("container", "track", "thumb", "label"), CN = Ge("table").parts("table", "thead", "tbody", "tr", "th", "td", "tfoot", "caption"), TN = Ge("tabs").parts("root", "tab", "tablist", "tabpanel", "tabpanels", "indicator"), MN = Ge("tag").parts("container", "label", "closeButton"), AN = Ge("card").parts("container", "header", "body", "footer");
  Ge("stepper").parts("stepper", "step", "title", "description", "indicator", "separator", "icon", "number");
  const { definePartsStyle: EN, defineMultiStyleConfig: PN } = it(rN.keys), ON = {
    borderTopWidth: "1px",
    borderColor: "inherit",
    _last: {
      borderBottomWidth: "1px"
    }
  }, RN = {
    transitionProperty: "common",
    transitionDuration: "normal",
    fontSize: "md",
    _focusVisible: {
      boxShadow: "outline"
    },
    _hover: {
      bg: "blackAlpha.50"
    },
    _disabled: {
      opacity: 0.4,
      cursor: "not-allowed"
    },
    px: "4",
    py: "2"
  }, LN = {
    pt: "2",
    px: "4",
    pb: "5"
  }, _N = {
    fontSize: "1.25em"
  }, DN = EN({
    container: ON,
    button: RN,
    panel: LN,
    icon: _N
  }), IN = PN({
    baseStyle: DN
  });
  function As(t, e, n) {
    return Math.min(Math.max(t, n), e);
  }
  class BN extends Error {
    constructor(e) {
      super(`Failed to parse color: "${e}"`);
    }
  }
  var gc = BN;
  function Rb(t) {
    if (typeof t != "string")
      throw new gc(t);
    if (t.trim().toLowerCase() === "transparent")
      return [
        0,
        0,
        0,
        0
      ];
    let e = t.trim();
    e = WN.test(t) ? zN(t) : t;
    const n = FN.exec(e);
    if (n) {
      const s = Array.from(n).slice(1);
      return [
        ...s.slice(0, 3).map((a) => parseInt(xu(a, 2), 16)),
        parseInt(xu(s[3] || "f", 2), 16) / 255
      ];
    }
    const r = VN.exec(e);
    if (r) {
      const s = Array.from(r).slice(1);
      return [
        ...s.slice(0, 3).map((a) => parseInt(a, 16)),
        parseInt(s[3] || "ff", 16) / 255
      ];
    }
    const i = HN.exec(e);
    if (i) {
      const s = Array.from(i).slice(1);
      return [
        ...s.slice(0, 3).map((a) => parseInt(a, 10)),
        parseFloat(s[3] || "1")
      ];
    }
    const o = jN.exec(e);
    if (o) {
      const [s, a, l, c] = Array.from(o).slice(1).map(parseFloat);
      if (As(0, 100, a) !== a)
        throw new gc(t);
      if (As(0, 100, l) !== l)
        throw new gc(t);
      return [
        ...UN(s, a, l),
        Number.isNaN(c) ? 1 : c
      ];
    }
    throw new gc(t);
  }
  function NN(t) {
    let e = 5381, n = t.length;
    for (; n; )
      e = e * 33 ^ t.charCodeAt(--n);
    return (e >>> 0) % 2341;
  }
  const Ow = (t) => parseInt(t.replace(/_/g, ""), 36), $N = "1q29ehhb 1n09sgk7 1kl1ekf_ _yl4zsno 16z9eiv3 1p29lhp8 _bd9zg04 17u0____ _iw9zhe5 _to73___ _r45e31e _7l6g016 _jh8ouiv _zn3qba8 1jy4zshs 11u87k0u 1ro9yvyo 1aj3xael 1gz9zjz0 _3w8l4xo 1bf1ekf_ _ke3v___ _4rrkb__ 13j776yz _646mbhl _nrjr4__ _le6mbhl 1n37ehkb _m75f91n _qj3bzfz 1939yygw 11i5z6x8 _1k5f8xs 1509441m 15t5lwgf _ae2th1n _tg1ugcv 1lp1ugcv 16e14up_ _h55rw7n _ny9yavn _7a11xb_ 1ih442g9 _pv442g9 1mv16xof 14e6y7tu 1oo9zkds 17d1cisi _4v9y70f _y98m8kc 1019pq0v 12o9zda8 _348j4f4 1et50i2o _8epa8__ _ts6senj 1o350i2o 1mi9eiuo 1259yrp0 1ln80gnw _632xcoy 1cn9zldc _f29edu4 1n490c8q _9f9ziet 1b94vk74 _m49zkct 1kz6s73a 1eu9dtog _q58s1rz 1dy9sjiq __u89jo3 _aj5nkwg _ld89jo3 13h9z6wx _qa9z2ii _l119xgq _bs5arju 1hj4nwk9 1qt4nwk9 1ge6wau6 14j9zlcw 11p1edc_ _ms1zcxe _439shk6 _jt9y70f _754zsow 1la40eju _oq5p___ _x279qkz 1fa5r3rv _yd2d9ip _424tcku _8y1di2_ _zi2uabw _yy7rn9h 12yz980_ __39ljp6 1b59zg0x _n39zfzp 1fy9zest _b33k___ _hp9wq92 1il50hz4 _io472ub _lj9z3eo 19z9ykg0 _8t8iu3a 12b9bl4a 1ak5yw0o _896v4ku _tb8k8lv _s59zi6t _c09ze0p 1lg80oqn 1id9z8wb _238nba5 1kq6wgdi _154zssg _tn3zk49 _da9y6tc 1sg7cv4f _r12jvtt 1gq5fmkz 1cs9rvci _lp9jn1c _xw1tdnb 13f9zje6 16f6973h _vo7ir40 _bt5arjf _rc45e4t _hr4e100 10v4e100 _hc9zke2 _w91egv_ _sj2r1kk 13c87yx8 _vqpds__ _ni8ggk8 _tj9yqfb 1ia2j4r4 _7x9b10u 1fc9ld4j 1eq9zldr _5j9lhpx _ez9zl6o _md61fzm".split(" ").reduce((t, e) => {
    const n = Ow(e.substring(0, 3)), r = Ow(e.substring(3)).toString(16);
    let i = "";
    for (let o = 0; o < 6 - r.length; o++)
      i += "0";
    return t[n] = `${i}${r}`, t;
  }, {});
  function zN(t) {
    const e = t.toLowerCase().trim(), n = $N[NN(e)];
    if (!n)
      throw new gc(t);
    return `#${n}`;
  }
  const xu = (t, e) => Array.from(Array(e)).map(() => t).join(""), FN = new RegExp(`^#${xu("([a-f0-9])", 3)}([a-f0-9])?$`, "i"), VN = new RegExp(`^#${xu("([a-f0-9]{2})", 3)}([a-f0-9]{2})?$`, "i"), HN = new RegExp(`^rgba?\\(\\s*(\\d+)\\s*${xu(",\\s*(\\d+)\\s*", 2)}(?:,\\s*([\\d.]+))?\\s*\\)$`, "i"), jN = /^hsla?\(\s*([\d.]+)\s*,\s*([\d.]+)%\s*,\s*([\d.]+)%(?:\s*,\s*([\d.]+))?\s*\)$/i, WN = /^[a-z]+$/i, Rw = (t) => Math.round(t * 255), UN = (t, e, n) => {
    let r = n / 100;
    if (e === 0)
      return [
        r,
        r,
        r
      ].map(Rw);
    const i = (t % 360 + 360) % 360 / 60, o = (1 - Math.abs(2 * r - 1)) * (e / 100), s = o * (1 - Math.abs(i % 2 - 1));
    let a = 0, l = 0, c = 0;
    i >= 0 && i < 1 ? (a = o, l = s) : i >= 1 && i < 2 ? (a = s, l = o) : i >= 2 && i < 3 ? (l = o, c = s) : i >= 3 && i < 4 ? (l = s, c = o) : i >= 4 && i < 5 ? (a = s, c = o) : i >= 5 && i < 6 && (a = o, c = s);
    const u = r - o / 2, h = a + u, p = l + u, v = c + u;
    return [
      h,
      p,
      v
    ].map(Rw);
  };
  function KN(t, e, n, r) {
    return `rgba(${As(0, 255, t).toFixed()}, ${As(0, 255, e).toFixed()}, ${As(0, 255, n).toFixed()}, ${parseFloat(As(0, 1, r).toFixed(3))})`;
  }
  function qN(t, e) {
    const [n, r, i, o] = Rb(t);
    return KN(n, r, i, o - e);
  }
  function GN(t) {
    const [e, n, r, i] = Rb(t);
    let o = (s) => {
      const a = As(0, 255, s).toString(16);
      return a.length === 1 ? `0${a}` : a;
    };
    return `#${o(e)}${o(n)}${o(r)}${i < 1 ? o(Math.round(i * 255)) : ""}`;
  }
  const YN = (t) => Object.keys(t).length === 0;
  function XN(t, e, n, r, i) {
    for (e = e.split ? e.split(".") : e, r = 0; r < e.length; r++)
      t = t ? t[e[r]] : i;
    return t === i ? n : t;
  }
  const Sn = (t, e, n) => {
    const r = XN(t, `colors.${e}`, e);
    try {
      return GN(r), r;
    } catch {
      return n ?? "#000000";
    }
  }, QN = (t) => {
    const [e, n, r] = Rb(t);
    return (e * 299 + n * 587 + r * 114) / 1e3;
  }, JN = (t) => (e) => {
    const n = Sn(e, t);
    return QN(n) < 128 ? "dark" : "light";
  }, ZN = (t) => (e) => JN(t)(e) === "dark", al = (t, e) => (n) => {
    const r = Sn(n, t);
    return qN(r, 1 - e);
  };
  function Lw(t = "1rem", e = "rgba(255, 255, 255, 0.15)") {
    return {
      backgroundImage: `linear-gradient(
    45deg,
    ${e} 25%,
    transparent 25%,
    transparent 50%,
    ${e} 50%,
    ${e} 75%,
    transparent 75%,
    transparent
  )`,
      backgroundSize: `${t} ${t}`
    };
  }
  const e5 = () => `#${Math.floor(Math.random() * 16777215).toString(16).padEnd(6, "0")}`;
  function t5(t) {
    const e = e5();
    return !t || YN(t) ? e : t.string && t.colors ? r5(t.string, t.colors) : t.string && !t.colors ? n5(t.string) : t.colors && !t.string ? i5(t.colors) : e;
  }
  function n5(t) {
    let e = 0;
    if (t.length === 0)
      return e.toString();
    for (let r = 0; r < t.length; r += 1)
      e = t.charCodeAt(r) + ((e << 5) - e), e = e & e;
    let n = "#";
    for (let r = 0; r < 3; r += 1) {
      const i = e >> r * 8 & 255;
      n += `00${i.toString(16)}`.substr(-2);
    }
    return n;
  }
  function r5(t, e) {
    let n = 0;
    if (t.length === 0)
      return e[0];
    for (let r = 0; r < t.length; r += 1)
      n = t.charCodeAt(r) + ((n << 5) - n), n = n & n;
    return n = (n % e.length + e.length) % e.length, e[n];
  }
  function i5(t) {
    return t[Math.floor(Math.random() * t.length)];
  }
  function we(t, e) {
    return (n) => n.colorMode === "dark" ? e : t;
  }
  function Lb(t) {
    const { orientation: e, vertical: n, horizontal: r } = t;
    return e ? e === "vertical" ? n : r : {};
  }
  function AA(t) {
    return Hr(t) && t.reference ? t.reference : String(t);
  }
  const cm = (t, ...e) => e.map(AA).join(` ${t} `).replace(/calc/g, ""), _w = (...t) => `calc(${cm("+", ...t)})`, Dw = (...t) => `calc(${cm("-", ...t)})`, ay = (...t) => `calc(${cm("*", ...t)})`, Iw = (...t) => `calc(${cm("/", ...t)})`, Bw = (t) => {
    const e = AA(t);
    return e != null && !Number.isNaN(parseFloat(e)) ? String(e).startsWith("-") ? String(e).slice(1) : `-${e}` : ay(e, -1);
  }, zi = Object.assign((t) => ({
    add: (...e) => zi(_w(t, ...e)),
    subtract: (...e) => zi(Dw(t, ...e)),
    multiply: (...e) => zi(ay(t, ...e)),
    divide: (...e) => zi(Iw(t, ...e)),
    negate: () => zi(Bw(t)),
    toString: () => t.toString()
  }), {
    add: _w,
    subtract: Dw,
    multiply: ay,
    divide: Iw,
    negate: Bw
  });
  function o5(t) {
    return !Number.isInteger(parseFloat(t.toString()));
  }
  function s5(t, e = "-") {
    return t.replace(/\s+/g, e);
  }
  function EA(t) {
    const e = s5(t.toString());
    return e.includes("\\.") ? t : o5(t) ? e.replace(".", "\\.") : t;
  }
  function a5(t, e = "") {
    return [
      e,
      EA(t)
    ].filter(Boolean).join("-");
  }
  function l5(t, e) {
    return `var(${EA(t)}${e ? `, ${e}` : ""})`;
  }
  function c5(t, e = "") {
    return `--${a5(t, e)}`;
  }
  function Nt(t, e) {
    const n = c5(t, e == null ? void 0 : e.prefix);
    return {
      variable: n,
      reference: l5(n, u5(e == null ? void 0 : e.fallback))
    };
  }
  function u5(t) {
    return typeof t == "string" ? t : t == null ? void 0 : t.reference;
  }
  const { definePartsStyle: Ju, defineMultiStyleConfig: f5 } = it(iN.keys), Yn = ke("alert-fg"), Ji = ke("alert-bg"), h5 = Ju({
    container: {
      bg: Ji.reference,
      px: "4",
      py: "3"
    },
    title: {
      fontWeight: "bold",
      lineHeight: "6",
      marginEnd: "2"
    },
    description: {
      lineHeight: "6"
    },
    icon: {
      color: Yn.reference,
      flexShrink: 0,
      marginEnd: "3",
      w: "5",
      h: "6"
    },
    spinner: {
      color: Yn.reference,
      flexShrink: 0,
      marginEnd: "3",
      w: "5",
      h: "5"
    }
  });
  function _b(t) {
    const { theme: e, colorScheme: n } = t, r = al(`${n}.200`, 0.16)(e);
    return {
      light: `colors.${n}.100`,
      dark: r
    };
  }
  const d5 = Ju((t) => {
    const { colorScheme: e } = t, n = _b(t);
    return {
      container: {
        [Yn.variable]: `colors.${e}.600`,
        [Ji.variable]: n.light,
        _dark: {
          [Yn.variable]: `colors.${e}.200`,
          [Ji.variable]: n.dark
        }
      }
    };
  }), p5 = Ju((t) => {
    const { colorScheme: e } = t, n = _b(t);
    return {
      container: {
        [Yn.variable]: `colors.${e}.600`,
        [Ji.variable]: n.light,
        _dark: {
          [Yn.variable]: `colors.${e}.200`,
          [Ji.variable]: n.dark
        },
        paddingStart: "3",
        borderStartWidth: "4px",
        borderStartColor: Yn.reference
      }
    };
  }), m5 = Ju((t) => {
    const { colorScheme: e } = t, n = _b(t);
    return {
      container: {
        [Yn.variable]: `colors.${e}.600`,
        [Ji.variable]: n.light,
        _dark: {
          [Yn.variable]: `colors.${e}.200`,
          [Ji.variable]: n.dark
        },
        pt: "2",
        borderTopWidth: "4px",
        borderTopColor: Yn.reference
      }
    };
  }), g5 = Ju((t) => {
    const { colorScheme: e } = t;
    return {
      container: {
        [Yn.variable]: "colors.white",
        [Ji.variable]: `colors.${e}.600`,
        _dark: {
          [Yn.variable]: "colors.gray.900",
          [Ji.variable]: `colors.${e}.200`
        },
        color: Yn.reference
      }
    };
  }), v5 = {
    subtle: d5,
    "left-accent": p5,
    "top-accent": m5,
    solid: g5
  }, y5 = f5({
    baseStyle: h5,
    variants: v5,
    defaultProps: {
      variant: "subtle",
      colorScheme: "blue"
    }
  }), PA = {
    px: "1px",
    0.5: "0.125rem",
    1: "0.25rem",
    1.5: "0.375rem",
    2: "0.5rem",
    2.5: "0.625rem",
    3: "0.75rem",
    3.5: "0.875rem",
    4: "1rem",
    5: "1.25rem",
    6: "1.5rem",
    7: "1.75rem",
    8: "2rem",
    9: "2.25rem",
    10: "2.5rem",
    12: "3rem",
    14: "3.5rem",
    16: "4rem",
    20: "5rem",
    24: "6rem",
    28: "7rem",
    32: "8rem",
    36: "9rem",
    40: "10rem",
    44: "11rem",
    48: "12rem",
    52: "13rem",
    56: "14rem",
    60: "15rem",
    64: "16rem",
    72: "18rem",
    80: "20rem",
    96: "24rem"
  }, b5 = {
    max: "max-content",
    min: "min-content",
    full: "100%",
    "3xs": "14rem",
    "2xs": "16rem",
    xs: "20rem",
    sm: "24rem",
    md: "28rem",
    lg: "32rem",
    xl: "36rem",
    "2xl": "42rem",
    "3xl": "48rem",
    "4xl": "56rem",
    "5xl": "64rem",
    "6xl": "72rem",
    "7xl": "80rem",
    "8xl": "90rem",
    prose: "60ch"
  }, x5 = {
    sm: "640px",
    md: "768px",
    lg: "1024px",
    xl: "1280px"
  }, OA = {
    ...PA,
    ...b5,
    container: x5
  }, S5 = (t) => typeof t == "function";
  function kn(t, ...e) {
    return S5(t) ? t(...e) : t;
  }
  const { definePartsStyle: RA, defineMultiStyleConfig: w5 } = it(oN.keys), Ha = ke("avatar-border-color"), Bc = ke("avatar-bg"), Su = ke("avatar-font-size"), ll = ke("avatar-size"), k5 = {
    borderRadius: "full",
    border: "0.2em solid",
    borderColor: Ha.reference,
    [Ha.variable]: "white",
    _dark: {
      [Ha.variable]: "colors.gray.800"
    }
  }, C5 = {
    bg: Bc.reference,
    fontSize: Su.reference,
    width: ll.reference,
    height: ll.reference,
    lineHeight: "1",
    [Bc.variable]: "colors.gray.200",
    _dark: {
      [Bc.variable]: "colors.whiteAlpha.400"
    }
  }, T5 = (t) => {
    const { name: e, theme: n } = t, r = e ? t5({
      string: e
    }) : "colors.gray.400", i = ZN(r)(n);
    let o = "white";
    return i || (o = "gray.800"), {
      bg: Bc.reference,
      fontSize: Su.reference,
      color: o,
      borderColor: Ha.reference,
      verticalAlign: "top",
      width: ll.reference,
      height: ll.reference,
      "&:not([data-loaded])": {
        [Bc.variable]: r
      },
      [Ha.variable]: "colors.white",
      _dark: {
        [Ha.variable]: "colors.gray.800"
      }
    };
  }, M5 = {
    fontSize: Su.reference,
    lineHeight: "1"
  }, A5 = RA((t) => ({
    badge: kn(k5, t),
    excessLabel: kn(C5, t),
    container: kn(T5, t),
    label: M5
  }));
  function po(t) {
    const e = t !== "100%" ? OA[t] : void 0;
    return RA({
      container: {
        [ll.variable]: e ?? t,
        [Su.variable]: `calc(${e ?? t} / 2.5)`
      },
      excessLabel: {
        [ll.variable]: e ?? t,
        [Su.variable]: `calc(${e ?? t} / 2.5)`
      }
    });
  }
  const E5 = {
    "2xs": po(4),
    xs: po(6),
    sm: po(8),
    md: po(12),
    lg: po(16),
    xl: po(24),
    "2xl": po(32),
    full: po("100%")
  }, P5 = w5({
    baseStyle: A5,
    sizes: E5,
    defaultProps: {
      size: "md"
    }
  }), At = YB("badge", [
    "bg",
    "color",
    "shadow"
  ]), O5 = {
    px: 1,
    textTransform: "uppercase",
    fontSize: "xs",
    borderRadius: "sm",
    fontWeight: "bold",
    bg: At.bg.reference,
    color: At.color.reference,
    boxShadow: At.shadow.reference
  }, R5 = (t) => {
    const { colorScheme: e, theme: n } = t, r = al(`${e}.500`, 0.6)(n);
    return {
      [At.bg.variable]: `colors.${e}.500`,
      [At.color.variable]: "colors.white",
      _dark: {
        [At.bg.variable]: r,
        [At.color.variable]: "colors.whiteAlpha.800"
      }
    };
  }, L5 = (t) => {
    const { colorScheme: e, theme: n } = t, r = al(`${e}.200`, 0.16)(n);
    return {
      [At.bg.variable]: `colors.${e}.100`,
      [At.color.variable]: `colors.${e}.800`,
      _dark: {
        [At.bg.variable]: r,
        [At.color.variable]: `colors.${e}.200`
      }
    };
  }, _5 = (t) => {
    const { colorScheme: e, theme: n } = t, r = al(`${e}.200`, 0.8)(n);
    return {
      [At.color.variable]: `colors.${e}.500`,
      _dark: {
        [At.color.variable]: r
      },
      [At.shadow.variable]: `inset 0 0 0px 1px ${At.color.reference}`
    };
  }, D5 = {
    solid: R5,
    subtle: L5,
    outline: _5
  }, Nc = {
    baseStyle: O5,
    variants: D5,
    defaultProps: {
      variant: "subtle",
      colorScheme: "gray"
    }
  }, { defineMultiStyleConfig: I5, definePartsStyle: B5 } = it(sN.keys), Jg = ke("breadcrumb-link-decor"), N5 = {
    transitionProperty: "common",
    transitionDuration: "fast",
    transitionTimingFunction: "ease-out",
    outline: "none",
    color: "inherit",
    textDecoration: Jg.reference,
    [Jg.variable]: "none",
    "&:not([aria-current=page])": {
      cursor: "pointer",
      _hover: {
        [Jg.variable]: "underline"
      },
      _focusVisible: {
        boxShadow: "outline"
      }
    }
  }, $5 = B5({
    link: N5
  }), z5 = I5({
    baseStyle: $5
  }), F5 = {
    lineHeight: "1.2",
    borderRadius: "md",
    fontWeight: "semibold",
    transitionProperty: "common",
    transitionDuration: "normal",
    _focusVisible: {
      boxShadow: "outline"
    },
    _disabled: {
      opacity: 0.4,
      cursor: "not-allowed",
      boxShadow: "none"
    },
    _hover: {
      _disabled: {
        bg: "initial"
      }
    }
  }, LA = (t) => {
    const { colorScheme: e, theme: n } = t;
    if (e === "gray")
      return {
        color: we("gray.800", "whiteAlpha.900")(t),
        _hover: {
          bg: we("gray.100", "whiteAlpha.200")(t)
        },
        _active: {
          bg: we("gray.200", "whiteAlpha.300")(t)
        }
      };
    const r = al(`${e}.200`, 0.12)(n), i = al(`${e}.200`, 0.24)(n);
    return {
      color: we(`${e}.600`, `${e}.200`)(t),
      bg: "transparent",
      _hover: {
        bg: we(`${e}.50`, r)(t)
      },
      _active: {
        bg: we(`${e}.100`, i)(t)
      }
    };
  }, V5 = (t) => {
    const { colorScheme: e } = t, n = we("gray.200", "whiteAlpha.300")(t);
    return {
      border: "1px solid",
      borderColor: e === "gray" ? n : "currentColor",
      ".chakra-button__group[data-attached][data-orientation=horizontal] > &:not(:last-of-type)": {
        marginEnd: "-1px"
      },
      ".chakra-button__group[data-attached][data-orientation=vertical] > &:not(:last-of-type)": {
        marginBottom: "-1px"
      },
      ...kn(LA, t)
    };
  }, H5 = {
    yellow: {
      bg: "yellow.400",
      color: "black",
      hoverBg: "yellow.500",
      activeBg: "yellow.600"
    },
    cyan: {
      bg: "cyan.400",
      color: "black",
      hoverBg: "cyan.500",
      activeBg: "cyan.600"
    }
  }, j5 = (t) => {
    const { colorScheme: e } = t;
    if (e === "gray") {
      const a = we("gray.100", "whiteAlpha.200")(t);
      return {
        bg: a,
        color: we("gray.800", "whiteAlpha.900")(t),
        _hover: {
          bg: we("gray.200", "whiteAlpha.300")(t),
          _disabled: {
            bg: a
          }
        },
        _active: {
          bg: we("gray.300", "whiteAlpha.400")(t)
        }
      };
    }
    const { bg: n = `${e}.500`, color: r = "white", hoverBg: i = `${e}.600`, activeBg: o = `${e}.700` } = H5[e] ?? {}, s = we(n, `${e}.200`)(t);
    return {
      bg: s,
      color: we(r, "gray.800")(t),
      _hover: {
        bg: we(i, `${e}.300`)(t),
        _disabled: {
          bg: s
        }
      },
      _active: {
        bg: we(o, `${e}.400`)(t)
      }
    };
  }, W5 = (t) => {
    const { colorScheme: e } = t;
    return {
      padding: 0,
      height: "auto",
      lineHeight: "normal",
      verticalAlign: "baseline",
      color: we(`${e}.500`, `${e}.200`)(t),
      _hover: {
        textDecoration: "underline",
        _disabled: {
          textDecoration: "none"
        }
      },
      _active: {
        color: we(`${e}.700`, `${e}.500`)(t)
      }
    };
  }, U5 = {
    bg: "none",
    color: "inherit",
    display: "inline",
    lineHeight: "inherit",
    m: "0",
    p: "0"
  }, K5 = {
    ghost: LA,
    outline: V5,
    solid: j5,
    link: W5,
    unstyled: U5
  }, q5 = {
    lg: {
      h: "12",
      minW: "12",
      fontSize: "lg",
      px: "6"
    },
    md: {
      h: "10",
      minW: "10",
      fontSize: "md",
      px: "4"
    },
    sm: {
      h: "8",
      minW: "8",
      fontSize: "sm",
      px: "3"
    },
    xs: {
      h: "6",
      minW: "6",
      fontSize: "xs",
      px: "2"
    }
  }, G5 = {
    baseStyle: F5,
    variants: K5,
    sizes: q5,
    defaultProps: {
      variant: "solid",
      size: "md",
      colorScheme: "gray"
    }
  }, { definePartsStyle: _s, defineMultiStyleConfig: Y5 } = it(AN.keys), rp = ke("card-bg"), Ki = ke("card-padding"), _A = ke("card-shadow"), od = ke("card-radius"), DA = ke("card-border-width", "0"), IA = ke("card-border-color"), X5 = _s({
    container: {
      [rp.variable]: "colors.chakra-body-bg",
      backgroundColor: rp.reference,
      boxShadow: _A.reference,
      borderRadius: od.reference,
      color: "chakra-body-text",
      borderWidth: DA.reference,
      borderColor: IA.reference
    },
    body: {
      padding: Ki.reference,
      flex: "1 1 0%"
    },
    header: {
      padding: Ki.reference
    },
    footer: {
      padding: Ki.reference
    }
  }), Q5 = {
    sm: _s({
      container: {
        [od.variable]: "radii.base",
        [Ki.variable]: "space.3"
      }
    }),
    md: _s({
      container: {
        [od.variable]: "radii.md",
        [Ki.variable]: "space.5"
      }
    }),
    lg: _s({
      container: {
        [od.variable]: "radii.xl",
        [Ki.variable]: "space.7"
      }
    })
  }, J5 = {
    elevated: _s({
      container: {
        [_A.variable]: "shadows.base",
        _dark: {
          [rp.variable]: "colors.gray.700"
        }
      }
    }),
    outline: _s({
      container: {
        [DA.variable]: "1px",
        [IA.variable]: "colors.chakra-border-color"
      }
    }),
    filled: _s({
      container: {
        [rp.variable]: "colors.chakra-subtle-bg"
      }
    }),
    unstyled: {
      body: {
        [Ki.variable]: 0
      },
      header: {
        [Ki.variable]: 0
      },
      footer: {
        [Ki.variable]: 0
      }
    }
  }, Z5 = Y5({
    baseStyle: X5,
    variants: J5,
    sizes: Q5,
    defaultProps: {
      variant: "elevated",
      size: "md"
    }
  }), { definePartsStyle: sd, defineMultiStyleConfig: e$ } = it(aN.keys), $c = ke("checkbox-size"), t$ = (t) => {
    const { colorScheme: e } = t;
    return {
      w: $c.reference,
      h: $c.reference,
      transitionProperty: "box-shadow",
      transitionDuration: "normal",
      border: "2px solid",
      borderRadius: "sm",
      borderColor: "inherit",
      color: "white",
      _checked: {
        bg: we(`${e}.500`, `${e}.200`)(t),
        borderColor: we(`${e}.500`, `${e}.200`)(t),
        color: we("white", "gray.900")(t),
        _hover: {
          bg: we(`${e}.600`, `${e}.300`)(t),
          borderColor: we(`${e}.600`, `${e}.300`)(t)
        },
        _disabled: {
          borderColor: we("gray.200", "transparent")(t),
          bg: we("gray.200", "whiteAlpha.300")(t),
          color: we("gray.500", "whiteAlpha.500")(t)
        }
      },
      _indeterminate: {
        bg: we(`${e}.500`, `${e}.200`)(t),
        borderColor: we(`${e}.500`, `${e}.200`)(t),
        color: we("white", "gray.900")(t)
      },
      _disabled: {
        bg: we("gray.100", "whiteAlpha.100")(t),
        borderColor: we("gray.100", "transparent")(t)
      },
      _focusVisible: {
        boxShadow: "outline"
      },
      _invalid: {
        borderColor: we("red.500", "red.300")(t)
      }
    };
  }, n$ = {
    _disabled: {
      cursor: "not-allowed"
    }
  }, r$ = {
    userSelect: "none",
    _disabled: {
      opacity: 0.4
    }
  }, i$ = {
    transitionProperty: "transform",
    transitionDuration: "normal"
  }, o$ = sd((t) => ({
    icon: i$,
    container: n$,
    control: kn(t$, t),
    label: r$
  })), s$ = {
    sm: sd({
      control: {
        [$c.variable]: "sizes.3"
      },
      label: {
        fontSize: "sm"
      },
      icon: {
        fontSize: "3xs"
      }
    }),
    md: sd({
      control: {
        [$c.variable]: "sizes.4"
      },
      label: {
        fontSize: "md"
      },
      icon: {
        fontSize: "2xs"
      }
    }),
    lg: sd({
      control: {
        [$c.variable]: "sizes.5"
      },
      label: {
        fontSize: "lg"
      },
      icon: {
        fontSize: "2xs"
      }
    })
  }, ip = e$({
    baseStyle: o$,
    sizes: s$,
    defaultProps: {
      size: "md",
      colorScheme: "blue"
    }
  }), zc = Nt("close-button-size"), Zl = Nt("close-button-bg"), a$ = {
    w: [
      zc.reference
    ],
    h: [
      zc.reference
    ],
    borderRadius: "md",
    transitionProperty: "common",
    transitionDuration: "normal",
    _disabled: {
      opacity: 0.4,
      cursor: "not-allowed",
      boxShadow: "none"
    },
    _hover: {
      [Zl.variable]: "colors.blackAlpha.100",
      _dark: {
        [Zl.variable]: "colors.whiteAlpha.100"
      }
    },
    _active: {
      [Zl.variable]: "colors.blackAlpha.200",
      _dark: {
        [Zl.variable]: "colors.whiteAlpha.200"
      }
    },
    _focusVisible: {
      boxShadow: "outline"
    },
    bg: Zl.reference
  }, l$ = {
    lg: {
      [zc.variable]: "sizes.10",
      fontSize: "md"
    },
    md: {
      [zc.variable]: "sizes.8",
      fontSize: "xs"
    },
    sm: {
      [zc.variable]: "sizes.6",
      fontSize: "2xs"
    }
  }, c$ = {
    baseStyle: a$,
    sizes: l$,
    defaultProps: {
      size: "md"
    }
  }, { variants: u$, defaultProps: f$ } = Nc, h$ = {
    fontFamily: "mono",
    fontSize: "sm",
    px: "0.2em",
    borderRadius: "sm",
    bg: At.bg.reference,
    color: At.color.reference,
    boxShadow: At.shadow.reference
  }, d$ = {
    baseStyle: h$,
    variants: u$,
    defaultProps: f$
  }, p$ = {
    w: "100%",
    mx: "auto",
    maxW: "prose",
    px: "4"
  }, m$ = {
    baseStyle: p$
  }, g$ = {
    opacity: 0.6,
    borderColor: "inherit"
  }, v$ = {
    borderStyle: "solid"
  }, y$ = {
    borderStyle: "dashed"
  }, b$ = {
    solid: v$,
    dashed: y$
  }, x$ = {
    baseStyle: g$,
    variants: b$,
    defaultProps: {
      variant: "solid"
    }
  }, { definePartsStyle: ly, defineMultiStyleConfig: S$ } = it(lN.keys), Zg = ke("drawer-bg"), e0 = ke("drawer-box-shadow");
  function la(t) {
    return ly(t === "full" ? {
      dialog: {
        maxW: "100vw",
        h: "100vh"
      }
    } : {
      dialog: {
        maxW: t
      }
    });
  }
  const w$ = {
    bg: "blackAlpha.600",
    zIndex: "modal"
  }, k$ = {
    display: "flex",
    zIndex: "modal",
    justifyContent: "center"
  }, C$ = (t) => {
    const { isFullHeight: e } = t;
    return {
      ...e && {
        height: "100vh"
      },
      zIndex: "modal",
      maxH: "100vh",
      color: "inherit",
      [Zg.variable]: "colors.white",
      [e0.variable]: "shadows.lg",
      _dark: {
        [Zg.variable]: "colors.gray.700",
        [e0.variable]: "shadows.dark-lg"
      },
      bg: Zg.reference,
      boxShadow: e0.reference
    };
  }, T$ = {
    px: "6",
    py: "4",
    fontSize: "xl",
    fontWeight: "semibold"
  }, M$ = {
    position: "absolute",
    top: "2",
    insetEnd: "3"
  }, A$ = {
    px: "6",
    py: "2",
    flex: "1",
    overflow: "auto"
  }, E$ = {
    px: "6",
    py: "4"
  }, P$ = ly((t) => ({
    overlay: w$,
    dialogContainer: k$,
    dialog: kn(C$, t),
    header: T$,
    closeButton: M$,
    body: A$,
    footer: E$
  })), O$ = {
    xs: la("xs"),
    sm: la("md"),
    md: la("lg"),
    lg: la("2xl"),
    xl: la("4xl"),
    full: la("full")
  }, R$ = S$({
    baseStyle: P$,
    sizes: O$,
    defaultProps: {
      size: "xs"
    }
  }), { definePartsStyle: L$, defineMultiStyleConfig: _$ } = it(cN.keys), D$ = {
    borderRadius: "md",
    py: "1",
    transitionProperty: "common",
    transitionDuration: "normal"
  }, I$ = {
    borderRadius: "md",
    py: "1",
    transitionProperty: "common",
    transitionDuration: "normal",
    width: "full",
    _focusVisible: {
      boxShadow: "outline"
    },
    _placeholder: {
      opacity: 0.6
    }
  }, B$ = {
    borderRadius: "md",
    py: "1",
    transitionProperty: "common",
    transitionDuration: "normal",
    width: "full",
    _focusVisible: {
      boxShadow: "outline"
    },
    _placeholder: {
      opacity: 0.6
    }
  }, N$ = L$({
    preview: D$,
    input: I$,
    textarea: B$
  }), $$ = _$({
    baseStyle: N$
  }), { definePartsStyle: z$, defineMultiStyleConfig: F$ } = it(uN.keys), ja = ke("form-control-color"), V$ = {
    marginStart: "1",
    [ja.variable]: "colors.red.500",
    _dark: {
      [ja.variable]: "colors.red.300"
    },
    color: ja.reference
  }, H$ = {
    mt: "2",
    [ja.variable]: "colors.gray.600",
    _dark: {
      [ja.variable]: "colors.whiteAlpha.600"
    },
    color: ja.reference,
    lineHeight: "normal",
    fontSize: "sm"
  }, j$ = z$({
    container: {
      width: "100%",
      position: "relative"
    },
    requiredIndicator: V$,
    helperText: H$
  }), W$ = F$({
    baseStyle: j$
  }), { definePartsStyle: U$, defineMultiStyleConfig: K$ } = it(fN.keys), Wa = ke("form-error-color"), q$ = {
    [Wa.variable]: "colors.red.500",
    _dark: {
      [Wa.variable]: "colors.red.300"
    },
    color: Wa.reference,
    mt: "2",
    fontSize: "sm",
    lineHeight: "normal"
  }, G$ = {
    marginEnd: "0.5em",
    [Wa.variable]: "colors.red.500",
    _dark: {
      [Wa.variable]: "colors.red.300"
    },
    color: Wa.reference
  }, Y$ = U$({
    text: q$,
    icon: G$
  }), X$ = K$({
    baseStyle: Y$
  }), Q$ = {
    fontSize: "md",
    marginEnd: "3",
    mb: "2",
    fontWeight: "medium",
    transitionProperty: "common",
    transitionDuration: "normal",
    opacity: 1,
    _disabled: {
      opacity: 0.4
    }
  }, J$ = {
    baseStyle: Q$
  }, Z$ = {
    fontFamily: "heading",
    fontWeight: "bold"
  }, e3 = {
    "4xl": {
      fontSize: [
        "6xl",
        null,
        "7xl"
      ],
      lineHeight: 1
    },
    "3xl": {
      fontSize: [
        "5xl",
        null,
        "6xl"
      ],
      lineHeight: 1
    },
    "2xl": {
      fontSize: [
        "4xl",
        null,
        "5xl"
      ],
      lineHeight: [
        1.2,
        null,
        1
      ]
    },
    xl: {
      fontSize: [
        "3xl",
        null,
        "4xl"
      ],
      lineHeight: [
        1.33,
        null,
        1.2
      ]
    },
    lg: {
      fontSize: [
        "2xl",
        null,
        "3xl"
      ],
      lineHeight: [
        1.33,
        null,
        1.2
      ]
    },
    md: {
      fontSize: "xl",
      lineHeight: 1.2
    },
    sm: {
      fontSize: "md",
      lineHeight: 1.2
    },
    xs: {
      fontSize: "sm",
      lineHeight: 1.2
    }
  }, t3 = {
    baseStyle: Z$,
    sizes: e3,
    defaultProps: {
      size: "xl"
    }
  }, { definePartsStyle: Wi, defineMultiStyleConfig: n3 } = it(hN.keys), Ta = ke("input-height"), Ma = ke("input-font-size"), Aa = ke("input-padding"), Ea = ke("input-border-radius"), r3 = Wi({
    addon: {
      height: Ta.reference,
      fontSize: Ma.reference,
      px: Aa.reference,
      borderRadius: Ea.reference
    },
    field: {
      width: "100%",
      height: Ta.reference,
      fontSize: Ma.reference,
      px: Aa.reference,
      borderRadius: Ea.reference,
      minWidth: 0,
      outline: 0,
      position: "relative",
      appearance: "none",
      transitionProperty: "common",
      transitionDuration: "normal",
      _disabled: {
        opacity: 0.4,
        cursor: "not-allowed"
      }
    }
  }), mo = {
    lg: {
      [Ma.variable]: "fontSizes.lg",
      [Aa.variable]: "space.4",
      [Ea.variable]: "radii.md",
      [Ta.variable]: "sizes.12"
    },
    md: {
      [Ma.variable]: "fontSizes.md",
      [Aa.variable]: "space.4",
      [Ea.variable]: "radii.md",
      [Ta.variable]: "sizes.10"
    },
    sm: {
      [Ma.variable]: "fontSizes.sm",
      [Aa.variable]: "space.3",
      [Ea.variable]: "radii.sm",
      [Ta.variable]: "sizes.8"
    },
    xs: {
      [Ma.variable]: "fontSizes.xs",
      [Aa.variable]: "space.2",
      [Ea.variable]: "radii.sm",
      [Ta.variable]: "sizes.6"
    }
  }, i3 = {
    lg: Wi({
      field: mo.lg,
      group: mo.lg
    }),
    md: Wi({
      field: mo.md,
      group: mo.md
    }),
    sm: Wi({
      field: mo.sm,
      group: mo.sm
    }),
    xs: Wi({
      field: mo.xs,
      group: mo.xs
    })
  };
  function Db(t) {
    const { focusBorderColor: e, errorBorderColor: n } = t;
    return {
      focusBorderColor: e || we("blue.500", "blue.300")(t),
      errorBorderColor: n || we("red.500", "red.300")(t)
    };
  }
  const o3 = Wi((t) => {
    const { theme: e } = t, { focusBorderColor: n, errorBorderColor: r } = Db(t);
    return {
      field: {
        border: "1px solid",
        borderColor: "inherit",
        bg: "inherit",
        _hover: {
          borderColor: we("gray.300", "whiteAlpha.400")(t)
        },
        _readOnly: {
          boxShadow: "none !important",
          userSelect: "all"
        },
        _invalid: {
          borderColor: Sn(e, r),
          boxShadow: `0 0 0 1px ${Sn(e, r)}`
        },
        _focusVisible: {
          zIndex: 1,
          borderColor: Sn(e, n),
          boxShadow: `0 0 0 1px ${Sn(e, n)}`
        }
      },
      addon: {
        border: "1px solid",
        borderColor: we("inherit", "whiteAlpha.50")(t),
        bg: we("gray.100", "whiteAlpha.300")(t)
      }
    };
  }), s3 = Wi((t) => {
    const { theme: e } = t, { focusBorderColor: n, errorBorderColor: r } = Db(t);
    return {
      field: {
        border: "2px solid",
        borderColor: "transparent",
        bg: we("gray.100", "whiteAlpha.50")(t),
        _hover: {
          bg: we("gray.200", "whiteAlpha.100")(t)
        },
        _readOnly: {
          boxShadow: "none !important",
          userSelect: "all"
        },
        _invalid: {
          borderColor: Sn(e, r)
        },
        _focusVisible: {
          bg: "transparent",
          borderColor: Sn(e, n)
        }
      },
      addon: {
        border: "2px solid",
        borderColor: "transparent",
        bg: we("gray.100", "whiteAlpha.50")(t)
      }
    };
  }), a3 = Wi((t) => {
    const { theme: e } = t, { focusBorderColor: n, errorBorderColor: r } = Db(t);
    return {
      field: {
        borderBottom: "1px solid",
        borderColor: "inherit",
        borderRadius: "0",
        px: "0",
        bg: "transparent",
        _readOnly: {
          boxShadow: "none !important",
          userSelect: "all"
        },
        _invalid: {
          borderColor: Sn(e, r),
          boxShadow: `0px 1px 0px 0px ${Sn(e, r)}`
        },
        _focusVisible: {
          borderColor: Sn(e, n),
          boxShadow: `0px 1px 0px 0px ${Sn(e, n)}`
        }
      },
      addon: {
        borderBottom: "2px solid",
        borderColor: "inherit",
        borderRadius: "0",
        px: "0",
        bg: "transparent"
      }
    };
  }), l3 = Wi({
    field: {
      bg: "transparent",
      px: "0",
      height: "auto"
    },
    addon: {
      bg: "transparent",
      px: "0",
      height: "auto"
    }
  }), c3 = {
    outline: o3,
    filled: s3,
    flushed: a3,
    unstyled: l3
  }, qe = n3({
    baseStyle: r3,
    sizes: i3,
    variants: c3,
    defaultProps: {
      size: "md",
      variant: "outline"
    }
  }), t0 = ke("kbd-bg"), u3 = {
    [t0.variable]: "colors.gray.100",
    _dark: {
      [t0.variable]: "colors.whiteAlpha.100"
    },
    bg: t0.reference,
    borderRadius: "md",
    borderWidth: "1px",
    borderBottomWidth: "3px",
    fontSize: "0.8em",
    fontWeight: "bold",
    lineHeight: "normal",
    px: "0.4em",
    whiteSpace: "nowrap"
  }, f3 = {
    baseStyle: u3
  }, h3 = {
    transitionProperty: "common",
    transitionDuration: "fast",
    transitionTimingFunction: "ease-out",
    cursor: "pointer",
    textDecoration: "none",
    outline: "none",
    color: "inherit",
    _hover: {
      textDecoration: "underline"
    },
    _focusVisible: {
      boxShadow: "outline"
    }
  }, d3 = {
    baseStyle: h3
  }, { defineMultiStyleConfig: p3, definePartsStyle: m3 } = it(dN.keys), g3 = {
    marginEnd: "2",
    display: "inline",
    verticalAlign: "text-bottom"
  }, v3 = m3({
    icon: g3
  }), y3 = p3({
    baseStyle: v3
  }), { defineMultiStyleConfig: b3, definePartsStyle: x3 } = it(pN.keys), ci = ke("menu-bg"), n0 = ke("menu-shadow"), S3 = {
    [ci.variable]: "#fff",
    [n0.variable]: "shadows.sm",
    _dark: {
      [ci.variable]: "colors.gray.700",
      [n0.variable]: "shadows.dark-lg"
    },
    color: "inherit",
    minW: "3xs",
    py: "2",
    zIndex: "dropdown",
    borderRadius: "md",
    borderWidth: "1px",
    bg: ci.reference,
    boxShadow: n0.reference
  }, w3 = {
    py: "1.5",
    px: "3",
    transitionProperty: "background",
    transitionDuration: "ultra-fast",
    transitionTimingFunction: "ease-in",
    _focus: {
      [ci.variable]: "colors.gray.100",
      _dark: {
        [ci.variable]: "colors.whiteAlpha.100"
      }
    },
    _active: {
      [ci.variable]: "colors.gray.200",
      _dark: {
        [ci.variable]: "colors.whiteAlpha.200"
      }
    },
    _expanded: {
      [ci.variable]: "colors.gray.100",
      _dark: {
        [ci.variable]: "colors.whiteAlpha.100"
      }
    },
    _disabled: {
      opacity: 0.4,
      cursor: "not-allowed"
    },
    bg: ci.reference
  }, k3 = {
    mx: 4,
    my: 2,
    fontWeight: "semibold",
    fontSize: "sm"
  }, C3 = {
    display: "inline-flex",
    alignItems: "center",
    justifyContent: "center",
    flexShrink: 0
  }, T3 = {
    opacity: 0.6
  }, M3 = {
    border: 0,
    borderBottom: "1px solid",
    borderColor: "inherit",
    my: "2",
    opacity: 0.6
  }, A3 = {
    transitionProperty: "common",
    transitionDuration: "normal"
  }, E3 = x3({
    button: A3,
    list: S3,
    item: w3,
    groupTitle: k3,
    icon: C3,
    command: T3,
    divider: M3
  }), P3 = b3({
    baseStyle: E3
  }), { defineMultiStyleConfig: O3, definePartsStyle: cy } = it(mN.keys), r0 = ke("modal-bg"), i0 = ke("modal-shadow"), R3 = {
    bg: "blackAlpha.600",
    zIndex: "modal"
  }, L3 = (t) => {
    const { isCentered: e, scrollBehavior: n } = t;
    return {
      display: "flex",
      zIndex: "modal",
      justifyContent: "center",
      alignItems: e ? "center" : "flex-start",
      overflow: n === "inside" ? "hidden" : "auto",
      overscrollBehaviorY: "none"
    };
  }, _3 = (t) => {
    const { isCentered: e, scrollBehavior: n } = t;
    return {
      borderRadius: "md",
      color: "inherit",
      my: e ? "auto" : "16",
      mx: e ? "auto" : void 0,
      zIndex: "modal",
      maxH: n === "inside" ? "calc(100% - 7.5rem)" : void 0,
      [r0.variable]: "colors.white",
      [i0.variable]: "shadows.lg",
      _dark: {
        [r0.variable]: "colors.gray.700",
        [i0.variable]: "shadows.dark-lg"
      },
      bg: r0.reference,
      boxShadow: i0.reference
    };
  }, D3 = {
    px: "6",
    py: "4",
    fontSize: "xl",
    fontWeight: "semibold"
  }, I3 = {
    position: "absolute",
    top: "2",
    insetEnd: "3"
  }, B3 = (t) => {
    const { scrollBehavior: e } = t;
    return {
      px: "6",
      py: "2",
      flex: "1",
      overflow: e === "inside" ? "auto" : void 0
    };
  }, N3 = {
    px: "6",
    py: "4"
  }, $3 = cy((t) => ({
    overlay: R3,
    dialogContainer: kn(L3, t),
    dialog: kn(_3, t),
    header: D3,
    closeButton: I3,
    body: kn(B3, t),
    footer: N3
  }));
  function Lr(t) {
    return cy(t === "full" ? {
      dialog: {
        maxW: "100vw",
        minH: "$100vh",
        my: "0",
        borderRadius: "0"
      }
    } : {
      dialog: {
        maxW: t
      }
    });
  }
  const z3 = {
    xs: Lr("xs"),
    sm: Lr("sm"),
    md: Lr("md"),
    lg: Lr("lg"),
    xl: Lr("xl"),
    "2xl": Lr("2xl"),
    "3xl": Lr("3xl"),
    "4xl": Lr("4xl"),
    "5xl": Lr("5xl"),
    "6xl": Lr("6xl"),
    full: Lr("full")
  }, F3 = O3({
    baseStyle: $3,
    sizes: z3,
    defaultProps: {
      size: "md"
    }
  }), BA = {
    letterSpacings: {
      tighter: "-0.05em",
      tight: "-0.025em",
      normal: "0",
      wide: "0.025em",
      wider: "0.05em",
      widest: "0.1em"
    },
    lineHeights: {
      normal: "normal",
      none: 1,
      shorter: 1.25,
      short: 1.375,
      base: 1.5,
      tall: 1.625,
      taller: "2",
      3: ".75rem",
      4: "1rem",
      5: "1.25rem",
      6: "1.5rem",
      7: "1.75rem",
      8: "2rem",
      9: "2.25rem",
      10: "2.5rem"
    },
    fontWeights: {
      hairline: 100,
      thin: 200,
      light: 300,
      normal: 400,
      medium: 500,
      semibold: 600,
      bold: 700,
      extrabold: 800,
      black: 900
    },
    fonts: {
      heading: '-apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol"',
      body: '-apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol"',
      mono: 'SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace'
    },
    fontSizes: {
      "3xs": "0.45rem",
      "2xs": "0.625rem",
      xs: "0.75rem",
      sm: "0.875rem",
      md: "1rem",
      lg: "1.125rem",
      xl: "1.25rem",
      "2xl": "1.5rem",
      "3xl": "1.875rem",
      "4xl": "2.25rem",
      "5xl": "3rem",
      "6xl": "3.75rem",
      "7xl": "4.5rem",
      "8xl": "6rem",
      "9xl": "8rem"
    }
  }, { defineMultiStyleConfig: V3, definePartsStyle: NA } = it(gN.keys), Ib = Nt("number-input-stepper-width"), $A = Nt("number-input-input-padding"), H3 = zi(Ib).add("0.5rem").toString(), o0 = Nt("number-input-bg"), s0 = Nt("number-input-color"), a0 = Nt("number-input-border-color"), j3 = {
    [Ib.variable]: "sizes.6",
    [$A.variable]: H3
  }, W3 = (t) => {
    var _a3;
    return ((_a3 = kn(qe.baseStyle, t)) == null ? void 0 : _a3.field) ?? {};
  }, U3 = {
    width: Ib.reference
  }, K3 = {
    borderStart: "1px solid",
    borderStartColor: a0.reference,
    color: s0.reference,
    bg: o0.reference,
    [s0.variable]: "colors.chakra-body-text",
    [a0.variable]: "colors.chakra-border-color",
    _dark: {
      [s0.variable]: "colors.whiteAlpha.800",
      [a0.variable]: "colors.whiteAlpha.300"
    },
    _active: {
      [o0.variable]: "colors.gray.200",
      _dark: {
        [o0.variable]: "colors.whiteAlpha.300"
      }
    },
    _disabled: {
      opacity: 0.4,
      cursor: "not-allowed"
    }
  }, q3 = NA((t) => ({
    root: j3,
    field: kn(W3, t) ?? {},
    stepperGroup: U3,
    stepper: K3
  }));
  function ah(t) {
    var _a3, _b3;
    const e = (_a3 = qe.sizes) == null ? void 0 : _a3[t], n = {
      lg: "md",
      md: "md",
      sm: "sm",
      xs: "sm"
    }, r = ((_b3 = e.field) == null ? void 0 : _b3.fontSize) ?? "md", i = BA.fontSizes[r];
    return NA({
      field: {
        ...e.field,
        paddingInlineEnd: $A.reference,
        verticalAlign: "top"
      },
      stepper: {
        fontSize: zi(i).multiply(0.75).toString(),
        _first: {
          borderTopEndRadius: n[t]
        },
        _last: {
          borderBottomEndRadius: n[t],
          mt: "-1px",
          borderTopWidth: 1
        }
      }
    });
  }
  const G3 = {
    xs: ah("xs"),
    sm: ah("sm"),
    md: ah("md"),
    lg: ah("lg")
  }, Y3 = V3({
    baseStyle: q3,
    sizes: G3,
    variants: qe.variants,
    defaultProps: qe.defaultProps
  }), X3 = {
    ...(_a2 = qe.baseStyle) == null ? void 0 : _a2.field,
    textAlign: "center"
  }, Q3 = {
    lg: {
      fontSize: "lg",
      w: 12,
      h: 12,
      borderRadius: "md"
    },
    md: {
      fontSize: "md",
      w: 10,
      h: 10,
      borderRadius: "md"
    },
    sm: {
      fontSize: "sm",
      w: 8,
      h: 8,
      borderRadius: "sm"
    },
    xs: {
      fontSize: "xs",
      w: 6,
      h: 6,
      borderRadius: "sm"
    }
  }, J3 = {
    outline: (t) => {
      var _a3, _b3;
      return ((_b3 = kn((_a3 = qe.variants) == null ? void 0 : _a3.outline, t)) == null ? void 0 : _b3.field) ?? {};
    },
    flushed: (t) => {
      var _a3, _b3;
      return ((_b3 = kn((_a3 = qe.variants) == null ? void 0 : _a3.flushed, t)) == null ? void 0 : _b3.field) ?? {};
    },
    filled: (t) => {
      var _a3, _b3;
      return ((_b3 = kn((_a3 = qe.variants) == null ? void 0 : _a3.filled, t)) == null ? void 0 : _b3.field) ?? {};
    },
    unstyled: ((_b2 = qe.variants) == null ? void 0 : _b2.unstyled.field) ?? {}
  }, Z3 = {
    baseStyle: X3,
    sizes: Q3,
    variants: J3,
    defaultProps: qe.defaultProps
  }, { defineMultiStyleConfig: ez, definePartsStyle: tz } = it(vN.keys), lh = Nt("popper-bg"), nz = Nt("popper-arrow-bg"), Nw = Nt("popper-arrow-shadow-color"), rz = {
    zIndex: "popover"
  }, iz = {
    [lh.variable]: "colors.white",
    bg: lh.reference,
    [nz.variable]: lh.reference,
    [Nw.variable]: "colors.gray.200",
    _dark: {
      [lh.variable]: "colors.gray.700",
      [Nw.variable]: "colors.whiteAlpha.300"
    },
    width: "xs",
    border: "1px solid",
    borderColor: "inherit",
    borderRadius: "md",
    boxShadow: "sm",
    zIndex: "inherit",
    _focusVisible: {
      outline: 0,
      boxShadow: "outline"
    }
  }, oz = {
    px: 3,
    py: 2,
    borderBottomWidth: "1px"
  }, sz = {
    px: 3,
    py: 2
  }, az = {
    px: 3,
    py: 2,
    borderTopWidth: "1px"
  }, lz = {
    position: "absolute",
    borderRadius: "md",
    top: 1,
    insetEnd: 2,
    padding: 2
  }, cz = tz({
    popper: rz,
    content: iz,
    header: oz,
    body: sz,
    footer: az,
    closeButton: lz
  }), uz = ez({
    baseStyle: cz
  }), { defineMultiStyleConfig: fz, definePartsStyle: vc } = it(yN.keys), hz = (t) => {
    const { colorScheme: e, theme: n, isIndeterminate: r, hasStripe: i } = t, o = we(Lw(), Lw("1rem", "rgba(0,0,0,0.1)"))(t), s = we(`${e}.500`, `${e}.200`)(t), a = `linear-gradient(
    to right,
    transparent 0%,
    ${Sn(n, s)} 50%,
    transparent 100%
  )`;
    return {
      ...!r && i && o,
      ...r ? {
        bgImage: a
      } : {
        bgColor: s
      }
    };
  }, dz = {
    lineHeight: "1",
    fontSize: "0.25em",
    fontWeight: "bold",
    color: "white"
  }, pz = (t) => ({
    bg: we("gray.100", "whiteAlpha.300")(t)
  }), mz = (t) => ({
    transitionProperty: "common",
    transitionDuration: "slow",
    ...hz(t)
  }), gz = vc((t) => ({
    label: dz,
    filledTrack: mz(t),
    track: pz(t)
  })), vz = {
    xs: vc({
      track: {
        h: "1"
      }
    }),
    sm: vc({
      track: {
        h: "2"
      }
    }),
    md: vc({
      track: {
        h: "3"
      }
    }),
    lg: vc({
      track: {
        h: "4"
      }
    })
  }, yz = fz({
    sizes: vz,
    baseStyle: gz,
    defaultProps: {
      size: "md",
      colorScheme: "blue"
    }
  }), { defineMultiStyleConfig: bz, definePartsStyle: ad } = it(bN.keys), xz = (t) => {
    var _a3;
    const e = (_a3 = kn(ip.baseStyle, t)) == null ? void 0 : _a3.control;
    return {
      ...e,
      borderRadius: "full",
      _checked: {
        ...e == null ? void 0 : e._checked,
        _before: {
          content: '""',
          display: "inline-block",
          pos: "relative",
          w: "50%",
          h: "50%",
          borderRadius: "50%",
          bg: "currentColor"
        }
      }
    };
  }, Sz = ad((t) => {
    var _a3, _b3;
    return {
      label: (_a3 = ip.baseStyle) == null ? void 0 : _a3.call(ip, t).label,
      container: (_b3 = ip.baseStyle) == null ? void 0 : _b3.call(ip, t).container,
      control: xz(t)
    };
  }), wz = {
    md: ad({
      control: {
        w: "4",
        h: "4"
      },
      label: {
        fontSize: "md"
      }
    }),
    lg: ad({
      control: {
        w: "5",
        h: "5"
      },
      label: {
        fontSize: "lg"
      }
    }),
    sm: ad({
      control: {
        width: "3",
        height: "3"
      },
      label: {
        fontSize: "sm"
      }
    })
  }, kz = bz({
    baseStyle: Sz,
    sizes: wz,
    defaultProps: {
      size: "md",
      colorScheme: "blue"
    }
  }), { defineMultiStyleConfig: Cz, definePartsStyle: Tz } = it(xN.keys), ch = ke("select-bg"), Mz = {
    ...(_c2 = qe.baseStyle) == null ? void 0 : _c2.field,
    appearance: "none",
    paddingBottom: "1px",
    lineHeight: "normal",
    bg: ch.reference,
    [ch.variable]: "colors.white",
    _dark: {
      [ch.variable]: "colors.gray.700"
    },
    "> option, > optgroup": {
      bg: ch.reference
    }
  }, Az = {
    width: "6",
    height: "100%",
    insetEnd: "2",
    position: "relative",
    color: "currentColor",
    fontSize: "xl",
    _disabled: {
      opacity: 0.5
    }
  }, Ez = Tz({
    field: Mz,
    icon: Az
  }), uh = {
    paddingInlineEnd: "8"
  }, Pz = {
    lg: {
      ...(_d2 = qe.sizes) == null ? void 0 : _d2.lg,
      field: {
        ...(_e = qe.sizes) == null ? void 0 : _e.lg.field,
        ...uh
      }
    },
    md: {
      ...(_f = qe.sizes) == null ? void 0 : _f.md,
      field: {
        ...(_g2 = qe.sizes) == null ? void 0 : _g2.md.field,
        ...uh
      }
    },
    sm: {
      ...(_h2 = qe.sizes) == null ? void 0 : _h2.sm,
      field: {
        ...(_i = qe.sizes) == null ? void 0 : _i.sm.field,
        ...uh
      }
    },
    xs: {
      ...(_j2 = qe.sizes) == null ? void 0 : _j2.xs,
      field: {
        ...(_k2 = qe.sizes) == null ? void 0 : _k2.xs.field,
        ...uh
      },
      icon: {
        insetEnd: "1"
      }
    }
  }, Oz = Cz({
    baseStyle: Ez,
    sizes: Pz,
    variants: qe.variants,
    defaultProps: qe.defaultProps
  }), l0 = ke("skeleton-start-color"), c0 = ke("skeleton-end-color"), Rz = {
    [l0.variable]: "colors.gray.100",
    [c0.variable]: "colors.gray.400",
    _dark: {
      [l0.variable]: "colors.gray.800",
      [c0.variable]: "colors.gray.600"
    },
    background: l0.reference,
    borderColor: c0.reference,
    opacity: 0.7,
    borderRadius: "sm"
  }, Lz = {
    baseStyle: Rz
  }, u0 = ke("skip-link-bg"), _z = {
    borderRadius: "md",
    fontWeight: "semibold",
    _focusVisible: {
      boxShadow: "outline",
      padding: "4",
      position: "fixed",
      top: "6",
      insetStart: "6",
      [u0.variable]: "colors.white",
      _dark: {
        [u0.variable]: "colors.gray.700"
      },
      bg: u0.reference
    }
  }, Dz = {
    baseStyle: _z
  }, { defineMultiStyleConfig: Iz, definePartsStyle: um } = it(SN.keys), js = ke("slider-thumb-size"), wu = ke("slider-track-size"), To = ke("slider-bg"), Bz = (t) => {
    const { orientation: e } = t;
    return {
      display: "inline-block",
      position: "relative",
      cursor: "pointer",
      _disabled: {
        opacity: 0.6,
        cursor: "default",
        pointerEvents: "none"
      },
      ...Lb({
        orientation: e,
        vertical: {
          h: "100%",
          px: $i(js.reference).divide(2).toString()
        },
        horizontal: {
          w: "100%",
          py: $i(js.reference).divide(2).toString()
        }
      })
    };
  }, Nz = (t) => ({
    ...Lb({
      orientation: t.orientation,
      horizontal: {
        h: wu.reference
      },
      vertical: {
        w: wu.reference
      }
    }),
    overflow: "hidden",
    borderRadius: "sm",
    [To.variable]: "colors.gray.200",
    _dark: {
      [To.variable]: "colors.whiteAlpha.200"
    },
    _disabled: {
      [To.variable]: "colors.gray.300",
      _dark: {
        [To.variable]: "colors.whiteAlpha.300"
      }
    },
    bg: To.reference
  }), $z = (t) => {
    const { orientation: e } = t;
    return {
      ...Lb({
        orientation: e,
        vertical: {
          left: "50%"
        },
        horizontal: {
          top: "50%"
        }
      }),
      w: js.reference,
      h: js.reference,
      display: "flex",
      alignItems: "center",
      justifyContent: "center",
      position: "absolute",
      outline: 0,
      zIndex: 1,
      borderRadius: "full",
      bg: "white",
      boxShadow: "base",
      border: "1px solid",
      borderColor: "transparent",
      transitionProperty: "transform",
      transitionDuration: "normal",
      _focusVisible: {
        boxShadow: "outline"
      },
      _active: {
        "--slider-thumb-scale": "1.15"
      },
      _disabled: {
        bg: "gray.300"
      }
    };
  }, zz = (t) => {
    const { colorScheme: e } = t;
    return {
      width: "inherit",
      height: "inherit",
      [To.variable]: `colors.${e}.500`,
      _dark: {
        [To.variable]: `colors.${e}.200`
      },
      bg: To.reference
    };
  }, Fz = um((t) => ({
    container: Bz(t),
    track: Nz(t),
    thumb: $z(t),
    filledTrack: zz(t)
  })), Vz = um({
    container: {
      [js.variable]: "sizes.4",
      [wu.variable]: "sizes.1"
    }
  }), Hz = um({
    container: {
      [js.variable]: "sizes.3.5",
      [wu.variable]: "sizes.1"
    }
  }), jz = um({
    container: {
      [js.variable]: "sizes.2.5",
      [wu.variable]: "sizes.0.5"
    }
  }), Wz = {
    lg: Vz,
    md: Hz,
    sm: jz
  }, Uz = Iz({
    baseStyle: Fz,
    sizes: Wz,
    defaultProps: {
      size: "md",
      colorScheme: "blue"
    }
  }), Ss = Nt("spinner-size"), Kz = {
    width: [
      Ss.reference
    ],
    height: [
      Ss.reference
    ]
  }, qz = {
    xs: {
      [Ss.variable]: "sizes.3"
    },
    sm: {
      [Ss.variable]: "sizes.4"
    },
    md: {
      [Ss.variable]: "sizes.6"
    },
    lg: {
      [Ss.variable]: "sizes.8"
    },
    xl: {
      [Ss.variable]: "sizes.12"
    }
  }, Gz = {
    baseStyle: Kz,
    sizes: qz,
    defaultProps: {
      size: "md"
    }
  }, { defineMultiStyleConfig: Yz, definePartsStyle: zA } = it(wN.keys), Xz = {
    fontWeight: "medium"
  }, Qz = {
    opacity: 0.8,
    marginBottom: "2"
  }, Jz = {
    verticalAlign: "baseline",
    fontWeight: "semibold"
  }, Zz = {
    marginEnd: 1,
    w: "3.5",
    h: "3.5",
    verticalAlign: "middle"
  }, e4 = zA({
    container: {},
    label: Xz,
    helpText: Qz,
    number: Jz,
    icon: Zz
  }), t4 = {
    md: zA({
      label: {
        fontSize: "sm"
      },
      helpText: {
        fontSize: "sm"
      },
      number: {
        fontSize: "2xl"
      }
    })
  }, n4 = Yz({
    baseStyle: e4,
    sizes: t4,
    defaultProps: {
      size: "md"
    }
  }), { defineMultiStyleConfig: r4, definePartsStyle: yc } = it([
    "stepper",
    "step",
    "title",
    "description",
    "indicator",
    "separator",
    "icon",
    "number"
  ]), Fi = ke("stepper-indicator-size"), Pa = ke("stepper-icon-size"), Oa = ke("stepper-title-font-size"), bc = ke("stepper-description-font-size"), ec = ke("stepper-accent-color"), i4 = yc(({ colorScheme: t }) => ({
    stepper: {
      display: "flex",
      justifyContent: "space-between",
      gap: "4",
      "&[data-orientation=vertical]": {
        flexDirection: "column",
        alignItems: "flex-start"
      },
      "&[data-orientation=horizontal]": {
        flexDirection: "row",
        alignItems: "center"
      },
      [ec.variable]: `colors.${t}.500`,
      _dark: {
        [ec.variable]: `colors.${t}.200`
      }
    },
    title: {
      fontSize: Oa.reference,
      fontWeight: "medium"
    },
    description: {
      fontSize: bc.reference,
      color: "chakra-subtle-text"
    },
    number: {
      fontSize: Oa.reference
    },
    step: {
      flexShrink: 0,
      position: "relative",
      display: "flex",
      gap: "2",
      "&[data-orientation=horizontal]": {
        alignItems: "center"
      },
      flex: "1",
      "&:last-of-type:not([data-stretch])": {
        flex: "initial"
      }
    },
    icon: {
      flexShrink: 0,
      width: Pa.reference,
      height: Pa.reference
    },
    indicator: {
      flexShrink: 0,
      borderRadius: "full",
      width: Fi.reference,
      height: Fi.reference,
      display: "flex",
      justifyContent: "center",
      alignItems: "center",
      "&[data-status=active]": {
        borderWidth: "2px",
        borderColor: ec.reference
      },
      "&[data-status=complete]": {
        bg: ec.reference,
        color: "chakra-inverse-text"
      },
      "&[data-status=incomplete]": {
        borderWidth: "2px"
      }
    },
    separator: {
      bg: "chakra-border-color",
      flex: "1",
      "&[data-status=complete]": {
        bg: ec.reference
      },
      "&[data-orientation=horizontal]": {
        width: "100%",
        height: "2px",
        marginStart: "2"
      },
      "&[data-orientation=vertical]": {
        width: "2px",
        position: "absolute",
        height: "100%",
        maxHeight: `calc(100% - ${Fi.reference} - 8px)`,
        top: `calc(${Fi.reference} + 4px)`,
        insetStart: `calc(${Fi.reference} / 2 - 1px)`
      }
    }
  })), o4 = r4({
    baseStyle: i4,
    sizes: {
      xs: yc({
        stepper: {
          [Fi.variable]: "sizes.4",
          [Pa.variable]: "sizes.3",
          [Oa.variable]: "fontSizes.xs",
          [bc.variable]: "fontSizes.xs"
        }
      }),
      sm: yc({
        stepper: {
          [Fi.variable]: "sizes.6",
          [Pa.variable]: "sizes.4",
          [Oa.variable]: "fontSizes.sm",
          [bc.variable]: "fontSizes.xs"
        }
      }),
      md: yc({
        stepper: {
          [Fi.variable]: "sizes.8",
          [Pa.variable]: "sizes.5",
          [Oa.variable]: "fontSizes.md",
          [bc.variable]: "fontSizes.sm"
        }
      }),
      lg: yc({
        stepper: {
          [Fi.variable]: "sizes.10",
          [Pa.variable]: "sizes.6",
          [Oa.variable]: "fontSizes.lg",
          [bc.variable]: "fontSizes.md"
        }
      })
    },
    defaultProps: {
      size: "md",
      colorScheme: "blue"
    }
  }), { defineMultiStyleConfig: s4, definePartsStyle: ld } = it(kN.keys), Fc = Nt("switch-track-width"), Ds = Nt("switch-track-height"), f0 = Nt("switch-track-diff"), a4 = zi.subtract(Fc, Ds), uy = Nt("switch-thumb-x"), tc = Nt("switch-bg"), l4 = (t) => {
    const { colorScheme: e } = t;
    return {
      borderRadius: "full",
      p: "0.5",
      width: [
        Fc.reference
      ],
      height: [
        Ds.reference
      ],
      transitionProperty: "common",
      transitionDuration: "fast",
      [tc.variable]: "colors.gray.300",
      _dark: {
        [tc.variable]: "colors.whiteAlpha.400"
      },
      _focusVisible: {
        boxShadow: "outline"
      },
      _disabled: {
        opacity: 0.4,
        cursor: "not-allowed"
      },
      _checked: {
        [tc.variable]: `colors.${e}.500`,
        _dark: {
          [tc.variable]: `colors.${e}.200`
        }
      },
      bg: tc.reference
    };
  }, c4 = {
    bg: "white",
    transitionProperty: "transform",
    transitionDuration: "normal",
    borderRadius: "inherit",
    width: [
      Ds.reference
    ],
    height: [
      Ds.reference
    ],
    _checked: {
      transform: `translateX(${uy.reference})`
    }
  }, u4 = ld((t) => ({
    container: {
      [f0.variable]: a4,
      [uy.variable]: f0.reference,
      _rtl: {
        [uy.variable]: zi(f0).negate().toString()
      }
    },
    track: l4(t),
    thumb: c4
  })), f4 = {
    sm: ld({
      container: {
        [Fc.variable]: "1.375rem",
        [Ds.variable]: "sizes.3"
      }
    }),
    md: ld({
      container: {
        [Fc.variable]: "1.875rem",
        [Ds.variable]: "sizes.4"
      }
    }),
    lg: ld({
      container: {
        [Fc.variable]: "2.875rem",
        [Ds.variable]: "sizes.6"
      }
    })
  }, h4 = s4({
    baseStyle: u4,
    sizes: f4,
    defaultProps: {
      size: "md",
      colorScheme: "blue"
    }
  }), { defineMultiStyleConfig: d4, definePartsStyle: Ua } = it(CN.keys), p4 = Ua({
    table: {
      fontVariantNumeric: "lining-nums tabular-nums",
      borderCollapse: "collapse",
      width: "full"
    },
    th: {
      fontFamily: "heading",
      fontWeight: "bold",
      textTransform: "uppercase",
      letterSpacing: "wider",
      textAlign: "start"
    },
    td: {
      textAlign: "start"
    },
    caption: {
      mt: 4,
      fontFamily: "heading",
      textAlign: "center",
      fontWeight: "medium"
    }
  }), op = {
    "&[data-is-numeric=true]": {
      textAlign: "end"
    }
  }, m4 = Ua((t) => {
    const { colorScheme: e } = t;
    return {
      th: {
        color: we("gray.600", "gray.400")(t),
        borderBottom: "1px",
        borderColor: we(`${e}.100`, `${e}.700`)(t),
        ...op
      },
      td: {
        borderBottom: "1px",
        borderColor: we(`${e}.100`, `${e}.700`)(t),
        ...op
      },
      caption: {
        color: we("gray.600", "gray.100")(t)
      },
      tfoot: {
        tr: {
          "&:last-of-type": {
            th: {
              borderBottomWidth: 0
            }
          }
        }
      }
    };
  }), g4 = Ua((t) => {
    const { colorScheme: e } = t;
    return {
      th: {
        color: we("gray.600", "gray.400")(t),
        borderBottom: "1px",
        borderColor: we(`${e}.100`, `${e}.700`)(t),
        ...op
      },
      td: {
        borderBottom: "1px",
        borderColor: we(`${e}.100`, `${e}.700`)(t),
        ...op
      },
      caption: {
        color: we("gray.600", "gray.100")(t)
      },
      tbody: {
        tr: {
          "&:nth-of-type(odd)": {
            "th, td": {
              borderBottomWidth: "1px",
              borderColor: we(`${e}.100`, `${e}.700`)(t)
            },
            td: {
              background: we(`${e}.100`, `${e}.700`)(t)
            }
          }
        }
      },
      tfoot: {
        tr: {
          "&:last-of-type": {
            th: {
              borderBottomWidth: 0
            }
          }
        }
      }
    };
  }), v4 = {
    simple: m4,
    striped: g4,
    unstyled: {}
  }, y4 = {
    sm: Ua({
      th: {
        px: "4",
        py: "1",
        lineHeight: "4",
        fontSize: "xs"
      },
      td: {
        px: "4",
        py: "2",
        fontSize: "sm",
        lineHeight: "4"
      },
      caption: {
        px: "4",
        py: "2",
        fontSize: "xs"
      }
    }),
    md: Ua({
      th: {
        px: "6",
        py: "3",
        lineHeight: "4",
        fontSize: "xs"
      },
      td: {
        px: "6",
        py: "4",
        lineHeight: "5"
      },
      caption: {
        px: "6",
        py: "2",
        fontSize: "sm"
      }
    }),
    lg: Ua({
      th: {
        px: "8",
        py: "4",
        lineHeight: "5",
        fontSize: "sm"
      },
      td: {
        px: "8",
        py: "5",
        lineHeight: "6"
      },
      caption: {
        px: "6",
        py: "2",
        fontSize: "md"
      }
    })
  }, b4 = d4({
    baseStyle: p4,
    variants: v4,
    sizes: y4,
    defaultProps: {
      variant: "simple",
      size: "md",
      colorScheme: "gray"
    }
  }), Dn = ke("tabs-color"), $r = ke("tabs-bg"), fh = ke("tabs-border-color"), { defineMultiStyleConfig: x4, definePartsStyle: wi } = it(TN.keys), S4 = (t) => {
    const { orientation: e } = t;
    return {
      display: e === "vertical" ? "flex" : "block"
    };
  }, w4 = (t) => {
    const { isFitted: e } = t;
    return {
      flex: e ? 1 : void 0,
      transitionProperty: "common",
      transitionDuration: "normal",
      _focusVisible: {
        zIndex: 1,
        boxShadow: "outline"
      },
      _disabled: {
        cursor: "not-allowed",
        opacity: 0.4
      }
    };
  }, k4 = (t) => {
    const { align: e = "start", orientation: n } = t;
    return {
      justifyContent: {
        end: "flex-end",
        center: "center",
        start: "flex-start"
      }[e],
      flexDirection: n === "vertical" ? "column" : "row"
    };
  }, C4 = {
    p: 4
  }, T4 = wi((t) => ({
    root: S4(t),
    tab: w4(t),
    tablist: k4(t),
    tabpanel: C4
  })), M4 = {
    sm: wi({
      tab: {
        py: 1,
        px: 4,
        fontSize: "sm"
      }
    }),
    md: wi({
      tab: {
        fontSize: "md",
        py: 2,
        px: 4
      }
    }),
    lg: wi({
      tab: {
        fontSize: "lg",
        py: 3,
        px: 4
      }
    })
  }, A4 = wi((t) => {
    const { colorScheme: e, orientation: n } = t, r = n === "vertical", i = r ? "borderStart" : "borderBottom", o = r ? "marginStart" : "marginBottom";
    return {
      tablist: {
        [i]: "2px solid",
        borderColor: "inherit"
      },
      tab: {
        [i]: "2px solid",
        borderColor: "transparent",
        [o]: "-2px",
        _selected: {
          [Dn.variable]: `colors.${e}.600`,
          _dark: {
            [Dn.variable]: `colors.${e}.300`
          },
          borderColor: "currentColor"
        },
        _active: {
          [$r.variable]: "colors.gray.200",
          _dark: {
            [$r.variable]: "colors.whiteAlpha.300"
          }
        },
        _disabled: {
          _active: {
            bg: "none"
          }
        },
        color: Dn.reference,
        bg: $r.reference
      }
    };
  }), E4 = wi((t) => {
    const { colorScheme: e } = t;
    return {
      tab: {
        borderTopRadius: "md",
        border: "1px solid",
        borderColor: "transparent",
        mb: "-1px",
        [fh.variable]: "transparent",
        _selected: {
          [Dn.variable]: `colors.${e}.600`,
          [fh.variable]: "colors.white",
          _dark: {
            [Dn.variable]: `colors.${e}.300`,
            [fh.variable]: "colors.gray.800"
          },
          borderColor: "inherit",
          borderBottomColor: fh.reference
        },
        color: Dn.reference
      },
      tablist: {
        mb: "-1px",
        borderBottom: "1px solid",
        borderColor: "inherit"
      }
    };
  }), P4 = wi((t) => {
    const { colorScheme: e } = t;
    return {
      tab: {
        border: "1px solid",
        borderColor: "inherit",
        [$r.variable]: "colors.gray.50",
        _dark: {
          [$r.variable]: "colors.whiteAlpha.50"
        },
        mb: "-1px",
        _notLast: {
          marginEnd: "-1px"
        },
        _selected: {
          [$r.variable]: "colors.white",
          [Dn.variable]: `colors.${e}.600`,
          _dark: {
            [$r.variable]: "colors.gray.800",
            [Dn.variable]: `colors.${e}.300`
          },
          borderColor: "inherit",
          borderTopColor: "currentColor",
          borderBottomColor: "transparent"
        },
        color: Dn.reference,
        bg: $r.reference
      },
      tablist: {
        mb: "-1px",
        borderBottom: "1px solid",
        borderColor: "inherit"
      }
    };
  }), O4 = wi((t) => {
    const { colorScheme: e, theme: n } = t;
    return {
      tab: {
        borderRadius: "full",
        fontWeight: "semibold",
        color: "gray.600",
        _selected: {
          color: Sn(n, `${e}.700`),
          bg: Sn(n, `${e}.100`)
        }
      }
    };
  }), R4 = wi((t) => {
    const { colorScheme: e } = t;
    return {
      tab: {
        borderRadius: "full",
        fontWeight: "semibold",
        [Dn.variable]: "colors.gray.600",
        _dark: {
          [Dn.variable]: "inherit"
        },
        _selected: {
          [Dn.variable]: "colors.white",
          [$r.variable]: `colors.${e}.600`,
          _dark: {
            [Dn.variable]: "colors.gray.800",
            [$r.variable]: `colors.${e}.300`
          }
        },
        color: Dn.reference,
        bg: $r.reference
      }
    };
  }), L4 = wi({}), _4 = {
    line: A4,
    enclosed: E4,
    "enclosed-colored": P4,
    "soft-rounded": O4,
    "solid-rounded": R4,
    unstyled: L4
  }, D4 = x4({
    baseStyle: T4,
    sizes: M4,
    variants: _4,
    defaultProps: {
      size: "md",
      variant: "line",
      colorScheme: "blue"
    }
  }), { defineMultiStyleConfig: I4, definePartsStyle: Is } = it(MN.keys), $w = ke("tag-bg"), zw = ke("tag-color"), h0 = ke("tag-shadow"), cd = ke("tag-min-height"), ud = ke("tag-min-width"), fd = ke("tag-font-size"), hd = ke("tag-padding-inline"), B4 = {
    fontWeight: "medium",
    lineHeight: 1.2,
    outline: 0,
    [zw.variable]: At.color.reference,
    [$w.variable]: At.bg.reference,
    [h0.variable]: At.shadow.reference,
    color: zw.reference,
    bg: $w.reference,
    boxShadow: h0.reference,
    borderRadius: "md",
    minH: cd.reference,
    minW: ud.reference,
    fontSize: fd.reference,
    px: hd.reference,
    _focusVisible: {
      [h0.variable]: "shadows.outline"
    }
  }, N4 = {
    lineHeight: 1.2,
    overflow: "visible"
  }, $4 = {
    fontSize: "lg",
    w: "5",
    h: "5",
    transitionProperty: "common",
    transitionDuration: "normal",
    borderRadius: "full",
    marginStart: "1.5",
    marginEnd: "-1",
    opacity: 0.5,
    _disabled: {
      opacity: 0.4
    },
    _focusVisible: {
      boxShadow: "outline",
      bg: "rgba(0, 0, 0, 0.14)"
    },
    _hover: {
      opacity: 0.8
    },
    _active: {
      opacity: 1
    }
  }, z4 = Is({
    container: B4,
    label: N4,
    closeButton: $4
  }), F4 = {
    sm: Is({
      container: {
        [cd.variable]: "sizes.5",
        [ud.variable]: "sizes.5",
        [fd.variable]: "fontSizes.xs",
        [hd.variable]: "space.2"
      },
      closeButton: {
        marginEnd: "-2px",
        marginStart: "0.35rem"
      }
    }),
    md: Is({
      container: {
        [cd.variable]: "sizes.6",
        [ud.variable]: "sizes.6",
        [fd.variable]: "fontSizes.sm",
        [hd.variable]: "space.2"
      }
    }),
    lg: Is({
      container: {
        [cd.variable]: "sizes.8",
        [ud.variable]: "sizes.8",
        [fd.variable]: "fontSizes.md",
        [hd.variable]: "space.3"
      }
    })
  }, V4 = {
    subtle: Is((t) => {
      var _a3;
      return {
        container: (_a3 = Nc.variants) == null ? void 0 : _a3.subtle(t)
      };
    }),
    solid: Is((t) => {
      var _a3;
      return {
        container: (_a3 = Nc.variants) == null ? void 0 : _a3.solid(t)
      };
    }),
    outline: Is((t) => {
      var _a3;
      return {
        container: (_a3 = Nc.variants) == null ? void 0 : _a3.outline(t)
      };
    })
  }, H4 = I4({
    variants: V4,
    baseStyle: z4,
    sizes: F4,
    defaultProps: {
      size: "md",
      variant: "subtle",
      colorScheme: "gray"
    }
  }), j4 = {
    ...(_l = qe.baseStyle) == null ? void 0 : _l.field,
    paddingY: "2",
    minHeight: "20",
    lineHeight: "short",
    verticalAlign: "top"
  }, W4 = {
    outline: (t) => {
      var _a3;
      return ((_a3 = qe.variants) == null ? void 0 : _a3.outline(t).field) ?? {};
    },
    flushed: (t) => {
      var _a3;
      return ((_a3 = qe.variants) == null ? void 0 : _a3.flushed(t).field) ?? {};
    },
    filled: (t) => {
      var _a3;
      return ((_a3 = qe.variants) == null ? void 0 : _a3.filled(t).field) ?? {};
    },
    unstyled: ((_m2 = qe.variants) == null ? void 0 : _m2.unstyled.field) ?? {}
  }, U4 = {
    xs: ((_n2 = qe.sizes) == null ? void 0 : _n2.xs.field) ?? {},
    sm: ((_o2 = qe.sizes) == null ? void 0 : _o2.sm.field) ?? {},
    md: ((_p2 = qe.sizes) == null ? void 0 : _p2.md.field) ?? {},
    lg: ((_q2 = qe.sizes) == null ? void 0 : _q2.lg.field) ?? {}
  }, K4 = {
    baseStyle: j4,
    sizes: U4,
    variants: W4,
    defaultProps: {
      size: "md",
      variant: "outline"
    }
  }, hh = Nt("tooltip-bg"), d0 = Nt("tooltip-fg"), q4 = Nt("popper-arrow-bg"), G4 = {
    bg: hh.reference,
    color: d0.reference,
    [hh.variable]: "colors.gray.700",
    [d0.variable]: "colors.whiteAlpha.900",
    _dark: {
      [hh.variable]: "colors.gray.300",
      [d0.variable]: "colors.gray.900"
    },
    [q4.variable]: hh.reference,
    px: "2",
    py: "0.5",
    borderRadius: "sm",
    fontWeight: "medium",
    fontSize: "sm",
    boxShadow: "md",
    maxW: "xs",
    zIndex: "tooltip"
  }, Y4 = {
    baseStyle: G4
  }, X4 = {
    Accordion: IN,
    Alert: y5,
    Avatar: P5,
    Badge: Nc,
    Breadcrumb: z5,
    Button: G5,
    Checkbox: ip,
    CloseButton: c$,
    Code: d$,
    Container: m$,
    Divider: x$,
    Drawer: R$,
    Editable: $$,
    Form: W$,
    FormError: X$,
    FormLabel: J$,
    Heading: t3,
    Input: qe,
    Kbd: f3,
    Link: d3,
    List: y3,
    Menu: P3,
    Modal: F3,
    NumberInput: Y3,
    PinInput: Z3,
    Popover: uz,
    Progress: yz,
    Radio: kz,
    Select: Oz,
    Skeleton: Lz,
    SkipLink: Dz,
    Slider: Uz,
    Spinner: Gz,
    Stat: n4,
    Switch: h4,
    Table: b4,
    Tabs: D4,
    Tag: H4,
    Textarea: K4,
    Tooltip: Y4,
    Card: Z5,
    Stepper: o4
  }, Q4 = {
    none: 0,
    "1px": "1px solid",
    "2px": "2px solid",
    "4px": "4px solid",
    "8px": "8px solid"
  }, J4 = {
    base: "0em",
    sm: "30em",
    md: "48em",
    lg: "62em",
    xl: "80em",
    "2xl": "96em"
  }, Z4 = {
    transparent: "transparent",
    current: "currentColor",
    black: "#000000",
    white: "#FFFFFF",
    whiteAlpha: {
      50: "rgba(255, 255, 255, 0.04)",
      100: "rgba(255, 255, 255, 0.06)",
      200: "rgba(255, 255, 255, 0.08)",
      300: "rgba(255, 255, 255, 0.16)",
      400: "rgba(255, 255, 255, 0.24)",
      500: "rgba(255, 255, 255, 0.36)",
      600: "rgba(255, 255, 255, 0.48)",
      700: "rgba(255, 255, 255, 0.64)",
      800: "rgba(255, 255, 255, 0.80)",
      900: "rgba(255, 255, 255, 0.92)"
    },
    blackAlpha: {
      50: "rgba(0, 0, 0, 0.04)",
      100: "rgba(0, 0, 0, 0.06)",
      200: "rgba(0, 0, 0, 0.08)",
      300: "rgba(0, 0, 0, 0.16)",
      400: "rgba(0, 0, 0, 0.24)",
      500: "rgba(0, 0, 0, 0.36)",
      600: "rgba(0, 0, 0, 0.48)",
      700: "rgba(0, 0, 0, 0.64)",
      800: "rgba(0, 0, 0, 0.80)",
      900: "rgba(0, 0, 0, 0.92)"
    },
    gray: {
      50: "#F7FAFC",
      100: "#EDF2F7",
      200: "#E2E8F0",
      300: "#CBD5E0",
      400: "#A0AEC0",
      500: "#718096",
      600: "#4A5568",
      700: "#2D3748",
      800: "#1A202C",
      900: "#171923"
    },
    red: {
      50: "#FFF5F5",
      100: "#FED7D7",
      200: "#FEB2B2",
      300: "#FC8181",
      400: "#F56565",
      500: "#E53E3E",
      600: "#C53030",
      700: "#9B2C2C",
      800: "#822727",
      900: "#63171B"
    },
    orange: {
      50: "#FFFAF0",
      100: "#FEEBC8",
      200: "#FBD38D",
      300: "#F6AD55",
      400: "#ED8936",
      500: "#DD6B20",
      600: "#C05621",
      700: "#9C4221",
      800: "#7B341E",
      900: "#652B19"
    },
    yellow: {
      50: "#FFFFF0",
      100: "#FEFCBF",
      200: "#FAF089",
      300: "#F6E05E",
      400: "#ECC94B",
      500: "#D69E2E",
      600: "#B7791F",
      700: "#975A16",
      800: "#744210",
      900: "#5F370E"
    },
    green: {
      50: "#F0FFF4",
      100: "#C6F6D5",
      200: "#9AE6B4",
      300: "#68D391",
      400: "#48BB78",
      500: "#38A169",
      600: "#2F855A",
      700: "#276749",
      800: "#22543D",
      900: "#1C4532"
    },
    teal: {
      50: "#E6FFFA",
      100: "#B2F5EA",
      200: "#81E6D9",
      300: "#4FD1C5",
      400: "#38B2AC",
      500: "#319795",
      600: "#2C7A7B",
      700: "#285E61",
      800: "#234E52",
      900: "#1D4044"
    },
    blue: {
      50: "#ebf8ff",
      100: "#bee3f8",
      200: "#90cdf4",
      300: "#63b3ed",
      400: "#4299e1",
      500: "#3182ce",
      600: "#2b6cb0",
      700: "#2c5282",
      800: "#2a4365",
      900: "#1A365D"
    },
    cyan: {
      50: "#EDFDFD",
      100: "#C4F1F9",
      200: "#9DECF9",
      300: "#76E4F7",
      400: "#0BC5EA",
      500: "#00B5D8",
      600: "#00A3C4",
      700: "#0987A0",
      800: "#086F83",
      900: "#065666"
    },
    purple: {
      50: "#FAF5FF",
      100: "#E9D8FD",
      200: "#D6BCFA",
      300: "#B794F4",
      400: "#9F7AEA",
      500: "#805AD5",
      600: "#6B46C1",
      700: "#553C9A",
      800: "#44337A",
      900: "#322659"
    },
    pink: {
      50: "#FFF5F7",
      100: "#FED7E2",
      200: "#FBB6CE",
      300: "#F687B3",
      400: "#ED64A6",
      500: "#D53F8C",
      600: "#B83280",
      700: "#97266D",
      800: "#702459",
      900: "#521B41"
    }
  }, eF = {
    none: "0",
    sm: "0.125rem",
    base: "0.25rem",
    md: "0.375rem",
    lg: "0.5rem",
    xl: "0.75rem",
    "2xl": "1rem",
    "3xl": "1.5rem",
    full: "9999px"
  }, tF = {
    xs: "0 0 0 1px rgba(0, 0, 0, 0.05)",
    sm: "0 1px 2px 0 rgba(0, 0, 0, 0.05)",
    base: "0 1px 3px 0 rgba(0, 0, 0, 0.1), 0 1px 2px 0 rgba(0, 0, 0, 0.06)",
    md: "0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06)",
    lg: "0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05)",
    xl: "0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04)",
    "2xl": "0 25px 50px -12px rgba(0, 0, 0, 0.25)",
    outline: "0 0 0 3px rgba(66, 153, 225, 0.6)",
    inner: "inset 0 2px 4px 0 rgba(0,0,0,0.06)",
    none: "none",
    "dark-lg": "rgba(0, 0, 0, 0.1) 0px 0px 0px 1px, rgba(0, 0, 0, 0.2) 0px 5px 10px, rgba(0, 0, 0, 0.4) 0px 15px 40px"
  }, nF = {
    common: "background-color, border-color, color, fill, stroke, opacity, box-shadow, transform",
    colors: "background-color, border-color, color, fill, stroke",
    dimensions: "width, height",
    position: "left, right, top, bottom",
    background: "background-color, background-image, background-position"
  }, rF = {
    "ease-in": "cubic-bezier(0.4, 0, 1, 1)",
    "ease-out": "cubic-bezier(0, 0, 0.2, 1)",
    "ease-in-out": "cubic-bezier(0.4, 0, 0.2, 1)"
  }, iF = {
    "ultra-fast": "50ms",
    faster: "100ms",
    fast: "150ms",
    normal: "200ms",
    slow: "300ms",
    slower: "400ms",
    "ultra-slow": "500ms"
  }, oF = {
    property: nF,
    easing: rF,
    duration: iF
  }, sF = {
    hide: -1,
    auto: "auto",
    base: 0,
    docked: 10,
    dropdown: 1e3,
    sticky: 1100,
    banner: 1200,
    overlay: 1300,
    modal: 1400,
    popover: 1500,
    skipLink: 1600,
    toast: 1700,
    tooltip: 1800
  }, aF = {
    none: 0,
    sm: "4px",
    base: "8px",
    md: "12px",
    lg: "16px",
    xl: "24px",
    "2xl": "40px",
    "3xl": "64px"
  }, FA = {
    breakpoints: J4,
    zIndices: sF,
    radii: eF,
    blur: aF,
    colors: Z4,
    ...BA,
    sizes: OA,
    shadows: tF,
    space: PA,
    borders: Q4,
    transition: oF
  }, VA = {
    colors: {
      "chakra-body-text": {
        _light: "gray.800",
        _dark: "whiteAlpha.900"
      },
      "chakra-body-bg": {
        _light: "white",
        _dark: "gray.800"
      },
      "chakra-border-color": {
        _light: "gray.200",
        _dark: "whiteAlpha.300"
      },
      "chakra-inverse-text": {
        _light: "white",
        _dark: "gray.800"
      },
      "chakra-subtle-bg": {
        _light: "gray.100",
        _dark: "gray.700"
      },
      "chakra-subtle-text": {
        _light: "gray.600",
        _dark: "gray.400"
      },
      "chakra-placeholder-color": {
        _light: "gray.500",
        _dark: "whiteAlpha.400"
      }
    }
  }, HA = {
    global: {
      body: {
        fontFamily: "body",
        color: "chakra-body-text",
        bg: "chakra-body-bg",
        transitionProperty: "background-color",
        transitionDuration: "normal",
        lineHeight: "base"
      },
      "*::placeholder": {
        color: "chakra-placeholder-color"
      },
      "*, *::before, &::after": {
        borderColor: "chakra-border-color"
      }
    }
  }, jA = "ltr", WA = {
    useSystemColorMode: false,
    initialColorMode: "light",
    cssVarPrefix: "chakra"
  }, lF = {
    semanticTokens: VA,
    direction: jA,
    ...FA,
    components: X4,
    styles: HA,
    config: WA
  };
  ({
    ...FA
  });
  var fm = {
    exports: {}
  }, hm = {};
  var cF = z.exports, uF = Symbol.for("react.element"), fF = Symbol.for("react.fragment"), hF = Object.prototype.hasOwnProperty, dF = cF.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, pF = {
    key: true,
    ref: true,
    __self: true,
    __source: true
  };
  function UA(t, e, n) {
    var r, i = {}, o = null, s = null;
    n !== void 0 && (o = "" + n), e.key !== void 0 && (o = "" + e.key), e.ref !== void 0 && (s = e.ref);
    for (r in e)
      hF.call(e, r) && !pF.hasOwnProperty(r) && (i[r] = e[r]);
    if (t && t.defaultProps)
      for (r in e = t.defaultProps, e)
        i[r] === void 0 && (i[r] = e[r]);
    return {
      $$typeof: uF,
      type: t,
      key: o,
      ref: s,
      props: i,
      _owner: dF.current
    };
  }
  hm.Fragment = fF;
  hm.jsx = UA;
  hm.jsxs = UA;
  (function(t) {
    t.exports = hm;
  })(fm);
  const sp = fm.exports.Fragment, J = fm.exports.jsx, Xn = fm.exports.jsxs;
  var mF = false;
  function gF(t) {
    if (t.sheet)
      return t.sheet;
    for (var e = 0; e < document.styleSheets.length; e++)
      if (document.styleSheets[e].ownerNode === t)
        return document.styleSheets[e];
  }
  function vF(t) {
    var e = document.createElement("style");
    return e.setAttribute("data-emotion", t.key), t.nonce !== void 0 && e.setAttribute("nonce", t.nonce), e.appendChild(document.createTextNode("")), e.setAttribute("data-s", ""), e;
  }
  var yF = function() {
    function t(n) {
      var r = this;
      this._insertTag = function(i) {
        var o;
        r.tags.length === 0 ? r.insertionPoint ? o = r.insertionPoint.nextSibling : r.prepend ? o = r.container.firstChild : o = r.before : o = r.tags[r.tags.length - 1].nextSibling, r.container.insertBefore(i, o), r.tags.push(i);
      }, this.isSpeedy = n.speedy === void 0 ? !mF : n.speedy, this.tags = [], this.ctr = 0, this.nonce = n.nonce, this.key = n.key, this.container = n.container, this.prepend = n.prepend, this.insertionPoint = n.insertionPoint, this.before = null;
    }
    var e = t.prototype;
    return e.hydrate = function(r) {
      r.forEach(this._insertTag);
    }, e.insert = function(r) {
      this.ctr % (this.isSpeedy ? 65e3 : 1) === 0 && this._insertTag(vF(this));
      var i = this.tags[this.tags.length - 1];
      if (this.isSpeedy) {
        var o = gF(i);
        try {
          o.insertRule(r, o.cssRules.length);
        } catch {
        }
      } else
        i.appendChild(document.createTextNode(r));
      this.ctr++;
    }, e.flush = function() {
      this.tags.forEach(function(r) {
        var i;
        return (i = r.parentNode) == null ? void 0 : i.removeChild(r);
      }), this.tags = [], this.ctr = 0;
    }, t;
  }(), ln = "-ms-", ap = "-moz-", Ue = "-webkit-", KA = "comm", Bb = "rule", Nb = "decl", bF = "@import", qA = "@keyframes", xF = "@layer", SF = Math.abs, dm = String.fromCharCode, wF = Object.assign;
  function kF(t, e) {
    return Xt(t, 0) ^ 45 ? (((e << 2 ^ Xt(t, 0)) << 2 ^ Xt(t, 1)) << 2 ^ Xt(t, 2)) << 2 ^ Xt(t, 3) : 0;
  }
  function GA(t) {
    return t.trim();
  }
  function CF(t, e) {
    return (t = e.exec(t)) ? t[0] : t;
  }
  function Ke(t, e, n) {
    return t.replace(e, n);
  }
  function fy(t, e) {
    return t.indexOf(e);
  }
  function Xt(t, e) {
    return t.charCodeAt(e) | 0;
  }
  function ku(t, e, n) {
    return t.slice(e, n);
  }
  function ui(t) {
    return t.length;
  }
  function $b(t) {
    return t.length;
  }
  function dh(t, e) {
    return e.push(t), t;
  }
  function TF(t, e) {
    return t.map(e).join("");
  }
  var pm = 1, cl = 1, YA = 0, Vn = 0, Ot = 0, Ml = "";
  function mm(t, e, n, r, i, o, s) {
    return {
      value: t,
      root: e,
      parent: n,
      type: r,
      props: i,
      children: o,
      line: pm,
      column: cl,
      length: s,
      return: ""
    };
  }
  function nc(t, e) {
    return wF(mm("", null, null, "", null, null, 0), t, {
      length: -t.length
    }, e);
  }
  function MF() {
    return Ot;
  }
  function AF() {
    return Ot = Vn > 0 ? Xt(Ml, --Vn) : 0, cl--, Ot === 10 && (cl = 1, pm--), Ot;
  }
  function Qn() {
    return Ot = Vn < YA ? Xt(Ml, Vn++) : 0, cl++, Ot === 10 && (cl = 1, pm++), Ot;
  }
  function ki() {
    return Xt(Ml, Vn);
  }
  function dd() {
    return Vn;
  }
  function Zu(t, e) {
    return ku(Ml, t, e);
  }
  function Cu(t) {
    switch (t) {
      case 0:
      case 9:
      case 10:
      case 13:
      case 32:
        return 5;
      case 33:
      case 43:
      case 44:
      case 47:
      case 62:
      case 64:
      case 126:
      case 59:
      case 123:
      case 125:
        return 4;
      case 58:
        return 3;
      case 34:
      case 39:
      case 40:
      case 91:
        return 2;
      case 41:
      case 93:
        return 1;
    }
    return 0;
  }
  function XA(t) {
    return pm = cl = 1, YA = ui(Ml = t), Vn = 0, [];
  }
  function QA(t) {
    return Ml = "", t;
  }
  function pd(t) {
    return GA(Zu(Vn - 1, hy(t === 91 ? t + 2 : t === 40 ? t + 1 : t)));
  }
  function EF(t) {
    for (; (Ot = ki()) && Ot < 33; )
      Qn();
    return Cu(t) > 2 || Cu(Ot) > 3 ? "" : " ";
  }
  function PF(t, e) {
    for (; --e && Qn() && !(Ot < 48 || Ot > 102 || Ot > 57 && Ot < 65 || Ot > 70 && Ot < 97); )
      ;
    return Zu(t, dd() + (e < 6 && ki() == 32 && Qn() == 32));
  }
  function hy(t) {
    for (; Qn(); )
      switch (Ot) {
        case t:
          return Vn;
        case 34:
        case 39:
          t !== 34 && t !== 39 && hy(Ot);
          break;
        case 40:
          t === 41 && hy(t);
          break;
        case 92:
          Qn();
          break;
      }
    return Vn;
  }
  function OF(t, e) {
    for (; Qn() && t + Ot !== 47 + 10; )
      if (t + Ot === 42 + 42 && ki() === 47)
        break;
    return "/*" + Zu(e, Vn - 1) + "*" + dm(t === 47 ? t : Qn());
  }
  function RF(t) {
    for (; !Cu(ki()); )
      Qn();
    return Zu(t, Vn);
  }
  function LF(t) {
    return QA(md("", null, null, null, [
      ""
    ], t = XA(t), 0, [
      0
    ], t));
  }
  function md(t, e, n, r, i, o, s, a, l) {
    for (var c = 0, u = 0, h = s, p = 0, v = 0, y = 0, x = 1, T = 1, w = 1, k = 0, C = "", P = i, R = o, L = r, _ = C; T; )
      switch (y = k, k = Qn()) {
        case 40:
          if (y != 108 && Xt(_, h - 1) == 58) {
            fy(_ += Ke(pd(k), "&", "&\f"), "&\f") != -1 && (w = -1);
            break;
          }
        case 34:
        case 39:
        case 91:
          _ += pd(k);
          break;
        case 9:
        case 10:
        case 13:
        case 32:
          _ += EF(y);
          break;
        case 92:
          _ += PF(dd() - 1, 7);
          continue;
        case 47:
          switch (ki()) {
            case 42:
            case 47:
              dh(_F(OF(Qn(), dd()), e, n), l);
              break;
            default:
              _ += "/";
          }
          break;
        case 123 * x:
          a[c++] = ui(_) * w;
        case 125 * x:
        case 59:
        case 0:
          switch (k) {
            case 0:
            case 125:
              T = 0;
            case 59 + u:
              w == -1 && (_ = Ke(_, /\f/g, "")), v > 0 && ui(_) - h && dh(v > 32 ? Vw(_ + ";", r, n, h - 1) : Vw(Ke(_, " ", "") + ";", r, n, h - 2), l);
              break;
            case 59:
              _ += ";";
            default:
              if (dh(L = Fw(_, e, n, c, u, i, a, C, P = [], R = [], h), o), k === 123)
                if (u === 0)
                  md(_, e, L, L, P, o, h, a, R);
                else
                  switch (p === 99 && Xt(_, 3) === 110 ? 100 : p) {
                    case 100:
                    case 108:
                    case 109:
                    case 115:
                      md(t, L, L, r && dh(Fw(t, L, L, 0, 0, i, a, C, i, P = [], h), R), i, R, h, a, r ? P : R);
                      break;
                    default:
                      md(_, L, L, L, [
                        ""
                      ], R, 0, a, R);
                  }
          }
          c = u = v = 0, x = w = 1, C = _ = "", h = s;
          break;
        case 58:
          h = 1 + ui(_), v = y;
        default:
          if (x < 1) {
            if (k == 123)
              --x;
            else if (k == 125 && x++ == 0 && AF() == 125)
              continue;
          }
          switch (_ += dm(k), k * x) {
            case 38:
              w = u > 0 ? 1 : (_ += "\f", -1);
              break;
            case 44:
              a[c++] = (ui(_) - 1) * w, w = 1;
              break;
            case 64:
              ki() === 45 && (_ += pd(Qn())), p = ki(), u = h = ui(C = _ += RF(dd())), k++;
              break;
            case 45:
              y === 45 && ui(_) == 2 && (x = 0);
          }
      }
    return o;
  }
  function Fw(t, e, n, r, i, o, s, a, l, c, u) {
    for (var h = i - 1, p = i === 0 ? o : [
      ""
    ], v = $b(p), y = 0, x = 0, T = 0; y < r; ++y)
      for (var w = 0, k = ku(t, h + 1, h = SF(x = s[y])), C = t; w < v; ++w)
        (C = GA(x > 0 ? p[w] + " " + k : Ke(k, /&\f/g, p[w]))) && (l[T++] = C);
    return mm(t, e, n, i === 0 ? Bb : a, l, c, u);
  }
  function _F(t, e, n) {
    return mm(t, e, n, KA, dm(MF()), ku(t, 2, -2), 0);
  }
  function Vw(t, e, n, r) {
    return mm(t, e, n, Nb, ku(t, 0, r), ku(t, r + 1, -1), r);
  }
  function Ka(t, e) {
    for (var n = "", r = $b(t), i = 0; i < r; i++)
      n += e(t[i], i, t, e) || "";
    return n;
  }
  function DF(t, e, n, r) {
    switch (t.type) {
      case xF:
        if (t.children.length)
          break;
      case bF:
      case Nb:
        return t.return = t.return || t.value;
      case KA:
        return "";
      case qA:
        return t.return = t.value + "{" + Ka(t.children, r) + "}";
      case Bb:
        t.value = t.props.join(",");
    }
    return ui(n = Ka(t.children, r)) ? t.return = t.value + "{" + n + "}" : "";
  }
  function IF(t) {
    var e = $b(t);
    return function(n, r, i, o) {
      for (var s = "", a = 0; a < e; a++)
        s += t[a](n, r, i, o) || "";
      return s;
    };
  }
  function BF(t) {
    return function(e) {
      e.root || (e = e.return) && t(e);
    };
  }
  var Hw = function(e) {
    var n = /* @__PURE__ */ new WeakMap();
    return function(r) {
      if (n.has(r))
        return n.get(r);
      var i = e(r);
      return n.set(r, i), i;
    };
  };
  function JA(t) {
    var e = /* @__PURE__ */ Object.create(null);
    return function(n) {
      return e[n] === void 0 && (e[n] = t(n)), e[n];
    };
  }
  var NF = function(e, n, r) {
    for (var i = 0, o = 0; i = o, o = ki(), i === 38 && o === 12 && (n[r] = 1), !Cu(o); )
      Qn();
    return Zu(e, Vn);
  }, $F = function(e, n) {
    var r = -1, i = 44;
    do
      switch (Cu(i)) {
        case 0:
          i === 38 && ki() === 12 && (n[r] = 1), e[r] += NF(Vn - 1, n, r);
          break;
        case 2:
          e[r] += pd(i);
          break;
        case 4:
          if (i === 44) {
            e[++r] = ki() === 58 ? "&\f" : "", n[r] = e[r].length;
            break;
          }
        default:
          e[r] += dm(i);
      }
    while (i = Qn());
    return e;
  }, zF = function(e, n) {
    return QA($F(XA(e), n));
  }, jw = /* @__PURE__ */ new WeakMap(), FF = function(e) {
    if (!(e.type !== "rule" || !e.parent || e.length < 1)) {
      for (var n = e.value, r = e.parent, i = e.column === r.column && e.line === r.line; r.type !== "rule"; )
        if (r = r.parent, !r)
          return;
      if (!(e.props.length === 1 && n.charCodeAt(0) !== 58 && !jw.get(r)) && !i) {
        jw.set(e, true);
        for (var o = [], s = zF(n, o), a = r.props, l = 0, c = 0; l < s.length; l++)
          for (var u = 0; u < a.length; u++, c++)
            e.props[c] = o[l] ? s[l].replace(/&\f/g, a[u]) : a[u] + " " + s[l];
      }
    }
  }, VF = function(e) {
    if (e.type === "decl") {
      var n = e.value;
      n.charCodeAt(0) === 108 && n.charCodeAt(2) === 98 && (e.return = "", e.value = "");
    }
  };
  function ZA(t, e) {
    switch (kF(t, e)) {
      case 5103:
        return Ue + "print-" + t + t;
      case 5737:
      case 4201:
      case 3177:
      case 3433:
      case 1641:
      case 4457:
      case 2921:
      case 5572:
      case 6356:
      case 5844:
      case 3191:
      case 6645:
      case 3005:
      case 6391:
      case 5879:
      case 5623:
      case 6135:
      case 4599:
      case 4855:
      case 4215:
      case 6389:
      case 5109:
      case 5365:
      case 5621:
      case 3829:
        return Ue + t + t;
      case 5349:
      case 4246:
      case 4810:
      case 6968:
      case 2756:
        return Ue + t + ap + t + ln + t + t;
      case 6828:
      case 4268:
        return Ue + t + ln + t + t;
      case 6165:
        return Ue + t + ln + "flex-" + t + t;
      case 5187:
        return Ue + t + Ke(t, /(\w+).+(:[^]+)/, Ue + "box-$1$2" + ln + "flex-$1$2") + t;
      case 5443:
        return Ue + t + ln + "flex-item-" + Ke(t, /flex-|-self/, "") + t;
      case 4675:
        return Ue + t + ln + "flex-line-pack" + Ke(t, /align-content|flex-|-self/, "") + t;
      case 5548:
        return Ue + t + ln + Ke(t, "shrink", "negative") + t;
      case 5292:
        return Ue + t + ln + Ke(t, "basis", "preferred-size") + t;
      case 6060:
        return Ue + "box-" + Ke(t, "-grow", "") + Ue + t + ln + Ke(t, "grow", "positive") + t;
      case 4554:
        return Ue + Ke(t, /([^-])(transform)/g, "$1" + Ue + "$2") + t;
      case 6187:
        return Ke(Ke(Ke(t, /(zoom-|grab)/, Ue + "$1"), /(image-set)/, Ue + "$1"), t, "") + t;
      case 5495:
      case 3959:
        return Ke(t, /(image-set\([^]*)/, Ue + "$1$`$1");
      case 4968:
        return Ke(Ke(t, /(.+:)(flex-)?(.*)/, Ue + "box-pack:$3" + ln + "flex-pack:$3"), /s.+-b[^;]+/, "justify") + Ue + t + t;
      case 4095:
      case 3583:
      case 4068:
      case 2532:
        return Ke(t, /(.+)-inline(.+)/, Ue + "$1$2") + t;
      case 8116:
      case 7059:
      case 5753:
      case 5535:
      case 5445:
      case 5701:
      case 4933:
      case 4677:
      case 5533:
      case 5789:
      case 5021:
      case 4765:
        if (ui(t) - 1 - e > 6)
          switch (Xt(t, e + 1)) {
            case 109:
              if (Xt(t, e + 4) !== 45)
                break;
            case 102:
              return Ke(t, /(.+:)(.+)-([^]+)/, "$1" + Ue + "$2-$3$1" + ap + (Xt(t, e + 3) == 108 ? "$3" : "$2-$3")) + t;
            case 115:
              return ~fy(t, "stretch") ? ZA(Ke(t, "stretch", "fill-available"), e) + t : t;
          }
        break;
      case 4949:
        if (Xt(t, e + 1) !== 115)
          break;
      case 6444:
        switch (Xt(t, ui(t) - 3 - (~fy(t, "!important") && 10))) {
          case 107:
            return Ke(t, ":", ":" + Ue) + t;
          case 101:
            return Ke(t, /(.+:)([^;!]+)(;|!.+)?/, "$1" + Ue + (Xt(t, 14) === 45 ? "inline-" : "") + "box$3$1" + Ue + "$2$3$1" + ln + "$2box$3") + t;
        }
        break;
      case 5936:
        switch (Xt(t, e + 11)) {
          case 114:
            return Ue + t + ln + Ke(t, /[svh]\w+-[tblr]{2}/, "tb") + t;
          case 108:
            return Ue + t + ln + Ke(t, /[svh]\w+-[tblr]{2}/, "tb-rl") + t;
          case 45:
            return Ue + t + ln + Ke(t, /[svh]\w+-[tblr]{2}/, "lr") + t;
        }
        return Ue + t + ln + t + t;
    }
    return t;
  }
  var HF = function(e, n, r, i) {
    if (e.length > -1 && !e.return)
      switch (e.type) {
        case Nb:
          e.return = ZA(e.value, e.length);
          break;
        case qA:
          return Ka([
            nc(e, {
              value: Ke(e.value, "@", "@" + Ue)
            })
          ], i);
        case Bb:
          if (e.length)
            return TF(e.props, function(o) {
              switch (CF(o, /(::plac\w+|:read-\w+)/)) {
                case ":read-only":
                case ":read-write":
                  return Ka([
                    nc(e, {
                      props: [
                        Ke(o, /:(read-\w+)/, ":" + ap + "$1")
                      ]
                    })
                  ], i);
                case "::placeholder":
                  return Ka([
                    nc(e, {
                      props: [
                        Ke(o, /:(plac\w+)/, ":" + Ue + "input-$1")
                      ]
                    }),
                    nc(e, {
                      props: [
                        Ke(o, /:(plac\w+)/, ":" + ap + "$1")
                      ]
                    }),
                    nc(e, {
                      props: [
                        Ke(o, /:(plac\w+)/, ln + "input-$1")
                      ]
                    })
                  ], i);
              }
              return "";
            });
      }
  }, jF = [
    HF
  ], WF = function(e) {
    var n = e.key;
    if (n === "css") {
      var r = document.querySelectorAll("style[data-emotion]:not([data-s])");
      Array.prototype.forEach.call(r, function(x) {
        var T = x.getAttribute("data-emotion");
        T.indexOf(" ") !== -1 && (document.head.appendChild(x), x.setAttribute("data-s", ""));
      });
    }
    var i = e.stylisPlugins || jF, o = {}, s, a = [];
    s = e.container || document.head, Array.prototype.forEach.call(document.querySelectorAll('style[data-emotion^="' + n + ' "]'), function(x) {
      for (var T = x.getAttribute("data-emotion").split(" "), w = 1; w < T.length; w++)
        o[T[w]] = true;
      a.push(x);
    });
    var l, c = [
      FF,
      VF
    ];
    {
      var u, h = [
        DF,
        BF(function(x) {
          u.insert(x);
        })
      ], p = IF(c.concat(i, h)), v = function(T) {
        return Ka(LF(T), p);
      };
      l = function(T, w, k, C) {
        u = k, v(T ? T + "{" + w.styles + "}" : w.styles), C && (y.inserted[w.name] = true);
      };
    }
    var y = {
      key: n,
      sheet: new yF({
        key: n,
        container: s,
        nonce: e.nonce,
        speedy: e.speedy,
        prepend: e.prepend,
        insertionPoint: e.insertionPoint
      }),
      nonce: e.nonce,
      inserted: o,
      registered: {},
      insert: l
    };
    return y.sheet.hydrate(a), y;
  };
  function Tu() {
    return Tu = Object.assign ? Object.assign.bind() : function(t) {
      for (var e = 1; e < arguments.length; e++) {
        var n = arguments[e];
        for (var r in n)
          ({}).hasOwnProperty.call(n, r) && (t[r] = n[r]);
      }
      return t;
    }, Tu.apply(null, arguments);
  }
  var eE = {
    exports: {}
  }, Xe = {};
  var Wt = typeof Symbol == "function" && Symbol.for, zb = Wt ? Symbol.for("react.element") : 60103, Fb = Wt ? Symbol.for("react.portal") : 60106, gm = Wt ? Symbol.for("react.fragment") : 60107, vm = Wt ? Symbol.for("react.strict_mode") : 60108, ym = Wt ? Symbol.for("react.profiler") : 60114, bm = Wt ? Symbol.for("react.provider") : 60109, xm = Wt ? Symbol.for("react.context") : 60110, Vb = Wt ? Symbol.for("react.async_mode") : 60111, Sm = Wt ? Symbol.for("react.concurrent_mode") : 60111, wm = Wt ? Symbol.for("react.forward_ref") : 60112, km = Wt ? Symbol.for("react.suspense") : 60113, UF = Wt ? Symbol.for("react.suspense_list") : 60120, Cm = Wt ? Symbol.for("react.memo") : 60115, Tm = Wt ? Symbol.for("react.lazy") : 60116, KF = Wt ? Symbol.for("react.block") : 60121, qF = Wt ? Symbol.for("react.fundamental") : 60117, GF = Wt ? Symbol.for("react.responder") : 60118, YF = Wt ? Symbol.for("react.scope") : 60119;
  function tr(t) {
    if (typeof t == "object" && t !== null) {
      var e = t.$$typeof;
      switch (e) {
        case zb:
          switch (t = t.type, t) {
            case Vb:
            case Sm:
            case gm:
            case ym:
            case vm:
            case km:
              return t;
            default:
              switch (t = t && t.$$typeof, t) {
                case xm:
                case wm:
                case Tm:
                case Cm:
                case bm:
                  return t;
                default:
                  return e;
              }
          }
        case Fb:
          return e;
      }
    }
  }
  function tE(t) {
    return tr(t) === Sm;
  }
  Xe.AsyncMode = Vb;
  Xe.ConcurrentMode = Sm;
  Xe.ContextConsumer = xm;
  Xe.ContextProvider = bm;
  Xe.Element = zb;
  Xe.ForwardRef = wm;
  Xe.Fragment = gm;
  Xe.Lazy = Tm;
  Xe.Memo = Cm;
  Xe.Portal = Fb;
  Xe.Profiler = ym;
  Xe.StrictMode = vm;
  Xe.Suspense = km;
  Xe.isAsyncMode = function(t) {
    return tE(t) || tr(t) === Vb;
  };
  Xe.isConcurrentMode = tE;
  Xe.isContextConsumer = function(t) {
    return tr(t) === xm;
  };
  Xe.isContextProvider = function(t) {
    return tr(t) === bm;
  };
  Xe.isElement = function(t) {
    return typeof t == "object" && t !== null && t.$$typeof === zb;
  };
  Xe.isForwardRef = function(t) {
    return tr(t) === wm;
  };
  Xe.isFragment = function(t) {
    return tr(t) === gm;
  };
  Xe.isLazy = function(t) {
    return tr(t) === Tm;
  };
  Xe.isMemo = function(t) {
    return tr(t) === Cm;
  };
  Xe.isPortal = function(t) {
    return tr(t) === Fb;
  };
  Xe.isProfiler = function(t) {
    return tr(t) === ym;
  };
  Xe.isStrictMode = function(t) {
    return tr(t) === vm;
  };
  Xe.isSuspense = function(t) {
    return tr(t) === km;
  };
  Xe.isValidElementType = function(t) {
    return typeof t == "string" || typeof t == "function" || t === gm || t === Sm || t === ym || t === vm || t === km || t === UF || typeof t == "object" && t !== null && (t.$$typeof === Tm || t.$$typeof === Cm || t.$$typeof === bm || t.$$typeof === xm || t.$$typeof === wm || t.$$typeof === qF || t.$$typeof === GF || t.$$typeof === YF || t.$$typeof === KF);
  };
  Xe.typeOf = tr;
  (function(t) {
    t.exports = Xe;
  })(eE);
  var nE = eE.exports, XF = {
    $$typeof: true,
    render: true,
    defaultProps: true,
    displayName: true,
    propTypes: true
  }, QF = {
    $$typeof: true,
    compare: true,
    defaultProps: true,
    displayName: true,
    propTypes: true,
    type: true
  }, rE = {};
  rE[nE.ForwardRef] = XF;
  rE[nE.Memo] = QF;
  var JF = true;
  function iE(t, e, n) {
    var r = "";
    return n.split(" ").forEach(function(i) {
      t[i] !== void 0 ? e.push(t[i] + ";") : i && (r += i + " ");
    }), r;
  }
  var Hb = function(e, n, r) {
    var i = e.key + "-" + n.name;
    (r === false || JF === false) && e.registered[i] === void 0 && (e.registered[i] = n.styles);
  }, jb = function(e, n, r) {
    Hb(e, n, r);
    var i = e.key + "-" + n.name;
    if (e.inserted[n.name] === void 0) {
      var o = n;
      do
        e.insert(n === o ? "." + i : "", o, e.sheet, true), o = o.next;
      while (o !== void 0);
    }
  };
  function ZF(t) {
    for (var e = 0, n, r = 0, i = t.length; i >= 4; ++r, i -= 4)
      n = t.charCodeAt(r) & 255 | (t.charCodeAt(++r) & 255) << 8 | (t.charCodeAt(++r) & 255) << 16 | (t.charCodeAt(++r) & 255) << 24, n = (n & 65535) * 1540483477 + ((n >>> 16) * 59797 << 16), n ^= n >>> 24, e = (n & 65535) * 1540483477 + ((n >>> 16) * 59797 << 16) ^ (e & 65535) * 1540483477 + ((e >>> 16) * 59797 << 16);
    switch (i) {
      case 3:
        e ^= (t.charCodeAt(r + 2) & 255) << 16;
      case 2:
        e ^= (t.charCodeAt(r + 1) & 255) << 8;
      case 1:
        e ^= t.charCodeAt(r) & 255, e = (e & 65535) * 1540483477 + ((e >>> 16) * 59797 << 16);
    }
    return e ^= e >>> 13, e = (e & 65535) * 1540483477 + ((e >>> 16) * 59797 << 16), ((e ^ e >>> 15) >>> 0).toString(36);
  }
  var eV = {
    animationIterationCount: 1,
    aspectRatio: 1,
    borderImageOutset: 1,
    borderImageSlice: 1,
    borderImageWidth: 1,
    boxFlex: 1,
    boxFlexGroup: 1,
    boxOrdinalGroup: 1,
    columnCount: 1,
    columns: 1,
    flex: 1,
    flexGrow: 1,
    flexPositive: 1,
    flexShrink: 1,
    flexNegative: 1,
    flexOrder: 1,
    gridRow: 1,
    gridRowEnd: 1,
    gridRowSpan: 1,
    gridRowStart: 1,
    gridColumn: 1,
    gridColumnEnd: 1,
    gridColumnSpan: 1,
    gridColumnStart: 1,
    msGridRow: 1,
    msGridRowSpan: 1,
    msGridColumn: 1,
    msGridColumnSpan: 1,
    fontWeight: 1,
    lineHeight: 1,
    opacity: 1,
    order: 1,
    orphans: 1,
    scale: 1,
    tabSize: 1,
    widows: 1,
    zIndex: 1,
    zoom: 1,
    WebkitLineClamp: 1,
    fillOpacity: 1,
    floodOpacity: 1,
    stopOpacity: 1,
    strokeDasharray: 1,
    strokeDashoffset: 1,
    strokeMiterlimit: 1,
    strokeOpacity: 1,
    strokeWidth: 1
  }, tV = false, nV = /[A-Z]|^ms/g, rV = /_EMO_([^_]+?)_([^]*?)_EMO_/g, oE = function(e) {
    return e.charCodeAt(1) === 45;
  }, Ww = function(e) {
    return e != null && typeof e != "boolean";
  }, p0 = JA(function(t) {
    return oE(t) ? t : t.replace(nV, "-$&").toLowerCase();
  }), Uw = function(e, n) {
    switch (e) {
      case "animation":
      case "animationName":
        if (typeof n == "string")
          return n.replace(rV, function(r, i, o) {
            return fi = {
              name: i,
              styles: o,
              next: fi
            }, i;
          });
    }
    return eV[e] !== 1 && !oE(e) && typeof n == "number" && n !== 0 ? n + "px" : n;
  }, iV = "Component selectors can only be used in conjunction with @emotion/babel-plugin, the swc Emotion plugin, or another Emotion-aware compiler transform.";
  function Mu(t, e, n) {
    if (n == null)
      return "";
    var r = n;
    if (r.__emotion_styles !== void 0)
      return r;
    switch (typeof n) {
      case "boolean":
        return "";
      case "object": {
        var i = n;
        if (i.anim === 1)
          return fi = {
            name: i.name,
            styles: i.styles,
            next: fi
          }, i.name;
        var o = n;
        if (o.styles !== void 0) {
          var s = o.next;
          if (s !== void 0)
            for (; s !== void 0; )
              fi = {
                name: s.name,
                styles: s.styles,
                next: fi
              }, s = s.next;
          var a = o.styles + ";";
          return a;
        }
        return oV(t, e, n);
      }
      case "function": {
        if (t !== void 0) {
          var l = fi, c = n(t);
          return fi = l, Mu(t, e, c);
        }
        break;
      }
    }
    var u = n;
    if (e == null)
      return u;
    var h = e[u];
    return h !== void 0 ? h : u;
  }
  function oV(t, e, n) {
    var r = "";
    if (Array.isArray(n))
      for (var i = 0; i < n.length; i++)
        r += Mu(t, e, n[i]) + ";";
    else
      for (var o in n) {
        var s = n[o];
        if (typeof s != "object") {
          var a = s;
          e != null && e[a] !== void 0 ? r += o + "{" + e[a] + "}" : Ww(a) && (r += p0(o) + ":" + Uw(o, a) + ";");
        } else {
          if (o === "NO_COMPONENT_SELECTOR" && tV)
            throw new Error(iV);
          if (Array.isArray(s) && typeof s[0] == "string" && (e == null || e[s[0]] === void 0))
            for (var l = 0; l < s.length; l++)
              Ww(s[l]) && (r += p0(o) + ":" + Uw(o, s[l]) + ";");
          else {
            var c = Mu(t, e, s);
            switch (o) {
              case "animation":
              case "animationName": {
                r += p0(o) + ":" + c + ";";
                break;
              }
              default:
                r += o + "{" + c + "}";
            }
          }
        }
      }
    return r;
  }
  var Kw = /label:\s*([^\s;{]+)\s*(;|$)/g, fi;
  function Mm(t, e, n) {
    if (t.length === 1 && typeof t[0] == "object" && t[0] !== null && t[0].styles !== void 0)
      return t[0];
    var r = true, i = "";
    fi = void 0;
    var o = t[0];
    if (o == null || o.raw === void 0)
      r = false, i += Mu(n, e, o);
    else {
      var s = o;
      i += s[0];
    }
    for (var a = 1; a < t.length; a++)
      if (i += Mu(n, e, t[a]), r) {
        var l = o;
        i += l[a];
      }
    Kw.lastIndex = 0;
    for (var c = "", u; (u = Kw.exec(i)) !== null; )
      c += "-" + u[1];
    var h = ZF(i) + c;
    return {
      name: h,
      styles: i,
      next: fi
    };
  }
  var sV = function(e) {
    return e();
  }, sE = dS["useInsertionEffect"] ? dS["useInsertionEffect"] : false, aE = sE || sV, qw = sE || z.exports.useLayoutEffect, aV = false, Wb = z.exports.createContext(typeof HTMLElement < "u" ? WF({
    key: "css"
  }) : null);
  Wb.Provider;
  var lV = function() {
    return z.exports.useContext(Wb);
  }, Ub = function(e) {
    return z.exports.forwardRef(function(n, r) {
      var i = z.exports.useContext(Wb);
      return e(n, i, r);
    });
  }, ul = z.exports.createContext({}), cV = function(e, n) {
    if (typeof n == "function") {
      var r = n(e);
      return r;
    }
    return Tu({}, e, n);
  }, uV = Hw(function(t) {
    return Hw(function(e) {
      return cV(t, e);
    });
  }), fV = function(e) {
    var n = z.exports.useContext(ul);
    return e.theme !== n && (n = uV(n)(e.theme)), J(ul.Provider, {
      value: n,
      children: e.children
    });
  }, Kb = {}.hasOwnProperty, dy = "__EMOTION_TYPE_PLEASE_DO_NOT_USE__", hV = function(e, n) {
    var r = {};
    for (var i in n)
      Kb.call(n, i) && (r[i] = n[i]);
    return r[dy] = e, r;
  }, dV = function(e) {
    var n = e.cache, r = e.serialized, i = e.isStringTag;
    return Hb(n, r, i), aE(function() {
      return jb(n, r, i);
    }), null;
  }, pV = Ub(function(t, e, n) {
    var r = t.css;
    typeof r == "string" && e.registered[r] !== void 0 && (r = e.registered[r]);
    var i = t[dy], o = [
      r
    ], s = "";
    typeof t.className == "string" ? s = iE(e.registered, o, t.className) : t.className != null && (s = t.className + " ");
    var a = Mm(o, void 0, z.exports.useContext(ul));
    s += e.key + "-" + a.name;
    var l = {};
    for (var c in t)
      Kb.call(t, c) && c !== "css" && c !== dy && !aV && (l[c] = t[c]);
    return l.className = s, n && (l.ref = n), Xn(sp, {
      children: [
        J(dV, {
          cache: e,
          serialized: a,
          isStringTag: typeof i == "string"
        }),
        J(i, {
          ...l
        })
      ]
    });
  }), mV = pV, Gw = function(e, n) {
    var r = arguments;
    if (n == null || !Kb.call(n, "css"))
      return z.exports.createElement.apply(void 0, r);
    var i = r.length, o = new Array(i);
    o[0] = mV, o[1] = hV(e, n);
    for (var s = 2; s < i; s++)
      o[s] = r[s];
    return z.exports.createElement.apply(null, o);
  };
  (function(t) {
    var e;
    (function(n) {
    })(e || (e = t.JSX || (t.JSX = {})));
  })(Gw || (Gw = {}));
  var Am = Ub(function(t, e) {
    var n = t.styles, r = Mm([
      n
    ], void 0, z.exports.useContext(ul)), i = z.exports.useRef();
    return qw(function() {
      var o = e.key + "-global", s = new e.sheet.constructor({
        key: o,
        nonce: e.sheet.nonce,
        container: e.sheet.container,
        speedy: e.sheet.isSpeedy
      }), a = false, l = document.querySelector('style[data-emotion="' + o + " " + r.name + '"]');
      return e.sheet.tags.length && (s.before = e.sheet.tags[0]), l !== null && (a = true, l.setAttribute("data-emotion", o), s.hydrate([
        l
      ])), i.current = [
        s,
        a
      ], function() {
        s.flush();
      };
    }, [
      e
    ]), qw(function() {
      var o = i.current, s = o[0], a = o[1];
      if (a) {
        o[1] = false;
        return;
      }
      if (r.next !== void 0 && jb(e, r.next, true), s.tags.length) {
        var l = s.tags[s.tags.length - 1].nextElementSibling;
        s.before = l, s.flush();
      }
      e.insert("", r, s, false);
    }, [
      e,
      r.name
    ]), null;
  });
  function gV() {
    for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++)
      e[n] = arguments[n];
    return Mm(e);
  }
  function vV() {
    var t = gV.apply(void 0, arguments), e = "animation-" + t.name;
    return {
      name: e,
      styles: "@keyframes " + e + "{" + t.styles + "}",
      anim: 1,
      toString: function() {
        return "_EMO_" + this.name + "_" + this.styles + "_EMO_";
      }
    };
  }
  const qb = z.exports.createContext({});
  qb.displayName = "ColorModeContext";
  function Gb() {
    const t = z.exports.useContext(qb);
    if (t === void 0)
      throw new Error("useColorMode must be used within a ColorModeProvider");
    return t;
  }
  const ph = {
    light: "chakra-ui-light",
    dark: "chakra-ui-dark"
  };
  function yV(t = {}) {
    const { preventTransition: e = true, nonce: n } = t, r = {
      setDataset: (i) => {
        const o = e ? r.preventTransition() : void 0;
        document.documentElement.dataset.theme = i, document.documentElement.style.colorScheme = i, o == null ? void 0 : o();
      },
      setClassName(i) {
        document.body.classList.add(i ? ph.dark : ph.light), document.body.classList.remove(i ? ph.light : ph.dark);
      },
      query() {
        return window.matchMedia("(prefers-color-scheme: dark)");
      },
      getSystemTheme(i) {
        return r.query().matches ?? i === "dark" ? "dark" : "light";
      },
      addListener(i) {
        const o = r.query(), s = (a) => {
          i(a.matches ? "dark" : "light");
        };
        return typeof o.addListener == "function" ? o.addListener(s) : o.addEventListener("change", s), () => {
          typeof o.removeListener == "function" ? o.removeListener(s) : o.removeEventListener("change", s);
        };
      },
      preventTransition() {
        const i = document.createElement("style");
        return i.appendChild(document.createTextNode("*{-webkit-transition:none!important;-moz-transition:none!important;-o-transition:none!important;-ms-transition:none!important;transition:none!important}")), n !== void 0 && (i.nonce = n), document.head.appendChild(i), () => {
          window.getComputedStyle(document.body), requestAnimationFrame(() => {
            requestAnimationFrame(() => {
              document.head.removeChild(i);
            });
          });
        };
      }
    };
    return r;
  }
  const bV = "chakra-ui-color-mode";
  function xV(t) {
    return {
      ssr: false,
      type: "localStorage",
      get(e) {
        if (!(globalThis == null ? void 0 : globalThis.document))
          return e;
        let n;
        try {
          n = localStorage.getItem(t) || e;
        } catch {
        }
        return n || e;
      },
      set(e) {
        try {
          localStorage.setItem(t, e);
        } catch {
        }
      }
    };
  }
  const SV = xV(bV), Yw = () => {
  }, wV = PI() ? z.exports.useLayoutEffect : z.exports.useEffect;
  function Xw(t, e) {
    return t.type === "cookie" && t.ssr ? t.get(e) : e;
  }
  const lE = function(e) {
    const { value: n, children: r, options: { useSystemColorMode: i, initialColorMode: o, disableTransitionOnChange: s } = {}, colorModeManager: a = SV } = e, l = lV(), c = o === "dark" ? "dark" : "light", [u, h] = z.exports.useState(() => Xw(a, c)), [p, v] = z.exports.useState(() => Xw(a)), { getSystemTheme: y, setClassName: x, setDataset: T, addListener: w } = z.exports.useMemo(() => yV({
      preventTransition: s,
      nonce: l == null ? void 0 : l.nonce
    }), [
      s,
      l == null ? void 0 : l.nonce
    ]), k = o === "system" && !u ? p : u, C = z.exports.useCallback((L) => {
      const _ = L === "system" ? y() : L;
      h(_), x(_ === "dark"), T(_), a.set(_);
    }, [
      a,
      y,
      x,
      T
    ]);
    wV(() => {
      o === "system" && v(y());
    }, []), z.exports.useEffect(() => {
      const L = a.get();
      if (L) {
        C(L);
        return;
      }
      if (o === "system") {
        C("system");
        return;
      }
      C(c);
    }, [
      a,
      c,
      o,
      C
    ]);
    const P = z.exports.useCallback(() => {
      C(k === "dark" ? "light" : "dark");
    }, [
      k,
      C
    ]);
    z.exports.useEffect(() => {
      if (!!i)
        return w(C);
    }, [
      i,
      w,
      C
    ]);
    const R = z.exports.useMemo(() => ({
      colorMode: n ?? k,
      toggleColorMode: n ? Yw : P,
      setColorMode: n ? Yw : C,
      forced: n !== void 0
    }), [
      k,
      P,
      C,
      n
    ]);
    return J(qb.Provider, {
      value: R,
      children: r
    });
  };
  lE.displayName = "ColorModeProvider";
  const cE = String.raw, uE = cE`
  :root,
  :host {
    --chakra-vh: 100vh;
  }

  @supports (height: -webkit-fill-available) {
    :root,
    :host {
      --chakra-vh: -webkit-fill-available;
    }
  }

  @supports (height: -moz-fill-available) {
    :root,
    :host {
      --chakra-vh: -moz-fill-available;
    }
  }

  @supports (height: 100dvh) {
    :root,
    :host {
      --chakra-vh: 100dvh;
    }
  }
`, kV = () => J(Am, {
    styles: uE
  }), CV = ({ scope: t = "" }) => J(Am, {
    styles: cE`
      html {
        line-height: 1.5;
        -webkit-text-size-adjust: 100%;
        font-family: system-ui, sans-serif;
        -webkit-font-smoothing: antialiased;
        text-rendering: optimizeLegibility;
        -moz-osx-font-smoothing: grayscale;
        touch-action: manipulation;
      }

      body {
        position: relative;
        min-height: 100%;
        margin: 0;
        font-feature-settings: "kern";
      }

      ${t} :where(*, *::before, *::after) {
        border-width: 0;
        border-style: solid;
        box-sizing: border-box;
        word-wrap: break-word;
      }

      main {
        display: block;
      }

      ${t} hr {
        border-top-width: 1px;
        box-sizing: content-box;
        height: 0;
        overflow: visible;
      }

      ${t} :where(pre, code, kbd,samp) {
        font-family: SFMono-Regular, Menlo, Monaco, Consolas, monospace;
        font-size: 1em;
      }

      ${t} a {
        background-color: transparent;
        color: inherit;
        text-decoration: inherit;
      }

      ${t} abbr[title] {
        border-bottom: none;
        text-decoration: underline;
        -webkit-text-decoration: underline dotted;
        text-decoration: underline dotted;
      }

      ${t} :where(b, strong) {
        font-weight: bold;
      }

      ${t} small {
        font-size: 80%;
      }

      ${t} :where(sub,sup) {
        font-size: 75%;
        line-height: 0;
        position: relative;
        vertical-align: baseline;
      }

      ${t} sub {
        bottom: -0.25em;
      }

      ${t} sup {
        top: -0.5em;
      }

      ${t} img {
        border-style: none;
      }

      ${t} :where(button, input, optgroup, select, textarea) {
        font-family: inherit;
        font-size: 100%;
        line-height: 1.15;
        margin: 0;
      }

      ${t} :where(button, input) {
        overflow: visible;
      }

      ${t} :where(button, select) {
        text-transform: none;
      }

      ${t} :where(
          button::-moz-focus-inner,
          [type="button"]::-moz-focus-inner,
          [type="reset"]::-moz-focus-inner,
          [type="submit"]::-moz-focus-inner
        ) {
        border-style: none;
        padding: 0;
      }

      ${t} fieldset {
        padding: 0.35em 0.75em 0.625em;
      }

      ${t} legend {
        box-sizing: border-box;
        color: inherit;
        display: table;
        max-width: 100%;
        padding: 0;
        white-space: normal;
      }

      ${t} progress {
        vertical-align: baseline;
      }

      ${t} textarea {
        overflow: auto;
      }

      ${t} :where([type="checkbox"], [type="radio"]) {
        box-sizing: border-box;
        padding: 0;
      }

      ${t} input[type="number"]::-webkit-inner-spin-button,
      ${t} input[type="number"]::-webkit-outer-spin-button {
        -webkit-appearance: none !important;
      }

      ${t} input[type="number"] {
        -moz-appearance: textfield;
      }

      ${t} input[type="search"] {
        -webkit-appearance: textfield;
        outline-offset: -2px;
      }

      ${t} input[type="search"]::-webkit-search-decoration {
        -webkit-appearance: none !important;
      }

      ${t} ::-webkit-file-upload-button {
        -webkit-appearance: button;
        font: inherit;
      }

      ${t} details {
        display: block;
      }

      ${t} summary {
        display: list-item;
      }

      template {
        display: none;
      }

      [hidden] {
        display: none !important;
      }

      ${t} :where(
          blockquote,
          dl,
          dd,
          h1,
          h2,
          h3,
          h4,
          h5,
          h6,
          hr,
          figure,
          p,
          pre
        ) {
        margin: 0;
      }

      ${t} button {
        background: transparent;
        padding: 0;
      }

      ${t} fieldset {
        margin: 0;
        padding: 0;
      }

      ${t} :where(ol, ul) {
        margin: 0;
        padding: 0;
      }

      ${t} textarea {
        resize: vertical;
      }

      ${t} :where(button, [role="button"]) {
        cursor: pointer;
      }

      ${t} button::-moz-focus-inner {
        border: 0 !important;
      }

      ${t} table {
        border-collapse: collapse;
      }

      ${t} :where(h1, h2, h3, h4, h5, h6) {
        font-size: inherit;
        font-weight: inherit;
      }

      ${t} :where(button, input, optgroup, select, textarea) {
        padding: 0;
        line-height: inherit;
        color: inherit;
      }

      ${t} :where(img, svg, video, canvas, audio, iframe, embed, object) {
        display: block;
      }

      ${t} :where(img, video) {
        max-width: 100%;
        height: auto;
      }

      [data-js-focus-visible]
        :focus:not([data-focus-visible-added]):not(
          [data-focus-visible-disabled]
        ) {
        outline: none;
        box-shadow: none;
      }

      ${t} select::-ms-expand {
        display: none;
      }

      ${uE}
    `
  });
  function TV(t) {
    const { cssVarsRoot: e, theme: n, children: r } = t, i = z.exports.useMemo(() => nN(n), [
      n
    ]);
    return Xn(fV, {
      theme: i,
      children: [
        J(MV, {
          root: e
        }),
        r
      ]
    });
  }
  function MV({ root: t = ":host, :root" }) {
    const e = [
      t,
      "[data-theme]"
    ].join(",");
    return J(Am, {
      styles: (n) => ({
        [e]: n.__cssVars
      })
    });
  }
  Ei({
    name: "StylesContext",
    errorMessage: "useStyles: `styles` is undefined. Seems you forgot to wrap the components in `<StylesProvider />` "
  });
  function AV() {
    const { colorMode: t } = Gb();
    return J(Am, {
      styles: (e) => {
        const n = xA(e, "styles.global"), r = vi(n, {
          theme: e,
          colorMode: t
        });
        return r ? TA(r)(e) : void 0;
      }
    });
  }
  const [EV, PV] = Ei({
    strict: false,
    name: "PortalManagerContext"
  });
  function fE(t) {
    const { children: e, zIndex: n } = t;
    return J(EV, {
      value: {
        zIndex: n
      },
      children: e
    });
  }
  fE.displayName = "PortalManager";
  const hE = z.exports.createContext({
    getDocument() {
      return document;
    },
    getWindow() {
      return window;
    }
  });
  hE.displayName = "EnvironmentContext";
  function dE(t) {
    const { children: e, environment: n, disabled: r } = t, i = z.exports.useRef(null), o = z.exports.useMemo(() => n || {
      getDocument: () => {
        var _a3;
        return ((_a3 = i.current) == null ? void 0 : _a3.ownerDocument) ?? document;
      },
      getWindow: () => {
        var _a3;
        return ((_a3 = i.current) == null ? void 0 : _a3.ownerDocument.defaultView) ?? window;
      }
    }, [
      n
    ]), s = !r || !n;
    return Xn(hE.Provider, {
      value: o,
      children: [
        e,
        s && J("span", {
          id: "__chakra_env",
          hidden: true,
          ref: i
        })
      ]
    });
  }
  dE.displayName = "EnvironmentProvider";
  const OV = (t) => {
    const { children: e, colorModeManager: n, portalZIndex: r, resetScope: i, resetCSS: o = true, theme: s = {}, environment: a, cssVarsRoot: l, disableEnvironment: c, disableGlobalStyle: u } = t, h = J(dE, {
      environment: a,
      disabled: c,
      children: e
    });
    return J(TV, {
      theme: s,
      cssVarsRoot: l,
      children: Xn(lE, {
        colorModeManager: n,
        options: s.config,
        children: [
          o ? J(CV, {
            scope: i
          }) : J(kV, {}),
          !u && J(AV, {}),
          r ? J(fE, {
            zIndex: r,
            children: h
          }) : h
        ]
      })
    });
  };
  var py = function(t, e) {
    return py = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function(n, r) {
      n.__proto__ = r;
    } || function(n, r) {
      for (var i in r)
        Object.prototype.hasOwnProperty.call(r, i) && (n[i] = r[i]);
    }, py(t, e);
  };
  function pE(t, e) {
    if (typeof e != "function" && e !== null)
      throw new TypeError("Class extends value " + String(e) + " is not a constructor or null");
    py(t, e);
    function n() {
      this.constructor = t;
    }
    t.prototype = e === null ? Object.create(e) : (n.prototype = e.prototype, new n());
  }
  var ie = function() {
    return ie = Object.assign || function(e) {
      for (var n, r = 1, i = arguments.length; r < i; r++) {
        n = arguments[r];
        for (var o in n)
          Object.prototype.hasOwnProperty.call(n, o) && (e[o] = n[o]);
      }
      return e;
    }, ie.apply(this, arguments);
  };
  function Mr(t, e) {
    var n = {};
    for (var r in t)
      Object.prototype.hasOwnProperty.call(t, r) && e.indexOf(r) < 0 && (n[r] = t[r]);
    if (t != null && typeof Object.getOwnPropertySymbols == "function")
      for (var i = 0, r = Object.getOwnPropertySymbols(t); i < r.length; i++)
        e.indexOf(r[i]) < 0 && Object.prototype.propertyIsEnumerable.call(t, r[i]) && (n[r[i]] = t[r[i]]);
    return n;
  }
  function RV(t) {
    var e = typeof Symbol == "function" && Symbol.iterator, n = e && t[e], r = 0;
    if (n)
      return n.call(t);
    if (t && typeof t.length == "number")
      return {
        next: function() {
          return t && r >= t.length && (t = void 0), {
            value: t && t[r++],
            done: !t
          };
        }
      };
    throw new TypeError(e ? "Object is not iterable." : "Symbol.iterator is not defined.");
  }
  function kt(t, e) {
    var n = typeof Symbol == "function" && t[Symbol.iterator];
    if (!n)
      return t;
    var r = n.call(t), i, o = [], s;
    try {
      for (; (e === void 0 || e-- > 0) && !(i = r.next()).done; )
        o.push(i.value);
    } catch (a) {
      s = {
        error: a
      };
    } finally {
      try {
        i && !i.done && (n = r.return) && n.call(r);
      } finally {
        if (s)
          throw s.error;
      }
    }
    return o;
  }
  function jr(t, e, n) {
    if (n || arguments.length === 2)
      for (var r = 0, i = e.length, o; r < i; r++)
        (o || !(r in e)) && (o || (o = Array.prototype.slice.call(e, 0, r)), o[r] = e[r]);
    return t.concat(o || Array.prototype.slice.call(e));
  }
  var LV = "production", Yb = typeof process > "u" || process.env === void 0 ? LV : "production", Ii = function(t) {
    return {
      isEnabled: function(e) {
        return t.some(function(n) {
          return !!e[n];
        });
      }
    };
  }, Au = {
    measureLayout: Ii([
      "layout",
      "layoutId",
      "drag"
    ]),
    animation: Ii([
      "animate",
      "exit",
      "variants",
      "whileHover",
      "whileTap",
      "whileFocus",
      "whileDrag",
      "whileInView"
    ]),
    exit: Ii([
      "exit"
    ]),
    drag: Ii([
      "drag",
      "dragControls"
    ]),
    focus: Ii([
      "whileFocus"
    ]),
    hover: Ii([
      "whileHover",
      "onHoverStart",
      "onHoverEnd"
    ]),
    tap: Ii([
      "whileTap",
      "onTap",
      "onTapStart",
      "onTapCancel"
    ]),
    pan: Ii([
      "onPan",
      "onPanStart",
      "onPanSessionStart",
      "onPanEnd"
    ]),
    inView: Ii([
      "whileInView",
      "onViewportEnter",
      "onViewportLeave"
    ])
  };
  function _V(t) {
    for (var e in t)
      t[e] !== null && (e === "projectionNodeConstructor" ? Au.projectionNodeConstructor = t[e] : Au[e].Component = t[e]);
  }
  var DV = function() {
  }, lp = function() {
  }, mE = z.exports.createContext({
    strict: false
  }), gE = Object.keys(Au), IV = gE.length;
  function BV(t, e, n) {
    var r = [], i = z.exports.useContext(mE);
    if (!e)
      return null;
    Yb !== "production" && n && i.strict;
    for (var o = 0; o < IV; o++) {
      var s = gE[o], a = Au[s], l = a.isEnabled, c = a.Component;
      l(t) && c && r.push(J(c, {
        ...ie({
          key: s
        }, t, {
          visualElement: e
        })
      }));
    }
    return r;
  }
  var Xb = z.exports.createContext({
    transformPagePoint: function(t) {
      return t;
    },
    isStatic: false,
    reducedMotion: "never"
  }), Em = z.exports.createContext({});
  function NV() {
    return z.exports.useContext(Em).visualElement;
  }
  var Al = z.exports.createContext(null), El = typeof document < "u", cp = El ? z.exports.useLayoutEffect : z.exports.useEffect, my = {
    current: null
  }, vE = false;
  function $V() {
    if (vE = true, !!El)
      if (window.matchMedia) {
        var t = window.matchMedia("(prefers-reduced-motion)"), e = function() {
          return my.current = t.matches;
        };
        t.addListener(e), e();
      } else
        my.current = false;
  }
  function zV() {
    !vE && $V();
    var t = kt(z.exports.useState(my.current), 1), e = t[0];
    return e;
  }
  function FV() {
    var t = zV(), e = z.exports.useContext(Xb).reducedMotion;
    return e === "never" ? false : e === "always" ? true : t;
  }
  function VV(t, e, n, r) {
    var i = z.exports.useContext(mE), o = NV(), s = z.exports.useContext(Al), a = FV(), l = z.exports.useRef(void 0);
    r || (r = i.renderer), !l.current && r && (l.current = r(t, {
      visualState: e,
      parent: o,
      props: n,
      presenceId: s == null ? void 0 : s.id,
      blockInitialAnimation: (s == null ? void 0 : s.initial) === false,
      shouldReduceMotion: a
    }));
    var c = l.current;
    return cp(function() {
      c == null ? void 0 : c.syncRender();
    }), z.exports.useEffect(function() {
      var u;
      (u = c == null ? void 0 : c.animationState) === null || u === void 0 || u.animateChanges();
    }), cp(function() {
      return function() {
        return c == null ? void 0 : c.notifyUnmount();
      };
    }, []), c;
  }
  function Ra(t) {
    return typeof t == "object" && Object.prototype.hasOwnProperty.call(t, "current");
  }
  function HV(t, e, n) {
    return z.exports.useCallback(function(r) {
      var i;
      r && ((i = t.mount) === null || i === void 0 || i.call(t, r)), e && (r ? e.mount(r) : e.unmount()), n && (typeof n == "function" ? n(r) : Ra(n) && (n.current = r));
    }, [
      e
    ]);
  }
  function yE(t) {
    return Array.isArray(t);
  }
  function Br(t) {
    return typeof t == "string" || yE(t);
  }
  function jV(t) {
    var e = {};
    return t.forEachValue(function(n, r) {
      return e[r] = n.get();
    }), e;
  }
  function WV(t) {
    var e = {};
    return t.forEachValue(function(n, r) {
      return e[r] = n.getVelocity();
    }), e;
  }
  function bE(t, e, n, r, i) {
    var o;
    return r === void 0 && (r = {}), i === void 0 && (i = {}), typeof e == "function" && (e = e(n ?? t.custom, r, i)), typeof e == "string" && (e = (o = t.variants) === null || o === void 0 ? void 0 : o[e]), typeof e == "function" && (e = e(n ?? t.custom, r, i)), e;
  }
  function Pm(t, e, n) {
    var r = t.getProps();
    return bE(r, e, n ?? r.custom, jV(t), WV(t));
  }
  function Om(t) {
    var e;
    return typeof ((e = t.animate) === null || e === void 0 ? void 0 : e.start) == "function" || Br(t.initial) || Br(t.animate) || Br(t.whileHover) || Br(t.whileDrag) || Br(t.whileTap) || Br(t.whileFocus) || Br(t.exit);
  }
  function xE(t) {
    return Boolean(Om(t) || t.variants);
  }
  function UV(t, e) {
    if (Om(t)) {
      var n = t.initial, r = t.animate;
      return {
        initial: n === false || Br(n) ? n : void 0,
        animate: Br(r) ? r : void 0
      };
    }
    return t.inherit !== false ? e : {};
  }
  function KV(t) {
    var e = UV(t, z.exports.useContext(Em)), n = e.initial, r = e.animate;
    return z.exports.useMemo(function() {
      return {
        initial: n,
        animate: r
      };
    }, [
      Qw(n),
      Qw(r)
    ]);
  }
  function Qw(t) {
    return Array.isArray(t) ? t.join(" ") : t;
  }
  function ef(t) {
    var e = z.exports.useRef(null);
    return e.current === null && (e.current = t()), e.current;
  }
  var Vc = {
    hasAnimatedSinceResize: true,
    hasEverUpdated: false
  }, qV = 1;
  function GV() {
    return ef(function() {
      if (Vc.hasEverUpdated)
        return qV++;
    });
  }
  var Qb = z.exports.createContext({}), SE = z.exports.createContext({});
  function YV(t, e, n, r) {
    var i, o = e.layoutId, s = e.layout, a = e.drag, l = e.dragConstraints, c = e.layoutScroll, u = z.exports.useContext(SE);
    !r || !n || (n == null ? void 0 : n.projection) || (n.projection = new r(t, n.getLatestValues(), (i = n.parent) === null || i === void 0 ? void 0 : i.projection), n.projection.setOptions({
      layoutId: o,
      layout: s,
      alwaysMeasureLayout: Boolean(a) || l && Ra(l),
      visualElement: n,
      scheduleRender: function() {
        return n.scheduleRender();
      },
      animationType: typeof s == "string" ? s : "both",
      initialPromotionConfig: u,
      layoutScroll: c
    }));
  }
  var XV = function(t) {
    pE(e, t);
    function e() {
      return t !== null && t.apply(this, arguments) || this;
    }
    return e.prototype.getSnapshotBeforeUpdate = function() {
      return this.updateProps(), null;
    }, e.prototype.componentDidUpdate = function() {
    }, e.prototype.updateProps = function() {
      var n = this.props, r = n.visualElement, i = n.props;
      r && r.setProps(i);
    }, e.prototype.render = function() {
      return this.props.children;
    }, e;
  }(jp.Component);
  function QV(t) {
    var e = t.preloadedFeatures, n = t.createVisualElement, r = t.projectionNodeConstructor, i = t.useRender, o = t.useVisualState, s = t.Component;
    e && _V(e);
    function a(l, c) {
      var u = JV(l);
      l = ie(ie({}, l), {
        layoutId: u
      });
      var h = z.exports.useContext(Xb), p = null, v = KV(l), y = h.isStatic ? void 0 : GV(), x = o(l, h.isStatic);
      return !h.isStatic && El && (v.visualElement = VV(s, x, ie(ie({}, h), l), n), YV(y, l, v.visualElement, r || Au.projectionNodeConstructor), p = BV(l, v.visualElement, e)), Xn(XV, {
        visualElement: v.visualElement,
        props: ie(ie({}, h), l),
        children: [
          p,
          J(Em.Provider, {
            value: v,
            children: i(s, l, y, HV(x, v.visualElement, c), x, h.isStatic, v.visualElement)
          })
        ]
      });
    }
    return z.exports.forwardRef(a);
  }
  function JV(t) {
    var e, n = t.layoutId, r = (e = z.exports.useContext(Qb)) === null || e === void 0 ? void 0 : e.id;
    return r && n !== void 0 ? r + "-" + n : n;
  }
  function ZV(t) {
    function e(r, i) {
      return i === void 0 && (i = {}), QV(t(r, i));
    }
    if (typeof Proxy > "u")
      return e;
    var n = /* @__PURE__ */ new Map();
    return new Proxy(e, {
      get: function(r, i) {
        return n.has(i) || n.set(i, e(i)), n.get(i);
      }
    });
  }
  var e6 = [
    "animate",
    "circle",
    "defs",
    "desc",
    "ellipse",
    "g",
    "image",
    "line",
    "filter",
    "marker",
    "mask",
    "metadata",
    "path",
    "pattern",
    "polygon",
    "polyline",
    "rect",
    "stop",
    "svg",
    "switch",
    "symbol",
    "text",
    "tspan",
    "use",
    "view"
  ];
  function Jb(t) {
    return typeof t != "string" || t.includes("-") ? false : !!(e6.indexOf(t) > -1 || /[A-Z]/.test(t));
  }
  var up = {};
  function t6(t) {
    Object.assign(up, t);
  }
  var gy = [
    "",
    "X",
    "Y",
    "Z"
  ], n6 = [
    "translate",
    "scale",
    "rotate",
    "skew"
  ], Eu = [
    "transformPerspective",
    "x",
    "y",
    "z"
  ];
  n6.forEach(function(t) {
    return gy.forEach(function(e) {
      return Eu.push(t + e);
    });
  });
  function r6(t, e) {
    return Eu.indexOf(t) - Eu.indexOf(e);
  }
  var i6 = new Set(Eu);
  function tf(t) {
    return i6.has(t);
  }
  var o6 = /* @__PURE__ */ new Set([
    "originX",
    "originY",
    "originZ"
  ]);
  function wE(t) {
    return o6.has(t);
  }
  function kE(t, e) {
    var n = e.layout, r = e.layoutId;
    return tf(t) || wE(t) || (n || r !== void 0) && (!!up[t] || t === "opacity");
  }
  var Zi = function(t) {
    return Boolean(t !== null && typeof t == "object" && t.getVelocity);
  }, s6 = {
    x: "translateX",
    y: "translateY",
    z: "translateZ",
    transformPerspective: "perspective"
  };
  function a6(t, e, n, r) {
    var i = t.transform, o = t.transformKeys, s = e.enableHardwareAcceleration, a = s === void 0 ? true : s, l = e.allowTransformNone, c = l === void 0 ? true : l, u = "";
    o.sort(r6);
    for (var h = false, p = o.length, v = 0; v < p; v++) {
      var y = o[v];
      u += "".concat(s6[y] || y, "(").concat(i[y], ") "), y === "z" && (h = true);
    }
    return !h && a ? u += "translateZ(0)" : u = u.trim(), r ? u = r(i, n ? "" : u) : c && n && (u = "none"), u;
  }
  function l6(t) {
    var e = t.originX, n = e === void 0 ? "50%" : e, r = t.originY, i = r === void 0 ? "50%" : r, o = t.originZ, s = o === void 0 ? 0 : o;
    return "".concat(n, " ").concat(i, " ").concat(s);
  }
  function CE(t) {
    return t.startsWith("--");
  }
  var c6 = function(t, e) {
    return e && typeof t == "number" ? e.transform(t) : t;
  };
  const TE = (t, e) => (n) => Math.max(Math.min(n, e), t), Hc = (t) => t % 1 ? Number(t.toFixed(5)) : t, Pu = /(-)?([\d]*\.?[\d])+/g, vy = /(#[0-9a-f]{6}|#[0-9a-f]{3}|#(?:[0-9a-f]{2}){2,4}|(rgb|hsl)a?\((-?[\d\.]+%?[,\s]+){2,3}\s*\/*\s*[\d\.]+%?\))/gi, u6 = /^(#[0-9a-f]{3}|#(?:[0-9a-f]{2}){2,4}|(rgb|hsl)a?\((-?[\d\.]+%?[,\s]+){2,3}\s*\/*\s*[\d\.]+%?\))$/i;
  function nf(t) {
    return typeof t == "string";
  }
  const Js = {
    test: (t) => typeof t == "number",
    parse: parseFloat,
    transform: (t) => t
  }, jc = Object.assign(Object.assign({}, Js), {
    transform: TE(0, 1)
  }), mh = Object.assign(Object.assign({}, Js), {
    default: 1
  }), rf = (t) => ({
    test: (e) => nf(e) && e.endsWith(t) && e.split(" ").length === 1,
    parse: parseFloat,
    transform: (e) => `${e}${t}`
  }), go = rf("deg"), Ci = rf("%"), Te = rf("px"), f6 = rf("vh"), h6 = rf("vw"), Jw = Object.assign(Object.assign({}, Ci), {
    parse: (t) => Ci.parse(t) / 100,
    transform: (t) => Ci.transform(t * 100)
  }), Zb = (t, e) => (n) => Boolean(nf(n) && u6.test(n) && n.startsWith(t) || e && Object.prototype.hasOwnProperty.call(n, e)), ME = (t, e, n) => (r) => {
    if (!nf(r))
      return r;
    const [i, o, s, a] = r.match(Pu);
    return {
      [t]: parseFloat(i),
      [e]: parseFloat(o),
      [n]: parseFloat(s),
      alpha: a !== void 0 ? parseFloat(a) : 1
    };
  }, Es = {
    test: Zb("hsl", "hue"),
    parse: ME("hue", "saturation", "lightness"),
    transform: ({ hue: t, saturation: e, lightness: n, alpha: r = 1 }) => "hsla(" + Math.round(t) + ", " + Ci.transform(Hc(e)) + ", " + Ci.transform(Hc(n)) + ", " + Hc(jc.transform(r)) + ")"
  }, d6 = TE(0, 255), m0 = Object.assign(Object.assign({}, Js), {
    transform: (t) => Math.round(d6(t))
  }), Oo = {
    test: Zb("rgb", "red"),
    parse: ME("red", "green", "blue"),
    transform: ({ red: t, green: e, blue: n, alpha: r = 1 }) => "rgba(" + m0.transform(t) + ", " + m0.transform(e) + ", " + m0.transform(n) + ", " + Hc(jc.transform(r)) + ")"
  };
  function p6(t) {
    let e = "", n = "", r = "", i = "";
    return t.length > 5 ? (e = t.substr(1, 2), n = t.substr(3, 2), r = t.substr(5, 2), i = t.substr(7, 2)) : (e = t.substr(1, 1), n = t.substr(2, 1), r = t.substr(3, 1), i = t.substr(4, 1), e += e, n += n, r += r, i += i), {
      red: parseInt(e, 16),
      green: parseInt(n, 16),
      blue: parseInt(r, 16),
      alpha: i ? parseInt(i, 16) / 255 : 1
    };
  }
  const yy = {
    test: Zb("#"),
    parse: p6,
    transform: Oo.transform
  }, yn = {
    test: (t) => Oo.test(t) || yy.test(t) || Es.test(t),
    parse: (t) => Oo.test(t) ? Oo.parse(t) : Es.test(t) ? Es.parse(t) : yy.parse(t),
    transform: (t) => nf(t) ? t : t.hasOwnProperty("red") ? Oo.transform(t) : Es.transform(t)
  }, AE = "${c}", EE = "${n}";
  function m6(t) {
    var e, n, r, i;
    return isNaN(t) && nf(t) && ((n = (e = t.match(Pu)) === null || e === void 0 ? void 0 : e.length) !== null && n !== void 0 ? n : 0) + ((i = (r = t.match(vy)) === null || r === void 0 ? void 0 : r.length) !== null && i !== void 0 ? i : 0) > 0;
  }
  function PE(t) {
    typeof t == "number" && (t = `${t}`);
    const e = [];
    let n = 0;
    const r = t.match(vy);
    r && (n = r.length, t = t.replace(vy, AE), e.push(...r.map(yn.parse)));
    const i = t.match(Pu);
    return i && (t = t.replace(Pu, EE), e.push(...i.map(Js.parse))), {
      values: e,
      numColors: n,
      tokenised: t
    };
  }
  function OE(t) {
    return PE(t).values;
  }
  function RE(t) {
    const { values: e, numColors: n, tokenised: r } = PE(t), i = e.length;
    return (o) => {
      let s = r;
      for (let a = 0; a < i; a++)
        s = s.replace(a < n ? AE : EE, a < n ? yn.transform(o[a]) : Hc(o[a]));
      return s;
    };
  }
  const g6 = (t) => typeof t == "number" ? 0 : t;
  function v6(t) {
    const e = OE(t);
    return RE(t)(e.map(g6));
  }
  const eo = {
    test: m6,
    parse: OE,
    createTransformer: RE,
    getAnimatableNone: v6
  }, y6 = /* @__PURE__ */ new Set([
    "brightness",
    "contrast",
    "saturate",
    "opacity"
  ]);
  function b6(t) {
    let [e, n] = t.slice(0, -1).split("(");
    if (e === "drop-shadow")
      return t;
    const [r] = n.match(Pu) || [];
    if (!r)
      return t;
    const i = n.replace(r, "");
    let o = y6.has(e) ? 1 : 0;
    return r !== n && (o *= 100), e + "(" + o + i + ")";
  }
  const x6 = /([a-z-]*)\(.*?\)/g, by = Object.assign(Object.assign({}, eo), {
    getAnimatableNone: (t) => {
      const e = t.match(x6);
      return e ? e.map(b6).join(" ") : t;
    }
  });
  var Zw = ie(ie({}, Js), {
    transform: Math.round
  }), LE = {
    borderWidth: Te,
    borderTopWidth: Te,
    borderRightWidth: Te,
    borderBottomWidth: Te,
    borderLeftWidth: Te,
    borderRadius: Te,
    radius: Te,
    borderTopLeftRadius: Te,
    borderTopRightRadius: Te,
    borderBottomRightRadius: Te,
    borderBottomLeftRadius: Te,
    width: Te,
    maxWidth: Te,
    height: Te,
    maxHeight: Te,
    size: Te,
    top: Te,
    right: Te,
    bottom: Te,
    left: Te,
    padding: Te,
    paddingTop: Te,
    paddingRight: Te,
    paddingBottom: Te,
    paddingLeft: Te,
    margin: Te,
    marginTop: Te,
    marginRight: Te,
    marginBottom: Te,
    marginLeft: Te,
    rotate: go,
    rotateX: go,
    rotateY: go,
    rotateZ: go,
    scale: mh,
    scaleX: mh,
    scaleY: mh,
    scaleZ: mh,
    skew: go,
    skewX: go,
    skewY: go,
    distance: Te,
    translateX: Te,
    translateY: Te,
    translateZ: Te,
    x: Te,
    y: Te,
    z: Te,
    perspective: Te,
    transformPerspective: Te,
    opacity: jc,
    originX: Jw,
    originY: Jw,
    originZ: Te,
    zIndex: Zw,
    fillOpacity: jc,
    strokeOpacity: jc,
    numOctaves: Zw
  };
  function ex(t, e, n, r) {
    var i, o = t.style, s = t.vars, a = t.transform, l = t.transformKeys, c = t.transformOrigin;
    l.length = 0;
    var u = false, h = false, p = true;
    for (var v in e) {
      var y = e[v];
      if (CE(v)) {
        s[v] = y;
        continue;
      }
      var x = LE[v], T = c6(y, x);
      if (tf(v)) {
        if (u = true, a[v] = T, l.push(v), !p)
          continue;
        y !== ((i = x.default) !== null && i !== void 0 ? i : 0) && (p = false);
      } else
        wE(v) ? (c[v] = T, h = true) : o[v] = T;
    }
    u ? o.transform = a6(t, n, p, r) : r ? o.transform = r({}, "") : !e.transform && o.transform && (o.transform = "none"), h && (o.transformOrigin = l6(c));
  }
  var tx = function() {
    return {
      style: {},
      transform: {},
      transformKeys: [],
      transformOrigin: {},
      vars: {}
    };
  };
  function _E(t, e, n) {
    for (var r in e)
      !Zi(e[r]) && !kE(r, n) && (t[r] = e[r]);
  }
  function S6(t, e, n) {
    var r = t.transformTemplate;
    return z.exports.useMemo(function() {
      var i = tx();
      ex(i, e, {
        enableHardwareAcceleration: !n
      }, r);
      var o = i.vars, s = i.style;
      return ie(ie({}, o), s);
    }, [
      e
    ]);
  }
  function w6(t, e, n) {
    var r = t.style || {}, i = {};
    return _E(i, r, t), Object.assign(i, S6(t, e, n)), t.transformValues && (i = t.transformValues(i)), i;
  }
  function k6(t, e, n) {
    var r = {}, i = w6(t, e, n);
    return Boolean(t.drag) && t.dragListener !== false && (r.draggable = false, i.userSelect = i.WebkitUserSelect = i.WebkitTouchCallout = "none", i.touchAction = t.drag === true ? "none" : "pan-".concat(t.drag === "x" ? "y" : "x")), r.style = i, r;
  }
  var C6 = /* @__PURE__ */ new Set([
    "initial",
    "animate",
    "exit",
    "style",
    "variants",
    "transition",
    "transformTemplate",
    "transformValues",
    "custom",
    "inherit",
    "layout",
    "layoutId",
    "layoutDependency",
    "onLayoutAnimationStart",
    "onLayoutAnimationComplete",
    "onLayoutMeasure",
    "onBeforeLayoutMeasure",
    "onAnimationStart",
    "onAnimationComplete",
    "onUpdate",
    "onDragStart",
    "onDrag",
    "onDragEnd",
    "onMeasureDragConstraints",
    "onDirectionLock",
    "onDragTransitionEnd",
    "drag",
    "dragControls",
    "dragListener",
    "dragConstraints",
    "dragDirectionLock",
    "dragSnapToOrigin",
    "_dragX",
    "_dragY",
    "dragElastic",
    "dragMomentum",
    "dragPropagation",
    "dragTransition",
    "whileDrag",
    "onPan",
    "onPanStart",
    "onPanEnd",
    "onPanSessionStart",
    "onTap",
    "onTapStart",
    "onTapCancel",
    "onHoverStart",
    "onHoverEnd",
    "whileFocus",
    "whileTap",
    "whileHover",
    "whileInView",
    "onViewportEnter",
    "onViewportLeave",
    "viewport",
    "layoutScroll"
  ]);
  function fp(t) {
    return C6.has(t);
  }
  var DE = function(t) {
    return !fp(t);
  };
  function T6(t) {
    !t || (DE = function(e) {
      return e.startsWith("on") ? !fp(e) : t(e);
    });
  }
  try {
    T6(require("@emotion/is-prop-valid").default);
  } catch {
  }
  function M6(t, e, n) {
    var r = {};
    for (var i in t)
      (DE(i) || n === true && fp(i) || !e && !fp(i) || t.draggable && i.startsWith("onDrag")) && (r[i] = t[i]);
    return r;
  }
  function ek(t, e, n) {
    return typeof t == "string" ? t : Te.transform(e + n * t);
  }
  function A6(t, e, n) {
    var r = ek(e, t.x, t.width), i = ek(n, t.y, t.height);
    return "".concat(r, " ").concat(i);
  }
  var E6 = {
    offset: "stroke-dashoffset",
    array: "stroke-dasharray"
  }, P6 = {
    offset: "strokeDashoffset",
    array: "strokeDasharray"
  };
  function O6(t, e, n, r, i) {
    n === void 0 && (n = 1), r === void 0 && (r = 0), i === void 0 && (i = true), t.pathLength = 1;
    var o = i ? E6 : P6;
    t[o.offset] = Te.transform(-r);
    var s = Te.transform(e), a = Te.transform(n);
    t[o.array] = "".concat(s, " ").concat(a);
  }
  function nx(t, e, n, r) {
    var i = e.attrX, o = e.attrY, s = e.originX, a = e.originY, l = e.pathLength, c = e.pathSpacing, u = c === void 0 ? 1 : c, h = e.pathOffset, p = h === void 0 ? 0 : h, v = Mr(e, [
      "attrX",
      "attrY",
      "originX",
      "originY",
      "pathLength",
      "pathSpacing",
      "pathOffset"
    ]);
    ex(t, v, n, r), t.attrs = t.style, t.style = {};
    var y = t.attrs, x = t.style, T = t.dimensions;
    y.transform && (T && (x.transform = y.transform), delete y.transform), T && (s !== void 0 || a !== void 0 || x.transform) && (x.transformOrigin = A6(T, s !== void 0 ? s : 0.5, a !== void 0 ? a : 0.5)), i !== void 0 && (y.x = i), o !== void 0 && (y.y = o), l !== void 0 && O6(y, l, u, p, false);
  }
  var IE = function() {
    return ie(ie({}, tx()), {
      attrs: {}
    });
  };
  function R6(t, e) {
    var n = z.exports.useMemo(function() {
      var i = IE();
      return nx(i, e, {
        enableHardwareAcceleration: false
      }, t.transformTemplate), ie(ie({}, i.attrs), {
        style: ie({}, i.style)
      });
    }, [
      e
    ]);
    if (t.style) {
      var r = {};
      _E(r, t.style, t), n.style = ie(ie({}, r), n.style);
    }
    return n;
  }
  function L6(t) {
    t === void 0 && (t = false);
    var e = function(n, r, i, o, s, a) {
      var l = s.latestValues, c = Jb(n) ? R6 : k6, u = c(r, l, a), h = M6(r, typeof n == "string", t), p = ie(ie(ie({}, h), u), {
        ref: o
      });
      return i && (p["data-projection-id"] = i), z.exports.createElement(n, p);
    };
    return e;
  }
  var _6 = /([a-z])([A-Z])/g, D6 = "$1-$2", BE = function(t) {
    return t.replace(_6, D6).toLowerCase();
  };
  function NE(t, e, n, r) {
    var i = e.style, o = e.vars;
    Object.assign(t.style, i, r && r.getProjectionStyles(n));
    for (var s in o)
      t.style.setProperty(s, o[s]);
  }
  var $E = /* @__PURE__ */ new Set([
    "baseFrequency",
    "diffuseConstant",
    "kernelMatrix",
    "kernelUnitLength",
    "keySplines",
    "keyTimes",
    "limitingConeAngle",
    "markerHeight",
    "markerWidth",
    "numOctaves",
    "targetX",
    "targetY",
    "surfaceScale",
    "specularConstant",
    "specularExponent",
    "stdDeviation",
    "tableValues",
    "viewBox",
    "gradientTransform",
    "pathLength"
  ]);
  function zE(t, e, n, r) {
    NE(t, e, void 0, r);
    for (var i in e.attrs)
      t.setAttribute($E.has(i) ? i : BE(i), e.attrs[i]);
  }
  function rx(t) {
    var e = t.style, n = {};
    for (var r in e)
      (Zi(e[r]) || kE(r, t)) && (n[r] = e[r]);
    return n;
  }
  function FE(t) {
    var e = rx(t);
    for (var n in t)
      if (Zi(t[n])) {
        var r = n === "x" || n === "y" ? "attr" + n.toUpperCase() : n;
        e[r] = t[n];
      }
    return e;
  }
  function ix(t) {
    return typeof t == "object" && typeof t.start == "function";
  }
  var Ou = function(t) {
    return Array.isArray(t);
  }, I6 = function(t) {
    return Boolean(t && typeof t == "object" && t.mix && t.toValue);
  }, VE = function(t) {
    return Ou(t) ? t[t.length - 1] || 0 : t;
  };
  function gd(t) {
    var e = Zi(t) ? t.get() : t;
    return I6(e) ? e.toValue() : e;
  }
  function tk(t, e, n, r) {
    var i = t.scrapeMotionValuesFromProps, o = t.createRenderState, s = t.onMount, a = {
      latestValues: B6(e, n, r, i),
      renderState: o()
    };
    return s && (a.mount = function(l) {
      return s(e, l, a);
    }), a;
  }
  var HE = function(t) {
    return function(e, n) {
      var r = z.exports.useContext(Em), i = z.exports.useContext(Al);
      return n ? tk(t, e, r, i) : ef(function() {
        return tk(t, e, r, i);
      });
    };
  };
  function B6(t, e, n, r) {
    var i = {}, o = (n == null ? void 0 : n.initial) === false, s = r(t);
    for (var a in s)
      i[a] = gd(s[a]);
    var l = t.initial, c = t.animate, u = Om(t), h = xE(t);
    e && h && !u && t.inherit !== false && (l ?? (l = e.initial), c ?? (c = e.animate));
    var p = o || l === false, v = p ? c : l;
    if (v && typeof v != "boolean" && !ix(v)) {
      var y = Array.isArray(v) ? v : [
        v
      ];
      y.forEach(function(x) {
        var T = bE(t, x);
        if (!!T) {
          var w = T.transitionEnd;
          T.transition;
          var k = Mr(T, [
            "transitionEnd",
            "transition"
          ]);
          for (var C in k) {
            var P = k[C];
            if (Array.isArray(P)) {
              var R = p ? P.length - 1 : 0;
              P = P[R];
            }
            P !== null && (i[C] = P);
          }
          for (var C in w)
            i[C] = w[C];
        }
      });
    }
    return i;
  }
  var N6 = {
    useVisualState: HE({
      scrapeMotionValuesFromProps: FE,
      createRenderState: IE,
      onMount: function(t, e, n) {
        var r = n.renderState, i = n.latestValues;
        try {
          r.dimensions = typeof e.getBBox == "function" ? e.getBBox() : e.getBoundingClientRect();
        } catch {
          r.dimensions = {
            x: 0,
            y: 0,
            width: 0,
            height: 0
          };
        }
        nx(r, i, {
          enableHardwareAcceleration: false
        }, t.transformTemplate), zE(e, r);
      }
    })
  }, $6 = {
    useVisualState: HE({
      scrapeMotionValuesFromProps: rx,
      createRenderState: tx
    })
  };
  function z6(t, e, n, r, i) {
    var o = e.forwardMotionProps, s = o === void 0 ? false : o, a = Jb(t) ? N6 : $6;
    return ie(ie({}, a), {
      preloadedFeatures: n,
      useRender: L6(s),
      createVisualElement: r,
      projectionNodeConstructor: i,
      Component: t
    });
  }
  var tt;
  (function(t) {
    t.Animate = "animate", t.Hover = "whileHover", t.Tap = "whileTap", t.Drag = "whileDrag", t.Focus = "whileFocus", t.InView = "whileInView", t.Exit = "exit";
  })(tt || (tt = {}));
  function Rm(t, e, n, r) {
    return r === void 0 && (r = {
      passive: true
    }), t.addEventListener(e, n, r), function() {
      return t.removeEventListener(e, n);
    };
  }
  function xy(t, e, n, r) {
    z.exports.useEffect(function() {
      var i = t.current;
      if (n && i)
        return Rm(i, e, n, r);
    }, [
      t,
      e,
      n,
      r
    ]);
  }
  function F6(t) {
    var e = t.whileFocus, n = t.visualElement, r = function() {
      var o;
      (o = n.animationState) === null || o === void 0 || o.setActive(tt.Focus, true);
    }, i = function() {
      var o;
      (o = n.animationState) === null || o === void 0 || o.setActive(tt.Focus, false);
    };
    xy(n, "focus", e ? r : void 0), xy(n, "blur", e ? i : void 0);
  }
  function jE(t) {
    return typeof PointerEvent < "u" && t instanceof PointerEvent ? t.pointerType === "mouse" : t instanceof MouseEvent;
  }
  function WE(t) {
    var e = !!t.touches;
    return e;
  }
  function V6(t) {
    return function(e) {
      var n = e instanceof MouseEvent, r = !n || n && e.button === 0;
      r && t(e);
    };
  }
  var H6 = {
    pageX: 0,
    pageY: 0
  };
  function j6(t, e) {
    e === void 0 && (e = "page");
    var n = t.touches[0] || t.changedTouches[0], r = n || H6;
    return {
      x: r[e + "X"],
      y: r[e + "Y"]
    };
  }
  function W6(t, e) {
    return e === void 0 && (e = "page"), {
      x: t[e + "X"],
      y: t[e + "Y"]
    };
  }
  function ox(t, e) {
    return e === void 0 && (e = "page"), {
      point: WE(t) ? j6(t, e) : W6(t, e)
    };
  }
  var UE = function(t, e) {
    e === void 0 && (e = false);
    var n = function(r) {
      return t(r, ox(r));
    };
    return e ? V6(n) : n;
  }, U6 = function() {
    return El && window.onpointerdown === null;
  }, K6 = function() {
    return El && window.ontouchstart === null;
  }, q6 = function() {
    return El && window.onmousedown === null;
  }, G6 = {
    pointerdown: "mousedown",
    pointermove: "mousemove",
    pointerup: "mouseup",
    pointercancel: "mousecancel",
    pointerover: "mouseover",
    pointerout: "mouseout",
    pointerenter: "mouseenter",
    pointerleave: "mouseleave"
  }, Y6 = {
    pointerdown: "touchstart",
    pointermove: "touchmove",
    pointerup: "touchend",
    pointercancel: "touchcancel"
  };
  function KE(t) {
    return U6() ? t : K6() ? Y6[t] : q6() ? G6[t] : t;
  }
  function qa(t, e, n, r) {
    return Rm(t, KE(e), UE(n, e === "pointerdown"), r);
  }
  function hp(t, e, n, r) {
    return xy(t, KE(e), n && UE(n, e === "pointerdown"), r);
  }
  function qE(t) {
    var e = null;
    return function() {
      var n = function() {
        e = null;
      };
      return e === null ? (e = t, n) : false;
    };
  }
  var nk = qE("dragHorizontal"), rk = qE("dragVertical");
  function GE(t) {
    var e = false;
    if (t === "y")
      e = rk();
    else if (t === "x")
      e = nk();
    else {
      var n = nk(), r = rk();
      n && r ? e = function() {
        n(), r();
      } : (n && n(), r && r());
    }
    return e;
  }
  function YE() {
    var t = GE(true);
    return t ? (t(), false) : true;
  }
  function ik(t, e, n) {
    return function(r, i) {
      var o;
      !jE(r) || YE() || ((o = t.animationState) === null || o === void 0 || o.setActive(tt.Hover, e), n == null ? void 0 : n(r, i));
    };
  }
  function X6(t) {
    var e = t.onHoverStart, n = t.onHoverEnd, r = t.whileHover, i = t.visualElement;
    hp(i, "pointerenter", e || r ? ik(i, true, e) : void 0, {
      passive: !e
    }), hp(i, "pointerleave", n || r ? ik(i, false, n) : void 0, {
      passive: !n
    });
  }
  var XE = function(t, e) {
    return e ? t === e ? true : XE(t, e.parentElement) : false;
  };
  function sx(t) {
    return z.exports.useEffect(function() {
      return function() {
        return t();
      };
    }, []);
  }
  const dp = (t, e, n) => Math.min(Math.max(n, t), e), g0 = 1e-3, Q6 = 0.01, ok = 10, J6 = 0.05, Z6 = 1;
  function e8({ duration: t = 800, bounce: e = 0.25, velocity: n = 0, mass: r = 1 }) {
    let i, o;
    DV(t <= ok * 1e3);
    let s = 1 - e;
    s = dp(J6, Z6, s), t = dp(Q6, ok, t / 1e3), s < 1 ? (i = (c) => {
      const u = c * s, h = u * t, p = u - n, v = Sy(c, s), y = Math.exp(-h);
      return g0 - p / v * y;
    }, o = (c) => {
      const h = c * s * t, p = h * n + n, v = Math.pow(s, 2) * Math.pow(c, 2) * t, y = Math.exp(-h), x = Sy(Math.pow(c, 2), s);
      return (-i(c) + g0 > 0 ? -1 : 1) * ((p - v) * y) / x;
    }) : (i = (c) => {
      const u = Math.exp(-c * t), h = (c - n) * t + 1;
      return -g0 + u * h;
    }, o = (c) => {
      const u = Math.exp(-c * t), h = (n - c) * (t * t);
      return u * h;
    });
    const a = 5 / t, l = n8(i, o, a);
    if (t = t * 1e3, isNaN(l))
      return {
        stiffness: 100,
        damping: 10,
        duration: t
      };
    {
      const c = Math.pow(l, 2) * r;
      return {
        stiffness: c,
        damping: s * 2 * Math.sqrt(r * c),
        duration: t
      };
    }
  }
  const t8 = 12;
  function n8(t, e, n) {
    let r = n;
    for (let i = 1; i < t8; i++)
      r = r - t(r) / e(r);
    return r;
  }
  function Sy(t, e) {
    return t * Math.sqrt(1 - e * e);
  }
  const r8 = [
    "duration",
    "bounce"
  ], i8 = [
    "stiffness",
    "damping",
    "mass"
  ];
  function sk(t, e) {
    return e.some((n) => t[n] !== void 0);
  }
  function o8(t) {
    let e = Object.assign({
      velocity: 0,
      stiffness: 100,
      damping: 10,
      mass: 1,
      isResolvedFromDuration: false
    }, t);
    if (!sk(t, i8) && sk(t, r8)) {
      const n = e8(t);
      e = Object.assign(Object.assign(Object.assign({}, e), n), {
        velocity: 0,
        mass: 1
      }), e.isResolvedFromDuration = true;
    }
    return e;
  }
  function ax(t) {
    var { from: e = 0, to: n = 1, restSpeed: r = 2, restDelta: i } = t, o = Mr(t, [
      "from",
      "to",
      "restSpeed",
      "restDelta"
    ]);
    const s = {
      done: false,
      value: e
    };
    let { stiffness: a, damping: l, mass: c, velocity: u, duration: h, isResolvedFromDuration: p } = o8(o), v = ak, y = ak;
    function x() {
      const T = u ? -(u / 1e3) : 0, w = n - e, k = l / (2 * Math.sqrt(a * c)), C = Math.sqrt(a / c) / 1e3;
      if (i === void 0 && (i = Math.min(Math.abs(n - e) / 100, 0.4)), k < 1) {
        const P = Sy(C, k);
        v = (R) => {
          const L = Math.exp(-k * C * R);
          return n - L * ((T + k * C * w) / P * Math.sin(P * R) + w * Math.cos(P * R));
        }, y = (R) => {
          const L = Math.exp(-k * C * R);
          return k * C * L * (Math.sin(P * R) * (T + k * C * w) / P + w * Math.cos(P * R)) - L * (Math.cos(P * R) * (T + k * C * w) - P * w * Math.sin(P * R));
        };
      } else if (k === 1)
        v = (P) => n - Math.exp(-C * P) * (w + (T + C * w) * P);
      else {
        const P = C * Math.sqrt(k * k - 1);
        v = (R) => {
          const L = Math.exp(-k * C * R), _ = Math.min(P * R, 300);
          return n - L * ((T + k * C * w) * Math.sinh(_) + P * w * Math.cosh(_)) / P;
        };
      }
    }
    return x(), {
      next: (T) => {
        const w = v(T);
        if (p)
          s.done = T >= h;
        else {
          const k = y(T) * 1e3, C = Math.abs(k) <= r, P = Math.abs(n - w) <= i;
          s.done = C && P;
        }
        return s.value = s.done ? n : w, s;
      },
      flipTarget: () => {
        u = -u, [e, n] = [
          n,
          e
        ], x();
      }
    };
  }
  ax.needsInterpolation = (t, e) => typeof t == "string" || typeof e == "string";
  const ak = (t) => 0, Ru = (t, e, n) => {
    const r = e - t;
    return r === 0 ? 1 : (n - t) / r;
  }, wt = (t, e, n) => -n * t + n * e + t;
  function v0(t, e, n) {
    return n < 0 && (n += 1), n > 1 && (n -= 1), n < 1 / 6 ? t + (e - t) * 6 * n : n < 1 / 2 ? e : n < 2 / 3 ? t + (e - t) * (2 / 3 - n) * 6 : t;
  }
  function lk({ hue: t, saturation: e, lightness: n, alpha: r }) {
    t /= 360, e /= 100, n /= 100;
    let i = 0, o = 0, s = 0;
    if (!e)
      i = o = s = n;
    else {
      const a = n < 0.5 ? n * (1 + e) : n + e - n * e, l = 2 * n - a;
      i = v0(l, a, t + 1 / 3), o = v0(l, a, t), s = v0(l, a, t - 1 / 3);
    }
    return {
      red: Math.round(i * 255),
      green: Math.round(o * 255),
      blue: Math.round(s * 255),
      alpha: r
    };
  }
  const s8 = (t, e, n) => {
    const r = t * t, i = e * e;
    return Math.sqrt(Math.max(0, n * (i - r) + r));
  }, a8 = [
    yy,
    Oo,
    Es
  ], ck = (t) => a8.find((e) => e.test(t)), QE = (t, e) => {
    let n = ck(t), r = ck(e), i = n.parse(t), o = r.parse(e);
    n === Es && (i = lk(i), n = Oo), r === Es && (o = lk(o), r = Oo);
    const s = Object.assign({}, i);
    return (a) => {
      for (const l in s)
        l !== "alpha" && (s[l] = s8(i[l], o[l], a));
      return s.alpha = wt(i.alpha, o.alpha, a), n.transform(s);
    };
  }, wy = (t) => typeof t == "number", l8 = (t, e) => (n) => e(t(n)), Lm = (...t) => t.reduce(l8);
  function JE(t, e) {
    return wy(t) ? (n) => wt(t, e, n) : yn.test(t) ? QE(t, e) : eP(t, e);
  }
  const ZE = (t, e) => {
    const n = [
      ...t
    ], r = n.length, i = t.map((o, s) => JE(o, e[s]));
    return (o) => {
      for (let s = 0; s < r; s++)
        n[s] = i[s](o);
      return n;
    };
  }, c8 = (t, e) => {
    const n = Object.assign(Object.assign({}, t), e), r = {};
    for (const i in n)
      t[i] !== void 0 && e[i] !== void 0 && (r[i] = JE(t[i], e[i]));
    return (i) => {
      for (const o in r)
        n[o] = r[o](i);
      return n;
    };
  };
  function uk(t) {
    const e = eo.parse(t), n = e.length;
    let r = 0, i = 0, o = 0;
    for (let s = 0; s < n; s++)
      r || typeof e[s] == "number" ? r++ : e[s].hue !== void 0 ? o++ : i++;
    return {
      parsed: e,
      numNumbers: r,
      numRGB: i,
      numHSL: o
    };
  }
  const eP = (t, e) => {
    const n = eo.createTransformer(e), r = uk(t), i = uk(e);
    return r.numHSL === i.numHSL && r.numRGB === i.numRGB && r.numNumbers >= i.numNumbers ? Lm(ZE(r.parsed, i.parsed), n) : (s) => `${s > 0 ? e : t}`;
  }, u8 = (t, e) => (n) => wt(t, e, n);
  function f8(t) {
    if (typeof t == "number")
      return u8;
    if (typeof t == "string")
      return yn.test(t) ? QE : eP;
    if (Array.isArray(t))
      return ZE;
    if (typeof t == "object")
      return c8;
  }
  function h8(t, e, n) {
    const r = [], i = n || f8(t[0]), o = t.length - 1;
    for (let s = 0; s < o; s++) {
      let a = i(t[s], t[s + 1]);
      if (e) {
        const l = Array.isArray(e) ? e[s] : e;
        a = Lm(l, a);
      }
      r.push(a);
    }
    return r;
  }
  function d8([t, e], [n]) {
    return (r) => n(Ru(t, e, r));
  }
  function p8(t, e) {
    const n = t.length, r = n - 1;
    return (i) => {
      let o = 0, s = false;
      if (i <= t[0] ? s = true : i >= t[r] && (o = r - 1, s = true), !s) {
        let l = 1;
        for (; l < n && !(t[l] > i || l === r); l++)
          ;
        o = l - 1;
      }
      const a = Ru(t[o], t[o + 1], i);
      return e[o](a);
    };
  }
  function tP(t, e, { clamp: n = true, ease: r, mixer: i } = {}) {
    const o = t.length;
    lp(o === e.length), lp(!r || !Array.isArray(r) || r.length === o - 1), t[0] > t[o - 1] && (t = [].concat(t), e = [].concat(e), t.reverse(), e.reverse());
    const s = h8(e, r, i), a = o === 2 ? d8(t, s) : p8(t, s);
    return n ? (l) => a(dp(t[0], t[o - 1], l)) : a;
  }
  const _m = (t) => (e) => 1 - t(1 - e), lx = (t) => (e) => e <= 0.5 ? t(2 * e) / 2 : (2 - t(2 * (1 - e))) / 2, m8 = (t) => (e) => Math.pow(e, t), nP = (t) => (e) => e * e * ((t + 1) * e - t), g8 = (t) => {
    const e = nP(t);
    return (n) => (n *= 2) < 1 ? 0.5 * e(n) : 0.5 * (2 - Math.pow(2, -10 * (n - 1)));
  }, rP = 1.525, v8 = 4 / 11, y8 = 8 / 11, b8 = 9 / 10, cx = (t) => t, ux = m8(2), x8 = _m(ux), iP = lx(ux), oP = (t) => 1 - Math.sin(Math.acos(t)), fx = _m(oP), S8 = lx(fx), hx = nP(rP), w8 = _m(hx), k8 = lx(hx), C8 = g8(rP), T8 = 4356 / 361, M8 = 35442 / 1805, A8 = 16061 / 1805, pp = (t) => {
    if (t === 1 || t === 0)
      return t;
    const e = t * t;
    return t < v8 ? 7.5625 * e : t < y8 ? 9.075 * e - 9.9 * t + 3.4 : t < b8 ? T8 * e - M8 * t + A8 : 10.8 * t * t - 20.52 * t + 10.72;
  }, E8 = _m(pp), P8 = (t) => t < 0.5 ? 0.5 * (1 - pp(1 - t * 2)) : 0.5 * pp(t * 2 - 1) + 0.5;
  function O8(t, e) {
    return t.map(() => e || iP).splice(0, t.length - 1);
  }
  function R8(t) {
    const e = t.length;
    return t.map((n, r) => r !== 0 ? r / (e - 1) : 0);
  }
  function L8(t, e) {
    return t.map((n) => n * e);
  }
  function vd({ from: t = 0, to: e = 1, ease: n, offset: r, duration: i = 300 }) {
    const o = {
      done: false,
      value: t
    }, s = Array.isArray(e) ? e : [
      t,
      e
    ], a = L8(r && r.length === s.length ? r : R8(s), i);
    function l() {
      return tP(a, s, {
        ease: Array.isArray(n) ? n : O8(s, n)
      });
    }
    let c = l();
    return {
      next: (u) => (o.value = c(u), o.done = u >= i, o),
      flipTarget: () => {
        s.reverse(), c = l();
      }
    };
  }
  function _8({ velocity: t = 0, from: e = 0, power: n = 0.8, timeConstant: r = 350, restDelta: i = 0.5, modifyTarget: o }) {
    const s = {
      done: false,
      value: e
    };
    let a = n * t;
    const l = e + a, c = o === void 0 ? l : o(l);
    return c !== l && (a = c - e), {
      next: (u) => {
        const h = -a * Math.exp(-u / r);
        return s.done = !(h > i || h < -i), s.value = s.done ? c : c + h, s;
      },
      flipTarget: () => {
      }
    };
  }
  const fk = {
    keyframes: vd,
    spring: ax,
    decay: _8
  };
  function D8(t) {
    if (Array.isArray(t.to))
      return vd;
    if (fk[t.type])
      return fk[t.type];
    const e = new Set(Object.keys(t));
    return e.has("ease") || e.has("duration") && !e.has("dampingRatio") ? vd : e.has("dampingRatio") || e.has("stiffness") || e.has("mass") || e.has("damping") || e.has("restSpeed") || e.has("restDelta") ? ax : vd;
  }
  const sP = 1 / 60 * 1e3, I8 = typeof performance < "u" ? () => performance.now() : () => Date.now(), aP = typeof window < "u" ? (t) => window.requestAnimationFrame(t) : (t) => setTimeout(() => t(I8()), sP);
  function B8(t) {
    let e = [], n = [], r = 0, i = false, o = false;
    const s = /* @__PURE__ */ new WeakSet(), a = {
      schedule: (l, c = false, u = false) => {
        const h = u && i, p = h ? e : n;
        return c && s.add(l), p.indexOf(l) === -1 && (p.push(l), h && i && (r = e.length)), l;
      },
      cancel: (l) => {
        const c = n.indexOf(l);
        c !== -1 && n.splice(c, 1), s.delete(l);
      },
      process: (l) => {
        if (i) {
          o = true;
          return;
        }
        if (i = true, [e, n] = [
          n,
          e
        ], n.length = 0, r = e.length, r)
          for (let c = 0; c < r; c++) {
            const u = e[c];
            u(l), s.has(u) && (a.schedule(u), t());
          }
        i = false, o && (o = false, a.process(l));
      }
    };
    return a;
  }
  const N8 = 40;
  let ky = true, Lu = false, Cy = false;
  const Ga = {
    delta: 0,
    timestamp: 0
  }, of = [
    "read",
    "update",
    "preRender",
    "render",
    "postRender"
  ], Dm = of.reduce((t, e) => (t[e] = B8(() => Lu = true), t), {}), Wr = of.reduce((t, e) => {
    const n = Dm[e];
    return t[e] = (r, i = false, o = false) => (Lu || z8(), n.schedule(r, i, o)), t;
  }, {}), fl = of.reduce((t, e) => (t[e] = Dm[e].cancel, t), {}), y0 = of.reduce((t, e) => (t[e] = () => Dm[e].process(Ga), t), {}), $8 = (t) => Dm[t].process(Ga), lP = (t) => {
    Lu = false, Ga.delta = ky ? sP : Math.max(Math.min(t - Ga.timestamp, N8), 1), Ga.timestamp = t, Cy = true, of.forEach($8), Cy = false, Lu && (ky = false, aP(lP));
  }, z8 = () => {
    Lu = true, ky = true, Cy || aP(lP);
  }, mp = () => Ga;
  function cP(t, e, n = 0) {
    return t - e - n;
  }
  function F8(t, e, n = 0, r = true) {
    return r ? cP(e + -t, e, n) : e - (t - e) + n;
  }
  function V8(t, e, n, r) {
    return r ? t >= e + n : t <= -n;
  }
  const H8 = (t) => {
    const e = ({ delta: n }) => t(n);
    return {
      start: () => Wr.update(e, true),
      stop: () => fl.update(e)
    };
  };
  function uP(t) {
    var e, n, { from: r, autoplay: i = true, driver: o = H8, elapsed: s = 0, repeat: a = 0, repeatType: l = "loop", repeatDelay: c = 0, onPlay: u, onStop: h, onComplete: p, onRepeat: v, onUpdate: y } = t, x = Mr(t, [
      "from",
      "autoplay",
      "driver",
      "elapsed",
      "repeat",
      "repeatType",
      "repeatDelay",
      "onPlay",
      "onStop",
      "onComplete",
      "onRepeat",
      "onUpdate"
    ]);
    let { to: T } = x, w, k = 0, C = x.duration, P, R = false, L = true, _;
    const F = D8(x);
    !((n = (e = F).needsInterpolation) === null || n === void 0) && n.call(e, r, T) && (_ = tP([
      0,
      100
    ], [
      r,
      T
    ], {
      clamp: false
    }), r = 0, T = 100);
    const K = F(Object.assign(Object.assign({}, x), {
      from: r,
      to: T
    }));
    function Y() {
      k++, l === "reverse" ? (L = k % 2 === 0, s = F8(s, C, c, L)) : (s = cP(s, C, c), l === "mirror" && K.flipTarget()), R = false, v && v();
    }
    function te() {
      w.stop(), p && p();
    }
    function ne(ye) {
      if (L || (ye = -ye), s += ye, !R) {
        const Ce = K.next(Math.max(0, s));
        P = Ce.value, _ && (P = _(P)), R = L ? Ce.done : s <= 0;
      }
      y == null ? void 0 : y(P), R && (k === 0 && (C ?? (C = s)), k < a ? V8(s, C, c, L) && Y() : te());
    }
    function ae() {
      u == null ? void 0 : u(), w = o(ne), w.start();
    }
    return i && ae(), {
      stop: () => {
        h == null ? void 0 : h(), w.stop();
      }
    };
  }
  function fP(t, e) {
    return e ? t * (1e3 / e) : 0;
  }
  function j8({ from: t = 0, velocity: e = 0, min: n, max: r, power: i = 0.8, timeConstant: o = 750, bounceStiffness: s = 500, bounceDamping: a = 10, restDelta: l = 1, modifyTarget: c, driver: u, onUpdate: h, onComplete: p, onStop: v }) {
    let y;
    function x(C) {
      return n !== void 0 && C < n || r !== void 0 && C > r;
    }
    function T(C) {
      return n === void 0 ? r : r === void 0 || Math.abs(n - C) < Math.abs(r - C) ? n : r;
    }
    function w(C) {
      y == null ? void 0 : y.stop(), y = uP(Object.assign(Object.assign({}, C), {
        driver: u,
        onUpdate: (P) => {
          var R;
          h == null ? void 0 : h(P), (R = C.onUpdate) === null || R === void 0 || R.call(C, P);
        },
        onComplete: p,
        onStop: v
      }));
    }
    function k(C) {
      w(Object.assign({
        type: "spring",
        stiffness: s,
        damping: a,
        restDelta: l
      }, C));
    }
    if (x(t))
      k({
        from: t,
        velocity: e,
        to: T(t)
      });
    else {
      let C = i * e + t;
      typeof c < "u" && (C = c(C));
      const P = T(C), R = P === n ? -1 : 1;
      let L, _;
      const F = (K) => {
        L = _, _ = K, e = fP(K - L, mp().delta), (R === 1 && K > P || R === -1 && K < P) && k({
          from: K,
          to: P,
          velocity: e
        });
      };
      w({
        type: "decay",
        from: t,
        velocity: e,
        timeConstant: o,
        power: i,
        restDelta: l,
        modifyTarget: c,
        onUpdate: x(C) ? F : void 0
      });
    }
    return {
      stop: () => y == null ? void 0 : y.stop()
    };
  }
  const Ty = (t) => t.hasOwnProperty("x") && t.hasOwnProperty("y"), hk = (t) => Ty(t) && t.hasOwnProperty("z"), gh = (t, e) => Math.abs(t - e);
  function hP(t, e) {
    if (wy(t) && wy(e))
      return gh(t, e);
    if (Ty(t) && Ty(e)) {
      const n = gh(t.x, e.x), r = gh(t.y, e.y), i = hk(t) && hk(e) ? gh(t.z, e.z) : 0;
      return Math.sqrt(Math.pow(n, 2) + Math.pow(r, 2) + Math.pow(i, 2));
    }
  }
  const dP = (t, e) => 1 - 3 * e + 3 * t, pP = (t, e) => 3 * e - 6 * t, mP = (t) => 3 * t, gp = (t, e, n) => ((dP(e, n) * t + pP(e, n)) * t + mP(e)) * t, gP = (t, e, n) => 3 * dP(e, n) * t * t + 2 * pP(e, n) * t + mP(e), W8 = 1e-7, U8 = 10;
  function K8(t, e, n, r, i) {
    let o, s, a = 0;
    do
      s = e + (n - e) / 2, o = gp(s, r, i) - t, o > 0 ? n = s : e = s;
    while (Math.abs(o) > W8 && ++a < U8);
    return s;
  }
  const q8 = 8, G8 = 1e-3;
  function Y8(t, e, n, r) {
    for (let i = 0; i < q8; ++i) {
      const o = gP(e, n, r);
      if (o === 0)
        return e;
      const s = gp(e, n, r) - t;
      e -= s / o;
    }
    return e;
  }
  const yd = 11, vh = 1 / (yd - 1);
  function X8(t, e, n, r) {
    if (t === e && n === r)
      return cx;
    const i = new Float32Array(yd);
    for (let s = 0; s < yd; ++s)
      i[s] = gp(s * vh, t, n);
    function o(s) {
      let a = 0, l = 1;
      const c = yd - 1;
      for (; l !== c && i[l] <= s; ++l)
        a += vh;
      --l;
      const u = (s - i[l]) / (i[l + 1] - i[l]), h = a + u * vh, p = gP(h, t, n);
      return p >= G8 ? Y8(s, h, t, n) : p === 0 ? h : K8(s, a, a + vh, t, n);
    }
    return (s) => s === 0 || s === 1 ? s : gp(o(s), e, r);
  }
  function Q8(t) {
    var e = t.onTap, n = t.onTapStart, r = t.onTapCancel, i = t.whileTap, o = t.visualElement, s = e || n || r || i, a = z.exports.useRef(false), l = z.exports.useRef(null), c = {
      passive: !(n || e || r || y)
    };
    function u() {
      var x;
      (x = l.current) === null || x === void 0 || x.call(l), l.current = null;
    }
    function h() {
      var x;
      return u(), a.current = false, (x = o.animationState) === null || x === void 0 || x.setActive(tt.Tap, false), !YE();
    }
    function p(x, T) {
      !h() || (XE(o.getInstance(), x.target) ? e == null ? void 0 : e(x, T) : r == null ? void 0 : r(x, T));
    }
    function v(x, T) {
      !h() || (r == null ? void 0 : r(x, T));
    }
    function y(x, T) {
      var w;
      u(), !a.current && (a.current = true, l.current = Lm(qa(window, "pointerup", p, c), qa(window, "pointercancel", v, c)), (w = o.animationState) === null || w === void 0 || w.setActive(tt.Tap, true), n == null ? void 0 : n(x, T));
    }
    hp(o, "pointerdown", s ? y : void 0, c), sx(u);
  }
  var dk = /* @__PURE__ */ new Set();
  function J8(t, e, n) {
    t || dk.has(e) || (console.warn(e), n && console.warn(n), dk.add(e));
  }
  var My = /* @__PURE__ */ new WeakMap(), b0 = /* @__PURE__ */ new WeakMap(), Z8 = function(t) {
    var e;
    (e = My.get(t.target)) === null || e === void 0 || e(t);
  }, eH = function(t) {
    t.forEach(Z8);
  };
  function tH(t) {
    var e = t.root, n = Mr(t, [
      "root"
    ]), r = e || document;
    b0.has(r) || b0.set(r, {});
    var i = b0.get(r), o = JSON.stringify(n);
    return i[o] || (i[o] = new IntersectionObserver(eH, ie({
      root: e
    }, n))), i[o];
  }
  function nH(t, e, n) {
    var r = tH(e);
    return My.set(t, n), r.observe(t), function() {
      My.delete(t), r.unobserve(t);
    };
  }
  function rH(t) {
    var e = t.visualElement, n = t.whileInView, r = t.onViewportEnter, i = t.onViewportLeave, o = t.viewport, s = o === void 0 ? {} : o, a = z.exports.useRef({
      hasEnteredView: false,
      isInView: false
    }), l = Boolean(n || r || i);
    s.once && a.current.hasEnteredView && (l = false);
    var c = typeof IntersectionObserver > "u" ? sH : oH;
    c(l, a.current, e, s);
  }
  var iH = {
    some: 0,
    all: 1
  };
  function oH(t, e, n, r) {
    var i = r.root, o = r.margin, s = r.amount, a = s === void 0 ? "some" : s, l = r.once;
    z.exports.useEffect(function() {
      if (!!t) {
        var c = {
          root: i == null ? void 0 : i.current,
          rootMargin: o,
          threshold: typeof a == "number" ? a : iH[a]
        }, u = function(h) {
          var p, v = h.isIntersecting;
          if (e.isInView !== v && (e.isInView = v, !(l && !v && e.hasEnteredView))) {
            v && (e.hasEnteredView = true), (p = n.animationState) === null || p === void 0 || p.setActive(tt.InView, v);
            var y = n.getProps(), x = v ? y.onViewportEnter : y.onViewportLeave;
            x == null ? void 0 : x(h);
          }
        };
        return nH(n.getInstance(), c, u);
      }
    }, [
      t,
      i,
      o,
      a
    ]);
  }
  function sH(t, e, n, r) {
    var i = r.fallback, o = i === void 0 ? true : i;
    z.exports.useEffect(function() {
      !t || !o || (Yb !== "production" && J8(false, "IntersectionObserver not available on this device. whileInView animations will trigger on mount."), requestAnimationFrame(function() {
        var s;
        e.hasEnteredView = true;
        var a = n.getProps().onViewportEnter;
        a == null ? void 0 : a(null), (s = n.animationState) === null || s === void 0 || s.setActive(tt.InView, true);
      }));
    }, [
      t
    ]);
  }
  var Ro = function(t) {
    return function(e) {
      return t(e), null;
    };
  }, aH = {
    inView: Ro(rH),
    tap: Ro(Q8),
    focus: Ro(F6),
    hover: Ro(X6)
  }, lH = 0, cH = function() {
    return lH++;
  }, vP = function() {
    return ef(cH);
  };
  function yP() {
    var t = z.exports.useContext(Al);
    if (t === null)
      return [
        true,
        null
      ];
    var e = t.isPresent, n = t.onExitComplete, r = t.register, i = vP();
    z.exports.useEffect(function() {
      return r(i);
    }, []);
    var o = function() {
      return n == null ? void 0 : n(i);
    };
    return !e && n ? [
      false,
      o
    ] : [
      true
    ];
  }
  function uH() {
    return fH(z.exports.useContext(Al));
  }
  function fH(t) {
    return t === null ? true : t.isPresent;
  }
  function bP(t, e) {
    if (!Array.isArray(e))
      return false;
    var n = e.length;
    if (n !== t.length)
      return false;
    for (var r = 0; r < n; r++)
      if (e[r] !== t[r])
        return false;
    return true;
  }
  var vp = function(t) {
    return t * 1e3;
  }, hH = {
    linear: cx,
    easeIn: ux,
    easeInOut: iP,
    easeOut: x8,
    circIn: oP,
    circInOut: S8,
    circOut: fx,
    backIn: hx,
    backInOut: k8,
    backOut: w8,
    anticipate: C8,
    bounceIn: E8,
    bounceInOut: P8,
    bounceOut: pp
  }, pk = function(t) {
    if (Array.isArray(t)) {
      lp(t.length === 4);
      var e = kt(t, 4), n = e[0], r = e[1], i = e[2], o = e[3];
      return X8(n, r, i, o);
    } else if (typeof t == "string")
      return hH[t];
    return t;
  }, dH = function(t) {
    return Array.isArray(t) && typeof t[0] != "number";
  }, mk = function(t, e) {
    return t === "zIndex" ? false : !!(typeof e == "number" || Array.isArray(e) || typeof e == "string" && eo.test(e) && !e.startsWith("url("));
  }, ds = function() {
    return {
      type: "spring",
      stiffness: 500,
      damping: 25,
      restSpeed: 10
    };
  }, yh = function(t) {
    return {
      type: "spring",
      stiffness: 550,
      damping: t === 0 ? 2 * Math.sqrt(550) : 30,
      restSpeed: 10
    };
  }, x0 = function() {
    return {
      type: "keyframes",
      ease: "linear",
      duration: 0.3
    };
  }, pH = function(t) {
    return {
      type: "keyframes",
      duration: 0.8,
      values: t
    };
  }, gk = {
    x: ds,
    y: ds,
    z: ds,
    rotate: ds,
    rotateX: ds,
    rotateY: ds,
    rotateZ: ds,
    scaleX: yh,
    scaleY: yh,
    scale: yh,
    opacity: x0,
    backgroundColor: x0,
    color: x0,
    default: yh
  }, mH = function(t, e) {
    var n;
    return Ou(e) ? n = pH : n = gk[t] || gk.default, ie({
      to: e
    }, n(e));
  }, gH = ie(ie({}, LE), {
    color: yn,
    backgroundColor: yn,
    outlineColor: yn,
    fill: yn,
    stroke: yn,
    borderColor: yn,
    borderTopColor: yn,
    borderRightColor: yn,
    borderBottomColor: yn,
    borderLeftColor: yn,
    filter: by,
    WebkitFilter: by
  }), dx = function(t) {
    return gH[t];
  };
  function px(t, e) {
    var n, r = dx(t);
    return r !== by && (r = eo), (n = r.getAnimatableNone) === null || n === void 0 ? void 0 : n.call(r, e);
  }
  var vH = {
    current: false
  };
  function yH(t) {
    t.when, t.delay, t.delayChildren, t.staggerChildren, t.staggerDirection, t.repeat, t.repeatType, t.repeatDelay, t.from;
    var e = Mr(t, [
      "when",
      "delay",
      "delayChildren",
      "staggerChildren",
      "staggerDirection",
      "repeat",
      "repeatType",
      "repeatDelay",
      "from"
    ]);
    return !!Object.keys(e).length;
  }
  function bH(t) {
    var e = t.ease, n = t.times, r = t.yoyo, i = t.flip, o = t.loop, s = Mr(t, [
      "ease",
      "times",
      "yoyo",
      "flip",
      "loop"
    ]), a = ie({}, s);
    return n && (a.offset = n), s.duration && (a.duration = vp(s.duration)), s.repeatDelay && (a.repeatDelay = vp(s.repeatDelay)), e && (a.ease = dH(e) ? e.map(pk) : pk(e)), s.type === "tween" && (a.type = "keyframes"), (r || o || i) && (r ? a.repeatType = "reverse" : o ? a.repeatType = "loop" : i && (a.repeatType = "mirror"), a.repeat = o || r || i || s.repeat), s.type !== "spring" && (a.type = "keyframes"), a;
  }
  function xH(t, e) {
    var n, r, i = mx(t, e) || {};
    return (r = (n = i.delay) !== null && n !== void 0 ? n : t.delay) !== null && r !== void 0 ? r : 0;
  }
  function SH(t) {
    return Array.isArray(t.to) && t.to[0] === null && (t.to = jr([], kt(t.to), false), t.to[0] = t.from), t;
  }
  function wH(t, e, n) {
    var r;
    return Array.isArray(e.to) && ((r = t.duration) !== null && r !== void 0 || (t.duration = 0.8)), SH(e), yH(t) || (t = ie(ie({}, t), mH(n, e.to))), ie(ie({}, e), bH(t));
  }
  function kH(t, e, n, r, i) {
    var o, s = mx(r, t), a = (o = s.from) !== null && o !== void 0 ? o : e.get(), l = mk(t, n);
    a === "none" && l && typeof n == "string" ? a = px(t, n) : vk(a) && typeof n == "string" ? a = yk(n) : !Array.isArray(n) && vk(n) && typeof a == "string" && (n = yk(a));
    var c = mk(t, a);
    function u() {
      var p = {
        from: a,
        to: n,
        velocity: e.getVelocity(),
        onComplete: i,
        onUpdate: function(v) {
          return e.set(v);
        }
      };
      return s.type === "inertia" || s.type === "decay" ? j8(ie(ie({}, p), s)) : uP(ie(ie({}, wH(s, p, t)), {
        onUpdate: function(v) {
          var y;
          p.onUpdate(v), (y = s.onUpdate) === null || y === void 0 || y.call(s, v);
        },
        onComplete: function() {
          var v;
          p.onComplete(), (v = s.onComplete) === null || v === void 0 || v.call(s);
        }
      }));
    }
    function h() {
      var p, v, y = VE(n);
      return e.set(y), i(), (p = s == null ? void 0 : s.onUpdate) === null || p === void 0 || p.call(s, y), (v = s == null ? void 0 : s.onComplete) === null || v === void 0 || v.call(s), {
        stop: function() {
        }
      };
    }
    return !c || !l || s.type === false ? h : u;
  }
  function vk(t) {
    return t === 0 || typeof t == "string" && parseFloat(t) === 0 && t.indexOf(" ") === -1;
  }
  function yk(t) {
    return typeof t == "number" ? 0 : px("", t);
  }
  function mx(t, e) {
    return t[e] || t.default || t;
  }
  function gx(t, e, n, r) {
    return r === void 0 && (r = {}), vH.current && (r = {
      type: false
    }), e.start(function(i) {
      var o, s, a = kH(t, e, n, r, i), l = xH(r, t), c = function() {
        return s = a();
      };
      return l ? o = window.setTimeout(c, vp(l)) : c(), function() {
        clearTimeout(o), s == null ? void 0 : s.stop();
      };
    });
  }
  var CH = function(t) {
    return /^\-?\d*\.?\d+$/.test(t);
  }, TH = function(t) {
    return /^0[^.\s]+$/.test(t);
  };
  function vx(t, e) {
    t.indexOf(e) === -1 && t.push(e);
  }
  function yx(t, e) {
    var n = t.indexOf(e);
    n > -1 && t.splice(n, 1);
  }
  var Wc = function() {
    function t() {
      this.subscriptions = [];
    }
    return t.prototype.add = function(e) {
      var n = this;
      return vx(this.subscriptions, e), function() {
        return yx(n.subscriptions, e);
      };
    }, t.prototype.notify = function(e, n, r) {
      var i = this.subscriptions.length;
      if (!!i)
        if (i === 1)
          this.subscriptions[0](e, n, r);
        else
          for (var o = 0; o < i; o++) {
            var s = this.subscriptions[o];
            s && s(e, n, r);
          }
    }, t.prototype.getSize = function() {
      return this.subscriptions.length;
    }, t.prototype.clear = function() {
      this.subscriptions.length = 0;
    }, t;
  }(), MH = function(t) {
    return !isNaN(parseFloat(t));
  }, AH = function() {
    function t(e) {
      var n = this;
      this.version = "6.5.1", this.timeDelta = 0, this.lastUpdated = 0, this.updateSubscribers = new Wc(), this.velocityUpdateSubscribers = new Wc(), this.renderSubscribers = new Wc(), this.canTrackVelocity = false, this.updateAndNotify = function(r, i) {
        i === void 0 && (i = true), n.prev = n.current, n.current = r;
        var o = mp(), s = o.delta, a = o.timestamp;
        n.lastUpdated !== a && (n.timeDelta = s, n.lastUpdated = a, Wr.postRender(n.scheduleVelocityCheck)), n.prev !== n.current && n.updateSubscribers.notify(n.current), n.velocityUpdateSubscribers.getSize() && n.velocityUpdateSubscribers.notify(n.getVelocity()), i && n.renderSubscribers.notify(n.current);
      }, this.scheduleVelocityCheck = function() {
        return Wr.postRender(n.velocityCheck);
      }, this.velocityCheck = function(r) {
        var i = r.timestamp;
        i !== n.lastUpdated && (n.prev = n.current, n.velocityUpdateSubscribers.notify(n.getVelocity()));
      }, this.hasAnimated = false, this.prev = this.current = e, this.canTrackVelocity = MH(this.current);
    }
    return t.prototype.onChange = function(e) {
      return this.updateSubscribers.add(e);
    }, t.prototype.clearListeners = function() {
      this.updateSubscribers.clear();
    }, t.prototype.onRenderRequest = function(e) {
      return e(this.get()), this.renderSubscribers.add(e);
    }, t.prototype.attach = function(e) {
      this.passiveEffect = e;
    }, t.prototype.set = function(e, n) {
      n === void 0 && (n = true), !n || !this.passiveEffect ? this.updateAndNotify(e, n) : this.passiveEffect(e, this.updateAndNotify);
    }, t.prototype.get = function() {
      return this.current;
    }, t.prototype.getPrevious = function() {
      return this.prev;
    }, t.prototype.getVelocity = function() {
      return this.canTrackVelocity ? fP(parseFloat(this.current) - parseFloat(this.prev), this.timeDelta) : 0;
    }, t.prototype.start = function(e) {
      var n = this;
      return this.stop(), new Promise(function(r) {
        n.hasAnimated = true, n.stopAnimation = e(r);
      }).then(function() {
        return n.clearAnimation();
      });
    }, t.prototype.stop = function() {
      this.stopAnimation && this.stopAnimation(), this.clearAnimation();
    }, t.prototype.isAnimating = function() {
      return !!this.stopAnimation;
    }, t.prototype.clearAnimation = function() {
      this.stopAnimation = null;
    }, t.prototype.destroy = function() {
      this.updateSubscribers.clear(), this.renderSubscribers.clear(), this.stop();
    }, t;
  }();
  function hl(t) {
    return new AH(t);
  }
  var xP = function(t) {
    return function(e) {
      return e.test(t);
    };
  }, EH = {
    test: function(t) {
      return t === "auto";
    },
    parse: function(t) {
      return t;
    }
  }, SP = [
    Js,
    Te,
    Ci,
    go,
    h6,
    f6,
    EH
  ], rc = function(t) {
    return SP.find(xP(t));
  }, PH = jr(jr([], kt(SP), false), [
    yn,
    eo
  ], false), OH = function(t) {
    return PH.find(xP(t));
  };
  function RH(t, e, n) {
    t.hasValue(e) ? t.getValue(e).set(n) : t.addValue(e, hl(n));
  }
  function LH(t, e) {
    var n = Pm(t, e), r = n ? t.makeTargetAnimatable(n, false) : {}, i = r.transitionEnd, o = i === void 0 ? {} : i;
    r.transition;
    var s = Mr(r, [
      "transitionEnd",
      "transition"
    ]);
    s = ie(ie({}, s), o);
    for (var a in s) {
      var l = VE(s[a]);
      RH(t, a, l);
    }
  }
  function _H(t, e, n) {
    var r, i, o, s, a = Object.keys(e).filter(function(v) {
      return !t.hasValue(v);
    }), l = a.length;
    if (!!l)
      for (var c = 0; c < l; c++) {
        var u = a[c], h = e[u], p = null;
        Array.isArray(h) && (p = h[0]), p === null && (p = (i = (r = n[u]) !== null && r !== void 0 ? r : t.readValue(u)) !== null && i !== void 0 ? i : e[u]), p != null && (typeof p == "string" && (CH(p) || TH(p)) ? p = parseFloat(p) : !OH(p) && eo.test(h) && (p = px(u, h)), t.addValue(u, hl(p)), (o = (s = n)[u]) !== null && o !== void 0 || (s[u] = p), t.setBaseTarget(u, p));
      }
  }
  function DH(t, e) {
    if (!!e) {
      var n = e[t] || e.default || e;
      return n.from;
    }
  }
  function IH(t, e, n) {
    var r, i, o = {};
    for (var s in t)
      o[s] = (r = DH(s, e)) !== null && r !== void 0 ? r : (i = n.getValue(s)) === null || i === void 0 ? void 0 : i.get();
    return o;
  }
  function BH(t, e, n) {
    n === void 0 && (n = {}), t.notifyAnimationStart(e);
    var r;
    if (Array.isArray(e)) {
      var i = e.map(function(s) {
        return Ay(t, s, n);
      });
      r = Promise.all(i);
    } else if (typeof e == "string")
      r = Ay(t, e, n);
    else {
      var o = typeof e == "function" ? Pm(t, e, n.custom) : e;
      r = wP(t, o, n);
    }
    return r.then(function() {
      return t.notifyAnimationComplete(e);
    });
  }
  function Ay(t, e, n) {
    var r;
    n === void 0 && (n = {});
    var i = Pm(t, e, n.custom), o = (i || {}).transition, s = o === void 0 ? t.getDefaultTransition() || {} : o;
    n.transitionOverride && (s = n.transitionOverride);
    var a = i ? function() {
      return wP(t, i, n);
    } : function() {
      return Promise.resolve();
    }, l = !((r = t.variantChildren) === null || r === void 0) && r.size ? function(v) {
      v === void 0 && (v = 0);
      var y = s.delayChildren, x = y === void 0 ? 0 : y, T = s.staggerChildren, w = s.staggerDirection;
      return NH(t, e, x + v, T, w, n);
    } : function() {
      return Promise.resolve();
    }, c = s.when;
    if (c) {
      var u = kt(c === "beforeChildren" ? [
        a,
        l
      ] : [
        l,
        a
      ], 2), h = u[0], p = u[1];
      return h().then(p);
    } else
      return Promise.all([
        a(),
        l(n.delay)
      ]);
  }
  function wP(t, e, n) {
    var r, i = n === void 0 ? {} : n, o = i.delay, s = o === void 0 ? 0 : o, a = i.transitionOverride, l = i.type, c = t.makeTargetAnimatable(e), u = c.transition, h = u === void 0 ? t.getDefaultTransition() : u, p = c.transitionEnd, v = Mr(c, [
      "transition",
      "transitionEnd"
    ]);
    a && (h = a);
    var y = [], x = l && ((r = t.animationState) === null || r === void 0 ? void 0 : r.getState()[l]);
    for (var T in v) {
      var w = t.getValue(T), k = v[T];
      if (!(!w || k === void 0 || x && zH(x, T))) {
        var C = ie({
          delay: s
        }, h);
        t.shouldReduceMotion && tf(T) && (C = ie(ie({}, C), {
          type: false,
          delay: 0
        }));
        var P = gx(T, w, k, C);
        y.push(P);
      }
    }
    return Promise.all(y).then(function() {
      p && LH(t, p);
    });
  }
  function NH(t, e, n, r, i, o) {
    n === void 0 && (n = 0), r === void 0 && (r = 0), i === void 0 && (i = 1);
    var s = [], a = (t.variantChildren.size - 1) * r, l = i === 1 ? function(c) {
      return c === void 0 && (c = 0), c * r;
    } : function(c) {
      return c === void 0 && (c = 0), a - c * r;
    };
    return Array.from(t.variantChildren).sort($H).forEach(function(c, u) {
      s.push(Ay(c, e, ie(ie({}, o), {
        delay: n + l(u)
      })).then(function() {
        return c.notifyAnimationComplete(e);
      }));
    }), Promise.all(s);
  }
  function $H(t, e) {
    return t.sortNodePosition(e);
  }
  function zH(t, e) {
    var n = t.protectedKeys, r = t.needsAnimating, i = n.hasOwnProperty(e) && r[e] !== true;
    return r[e] = false, i;
  }
  var bx = [
    tt.Animate,
    tt.InView,
    tt.Focus,
    tt.Hover,
    tt.Tap,
    tt.Drag,
    tt.Exit
  ], FH = jr([], kt(bx), false).reverse(), VH = bx.length;
  function HH(t) {
    return function(e) {
      return Promise.all(e.map(function(n) {
        var r = n.animation, i = n.options;
        return BH(t, r, i);
      }));
    };
  }
  function jH(t) {
    var e = HH(t), n = UH(), r = {}, i = true, o = function(u, h) {
      var p = Pm(t, h);
      if (p) {
        p.transition;
        var v = p.transitionEnd, y = Mr(p, [
          "transition",
          "transitionEnd"
        ]);
        u = ie(ie(ie({}, u), y), v);
      }
      return u;
    };
    function s(u) {
      return r[u] !== void 0;
    }
    function a(u) {
      e = u(t);
    }
    function l(u, h) {
      for (var p, v = t.getProps(), y = t.getVariantContext(true) || {}, x = [], T = /* @__PURE__ */ new Set(), w = {}, k = 1 / 0, C = function(_) {
        var F = FH[_], K = n[F], Y = (p = v[F]) !== null && p !== void 0 ? p : y[F], te = Br(Y), ne = F === h ? K.isActive : null;
        ne === false && (k = _);
        var ae = Y === y[F] && Y !== v[F] && te;
        if (ae && i && t.manuallyAnimateOnMount && (ae = false), K.protectedKeys = ie({}, w), !K.isActive && ne === null || !Y && !K.prevProp || ix(Y) || typeof Y == "boolean")
          return "continue";
        var ye = WH(K.prevProp, Y), Ce = ye || F === h && K.isActive && !ae && te || _ > k && te, Re = Array.isArray(Y) ? Y : [
          Y
        ], ee = Re.reduce(o, {});
        ne === false && (ee = {});
        var V = K.prevResolvedValues, oe = V === void 0 ? {} : V, de = ie(ie({}, oe), ee), Se = function(se) {
          Ce = true, T.delete(se), K.needsAnimating[se] = true;
        };
        for (var ve in de) {
          var le = ee[ve], re = oe[ve];
          w.hasOwnProperty(ve) || (le !== re ? Ou(le) && Ou(re) ? !bP(le, re) || ye ? Se(ve) : K.protectedKeys[ve] = true : le !== void 0 ? Se(ve) : T.add(ve) : le !== void 0 && T.has(ve) ? Se(ve) : K.protectedKeys[ve] = true);
        }
        K.prevProp = Y, K.prevResolvedValues = ee, K.isActive && (w = ie(ie({}, w), ee)), i && t.blockInitialAnimation && (Ce = false), Ce && !ae && x.push.apply(x, jr([], kt(Re.map(function(se) {
          return {
            animation: se,
            options: ie({
              type: F
            }, u)
          };
        })), false));
      }, P = 0; P < VH; P++)
        C(P);
      if (r = ie({}, w), T.size) {
        var R = {};
        T.forEach(function(_) {
          var F = t.getBaseTarget(_);
          F !== void 0 && (R[_] = F);
        }), x.push({
          animation: R
        });
      }
      var L = Boolean(x.length);
      return i && v.initial === false && !t.manuallyAnimateOnMount && (L = false), i = false, L ? e(x) : Promise.resolve();
    }
    function c(u, h, p) {
      var v;
      if (n[u].isActive === h)
        return Promise.resolve();
      (v = t.variantChildren) === null || v === void 0 || v.forEach(function(T) {
        var w;
        return (w = T.animationState) === null || w === void 0 ? void 0 : w.setActive(u, h);
      }), n[u].isActive = h;
      var y = l(p, u);
      for (var x in n)
        n[x].protectedKeys = {};
      return y;
    }
    return {
      isAnimated: s,
      animateChanges: l,
      setActive: c,
      setAnimateFunction: a,
      getState: function() {
        return n;
      }
    };
  }
  function WH(t, e) {
    return typeof e == "string" ? e !== t : yE(e) ? !bP(e, t) : false;
  }
  function ps(t) {
    return t === void 0 && (t = false), {
      isActive: t,
      protectedKeys: {},
      needsAnimating: {},
      prevResolvedValues: {}
    };
  }
  function UH() {
    var t;
    return t = {}, t[tt.Animate] = ps(true), t[tt.InView] = ps(), t[tt.Hover] = ps(), t[tt.Tap] = ps(), t[tt.Drag] = ps(), t[tt.Focus] = ps(), t[tt.Exit] = ps(), t;
  }
  var KH = {
    animation: Ro(function(t) {
      var e = t.visualElement, n = t.animate;
      e.animationState || (e.animationState = jH(e)), ix(n) && z.exports.useEffect(function() {
        return n.subscribe(e);
      }, [
        n
      ]);
    }),
    exit: Ro(function(t) {
      var e = t.custom, n = t.visualElement, r = kt(yP(), 2), i = r[0], o = r[1], s = z.exports.useContext(Al);
      z.exports.useEffect(function() {
        var a, l;
        n.isPresent = i;
        var c = (a = n.animationState) === null || a === void 0 ? void 0 : a.setActive(tt.Exit, !i, {
          custom: (l = s == null ? void 0 : s.custom) !== null && l !== void 0 ? l : e
        });
        !i && (c == null ? void 0 : c.then(o));
      }, [
        i
      ]);
    })
  }, kP = function() {
    function t(e, n, r) {
      var i = this, o = r === void 0 ? {} : r, s = o.transformPagePoint;
      if (this.startEvent = null, this.lastMoveEvent = null, this.lastMoveEventInfo = null, this.handlers = {}, this.updatePoint = function() {
        if (!!(i.lastMoveEvent && i.lastMoveEventInfo)) {
          var p = w0(i.lastMoveEventInfo, i.history), v = i.startEvent !== null, y = hP(p.offset, {
            x: 0,
            y: 0
          }) >= 3;
          if (!(!v && !y)) {
            var x = p.point, T = mp().timestamp;
            i.history.push(ie(ie({}, x), {
              timestamp: T
            }));
            var w = i.handlers, k = w.onStart, C = w.onMove;
            v || (k && k(i.lastMoveEvent, p), i.startEvent = i.lastMoveEvent), C && C(i.lastMoveEvent, p);
          }
        }
      }, this.handlePointerMove = function(p, v) {
        if (i.lastMoveEvent = p, i.lastMoveEventInfo = S0(v, i.transformPagePoint), jE(p) && p.buttons === 0) {
          i.handlePointerUp(p, v);
          return;
        }
        Wr.update(i.updatePoint, true);
      }, this.handlePointerUp = function(p, v) {
        i.end();
        var y = i.handlers, x = y.onEnd, T = y.onSessionEnd, w = w0(S0(v, i.transformPagePoint), i.history);
        i.startEvent && x && x(p, w), T && T(p, w);
      }, !(WE(e) && e.touches.length > 1)) {
        this.handlers = n, this.transformPagePoint = s;
        var a = ox(e), l = S0(a, this.transformPagePoint), c = l.point, u = mp().timestamp;
        this.history = [
          ie(ie({}, c), {
            timestamp: u
          })
        ];
        var h = n.onSessionStart;
        h && h(e, w0(l, this.history)), this.removeListeners = Lm(qa(window, "pointermove", this.handlePointerMove), qa(window, "pointerup", this.handlePointerUp), qa(window, "pointercancel", this.handlePointerUp));
      }
    }
    return t.prototype.updateHandlers = function(e) {
      this.handlers = e;
    }, t.prototype.end = function() {
      this.removeListeners && this.removeListeners(), fl.update(this.updatePoint);
    }, t;
  }();
  function S0(t, e) {
    return e ? {
      point: e(t.point)
    } : t;
  }
  function bk(t, e) {
    return {
      x: t.x - e.x,
      y: t.y - e.y
    };
  }
  function w0(t, e) {
    var n = t.point;
    return {
      point: n,
      delta: bk(n, CP(e)),
      offset: bk(n, qH(e)),
      velocity: GH(e, 0.1)
    };
  }
  function qH(t) {
    return t[0];
  }
  function CP(t) {
    return t[t.length - 1];
  }
  function GH(t, e) {
    if (t.length < 2)
      return {
        x: 0,
        y: 0
      };
    for (var n = t.length - 1, r = null, i = CP(t); n >= 0 && (r = t[n], !(i.timestamp - r.timestamp > vp(e))); )
      n--;
    if (!r)
      return {
        x: 0,
        y: 0
      };
    var o = (i.timestamp - r.timestamp) / 1e3;
    if (o === 0)
      return {
        x: 0,
        y: 0
      };
    var s = {
      x: (i.x - r.x) / o,
      y: (i.y - r.y) / o
    };
    return s.x === 1 / 0 && (s.x = 0), s.y === 1 / 0 && (s.y = 0), s;
  }
  function to(t) {
    return t.max - t.min;
  }
  function xk(t, e, n) {
    return e === void 0 && (e = 0), n === void 0 && (n = 0.01), hP(t, e) < n;
  }
  function Sk(t, e, n, r) {
    r === void 0 && (r = 0.5), t.origin = r, t.originPoint = wt(e.min, e.max, t.origin), t.scale = to(n) / to(e), (xk(t.scale, 1, 1e-4) || isNaN(t.scale)) && (t.scale = 1), t.translate = wt(n.min, n.max, t.origin) - t.originPoint, (xk(t.translate) || isNaN(t.translate)) && (t.translate = 0);
  }
  function Uc(t, e, n, r) {
    Sk(t.x, e.x, n.x, r == null ? void 0 : r.originX), Sk(t.y, e.y, n.y, r == null ? void 0 : r.originY);
  }
  function wk(t, e, n) {
    t.min = n.min + e.min, t.max = t.min + to(e);
  }
  function YH(t, e, n) {
    wk(t.x, e.x, n.x), wk(t.y, e.y, n.y);
  }
  function kk(t, e, n) {
    t.min = e.min - n.min, t.max = t.min + to(e);
  }
  function Kc(t, e, n) {
    kk(t.x, e.x, n.x), kk(t.y, e.y, n.y);
  }
  function XH(t, e, n) {
    var r = e.min, i = e.max;
    return r !== void 0 && t < r ? t = n ? wt(r, t, n.min) : Math.max(t, r) : i !== void 0 && t > i && (t = n ? wt(i, t, n.max) : Math.min(t, i)), t;
  }
  function Ck(t, e, n) {
    return {
      min: e !== void 0 ? t.min + e : void 0,
      max: n !== void 0 ? t.max + n - (t.max - t.min) : void 0
    };
  }
  function QH(t, e) {
    var n = e.top, r = e.left, i = e.bottom, o = e.right;
    return {
      x: Ck(t.x, r, o),
      y: Ck(t.y, n, i)
    };
  }
  function Tk(t, e) {
    var n, r = e.min - t.min, i = e.max - t.max;
    return e.max - e.min < t.max - t.min && (n = kt([
      i,
      r
    ], 2), r = n[0], i = n[1]), {
      min: r,
      max: i
    };
  }
  function JH(t, e) {
    return {
      x: Tk(t.x, e.x),
      y: Tk(t.y, e.y)
    };
  }
  function ZH(t, e) {
    var n = 0.5, r = to(t), i = to(e);
    return i > r ? n = Ru(e.min, e.max - r, t.min) : r > i && (n = Ru(t.min, t.max - i, e.min)), dp(0, 1, n);
  }
  function e9(t, e) {
    var n = {};
    return e.min !== void 0 && (n.min = e.min - t.min), e.max !== void 0 && (n.max = e.max - t.min), n;
  }
  var Ey = 0.35;
  function t9(t) {
    return t === void 0 && (t = Ey), t === false ? t = 0 : t === true && (t = Ey), {
      x: Mk(t, "left", "right"),
      y: Mk(t, "top", "bottom")
    };
  }
  function Mk(t, e, n) {
    return {
      min: Ak(t, e),
      max: Ak(t, n)
    };
  }
  function Ak(t, e) {
    var n;
    return typeof t == "number" ? t : (n = t[e]) !== null && n !== void 0 ? n : 0;
  }
  var Ek = function() {
    return {
      translate: 0,
      scale: 1,
      origin: 0,
      originPoint: 0
    };
  }, qc = function() {
    return {
      x: Ek(),
      y: Ek()
    };
  }, Pk = function() {
    return {
      min: 0,
      max: 0
    };
  }, cn = function() {
    return {
      x: Pk(),
      y: Pk()
    };
  };
  function li(t) {
    return [
      t("x"),
      t("y")
    ];
  }
  function TP(t) {
    var e = t.top, n = t.left, r = t.right, i = t.bottom;
    return {
      x: {
        min: n,
        max: r
      },
      y: {
        min: e,
        max: i
      }
    };
  }
  function n9(t) {
    var e = t.x, n = t.y;
    return {
      top: n.min,
      right: e.max,
      bottom: n.max,
      left: e.min
    };
  }
  function r9(t, e) {
    if (!e)
      return t;
    var n = e({
      x: t.left,
      y: t.top
    }), r = e({
      x: t.right,
      y: t.bottom
    });
    return {
      top: n.y,
      left: n.x,
      bottom: r.y,
      right: r.x
    };
  }
  function k0(t) {
    return t === void 0 || t === 1;
  }
  function MP(t) {
    var e = t.scale, n = t.scaleX, r = t.scaleY;
    return !k0(e) || !k0(n) || !k0(r);
  }
  function vo(t) {
    return MP(t) || Ok(t.x) || Ok(t.y) || t.z || t.rotate || t.rotateX || t.rotateY;
  }
  function Ok(t) {
    return t && t !== "0%";
  }
  function yp(t, e, n) {
    var r = t - n, i = e * r;
    return n + i;
  }
  function Rk(t, e, n, r, i) {
    return i !== void 0 && (t = yp(t, i, r)), yp(t, n, r) + e;
  }
  function Py(t, e, n, r, i) {
    e === void 0 && (e = 0), n === void 0 && (n = 1), t.min = Rk(t.min, e, n, r, i), t.max = Rk(t.max, e, n, r, i);
  }
  function AP(t, e) {
    var n = e.x, r = e.y;
    Py(t.x, n.translate, n.scale, n.originPoint), Py(t.y, r.translate, r.scale, r.originPoint);
  }
  function i9(t, e, n, r) {
    var i, o;
    r === void 0 && (r = false);
    var s = n.length;
    if (!!s) {
      e.x = e.y = 1;
      for (var a, l, c = 0; c < s; c++)
        a = n[c], l = a.projectionDelta, ((o = (i = a.instance) === null || i === void 0 ? void 0 : i.style) === null || o === void 0 ? void 0 : o.display) !== "contents" && (r && a.options.layoutScroll && a.scroll && a !== a.root && La(t, {
          x: -a.scroll.x,
          y: -a.scroll.y
        }), l && (e.x *= l.x.scale, e.y *= l.y.scale, AP(t, l)), r && vo(a.latestValues) && La(t, a.latestValues));
    }
  }
  function xo(t, e) {
    t.min = t.min + e, t.max = t.max + e;
  }
  function Lk(t, e, n) {
    var r = kt(n, 3), i = r[0], o = r[1], s = r[2], a = e[s] !== void 0 ? e[s] : 0.5, l = wt(t.min, t.max, a);
    Py(t, e[i], e[o], l, e.scale);
  }
  var o9 = [
    "x",
    "scaleX",
    "originX"
  ], s9 = [
    "y",
    "scaleY",
    "originY"
  ];
  function La(t, e) {
    Lk(t.x, e, o9), Lk(t.y, e, s9);
  }
  function EP(t, e) {
    return TP(r9(t.getBoundingClientRect(), e));
  }
  function a9(t, e, n) {
    var r = EP(t, n), i = e.scroll;
    return i && (xo(r.x, i.x), xo(r.y, i.y)), r;
  }
  var l9 = /* @__PURE__ */ new WeakMap(), c9 = function() {
    function t(e) {
      this.openGlobalLock = null, this.isDragging = false, this.currentDirection = null, this.originPoint = {
        x: 0,
        y: 0
      }, this.constraints = false, this.hasMutatedConstraints = false, this.elastic = cn(), this.visualElement = e;
    }
    return t.prototype.start = function(e, n) {
      var r = this, i = n === void 0 ? {} : n, o = i.snapToCursor, s = o === void 0 ? false : o;
      if (this.visualElement.isPresent !== false) {
        var a = function(h) {
          r.stopAnimation(), s && r.snapToCursor(ox(h, "page").point);
        }, l = function(h, p) {
          var v, y = r.getProps(), x = y.drag, T = y.dragPropagation, w = y.onDragStart;
          x && !T && (r.openGlobalLock && r.openGlobalLock(), r.openGlobalLock = GE(x), !r.openGlobalLock) || (r.isDragging = true, r.currentDirection = null, r.resolveConstraints(), r.visualElement.projection && (r.visualElement.projection.isAnimationBlocked = true, r.visualElement.projection.target = void 0), li(function(k) {
            var C, P, R = r.getAxisMotionValue(k).get() || 0;
            if (Ci.test(R)) {
              var L = (P = (C = r.visualElement.projection) === null || C === void 0 ? void 0 : C.layout) === null || P === void 0 ? void 0 : P.actual[k];
              if (L) {
                var _ = to(L);
                R = _ * (parseFloat(R) / 100);
              }
            }
            r.originPoint[k] = R;
          }), w == null ? void 0 : w(h, p), (v = r.visualElement.animationState) === null || v === void 0 || v.setActive(tt.Drag, true));
        }, c = function(h, p) {
          var v = r.getProps(), y = v.dragPropagation, x = v.dragDirectionLock, T = v.onDirectionLock, w = v.onDrag;
          if (!(!y && !r.openGlobalLock)) {
            var k = p.offset;
            if (x && r.currentDirection === null) {
              r.currentDirection = u9(k), r.currentDirection !== null && (T == null ? void 0 : T(r.currentDirection));
              return;
            }
            r.updateAxis("x", p.point, k), r.updateAxis("y", p.point, k), r.visualElement.syncRender(), w == null ? void 0 : w(h, p);
          }
        }, u = function(h, p) {
          return r.stop(h, p);
        };
        this.panSession = new kP(e, {
          onSessionStart: a,
          onStart: l,
          onMove: c,
          onSessionEnd: u
        }, {
          transformPagePoint: this.visualElement.getTransformPagePoint()
        });
      }
    }, t.prototype.stop = function(e, n) {
      var r = this.isDragging;
      if (this.cancel(), !!r) {
        var i = n.velocity;
        this.startAnimation(i);
        var o = this.getProps().onDragEnd;
        o == null ? void 0 : o(e, n);
      }
    }, t.prototype.cancel = function() {
      var e, n;
      this.isDragging = false, this.visualElement.projection && (this.visualElement.projection.isAnimationBlocked = false), (e = this.panSession) === null || e === void 0 || e.end(), this.panSession = void 0;
      var r = this.getProps().dragPropagation;
      !r && this.openGlobalLock && (this.openGlobalLock(), this.openGlobalLock = null), (n = this.visualElement.animationState) === null || n === void 0 || n.setActive(tt.Drag, false);
    }, t.prototype.updateAxis = function(e, n, r) {
      var i = this.getProps().drag;
      if (!(!r || !bh(e, i, this.currentDirection))) {
        var o = this.getAxisMotionValue(e), s = this.originPoint[e] + r[e];
        this.constraints && this.constraints[e] && (s = XH(s, this.constraints[e], this.elastic[e])), o.set(s);
      }
    }, t.prototype.resolveConstraints = function() {
      var e = this, n = this.getProps(), r = n.dragConstraints, i = n.dragElastic, o = (this.visualElement.projection || {}).layout, s = this.constraints;
      r && Ra(r) ? this.constraints || (this.constraints = this.resolveRefConstraints()) : r && o ? this.constraints = QH(o.actual, r) : this.constraints = false, this.elastic = t9(i), s !== this.constraints && o && this.constraints && !this.hasMutatedConstraints && li(function(a) {
        e.getAxisMotionValue(a) && (e.constraints[a] = e9(o.actual[a], e.constraints[a]));
      });
    }, t.prototype.resolveRefConstraints = function() {
      var e = this.getProps(), n = e.dragConstraints, r = e.onMeasureDragConstraints;
      if (!n || !Ra(n))
        return false;
      var i = n.current, o = this.visualElement.projection;
      if (!o || !o.layout)
        return false;
      var s = a9(i, o.root, this.visualElement.getTransformPagePoint()), a = JH(o.layout.actual, s);
      if (r) {
        var l = r(n9(a));
        this.hasMutatedConstraints = !!l, l && (a = TP(l));
      }
      return a;
    }, t.prototype.startAnimation = function(e) {
      var n = this, r = this.getProps(), i = r.drag, o = r.dragMomentum, s = r.dragElastic, a = r.dragTransition, l = r.dragSnapToOrigin, c = r.onDragTransitionEnd, u = this.constraints || {}, h = li(function(p) {
        var v;
        if (!!bh(p, i, n.currentDirection)) {
          var y = (v = u == null ? void 0 : u[p]) !== null && v !== void 0 ? v : {};
          l && (y = {
            min: 0,
            max: 0
          });
          var x = s ? 200 : 1e6, T = s ? 40 : 1e7, w = ie(ie({
            type: "inertia",
            velocity: o ? e[p] : 0,
            bounceStiffness: x,
            bounceDamping: T,
            timeConstant: 750,
            restDelta: 1,
            restSpeed: 10
          }, a), y);
          return n.startAxisValueAnimation(p, w);
        }
      });
      return Promise.all(h).then(c);
    }, t.prototype.startAxisValueAnimation = function(e, n) {
      var r = this.getAxisMotionValue(e);
      return gx(e, r, 0, n);
    }, t.prototype.stopAnimation = function() {
      var e = this;
      li(function(n) {
        return e.getAxisMotionValue(n).stop();
      });
    }, t.prototype.getAxisMotionValue = function(e) {
      var n, r, i = "_drag" + e.toUpperCase(), o = this.visualElement.getProps()[i];
      return o || this.visualElement.getValue(e, (r = (n = this.visualElement.getProps().initial) === null || n === void 0 ? void 0 : n[e]) !== null && r !== void 0 ? r : 0);
    }, t.prototype.snapToCursor = function(e) {
      var n = this;
      li(function(r) {
        var i = n.getProps().drag;
        if (!!bh(r, i, n.currentDirection)) {
          var o = n.visualElement.projection, s = n.getAxisMotionValue(r);
          if (o && o.layout) {
            var a = o.layout.actual[r], l = a.min, c = a.max;
            s.set(e[r] - wt(l, c, 0.5));
          }
        }
      });
    }, t.prototype.scalePositionWithinConstraints = function() {
      var e = this, n, r = this.getProps(), i = r.drag, o = r.dragConstraints, s = this.visualElement.projection;
      if (!(!Ra(o) || !s || !this.constraints)) {
        this.stopAnimation();
        var a = {
          x: 0,
          y: 0
        };
        li(function(c) {
          var u = e.getAxisMotionValue(c);
          if (u) {
            var h = u.get();
            a[c] = ZH({
              min: h,
              max: h
            }, e.constraints[c]);
          }
        });
        var l = this.visualElement.getProps().transformTemplate;
        this.visualElement.getInstance().style.transform = l ? l({}, "") : "none", (n = s.root) === null || n === void 0 || n.updateScroll(), s.updateLayout(), this.resolveConstraints(), li(function(c) {
          if (!!bh(c, i, null)) {
            var u = e.getAxisMotionValue(c), h = e.constraints[c], p = h.min, v = h.max;
            u.set(wt(p, v, a[c]));
          }
        });
      }
    }, t.prototype.addListeners = function() {
      var e = this, n;
      l9.set(this.visualElement, this);
      var r = this.visualElement.getInstance(), i = qa(r, "pointerdown", function(c) {
        var u = e.getProps(), h = u.drag, p = u.dragListener, v = p === void 0 ? true : p;
        h && v && e.start(c);
      }), o = function() {
        var c = e.getProps().dragConstraints;
        Ra(c) && (e.constraints = e.resolveRefConstraints());
      }, s = this.visualElement.projection, a = s.addEventListener("measure", o);
      s && !s.layout && ((n = s.root) === null || n === void 0 || n.updateScroll(), s.updateLayout()), o();
      var l = Rm(window, "resize", function() {
        return e.scalePositionWithinConstraints();
      });
      return s.addEventListener("didUpdate", function(c) {
        var u = c.delta, h = c.hasLayoutChanged;
        e.isDragging && h && (li(function(p) {
          var v = e.getAxisMotionValue(p);
          !v || (e.originPoint[p] += u[p].translate, v.set(v.get() + u[p].translate));
        }), e.visualElement.syncRender());
      }), function() {
        l(), i(), a();
      };
    }, t.prototype.getProps = function() {
      var e = this.visualElement.getProps(), n = e.drag, r = n === void 0 ? false : n, i = e.dragDirectionLock, o = i === void 0 ? false : i, s = e.dragPropagation, a = s === void 0 ? false : s, l = e.dragConstraints, c = l === void 0 ? false : l, u = e.dragElastic, h = u === void 0 ? Ey : u, p = e.dragMomentum, v = p === void 0 ? true : p;
      return ie(ie({}, e), {
        drag: r,
        dragDirectionLock: o,
        dragPropagation: a,
        dragConstraints: c,
        dragElastic: h,
        dragMomentum: v
      });
    }, t;
  }();
  function bh(t, e, n) {
    return (e === true || e === t) && (n === null || n === t);
  }
  function u9(t, e) {
    e === void 0 && (e = 10);
    var n = null;
    return Math.abs(t.y) > e ? n = "y" : Math.abs(t.x) > e && (n = "x"), n;
  }
  function f9(t) {
    var e = t.dragControls, n = t.visualElement, r = ef(function() {
      return new c9(n);
    });
    z.exports.useEffect(function() {
      return e && e.subscribe(r);
    }, [
      r,
      e
    ]), z.exports.useEffect(function() {
      return r.addListeners();
    }, [
      r
    ]);
  }
  function h9(t) {
    var e = t.onPan, n = t.onPanStart, r = t.onPanEnd, i = t.onPanSessionStart, o = t.visualElement, s = e || n || r || i, a = z.exports.useRef(null), l = z.exports.useContext(Xb).transformPagePoint, c = {
      onSessionStart: i,
      onStart: n,
      onMove: e,
      onEnd: function(h, p) {
        a.current = null, r && r(h, p);
      }
    };
    z.exports.useEffect(function() {
      a.current !== null && a.current.updateHandlers(c);
    });
    function u(h) {
      a.current = new kP(h, c, {
        transformPagePoint: l
      });
    }
    hp(o, "pointerdown", s && u), sx(function() {
      return a.current && a.current.end();
    });
  }
  var d9 = {
    pan: Ro(h9),
    drag: Ro(f9)
  }, xh = [
    "LayoutMeasure",
    "BeforeLayoutMeasure",
    "LayoutUpdate",
    "ViewportBoxUpdate",
    "Update",
    "Render",
    "AnimationComplete",
    "LayoutAnimationComplete",
    "AnimationStart",
    "LayoutAnimationStart",
    "SetAxisTarget",
    "Unmount"
  ];
  function p9() {
    var t = xh.map(function() {
      return new Wc();
    }), e = {}, n = {
      clearAllListeners: function() {
        return t.forEach(function(r) {
          return r.clear();
        });
      },
      updatePropListeners: function(r) {
        xh.forEach(function(i) {
          var o, s = "on" + i, a = r[s];
          (o = e[i]) === null || o === void 0 || o.call(e), a && (e[i] = n[s](a));
        });
      }
    };
    return t.forEach(function(r, i) {
      n["on" + xh[i]] = function(o) {
        return r.add(o);
      }, n["notify" + xh[i]] = function() {
        for (var o = [], s = 0; s < arguments.length; s++)
          o[s] = arguments[s];
        return r.notify.apply(r, jr([], kt(o), false));
      };
    }), n;
  }
  function m9(t, e, n) {
    var r;
    for (var i in e) {
      var o = e[i], s = n[i];
      if (Zi(o))
        t.addValue(i, o);
      else if (Zi(s))
        t.addValue(i, hl(o));
      else if (s !== o)
        if (t.hasValue(i)) {
          var a = t.getValue(i);
          !a.hasAnimated && a.set(o);
        } else
          t.addValue(i, hl((r = t.getStaticValue(i)) !== null && r !== void 0 ? r : o));
    }
    for (var i in n)
      e[i] === void 0 && t.removeValue(i);
    return e;
  }
  var PP = function(t) {
    var e = t.treeType, n = e === void 0 ? "" : e, r = t.build, i = t.getBaseTarget, o = t.makeTargetAnimatable, s = t.measureViewportBox, a = t.render, l = t.readValueFromInstance, c = t.removeValueFromRenderState, u = t.sortNodePosition, h = t.scrapeMotionValuesFromProps;
    return function(p, v) {
      var y = p.parent, x = p.props, T = p.presenceId, w = p.blockInitialAnimation, k = p.visualState, C = p.shouldReduceMotion;
      v === void 0 && (v = {});
      var P = false, R = k.latestValues, L = k.renderState, _, F = p9(), K = /* @__PURE__ */ new Map(), Y = /* @__PURE__ */ new Map(), te = {}, ne = ie({}, R), ae;
      function ye() {
        !_ || !P || (Ce(), a(_, L, x.style, le.projection));
      }
      function Ce() {
        r(le, L, R, v, x);
      }
      function Re() {
        F.notifyUpdate(R);
      }
      function ee(re, se) {
        var _e2 = se.onChange(function(En) {
          R[re] = En, x.onUpdate && Wr.update(Re, false, true);
        }), yt = se.onRenderRequest(le.scheduleRender);
        Y.set(re, function() {
          _e2(), yt();
        });
      }
      var V = h(x);
      for (var oe in V) {
        var de = V[oe];
        R[oe] !== void 0 && Zi(de) && de.set(R[oe], false);
      }
      var Se = Om(x), ve = xE(x), le = ie(ie({
        treeType: n,
        current: null,
        depth: y ? y.depth + 1 : 0,
        parent: y,
        children: /* @__PURE__ */ new Set(),
        presenceId: T,
        shouldReduceMotion: C,
        variantChildren: ve ? /* @__PURE__ */ new Set() : void 0,
        isVisible: void 0,
        manuallyAnimateOnMount: Boolean(y == null ? void 0 : y.isMounted()),
        blockInitialAnimation: w,
        isMounted: function() {
          return Boolean(_);
        },
        mount: function(re) {
          P = true, _ = le.current = re, le.projection && le.projection.mount(re), ve && y && !Se && (ae = y == null ? void 0 : y.addVariantChild(le)), K.forEach(function(se, _e2) {
            return ee(_e2, se);
          }), y == null ? void 0 : y.children.add(le), le.setProps(x);
        },
        unmount: function() {
          var re;
          (re = le.projection) === null || re === void 0 || re.unmount(), fl.update(Re), fl.render(ye), Y.forEach(function(se) {
            return se();
          }), ae == null ? void 0 : ae(), y == null ? void 0 : y.children.delete(le), F.clearAllListeners(), _ = void 0, P = false;
        },
        addVariantChild: function(re) {
          var se, _e2 = le.getClosestVariantNode();
          if (_e2)
            return (se = _e2.variantChildren) === null || se === void 0 || se.add(re), function() {
              return _e2.variantChildren.delete(re);
            };
        },
        sortNodePosition: function(re) {
          return !u || n !== re.treeType ? 0 : u(le.getInstance(), re.getInstance());
        },
        getClosestVariantNode: function() {
          return ve ? le : y == null ? void 0 : y.getClosestVariantNode();
        },
        getLayoutId: function() {
          return x.layoutId;
        },
        getInstance: function() {
          return _;
        },
        getStaticValue: function(re) {
          return R[re];
        },
        setStaticValue: function(re, se) {
          return R[re] = se;
        },
        getLatestValues: function() {
          return R;
        },
        setVisibility: function(re) {
          le.isVisible !== re && (le.isVisible = re, le.scheduleRender());
        },
        makeTargetAnimatable: function(re, se) {
          return se === void 0 && (se = true), o(le, re, x, se);
        },
        measureViewportBox: function() {
          return s(_, x);
        },
        addValue: function(re, se) {
          le.hasValue(re) && le.removeValue(re), K.set(re, se), R[re] = se.get(), ee(re, se);
        },
        removeValue: function(re) {
          var se;
          K.delete(re), (se = Y.get(re)) === null || se === void 0 || se(), Y.delete(re), delete R[re], c(re, L);
        },
        hasValue: function(re) {
          return K.has(re);
        },
        getValue: function(re, se) {
          var _e2 = K.get(re);
          return _e2 === void 0 && se !== void 0 && (_e2 = hl(se), le.addValue(re, _e2)), _e2;
        },
        forEachValue: function(re) {
          return K.forEach(re);
        },
        readValue: function(re) {
          var se;
          return (se = R[re]) !== null && se !== void 0 ? se : l(_, re, v);
        },
        setBaseTarget: function(re, se) {
          ne[re] = se;
        },
        getBaseTarget: function(re) {
          if (i) {
            var se = i(x, re);
            if (se !== void 0 && !Zi(se))
              return se;
          }
          return ne[re];
        }
      }, F), {
        build: function() {
          return Ce(), L;
        },
        scheduleRender: function() {
          Wr.render(ye, false, true);
        },
        syncRender: ye,
        setProps: function(re) {
          (re.transformTemplate || x.transformTemplate) && le.scheduleRender(), x = re, F.updatePropListeners(re), te = m9(le, h(x), te);
        },
        getProps: function() {
          return x;
        },
        getVariant: function(re) {
          var se;
          return (se = x.variants) === null || se === void 0 ? void 0 : se[re];
        },
        getDefaultTransition: function() {
          return x.transition;
        },
        getTransformPagePoint: function() {
          return x.transformPagePoint;
        },
        getVariantContext: function(re) {
          if (re === void 0 && (re = false), re)
            return y == null ? void 0 : y.getVariantContext();
          if (!Se) {
            var se = (y == null ? void 0 : y.getVariantContext()) || {};
            return x.initial !== void 0 && (se.initial = x.initial), se;
          }
          for (var _e2 = {}, yt = 0; yt < g9; yt++) {
            var En = OP[yt], so = x[En];
            (Br(so) || so === false) && (_e2[En] = so);
          }
          return _e2;
        }
      });
      return le;
    };
  }, OP = jr([
    "initial"
  ], kt(bx), false), g9 = OP.length;
  function Oy(t) {
    return typeof t == "string" && t.startsWith("var(--");
  }
  var RP = /var\((--[a-zA-Z0-9-_]+),? ?([a-zA-Z0-9 ()%#.,-]+)?\)/;
  function v9(t) {
    var e = RP.exec(t);
    if (!e)
      return [
        ,
      ];
    var n = kt(e, 3), r = n[1], i = n[2];
    return [
      r,
      i
    ];
  }
  function Ry(t, e, n) {
    var r = kt(v9(t), 2), i = r[0], o = r[1];
    if (!!i) {
      var s = window.getComputedStyle(e).getPropertyValue(i);
      return s ? s.trim() : Oy(o) ? Ry(o, e) : o;
    }
  }
  function y9(t, e, n) {
    var r, i = Mr(e, []), o = t.getInstance();
    if (!(o instanceof Element))
      return {
        target: i,
        transitionEnd: n
      };
    n && (n = ie({}, n)), t.forEachValue(function(c) {
      var u = c.get();
      if (!!Oy(u)) {
        var h = Ry(u, o);
        h && c.set(h);
      }
    });
    for (var s in i) {
      var a = i[s];
      if (!!Oy(a)) {
        var l = Ry(a, o);
        !l || (i[s] = l, n && ((r = n[s]) !== null && r !== void 0 || (n[s] = a)));
      }
    }
    return {
      target: i,
      transitionEnd: n
    };
  }
  var b9 = /* @__PURE__ */ new Set([
    "width",
    "height",
    "top",
    "left",
    "right",
    "bottom",
    "x",
    "y"
  ]), LP = function(t) {
    return b9.has(t);
  }, x9 = function(t) {
    return Object.keys(t).some(LP);
  }, _P = function(t, e) {
    t.set(e, false), t.set(e);
  }, _k = function(t) {
    return t === Js || t === Te;
  }, Dk;
  (function(t) {
    t.width = "width", t.height = "height", t.left = "left", t.right = "right", t.top = "top", t.bottom = "bottom";
  })(Dk || (Dk = {}));
  var Ik = function(t, e) {
    return parseFloat(t.split(", ")[e]);
  }, Bk = function(t, e) {
    return function(n, r) {
      var i = r.transform;
      if (i === "none" || !i)
        return 0;
      var o = i.match(/^matrix3d\((.+)\)$/);
      if (o)
        return Ik(o[1], e);
      var s = i.match(/^matrix\((.+)\)$/);
      return s ? Ik(s[1], t) : 0;
    };
  }, S9 = /* @__PURE__ */ new Set([
    "x",
    "y",
    "z"
  ]), w9 = Eu.filter(function(t) {
    return !S9.has(t);
  });
  function k9(t) {
    var e = [];
    return w9.forEach(function(n) {
      var r = t.getValue(n);
      r !== void 0 && (e.push([
        n,
        r.get()
      ]), r.set(n.startsWith("scale") ? 1 : 0));
    }), e.length && t.syncRender(), e;
  }
  var Nk = {
    width: function(t, e) {
      var n = t.x, r = e.paddingLeft, i = r === void 0 ? "0" : r, o = e.paddingRight, s = o === void 0 ? "0" : o;
      return n.max - n.min - parseFloat(i) - parseFloat(s);
    },
    height: function(t, e) {
      var n = t.y, r = e.paddingTop, i = r === void 0 ? "0" : r, o = e.paddingBottom, s = o === void 0 ? "0" : o;
      return n.max - n.min - parseFloat(i) - parseFloat(s);
    },
    top: function(t, e) {
      var n = e.top;
      return parseFloat(n);
    },
    left: function(t, e) {
      var n = e.left;
      return parseFloat(n);
    },
    bottom: function(t, e) {
      var n = t.y, r = e.top;
      return parseFloat(r) + (n.max - n.min);
    },
    right: function(t, e) {
      var n = t.x, r = e.left;
      return parseFloat(r) + (n.max - n.min);
    },
    x: Bk(4, 13),
    y: Bk(5, 14)
  }, C9 = function(t, e, n) {
    var r = e.measureViewportBox(), i = e.getInstance(), o = getComputedStyle(i), s = o.display, a = {};
    s === "none" && e.setStaticValue("display", t.display || "block"), n.forEach(function(c) {
      a[c] = Nk[c](r, o);
    }), e.syncRender();
    var l = e.measureViewportBox();
    return n.forEach(function(c) {
      var u = e.getValue(c);
      _P(u, a[c]), t[c] = Nk[c](l, o);
    }), t;
  }, T9 = function(t, e, n, r) {
    n === void 0 && (n = {}), r === void 0 && (r = {}), e = ie({}, e), r = ie({}, r);
    var i = Object.keys(e).filter(LP), o = [], s = false, a = [];
    if (i.forEach(function(u) {
      var h = t.getValue(u);
      if (!!t.hasValue(u)) {
        var p = n[u], v = rc(p), y = e[u], x;
        if (Ou(y)) {
          var T = y.length, w = y[0] === null ? 1 : 0;
          p = y[w], v = rc(p);
          for (var k = w; k < T; k++)
            x ? lp(rc(y[k]) === x) : x = rc(y[k]);
        } else
          x = rc(y);
        if (v !== x)
          if (_k(v) && _k(x)) {
            var C = h.get();
            typeof C == "string" && h.set(parseFloat(C)), typeof y == "string" ? e[u] = parseFloat(y) : Array.isArray(y) && x === Te && (e[u] = y.map(parseFloat));
          } else
            (v == null ? void 0 : v.transform) && (x == null ? void 0 : x.transform) && (p === 0 || y === 0) ? p === 0 ? h.set(x.transform(p)) : e[u] = v.transform(y) : (s || (o = k9(t), s = true), a.push(u), r[u] = r[u] !== void 0 ? r[u] : e[u], _P(h, y));
      }
    }), a.length) {
      var l = a.indexOf("height") >= 0 ? window.pageYOffset : null, c = C9(e, t, a);
      return o.length && o.forEach(function(u) {
        var h = kt(u, 2), p = h[0], v = h[1];
        t.getValue(p).set(v);
      }), t.syncRender(), l !== null && window.scrollTo({
        top: l
      }), {
        target: c,
        transitionEnd: r
      };
    } else
      return {
        target: e,
        transitionEnd: r
      };
  };
  function M9(t, e, n, r) {
    return x9(e) ? T9(t, e, n, r) : {
      target: e,
      transitionEnd: r
    };
  }
  var A9 = function(t, e, n, r) {
    var i = y9(t, e, r);
    return e = i.target, r = i.transitionEnd, M9(t, e, n, r);
  };
  function E9(t) {
    return window.getComputedStyle(t);
  }
  var DP = {
    treeType: "dom",
    readValueFromInstance: function(t, e) {
      if (tf(e)) {
        var n = dx(e);
        return n && n.default || 0;
      } else {
        var r = E9(t);
        return (CE(e) ? r.getPropertyValue(e) : r[e]) || 0;
      }
    },
    sortNodePosition: function(t, e) {
      return t.compareDocumentPosition(e) & 2 ? 1 : -1;
    },
    getBaseTarget: function(t, e) {
      var n;
      return (n = t.style) === null || n === void 0 ? void 0 : n[e];
    },
    measureViewportBox: function(t, e) {
      var n = e.transformPagePoint;
      return EP(t, n);
    },
    resetTransform: function(t, e, n) {
      var r = n.transformTemplate;
      e.style.transform = r ? r({}, "") : "none", t.scheduleRender();
    },
    restoreTransform: function(t, e) {
      t.style.transform = e.style.transform;
    },
    removeValueFromRenderState: function(t, e) {
      var n = e.vars, r = e.style;
      delete n[t], delete r[t];
    },
    makeTargetAnimatable: function(t, e, n, r) {
      var i = n.transformValues;
      r === void 0 && (r = true);
      var o = e.transition, s = e.transitionEnd, a = Mr(e, [
        "transition",
        "transitionEnd"
      ]), l = IH(a, o || {}, t);
      if (i && (s && (s = i(s)), a && (a = i(a)), l && (l = i(l))), r) {
        _H(t, a, l);
        var c = A9(t, a, l, s);
        s = c.transitionEnd, a = c.target;
      }
      return ie({
        transition: o,
        transitionEnd: s
      }, a);
    },
    scrapeMotionValuesFromProps: rx,
    build: function(t, e, n, r, i) {
      t.isVisible !== void 0 && (e.style.visibility = t.isVisible ? "visible" : "hidden"), ex(e, n, r, i.transformTemplate);
    },
    render: NE
  }, P9 = PP(DP), O9 = PP(ie(ie({}, DP), {
    getBaseTarget: function(t, e) {
      return t[e];
    },
    readValueFromInstance: function(t, e) {
      var n;
      return tf(e) ? ((n = dx(e)) === null || n === void 0 ? void 0 : n.default) || 0 : (e = $E.has(e) ? e : BE(e), t.getAttribute(e));
    },
    scrapeMotionValuesFromProps: FE,
    build: function(t, e, n, r, i) {
      nx(e, n, r, i.transformTemplate);
    },
    render: zE
  })), R9 = function(t, e) {
    return Jb(t) ? O9(e, {
      enableHardwareAcceleration: false
    }) : P9(e, {
      enableHardwareAcceleration: true
    });
  };
  function $k(t, e) {
    return e.max === e.min ? 0 : t / (e.max - e.min) * 100;
  }
  var ic = {
    correct: function(t, e) {
      if (!e.target)
        return t;
      if (typeof t == "string")
        if (Te.test(t))
          t = parseFloat(t);
        else
          return t;
      var n = $k(t, e.target.x), r = $k(t, e.target.y);
      return "".concat(n, "% ").concat(r, "%");
    }
  }, zk = "_$css", L9 = {
    correct: function(t, e) {
      var n = e.treeScale, r = e.projectionDelta, i = t, o = t.includes("var("), s = [];
      o && (t = t.replace(RP, function(x) {
        return s.push(x), zk;
      }));
      var a = eo.parse(t);
      if (a.length > 5)
        return i;
      var l = eo.createTransformer(t), c = typeof a[0] != "number" ? 1 : 0, u = r.x.scale * n.x, h = r.y.scale * n.y;
      a[0 + c] /= u, a[1 + c] /= h;
      var p = wt(u, h, 0.5);
      typeof a[2 + c] == "number" && (a[2 + c] /= p), typeof a[3 + c] == "number" && (a[3 + c] /= p);
      var v = l(a);
      if (o) {
        var y = 0;
        v = v.replace(zk, function() {
          var x = s[y];
          return y++, x;
        });
      }
      return v;
    }
  }, _9 = function(t) {
    pE(e, t);
    function e() {
      return t !== null && t.apply(this, arguments) || this;
    }
    return e.prototype.componentDidMount = function() {
      var n = this, r = this.props, i = r.visualElement, o = r.layoutGroup, s = r.switchLayoutGroup, a = r.layoutId, l = i.projection;
      t6(I9), l && ((o == null ? void 0 : o.group) && o.group.add(l), (s == null ? void 0 : s.register) && a && s.register(l), l.root.didUpdate(), l.addEventListener("animationComplete", function() {
        n.safeToRemove();
      }), l.setOptions(ie(ie({}, l.options), {
        onExitComplete: function() {
          return n.safeToRemove();
        }
      }))), Vc.hasEverUpdated = true;
    }, e.prototype.getSnapshotBeforeUpdate = function(n) {
      var r = this, i = this.props, o = i.layoutDependency, s = i.visualElement, a = i.drag, l = i.isPresent, c = s.projection;
      return c && (c.isPresent = l, a || n.layoutDependency !== o || o === void 0 ? c.willUpdate() : this.safeToRemove(), n.isPresent !== l && (l ? c.promote() : c.relegate() || Wr.postRender(function() {
        var u;
        !((u = c.getStack()) === null || u === void 0) && u.members.length || r.safeToRemove();
      }))), null;
    }, e.prototype.componentDidUpdate = function() {
      var n = this.props.visualElement.projection;
      n && (n.root.didUpdate(), !n.currentAnimation && n.isLead() && this.safeToRemove());
    }, e.prototype.componentWillUnmount = function() {
      var n = this.props, r = n.visualElement, i = n.layoutGroup, o = n.switchLayoutGroup, s = r.projection;
      s && (s.scheduleCheckAfterUnmount(), (i == null ? void 0 : i.group) && i.group.remove(s), (o == null ? void 0 : o.deregister) && o.deregister(s));
    }, e.prototype.safeToRemove = function() {
      var n = this.props.safeToRemove;
      n == null ? void 0 : n();
    }, e.prototype.render = function() {
      return null;
    }, e;
  }(jp.Component);
  function D9(t) {
    var e = kt(yP(), 2), n = e[0], r = e[1], i = z.exports.useContext(Qb);
    return J(_9, {
      ...ie({}, t, {
        layoutGroup: i,
        switchLayoutGroup: z.exports.useContext(SE),
        isPresent: n,
        safeToRemove: r
      })
    });
  }
  var I9 = {
    borderRadius: ie(ie({}, ic), {
      applyTo: [
        "borderTopLeftRadius",
        "borderTopRightRadius",
        "borderBottomLeftRadius",
        "borderBottomRightRadius"
      ]
    }),
    borderTopLeftRadius: ic,
    borderTopRightRadius: ic,
    borderBottomLeftRadius: ic,
    borderBottomRightRadius: ic,
    boxShadow: L9
  }, B9 = {
    measureLayout: D9
  };
  function N9(t, e, n) {
    n === void 0 && (n = {});
    var r = Zi(t) ? t : hl(t);
    return gx("", r, e, n), {
      stop: function() {
        return r.stop();
      },
      isAnimating: function() {
        return r.isAnimating();
      }
    };
  }
  var IP = [
    "TopLeft",
    "TopRight",
    "BottomLeft",
    "BottomRight"
  ], $9 = IP.length, Fk = function(t) {
    return typeof t == "string" ? parseFloat(t) : t;
  }, Vk = function(t) {
    return typeof t == "number" || Te.test(t);
  };
  function z9(t, e, n, r, i, o) {
    var s, a, l, c;
    i ? (t.opacity = wt(0, (s = n.opacity) !== null && s !== void 0 ? s : 1, F9(r)), t.opacityExit = wt((a = e.opacity) !== null && a !== void 0 ? a : 1, 0, V9(r))) : o && (t.opacity = wt((l = e.opacity) !== null && l !== void 0 ? l : 1, (c = n.opacity) !== null && c !== void 0 ? c : 1, r));
    for (var u = 0; u < $9; u++) {
      var h = "border".concat(IP[u], "Radius"), p = Hk(e, h), v = Hk(n, h);
      if (!(p === void 0 && v === void 0)) {
        p || (p = 0), v || (v = 0);
        var y = p === 0 || v === 0 || Vk(p) === Vk(v);
        y ? (t[h] = Math.max(wt(Fk(p), Fk(v), r), 0), (Ci.test(v) || Ci.test(p)) && (t[h] += "%")) : t[h] = v;
      }
    }
    (e.rotate || n.rotate) && (t.rotate = wt(e.rotate || 0, n.rotate || 0, r));
  }
  function Hk(t, e) {
    var n;
    return (n = t[e]) !== null && n !== void 0 ? n : t.borderRadius;
  }
  var F9 = BP(0, 0.5, fx), V9 = BP(0.5, 0.95, cx);
  function BP(t, e, n) {
    return function(r) {
      return r < t ? 0 : r > e ? 1 : n(Ru(t, e, r));
    };
  }
  function jk(t, e) {
    t.min = e.min, t.max = e.max;
  }
  function _r(t, e) {
    jk(t.x, e.x), jk(t.y, e.y);
  }
  function Wk(t, e, n, r, i) {
    return t -= e, t = yp(t, 1 / n, r), i !== void 0 && (t = yp(t, 1 / i, r)), t;
  }
  function H9(t, e, n, r, i, o, s) {
    if (e === void 0 && (e = 0), n === void 0 && (n = 1), r === void 0 && (r = 0.5), o === void 0 && (o = t), s === void 0 && (s = t), Ci.test(e)) {
      e = parseFloat(e);
      var a = wt(s.min, s.max, e / 100);
      e = a - s.min;
    }
    if (typeof e == "number") {
      var l = wt(o.min, o.max, r);
      t === o && (l -= e), t.min = Wk(t.min, e, n, l, i), t.max = Wk(t.max, e, n, l, i);
    }
  }
  function Uk(t, e, n, r, i) {
    var o = kt(n, 3), s = o[0], a = o[1], l = o[2];
    H9(t, e[s], e[a], e[l], e.scale, r, i);
  }
  var j9 = [
    "x",
    "scaleX",
    "originX"
  ], W9 = [
    "y",
    "scaleY",
    "originY"
  ];
  function Kk(t, e, n, r) {
    Uk(t.x, e, j9, n == null ? void 0 : n.x, r == null ? void 0 : r.x), Uk(t.y, e, W9, n == null ? void 0 : n.y, r == null ? void 0 : r.y);
  }
  function qk(t) {
    return t.translate === 0 && t.scale === 1;
  }
  function NP(t) {
    return qk(t.x) && qk(t.y);
  }
  function $P(t, e) {
    return t.x.min === e.x.min && t.x.max === e.x.max && t.y.min === e.y.min && t.y.max === e.y.max;
  }
  var U9 = function() {
    function t() {
      this.members = [];
    }
    return t.prototype.add = function(e) {
      vx(this.members, e), e.scheduleRender();
    }, t.prototype.remove = function(e) {
      if (yx(this.members, e), e === this.prevLead && (this.prevLead = void 0), e === this.lead) {
        var n = this.members[this.members.length - 1];
        n && this.promote(n);
      }
    }, t.prototype.relegate = function(e) {
      var n = this.members.findIndex(function(s) {
        return e === s;
      });
      if (n === 0)
        return false;
      for (var r, i = n; i >= 0; i--) {
        var o = this.members[i];
        if (o.isPresent !== false) {
          r = o;
          break;
        }
      }
      return r ? (this.promote(r), true) : false;
    }, t.prototype.promote = function(e, n) {
      var r, i = this.lead;
      if (e !== i && (this.prevLead = i, this.lead = e, e.show(), i)) {
        i.instance && i.scheduleRender(), e.scheduleRender(), e.resumeFrom = i, n && (e.resumeFrom.preserveOpacity = true), i.snapshot && (e.snapshot = i.snapshot, e.snapshot.latestValues = i.animationValues || i.latestValues, e.snapshot.isShared = true), !((r = e.root) === null || r === void 0) && r.isUpdating && (e.isLayoutDirty = true);
        var o = e.options.crossfade;
        o === false && i.hide();
      }
    }, t.prototype.exitAnimationComplete = function() {
      this.members.forEach(function(e) {
        var n, r, i, o, s;
        (r = (n = e.options).onExitComplete) === null || r === void 0 || r.call(n), (s = (i = e.resumingFrom) === null || i === void 0 ? void 0 : (o = i.options).onExitComplete) === null || s === void 0 || s.call(o);
      });
    }, t.prototype.scheduleRender = function() {
      this.members.forEach(function(e) {
        e.instance && e.scheduleRender(false);
      });
    }, t.prototype.removeLeadSnapshot = function() {
      this.lead && this.lead.snapshot && (this.lead.snapshot = void 0);
    }, t;
  }(), K9 = "translate3d(0px, 0px, 0) scale(1, 1) scale(1, 1)";
  function Gk(t, e, n) {
    var r = t.x.translate / e.x, i = t.y.translate / e.y, o = "translate3d(".concat(r, "px, ").concat(i, "px, 0) ");
    if (o += "scale(".concat(1 / e.x, ", ").concat(1 / e.y, ") "), n) {
      var s = n.rotate, a = n.rotateX, l = n.rotateY;
      s && (o += "rotate(".concat(s, "deg) ")), a && (o += "rotateX(".concat(a, "deg) ")), l && (o += "rotateY(".concat(l, "deg) "));
    }
    var c = t.x.scale * e.x, u = t.y.scale * e.y;
    return o += "scale(".concat(c, ", ").concat(u, ")"), o === K9 ? "none" : o;
  }
  var q9 = function(t, e) {
    return t.depth - e.depth;
  }, G9 = function() {
    function t() {
      this.children = [], this.isDirty = false;
    }
    return t.prototype.add = function(e) {
      vx(this.children, e), this.isDirty = true;
    }, t.prototype.remove = function(e) {
      yx(this.children, e), this.isDirty = true;
    }, t.prototype.forEach = function(e) {
      this.isDirty && this.children.sort(q9), this.isDirty = false, this.children.forEach(e);
    }, t;
  }(), Yk = 1e3;
  function zP(t) {
    var e = t.attachResizeListener, n = t.defaultParent, r = t.measureScroll, i = t.checkIsScrollRoot, o = t.resetTransform;
    return function() {
      function s(a, l, c) {
        var u = this;
        l === void 0 && (l = {}), c === void 0 && (c = n == null ? void 0 : n()), this.children = /* @__PURE__ */ new Set(), this.options = {}, this.isTreeAnimating = false, this.isAnimationBlocked = false, this.isLayoutDirty = false, this.updateManuallyBlocked = false, this.updateBlockedByResize = false, this.isUpdating = false, this.isSVG = false, this.needsReset = false, this.shouldResetTransform = false, this.treeScale = {
          x: 1,
          y: 1
        }, this.eventHandlers = /* @__PURE__ */ new Map(), this.potentialNodes = /* @__PURE__ */ new Map(), this.checkUpdateFailed = function() {
          u.isUpdating && (u.isUpdating = false, u.clearAllSnapshots());
        }, this.updateProjection = function() {
          u.nodes.forEach(ej), u.nodes.forEach(tj);
        }, this.hasProjected = false, this.isVisible = true, this.animationProgress = 0, this.sharedNodes = /* @__PURE__ */ new Map(), this.id = a, this.latestValues = l, this.root = c ? c.root || c : this, this.path = c ? jr(jr([], kt(c.path), false), [
          c
        ], false) : [], this.parent = c, this.depth = c ? c.depth + 1 : 0, a && this.root.registerPotentialNode(a, this);
        for (var h = 0; h < this.path.length; h++)
          this.path[h].shouldResetTransform = true;
        this.root === this && (this.nodes = new G9());
      }
      return s.prototype.addEventListener = function(a, l) {
        return this.eventHandlers.has(a) || this.eventHandlers.set(a, new Wc()), this.eventHandlers.get(a).add(l);
      }, s.prototype.notifyListeners = function(a) {
        for (var l = [], c = 1; c < arguments.length; c++)
          l[c - 1] = arguments[c];
        var u = this.eventHandlers.get(a);
        u == null ? void 0 : u.notify.apply(u, jr([], kt(l), false));
      }, s.prototype.hasListeners = function(a) {
        return this.eventHandlers.has(a);
      }, s.prototype.registerPotentialNode = function(a, l) {
        this.potentialNodes.set(a, l);
      }, s.prototype.mount = function(a, l) {
        var c = this, u;
        if (l === void 0 && (l = false), !this.instance) {
          this.isSVG = a instanceof SVGElement && a.tagName !== "svg", this.instance = a;
          var h = this.options, p = h.layoutId, v = h.layout, y = h.visualElement;
          if (y && !y.getInstance() && y.mount(a), this.root.nodes.add(this), (u = this.parent) === null || u === void 0 || u.children.add(this), this.id && this.root.potentialNodes.delete(this.id), l && (v || p) && (this.isLayoutDirty = true), e) {
            var x, T = function() {
              return c.root.updateBlockedByResize = false;
            };
            e(a, function() {
              c.root.updateBlockedByResize = true, clearTimeout(x), x = window.setTimeout(T, 250), Vc.hasAnimatedSinceResize && (Vc.hasAnimatedSinceResize = false, c.nodes.forEach(Z9));
            });
          }
          p && this.root.registerSharedNode(p, this), this.options.animate !== false && y && (p || v) && this.addEventListener("didUpdate", function(w) {
            var k, C, P, R, L, _ = w.delta, F = w.hasLayoutChanged, K = w.hasRelativeTargetChanged, Y = w.layout;
            if (c.isTreeAnimationBlocked()) {
              c.target = void 0, c.relativeTarget = void 0;
              return;
            }
            var te = (C = (k = c.options.transition) !== null && k !== void 0 ? k : y.getDefaultTransition()) !== null && C !== void 0 ? C : sj, ne = y.getProps(), ae = ne.onLayoutAnimationStart, ye = ne.onLayoutAnimationComplete, Ce = !c.targetLayout || !$P(c.targetLayout, Y) || K, Re = !F && K;
            if (((P = c.resumeFrom) === null || P === void 0 ? void 0 : P.instance) || Re || F && (Ce || !c.currentAnimation)) {
              c.resumeFrom && (c.resumingFrom = c.resumeFrom, c.resumingFrom.resumingFrom = void 0), c.setAnimationOrigin(_, Re);
              var ee = ie(ie({}, mx(te, "layout")), {
                onPlay: ae,
                onComplete: ye
              });
              y.shouldReduceMotion && (ee.delay = 0, ee.type = false), c.startAnimation(ee);
            } else
              !F && c.animationProgress === 0 && c.finishAnimation(), c.isLead() && ((L = (R = c.options).onExitComplete) === null || L === void 0 || L.call(R));
            c.targetLayout = Y;
          });
        }
      }, s.prototype.unmount = function() {
        var a, l;
        this.options.layoutId && this.willUpdate(), this.root.nodes.remove(this), (a = this.getStack()) === null || a === void 0 || a.remove(this), (l = this.parent) === null || l === void 0 || l.children.delete(this), this.instance = void 0, fl.preRender(this.updateProjection);
      }, s.prototype.blockUpdate = function() {
        this.updateManuallyBlocked = true;
      }, s.prototype.unblockUpdate = function() {
        this.updateManuallyBlocked = false;
      }, s.prototype.isUpdateBlocked = function() {
        return this.updateManuallyBlocked || this.updateBlockedByResize;
      }, s.prototype.isTreeAnimationBlocked = function() {
        var a;
        return this.isAnimationBlocked || ((a = this.parent) === null || a === void 0 ? void 0 : a.isTreeAnimationBlocked()) || false;
      }, s.prototype.startUpdate = function() {
        var a;
        this.isUpdateBlocked() || (this.isUpdating = true, (a = this.nodes) === null || a === void 0 || a.forEach(nj));
      }, s.prototype.willUpdate = function(a) {
        var l, c, u;
        if (a === void 0 && (a = true), this.root.isUpdateBlocked()) {
          (c = (l = this.options).onExitComplete) === null || c === void 0 || c.call(l);
          return;
        }
        if (!this.root.isUpdating && this.root.startUpdate(), !this.isLayoutDirty) {
          this.isLayoutDirty = true;
          for (var h = 0; h < this.path.length; h++) {
            var p = this.path[h];
            p.shouldResetTransform = true, p.updateScroll();
          }
          var v = this.options, y = v.layoutId, x = v.layout;
          if (!(y === void 0 && !x)) {
            var T = (u = this.options.visualElement) === null || u === void 0 ? void 0 : u.getProps().transformTemplate;
            this.prevTransformTemplateValue = T == null ? void 0 : T(this.latestValues, ""), this.updateSnapshot(), a && this.notifyListeners("willUpdate");
          }
        }
      }, s.prototype.didUpdate = function() {
        var a = this.isUpdateBlocked();
        if (a) {
          this.unblockUpdate(), this.clearAllSnapshots(), this.nodes.forEach(Xk);
          return;
        }
        !this.isUpdating || (this.isUpdating = false, this.potentialNodes.size && (this.potentialNodes.forEach(aj), this.potentialNodes.clear()), this.nodes.forEach(J9), this.nodes.forEach(Y9), this.nodes.forEach(X9), this.clearAllSnapshots(), y0.update(), y0.preRender(), y0.render());
      }, s.prototype.clearAllSnapshots = function() {
        this.nodes.forEach(Q9), this.sharedNodes.forEach(rj);
      }, s.prototype.scheduleUpdateProjection = function() {
        Wr.preRender(this.updateProjection, false, true);
      }, s.prototype.scheduleCheckAfterUnmount = function() {
        var a = this;
        Wr.postRender(function() {
          a.isLayoutDirty ? a.root.didUpdate() : a.root.checkUpdateFailed();
        });
      }, s.prototype.updateSnapshot = function() {
        if (!(this.snapshot || !this.instance)) {
          var a = this.measure(), l = this.removeTransform(this.removeElementScroll(a));
          eC(l), this.snapshot = {
            measured: a,
            layout: l,
            latestValues: {}
          };
        }
      }, s.prototype.updateLayout = function() {
        var a;
        if (!!this.instance && (this.updateScroll(), !(!(this.options.alwaysMeasureLayout && this.isLead()) && !this.isLayoutDirty))) {
          if (this.resumeFrom && !this.resumeFrom.instance)
            for (var l = 0; l < this.path.length; l++) {
              var c = this.path[l];
              c.updateScroll();
            }
          var u = this.measure();
          eC(u);
          var h = this.layout;
          this.layout = {
            measured: u,
            actual: this.removeElementScroll(u)
          }, this.layoutCorrected = cn(), this.isLayoutDirty = false, this.projectionDelta = void 0, this.notifyListeners("measure", this.layout.actual), (a = this.options.visualElement) === null || a === void 0 || a.notifyLayoutMeasure(this.layout.actual, h == null ? void 0 : h.actual);
        }
      }, s.prototype.updateScroll = function() {
        this.options.layoutScroll && this.instance && (this.isScrollRoot = i(this.instance), this.scroll = r(this.instance));
      }, s.prototype.resetTransform = function() {
        var a;
        if (!!o) {
          var l = this.isLayoutDirty || this.shouldResetTransform, c = this.projectionDelta && !NP(this.projectionDelta), u = (a = this.options.visualElement) === null || a === void 0 ? void 0 : a.getProps().transformTemplate, h = u == null ? void 0 : u(this.latestValues, ""), p = h !== this.prevTransformTemplateValue;
          l && (c || vo(this.latestValues) || p) && (o(this.instance, h), this.shouldResetTransform = false, this.scheduleRender());
        }
      }, s.prototype.measure = function() {
        var a = this.options.visualElement;
        if (!a)
          return cn();
        var l = a.measureViewportBox(), c = this.root.scroll;
        return c && (xo(l.x, c.x), xo(l.y, c.y)), l;
      }, s.prototype.removeElementScroll = function(a) {
        var l = cn();
        _r(l, a);
        for (var c = 0; c < this.path.length; c++) {
          var u = this.path[c], h = u.scroll, p = u.options, v = u.isScrollRoot;
          if (u !== this.root && h && p.layoutScroll) {
            if (v) {
              _r(l, a);
              var y = this.root.scroll;
              y && (xo(l.x, -y.x), xo(l.y, -y.y));
            }
            xo(l.x, h.x), xo(l.y, h.y);
          }
        }
        return l;
      }, s.prototype.applyTransform = function(a, l) {
        l === void 0 && (l = false);
        var c = cn();
        _r(c, a);
        for (var u = 0; u < this.path.length; u++) {
          var h = this.path[u];
          !l && h.options.layoutScroll && h.scroll && h !== h.root && La(c, {
            x: -h.scroll.x,
            y: -h.scroll.y
          }), vo(h.latestValues) && La(c, h.latestValues);
        }
        return vo(this.latestValues) && La(c, this.latestValues), c;
      }, s.prototype.removeTransform = function(a) {
        var l, c = cn();
        _r(c, a);
        for (var u = 0; u < this.path.length; u++) {
          var h = this.path[u];
          if (!!h.instance && !!vo(h.latestValues)) {
            MP(h.latestValues) && h.updateSnapshot();
            var p = cn(), v = h.measure();
            _r(p, v), Kk(c, h.latestValues, (l = h.snapshot) === null || l === void 0 ? void 0 : l.layout, p);
          }
        }
        return vo(this.latestValues) && Kk(c, this.latestValues), c;
      }, s.prototype.setTargetDelta = function(a) {
        this.targetDelta = a, this.root.scheduleUpdateProjection();
      }, s.prototype.setOptions = function(a) {
        var l;
        this.options = ie(ie(ie({}, this.options), a), {
          crossfade: (l = a.crossfade) !== null && l !== void 0 ? l : true
        });
      }, s.prototype.clearMeasurements = function() {
        this.scroll = void 0, this.layout = void 0, this.snapshot = void 0, this.prevTransformTemplateValue = void 0, this.targetDelta = void 0, this.target = void 0, this.isLayoutDirty = false;
      }, s.prototype.resolveTargetDelta = function() {
        var a, l = this.options, c = l.layout, u = l.layoutId;
        !this.layout || !(c || u) || (!this.targetDelta && !this.relativeTarget && (this.relativeParent = this.getClosestProjectingParent(), this.relativeParent && this.relativeParent.layout && (this.relativeTarget = cn(), this.relativeTargetOrigin = cn(), Kc(this.relativeTargetOrigin, this.layout.actual, this.relativeParent.layout.actual), _r(this.relativeTarget, this.relativeTargetOrigin))), !(!this.relativeTarget && !this.targetDelta) && (this.target || (this.target = cn(), this.targetWithTransforms = cn()), this.relativeTarget && this.relativeTargetOrigin && ((a = this.relativeParent) === null || a === void 0 ? void 0 : a.target) ? YH(this.target, this.relativeTarget, this.relativeParent.target) : this.targetDelta ? (Boolean(this.resumingFrom) ? this.target = this.applyTransform(this.layout.actual) : _r(this.target, this.layout.actual), AP(this.target, this.targetDelta)) : _r(this.target, this.layout.actual), this.attemptToResolveRelativeTarget && (this.attemptToResolveRelativeTarget = false, this.relativeParent = this.getClosestProjectingParent(), this.relativeParent && Boolean(this.relativeParent.resumingFrom) === Boolean(this.resumingFrom) && !this.relativeParent.options.layoutScroll && this.relativeParent.target && (this.relativeTarget = cn(), this.relativeTargetOrigin = cn(), Kc(this.relativeTargetOrigin, this.target, this.relativeParent.target), _r(this.relativeTarget, this.relativeTargetOrigin)))));
      }, s.prototype.getClosestProjectingParent = function() {
        if (!(!this.parent || vo(this.parent.latestValues)))
          return (this.parent.relativeTarget || this.parent.targetDelta) && this.parent.layout ? this.parent : this.parent.getClosestProjectingParent();
      }, s.prototype.calcProjection = function() {
        var a, l = this.options, c = l.layout, u = l.layoutId;
        if (this.isTreeAnimating = Boolean(((a = this.parent) === null || a === void 0 ? void 0 : a.isTreeAnimating) || this.currentAnimation || this.pendingAnimation), this.isTreeAnimating || (this.targetDelta = this.relativeTarget = void 0), !(!this.layout || !(c || u))) {
          var h = this.getLead();
          _r(this.layoutCorrected, this.layout.actual), i9(this.layoutCorrected, this.treeScale, this.path, Boolean(this.resumingFrom) || this !== h);
          var p = h.target;
          if (!!p) {
            this.projectionDelta || (this.projectionDelta = qc(), this.projectionDeltaWithTransform = qc());
            var v = this.treeScale.x, y = this.treeScale.y, x = this.projectionTransform;
            Uc(this.projectionDelta, this.layoutCorrected, p, this.latestValues), this.projectionTransform = Gk(this.projectionDelta, this.treeScale), (this.projectionTransform !== x || this.treeScale.x !== v || this.treeScale.y !== y) && (this.hasProjected = true, this.scheduleRender(), this.notifyListeners("projectionUpdate", p));
          }
        }
      }, s.prototype.hide = function() {
        this.isVisible = false;
      }, s.prototype.show = function() {
        this.isVisible = true;
      }, s.prototype.scheduleRender = function(a) {
        var l, c, u;
        a === void 0 && (a = true), (c = (l = this.options).scheduleRender) === null || c === void 0 || c.call(l), a && ((u = this.getStack()) === null || u === void 0 || u.scheduleRender()), this.resumingFrom && !this.resumingFrom.instance && (this.resumingFrom = void 0);
      }, s.prototype.setAnimationOrigin = function(a, l) {
        var c = this, u;
        l === void 0 && (l = false);
        var h = this.snapshot, p = (h == null ? void 0 : h.latestValues) || {}, v = ie({}, this.latestValues), y = qc();
        this.relativeTarget = this.relativeTargetOrigin = void 0, this.attemptToResolveRelativeTarget = !l;
        var x = cn(), T = h == null ? void 0 : h.isShared, w = (((u = this.getStack()) === null || u === void 0 ? void 0 : u.members.length) || 0) <= 1, k = Boolean(T && !w && this.options.crossfade === true && !this.path.some(oj));
        this.animationProgress = 0, this.mixTargetDelta = function(C) {
          var P, R = C / 1e3;
          Qk(y.x, a.x, R), Qk(y.y, a.y, R), c.setTargetDelta(y), c.relativeTarget && c.relativeTargetOrigin && c.layout && ((P = c.relativeParent) === null || P === void 0 ? void 0 : P.layout) && (Kc(x, c.layout.actual, c.relativeParent.layout.actual), ij(c.relativeTarget, c.relativeTargetOrigin, x, R)), T && (c.animationValues = v, z9(v, p, c.latestValues, R, k, w)), c.root.scheduleUpdateProjection(), c.scheduleRender(), c.animationProgress = R;
        }, this.mixTargetDelta(0);
      }, s.prototype.startAnimation = function(a) {
        var l = this, c, u;
        this.notifyListeners("animationStart"), (c = this.currentAnimation) === null || c === void 0 || c.stop(), this.resumingFrom && ((u = this.resumingFrom.currentAnimation) === null || u === void 0 || u.stop()), this.pendingAnimation && (fl.update(this.pendingAnimation), this.pendingAnimation = void 0), this.pendingAnimation = Wr.update(function() {
          Vc.hasAnimatedSinceResize = true, l.currentAnimation = N9(0, Yk, ie(ie({}, a), {
            onUpdate: function(h) {
              var p;
              l.mixTargetDelta(h), (p = a.onUpdate) === null || p === void 0 || p.call(a, h);
            },
            onComplete: function() {
              var h;
              (h = a.onComplete) === null || h === void 0 || h.call(a), l.completeAnimation();
            }
          })), l.resumingFrom && (l.resumingFrom.currentAnimation = l.currentAnimation), l.pendingAnimation = void 0;
        });
      }, s.prototype.completeAnimation = function() {
        var a;
        this.resumingFrom && (this.resumingFrom.currentAnimation = void 0, this.resumingFrom.preserveOpacity = void 0), (a = this.getStack()) === null || a === void 0 || a.exitAnimationComplete(), this.resumingFrom = this.currentAnimation = this.animationValues = void 0, this.notifyListeners("animationComplete");
      }, s.prototype.finishAnimation = function() {
        var a;
        this.currentAnimation && ((a = this.mixTargetDelta) === null || a === void 0 || a.call(this, Yk), this.currentAnimation.stop()), this.completeAnimation();
      }, s.prototype.applyTransformsToTarget = function() {
        var a = this.getLead(), l = a.targetWithTransforms, c = a.target, u = a.layout, h = a.latestValues;
        !l || !c || !u || (_r(l, c), La(l, h), Uc(this.projectionDeltaWithTransform, this.layoutCorrected, l, h));
      }, s.prototype.registerSharedNode = function(a, l) {
        var c, u, h;
        this.sharedNodes.has(a) || this.sharedNodes.set(a, new U9());
        var p = this.sharedNodes.get(a);
        p.add(l), l.promote({
          transition: (c = l.options.initialPromotionConfig) === null || c === void 0 ? void 0 : c.transition,
          preserveFollowOpacity: (h = (u = l.options.initialPromotionConfig) === null || u === void 0 ? void 0 : u.shouldPreserveFollowOpacity) === null || h === void 0 ? void 0 : h.call(u, l)
        });
      }, s.prototype.isLead = function() {
        var a = this.getStack();
        return a ? a.lead === this : true;
      }, s.prototype.getLead = function() {
        var a, l = this.options.layoutId;
        return l ? ((a = this.getStack()) === null || a === void 0 ? void 0 : a.lead) || this : this;
      }, s.prototype.getPrevLead = function() {
        var a, l = this.options.layoutId;
        return l ? (a = this.getStack()) === null || a === void 0 ? void 0 : a.prevLead : void 0;
      }, s.prototype.getStack = function() {
        var a = this.options.layoutId;
        if (a)
          return this.root.sharedNodes.get(a);
      }, s.prototype.promote = function(a) {
        var l = a === void 0 ? {} : a, c = l.needsReset, u = l.transition, h = l.preserveFollowOpacity, p = this.getStack();
        p && p.promote(this, h), c && (this.projectionDelta = void 0, this.needsReset = true), u && this.setOptions({
          transition: u
        });
      }, s.prototype.relegate = function() {
        var a = this.getStack();
        return a ? a.relegate(this) : false;
      }, s.prototype.resetRotation = function() {
        var a = this.options.visualElement;
        if (!!a) {
          for (var l = false, c = {}, u = 0; u < gy.length; u++) {
            var h = gy[u], p = "rotate" + h;
            !a.getStaticValue(p) || (l = true, c[p] = a.getStaticValue(p), a.setStaticValue(p, 0));
          }
          if (!!l) {
            a == null ? void 0 : a.syncRender();
            for (var p in c)
              a.setStaticValue(p, c[p]);
            a.scheduleRender();
          }
        }
      }, s.prototype.getProjectionStyles = function(a) {
        var l, c, u, h, p, v;
        a === void 0 && (a = {});
        var y = {};
        if (!this.instance || this.isSVG)
          return y;
        if (this.isVisible)
          y.visibility = "";
        else
          return {
            visibility: "hidden"
          };
        var x = (l = this.options.visualElement) === null || l === void 0 ? void 0 : l.getProps().transformTemplate;
        if (this.needsReset)
          return this.needsReset = false, y.opacity = "", y.pointerEvents = gd(a.pointerEvents) || "", y.transform = x ? x(this.latestValues, "") : "none", y;
        var T = this.getLead();
        if (!this.projectionDelta || !this.layout || !T.target) {
          var w = {};
          return this.options.layoutId && (w.opacity = (c = this.latestValues.opacity) !== null && c !== void 0 ? c : 1, w.pointerEvents = gd(a.pointerEvents) || ""), this.hasProjected && !vo(this.latestValues) && (w.transform = x ? x({}, "") : "none", this.hasProjected = false), w;
        }
        var k = T.animationValues || T.latestValues;
        this.applyTransformsToTarget(), y.transform = Gk(this.projectionDeltaWithTransform, this.treeScale, k), x && (y.transform = x(k, y.transform));
        var C = this.projectionDelta, P = C.x, R = C.y;
        y.transformOrigin = "".concat(P.origin * 100, "% ").concat(R.origin * 100, "% 0"), T.animationValues ? y.opacity = T === this ? (h = (u = k.opacity) !== null && u !== void 0 ? u : this.latestValues.opacity) !== null && h !== void 0 ? h : 1 : this.preserveOpacity ? this.latestValues.opacity : k.opacityExit : y.opacity = T === this ? (p = k.opacity) !== null && p !== void 0 ? p : "" : (v = k.opacityExit) !== null && v !== void 0 ? v : 0;
        for (var L in up)
          if (k[L] !== void 0) {
            var _ = up[L], F = _.correct, K = _.applyTo, Y = F(k[L], T);
            if (K)
              for (var te = K.length, ne = 0; ne < te; ne++)
                y[K[ne]] = Y;
            else
              y[L] = Y;
          }
        return this.options.layoutId && (y.pointerEvents = T === this ? gd(a.pointerEvents) || "" : "none"), y;
      }, s.prototype.clearSnapshot = function() {
        this.resumeFrom = this.snapshot = void 0;
      }, s.prototype.resetTree = function() {
        this.root.nodes.forEach(function(a) {
          var l;
          return (l = a.currentAnimation) === null || l === void 0 ? void 0 : l.stop();
        }), this.root.nodes.forEach(Xk), this.root.sharedNodes.clear();
      }, s;
    }();
  }
  function Y9(t) {
    t.updateLayout();
  }
  function X9(t) {
    var e, n, r, i, o = (n = (e = t.resumeFrom) === null || e === void 0 ? void 0 : e.snapshot) !== null && n !== void 0 ? n : t.snapshot;
    if (t.isLead() && t.layout && o && t.hasListeners("didUpdate")) {
      var s = t.layout, a = s.actual, l = s.measured;
      t.options.animationType === "size" ? li(function(k) {
        var C = o.isShared ? o.measured[k] : o.layout[k], P = to(C);
        C.min = a[k].min, C.max = C.min + P;
      }) : t.options.animationType === "position" && li(function(k) {
        var C = o.isShared ? o.measured[k] : o.layout[k], P = to(a[k]);
        C.max = C.min + P;
      });
      var c = qc();
      Uc(c, a, o.layout);
      var u = qc();
      o.isShared ? Uc(u, t.applyTransform(l, true), o.measured) : Uc(u, a, o.layout);
      var h = !NP(c), p = false;
      if (!t.resumeFrom && (t.relativeParent = t.getClosestProjectingParent(), t.relativeParent && !t.relativeParent.resumeFrom)) {
        var v = t.relativeParent, y = v.snapshot, x = v.layout;
        if (y && x) {
          var T = cn();
          Kc(T, o.layout, y.layout);
          var w = cn();
          Kc(w, a, x.actual), $P(T, w) || (p = true);
        }
      }
      t.notifyListeners("didUpdate", {
        layout: a,
        snapshot: o,
        delta: u,
        layoutDelta: c,
        hasLayoutChanged: h,
        hasRelativeTargetChanged: p
      });
    } else
      t.isLead() && ((i = (r = t.options).onExitComplete) === null || i === void 0 || i.call(r));
    t.options.transition = void 0;
  }
  function Q9(t) {
    t.clearSnapshot();
  }
  function Xk(t) {
    t.clearMeasurements();
  }
  function J9(t) {
    var e = t.options.visualElement;
    (e == null ? void 0 : e.getProps().onBeforeLayoutMeasure) && e.notifyBeforeLayoutMeasure(), t.resetTransform();
  }
  function Z9(t) {
    t.finishAnimation(), t.targetDelta = t.relativeTarget = t.target = void 0;
  }
  function ej(t) {
    t.resolveTargetDelta();
  }
  function tj(t) {
    t.calcProjection();
  }
  function nj(t) {
    t.resetRotation();
  }
  function rj(t) {
    t.removeLeadSnapshot();
  }
  function Qk(t, e, n) {
    t.translate = wt(e.translate, 0, n), t.scale = wt(e.scale, 1, n), t.origin = e.origin, t.originPoint = e.originPoint;
  }
  function Jk(t, e, n, r) {
    t.min = wt(e.min, n.min, r), t.max = wt(e.max, n.max, r);
  }
  function ij(t, e, n, r) {
    Jk(t.x, e.x, n.x, r), Jk(t.y, e.y, n.y, r);
  }
  function oj(t) {
    return t.animationValues && t.animationValues.opacityExit !== void 0;
  }
  var sj = {
    duration: 0.45,
    ease: [
      0.4,
      0,
      0.1,
      1
    ]
  };
  function aj(t, e) {
    for (var n = t.root, r = t.path.length - 1; r >= 0; r--)
      if (Boolean(t.path[r].instance)) {
        n = t.path[r];
        break;
      }
    var i = n && n !== t.root ? n.instance : document, o = i.querySelector('[data-projection-id="'.concat(e, '"]'));
    o && t.mount(o, true);
  }
  function Zk(t) {
    t.min = Math.round(t.min), t.max = Math.round(t.max);
  }
  function eC(t) {
    Zk(t.x), Zk(t.y);
  }
  var lj = zP({
    attachResizeListener: function(t, e) {
      return Rm(t, "resize", e);
    },
    measureScroll: function() {
      return {
        x: document.documentElement.scrollLeft || document.body.scrollLeft,
        y: document.documentElement.scrollTop || document.body.scrollTop
      };
    },
    checkIsScrollRoot: function() {
      return true;
    }
  }), C0 = {
    current: void 0
  }, cj = zP({
    measureScroll: function(t) {
      return {
        x: t.scrollLeft,
        y: t.scrollTop
      };
    },
    defaultParent: function() {
      if (!C0.current) {
        var t = new lj(0, {});
        t.mount(window), t.setOptions({
          layoutScroll: true
        }), C0.current = t;
      }
      return C0.current;
    },
    resetTransform: function(t, e) {
      t.style.transform = e ?? "none";
    },
    checkIsScrollRoot: function(t) {
      return Boolean(window.getComputedStyle(t).position === "fixed");
    }
  }), uj = ie(ie(ie(ie({}, KH), aH), d9), B9), fj = ZV(function(t, e) {
    return z6(t, e, uj, R9, cj);
  });
  function FP() {
    var t = z.exports.useRef(false);
    return cp(function() {
      return t.current = true, function() {
        t.current = false;
      };
    }, []), t;
  }
  function hj() {
    var t = FP(), e = kt(z.exports.useState(0), 2), n = e[0], r = e[1], i = z.exports.useCallback(function() {
      t.current && r(n + 1);
    }, [
      n
    ]), o = z.exports.useCallback(function() {
      return Wr.postRender(i);
    }, [
      i
    ]);
    return [
      o,
      n
    ];
  }
  var T0 = function(t) {
    var e = t.children, n = t.initial, r = t.isPresent, i = t.onExitComplete, o = t.custom, s = t.presenceAffectsLayout, a = ef(dj), l = vP(), c = z.exports.useMemo(function() {
      return {
        id: l,
        initial: n,
        isPresent: r,
        custom: o,
        onExitComplete: function(u) {
          var h, p;
          a.set(u, true);
          try {
            for (var v = RV(a.values()), y = v.next(); !y.done; y = v.next()) {
              var x = y.value;
              if (!x)
                return;
            }
          } catch (T) {
            h = {
              error: T
            };
          } finally {
            try {
              y && !y.done && (p = v.return) && p.call(v);
            } finally {
              if (h)
                throw h.error;
            }
          }
          i == null ? void 0 : i();
        },
        register: function(u) {
          return a.set(u, false), function() {
            return a.delete(u);
          };
        }
      };
    }, s ? void 0 : [
      r
    ]);
    return z.exports.useMemo(function() {
      a.forEach(function(u, h) {
        return a.set(h, false);
      });
    }, [
      r
    ]), z.exports.useEffect(function() {
      !r && !a.size && (i == null ? void 0 : i());
    }, [
      r
    ]), J(Al.Provider, {
      value: c,
      children: e
    });
  };
  function dj() {
    return /* @__PURE__ */ new Map();
  }
  var ua = function(t) {
    return t.key || "";
  };
  function pj(t, e) {
    t.forEach(function(n) {
      var r = ua(n);
      e.set(r, n);
    });
  }
  function mj(t) {
    var e = [];
    return z.exports.Children.forEach(t, function(n) {
      z.exports.isValidElement(n) && e.push(n);
    }), e;
  }
  var gj = function(t) {
    var e = t.children, n = t.custom, r = t.initial, i = r === void 0 ? true : r, o = t.onExitComplete, s = t.exitBeforeEnter, a = t.presenceAffectsLayout, l = a === void 0 ? true : a, c = kt(hj(), 1), u = c[0], h = z.exports.useContext(Qb).forceRender;
    h && (u = h);
    var p = FP(), v = mj(e), y = v, x = /* @__PURE__ */ new Set(), T = z.exports.useRef(y), w = z.exports.useRef(/* @__PURE__ */ new Map()).current, k = z.exports.useRef(true);
    if (cp(function() {
      k.current = false, pj(v, w), T.current = y;
    }), sx(function() {
      k.current = true, w.clear(), x.clear();
    }), k.current)
      return J(sp, {
        children: y.map(function(F) {
          return J(T0, {
            isPresent: true,
            initial: i ? void 0 : false,
            presenceAffectsLayout: l,
            children: F
          }, ua(F));
        })
      });
    y = jr([], kt(y), false);
    for (var C = T.current.map(ua), P = v.map(ua), R = C.length, L = 0; L < R; L++) {
      var _ = C[L];
      P.indexOf(_) === -1 && x.add(_);
    }
    return s && x.size && (y = []), x.forEach(function(F) {
      if (P.indexOf(F) === -1) {
        var K = w.get(F);
        if (!!K) {
          var Y = C.indexOf(F), te = function() {
            w.delete(F), x.delete(F);
            var ne = T.current.findIndex(function(ae) {
              return ae.key === F;
            });
            if (T.current.splice(ne, 1), !x.size) {
              if (T.current = v, p.current === false)
                return;
              u(), o && o();
            }
          };
          y.splice(Y, 0, J(T0, {
            isPresent: false,
            onExitComplete: te,
            custom: n,
            presenceAffectsLayout: l,
            children: K
          }, ua(K)));
        }
      }
    }), y = y.map(function(F) {
      var K = F.key;
      return x.has(K) ? F : J(T0, {
        isPresent: true,
        presenceAffectsLayout: l,
        children: F
      }, ua(F));
    }), Yb !== "production" && s && y.length > 1 && console.warn("You're attempting to animate multiple children within AnimatePresence, but its exitBeforeEnter prop is set to true. This will lead to odd visual behaviour."), J(sp, {
      children: x.size ? y : y.map(function(F) {
        return z.exports.cloneElement(F);
      })
    });
  };
  const vj = (t, e) => t.find((n) => n.id === e);
  function tC(t, e) {
    const n = VP(t, e), r = n ? t[n].findIndex((i) => i.id === e) : -1;
    return {
      position: n,
      index: r
    };
  }
  function VP(t, e) {
    for (const [n, r] of Object.entries(t))
      if (vj(r, e))
        return n;
  }
  function yj(t) {
    const e = t.includes("right"), n = t.includes("left");
    let r = "center";
    return e && (r = "flex-end"), n && (r = "flex-start"), {
      display: "flex",
      flexDirection: "column",
      alignItems: r
    };
  }
  function bj(t) {
    const n = t === "top" || t === "bottom" ? "0 auto" : void 0, r = t.includes("top") ? "env(safe-area-inset-top, 0px)" : void 0, i = t.includes("bottom") ? "env(safe-area-inset-bottom, 0px)" : void 0, o = t.includes("left") ? void 0 : "env(safe-area-inset-right, 0px)", s = t.includes("right") ? void 0 : "env(safe-area-inset-left, 0px)";
    return {
      position: "fixed",
      zIndex: "var(--toast-z-index, 5500)",
      pointerEvents: "none",
      display: "flex",
      flexDirection: "column",
      margin: n,
      top: r,
      bottom: i,
      right: o,
      left: s
    };
  }
  var xj = /^((children|dangerouslySetInnerHTML|key|ref|autoFocus|defaultValue|defaultChecked|innerHTML|suppressContentEditableWarning|suppressHydrationWarning|valueLink|abbr|accept|acceptCharset|accessKey|action|allow|allowUserMedia|allowPaymentRequest|allowFullScreen|allowTransparency|alt|async|autoComplete|autoPlay|capture|cellPadding|cellSpacing|challenge|charSet|checked|cite|classID|className|cols|colSpan|content|contentEditable|contextMenu|controls|controlsList|coords|crossOrigin|data|dateTime|decoding|default|defer|dir|disabled|disablePictureInPicture|disableRemotePlayback|download|draggable|encType|enterKeyHint|fetchpriority|fetchPriority|form|formAction|formEncType|formMethod|formNoValidate|formTarget|frameBorder|headers|height|hidden|high|href|hrefLang|htmlFor|httpEquiv|id|inputMode|integrity|is|keyParams|keyType|kind|label|lang|list|loading|loop|low|marginHeight|marginWidth|max|maxLength|media|mediaGroup|method|min|minLength|multiple|muted|name|nonce|noValidate|open|optimum|pattern|placeholder|playsInline|popover|popoverTarget|popoverTargetAction|poster|preload|profile|radioGroup|readOnly|referrerPolicy|rel|required|reversed|role|rows|rowSpan|sandbox|scope|scoped|scrolling|seamless|selected|shape|size|sizes|slot|span|spellCheck|src|srcDoc|srcLang|srcSet|start|step|style|summary|tabIndex|target|title|translate|type|useMap|value|width|wmode|wrap|about|datatype|inlist|prefix|property|resource|typeof|vocab|autoCapitalize|autoCorrect|autoSave|color|incremental|fallback|inert|itemProp|itemScope|itemType|itemID|itemRef|on|option|results|security|unselectable|accentHeight|accumulate|additive|alignmentBaseline|allowReorder|alphabetic|amplitude|arabicForm|ascent|attributeName|attributeType|autoReverse|azimuth|baseFrequency|baselineShift|baseProfile|bbox|begin|bias|by|calcMode|capHeight|clip|clipPathUnits|clipPath|clipRule|colorInterpolation|colorInterpolationFilters|colorProfile|colorRendering|contentScriptType|contentStyleType|cursor|cx|cy|d|decelerate|descent|diffuseConstant|direction|display|divisor|dominantBaseline|dur|dx|dy|edgeMode|elevation|enableBackground|end|exponent|externalResourcesRequired|fill|fillOpacity|fillRule|filter|filterRes|filterUnits|floodColor|floodOpacity|focusable|fontFamily|fontSize|fontSizeAdjust|fontStretch|fontStyle|fontVariant|fontWeight|format|from|fr|fx|fy|g1|g2|glyphName|glyphOrientationHorizontal|glyphOrientationVertical|glyphRef|gradientTransform|gradientUnits|hanging|horizAdvX|horizOriginX|ideographic|imageRendering|in|in2|intercept|k|k1|k2|k3|k4|kernelMatrix|kernelUnitLength|kerning|keyPoints|keySplines|keyTimes|lengthAdjust|letterSpacing|lightingColor|limitingConeAngle|local|markerEnd|markerMid|markerStart|markerHeight|markerUnits|markerWidth|mask|maskContentUnits|maskUnits|mathematical|mode|numOctaves|offset|opacity|operator|order|orient|orientation|origin|overflow|overlinePosition|overlineThickness|panose1|paintOrder|pathLength|patternContentUnits|patternTransform|patternUnits|pointerEvents|points|pointsAtX|pointsAtY|pointsAtZ|preserveAlpha|preserveAspectRatio|primitiveUnits|r|radius|refX|refY|renderingIntent|repeatCount|repeatDur|requiredExtensions|requiredFeatures|restart|result|rotate|rx|ry|scale|seed|shapeRendering|slope|spacing|specularConstant|specularExponent|speed|spreadMethod|startOffset|stdDeviation|stemh|stemv|stitchTiles|stopColor|stopOpacity|strikethroughPosition|strikethroughThickness|string|stroke|strokeDasharray|strokeDashoffset|strokeLinecap|strokeLinejoin|strokeMiterlimit|strokeOpacity|strokeWidth|surfaceScale|systemLanguage|tableValues|targetX|targetY|textAnchor|textDecoration|textRendering|textLength|to|transform|u1|u2|underlinePosition|underlineThickness|unicode|unicodeBidi|unicodeRange|unitsPerEm|vAlphabetic|vHanging|vIdeographic|vMathematical|values|vectorEffect|version|vertAdvY|vertOriginX|vertOriginY|viewBox|viewTarget|visibility|widths|wordSpacing|writingMode|x|xHeight|x1|x2|xChannelSelector|xlinkActuate|xlinkArcrole|xlinkHref|xlinkRole|xlinkShow|xlinkTitle|xlinkType|xmlBase|xmlns|xmlnsXlink|xmlLang|xmlSpace|y|y1|y2|yChannelSelector|z|zoomAndPan|for|class|autofocus)|(([Dd][Aa][Tt][Aa]|[Aa][Rr][Ii][Aa]|x)-.*))$/, Sj = JA(function(t) {
    return xj.test(t) || t.charCodeAt(0) === 111 && t.charCodeAt(1) === 110 && t.charCodeAt(2) < 91;
  }), wj = false, kj = Sj, Cj = function(e) {
    return e !== "theme";
  }, nC = function(e) {
    return typeof e == "string" && e.charCodeAt(0) > 96 ? kj : Cj;
  }, rC = function(e, n, r) {
    var i;
    if (n) {
      var o = n.shouldForwardProp;
      i = e.__emotion_forwardProp && o ? function(s) {
        return e.__emotion_forwardProp(s) && o(s);
      } : o;
    }
    return typeof i != "function" && r && (i = e.__emotion_forwardProp), i;
  }, Tj = function(e) {
    var n = e.cache, r = e.serialized, i = e.isStringTag;
    return Hb(n, r, i), aE(function() {
      return jb(n, r, i);
    }), null;
  }, Mj = function t(e, n) {
    var r = e.__emotion_real === e, i = r && e.__emotion_base || e, o, s;
    n !== void 0 && (o = n.label, s = n.target);
    var a = rC(e, n, r), l = a || nC(i), c = !l("as");
    return function() {
      var u = arguments, h = r && e.__emotion_styles !== void 0 ? e.__emotion_styles.slice(0) : [];
      if (o !== void 0 && h.push("label:" + o + ";"), u[0] == null || u[0].raw === void 0)
        h.push.apply(h, u);
      else {
        var p = u[0];
        h.push(p[0]);
        for (var v = u.length, y = 1; y < v; y++)
          h.push(u[y], p[y]);
      }
      var x = Ub(function(T, w, k) {
        var C = c && T.as || i, P = "", R = [], L = T;
        if (T.theme == null) {
          L = {};
          for (var _ in T)
            L[_] = T[_];
          L.theme = z.exports.useContext(ul);
        }
        typeof T.className == "string" ? P = iE(w.registered, R, T.className) : T.className != null && (P = T.className + " ");
        var F = Mm(h.concat(R), w.registered, L);
        P += w.key + "-" + F.name, s !== void 0 && (P += " " + s);
        var K = c && a === void 0 ? nC(C) : l, Y = {};
        for (var te in T)
          c && te === "as" || K(te) && (Y[te] = T[te]);
        return Y.className = P, k && (Y.ref = k), Xn(sp, {
          children: [
            J(Tj, {
              cache: w,
              serialized: F,
              isStringTag: typeof C == "string"
            }),
            J(C, {
              ...Y
            })
          ]
        });
      });
      return x.displayName = o !== void 0 ? o : "Styled(" + (typeof i == "string" ? i : i.displayName || i.name || "Component") + ")", x.defaultProps = e.defaultProps, x.__emotion_real = x, x.__emotion_base = i, x.__emotion_styles = h, x.__emotion_forwardProp = a, Object.defineProperty(x, "toString", {
        value: function() {
          return s === void 0 && wj ? "NO_COMPONENT_SELECTOR" : "." + s;
        }
      }), x.withComponent = function(T, w) {
        var k = t(T, Tu({}, n, w, {
          shouldForwardProp: rC(x, w, true)
        }));
        return k.apply(void 0, h);
      }, x;
    };
  }, Aj = [
    "a",
    "abbr",
    "address",
    "area",
    "article",
    "aside",
    "audio",
    "b",
    "base",
    "bdi",
    "bdo",
    "big",
    "blockquote",
    "body",
    "br",
    "button",
    "canvas",
    "caption",
    "cite",
    "code",
    "col",
    "colgroup",
    "data",
    "datalist",
    "dd",
    "del",
    "details",
    "dfn",
    "dialog",
    "div",
    "dl",
    "dt",
    "em",
    "embed",
    "fieldset",
    "figcaption",
    "figure",
    "footer",
    "form",
    "h1",
    "h2",
    "h3",
    "h4",
    "h5",
    "h6",
    "head",
    "header",
    "hgroup",
    "hr",
    "html",
    "i",
    "iframe",
    "img",
    "input",
    "ins",
    "kbd",
    "keygen",
    "label",
    "legend",
    "li",
    "link",
    "main",
    "map",
    "mark",
    "marquee",
    "menu",
    "menuitem",
    "meta",
    "meter",
    "nav",
    "noscript",
    "object",
    "ol",
    "optgroup",
    "option",
    "output",
    "p",
    "param",
    "picture",
    "pre",
    "progress",
    "q",
    "rp",
    "rt",
    "ruby",
    "s",
    "samp",
    "script",
    "section",
    "select",
    "small",
    "source",
    "span",
    "strong",
    "style",
    "sub",
    "summary",
    "sup",
    "table",
    "tbody",
    "td",
    "textarea",
    "tfoot",
    "th",
    "thead",
    "time",
    "title",
    "tr",
    "track",
    "u",
    "ul",
    "var",
    "video",
    "wbr",
    "circle",
    "clipPath",
    "defs",
    "ellipse",
    "foreignObject",
    "g",
    "image",
    "line",
    "linearGradient",
    "mask",
    "path",
    "pattern",
    "polygon",
    "polyline",
    "radialGradient",
    "rect",
    "stop",
    "svg",
    "text",
    "tspan"
  ], Ly = Mj.bind(null);
  Aj.forEach(function(t) {
    Ly[t] = Ly(t);
  });
  const Ej = /* @__PURE__ */ new Set([
    ...PB,
    "textStyle",
    "layerStyle",
    "apply",
    "noOfLines",
    "focusBorderColor",
    "errorBorderColor",
    "as",
    "__css",
    "css",
    "sx"
  ]), Pj = /* @__PURE__ */ new Set([
    "htmlWidth",
    "htmlHeight",
    "htmlSize",
    "htmlTranslate"
  ]);
  function Oj(t) {
    return (Pj.has(t) || !Ej.has(t)) && t[0] !== "_";
  }
  const Rj = HI(Ly), Lj = ({ baseStyle: t }) => (e) => {
    const { theme: n, css: r, __css: i, sx: o, ...s } = e, [a] = qI(s, RB), l = vi(t, e), c = OI({}, i, l, $I(a), o), u = TA(c)(e.theme);
    return r ? [
      u,
      r
    ] : u;
  };
  function M0(t, e) {
    const { baseStyle: n, ...r } = e ?? {};
    r.shouldForwardProp || (r.shouldForwardProp = Oj);
    const i = Lj({
      baseStyle: n
    }), o = Rj(t, r)(i);
    return z.exports.forwardRef(function(l, c) {
      const { children: u, ...h } = l, { colorMode: p, forced: v } = Gb(), y = v ? p : void 0;
      return z.exports.createElement(o, {
        ref: c,
        "data-theme": y,
        ...h
      }, u);
    });
  }
  function _j() {
    const t = /* @__PURE__ */ new Map();
    return new Proxy(M0, {
      apply(e, n, r) {
        return M0(...r);
      },
      get(e, n) {
        return t.has(n) || t.set(n, M0(n)), t.get(n);
      }
    });
  }
  const rn = _j(), Dj = {
    initial: (t) => {
      const { position: e } = t, n = [
        "top",
        "bottom"
      ].includes(e) ? "y" : "x";
      let r = [
        "top-right",
        "bottom-right"
      ].includes(e) ? 1 : -1;
      return e === "bottom" && (r = 1), {
        opacity: 0,
        [n]: r * 24
      };
    },
    animate: {
      opacity: 1,
      y: 0,
      x: 0,
      scale: 1,
      transition: {
        duration: 0.4,
        ease: [
          0.4,
          0,
          0.2,
          1
        ]
      }
    },
    exit: {
      opacity: 0,
      scale: 0.85,
      transition: {
        duration: 0.2,
        ease: [
          0.4,
          0,
          1,
          1
        ]
      }
    }
  }, HP = z.exports.memo((t) => {
    const { id: e, message: n, onCloseComplete: r, onRequestRemove: i, requestClose: o = false, position: s = "bottom", duration: a = 5e3, containerStyle: l, motionVariants: c = Dj, toastSpacing: u = "0.5rem" } = t, [h, p] = z.exports.useState(a), v = uH();
    kw(() => {
      v || (r == null ? void 0 : r());
    }, [
      v
    ]), kw(() => {
      p(a);
    }, [
      a
    ]);
    const y = () => p(null), x = () => p(a), T = () => {
      v && i();
    };
    z.exports.useEffect(() => {
      v && o && i();
    }, [
      v,
      o,
      i
    ]), XI(T, h);
    const w = z.exports.useMemo(() => ({
      pointerEvents: "auto",
      maxWidth: 560,
      minWidth: 300,
      margin: u,
      ...l
    }), [
      l,
      u
    ]), k = z.exports.useMemo(() => yj(s), [
      s
    ]);
    return J(fj.div, {
      layout: true,
      className: "chakra-toast",
      variants: c,
      initial: "initial",
      animate: "animate",
      exit: "exit",
      onHoverStart: y,
      onHoverEnd: x,
      custom: {
        position: s
      },
      style: k,
      children: J(rn.div, {
        role: "status",
        "aria-atomic": "true",
        className: "chakra-toast__inner",
        __css: w,
        children: vi(n, {
          id: e,
          onClose: T
        })
      })
    });
  });
  HP.displayName = "ToastComponent";
  function Ar(t) {
    return z.exports.forwardRef(t);
  }
  var Ij = typeof Element < "u", Bj = typeof Map == "function", Nj = typeof Set == "function", $j = typeof ArrayBuffer == "function" && !!ArrayBuffer.isView;
  function bd(t, e) {
    if (t === e)
      return true;
    if (t && e && typeof t == "object" && typeof e == "object") {
      if (t.constructor !== e.constructor)
        return false;
      var n, r, i;
      if (Array.isArray(t)) {
        if (n = t.length, n != e.length)
          return false;
        for (r = n; r-- !== 0; )
          if (!bd(t[r], e[r]))
            return false;
        return true;
      }
      var o;
      if (Bj && t instanceof Map && e instanceof Map) {
        if (t.size !== e.size)
          return false;
        for (o = t.entries(); !(r = o.next()).done; )
          if (!e.has(r.value[0]))
            return false;
        for (o = t.entries(); !(r = o.next()).done; )
          if (!bd(r.value[1], e.get(r.value[0])))
            return false;
        return true;
      }
      if (Nj && t instanceof Set && e instanceof Set) {
        if (t.size !== e.size)
          return false;
        for (o = t.entries(); !(r = o.next()).done; )
          if (!e.has(r.value[0]))
            return false;
        return true;
      }
      if ($j && ArrayBuffer.isView(t) && ArrayBuffer.isView(e)) {
        if (n = t.length, n != e.length)
          return false;
        for (r = n; r-- !== 0; )
          if (t[r] !== e[r])
            return false;
        return true;
      }
      if (t.constructor === RegExp)
        return t.source === e.source && t.flags === e.flags;
      if (t.valueOf !== Object.prototype.valueOf && typeof t.valueOf == "function" && typeof e.valueOf == "function")
        return t.valueOf() === e.valueOf();
      if (t.toString !== Object.prototype.toString && typeof t.toString == "function" && typeof e.toString == "function")
        return t.toString() === e.toString();
      if (i = Object.keys(t), n = i.length, n !== Object.keys(e).length)
        return false;
      for (r = n; r-- !== 0; )
        if (!Object.prototype.hasOwnProperty.call(e, i[r]))
          return false;
      if (Ij && t instanceof Element)
        return false;
      for (r = n; r-- !== 0; )
        if (!((i[r] === "_owner" || i[r] === "__v" || i[r] === "__o") && t.$$typeof) && !bd(t[i[r]], e[i[r]]))
          return false;
      return true;
    }
    return t !== t && e !== e;
  }
  var zj = function(e, n) {
    try {
      return bd(e, n);
    } catch (r) {
      if ((r.message || "").match(/stack|recursion/i))
        return console.warn("react-fast-compare cannot handle circular refs"), false;
      throw r;
    }
  };
  function Fj() {
    const t = z.exports.useContext(ul);
    if (!t)
      throw Error("useTheme: `theme` is undefined. Seems you forgot to wrap your app in `<ChakraProvider />` or `<ThemeProvider />`");
    return t;
  }
  function Vj() {
    const t = Gb(), e = Fj();
    return {
      ...t,
      theme: e
    };
  }
  function Hj(t) {
    return Object.fromEntries(Object.entries(t).filter(([e, n]) => n !== void 0 && e !== "children" && !z.exports.isValidElement(n)));
  }
  function jP(t, e = {}) {
    const { styleConfig: n, ...r } = e, { theme: i, colorMode: o } = Vj(), s = t ? xA(i, `components.${t}`) : void 0, a = n || s, l = yi({
      theme: i,
      colorMode: o
    }, (a == null ? void 0 : a.defaultProps) ?? {}, Hj(r), (u, h) => u ? void 0 : h), c = z.exports.useRef({});
    if (a) {
      const h = VB(a)(l);
      zj(c.current, h) || (c.current = h);
    }
    return c.current;
  }
  function xx(t, e = {}) {
    return jP(t, e);
  }
  function WP(t, e = {}) {
    return jP(t, e);
  }
  const iC = {
    path: Xn("g", {
      stroke: "currentColor",
      strokeWidth: "1.5",
      children: [
        J("path", {
          strokeLinecap: "round",
          fill: "none",
          d: "M9,9a3,3,0,1,1,4,2.829,1.5,1.5,0,0,0-1,1.415V14.25"
        }),
        J("path", {
          fill: "currentColor",
          strokeLinecap: "round",
          d: "M12,17.25a.375.375,0,1,0,.375.375A.375.375,0,0,0,12,17.25h0"
        }),
        J("circle", {
          fill: "none",
          strokeMiterlimit: "10",
          cx: "12",
          cy: "12",
          r: "11.25"
        })
      ]
    }),
    viewBox: "0 0 24 24"
  }, sf = Ar((t, e) => {
    const { as: n, viewBox: r, color: i = "currentColor", focusable: o = false, children: s, className: a, __css: l, ...c } = t, u = Gr("chakra-icon", a), h = xx("Icon", t), p = {
      w: "1em",
      h: "1em",
      display: "inline-block",
      lineHeight: "1em",
      flexShrink: 0,
      color: i,
      ...l,
      ...h
    }, v = {
      ref: e,
      focusable: o,
      className: u,
      __css: p
    }, y = r ?? iC.viewBox;
    if (n && typeof n != "string")
      return J(rn.svg, {
        as: n,
        ...v,
        ...c
      });
    const x = s ?? iC.path;
    return J(rn.svg, {
      verticalAlign: "middle",
      viewBox: y,
      ...v,
      ...c,
      children: x
    });
  });
  sf.displayName = "Icon";
  function jj(t) {
    return J(sf, {
      viewBox: "0 0 24 24",
      ...t,
      children: J("path", {
        fill: "currentColor",
        d: "M12,0A12,12,0,1,0,24,12,12.014,12.014,0,0,0,12,0Zm6.927,8.2-6.845,9.289a1.011,1.011,0,0,1-1.43.188L5.764,13.769a1,1,0,1,1,1.25-1.562l4.076,3.261,6.227-8.451A1,1,0,1,1,18.927,8.2Z"
      })
    });
  }
  function Wj(t) {
    return J(sf, {
      viewBox: "0 0 24 24",
      ...t,
      children: J("path", {
        fill: "currentColor",
        d: "M12,0A12,12,0,1,0,24,12,12.013,12.013,0,0,0,12,0Zm.25,5a1.5,1.5,0,1,1-1.5,1.5A1.5,1.5,0,0,1,12.25,5ZM14.5,18.5h-4a1,1,0,0,1,0-2h.75a.25.25,0,0,0,.25-.25v-4.5a.25.25,0,0,0-.25-.25H10.5a1,1,0,0,1,0-2h1a2,2,0,0,1,2,2v4.75a.25.25,0,0,0,.25.25h.75a1,1,0,1,1,0,2Z"
      })
    });
  }
  function oC(t) {
    return J(sf, {
      viewBox: "0 0 24 24",
      ...t,
      children: J("path", {
        fill: "currentColor",
        d: "M11.983,0a12.206,12.206,0,0,0-8.51,3.653A11.8,11.8,0,0,0,0,12.207,11.779,11.779,0,0,0,11.8,24h.214A12.111,12.111,0,0,0,24,11.791h0A11.766,11.766,0,0,0,11.983,0ZM10.5,16.542a1.476,1.476,0,0,1,1.449-1.53h.027a1.527,1.527,0,0,1,1.523,1.47,1.475,1.475,0,0,1-1.449,1.53h-.027A1.529,1.529,0,0,1,10.5,16.542ZM11,12.5v-6a1,1,0,0,1,2,0v6a1,1,0,1,1-2,0Z"
      })
    });
  }
  const Uj = vV({
    "0%": {
      transform: "rotate(0deg)"
    },
    "100%": {
      transform: "rotate(360deg)"
    }
  }), UP = Ar((t, e) => {
    const n = xx("Spinner", t), { label: r = "Loading...", thickness: i = "2px", speed: o = "0.45s", emptyColor: s = "transparent", className: a, ...l } = am(t), c = Gr("chakra-spinner", a), u = {
      display: "inline-block",
      borderColor: "currentColor",
      borderStyle: "solid",
      borderRadius: "99999px",
      borderWidth: i,
      borderBottomColor: s,
      borderLeftColor: s,
      animation: `${Uj} ${o} linear infinite`,
      ...n
    };
    return J(rn.div, {
      ref: e,
      __css: u,
      className: c,
      ...l,
      children: r && J(rn.span, {
        srOnly: true,
        children: r
      })
    });
  });
  UP.displayName = "Spinner";
  const [Kj, Sx] = Ei({
    name: "AlertContext",
    hookName: "useAlertContext",
    providerName: "<Alert />"
  }), [qj, wx] = Ei({
    name: "AlertStylesContext",
    hookName: "useAlertStyles",
    providerName: "<Alert />"
  }), KP = {
    info: {
      icon: Wj,
      colorScheme: "blue"
    },
    warning: {
      icon: oC,
      colorScheme: "orange"
    },
    success: {
      icon: jj,
      colorScheme: "green"
    },
    error: {
      icon: oC,
      colorScheme: "red"
    },
    loading: {
      icon: UP,
      colorScheme: "blue"
    }
  };
  function Gj(t) {
    return KP[t].colorScheme;
  }
  function Yj(t) {
    return KP[t].icon;
  }
  const qP = Ar(function(e, n) {
    const { status: r = "info", addRole: i = true, ...o } = am(e), s = e.colorScheme ?? Gj(r), a = WP("Alert", {
      ...e,
      colorScheme: s
    }), l = {
      width: "100%",
      display: "flex",
      alignItems: "center",
      position: "relative",
      overflow: "hidden",
      ...a.container
    };
    return J(Kj, {
      value: {
        status: r
      },
      children: J(qj, {
        value: a,
        children: J(rn.div, {
          "data-status": r,
          role: i ? "alert" : void 0,
          ref: n,
          ...o,
          className: Gr("chakra-alert", e.className),
          __css: l
        })
      })
    });
  });
  qP.displayName = "Alert";
  function GP(t) {
    const { status: e } = Sx(), n = Yj(e), r = wx(), i = e === "loading" ? r.spinner : r.icon;
    return J(rn.span, {
      display: "inherit",
      "data-status": e,
      ...t,
      className: Gr("chakra-alert__icon", t.className),
      __css: i,
      children: t.children || J(n, {
        h: "100%",
        w: "100%"
      })
    });
  }
  GP.displayName = "AlertIcon";
  const YP = Ar(function(e, n) {
    const r = wx(), { status: i } = Sx();
    return J(rn.div, {
      ref: n,
      "data-status": i,
      ...e,
      className: Gr("chakra-alert__title", e.className),
      __css: r.title
    });
  });
  YP.displayName = "AlertTitle";
  const XP = Ar(function(e, n) {
    const { status: r } = Sx(), i = wx(), o = {
      display: "inline",
      ...i.description
    };
    return J(rn.div, {
      ref: n,
      "data-status": r,
      ...e,
      className: Gr("chakra-alert__desc", e.className),
      __css: o
    });
  });
  XP.displayName = "AlertDescription";
  function Xj(t) {
    return J(sf, {
      focusable: "false",
      "aria-hidden": true,
      ...t,
      children: J("path", {
        fill: "currentColor",
        d: "M.439,21.44a1.5,1.5,0,0,0,2.122,2.121L11.823,14.3a.25.25,0,0,1,.354,0l9.262,9.263a1.5,1.5,0,1,0,2.122-2.121L14.3,12.177a.25.25,0,0,1,0-.354l9.263-9.262A1.5,1.5,0,0,0,21.439.44L12.177,9.7a.25.25,0,0,1-.354,0L2.561.44A1.5,1.5,0,0,0,.439,2.561L9.7,11.823a.25.25,0,0,1,0,.354Z"
      })
    });
  }
  const QP = Ar(function(e, n) {
    const r = xx("CloseButton", e), { children: i, isDisabled: o, __css: s, ...a } = am(e), l = {
      outline: 0,
      display: "flex",
      alignItems: "center",
      justifyContent: "center",
      flexShrink: 0
    };
    return J(rn.button, {
      type: "button",
      "aria-label": "Close",
      ref: n,
      disabled: o,
      __css: {
        ...l,
        ...r,
        ...s
      },
      ...a,
      children: i || J(Xj, {
        width: "1em",
        height: "1em"
      })
    });
  });
  QP.displayName = "CloseButton";
  const Qj = (t) => {
    const { status: e, variant: n = "solid", id: r, title: i, isClosable: o, onClose: s, description: a, colorScheme: l, icon: c } = t, u = r ? {
      root: `toast-${r}`,
      title: `toast-${r}-title`,
      description: `toast-${r}-description`
    } : void 0;
    return Xn(qP, {
      addRole: false,
      status: e,
      variant: n,
      id: u == null ? void 0 : u.root,
      alignItems: "start",
      borderRadius: "md",
      boxShadow: "lg",
      paddingEnd: 8,
      textAlign: "start",
      width: "auto",
      colorScheme: l,
      children: [
        J(GP, {
          children: c
        }),
        Xn(rn.div, {
          flex: "1",
          maxWidth: "100%",
          children: [
            i && J(YP, {
              id: u == null ? void 0 : u.title,
              children: i
            }),
            a && J(XP, {
              id: u == null ? void 0 : u.description,
              display: "block",
              children: a
            })
          ]
        }),
        o && J(QP, {
          size: "sm",
          onClick: s,
          position: "absolute",
          insetEnd: 1,
          top: 1
        })
      ]
    });
  };
  function Jj(t = {}) {
    const { render: e, toastComponent: n = Qj } = t;
    return (i) => typeof e == "function" ? e({
      ...i,
      ...t
    }) : J(n, {
      ...i,
      ...t
    });
  }
  const Zj = {
    top: [],
    "top-left": [],
    "top-right": [],
    "bottom-left": [],
    bottom: [],
    "bottom-right": []
  }, Gc = eW(Zj);
  function eW(t) {
    let e = t;
    const n = /* @__PURE__ */ new Set(), r = (i) => {
      e = i(e), n.forEach((o) => o());
    };
    return {
      getState: () => e,
      subscribe: (i) => (n.add(i), () => {
        r(() => t), n.delete(i);
      }),
      removeToast: (i, o) => {
        r((s) => ({
          ...s,
          [o]: s[o].filter((a) => a.id != i)
        }));
      },
      notify: (i, o) => {
        const s = tW(i, o), { position: a, id: l } = s;
        return r((c) => {
          const h = a.includes("top") ? [
            s,
            ...c[a] ?? []
          ] : [
            ...c[a] ?? [],
            s
          ];
          return {
            ...c,
            [a]: h
          };
        }), l;
      },
      update: (i, o) => {
        !i || r((s) => {
          const a = {
            ...s
          }, { position: l, index: c } = tC(a, i);
          return l && c !== -1 && (a[l][c] = {
            ...a[l][c],
            ...o,
            message: Jj(o)
          }), a;
        });
      },
      closeAll: ({ positions: i } = {}) => {
        r((o) => (i ?? [
          "bottom",
          "bottom-right",
          "bottom-left",
          "top",
          "top-left",
          "top-right"
        ]).reduce((l, c) => (l[c] = o[c].map((u) => ({
          ...u,
          requestClose: true
        })), l), {
          ...o
        }));
      },
      close: (i) => {
        r((o) => {
          const s = VP(o, i);
          return s ? {
            ...o,
            [s]: o[s].map((a) => a.id == i ? {
              ...a,
              requestClose: true
            } : a)
          } : o;
        });
      },
      isActive: (i) => Boolean(tC(Gc.getState(), i).position)
    };
  }
  let sC = 0;
  function tW(t, e = {}) {
    sC += 1;
    const n = e.id ?? sC, r = e.position ?? "bottom";
    return {
      id: n,
      message: t,
      position: r,
      duration: e.duration,
      onCloseComplete: e.onCloseComplete,
      onRequestRemove: () => Gc.removeToast(String(n), r),
      status: e.status,
      requestClose: false,
      containerStyle: e.containerStyle
    };
  }
  const [JP, nW] = Ei({
    strict: false,
    name: "PortalContext"
  }), kx = "chakra-portal", rW = ".chakra-portal", iW = (t) => J("div", {
    className: "chakra-portal-zIndex",
    style: {
      position: "absolute",
      zIndex: t.zIndex,
      top: 0,
      left: 0,
      right: 0
    },
    children: t.children
  }), oW = (t) => {
    const { appendToParentPortal: e, children: n } = t, [r, i] = z.exports.useState(null), o = z.exports.useRef(null), [, s] = z.exports.useState({});
    z.exports.useEffect(() => s({}), []);
    const a = nW(), l = PV();
    ty(() => {
      if (!r)
        return;
      const u = r.ownerDocument, h = e ? a ?? u.body : u.body;
      if (!h)
        return;
      o.current = u.createElement("div"), o.current.className = kx, h.appendChild(o.current), s({});
      const p = o.current;
      return () => {
        h.contains(p) && h.removeChild(p);
      };
    }, [
      r
    ]);
    const c = (l == null ? void 0 : l.zIndex) ? J(iW, {
      zIndex: l == null ? void 0 : l.zIndex,
      children: n
    }) : n;
    return o.current ? Wp.exports.createPortal(J(JP, {
      value: o.current,
      children: c
    }), o.current) : J("span", {
      ref: (u) => {
        u && i(u);
      }
    });
  }, sW = (t) => {
    const { children: e, containerRef: n, appendToParentPortal: r } = t, i = n.current, o = i ?? (typeof window < "u" ? document.body : void 0), s = z.exports.useMemo(() => {
      const l = i == null ? void 0 : i.ownerDocument.createElement("div");
      return l && (l.className = kx), l;
    }, [
      i
    ]), [, a] = z.exports.useState({});
    return ty(() => a({}), []), ty(() => {
      if (!(!s || !o))
        return o.appendChild(s), () => {
          o.removeChild(s);
        };
    }, [
      s,
      o
    ]), o && s ? Wp.exports.createPortal(J(JP, {
      value: r ? s : null,
      children: e
    }), s) : null;
  };
  function Im(t) {
    const e = {
      appendToParentPortal: true,
      ...t
    }, { containerRef: n, ...r } = e;
    return n ? J(sW, {
      containerRef: n,
      ...r
    }) : J(oW, {
      ...r
    });
  }
  Im.className = kx;
  Im.selector = rW;
  Im.displayName = "Portal";
  const [aW, iJ] = Ei({
    name: "ToastOptionsContext",
    strict: false
  }), lW = (t) => {
    const e = z.exports.useSyncExternalStore(Gc.subscribe, Gc.getState, Gc.getState), { motionVariants: n, component: r = HP, portalProps: i, animatePresenceProps: o } = t, a = Object.keys(e).map((l) => {
      const c = e[l];
      return J("div", {
        role: "region",
        "aria-live": "polite",
        "aria-label": `Notifications-${l}`,
        id: `chakra-toast-manager-${l}`,
        style: bj(l),
        children: J(gj, {
          ...o,
          initial: false,
          children: c.map((u) => J(r, {
            motionVariants: n,
            ...u
          }, u.id))
        })
      }, l);
    });
    return J(Im, {
      ...i,
      children: a
    });
  }, cW = (t) => function({ children: n, theme: r = t, toastOptions: i, ...o }) {
    return Xn(OV, {
      theme: r,
      ...o,
      children: [
        J(aW, {
          value: i == null ? void 0 : i.defaultOptions,
          children: n
        }),
        J(lW, {
          ...i
        })
      ]
    });
  }, uW = cW(lF);
  function aC(t) {
    return t.sort((e, n) => {
      const r = e.compareDocumentPosition(n);
      if (r & Node.DOCUMENT_POSITION_FOLLOWING || r & Node.DOCUMENT_POSITION_CONTAINED_BY)
        return -1;
      if (r & Node.DOCUMENT_POSITION_PRECEDING || r & Node.DOCUMENT_POSITION_CONTAINS)
        return 1;
      if (r & Node.DOCUMENT_POSITION_DISCONNECTED || r & Node.DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC)
        throw Error("Cannot sort the given nodes.");
      return 0;
    });
  }
  const fW = (t) => typeof t == "object" && "nodeType" in t && t.nodeType === Node.ELEMENT_NODE;
  function lC(t, e, n) {
    let r = t + 1;
    return n && r >= e && (r = 0), r;
  }
  function cC(t, e, n) {
    let r = t - 1;
    return n && r < 0 && (r = e), r;
  }
  const A0 = typeof window < "u" ? z.exports.useLayoutEffect : z.exports.useEffect, uC = (t) => t;
  var hW = Object.defineProperty, dW = (t, e, n) => e in t ? hW(t, e, {
    enumerable: true,
    configurable: true,
    writable: true,
    value: n
  }) : t[e] = n, xt = (t, e, n) => (dW(t, typeof e != "symbol" ? e + "" : e, n), n);
  class pW {
    constructor() {
      xt(this, "descendants", /* @__PURE__ */ new Map()), xt(this, "register", (e) => {
        if (e != null)
          return fW(e) ? this.registerNode(e) : (n) => {
            this.registerNode(n, e);
          };
      }), xt(this, "unregister", (e) => {
        this.descendants.delete(e);
        const n = aC(Array.from(this.descendants.keys()));
        this.assignIndex(n);
      }), xt(this, "destroy", () => {
        this.descendants.clear();
      }), xt(this, "assignIndex", (e) => {
        this.descendants.forEach((n) => {
          const r = e.indexOf(n.node);
          n.index = r, n.node.dataset.index = n.index.toString();
        });
      }), xt(this, "count", () => this.descendants.size), xt(this, "enabledCount", () => this.enabledValues().length), xt(this, "values", () => Array.from(this.descendants.values()).sort((n, r) => n.index - r.index)), xt(this, "enabledValues", () => this.values().filter((e) => !e.disabled)), xt(this, "item", (e) => {
        if (this.count() !== 0)
          return this.values()[e];
      }), xt(this, "enabledItem", (e) => {
        if (this.enabledCount() !== 0)
          return this.enabledValues()[e];
      }), xt(this, "first", () => this.item(0)), xt(this, "firstEnabled", () => this.enabledItem(0)), xt(this, "last", () => this.item(this.descendants.size - 1)), xt(this, "lastEnabled", () => {
        const e = this.enabledValues().length - 1;
        return this.enabledItem(e);
      }), xt(this, "indexOf", (e) => {
        var _a3;
        return e ? ((_a3 = this.descendants.get(e)) == null ? void 0 : _a3.index) ?? -1 : -1;
      }), xt(this, "enabledIndexOf", (e) => e == null ? -1 : this.enabledValues().findIndex((n) => n.node.isSameNode(e))), xt(this, "next", (e, n = true) => {
        const r = lC(e, this.count(), n);
        return this.item(r);
      }), xt(this, "nextEnabled", (e, n = true) => {
        const r = this.item(e);
        if (!r)
          return;
        const i = this.enabledIndexOf(r.node), o = lC(i, this.enabledCount(), n);
        return this.enabledItem(o);
      }), xt(this, "prev", (e, n = true) => {
        const r = cC(e, this.count() - 1, n);
        return this.item(r);
      }), xt(this, "prevEnabled", (e, n = true) => {
        const r = this.item(e);
        if (!r)
          return;
        const i = this.enabledIndexOf(r.node), o = cC(i, this.enabledCount() - 1, n);
        return this.enabledItem(o);
      }), xt(this, "registerNode", (e, n) => {
        if (!e || this.descendants.has(e))
          return;
        const r = Array.from(this.descendants.keys()).concat(e), i = aC(r);
        (n == null ? void 0 : n.disabled) && (n.disabled = !!n.disabled);
        const o = {
          node: e,
          index: -1,
          ...n
        };
        this.descendants.set(e, o), this.assignIndex(i);
      });
    }
  }
  function mW() {
    const [t, e] = Ei({
      name: "DescendantsProvider",
      errorMessage: "useDescendantsContext must be used within DescendantsProvider"
    });
    return [
      t,
      e,
      () => {
        const i = z.exports.useRef(new pW());
        return A0(() => () => i.current.destroy()), i.current;
      },
      (i) => {
        const o = e(), [s, a] = z.exports.useState(-1), l = z.exports.useRef(null);
        A0(() => () => {
          !l.current || o.unregister(l.current);
        }, []), A0(() => {
          if (!l.current)
            return;
          const u = Number(l.current.dataset.index);
          s != u && !Number.isNaN(u) && a(u);
        });
        const c = uC(i ? o.register(i) : o.register);
        return {
          descendants: o,
          index: s,
          enabledIndex: o.enabledIndexOf(l.current),
          register: Eb(c, l)
        };
      }
    ];
  }
  function gW(t, e) {
    if (t == null)
      return {};
    var n = {};
    for (var r in t)
      if ({}.hasOwnProperty.call(t, r)) {
        if (e.indexOf(r) !== -1)
          continue;
        n[r] = t[r];
      }
    return n;
  }
  const ZP = Ar(function(e, n) {
    const { templateAreas: r, gap: i, rowGap: o, columnGap: s, column: a, row: l, autoFlow: c, autoRows: u, templateRows: h, autoColumns: p, templateColumns: v, ...y } = e, x = {
      display: "grid",
      gridTemplateAreas: r,
      gridGap: i,
      gridRowGap: o,
      gridColumnGap: s,
      gridAutoColumns: p,
      gridColumn: a,
      gridRow: l,
      gridAutoFlow: c,
      gridAutoRows: u,
      gridTemplateRows: h,
      gridTemplateColumns: v
    };
    return J(rn.div, {
      ref: n,
      __css: x,
      ...y
    });
  });
  ZP.displayName = "Grid";
  function vW() {
    const t = z.exports.useRef(/* @__PURE__ */ new Map()), e = t.current, n = z.exports.useCallback((i, o, s, a) => {
      t.current.set(s, {
        type: o,
        el: i,
        options: a
      }), i.addEventListener(o, s, a);
    }, []), r = z.exports.useCallback((i, o, s, a) => {
      i.removeEventListener(o, s, a), t.current.delete(s);
    }, []);
    return z.exports.useEffect(() => () => {
      e.forEach((i, o) => {
        r(i.el, i.type, o, i.options);
      });
    }, [
      r,
      e
    ]), {
      add: n,
      remove: r
    };
  }
  function E0(t) {
    var _a3, _b3;
    const e = ((_b3 = (_a3 = t.composedPath) == null ? void 0 : _a3.call(t)) == null ? void 0 : _b3[0]) ?? t.target, { tagName: n, isContentEditable: r } = e;
    return n !== "INPUT" && n !== "TEXTAREA" && r !== true;
  }
  function yW(t = {}) {
    const { ref: e, isDisabled: n, isFocusable: r, clickOnEnter: i = true, clickOnSpace: o = true, onMouseDown: s, onMouseUp: a, onClick: l, onKeyDown: c, onKeyUp: u, tabIndex: h, onMouseOver: p, onMouseLeave: v, ...y } = t, [x, T] = z.exports.useState(true), [w, k] = z.exports.useState(false), C = vW(), P = (ee) => {
      !ee || ee.tagName !== "BUTTON" && T(false);
    }, R = x ? h : h || 0, L = n && !r, _ = z.exports.useCallback((ee) => {
      if (n) {
        ee.stopPropagation(), ee.preventDefault();
        return;
      }
      ee.currentTarget.focus(), l == null ? void 0 : l(ee);
    }, [
      n,
      l
    ]), F = z.exports.useCallback((ee) => {
      w && E0(ee) && (ee.preventDefault(), ee.stopPropagation(), k(false), C.remove(document, "keyup", F, false));
    }, [
      w,
      C
    ]), K = z.exports.useCallback((ee) => {
      if (c == null ? void 0 : c(ee), n || ee.defaultPrevented || ee.metaKey || !E0(ee.nativeEvent) || x)
        return;
      const V = i && ee.key === "Enter";
      o && ee.key === " " && (ee.preventDefault(), k(true)), V && (ee.preventDefault(), ee.currentTarget.click()), C.add(document, "keyup", F, false);
    }, [
      n,
      x,
      c,
      i,
      o,
      C,
      F
    ]), Y = z.exports.useCallback((ee) => {
      if (u == null ? void 0 : u(ee), n || ee.defaultPrevented || ee.metaKey || !E0(ee.nativeEvent) || x)
        return;
      o && ee.key === " " && (ee.preventDefault(), k(false), ee.currentTarget.click());
    }, [
      o,
      x,
      n,
      u
    ]), te = z.exports.useCallback((ee) => {
      ee.button === 0 && (k(false), C.remove(document, "mouseup", te, false));
    }, [
      C
    ]), ne = z.exports.useCallback((ee) => {
      if (ee.button !== 0)
        return;
      if (n) {
        ee.stopPropagation(), ee.preventDefault();
        return;
      }
      x || k(true), ee.currentTarget.focus({
        preventScroll: true
      }), C.add(document, "mouseup", te, false), s == null ? void 0 : s(ee);
    }, [
      n,
      x,
      s,
      C,
      te
    ]), ae = z.exports.useCallback((ee) => {
      ee.button === 0 && (x || k(false), a == null ? void 0 : a(ee));
    }, [
      a,
      x
    ]), ye = z.exports.useCallback((ee) => {
      if (n) {
        ee.preventDefault();
        return;
      }
      p == null ? void 0 : p(ee);
    }, [
      n,
      p
    ]), Ce = z.exports.useCallback((ee) => {
      w && (ee.preventDefault(), k(false)), v == null ? void 0 : v(ee);
    }, [
      w,
      v
    ]), Re = Eb(e, P);
    return x ? {
      ...y,
      ref: Re,
      type: "button",
      "aria-disabled": L ? void 0 : n,
      disabled: L,
      onClick: _,
      onMouseDown: s,
      onMouseUp: a,
      onKeyUp: u,
      onKeyDown: c,
      onMouseOver: p,
      onMouseLeave: v
    } : {
      ...y,
      ref: Re,
      role: "button",
      "data-active": RI(w),
      "aria-disabled": n ? "true" : void 0,
      tabIndex: L ? void 0 : R,
      onClick: _,
      onMouseDown: ne,
      onMouseUp: ae,
      onKeyUp: Y,
      onKeyDown: K,
      onMouseOver: ye,
      onMouseLeave: Ce
    };
  }
  const [bW, xW, SW, wW] = mW();
  function kW(t) {
    const { defaultIndex: e, onChange: n, index: r, isManual: i, isLazy: o, lazyBehavior: s = "unmount", orientation: a = "horizontal", direction: l = "ltr", ...c } = t, [u, h] = z.exports.useState(e ?? 0), [p, v] = GI({
      defaultValue: e ?? 0,
      value: r,
      onChange: n
    });
    z.exports.useEffect(() => {
      r != null && h(r);
    }, [
      r
    ]);
    const y = SW(), x = z.exports.useId();
    return {
      id: `tabs-${t.id ?? x}`,
      selectedIndex: p,
      focusedIndex: u,
      setSelectedIndex: v,
      setFocusedIndex: h,
      isManual: i,
      isLazy: o,
      lazyBehavior: s,
      orientation: a,
      descendants: y,
      direction: l,
      htmlProps: c
    };
  }
  const [CW, Bm] = Ei({
    name: "TabsContext",
    errorMessage: "useTabsContext: `context` is undefined. Seems you forgot to wrap all tabs components within <Tabs />"
  });
  function TW(t) {
    const { focusedIndex: e, orientation: n, direction: r } = Bm(), i = xW(), o = z.exports.useCallback((s) => {
      const a = () => {
        var _a3;
        const k = i.nextEnabled(e);
        k && ((_a3 = k.node) == null ? void 0 : _a3.focus());
      }, l = () => {
        var _a3;
        const k = i.prevEnabled(e);
        k && ((_a3 = k.node) == null ? void 0 : _a3.focus());
      }, c = () => {
        var _a3;
        const k = i.firstEnabled();
        k && ((_a3 = k.node) == null ? void 0 : _a3.focus());
      }, u = () => {
        var _a3;
        const k = i.lastEnabled();
        k && ((_a3 = k.node) == null ? void 0 : _a3.focus());
      }, h = n === "horizontal", p = n === "vertical", v = s.key, y = r === "ltr" ? "ArrowLeft" : "ArrowRight", x = r === "ltr" ? "ArrowRight" : "ArrowLeft", w = {
        [y]: () => h && l(),
        [x]: () => h && a(),
        ArrowDown: () => p && a(),
        ArrowUp: () => p && l(),
        Home: c,
        End: u
      }[v];
      w && (s.preventDefault(), w(s));
    }, [
      i,
      e,
      n,
      r
    ]);
    return {
      ...t,
      role: "tablist",
      "aria-orientation": n,
      onKeyDown: Zv(t.onKeyDown, o)
    };
  }
  function MW(t) {
    const { isDisabled: e = false, isFocusable: n = false, ...r } = t, { setSelectedIndex: i, isManual: o, id: s, setFocusedIndex: a, selectedIndex: l } = Bm(), { index: c, register: u } = wW({
      disabled: e && !n
    }), h = c === l, p = () => {
      i(c);
    }, v = () => {
      a(c), !o && !(e && n) && i(c);
    }, y = yW({
      ...r,
      ref: Eb(u, t.ref),
      isDisabled: e,
      isFocusable: n,
      onClick: Zv(t.onClick, p)
    }), x = "button";
    return {
      ...y,
      id: eO(s, c),
      role: "tab",
      tabIndex: h ? 0 : -1,
      type: x,
      "aria-selected": h,
      "aria-controls": tO(s, c),
      onFocus: e ? void 0 : Zv(t.onFocus, v)
    };
  }
  const [AW, EW] = Ei({});
  function PW(t) {
    const e = Bm(), { id: n, selectedIndex: r } = e, o = NI(t.children).map((s, a) => z.exports.createElement(AW, {
      key: s.key ?? a,
      value: {
        isSelected: a === r,
        id: tO(n, a),
        tabId: eO(n, a),
        selectedIndex: r
      }
    }, s));
    return {
      ...t,
      children: o
    };
  }
  function OW(t) {
    const { children: e, ...n } = t, { isLazy: r, lazyBehavior: i } = Bm(), { isSelected: o, id: s, tabId: a } = EW(), l = z.exports.useRef(false);
    o && (l.current = true);
    const c = jI({
      wasSelected: l.current,
      isSelected: o,
      enabled: r,
      mode: i
    });
    return {
      tabIndex: 0,
      ...n,
      children: c ? e : null,
      role: "tabpanel",
      "aria-labelledby": a,
      hidden: !o,
      id: s
    };
  }
  function eO(t, e) {
    return `${t}--tab-${e}`;
  }
  function tO(t, e) {
    return `${t}--tabpanel-${e}`;
  }
  const [RW, Nm] = Ei({
    name: "TabsStylesContext",
    errorMessage: `useTabsStyles returned is 'undefined'. Seems you forgot to wrap the components in "<Tabs />" `
  }), nO = Ar(function(e, n) {
    const r = WP("Tabs", e), { children: i, className: o, ...s } = am(e), { htmlProps: a, descendants: l, ...c } = kW(s), u = z.exports.useMemo(() => c, [
      c
    ]), { isFitted: h, ...p } = a, v = {
      position: "relative",
      ...r.root
    };
    return J(bW, {
      value: l,
      children: J(CW, {
        value: u,
        children: J(RW, {
          value: r,
          children: J(rn.div, {
            className: Gr("chakra-tabs", o),
            ref: n,
            ...p,
            __css: v,
            children: i
          })
        })
      })
    });
  });
  nO.displayName = "Tabs";
  const rO = Ar(function(e, n) {
    const r = Nm(), i = MW({
      ...e,
      ref: n
    }), o = {
      outline: "0",
      display: "flex",
      alignItems: "center",
      justifyContent: "center",
      ...r.tab
    };
    return J(rn.button, {
      ...i,
      className: Gr("chakra-tabs__tab", e.className),
      __css: o
    });
  });
  rO.displayName = "Tab";
  const iO = Ar(function(e, n) {
    const r = TW({
      ...e,
      ref: n
    }), i = Nm(), o = {
      display: "flex",
      ...i.tablist
    };
    return J(rn.div, {
      ...r,
      className: Gr("chakra-tabs__tablist", e.className),
      __css: o
    });
  });
  iO.displayName = "TabList";
  const _y = Ar(function(e, n) {
    const r = OW({
      ...e,
      ref: n
    }), i = Nm();
    return J(rn.div, {
      outline: "0",
      ...r,
      className: Gr("chakra-tabs__tab-panel", e.className),
      __css: i.tabpanel
    });
  });
  _y.displayName = "TabPanel";
  const oO = Ar(function(e, n) {
    const r = PW(e), i = Nm();
    return J(rn.div, {
      ...r,
      width: "100%",
      ref: n,
      className: Gr("chakra-tabs__tab-panels", e.className),
      __css: i.tabpanels
    });
  });
  oO.displayName = "TabPanels";
  let Dy = [], sO = [];
  (() => {
    let t = "lc,34,7n,7,7b,19,,,,2,,2,,,20,b,1c,l,g,,2t,7,2,6,2,2,,4,z,,u,r,2j,b,1m,9,9,,o,4,,9,,3,,5,17,3,3b,f,,w,1j,,,,4,8,4,,3,7,a,2,t,,1m,,,,2,4,8,,9,,a,2,q,,2,2,1l,,4,2,4,2,2,3,3,,u,2,3,,b,2,1l,,4,5,,2,4,,k,2,m,6,,,1m,,,2,,4,8,,7,3,a,2,u,,1n,,,,c,,9,,14,,3,,1l,3,5,3,,4,7,2,b,2,t,,1m,,2,,2,,3,,5,2,7,2,b,2,s,2,1l,2,,,2,4,8,,9,,a,2,t,,20,,4,,2,3,,,8,,29,,2,7,c,8,2q,,2,9,b,6,22,2,r,,,,,,1j,e,,5,,2,5,b,,10,9,,2u,4,,6,,2,2,2,p,2,4,3,g,4,d,,2,2,6,,f,,jj,3,qa,3,t,3,t,2,u,2,1s,2,,7,8,,2,b,9,,19,3,3b,2,y,,3a,3,4,2,9,,6,3,63,2,2,,1m,,,7,,,,,2,8,6,a,2,,1c,h,1r,4,1c,7,,,5,,14,9,c,2,w,4,2,2,,3,1k,,,2,3,,,3,1m,8,2,2,48,3,,d,,7,4,,6,,3,2,5i,1m,,5,ek,,5f,x,2da,3,3x,,2o,w,fe,6,2x,2,n9w,4,,a,w,2,28,2,7k,,3,,4,,p,2,5,,47,2,q,i,d,,12,8,p,b,1a,3,1c,,2,4,2,2,13,,1v,6,2,2,2,2,c,,8,,1b,,1f,,,3,2,2,5,2,,,16,2,8,,6m,,2,,4,,fn4,,kh,g,g,g,a6,2,gt,,6a,,45,5,1ae,3,,2,5,4,14,3,4,,4l,2,fx,4,ar,2,49,b,4w,,1i,f,1k,3,1d,4,2,2,1x,3,10,5,,8,1q,,c,2,1g,9,a,4,2,,2n,3,2,,,2,6,,4g,,3,8,l,2,1l,2,,,,,m,,e,7,3,5,5f,8,2,3,,,n,,29,,2,6,,,2,,,2,,2,6j,,2,4,6,2,,2,r,2,2d,8,2,,,2,2y,,,,2,6,,,2t,3,2,4,,5,77,9,,2,6t,,a,2,,,4,,40,4,2,2,4,,w,a,14,6,2,4,8,,9,6,2,3,1a,d,,2,ba,7,,6,,,2a,m,2,7,,2,,2,3e,6,3,,,2,,7,,,20,2,3,,,,9n,2,f0b,5,1n,7,t4,,1r,4,29,,f5k,2,43q,,,3,4,5,8,8,2,7,u,4,44,3,1iz,1j,4,1e,8,,e,,m,5,,f,11s,7,,h,2,7,,2,,5,79,7,c5,4,15s,7,31,7,240,5,gx7k,2o,3k,6o".split(",").map((e) => e ? parseInt(e, 36) : 1);
    for (let e = 0, n = 0; e < t.length; e++)
      (e % 2 ? sO : Dy).push(n = n + t[e]);
  })();
  function LW(t) {
    if (t < 768)
      return false;
    for (let e = 0, n = Dy.length; ; ) {
      let r = e + n >> 1;
      if (t < Dy[r])
        n = r;
      else if (t >= sO[r])
        e = r + 1;
      else
        return true;
      if (e == n)
        return false;
    }
  }
  function fC(t) {
    return t >= 127462 && t <= 127487;
  }
  const hC = 8205;
  function _W(t, e, n = true, r = true) {
    return (n ? aO : DW)(t, e, r);
  }
  function aO(t, e, n) {
    if (e == t.length)
      return e;
    e && lO(t.charCodeAt(e)) && cO(t.charCodeAt(e - 1)) && e--;
    let r = P0(t, e);
    for (e += dC(r); e < t.length; ) {
      let i = P0(t, e);
      if (r == hC || i == hC || n && LW(i))
        e += dC(i), r = i;
      else if (fC(i)) {
        let o = 0, s = e - 2;
        for (; s >= 0 && fC(P0(t, s)); )
          o++, s -= 2;
        if (o % 2 == 0)
          break;
        e += 2;
      } else
        break;
    }
    return e;
  }
  function DW(t, e, n) {
    for (; e > 0; ) {
      let r = aO(t, e - 2, n);
      if (r < e)
        return r;
      e--;
    }
    return 0;
  }
  function P0(t, e) {
    let n = t.charCodeAt(e);
    if (!cO(n) || e + 1 == t.length)
      return n;
    let r = t.charCodeAt(e + 1);
    return lO(r) ? (n - 55296 << 10) + (r - 56320) + 65536 : n;
  }
  function lO(t) {
    return t >= 56320 && t < 57344;
  }
  function cO(t) {
    return t >= 55296 && t < 56320;
  }
  function dC(t) {
    return t < 65536 ? 1 : 2;
  }
  class He {
    lineAt(e) {
      if (e < 0 || e > this.length)
        throw new RangeError(`Invalid position ${e} in document of length ${this.length}`);
      return this.lineInner(e, false, 1, 0);
    }
    line(e) {
      if (e < 1 || e > this.lines)
        throw new RangeError(`Invalid line number ${e} in ${this.lines}-line document`);
      return this.lineInner(e, true, 1, 0);
    }
    replace(e, n, r) {
      [e, n] = dl(this, e, n);
      let i = [];
      return this.decompose(0, e, i, 2), r.length && r.decompose(0, r.length, i, 3), this.decompose(n, this.length, i, 1), pi.from(i, this.length - (n - e) + r.length);
    }
    append(e) {
      return this.replace(this.length, this.length, e);
    }
    slice(e, n = this.length) {
      [e, n] = dl(this, e, n);
      let r = [];
      return this.decompose(e, n, r, 0), pi.from(r, n - e);
    }
    eq(e) {
      if (e == this)
        return true;
      if (e.length != this.length || e.lines != this.lines)
        return false;
      let n = this.scanIdentical(e, 1), r = this.length - this.scanIdentical(e, -1), i = new Yc(this), o = new Yc(e);
      for (let s = n, a = n; ; ) {
        if (i.next(s), o.next(s), s = 0, i.lineBreak != o.lineBreak || i.done != o.done || i.value != o.value)
          return false;
        if (a += i.value.length, i.done || a >= r)
          return true;
      }
    }
    iter(e = 1) {
      return new Yc(this, e);
    }
    iterRange(e, n = this.length) {
      return new uO(this, e, n);
    }
    iterLines(e, n) {
      let r;
      if (e == null)
        r = this.iter();
      else {
        n == null && (n = this.lines + 1);
        let i = this.line(e).from;
        r = this.iterRange(i, Math.max(i, n == this.lines + 1 ? this.length : n <= 1 ? 0 : this.line(n - 1).to));
      }
      return new fO(r);
    }
    toString() {
      return this.sliceString(0);
    }
    toJSON() {
      let e = [];
      return this.flatten(e), e;
    }
    constructor() {
    }
    static of(e) {
      if (e.length == 0)
        throw new RangeError("A document must have at least one line");
      return e.length == 1 && !e[0] ? He.empty : e.length <= 32 ? new Tt(e) : pi.from(Tt.split(e, []));
    }
  }
  class Tt extends He {
    constructor(e, n = IW(e)) {
      super(), this.text = e, this.length = n;
    }
    get lines() {
      return this.text.length;
    }
    get children() {
      return null;
    }
    lineInner(e, n, r, i) {
      for (let o = 0; ; o++) {
        let s = this.text[o], a = i + s.length;
        if ((n ? r : a) >= e)
          return new BW(i, a, r, s);
        i = a + 1, r++;
      }
    }
    decompose(e, n, r, i) {
      let o = e <= 0 && n >= this.length ? this : new Tt(pC(this.text, e, n), Math.min(n, this.length) - Math.max(0, e));
      if (i & 1) {
        let s = r.pop(), a = xd(o.text, s.text.slice(), 0, o.length);
        if (a.length <= 32)
          r.push(new Tt(a, s.length + o.length));
        else {
          let l = a.length >> 1;
          r.push(new Tt(a.slice(0, l)), new Tt(a.slice(l)));
        }
      } else
        r.push(o);
    }
    replace(e, n, r) {
      if (!(r instanceof Tt))
        return super.replace(e, n, r);
      [e, n] = dl(this, e, n);
      let i = xd(this.text, xd(r.text, pC(this.text, 0, e)), n), o = this.length + r.length - (n - e);
      return i.length <= 32 ? new Tt(i, o) : pi.from(Tt.split(i, []), o);
    }
    sliceString(e, n = this.length, r = `
`) {
      [e, n] = dl(this, e, n);
      let i = "";
      for (let o = 0, s = 0; o <= n && s < this.text.length; s++) {
        let a = this.text[s], l = o + a.length;
        o > e && s && (i += r), e < l && n > o && (i += a.slice(Math.max(0, e - o), n - o)), o = l + 1;
      }
      return i;
    }
    flatten(e) {
      for (let n of this.text)
        e.push(n);
    }
    scanIdentical() {
      return 0;
    }
    static split(e, n) {
      let r = [], i = -1;
      for (let o of e)
        r.push(o), i += o.length + 1, r.length == 32 && (n.push(new Tt(r, i)), r = [], i = -1);
      return i > -1 && n.push(new Tt(r, i)), n;
    }
  }
  class pi extends He {
    constructor(e, n) {
      super(), this.children = e, this.length = n, this.lines = 0;
      for (let r of e)
        this.lines += r.lines;
    }
    lineInner(e, n, r, i) {
      for (let o = 0; ; o++) {
        let s = this.children[o], a = i + s.length, l = r + s.lines - 1;
        if ((n ? l : a) >= e)
          return s.lineInner(e, n, r, i);
        i = a + 1, r = l + 1;
      }
    }
    decompose(e, n, r, i) {
      for (let o = 0, s = 0; s <= n && o < this.children.length; o++) {
        let a = this.children[o], l = s + a.length;
        if (e <= l && n >= s) {
          let c = i & ((s <= e ? 1 : 0) | (l >= n ? 2 : 0));
          s >= e && l <= n && !c ? r.push(a) : a.decompose(e - s, n - s, r, c);
        }
        s = l + 1;
      }
    }
    replace(e, n, r) {
      if ([e, n] = dl(this, e, n), r.lines < this.lines)
        for (let i = 0, o = 0; i < this.children.length; i++) {
          let s = this.children[i], a = o + s.length;
          if (e >= o && n <= a) {
            let l = s.replace(e - o, n - o, r), c = this.lines - s.lines + l.lines;
            if (l.lines < c >> 5 - 1 && l.lines > c >> 5 + 1) {
              let u = this.children.slice();
              return u[i] = l, new pi(u, this.length - (n - e) + r.length);
            }
            return super.replace(o, a, l);
          }
          o = a + 1;
        }
      return super.replace(e, n, r);
    }
    sliceString(e, n = this.length, r = `
`) {
      [e, n] = dl(this, e, n);
      let i = "";
      for (let o = 0, s = 0; o < this.children.length && s <= n; o++) {
        let a = this.children[o], l = s + a.length;
        s > e && o && (i += r), e < l && n > s && (i += a.sliceString(e - s, n - s, r)), s = l + 1;
      }
      return i;
    }
    flatten(e) {
      for (let n of this.children)
        n.flatten(e);
    }
    scanIdentical(e, n) {
      if (!(e instanceof pi))
        return 0;
      let r = 0, [i, o, s, a] = n > 0 ? [
        0,
        0,
        this.children.length,
        e.children.length
      ] : [
        this.children.length - 1,
        e.children.length - 1,
        -1,
        -1
      ];
      for (; ; i += n, o += n) {
        if (i == s || o == a)
          return r;
        let l = this.children[i], c = e.children[o];
        if (l != c)
          return r + l.scanIdentical(c, n);
        r += l.length + 1;
      }
    }
    static from(e, n = e.reduce((r, i) => r + i.length + 1, -1)) {
      let r = 0;
      for (let v of e)
        r += v.lines;
      if (r < 32) {
        let v = [];
        for (let y of e)
          y.flatten(v);
        return new Tt(v, n);
      }
      let i = Math.max(32, r >> 5), o = i << 1, s = i >> 1, a = [], l = 0, c = -1, u = [];
      function h(v) {
        let y;
        if (v.lines > o && v instanceof pi)
          for (let x of v.children)
            h(x);
        else
          v.lines > s && (l > s || !l) ? (p(), a.push(v)) : v instanceof Tt && l && (y = u[u.length - 1]) instanceof Tt && v.lines + y.lines <= 32 ? (l += v.lines, c += v.length + 1, u[u.length - 1] = new Tt(y.text.concat(v.text), y.length + 1 + v.length)) : (l + v.lines > i && p(), l += v.lines, c += v.length + 1, u.push(v));
      }
      function p() {
        l != 0 && (a.push(u.length == 1 ? u[0] : pi.from(u, c)), c = -1, l = u.length = 0);
      }
      for (let v of e)
        h(v);
      return p(), a.length == 1 ? a[0] : new pi(a, n);
    }
  }
  He.empty = new Tt([
    ""
  ], 0);
  function IW(t) {
    let e = -1;
    for (let n of t)
      e += n.length + 1;
    return e;
  }
  function xd(t, e, n = 0, r = 1e9) {
    for (let i = 0, o = 0, s = true; o < t.length && i <= r; o++) {
      let a = t[o], l = i + a.length;
      l >= n && (l > r && (a = a.slice(0, r - i)), i < n && (a = a.slice(n - i)), s ? (e[e.length - 1] += a, s = false) : e.push(a)), i = l + 1;
    }
    return e;
  }
  function pC(t, e, n) {
    return xd(t, [
      ""
    ], e, n);
  }
  class Yc {
    constructor(e, n = 1) {
      this.dir = n, this.done = false, this.lineBreak = false, this.value = "", this.nodes = [
        e
      ], this.offsets = [
        n > 0 ? 1 : (e instanceof Tt ? e.text.length : e.children.length) << 1
      ];
    }
    nextInner(e, n) {
      for (this.done = this.lineBreak = false; ; ) {
        let r = this.nodes.length - 1, i = this.nodes[r], o = this.offsets[r], s = o >> 1, a = i instanceof Tt ? i.text.length : i.children.length;
        if (s == (n > 0 ? a : 0)) {
          if (r == 0)
            return this.done = true, this.value = "", this;
          n > 0 && this.offsets[r - 1]++, this.nodes.pop(), this.offsets.pop();
        } else if ((o & 1) == (n > 0 ? 0 : 1)) {
          if (this.offsets[r] += n, e == 0)
            return this.lineBreak = true, this.value = `
`, this;
          e--;
        } else if (i instanceof Tt) {
          let l = i.text[s + (n < 0 ? -1 : 0)];
          if (this.offsets[r] += n, l.length > Math.max(0, e))
            return this.value = e == 0 ? l : n > 0 ? l.slice(e) : l.slice(0, l.length - e), this;
          e -= l.length;
        } else {
          let l = i.children[s + (n < 0 ? -1 : 0)];
          e > l.length ? (e -= l.length, this.offsets[r] += n) : (n < 0 && this.offsets[r]--, this.nodes.push(l), this.offsets.push(n > 0 ? 1 : (l instanceof Tt ? l.text.length : l.children.length) << 1));
        }
      }
    }
    next(e = 0) {
      return e < 0 && (this.nextInner(-e, -this.dir), e = this.value.length), this.nextInner(e, this.dir);
    }
  }
  class uO {
    constructor(e, n, r) {
      this.value = "", this.done = false, this.cursor = new Yc(e, n > r ? -1 : 1), this.pos = n > r ? e.length : 0, this.from = Math.min(n, r), this.to = Math.max(n, r);
    }
    nextInner(e, n) {
      if (n < 0 ? this.pos <= this.from : this.pos >= this.to)
        return this.value = "", this.done = true, this;
      e += Math.max(0, n < 0 ? this.pos - this.to : this.from - this.pos);
      let r = n < 0 ? this.pos - this.from : this.to - this.pos;
      e > r && (e = r), r -= e;
      let { value: i } = this.cursor.next(e);
      return this.pos += (i.length + e) * n, this.value = i.length <= r ? i : n < 0 ? i.slice(i.length - r) : i.slice(0, r), this.done = !this.value, this;
    }
    next(e = 0) {
      return e < 0 ? e = Math.max(e, this.from - this.pos) : e > 0 && (e = Math.min(e, this.to - this.pos)), this.nextInner(e, this.cursor.dir);
    }
    get lineBreak() {
      return this.cursor.lineBreak && this.value != "";
    }
  }
  class fO {
    constructor(e) {
      this.inner = e, this.afterBreak = true, this.value = "", this.done = false;
    }
    next(e = 0) {
      let { done: n, lineBreak: r, value: i } = this.inner.next(e);
      return n && this.afterBreak ? (this.value = "", this.afterBreak = false) : n ? (this.done = true, this.value = "") : r ? this.afterBreak ? this.value = "" : (this.afterBreak = true, this.next()) : (this.value = i, this.afterBreak = false), this;
    }
    get lineBreak() {
      return false;
    }
  }
  typeof Symbol < "u" && (He.prototype[Symbol.iterator] = function() {
    return this.iter();
  }, Yc.prototype[Symbol.iterator] = uO.prototype[Symbol.iterator] = fO.prototype[Symbol.iterator] = function() {
    return this;
  });
  class BW {
    constructor(e, n, r, i) {
      this.from = e, this.to = n, this.number = r, this.text = i;
    }
    get length() {
      return this.to - this.from;
    }
  }
  function dl(t, e, n) {
    return e = Math.max(0, Math.min(t.length, e)), [
      e,
      Math.max(e, Math.min(t.length, n))
    ];
  }
  function en(t, e, n = true, r = true) {
    return _W(t, e, n, r);
  }
  function NW(t) {
    return t >= 56320 && t < 57344;
  }
  function $W(t) {
    return t >= 55296 && t < 56320;
  }
  function Ln(t, e) {
    let n = t.charCodeAt(e);
    if (!$W(n) || e + 1 == t.length)
      return n;
    let r = t.charCodeAt(e + 1);
    return NW(r) ? (n - 55296 << 10) + (r - 56320) + 65536 : n;
  }
  function Cx(t) {
    return t <= 65535 ? String.fromCharCode(t) : (t -= 65536, String.fromCharCode((t >> 10) + 55296, (t & 1023) + 56320));
  }
  function mi(t) {
    return t < 65536 ? 1 : 2;
  }
  const Iy = /\r\n?|\n/;
  var Zt = function(t) {
    return t[t.Simple = 0] = "Simple", t[t.TrackDel = 1] = "TrackDel", t[t.TrackBefore = 2] = "TrackBefore", t[t.TrackAfter = 3] = "TrackAfter", t;
  }(Zt || (Zt = {}));
  class Ti {
    constructor(e) {
      this.sections = e;
    }
    get length() {
      let e = 0;
      for (let n = 0; n < this.sections.length; n += 2)
        e += this.sections[n];
      return e;
    }
    get newLength() {
      let e = 0;
      for (let n = 0; n < this.sections.length; n += 2) {
        let r = this.sections[n + 1];
        e += r < 0 ? this.sections[n] : r;
      }
      return e;
    }
    get empty() {
      return this.sections.length == 0 || this.sections.length == 2 && this.sections[1] < 0;
    }
    iterGaps(e) {
      for (let n = 0, r = 0, i = 0; n < this.sections.length; ) {
        let o = this.sections[n++], s = this.sections[n++];
        s < 0 ? (e(r, i, o), i += o) : i += s, r += o;
      }
    }
    iterChangedRanges(e, n = false) {
      By(this, e, n);
    }
    get invertedDesc() {
      let e = [];
      for (let n = 0; n < this.sections.length; ) {
        let r = this.sections[n++], i = this.sections[n++];
        i < 0 ? e.push(r, i) : e.push(i, r);
      }
      return new Ti(e);
    }
    composeDesc(e) {
      return this.empty ? e : e.empty ? this : hO(this, e);
    }
    mapDesc(e, n = false) {
      return e.empty ? this : Ny(this, e, n);
    }
    mapPos(e, n = -1, r = Zt.Simple) {
      let i = 0, o = 0;
      for (let s = 0; s < this.sections.length; ) {
        let a = this.sections[s++], l = this.sections[s++], c = i + a;
        if (l < 0) {
          if (c > e)
            return o + (e - i);
          o += a;
        } else {
          if (r != Zt.Simple && c >= e && (r == Zt.TrackDel && i < e && c > e || r == Zt.TrackBefore && i < e || r == Zt.TrackAfter && c > e))
            return null;
          if (c > e || c == e && n < 0 && !a)
            return e == i || n < 0 ? o : o + l;
          o += l;
        }
        i = c;
      }
      if (e > i)
        throw new RangeError(`Position ${e} is out of range for changeset of length ${i}`);
      return o;
    }
    touchesRange(e, n = e) {
      for (let r = 0, i = 0; r < this.sections.length && i <= n; ) {
        let o = this.sections[r++], s = this.sections[r++], a = i + o;
        if (s >= 0 && i <= n && a >= e)
          return i < e && a > n ? "cover" : true;
        i = a;
      }
      return false;
    }
    toString() {
      let e = "";
      for (let n = 0; n < this.sections.length; ) {
        let r = this.sections[n++], i = this.sections[n++];
        e += (e ? " " : "") + r + (i >= 0 ? ":" + i : "");
      }
      return e;
    }
    toJSON() {
      return this.sections;
    }
    static fromJSON(e) {
      if (!Array.isArray(e) || e.length % 2 || e.some((n) => typeof n != "number"))
        throw new RangeError("Invalid JSON representation of ChangeDesc");
      return new Ti(e);
    }
    static create(e) {
      return new Ti(e);
    }
  }
  class Dt extends Ti {
    constructor(e, n) {
      super(e), this.inserted = n;
    }
    apply(e) {
      if (this.length != e.length)
        throw new RangeError("Applying change set to a document with the wrong length");
      return By(this, (n, r, i, o, s) => e = e.replace(i, i + (r - n), s), false), e;
    }
    mapDesc(e, n = false) {
      return Ny(this, e, n, true);
    }
    invert(e) {
      let n = this.sections.slice(), r = [];
      for (let i = 0, o = 0; i < n.length; i += 2) {
        let s = n[i], a = n[i + 1];
        if (a >= 0) {
          n[i] = a, n[i + 1] = s;
          let l = i >> 1;
          for (; r.length < l; )
            r.push(He.empty);
          r.push(s ? e.slice(o, o + s) : He.empty);
        }
        o += s;
      }
      return new Dt(n, r);
    }
    compose(e) {
      return this.empty ? e : e.empty ? this : hO(this, e, true);
    }
    map(e, n = false) {
      return e.empty ? this : Ny(this, e, n, true);
    }
    iterChanges(e, n = false) {
      By(this, e, n);
    }
    get desc() {
      return Ti.create(this.sections);
    }
    filter(e) {
      let n = [], r = [], i = [], o = new _u(this);
      e:
        for (let s = 0, a = 0; ; ) {
          let l = s == e.length ? 1e9 : e[s++];
          for (; a < l || a == l && o.len == 0; ) {
            if (o.done)
              break e;
            let u = Math.min(o.len, l - a);
            un(i, u, -1);
            let h = o.ins == -1 ? -1 : o.off == 0 ? o.ins : 0;
            un(n, u, h), h > 0 && Lo(r, n, o.text), o.forward(u), a += u;
          }
          let c = e[s++];
          for (; a < c; ) {
            if (o.done)
              break e;
            let u = Math.min(o.len, c - a);
            un(n, u, -1), un(i, u, o.ins == -1 ? -1 : o.off == 0 ? o.ins : 0), o.forward(u), a += u;
          }
        }
      return {
        changes: new Dt(n, r),
        filtered: Ti.create(i)
      };
    }
    toJSON() {
      let e = [];
      for (let n = 0; n < this.sections.length; n += 2) {
        let r = this.sections[n], i = this.sections[n + 1];
        i < 0 ? e.push(r) : i == 0 ? e.push([
          r
        ]) : e.push([
          r
        ].concat(this.inserted[n >> 1].toJSON()));
      }
      return e;
    }
    static of(e, n, r) {
      let i = [], o = [], s = 0, a = null;
      function l(u = false) {
        if (!u && !i.length)
          return;
        s < n && un(i, n - s, -1);
        let h = new Dt(i, o);
        a = a ? a.compose(h.map(a)) : h, i = [], o = [], s = 0;
      }
      function c(u) {
        if (Array.isArray(u))
          for (let h of u)
            c(h);
        else if (u instanceof Dt) {
          if (u.length != n)
            throw new RangeError(`Mismatched change set length (got ${u.length}, expected ${n})`);
          l(), a = a ? a.compose(u.map(a)) : u;
        } else {
          let { from: h, to: p = h, insert: v } = u;
          if (h > p || h < 0 || p > n)
            throw new RangeError(`Invalid change range ${h} to ${p} (in doc of length ${n})`);
          let y = v ? typeof v == "string" ? He.of(v.split(r || Iy)) : v : He.empty, x = y.length;
          if (h == p && x == 0)
            return;
          h < s && l(), h > s && un(i, h - s, -1), un(i, p - h, x), Lo(o, i, y), s = p;
        }
      }
      return c(e), l(!a), a;
    }
    static empty(e) {
      return new Dt(e ? [
        e,
        -1
      ] : [], []);
    }
    static fromJSON(e) {
      if (!Array.isArray(e))
        throw new RangeError("Invalid JSON representation of ChangeSet");
      let n = [], r = [];
      for (let i = 0; i < e.length; i++) {
        let o = e[i];
        if (typeof o == "number")
          n.push(o, -1);
        else {
          if (!Array.isArray(o) || typeof o[0] != "number" || o.some((s, a) => a && typeof s != "string"))
            throw new RangeError("Invalid JSON representation of ChangeSet");
          if (o.length == 1)
            n.push(o[0], 0);
          else {
            for (; r.length < i; )
              r.push(He.empty);
            r[i] = He.of(o.slice(1)), n.push(o[0], r[i].length);
          }
        }
      }
      return new Dt(n, r);
    }
    static createSet(e, n) {
      return new Dt(e, n);
    }
  }
  function un(t, e, n, r = false) {
    if (e == 0 && n <= 0)
      return;
    let i = t.length - 2;
    i >= 0 && n <= 0 && n == t[i + 1] ? t[i] += e : i >= 0 && e == 0 && t[i] == 0 ? t[i + 1] += n : r ? (t[i] += e, t[i + 1] += n) : t.push(e, n);
  }
  function Lo(t, e, n) {
    if (n.length == 0)
      return;
    let r = e.length - 2 >> 1;
    if (r < t.length)
      t[t.length - 1] = t[t.length - 1].append(n);
    else {
      for (; t.length < r; )
        t.push(He.empty);
      t.push(n);
    }
  }
  function By(t, e, n) {
    let r = t.inserted;
    for (let i = 0, o = 0, s = 0; s < t.sections.length; ) {
      let a = t.sections[s++], l = t.sections[s++];
      if (l < 0)
        i += a, o += a;
      else {
        let c = i, u = o, h = He.empty;
        for (; c += a, u += l, l && r && (h = h.append(r[s - 2 >> 1])), !(n || s == t.sections.length || t.sections[s + 1] < 0); )
          a = t.sections[s++], l = t.sections[s++];
        e(i, c, o, u, h), i = c, o = u;
      }
    }
  }
  function Ny(t, e, n, r = false) {
    let i = [], o = r ? [] : null, s = new _u(t), a = new _u(e);
    for (let l = -1; ; ) {
      if (s.done && a.len || a.done && s.len)
        throw new Error("Mismatched change set lengths");
      if (s.ins == -1 && a.ins == -1) {
        let c = Math.min(s.len, a.len);
        un(i, c, -1), s.forward(c), a.forward(c);
      } else if (a.ins >= 0 && (s.ins < 0 || l == s.i || s.off == 0 && (a.len < s.len || a.len == s.len && !n))) {
        let c = a.len;
        for (un(i, a.ins, -1); c; ) {
          let u = Math.min(s.len, c);
          s.ins >= 0 && l < s.i && s.len <= u && (un(i, 0, s.ins), o && Lo(o, i, s.text), l = s.i), s.forward(u), c -= u;
        }
        a.next();
      } else if (s.ins >= 0) {
        let c = 0, u = s.len;
        for (; u; )
          if (a.ins == -1) {
            let h = Math.min(u, a.len);
            c += h, u -= h, a.forward(h);
          } else if (a.ins == 0 && a.len < u)
            u -= a.len, a.next();
          else
            break;
        un(i, c, l < s.i ? s.ins : 0), o && l < s.i && Lo(o, i, s.text), l = s.i, s.forward(s.len - u);
      } else {
        if (s.done && a.done)
          return o ? Dt.createSet(i, o) : Ti.create(i);
        throw new Error("Mismatched change set lengths");
      }
    }
  }
  function hO(t, e, n = false) {
    let r = [], i = n ? [] : null, o = new _u(t), s = new _u(e);
    for (let a = false; ; ) {
      if (o.done && s.done)
        return i ? Dt.createSet(r, i) : Ti.create(r);
      if (o.ins == 0)
        un(r, o.len, 0, a), o.next();
      else if (s.len == 0 && !s.done)
        un(r, 0, s.ins, a), i && Lo(i, r, s.text), s.next();
      else {
        if (o.done || s.done)
          throw new Error("Mismatched change set lengths");
        {
          let l = Math.min(o.len2, s.len), c = r.length;
          if (o.ins == -1) {
            let u = s.ins == -1 ? -1 : s.off ? 0 : s.ins;
            un(r, l, u, a), i && u && Lo(i, r, s.text);
          } else
            s.ins == -1 ? (un(r, o.off ? 0 : o.len, l, a), i && Lo(i, r, o.textBit(l))) : (un(r, o.off ? 0 : o.len, s.off ? 0 : s.ins, a), i && !s.off && Lo(i, r, s.text));
          a = (o.ins > l || s.ins >= 0 && s.len > l) && (a || r.length > c), o.forward2(l), s.forward(l);
        }
      }
    }
  }
  class _u {
    constructor(e) {
      this.set = e, this.i = 0, this.next();
    }
    next() {
      let { sections: e } = this.set;
      this.i < e.length ? (this.len = e[this.i++], this.ins = e[this.i++]) : (this.len = 0, this.ins = -2), this.off = 0;
    }
    get done() {
      return this.ins == -2;
    }
    get len2() {
      return this.ins < 0 ? this.len : this.ins;
    }
    get text() {
      let { inserted: e } = this.set, n = this.i - 2 >> 1;
      return n >= e.length ? He.empty : e[n];
    }
    textBit(e) {
      let { inserted: n } = this.set, r = this.i - 2 >> 1;
      return r >= n.length && !e ? He.empty : n[r].slice(this.off, e == null ? void 0 : this.off + e);
    }
    forward(e) {
      e == this.len ? this.next() : (this.len -= e, this.off += e);
    }
    forward2(e) {
      this.ins == -1 ? this.forward(e) : e == this.ins ? this.next() : (this.ins -= e, this.off += e);
    }
  }
  class Ps {
    constructor(e, n, r) {
      this.from = e, this.to = n, this.flags = r;
    }
    get anchor() {
      return this.flags & 32 ? this.to : this.from;
    }
    get head() {
      return this.flags & 32 ? this.from : this.to;
    }
    get empty() {
      return this.from == this.to;
    }
    get assoc() {
      return this.flags & 8 ? -1 : this.flags & 16 ? 1 : 0;
    }
    get bidiLevel() {
      let e = this.flags & 7;
      return e == 7 ? null : e;
    }
    get goalColumn() {
      let e = this.flags >> 6;
      return e == 16777215 ? void 0 : e;
    }
    map(e, n = -1) {
      let r, i;
      return this.empty ? r = i = e.mapPos(this.from, n) : (r = e.mapPos(this.from, 1), i = e.mapPos(this.to, -1)), r == this.from && i == this.to ? this : new Ps(r, i, this.flags);
    }
    extend(e, n = e) {
      if (e <= this.anchor && n >= this.anchor)
        return q.range(e, n);
      let r = Math.abs(e - this.anchor) > Math.abs(n - this.anchor) ? e : n;
      return q.range(this.anchor, r);
    }
    eq(e, n = false) {
      return this.anchor == e.anchor && this.head == e.head && (!n || !this.empty || this.assoc == e.assoc);
    }
    toJSON() {
      return {
        anchor: this.anchor,
        head: this.head
      };
    }
    static fromJSON(e) {
      if (!e || typeof e.anchor != "number" || typeof e.head != "number")
        throw new RangeError("Invalid JSON representation for SelectionRange");
      return q.range(e.anchor, e.head);
    }
    static create(e, n, r) {
      return new Ps(e, n, r);
    }
  }
  class q {
    constructor(e, n) {
      this.ranges = e, this.mainIndex = n;
    }
    map(e, n = -1) {
      return e.empty ? this : q.create(this.ranges.map((r) => r.map(e, n)), this.mainIndex);
    }
    eq(e, n = false) {
      if (this.ranges.length != e.ranges.length || this.mainIndex != e.mainIndex)
        return false;
      for (let r = 0; r < this.ranges.length; r++)
        if (!this.ranges[r].eq(e.ranges[r], n))
          return false;
      return true;
    }
    get main() {
      return this.ranges[this.mainIndex];
    }
    asSingle() {
      return this.ranges.length == 1 ? this : new q([
        this.main
      ], 0);
    }
    addRange(e, n = true) {
      return q.create([
        e
      ].concat(this.ranges), n ? 0 : this.mainIndex + 1);
    }
    replaceRange(e, n = this.mainIndex) {
      let r = this.ranges.slice();
      return r[n] = e, q.create(r, this.mainIndex);
    }
    toJSON() {
      return {
        ranges: this.ranges.map((e) => e.toJSON()),
        main: this.mainIndex
      };
    }
    static fromJSON(e) {
      if (!e || !Array.isArray(e.ranges) || typeof e.main != "number" || e.main >= e.ranges.length)
        throw new RangeError("Invalid JSON representation for EditorSelection");
      return new q(e.ranges.map((n) => Ps.fromJSON(n)), e.main);
    }
    static single(e, n = e) {
      return new q([
        q.range(e, n)
      ], 0);
    }
    static create(e, n = 0) {
      if (e.length == 0)
        throw new RangeError("A selection needs at least one range");
      for (let r = 0, i = 0; i < e.length; i++) {
        let o = e[i];
        if (o.empty ? o.from <= r : o.from < r)
          return q.normalized(e.slice(), n);
        r = o.to;
      }
      return new q(e, n);
    }
    static cursor(e, n = 0, r, i) {
      return Ps.create(e, e, (n == 0 ? 0 : n < 0 ? 8 : 16) | (r == null ? 7 : Math.min(6, r)) | (i ?? 16777215) << 6);
    }
    static range(e, n, r, i) {
      let o = (r ?? 16777215) << 6 | (i == null ? 7 : Math.min(6, i));
      return n < e ? Ps.create(n, e, 48 | o) : Ps.create(e, n, (n > e ? 8 : 0) | o);
    }
    static normalized(e, n = 0) {
      let r = e[n];
      e.sort((i, o) => i.from - o.from), n = e.indexOf(r);
      for (let i = 1; i < e.length; i++) {
        let o = e[i], s = e[i - 1];
        if (o.empty ? o.from <= s.to : o.from < s.to) {
          let a = s.from, l = Math.max(o.to, s.to);
          i <= n && n--, e.splice(--i, 2, o.anchor > o.head ? q.range(l, a) : q.range(a, l));
        }
      }
      return new q(e, n);
    }
  }
  function dO(t, e) {
    for (let n of t.ranges)
      if (n.to > e)
        throw new RangeError("Selection points outside of document");
  }
  let Tx = 0;
  class me {
    constructor(e, n, r, i, o) {
      this.combine = e, this.compareInput = n, this.compare = r, this.isStatic = i, this.id = Tx++, this.default = e([]), this.extensions = typeof o == "function" ? o(this) : o;
    }
    get reader() {
      return this;
    }
    static define(e = {}) {
      return new me(e.combine || ((n) => n), e.compareInput || ((n, r) => n === r), e.compare || (e.combine ? (n, r) => n === r : Mx), !!e.static, e.enables);
    }
    of(e) {
      return new Sd([], this, 0, e);
    }
    compute(e, n) {
      if (this.isStatic)
        throw new Error("Can't compute a static facet");
      return new Sd(e, this, 1, n);
    }
    computeN(e, n) {
      if (this.isStatic)
        throw new Error("Can't compute a static facet");
      return new Sd(e, this, 2, n);
    }
    from(e, n) {
      return n || (n = (r) => r), this.compute([
        e
      ], (r) => n(r.field(e)));
    }
  }
  function Mx(t, e) {
    return t == e || t.length == e.length && t.every((n, r) => n === e[r]);
  }
  class Sd {
    constructor(e, n, r, i) {
      this.dependencies = e, this.facet = n, this.type = r, this.value = i, this.id = Tx++;
    }
    dynamicSlot(e) {
      var n;
      let r = this.value, i = this.facet.compareInput, o = this.id, s = e[o] >> 1, a = this.type == 2, l = false, c = false, u = [];
      for (let h of this.dependencies)
        h == "doc" ? l = true : h == "selection" ? c = true : (((n = e[h.id]) !== null && n !== void 0 ? n : 1) & 1) == 0 && u.push(e[h.id]);
      return {
        create(h) {
          return h.values[s] = r(h), 1;
        },
        update(h, p) {
          if (l && p.docChanged || c && (p.docChanged || p.selection) || $y(h, u)) {
            let v = r(h);
            if (a ? !mC(v, h.values[s], i) : !i(v, h.values[s]))
              return h.values[s] = v, 1;
          }
          return 0;
        },
        reconfigure: (h, p) => {
          let v, y = p.config.address[o];
          if (y != null) {
            let x = xp(p, y);
            if (this.dependencies.every((T) => T instanceof me ? p.facet(T) === h.facet(T) : T instanceof Ut ? p.field(T, false) == h.field(T, false) : true) || (a ? mC(v = r(h), x, i) : i(v = r(h), x)))
              return h.values[s] = x, 0;
          } else
            v = r(h);
          return h.values[s] = v, 1;
        }
      };
    }
  }
  function mC(t, e, n) {
    if (t.length != e.length)
      return false;
    for (let r = 0; r < t.length; r++)
      if (!n(t[r], e[r]))
        return false;
    return true;
  }
  function $y(t, e) {
    let n = false;
    for (let r of e)
      Xc(t, r) & 1 && (n = true);
    return n;
  }
  function zW(t, e, n) {
    let r = n.map((l) => t[l.id]), i = n.map((l) => l.type), o = r.filter((l) => !(l & 1)), s = t[e.id] >> 1;
    function a(l) {
      let c = [];
      for (let u = 0; u < r.length; u++) {
        let h = xp(l, r[u]);
        if (i[u] == 2)
          for (let p of h)
            c.push(p);
        else
          c.push(h);
      }
      return e.combine(c);
    }
    return {
      create(l) {
        for (let c of r)
          Xc(l, c);
        return l.values[s] = a(l), 1;
      },
      update(l, c) {
        if (!$y(l, o))
          return 0;
        let u = a(l);
        return e.compare(u, l.values[s]) ? 0 : (l.values[s] = u, 1);
      },
      reconfigure(l, c) {
        let u = $y(l, r), h = c.config.facets[e.id], p = c.facet(e);
        if (h && !u && Mx(n, h))
          return l.values[s] = p, 0;
        let v = a(l);
        return e.compare(v, p) ? (l.values[s] = p, 0) : (l.values[s] = v, 1);
      }
    };
  }
  const Sh = me.define({
    static: true
  });
  class Ut {
    constructor(e, n, r, i, o) {
      this.id = e, this.createF = n, this.updateF = r, this.compareF = i, this.spec = o, this.provides = void 0;
    }
    static define(e) {
      let n = new Ut(Tx++, e.create, e.update, e.compare || ((r, i) => r === i), e);
      return e.provide && (n.provides = e.provide(n)), n;
    }
    create(e) {
      let n = e.facet(Sh).find((r) => r.field == this);
      return ((n == null ? void 0 : n.create) || this.createF)(e);
    }
    slot(e) {
      let n = e[this.id] >> 1;
      return {
        create: (r) => (r.values[n] = this.create(r), 1),
        update: (r, i) => {
          let o = r.values[n], s = this.updateF(o, i);
          return this.compareF(o, s) ? 0 : (r.values[n] = s, 1);
        },
        reconfigure: (r, i) => {
          let o = r.facet(Sh), s = i.facet(Sh), a;
          return (a = o.find((l) => l.field == this)) && a != s.find((l) => l.field == this) ? (r.values[n] = a.create(r), 1) : i.config.address[this.id] != null ? (r.values[n] = i.field(this), 0) : (r.values[n] = this.create(r), 1);
        }
      };
    }
    init(e) {
      return [
        this,
        Sh.of({
          field: this,
          create: e
        })
      ];
    }
    get extension() {
      return this;
    }
  }
  const ws = {
    lowest: 4,
    low: 3,
    default: 2,
    high: 1,
    highest: 0
  };
  function oc(t) {
    return (e) => new pO(e, t);
  }
  const ns = {
    highest: oc(ws.highest),
    high: oc(ws.high),
    default: oc(ws.default),
    low: oc(ws.low),
    lowest: oc(ws.lowest)
  };
  class pO {
    constructor(e, n) {
      this.inner = e, this.prec = n;
    }
  }
  class $m {
    of(e) {
      return new zy(this, e);
    }
    reconfigure(e) {
      return $m.reconfigure.of({
        compartment: this,
        extension: e
      });
    }
    get(e) {
      return e.config.compartments.get(this);
    }
  }
  class zy {
    constructor(e, n) {
      this.compartment = e, this.inner = n;
    }
  }
  class bp {
    constructor(e, n, r, i, o, s) {
      for (this.base = e, this.compartments = n, this.dynamicSlots = r, this.address = i, this.staticValues = o, this.facets = s, this.statusTemplate = []; this.statusTemplate.length < r.length; )
        this.statusTemplate.push(0);
    }
    staticFacet(e) {
      let n = this.address[e.id];
      return n == null ? e.default : this.staticValues[n >> 1];
    }
    static resolve(e, n, r) {
      let i = [], o = /* @__PURE__ */ Object.create(null), s = /* @__PURE__ */ new Map();
      for (let p of FW(e, n, s))
        p instanceof Ut ? i.push(p) : (o[p.facet.id] || (o[p.facet.id] = [])).push(p);
      let a = /* @__PURE__ */ Object.create(null), l = [], c = [];
      for (let p of i)
        a[p.id] = c.length << 1, c.push((v) => p.slot(v));
      let u = r == null ? void 0 : r.config.facets;
      for (let p in o) {
        let v = o[p], y = v[0].facet, x = u && u[p] || [];
        if (v.every((T) => T.type == 0))
          if (a[y.id] = l.length << 1 | 1, Mx(x, v))
            l.push(r.facet(y));
          else {
            let T = y.combine(v.map((w) => w.value));
            l.push(r && y.compare(T, r.facet(y)) ? r.facet(y) : T);
          }
        else {
          for (let T of v)
            T.type == 0 ? (a[T.id] = l.length << 1 | 1, l.push(T.value)) : (a[T.id] = c.length << 1, c.push((w) => T.dynamicSlot(w)));
          a[y.id] = c.length << 1, c.push((T) => zW(T, y, v));
        }
      }
      let h = c.map((p) => p(a));
      return new bp(e, s, h, a, l, o);
    }
  }
  function FW(t, e, n) {
    let r = [
      [],
      [],
      [],
      [],
      []
    ], i = /* @__PURE__ */ new Map();
    function o(s, a) {
      let l = i.get(s);
      if (l != null) {
        if (l <= a)
          return;
        let c = r[l].indexOf(s);
        c > -1 && r[l].splice(c, 1), s instanceof zy && n.delete(s.compartment);
      }
      if (i.set(s, a), Array.isArray(s))
        for (let c of s)
          o(c, a);
      else if (s instanceof zy) {
        if (n.has(s.compartment))
          throw new RangeError("Duplicate use of compartment in extensions");
        let c = e.get(s.compartment) || s.inner;
        n.set(s.compartment, c), o(c, a);
      } else if (s instanceof pO)
        o(s.inner, s.prec);
      else if (s instanceof Ut)
        r[a].push(s), s.provides && o(s.provides, a);
      else if (s instanceof Sd)
        r[a].push(s), s.facet.extensions && o(s.facet.extensions, ws.default);
      else {
        let c = s.extension;
        if (!c)
          throw new Error(`Unrecognized extension value in extension set (${s}). This sometimes happens because multiple instances of @codemirror/state are loaded, breaking instanceof checks.`);
        o(c, a);
      }
    }
    return o(t, ws.default), r.reduce((s, a) => s.concat(a));
  }
  function Xc(t, e) {
    if (e & 1)
      return 2;
    let n = e >> 1, r = t.status[n];
    if (r == 4)
      throw new Error("Cyclic dependency between fields and/or facets");
    if (r & 2)
      return r;
    t.status[n] = 4;
    let i = t.computeSlot(t, t.config.dynamicSlots[n]);
    return t.status[n] = 2 | i;
  }
  function xp(t, e) {
    return e & 1 ? t.config.staticValues[e >> 1] : t.values[e >> 1];
  }
  const mO = me.define(), Fy = me.define({
    combine: (t) => t.some((e) => e),
    static: true
  }), gO = me.define({
    combine: (t) => t.length ? t[0] : void 0,
    static: true
  }), vO = me.define(), yO = me.define(), bO = me.define(), xO = me.define({
    combine: (t) => t.length ? t[0] : false
  });
  class Pi {
    constructor(e, n) {
      this.type = e, this.value = n;
    }
    static define() {
      return new VW();
    }
  }
  class VW {
    of(e) {
      return new Pi(this, e);
    }
  }
  class HW {
    constructor(e) {
      this.map = e;
    }
    of(e) {
      return new Ee(this, e);
    }
  }
  class Ee {
    constructor(e, n) {
      this.type = e, this.value = n;
    }
    map(e) {
      let n = this.type.map(this.value, e);
      return n === void 0 ? void 0 : n == this.value ? this : new Ee(this.type, n);
    }
    is(e) {
      return this.type == e;
    }
    static define(e = {}) {
      return new HW(e.map || ((n) => n));
    }
    static mapEffects(e, n) {
      if (!e.length)
        return e;
      let r = [];
      for (let i of e) {
        let o = i.map(n);
        o && r.push(o);
      }
      return r;
    }
  }
  Ee.reconfigure = Ee.define();
  Ee.appendConfig = Ee.define();
  class Bt {
    constructor(e, n, r, i, o, s) {
      this.startState = e, this.changes = n, this.selection = r, this.effects = i, this.annotations = o, this.scrollIntoView = s, this._doc = null, this._state = null, r && dO(r, n.newLength), o.some((a) => a.type == Bt.time) || (this.annotations = o.concat(Bt.time.of(Date.now())));
    }
    static create(e, n, r, i, o, s) {
      return new Bt(e, n, r, i, o, s);
    }
    get newDoc() {
      return this._doc || (this._doc = this.changes.apply(this.startState.doc));
    }
    get newSelection() {
      return this.selection || this.startState.selection.map(this.changes);
    }
    get state() {
      return this._state || this.startState.applyTransaction(this), this._state;
    }
    annotation(e) {
      for (let n of this.annotations)
        if (n.type == e)
          return n.value;
    }
    get docChanged() {
      return !this.changes.empty;
    }
    get reconfigured() {
      return this.startState.config != this.state.config;
    }
    isUserEvent(e) {
      let n = this.annotation(Bt.userEvent);
      return !!(n && (n == e || n.length > e.length && n.slice(0, e.length) == e && n[e.length] == "."));
    }
  }
  Bt.time = Pi.define();
  Bt.userEvent = Pi.define();
  Bt.addToHistory = Pi.define();
  Bt.remote = Pi.define();
  function jW(t, e) {
    let n = [];
    for (let r = 0, i = 0; ; ) {
      let o, s;
      if (r < t.length && (i == e.length || e[i] >= t[r]))
        o = t[r++], s = t[r++];
      else if (i < e.length)
        o = e[i++], s = e[i++];
      else
        return n;
      !n.length || n[n.length - 1] < o ? n.push(o, s) : n[n.length - 1] < s && (n[n.length - 1] = s);
    }
  }
  function SO(t, e, n) {
    var r;
    let i, o, s;
    return n ? (i = e.changes, o = Dt.empty(e.changes.length), s = t.changes.compose(e.changes)) : (i = e.changes.map(t.changes), o = t.changes.mapDesc(e.changes, true), s = t.changes.compose(i)), {
      changes: s,
      selection: e.selection ? e.selection.map(o) : (r = t.selection) === null || r === void 0 ? void 0 : r.map(i),
      effects: Ee.mapEffects(t.effects, i).concat(Ee.mapEffects(e.effects, o)),
      annotations: t.annotations.length ? t.annotations.concat(e.annotations) : e.annotations,
      scrollIntoView: t.scrollIntoView || e.scrollIntoView
    };
  }
  function Vy(t, e, n) {
    let r = e.selection, i = Ya(e.annotations);
    return e.userEvent && (i = i.concat(Bt.userEvent.of(e.userEvent))), {
      changes: e.changes instanceof Dt ? e.changes : Dt.of(e.changes || [], n, t.facet(gO)),
      selection: r && (r instanceof q ? r : q.single(r.anchor, r.head)),
      effects: Ya(e.effects),
      annotations: i,
      scrollIntoView: !!e.scrollIntoView
    };
  }
  function wO(t, e, n) {
    let r = Vy(t, e.length ? e[0] : {}, t.doc.length);
    e.length && e[0].filter === false && (n = false);
    for (let o = 1; o < e.length; o++) {
      e[o].filter === false && (n = false);
      let s = !!e[o].sequential;
      r = SO(r, Vy(t, e[o], s ? r.changes.newLength : t.doc.length), s);
    }
    let i = Bt.create(t, r.changes, r.selection, r.effects, r.annotations, r.scrollIntoView);
    return UW(n ? WW(i) : i);
  }
  function WW(t) {
    let e = t.startState, n = true;
    for (let i of e.facet(vO)) {
      let o = i(t);
      if (o === false) {
        n = false;
        break;
      }
      Array.isArray(o) && (n = n === true ? o : jW(n, o));
    }
    if (n !== true) {
      let i, o;
      if (n === false)
        o = t.changes.invertedDesc, i = Dt.empty(e.doc.length);
      else {
        let s = t.changes.filter(n);
        i = s.changes, o = s.filtered.mapDesc(s.changes).invertedDesc;
      }
      t = Bt.create(e, i, t.selection && t.selection.map(o), Ee.mapEffects(t.effects, o), t.annotations, t.scrollIntoView);
    }
    let r = e.facet(yO);
    for (let i = r.length - 1; i >= 0; i--) {
      let o = r[i](t);
      o instanceof Bt ? t = o : Array.isArray(o) && o.length == 1 && o[0] instanceof Bt ? t = o[0] : t = wO(e, Ya(o), false);
    }
    return t;
  }
  function UW(t) {
    let e = t.startState, n = e.facet(bO), r = t;
    for (let i = n.length - 1; i >= 0; i--) {
      let o = n[i](t);
      o && Object.keys(o).length && (r = SO(r, Vy(e, o, t.changes.newLength), true));
    }
    return r == t ? t : Bt.create(e, t.changes, t.selection, r.effects, r.annotations, r.scrollIntoView);
  }
  const KW = [];
  function Ya(t) {
    return t == null ? KW : Array.isArray(t) ? t : [
      t
    ];
  }
  var ht = function(t) {
    return t[t.Word = 0] = "Word", t[t.Space = 1] = "Space", t[t.Other = 2] = "Other", t;
  }(ht || (ht = {}));
  const qW = /[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/;
  let Hy;
  try {
    Hy = new RegExp("[\\p{Alphabetic}\\p{Number}_]", "u");
  } catch {
  }
  function GW(t) {
    if (Hy)
      return Hy.test(t);
    for (let e = 0; e < t.length; e++) {
      let n = t[e];
      if (/\w/.test(n) || n > "\x80" && (n.toUpperCase() != n.toLowerCase() || qW.test(n)))
        return true;
    }
    return false;
  }
  function YW(t) {
    return (e) => {
      if (!/\S/.test(e))
        return ht.Space;
      if (GW(e))
        return ht.Word;
      for (let n = 0; n < t.length; n++)
        if (e.indexOf(t[n]) > -1)
          return ht.Word;
      return ht.Other;
    };
  }
  class Ne {
    constructor(e, n, r, i, o, s) {
      this.config = e, this.doc = n, this.selection = r, this.values = i, this.status = e.statusTemplate.slice(), this.computeSlot = o, s && (s._state = this);
      for (let a = 0; a < this.config.dynamicSlots.length; a++)
        Xc(this, a << 1);
      this.computeSlot = null;
    }
    field(e, n = true) {
      let r = this.config.address[e.id];
      if (r == null) {
        if (n)
          throw new RangeError("Field is not present in this state");
        return;
      }
      return Xc(this, r), xp(this, r);
    }
    update(...e) {
      return wO(this, e, true);
    }
    applyTransaction(e) {
      let n = this.config, { base: r, compartments: i } = n;
      for (let a of e.effects)
        a.is($m.reconfigure) ? (n && (i = /* @__PURE__ */ new Map(), n.compartments.forEach((l, c) => i.set(c, l)), n = null), i.set(a.value.compartment, a.value.extension)) : a.is(Ee.reconfigure) ? (n = null, r = a.value) : a.is(Ee.appendConfig) && (n = null, r = Ya(r).concat(a.value));
      let o;
      n ? o = e.startState.values.slice() : (n = bp.resolve(r, i, this), o = new Ne(n, this.doc, this.selection, n.dynamicSlots.map(() => null), (l, c) => c.reconfigure(l, this), null).values);
      let s = e.startState.facet(Fy) ? e.newSelection : e.newSelection.asSingle();
      new Ne(n, e.newDoc, s, o, (a, l) => l.update(a, e), e);
    }
    replaceSelection(e) {
      return typeof e == "string" && (e = this.toText(e)), this.changeByRange((n) => ({
        changes: {
          from: n.from,
          to: n.to,
          insert: e
        },
        range: q.cursor(n.from + e.length)
      }));
    }
    changeByRange(e) {
      let n = this.selection, r = e(n.ranges[0]), i = this.changes(r.changes), o = [
        r.range
      ], s = Ya(r.effects);
      for (let a = 1; a < n.ranges.length; a++) {
        let l = e(n.ranges[a]), c = this.changes(l.changes), u = c.map(i);
        for (let p = 0; p < a; p++)
          o[p] = o[p].map(u);
        let h = i.mapDesc(c, true);
        o.push(l.range.map(h)), i = i.compose(u), s = Ee.mapEffects(s, u).concat(Ee.mapEffects(Ya(l.effects), h));
      }
      return {
        changes: i,
        selection: q.create(o, n.mainIndex),
        effects: s
      };
    }
    changes(e = []) {
      return e instanceof Dt ? e : Dt.of(e, this.doc.length, this.facet(Ne.lineSeparator));
    }
    toText(e) {
      return He.of(e.split(this.facet(Ne.lineSeparator) || Iy));
    }
    sliceDoc(e = 0, n = this.doc.length) {
      return this.doc.sliceString(e, n, this.lineBreak);
    }
    facet(e) {
      let n = this.config.address[e.id];
      return n == null ? e.default : (Xc(this, n), xp(this, n));
    }
    toJSON(e) {
      let n = {
        doc: this.sliceDoc(),
        selection: this.selection.toJSON()
      };
      if (e)
        for (let r in e) {
          let i = e[r];
          i instanceof Ut && this.config.address[i.id] != null && (n[r] = i.spec.toJSON(this.field(e[r]), this));
        }
      return n;
    }
    static fromJSON(e, n = {}, r) {
      if (!e || typeof e.doc != "string")
        throw new RangeError("Invalid JSON representation for EditorState");
      let i = [];
      if (r) {
        for (let o in r)
          if (Object.prototype.hasOwnProperty.call(e, o)) {
            let s = r[o], a = e[o];
            i.push(s.init((l) => s.spec.fromJSON(a, l)));
          }
      }
      return Ne.create({
        doc: e.doc,
        selection: q.fromJSON(e.selection),
        extensions: n.extensions ? i.concat([
          n.extensions
        ]) : i
      });
    }
    static create(e = {}) {
      let n = bp.resolve(e.extensions || [], /* @__PURE__ */ new Map()), r = e.doc instanceof He ? e.doc : He.of((e.doc || "").split(n.staticFacet(Ne.lineSeparator) || Iy)), i = e.selection ? e.selection instanceof q ? e.selection : q.single(e.selection.anchor, e.selection.head) : q.single(0);
      return dO(i, r.length), n.staticFacet(Fy) || (i = i.asSingle()), new Ne(n, r, i, n.dynamicSlots.map(() => null), (o, s) => s.create(o), null);
    }
    get tabSize() {
      return this.facet(Ne.tabSize);
    }
    get lineBreak() {
      return this.facet(Ne.lineSeparator) || `
`;
    }
    get readOnly() {
      return this.facet(xO);
    }
    phrase(e, ...n) {
      for (let r of this.facet(Ne.phrases))
        if (Object.prototype.hasOwnProperty.call(r, e)) {
          e = r[e];
          break;
        }
      return n.length && (e = e.replace(/\$(\$|\d*)/g, (r, i) => {
        if (i == "$")
          return "$";
        let o = +(i || 1);
        return !o || o > n.length ? r : n[o - 1];
      })), e;
    }
    languageDataAt(e, n, r = -1) {
      let i = [];
      for (let o of this.facet(mO))
        for (let s of o(this, n, r))
          Object.prototype.hasOwnProperty.call(s, e) && i.push(s[e]);
      return i;
    }
    charCategorizer(e) {
      return YW(this.languageDataAt("wordChars", e).join(""));
    }
    wordAt(e) {
      let { text: n, from: r, length: i } = this.doc.lineAt(e), o = this.charCategorizer(e), s = e - r, a = e - r;
      for (; s > 0; ) {
        let l = en(n, s, false);
        if (o(n.slice(l, s)) != ht.Word)
          break;
        s = l;
      }
      for (; a < i; ) {
        let l = en(n, a);
        if (o(n.slice(a, l)) != ht.Word)
          break;
        a = l;
      }
      return s == a ? null : q.range(s + r, a + r);
    }
  }
  Ne.allowMultipleSelections = Fy;
  Ne.tabSize = me.define({
    combine: (t) => t.length ? t[0] : 4
  });
  Ne.lineSeparator = gO;
  Ne.readOnly = xO;
  Ne.phrases = me.define({
    compare(t, e) {
      let n = Object.keys(t), r = Object.keys(e);
      return n.length == r.length && n.every((i) => t[i] == e[i]);
    }
  });
  Ne.languageData = mO;
  Ne.changeFilter = vO;
  Ne.transactionFilter = yO;
  Ne.transactionExtender = bO;
  $m.reconfigure = Ee.define();
  function Oi(t, e, n = {}) {
    let r = {};
    for (let i of t)
      for (let o of Object.keys(i)) {
        let s = i[o], a = r[o];
        if (a === void 0)
          r[o] = s;
        else if (!(a === s || s === void 0))
          if (Object.hasOwnProperty.call(n, o))
            r[o] = n[o](a, s);
          else
            throw new Error("Config merge conflict for field " + o);
      }
    for (let i in e)
      r[i] === void 0 && (r[i] = e[i]);
    return r;
  }
  class Ws {
    eq(e) {
      return this == e;
    }
    range(e, n = e) {
      return Du.create(e, n, this);
    }
  }
  Ws.prototype.startSide = Ws.prototype.endSide = 0;
  Ws.prototype.point = false;
  Ws.prototype.mapMode = Zt.TrackDel;
  class Du {
    constructor(e, n, r) {
      this.from = e, this.to = n, this.value = r;
    }
    static create(e, n, r) {
      return new Du(e, n, r);
    }
  }
  function jy(t, e) {
    return t.from - e.from || t.value.startSide - e.value.startSide;
  }
  class Ax {
    constructor(e, n, r, i) {
      this.from = e, this.to = n, this.value = r, this.maxPoint = i;
    }
    get length() {
      return this.to[this.to.length - 1];
    }
    findIndex(e, n, r, i = 0) {
      let o = r ? this.to : this.from;
      for (let s = i, a = o.length; ; ) {
        if (s == a)
          return s;
        let l = s + a >> 1, c = o[l] - e || (r ? this.value[l].endSide : this.value[l].startSide) - n;
        if (l == s)
          return c >= 0 ? s : a;
        c >= 0 ? a = l : s = l + 1;
      }
    }
    between(e, n, r, i) {
      for (let o = this.findIndex(n, -1e9, true), s = this.findIndex(r, 1e9, false, o); o < s; o++)
        if (i(this.from[o] + e, this.to[o] + e, this.value[o]) === false)
          return false;
    }
    map(e, n) {
      let r = [], i = [], o = [], s = -1, a = -1;
      for (let l = 0; l < this.value.length; l++) {
        let c = this.value[l], u = this.from[l] + e, h = this.to[l] + e, p, v;
        if (u == h) {
          let y = n.mapPos(u, c.startSide, c.mapMode);
          if (y == null || (p = v = y, c.startSide != c.endSide && (v = n.mapPos(u, c.endSide), v < p)))
            continue;
        } else if (p = n.mapPos(u, c.startSide), v = n.mapPos(h, c.endSide), p > v || p == v && c.startSide > 0 && c.endSide <= 0)
          continue;
        (v - p || c.endSide - c.startSide) < 0 || (s < 0 && (s = p), c.point && (a = Math.max(a, v - p)), r.push(c), i.push(p - s), o.push(v - s));
      }
      return {
        mapped: r.length ? new Ax(i, o, r, a) : null,
        pos: s
      };
    }
  }
  class Ve {
    constructor(e, n, r, i) {
      this.chunkPos = e, this.chunk = n, this.nextLayer = r, this.maxPoint = i;
    }
    static create(e, n, r, i) {
      return new Ve(e, n, r, i);
    }
    get length() {
      let e = this.chunk.length - 1;
      return e < 0 ? 0 : Math.max(this.chunkEnd(e), this.nextLayer.length);
    }
    get size() {
      if (this.isEmpty)
        return 0;
      let e = this.nextLayer.size;
      for (let n of this.chunk)
        e += n.value.length;
      return e;
    }
    chunkEnd(e) {
      return this.chunkPos[e] + this.chunk[e].length;
    }
    update(e) {
      let { add: n = [], sort: r = false, filterFrom: i = 0, filterTo: o = this.length } = e, s = e.filter;
      if (n.length == 0 && !s)
        return this;
      if (r && (n = n.slice().sort(jy)), this.isEmpty)
        return n.length ? Ve.of(n) : this;
      let a = new kO(this, null, -1).goto(0), l = 0, c = [], u = new Mi();
      for (; a.value || l < n.length; )
        if (l < n.length && (a.from - n[l].from || a.startSide - n[l].value.startSide) >= 0) {
          let h = n[l++];
          u.addInner(h.from, h.to, h.value) || c.push(h);
        } else
          a.rangeIndex == 1 && a.chunkIndex < this.chunk.length && (l == n.length || this.chunkEnd(a.chunkIndex) < n[l].from) && (!s || i > this.chunkEnd(a.chunkIndex) || o < this.chunkPos[a.chunkIndex]) && u.addChunk(this.chunkPos[a.chunkIndex], this.chunk[a.chunkIndex]) ? a.nextChunk() : ((!s || i > a.to || o < a.from || s(a.from, a.to, a.value)) && (u.addInner(a.from, a.to, a.value) || c.push(Du.create(a.from, a.to, a.value))), a.next());
      return u.finishInner(this.nextLayer.isEmpty && !c.length ? Ve.empty : this.nextLayer.update({
        add: c,
        filter: s,
        filterFrom: i,
        filterTo: o
      }));
    }
    map(e) {
      if (e.empty || this.isEmpty)
        return this;
      let n = [], r = [], i = -1;
      for (let s = 0; s < this.chunk.length; s++) {
        let a = this.chunkPos[s], l = this.chunk[s], c = e.touchesRange(a, a + l.length);
        if (c === false)
          i = Math.max(i, l.maxPoint), n.push(l), r.push(e.mapPos(a));
        else if (c === true) {
          let { mapped: u, pos: h } = l.map(a, e);
          u && (i = Math.max(i, u.maxPoint), n.push(u), r.push(h));
        }
      }
      let o = this.nextLayer.map(e);
      return n.length == 0 ? o : new Ve(r, n, o || Ve.empty, i);
    }
    between(e, n, r) {
      if (!this.isEmpty) {
        for (let i = 0; i < this.chunk.length; i++) {
          let o = this.chunkPos[i], s = this.chunk[i];
          if (n >= o && e <= o + s.length && s.between(o, e - o, n - o, r) === false)
            return;
        }
        this.nextLayer.between(e, n, r);
      }
    }
    iter(e = 0) {
      return Iu.from([
        this
      ]).goto(e);
    }
    get isEmpty() {
      return this.nextLayer == this;
    }
    static iter(e, n = 0) {
      return Iu.from(e).goto(n);
    }
    static compare(e, n, r, i, o = -1) {
      let s = e.filter((h) => h.maxPoint > 0 || !h.isEmpty && h.maxPoint >= o), a = n.filter((h) => h.maxPoint > 0 || !h.isEmpty && h.maxPoint >= o), l = gC(s, a, r), c = new sc(s, l, o), u = new sc(a, l, o);
      r.iterGaps((h, p, v) => vC(c, h, u, p, v, i)), r.empty && r.length == 0 && vC(c, 0, u, 0, 0, i);
    }
    static eq(e, n, r = 0, i) {
      i == null && (i = 1e9 - 1);
      let o = e.filter((u) => !u.isEmpty && n.indexOf(u) < 0), s = n.filter((u) => !u.isEmpty && e.indexOf(u) < 0);
      if (o.length != s.length)
        return false;
      if (!o.length)
        return true;
      let a = gC(o, s), l = new sc(o, a, 0).goto(r), c = new sc(s, a, 0).goto(r);
      for (; ; ) {
        if (l.to != c.to || !Wy(l.active, c.active) || l.point && (!c.point || !l.point.eq(c.point)))
          return false;
        if (l.to > i)
          return true;
        l.next(), c.next();
      }
    }
    static spans(e, n, r, i, o = -1) {
      let s = new sc(e, null, o).goto(n), a = n, l = s.openStart;
      for (; ; ) {
        let c = Math.min(s.to, r);
        if (s.point) {
          let u = s.activeForPoint(s.to), h = s.pointFrom < n ? u.length + 1 : s.point.startSide < 0 ? u.length : Math.min(u.length, l);
          i.point(a, c, s.point, u, h, s.pointRank), l = Math.min(s.openEnd(c), u.length);
        } else
          c > a && (i.span(a, c, s.active, l), l = s.openEnd(c));
        if (s.to > r)
          return l + (s.point && s.to > r ? 1 : 0);
        a = s.to, s.next();
      }
    }
    static of(e, n = false) {
      let r = new Mi();
      for (let i of e instanceof Du ? [
        e
      ] : n ? XW(e) : e)
        r.add(i.from, i.to, i.value);
      return r.finish();
    }
    static join(e) {
      if (!e.length)
        return Ve.empty;
      let n = e[e.length - 1];
      for (let r = e.length - 2; r >= 0; r--)
        for (let i = e[r]; i != Ve.empty; i = i.nextLayer)
          n = new Ve(i.chunkPos, i.chunk, n, Math.max(i.maxPoint, n.maxPoint));
      return n;
    }
  }
  Ve.empty = new Ve([], [], null, -1);
  function XW(t) {
    if (t.length > 1)
      for (let e = t[0], n = 1; n < t.length; n++) {
        let r = t[n];
        if (jy(e, r) > 0)
          return t.slice().sort(jy);
        e = r;
      }
    return t;
  }
  Ve.empty.nextLayer = Ve.empty;
  class Mi {
    finishChunk(e) {
      this.chunks.push(new Ax(this.from, this.to, this.value, this.maxPoint)), this.chunkPos.push(this.chunkStart), this.chunkStart = -1, this.setMaxPoint = Math.max(this.setMaxPoint, this.maxPoint), this.maxPoint = -1, e && (this.from = [], this.to = [], this.value = []);
    }
    constructor() {
      this.chunks = [], this.chunkPos = [], this.chunkStart = -1, this.last = null, this.lastFrom = -1e9, this.lastTo = -1e9, this.from = [], this.to = [], this.value = [], this.maxPoint = -1, this.setMaxPoint = -1, this.nextLayer = null;
    }
    add(e, n, r) {
      this.addInner(e, n, r) || (this.nextLayer || (this.nextLayer = new Mi())).add(e, n, r);
    }
    addInner(e, n, r) {
      let i = e - this.lastTo || r.startSide - this.last.endSide;
      if (i <= 0 && (e - this.lastFrom || r.startSide - this.last.startSide) < 0)
        throw new Error("Ranges must be added sorted by `from` position and `startSide`");
      return i < 0 ? false : (this.from.length == 250 && this.finishChunk(true), this.chunkStart < 0 && (this.chunkStart = e), this.from.push(e - this.chunkStart), this.to.push(n - this.chunkStart), this.last = r, this.lastFrom = e, this.lastTo = n, this.value.push(r), r.point && (this.maxPoint = Math.max(this.maxPoint, n - e)), true);
    }
    addChunk(e, n) {
      if ((e - this.lastTo || n.value[0].startSide - this.last.endSide) < 0)
        return false;
      this.from.length && this.finishChunk(true), this.setMaxPoint = Math.max(this.setMaxPoint, n.maxPoint), this.chunks.push(n), this.chunkPos.push(e);
      let r = n.value.length - 1;
      return this.last = n.value[r], this.lastFrom = n.from[r] + e, this.lastTo = n.to[r] + e, true;
    }
    finish() {
      return this.finishInner(Ve.empty);
    }
    finishInner(e) {
      if (this.from.length && this.finishChunk(false), this.chunks.length == 0)
        return e;
      let n = Ve.create(this.chunkPos, this.chunks, this.nextLayer ? this.nextLayer.finishInner(e) : e, this.setMaxPoint);
      return this.from = null, n;
    }
  }
  function gC(t, e, n) {
    let r = /* @__PURE__ */ new Map();
    for (let o of t)
      for (let s = 0; s < o.chunk.length; s++)
        o.chunk[s].maxPoint <= 0 && r.set(o.chunk[s], o.chunkPos[s]);
    let i = /* @__PURE__ */ new Set();
    for (let o of e)
      for (let s = 0; s < o.chunk.length; s++) {
        let a = r.get(o.chunk[s]);
        a != null && (n ? n.mapPos(a) : a) == o.chunkPos[s] && !(n == null ? void 0 : n.touchesRange(a, a + o.chunk[s].length)) && i.add(o.chunk[s]);
      }
    return i;
  }
  class kO {
    constructor(e, n, r, i = 0) {
      this.layer = e, this.skip = n, this.minPoint = r, this.rank = i;
    }
    get startSide() {
      return this.value ? this.value.startSide : 0;
    }
    get endSide() {
      return this.value ? this.value.endSide : 0;
    }
    goto(e, n = -1e9) {
      return this.chunkIndex = this.rangeIndex = 0, this.gotoInner(e, n, false), this;
    }
    gotoInner(e, n, r) {
      for (; this.chunkIndex < this.layer.chunk.length; ) {
        let i = this.layer.chunk[this.chunkIndex];
        if (!(this.skip && this.skip.has(i) || this.layer.chunkEnd(this.chunkIndex) < e || i.maxPoint < this.minPoint))
          break;
        this.chunkIndex++, r = false;
      }
      if (this.chunkIndex < this.layer.chunk.length) {
        let i = this.layer.chunk[this.chunkIndex].findIndex(e - this.layer.chunkPos[this.chunkIndex], n, true);
        (!r || this.rangeIndex < i) && this.setRangeIndex(i);
      }
      this.next();
    }
    forward(e, n) {
      (this.to - e || this.endSide - n) < 0 && this.gotoInner(e, n, true);
    }
    next() {
      for (; ; )
        if (this.chunkIndex == this.layer.chunk.length) {
          this.from = this.to = 1e9, this.value = null;
          break;
        } else {
          let e = this.layer.chunkPos[this.chunkIndex], n = this.layer.chunk[this.chunkIndex], r = e + n.from[this.rangeIndex];
          if (this.from = r, this.to = e + n.to[this.rangeIndex], this.value = n.value[this.rangeIndex], this.setRangeIndex(this.rangeIndex + 1), this.minPoint < 0 || this.value.point && this.to - this.from >= this.minPoint)
            break;
        }
    }
    setRangeIndex(e) {
      if (e == this.layer.chunk[this.chunkIndex].value.length) {
        if (this.chunkIndex++, this.skip)
          for (; this.chunkIndex < this.layer.chunk.length && this.skip.has(this.layer.chunk[this.chunkIndex]); )
            this.chunkIndex++;
        this.rangeIndex = 0;
      } else
        this.rangeIndex = e;
    }
    nextChunk() {
      this.chunkIndex++, this.rangeIndex = 0, this.next();
    }
    compare(e) {
      return this.from - e.from || this.startSide - e.startSide || this.rank - e.rank || this.to - e.to || this.endSide - e.endSide;
    }
  }
  class Iu {
    constructor(e) {
      this.heap = e;
    }
    static from(e, n = null, r = -1) {
      let i = [];
      for (let o = 0; o < e.length; o++)
        for (let s = e[o]; !s.isEmpty; s = s.nextLayer)
          s.maxPoint >= r && i.push(new kO(s, n, r, o));
      return i.length == 1 ? i[0] : new Iu(i);
    }
    get startSide() {
      return this.value ? this.value.startSide : 0;
    }
    goto(e, n = -1e9) {
      for (let r of this.heap)
        r.goto(e, n);
      for (let r = this.heap.length >> 1; r >= 0; r--)
        O0(this.heap, r);
      return this.next(), this;
    }
    forward(e, n) {
      for (let r of this.heap)
        r.forward(e, n);
      for (let r = this.heap.length >> 1; r >= 0; r--)
        O0(this.heap, r);
      (this.to - e || this.value.endSide - n) < 0 && this.next();
    }
    next() {
      if (this.heap.length == 0)
        this.from = this.to = 1e9, this.value = null, this.rank = -1;
      else {
        let e = this.heap[0];
        this.from = e.from, this.to = e.to, this.value = e.value, this.rank = e.rank, e.value && e.next(), O0(this.heap, 0);
      }
    }
  }
  function O0(t, e) {
    for (let n = t[e]; ; ) {
      let r = (e << 1) + 1;
      if (r >= t.length)
        break;
      let i = t[r];
      if (r + 1 < t.length && i.compare(t[r + 1]) >= 0 && (i = t[r + 1], r++), n.compare(i) < 0)
        break;
      t[r] = n, t[e] = i, e = r;
    }
  }
  class sc {
    constructor(e, n, r) {
      this.minPoint = r, this.active = [], this.activeTo = [], this.activeRank = [], this.minActive = -1, this.point = null, this.pointFrom = 0, this.pointRank = 0, this.to = -1e9, this.endSide = 0, this.openStart = -1, this.cursor = Iu.from(e, n, r);
    }
    goto(e, n = -1e9) {
      return this.cursor.goto(e, n), this.active.length = this.activeTo.length = this.activeRank.length = 0, this.minActive = -1, this.to = e, this.endSide = n, this.openStart = -1, this.next(), this;
    }
    forward(e, n) {
      for (; this.minActive > -1 && (this.activeTo[this.minActive] - e || this.active[this.minActive].endSide - n) < 0; )
        this.removeActive(this.minActive);
      this.cursor.forward(e, n);
    }
    removeActive(e) {
      wh(this.active, e), wh(this.activeTo, e), wh(this.activeRank, e), this.minActive = yC(this.active, this.activeTo);
    }
    addActive(e) {
      let n = 0, { value: r, to: i, rank: o } = this.cursor;
      for (; n < this.activeRank.length && (o - this.activeRank[n] || i - this.activeTo[n]) > 0; )
        n++;
      kh(this.active, n, r), kh(this.activeTo, n, i), kh(this.activeRank, n, o), e && kh(e, n, this.cursor.from), this.minActive = yC(this.active, this.activeTo);
    }
    next() {
      let e = this.to, n = this.point;
      this.point = null;
      let r = this.openStart < 0 ? [] : null;
      for (; ; ) {
        let i = this.minActive;
        if (i > -1 && (this.activeTo[i] - this.cursor.from || this.active[i].endSide - this.cursor.startSide) < 0) {
          if (this.activeTo[i] > e) {
            this.to = this.activeTo[i], this.endSide = this.active[i].endSide;
            break;
          }
          this.removeActive(i), r && wh(r, i);
        } else if (this.cursor.value)
          if (this.cursor.from > e) {
            this.to = this.cursor.from, this.endSide = this.cursor.startSide;
            break;
          } else {
            let o = this.cursor.value;
            if (!o.point)
              this.addActive(r), this.cursor.next();
            else if (n && this.cursor.to == this.to && this.cursor.from < this.cursor.to)
              this.cursor.next();
            else {
              this.point = o, this.pointFrom = this.cursor.from, this.pointRank = this.cursor.rank, this.to = this.cursor.to, this.endSide = o.endSide, this.cursor.next(), this.forward(this.to, this.endSide);
              break;
            }
          }
        else {
          this.to = this.endSide = 1e9;
          break;
        }
      }
      if (r) {
        this.openStart = 0;
        for (let i = r.length - 1; i >= 0 && r[i] < e; i--)
          this.openStart++;
      }
    }
    activeForPoint(e) {
      if (!this.active.length)
        return this.active;
      let n = [];
      for (let r = this.active.length - 1; r >= 0 && !(this.activeRank[r] < this.pointRank); r--)
        (this.activeTo[r] > e || this.activeTo[r] == e && this.active[r].endSide >= this.point.endSide) && n.push(this.active[r]);
      return n.reverse();
    }
    openEnd(e) {
      let n = 0;
      for (let r = this.activeTo.length - 1; r >= 0 && this.activeTo[r] > e; r--)
        n++;
      return n;
    }
  }
  function vC(t, e, n, r, i, o) {
    t.goto(e), n.goto(r);
    let s = r + i, a = r, l = r - e;
    for (; ; ) {
      let c = t.to + l - n.to, u = c || t.endSide - n.endSide, h = u < 0 ? t.to + l : n.to, p = Math.min(h, s);
      if (t.point || n.point ? t.point && n.point && (t.point == n.point || t.point.eq(n.point)) && Wy(t.activeForPoint(t.to), n.activeForPoint(n.to)) || o.comparePoint(a, p, t.point, n.point) : p > a && !Wy(t.active, n.active) && o.compareRange(a, p, t.active, n.active), h > s)
        break;
      (c || t.openEnd != n.openEnd) && o.boundChange && o.boundChange(h), a = h, u <= 0 && t.next(), u >= 0 && n.next();
    }
  }
  function Wy(t, e) {
    if (t.length != e.length)
      return false;
    for (let n = 0; n < t.length; n++)
      if (t[n] != e[n] && !t[n].eq(e[n]))
        return false;
    return true;
  }
  function wh(t, e) {
    for (let n = e, r = t.length - 1; n < r; n++)
      t[n] = t[n + 1];
    t.pop();
  }
  function kh(t, e, n) {
    for (let r = t.length - 1; r >= e; r--)
      t[r + 1] = t[r];
    t[e] = n;
  }
  function yC(t, e) {
    let n = -1, r = 1e9;
    for (let i = 0; i < e.length; i++)
      (e[i] - r || t[i].endSide - t[n].endSide) < 0 && (n = i, r = e[i]);
    return n;
  }
  function Pl(t, e, n = t.length) {
    let r = 0;
    for (let i = 0; i < n && i < t.length; )
      t.charCodeAt(i) == 9 ? (r += e - r % e, i++) : (r++, i = en(t, i));
    return r;
  }
  function Uy(t, e, n, r) {
    for (let i = 0, o = 0; ; ) {
      if (o >= e)
        return i;
      if (i == t.length)
        break;
      o += t.charCodeAt(i) == 9 ? n - o % n : 1, i = en(t, i);
    }
    return r === true ? -1 : t.length;
  }
  const Ky = "\u037C", bC = typeof Symbol > "u" ? "__" + Ky : Symbol.for(Ky), qy = typeof Symbol > "u" ? "__styleSet" + Math.floor(Math.random() * 1e8) : Symbol("styleSet"), xC = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : {};
  class qo {
    constructor(e, n) {
      this.rules = [];
      let { finish: r } = n || {};
      function i(s) {
        return /^@/.test(s) ? [
          s
        ] : s.split(/,\s*/);
      }
      function o(s, a, l, c) {
        let u = [], h = /^@(\w+)\b/.exec(s[0]), p = h && h[1] == "keyframes";
        if (h && a == null)
          return l.push(s[0] + ";");
        for (let v in a) {
          let y = a[v];
          if (/&/.test(v))
            o(v.split(/,\s*/).map((x) => s.map((T) => x.replace(/&/, T))).reduce((x, T) => x.concat(T)), y, l);
          else if (y && typeof y == "object") {
            if (!h)
              throw new RangeError("The value of a property (" + v + ") should be a primitive value.");
            o(i(v), y, u, p);
          } else
            y != null && u.push(v.replace(/_.*/, "").replace(/[A-Z]/g, (x) => "-" + x.toLowerCase()) + ": " + y + ";");
        }
        (u.length || p) && l.push((r && !h && !c ? s.map(r) : s).join(", ") + " {" + u.join(" ") + "}");
      }
      for (let s in e)
        o(i(s), e[s], this.rules);
    }
    getRules() {
      return this.rules.join(`
`);
    }
    static newName() {
      let e = xC[bC] || 1;
      return xC[bC] = e + 1, Ky + e.toString(36);
    }
    static mount(e, n, r) {
      let i = e[qy], o = r && r.nonce;
      i ? o && i.setNonce(o) : i = new QW(e, o), i.mount(Array.isArray(n) ? n : [
        n
      ], e);
    }
  }
  let SC = /* @__PURE__ */ new Map();
  class QW {
    constructor(e, n) {
      let r = e.ownerDocument || e, i = r.defaultView;
      if (!e.head && e.adoptedStyleSheets && i.CSSStyleSheet) {
        let o = SC.get(r);
        if (o)
          return e[qy] = o;
        this.sheet = new i.CSSStyleSheet(), SC.set(r, this);
      } else
        this.styleTag = r.createElement("style"), n && this.styleTag.setAttribute("nonce", n);
      this.modules = [], e[qy] = this;
    }
    mount(e, n) {
      let r = this.sheet, i = 0, o = 0;
      for (let s = 0; s < e.length; s++) {
        let a = e[s], l = this.modules.indexOf(a);
        if (l < o && l > -1 && (this.modules.splice(l, 1), o--, l = -1), l == -1) {
          if (this.modules.splice(o++, 0, a), r)
            for (let c = 0; c < a.rules.length; c++)
              r.insertRule(a.rules[c], i++);
        } else {
          for (; o < l; )
            i += this.modules[o++].rules.length;
          i += a.rules.length, o++;
        }
      }
      if (r)
        n.adoptedStyleSheets.indexOf(this.sheet) < 0 && (n.adoptedStyleSheets = [
          this.sheet,
          ...n.adoptedStyleSheets
        ]);
      else {
        let s = "";
        for (let l = 0; l < this.modules.length; l++)
          s += this.modules[l].getRules() + `
`;
        this.styleTag.textContent = s;
        let a = n.head || n;
        this.styleTag.parentNode != a && a.insertBefore(this.styleTag, a.firstChild);
      }
    }
    setNonce(e) {
      this.styleTag && this.styleTag.getAttribute("nonce") != e && this.styleTag.setAttribute("nonce", e);
    }
  }
  var Go = {
    8: "Backspace",
    9: "Tab",
    10: "Enter",
    12: "NumLock",
    13: "Enter",
    16: "Shift",
    17: "Control",
    18: "Alt",
    20: "CapsLock",
    27: "Escape",
    32: " ",
    33: "PageUp",
    34: "PageDown",
    35: "End",
    36: "Home",
    37: "ArrowLeft",
    38: "ArrowUp",
    39: "ArrowRight",
    40: "ArrowDown",
    44: "PrintScreen",
    45: "Insert",
    46: "Delete",
    59: ";",
    61: "=",
    91: "Meta",
    92: "Meta",
    106: "*",
    107: "+",
    108: ",",
    109: "-",
    110: ".",
    111: "/",
    144: "NumLock",
    145: "ScrollLock",
    160: "Shift",
    161: "Shift",
    162: "Control",
    163: "Control",
    164: "Alt",
    165: "Alt",
    173: "-",
    186: ";",
    187: "=",
    188: ",",
    189: "-",
    190: ".",
    191: "/",
    192: "`",
    219: "[",
    220: "\\",
    221: "]",
    222: "'"
  }, Bu = {
    48: ")",
    49: "!",
    50: "@",
    51: "#",
    52: "$",
    53: "%",
    54: "^",
    55: "&",
    56: "*",
    57: "(",
    59: ":",
    61: "+",
    173: "_",
    186: ":",
    187: "+",
    188: "<",
    189: "_",
    190: ">",
    191: "?",
    192: "~",
    219: "{",
    220: "|",
    221: "}",
    222: '"'
  }, JW = typeof navigator < "u" && /Mac/.test(navigator.platform), ZW = typeof navigator < "u" && /MSIE \d|Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(navigator.userAgent);
  for (var Qt = 0; Qt < 10; Qt++)
    Go[48 + Qt] = Go[96 + Qt] = String(Qt);
  for (var Qt = 1; Qt <= 24; Qt++)
    Go[Qt + 111] = "F" + Qt;
  for (var Qt = 65; Qt <= 90; Qt++)
    Go[Qt] = String.fromCharCode(Qt + 32), Bu[Qt] = String.fromCharCode(Qt);
  for (var R0 in Go)
    Bu.hasOwnProperty(R0) || (Bu[R0] = Go[R0]);
  function e7(t) {
    var e = JW && t.metaKey && t.shiftKey && !t.ctrlKey && !t.altKey || ZW && t.shiftKey && t.key && t.key.length == 1 || t.key == "Unidentified", n = !e && t.key || (t.shiftKey ? Bu : Go)[t.keyCode] || t.key || "Unidentified";
    return n == "Esc" && (n = "Escape"), n == "Del" && (n = "Delete"), n == "Left" && (n = "ArrowLeft"), n == "Up" && (n = "ArrowUp"), n == "Right" && (n = "ArrowRight"), n == "Down" && (n = "ArrowDown"), n;
  }
  function Je() {
    var t = arguments[0];
    typeof t == "string" && (t = document.createElement(t));
    var e = 1, n = arguments[1];
    if (n && typeof n == "object" && n.nodeType == null && !Array.isArray(n)) {
      for (var r in n)
        if (Object.prototype.hasOwnProperty.call(n, r)) {
          var i = n[r];
          typeof i == "string" ? t.setAttribute(r, i) : i != null && (t[r] = i);
        }
      e++;
    }
    for (; e < arguments.length; e++)
      CO(t, arguments[e]);
    return t;
  }
  function CO(t, e) {
    if (typeof e == "string")
      t.appendChild(document.createTextNode(e));
    else if (e != null)
      if (e.nodeType != null)
        t.appendChild(e);
      else if (Array.isArray(e))
        for (var n = 0; n < e.length; n++)
          CO(t, e[n]);
      else
        throw new RangeError("Unsupported child node: " + e);
  }
  let xn = typeof navigator < "u" ? navigator : {
    userAgent: "",
    vendor: "",
    platform: ""
  }, Gy = typeof document < "u" ? document : {
    documentElement: {
      style: {}
    }
  };
  const Yy = /Edge\/(\d+)/.exec(xn.userAgent), TO = /MSIE \d/.test(xn.userAgent), Xy = /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(xn.userAgent), zm = !!(TO || Xy || Yy), wC = !zm && /gecko\/(\d+)/i.test(xn.userAgent), L0 = !zm && /Chrome\/(\d+)/.exec(xn.userAgent), kC = "webkitFontSmoothing" in Gy.documentElement.style, Qy = !zm && /Apple Computer/.test(xn.vendor), CC = Qy && (/Mobile\/\w+/.test(xn.userAgent) || xn.maxTouchPoints > 2);
  var fe = {
    mac: CC || /Mac/.test(xn.platform),
    windows: /Win/.test(xn.platform),
    linux: /Linux|X11/.test(xn.platform),
    ie: zm,
    ie_version: TO ? Gy.documentMode || 6 : Xy ? +Xy[1] : Yy ? +Yy[1] : 0,
    gecko: wC,
    gecko_version: wC ? +(/Firefox\/(\d+)/.exec(xn.userAgent) || [
      0,
      0
    ])[1] : 0,
    chrome: !!L0,
    chrome_version: L0 ? +L0[1] : 0,
    ios: CC,
    android: /Android\b/.test(xn.userAgent),
    webkit: kC,
    webkit_version: kC ? +(/\bAppleWebKit\/(\d+)/.exec(xn.userAgent) || [
      0,
      0
    ])[1] : 0,
    safari: Qy,
    safari_version: Qy ? +(/\bVersion\/(\d+(\.\d+)?)/.exec(xn.userAgent) || [
      0,
      0
    ])[1] : 0,
    tabSize: Gy.documentElement.style.tabSize != null ? "tab-size" : "-moz-tab-size"
  };
  function Nu(t) {
    let e;
    return t.nodeType == 11 ? e = t.getSelection ? t : t.ownerDocument : e = t, e.getSelection();
  }
  function Jy(t, e) {
    return e ? t == e || t.contains(e.nodeType != 1 ? e.parentNode : e) : false;
  }
  function wd(t, e) {
    if (!e.anchorNode)
      return false;
    try {
      return Jy(t, e.anchorNode);
    } catch {
      return false;
    }
  }
  function pl(t) {
    return t.nodeType == 3 ? Ks(t, 0, t.nodeValue.length).getClientRects() : t.nodeType == 1 ? t.getClientRects() : [];
  }
  function Qc(t, e, n, r) {
    return n ? TC(t, e, n, r, -1) || TC(t, e, n, r, 1) : false;
  }
  function Us(t) {
    for (var e = 0; ; e++)
      if (t = t.previousSibling, !t)
        return e;
  }
  function Sp(t) {
    return t.nodeType == 1 && /^(DIV|P|LI|UL|OL|BLOCKQUOTE|DD|DT|H\d|SECTION|PRE)$/.test(t.nodeName);
  }
  function TC(t, e, n, r, i) {
    for (; ; ) {
      if (t == n && e == r)
        return true;
      if (e == (i < 0 ? 0 : Ai(t))) {
        if (t.nodeName == "DIV")
          return false;
        let o = t.parentNode;
        if (!o || o.nodeType != 1)
          return false;
        e = Us(t) + (i < 0 ? 0 : 1), t = o;
      } else if (t.nodeType == 1) {
        if (t = t.childNodes[e + (i < 0 ? -1 : 0)], t.nodeType == 1 && t.contentEditable == "false")
          return false;
        e = i < 0 ? Ai(t) : 0;
      } else
        return false;
    }
  }
  function Ai(t) {
    return t.nodeType == 3 ? t.nodeValue.length : t.childNodes.length;
  }
  function af(t, e) {
    let n = e ? t.left : t.right;
    return {
      left: n,
      right: n,
      top: t.top,
      bottom: t.bottom
    };
  }
  function t7(t) {
    let e = t.visualViewport;
    return e ? {
      left: 0,
      right: e.width,
      top: 0,
      bottom: e.height
    } : {
      left: 0,
      right: t.innerWidth,
      top: 0,
      bottom: t.innerHeight
    };
  }
  function MO(t, e) {
    let n = e.width / t.offsetWidth, r = e.height / t.offsetHeight;
    return (n > 0.995 && n < 1.005 || !isFinite(n) || Math.abs(e.width - t.offsetWidth) < 1) && (n = 1), (r > 0.995 && r < 1.005 || !isFinite(r) || Math.abs(e.height - t.offsetHeight) < 1) && (r = 1), {
      scaleX: n,
      scaleY: r
    };
  }
  function n7(t, e, n, r, i, o, s, a) {
    let l = t.ownerDocument, c = l.defaultView || window;
    for (let u = t, h = false; u && !h; )
      if (u.nodeType == 1) {
        let p, v = u == l.body, y = 1, x = 1;
        if (v)
          p = t7(c);
        else {
          if (/^(fixed|sticky)$/.test(getComputedStyle(u).position) && (h = true), u.scrollHeight <= u.clientHeight && u.scrollWidth <= u.clientWidth) {
            u = u.assignedSlot || u.parentNode;
            continue;
          }
          let k = u.getBoundingClientRect();
          ({ scaleX: y, scaleY: x } = MO(u, k)), p = {
            left: k.left,
            right: k.left + u.clientWidth * y,
            top: k.top,
            bottom: k.top + u.clientHeight * x
          };
        }
        let T = 0, w = 0;
        if (i == "nearest")
          e.top < p.top ? (w = e.top - (p.top + s), n > 0 && e.bottom > p.bottom + w && (w = e.bottom - p.bottom + s)) : e.bottom > p.bottom && (w = e.bottom - p.bottom + s, n < 0 && e.top - w < p.top && (w = e.top - (p.top + s)));
        else {
          let k = e.bottom - e.top, C = p.bottom - p.top;
          w = (i == "center" && k <= C ? e.top + k / 2 - C / 2 : i == "start" || i == "center" && n < 0 ? e.top - s : e.bottom - C + s) - p.top;
        }
        if (r == "nearest" ? e.left < p.left ? (T = e.left - (p.left + o), n > 0 && e.right > p.right + T && (T = e.right - p.right + o)) : e.right > p.right && (T = e.right - p.right + o, n < 0 && e.left < p.left + T && (T = e.left - (p.left + o))) : T = (r == "center" ? e.left + (e.right - e.left) / 2 - (p.right - p.left) / 2 : r == "start" == a ? e.left - o : e.right - (p.right - p.left) + o) - p.left, T || w)
          if (v)
            c.scrollBy(T, w);
          else {
            let k = 0, C = 0;
            if (w) {
              let P = u.scrollTop;
              u.scrollTop += w / x, C = (u.scrollTop - P) * x;
            }
            if (T) {
              let P = u.scrollLeft;
              u.scrollLeft += T / y, k = (u.scrollLeft - P) * y;
            }
            e = {
              left: e.left - k,
              top: e.top - C,
              right: e.right - k,
              bottom: e.bottom - C
            }, k && Math.abs(k - T) < 1 && (r = "nearest"), C && Math.abs(C - w) < 1 && (i = "nearest");
          }
        if (v)
          break;
        (e.top < p.top || e.bottom > p.bottom || e.left < p.left || e.right > p.right) && (e = {
          left: Math.max(e.left, p.left),
          right: Math.min(e.right, p.right),
          top: Math.max(e.top, p.top),
          bottom: Math.min(e.bottom, p.bottom)
        }), u = u.assignedSlot || u.parentNode;
      } else if (u.nodeType == 11)
        u = u.host;
      else
        break;
  }
  function r7(t) {
    let e = t.ownerDocument, n, r;
    for (let i = t.parentNode; i && !(i == e.body || n && r); )
      if (i.nodeType == 1)
        !r && i.scrollHeight > i.clientHeight && (r = i), !n && i.scrollWidth > i.clientWidth && (n = i), i = i.assignedSlot || i.parentNode;
      else if (i.nodeType == 11)
        i = i.host;
      else
        break;
    return {
      x: n,
      y: r
    };
  }
  class i7 {
    constructor() {
      this.anchorNode = null, this.anchorOffset = 0, this.focusNode = null, this.focusOffset = 0;
    }
    eq(e) {
      return this.anchorNode == e.anchorNode && this.anchorOffset == e.anchorOffset && this.focusNode == e.focusNode && this.focusOffset == e.focusOffset;
    }
    setRange(e) {
      let { anchorNode: n, focusNode: r } = e;
      this.set(n, Math.min(e.anchorOffset, n ? Ai(n) : 0), r, Math.min(e.focusOffset, r ? Ai(r) : 0));
    }
    set(e, n, r, i) {
      this.anchorNode = e, this.anchorOffset = n, this.focusNode = r, this.focusOffset = i;
    }
  }
  let bs = null;
  fe.safari && fe.safari_version >= 26 && (bs = false);
  function AO(t) {
    if (t.setActive)
      return t.setActive();
    if (bs)
      return t.focus(bs);
    let e = [];
    for (let n = t; n && (e.push(n, n.scrollTop, n.scrollLeft), n != n.ownerDocument); n = n.parentNode)
      ;
    if (t.focus(bs == null ? {
      get preventScroll() {
        return bs = {
          preventScroll: true
        }, true;
      }
    } : void 0), !bs) {
      bs = false;
      for (let n = 0; n < e.length; ) {
        let r = e[n++], i = e[n++], o = e[n++];
        r.scrollTop != i && (r.scrollTop = i), r.scrollLeft != o && (r.scrollLeft = o);
      }
    }
  }
  let MC;
  function Ks(t, e, n = e) {
    let r = MC || (MC = document.createRange());
    return r.setEnd(t, n), r.setStart(t, e), r;
  }
  function Xa(t, e, n, r) {
    let i = {
      key: e,
      code: e,
      keyCode: n,
      which: n,
      cancelable: true
    };
    r && ({ altKey: i.altKey, ctrlKey: i.ctrlKey, shiftKey: i.shiftKey, metaKey: i.metaKey } = r);
    let o = new KeyboardEvent("keydown", i);
    o.synthetic = true, t.dispatchEvent(o);
    let s = new KeyboardEvent("keyup", i);
    return s.synthetic = true, t.dispatchEvent(s), o.defaultPrevented || s.defaultPrevented;
  }
  function o7(t) {
    for (; t; ) {
      if (t && (t.nodeType == 9 || t.nodeType == 11 && t.host))
        return t;
      t = t.assignedSlot || t.parentNode;
    }
    return null;
  }
  function EO(t) {
    for (; t.attributes.length; )
      t.removeAttributeNode(t.attributes[0]);
  }
  function s7(t, e) {
    let n = e.focusNode, r = e.focusOffset;
    if (!n || e.anchorNode != n || e.anchorOffset != r)
      return false;
    for (r = Math.min(r, Ai(n)); ; )
      if (r) {
        if (n.nodeType != 1)
          return false;
        let i = n.childNodes[r - 1];
        i.contentEditable == "false" ? r-- : (n = i, r = Ai(n));
      } else {
        if (n == t)
          return true;
        r = Us(n), n = n.parentNode;
      }
  }
  function PO(t) {
    return t.scrollTop > Math.max(1, t.scrollHeight - t.clientHeight - 4);
  }
  function OO(t, e) {
    for (let n = t, r = e; ; ) {
      if (n.nodeType == 3 && r > 0)
        return {
          node: n,
          offset: r
        };
      if (n.nodeType == 1 && r > 0) {
        if (n.contentEditable == "false")
          return null;
        n = n.childNodes[r - 1], r = Ai(n);
      } else if (n.parentNode && !Sp(n))
        r = Us(n), n = n.parentNode;
      else
        return null;
    }
  }
  function RO(t, e) {
    for (let n = t, r = e; ; ) {
      if (n.nodeType == 3 && r < n.nodeValue.length)
        return {
          node: n,
          offset: r
        };
      if (n.nodeType == 1 && r < n.childNodes.length) {
        if (n.contentEditable == "false")
          return null;
        n = n.childNodes[r], r = 0;
      } else if (n.parentNode && !Sp(n))
        r = Us(n) + 1, n = n.parentNode;
      else
        return null;
    }
  }
  class hn {
    constructor(e, n, r = true) {
      this.node = e, this.offset = n, this.precise = r;
    }
    static before(e, n) {
      return new hn(e.parentNode, Us(e), n);
    }
    static after(e, n) {
      return new hn(e.parentNode, Us(e) + 1, n);
    }
  }
  const Ex = [];
  class Qe {
    constructor() {
      this.parent = null, this.dom = null, this.flags = 2;
    }
    get overrideDOMText() {
      return null;
    }
    get posAtStart() {
      return this.parent ? this.parent.posBefore(this) : 0;
    }
    get posAtEnd() {
      return this.posAtStart + this.length;
    }
    posBefore(e) {
      let n = this.posAtStart;
      for (let r of this.children) {
        if (r == e)
          return n;
        n += r.length + r.breakAfter;
      }
      throw new RangeError("Invalid child in posBefore");
    }
    posAfter(e) {
      return this.posBefore(e) + e.length;
    }
    sync(e, n) {
      if (this.flags & 2) {
        let r = this.dom, i = null, o;
        for (let s of this.children) {
          if (s.flags & 7) {
            if (!s.dom && (o = i ? i.nextSibling : r.firstChild)) {
              let a = Qe.get(o);
              (!a || !a.parent && a.canReuseDOM(s)) && s.reuseDOM(o);
            }
            s.sync(e, n), s.flags &= -8;
          }
          if (o = i ? i.nextSibling : r.firstChild, n && !n.written && n.node == r && o != s.dom && (n.written = true), s.dom.parentNode == r)
            for (; o && o != s.dom; )
              o = AC(o);
          else
            r.insertBefore(s.dom, o);
          i = s.dom;
        }
        for (o = i ? i.nextSibling : r.firstChild, o && n && n.node == r && (n.written = true); o; )
          o = AC(o);
      } else if (this.flags & 1)
        for (let r of this.children)
          r.flags & 7 && (r.sync(e, n), r.flags &= -8);
    }
    reuseDOM(e) {
    }
    localPosFromDOM(e, n) {
      let r;
      if (e == this.dom)
        r = this.dom.childNodes[n];
      else {
        let i = Ai(e) == 0 ? 0 : n == 0 ? -1 : 1;
        for (; ; ) {
          let o = e.parentNode;
          if (o == this.dom)
            break;
          i == 0 && o.firstChild != o.lastChild && (e == o.firstChild ? i = -1 : i = 1), e = o;
        }
        i < 0 ? r = e : r = e.nextSibling;
      }
      if (r == this.dom.firstChild)
        return 0;
      for (; r && !Qe.get(r); )
        r = r.nextSibling;
      if (!r)
        return this.length;
      for (let i = 0, o = 0; ; i++) {
        let s = this.children[i];
        if (s.dom == r)
          return o;
        o += s.length + s.breakAfter;
      }
    }
    domBoundsAround(e, n, r = 0) {
      let i = -1, o = -1, s = -1, a = -1;
      for (let l = 0, c = r, u = r; l < this.children.length; l++) {
        let h = this.children[l], p = c + h.length;
        if (c < e && p > n)
          return h.domBoundsAround(e, n, c);
        if (p >= e && i == -1 && (i = l, o = c), c > n && h.dom.parentNode == this.dom) {
          s = l, a = u;
          break;
        }
        u = p, c = p + h.breakAfter;
      }
      return {
        from: o,
        to: a < 0 ? r + this.length : a,
        startDOM: (i ? this.children[i - 1].dom.nextSibling : null) || this.dom.firstChild,
        endDOM: s < this.children.length && s >= 0 ? this.children[s].dom : null
      };
    }
    markDirty(e = false) {
      this.flags |= 2, this.markParentsDirty(e);
    }
    markParentsDirty(e) {
      for (let n = this.parent; n; n = n.parent) {
        if (e && (n.flags |= 2), n.flags & 1)
          return;
        n.flags |= 1, e = false;
      }
    }
    setParent(e) {
      this.parent != e && (this.parent = e, this.flags & 7 && this.markParentsDirty(true));
    }
    setDOM(e) {
      this.dom != e && (this.dom && (this.dom.cmView = null), this.dom = e, e.cmView = this);
    }
    get rootView() {
      for (let e = this; ; ) {
        let n = e.parent;
        if (!n)
          return e;
        e = n;
      }
    }
    replaceChildren(e, n, r = Ex) {
      this.markDirty();
      for (let i = e; i < n; i++) {
        let o = this.children[i];
        o.parent == this && r.indexOf(o) < 0 && o.destroy();
      }
      r.length < 250 ? this.children.splice(e, n - e, ...r) : this.children = [].concat(this.children.slice(0, e), r, this.children.slice(n));
      for (let i = 0; i < r.length; i++)
        r[i].setParent(this);
    }
    ignoreMutation(e) {
      return false;
    }
    ignoreEvent(e) {
      return false;
    }
    childCursor(e = this.length) {
      return new LO(this.children, e, this.children.length);
    }
    childPos(e, n = 1) {
      return this.childCursor().findPos(e, n);
    }
    toString() {
      let e = this.constructor.name.replace("View", "");
      return e + (this.children.length ? "(" + this.children.join() + ")" : this.length ? "[" + (e == "Text" ? this.text : this.length) + "]" : "") + (this.breakAfter ? "#" : "");
    }
    static get(e) {
      return e.cmView;
    }
    get isEditable() {
      return true;
    }
    get isWidget() {
      return false;
    }
    get isHidden() {
      return false;
    }
    merge(e, n, r, i, o, s) {
      return false;
    }
    become(e) {
      return false;
    }
    canReuseDOM(e) {
      return e.constructor == this.constructor && !((this.flags | e.flags) & 8);
    }
    getSide() {
      return 0;
    }
    destroy() {
      for (let e of this.children)
        e.parent == this && e.destroy();
      this.parent = null;
    }
  }
  Qe.prototype.breakAfter = 0;
  function AC(t) {
    let e = t.nextSibling;
    return t.parentNode.removeChild(t), e;
  }
  class LO {
    constructor(e, n, r) {
      this.children = e, this.pos = n, this.i = r, this.off = 0;
    }
    findPos(e, n = 1) {
      for (; ; ) {
        if (e > this.pos || e == this.pos && (n > 0 || this.i == 0 || this.children[this.i - 1].breakAfter))
          return this.off = e - this.pos, this;
        let r = this.children[--this.i];
        this.pos -= r.length + r.breakAfter;
      }
    }
  }
  function _O(t, e, n, r, i, o, s, a, l) {
    let { children: c } = t, u = c.length ? c[e] : null, h = o.length ? o[o.length - 1] : null, p = h ? h.breakAfter : s;
    if (!(e == r && u && !s && !p && o.length < 2 && u.merge(n, i, o.length ? h : null, n == 0, a, l))) {
      if (r < c.length) {
        let v = c[r];
        v && (i < v.length || v.breakAfter && (h == null ? void 0 : h.breakAfter)) ? (e == r && (v = v.split(i), i = 0), !p && h && v.merge(0, i, h, true, 0, l) ? o[o.length - 1] = v : ((i || v.children.length && !v.children[0].length) && v.merge(0, i, null, false, 0, l), o.push(v))) : (v == null ? void 0 : v.breakAfter) && (h ? h.breakAfter = 1 : s = 1), r++;
      }
      for (u && (u.breakAfter = s, n > 0 && (!s && o.length && u.merge(n, u.length, o[0], false, a, 0) ? u.breakAfter = o.shift().breakAfter : (n < u.length || u.children.length && u.children[u.children.length - 1].length == 0) && u.merge(n, u.length, null, false, a, 0), e++)); e < r && o.length; )
        if (c[r - 1].become(o[o.length - 1]))
          r--, o.pop(), l = o.length ? 0 : a;
        else if (c[e].become(o[0]))
          e++, o.shift(), a = o.length ? 0 : l;
        else
          break;
      !o.length && e && r < c.length && !c[e - 1].breakAfter && c[r].merge(0, 0, c[e - 1], false, a, l) && e--, (e < r || o.length) && t.replaceChildren(e, r, o);
    }
  }
  function DO(t, e, n, r, i, o) {
    let s = t.childCursor(), { i: a, off: l } = s.findPos(n, 1), { i: c, off: u } = s.findPos(e, -1), h = e - n;
    for (let p of r)
      h += p.length;
    t.length += h, _O(t, c, u, a, l, r, 0, i, o);
  }
  const a7 = 256;
  class Kr extends Qe {
    constructor(e) {
      super(), this.text = e;
    }
    get length() {
      return this.text.length;
    }
    createDOM(e) {
      this.setDOM(e || document.createTextNode(this.text));
    }
    sync(e, n) {
      this.dom || this.createDOM(), this.dom.nodeValue != this.text && (n && n.node == this.dom && (n.written = true), this.dom.nodeValue = this.text);
    }
    reuseDOM(e) {
      e.nodeType == 3 && this.createDOM(e);
    }
    merge(e, n, r) {
      return this.flags & 8 || r && (!(r instanceof Kr) || this.length - (n - e) + r.length > a7 || r.flags & 8) ? false : (this.text = this.text.slice(0, e) + (r ? r.text : "") + this.text.slice(n), this.markDirty(), true);
    }
    split(e) {
      let n = new Kr(this.text.slice(e));
      return this.text = this.text.slice(0, e), this.markDirty(), n.flags |= this.flags & 8, n;
    }
    localPosFromDOM(e, n) {
      return e == this.dom ? n : n ? this.text.length : 0;
    }
    domAtPos(e) {
      return new hn(this.dom, e);
    }
    domBoundsAround(e, n, r) {
      return {
        from: r,
        to: r + this.length,
        startDOM: this.dom,
        endDOM: this.dom.nextSibling
      };
    }
    coordsAt(e, n) {
      return l7(this.dom, e, n);
    }
  }
  class no extends Qe {
    constructor(e, n = [], r = 0) {
      super(), this.mark = e, this.children = n, this.length = r;
      for (let i of n)
        i.setParent(this);
    }
    setAttrs(e) {
      if (EO(e), this.mark.class && (e.className = this.mark.class), this.mark.attrs)
        for (let n in this.mark.attrs)
          e.setAttribute(n, this.mark.attrs[n]);
      return e;
    }
    canReuseDOM(e) {
      return super.canReuseDOM(e) && !((this.flags | e.flags) & 8);
    }
    reuseDOM(e) {
      e.nodeName == this.mark.tagName.toUpperCase() && (this.setDOM(e), this.flags |= 6);
    }
    sync(e, n) {
      this.dom ? this.flags & 4 && this.setAttrs(this.dom) : this.setDOM(this.setAttrs(document.createElement(this.mark.tagName))), super.sync(e, n);
    }
    merge(e, n, r, i, o, s) {
      return r && (!(r instanceof no && r.mark.eq(this.mark)) || e && o <= 0 || n < this.length && s <= 0) ? false : (DO(this, e, n, r ? r.children.slice() : [], o - 1, s - 1), this.markDirty(), true);
    }
    split(e) {
      let n = [], r = 0, i = -1, o = 0;
      for (let a of this.children) {
        let l = r + a.length;
        l > e && n.push(r < e ? a.split(e - r) : a), i < 0 && r >= e && (i = o), r = l, o++;
      }
      let s = this.length - e;
      return this.length = e, i > -1 && (this.children.length = i, this.markDirty()), new no(this.mark, n, s);
    }
    domAtPos(e) {
      return IO(this, e);
    }
    coordsAt(e, n) {
      return NO(this, e, n);
    }
  }
  function l7(t, e, n) {
    let r = t.nodeValue.length;
    e > r && (e = r);
    let i = e, o = e, s = 0;
    e == 0 && n < 0 || e == r && n >= 0 ? fe.chrome || fe.gecko || (e ? (i--, s = 1) : o < r && (o++, s = -1)) : n < 0 ? i-- : o < r && o++;
    let a = Ks(t, i, o).getClientRects();
    if (!a.length)
      return null;
    let l = a[(s ? s < 0 : n >= 0) ? 0 : a.length - 1];
    return fe.safari && !s && l.width == 0 && (l = Array.prototype.find.call(a, (c) => c.width) || l), s ? af(l, s < 0) : l || null;
  }
  class _o extends Qe {
    static create(e, n, r) {
      return new _o(e, n, r);
    }
    constructor(e, n, r) {
      super(), this.widget = e, this.length = n, this.side = r, this.prevWidget = null;
    }
    split(e) {
      let n = _o.create(this.widget, this.length - e, this.side);
      return this.length -= e, n;
    }
    sync(e) {
      (!this.dom || !this.widget.updateDOM(this.dom, e)) && (this.dom && this.prevWidget && this.prevWidget.destroy(this.dom), this.prevWidget = null, this.setDOM(this.widget.toDOM(e)), this.widget.editable || (this.dom.contentEditable = "false"));
    }
    getSide() {
      return this.side;
    }
    merge(e, n, r, i, o, s) {
      return r && (!(r instanceof _o) || !this.widget.compare(r.widget) || e > 0 && o <= 0 || n < this.length && s <= 0) ? false : (this.length = e + (r ? r.length : 0) + (this.length - n), true);
    }
    become(e) {
      return e instanceof _o && e.side == this.side && this.widget.constructor == e.widget.constructor ? (this.widget.compare(e.widget) || this.markDirty(true), this.dom && !this.prevWidget && (this.prevWidget = this.widget), this.widget = e.widget, this.length = e.length, true) : false;
    }
    ignoreMutation() {
      return true;
    }
    ignoreEvent(e) {
      return this.widget.ignoreEvent(e);
    }
    get overrideDOMText() {
      if (this.length == 0)
        return He.empty;
      let e = this;
      for (; e.parent; )
        e = e.parent;
      let { view: n } = e, r = n && n.state.doc, i = this.posAtStart;
      return r ? r.slice(i, i + this.length) : He.empty;
    }
    domAtPos(e) {
      return (this.length ? e == 0 : this.side > 0) ? hn.before(this.dom) : hn.after(this.dom, e == this.length);
    }
    domBoundsAround() {
      return null;
    }
    coordsAt(e, n) {
      let r = this.widget.coordsAt(this.dom, e, n);
      if (r)
        return r;
      let i = this.dom.getClientRects(), o = null;
      if (!i.length)
        return null;
      let s = this.side ? this.side < 0 : e > 0;
      for (let a = s ? i.length - 1 : 0; o = i[a], !(e > 0 ? a == 0 : a == i.length - 1 || o.top < o.bottom); a += s ? -1 : 1)
        ;
      return af(o, !s);
    }
    get isEditable() {
      return false;
    }
    get isWidget() {
      return true;
    }
    get isHidden() {
      return this.widget.isHidden;
    }
    destroy() {
      super.destroy(), this.dom && this.widget.destroy(this.dom);
    }
  }
  class ml extends Qe {
    constructor(e) {
      super(), this.side = e;
    }
    get length() {
      return 0;
    }
    merge() {
      return false;
    }
    become(e) {
      return e instanceof ml && e.side == this.side;
    }
    split() {
      return new ml(this.side);
    }
    sync() {
      if (!this.dom) {
        let e = document.createElement("img");
        e.className = "cm-widgetBuffer", e.setAttribute("aria-hidden", "true"), this.setDOM(e);
      }
    }
    getSide() {
      return this.side;
    }
    domAtPos(e) {
      return this.side > 0 ? hn.before(this.dom) : hn.after(this.dom);
    }
    localPosFromDOM() {
      return 0;
    }
    domBoundsAround() {
      return null;
    }
    coordsAt(e) {
      return this.dom.getBoundingClientRect();
    }
    get overrideDOMText() {
      return He.empty;
    }
    get isHidden() {
      return true;
    }
  }
  Kr.prototype.children = _o.prototype.children = ml.prototype.children = Ex;
  function IO(t, e) {
    let n = t.dom, { children: r } = t, i = 0;
    for (let o = 0; i < r.length; i++) {
      let s = r[i], a = o + s.length;
      if (!(a == o && s.getSide() <= 0)) {
        if (e > o && e < a && s.dom.parentNode == n)
          return s.domAtPos(e - o);
        if (e <= o)
          break;
        o = a;
      }
    }
    for (let o = i; o > 0; o--) {
      let s = r[o - 1];
      if (s.dom.parentNode == n)
        return s.domAtPos(s.length);
    }
    for (let o = i; o < r.length; o++) {
      let s = r[o];
      if (s.dom.parentNode == n)
        return s.domAtPos(0);
    }
    return new hn(n, 0);
  }
  function BO(t, e, n) {
    let r, { children: i } = t;
    n > 0 && e instanceof no && i.length && (r = i[i.length - 1]) instanceof no && r.mark.eq(e.mark) ? BO(r, e.children[0], n - 1) : (i.push(e), e.setParent(t)), t.length += e.length;
  }
  function NO(t, e, n) {
    let r = null, i = -1, o = null, s = -1;
    function a(c, u) {
      for (let h = 0, p = 0; h < c.children.length && p <= u; h++) {
        let v = c.children[h], y = p + v.length;
        y >= u && (v.children.length ? a(v, u - p) : (!o || o.isHidden && (n > 0 || u7(o, v))) && (y > u || p == y && v.getSide() > 0) ? (o = v, s = u - p) : (p < u || p == y && v.getSide() < 0 && !v.isHidden) && (r = v, i = u - p)), p = y;
      }
    }
    a(t, e);
    let l = (n < 0 ? r : o) || r || o;
    return l ? l.coordsAt(Math.max(0, l == r ? i : s), n) : c7(t);
  }
  function c7(t) {
    let e = t.dom.lastChild;
    if (!e)
      return t.dom.getBoundingClientRect();
    let n = pl(e);
    return n[n.length - 1] || null;
  }
  function u7(t, e) {
    let n = t.coordsAt(0, 1), r = e.coordsAt(0, 1);
    return n && r && r.top < n.bottom;
  }
  function Zy(t, e) {
    for (let n in t)
      n == "class" && e.class ? e.class += " " + t.class : n == "style" && e.style ? e.style += ";" + t.style : e[n] = t[n];
    return e;
  }
  const EC = /* @__PURE__ */ Object.create(null);
  function wp(t, e, n) {
    if (t == e)
      return true;
    t || (t = EC), e || (e = EC);
    let r = Object.keys(t), i = Object.keys(e);
    if (r.length - (n && r.indexOf(n) > -1 ? 1 : 0) != i.length - (n && i.indexOf(n) > -1 ? 1 : 0))
      return false;
    for (let o of r)
      if (o != n && (i.indexOf(o) == -1 || t[o] !== e[o]))
        return false;
    return true;
  }
  function e1(t, e, n) {
    let r = false;
    if (e)
      for (let i in e)
        n && i in n || (r = true, i == "style" ? t.style.cssText = "" : t.removeAttribute(i));
    if (n)
      for (let i in n)
        e && e[i] == n[i] || (r = true, i == "style" ? t.style.cssText = n[i] : t.setAttribute(i, n[i]));
    return r;
  }
  function f7(t) {
    let e = /* @__PURE__ */ Object.create(null);
    for (let n = 0; n < t.attributes.length; n++) {
      let r = t.attributes[n];
      e[r.name] = r.value;
    }
    return e;
  }
  class oo {
    eq(e) {
      return false;
    }
    updateDOM(e, n) {
      return false;
    }
    compare(e) {
      return this == e || this.constructor == e.constructor && this.eq(e);
    }
    get estimatedHeight() {
      return -1;
    }
    get lineBreaks() {
      return 0;
    }
    ignoreEvent(e) {
      return true;
    }
    coordsAt(e, n, r) {
      return null;
    }
    get isHidden() {
      return false;
    }
    get editable() {
      return false;
    }
    destroy(e) {
    }
  }
  var Cn = function(t) {
    return t[t.Text = 0] = "Text", t[t.WidgetBefore = 1] = "WidgetBefore", t[t.WidgetAfter = 2] = "WidgetAfter", t[t.WidgetRange = 3] = "WidgetRange", t;
  }(Cn || (Cn = {}));
  class be extends Ws {
    constructor(e, n, r, i) {
      super(), this.startSide = e, this.endSide = n, this.widget = r, this.spec = i;
    }
    get heightRelevant() {
      return false;
    }
    static mark(e) {
      return new lf(e);
    }
    static widget(e) {
      let n = Math.max(-1e4, Math.min(1e4, e.side || 0)), r = !!e.block;
      return n += r && !e.inlineOrder ? n > 0 ? 3e8 : -4e8 : n > 0 ? 1e8 : -1e8, new Yo(e, n, n, r, e.widget || null, false);
    }
    static replace(e) {
      let n = !!e.block, r, i;
      if (e.isBlockGap)
        r = -5e8, i = 4e8;
      else {
        let { start: o, end: s } = $O(e, n);
        r = (o ? n ? -3e8 : -1 : 5e8) - 1, i = (s ? n ? 2e8 : 1 : -6e8) + 1;
      }
      return new Yo(e, r, i, n, e.widget || null, true);
    }
    static line(e) {
      return new cf(e);
    }
    static set(e, n = false) {
      return Ve.of(e, n);
    }
    hasHeight() {
      return this.widget ? this.widget.estimatedHeight > -1 : false;
    }
  }
  be.none = Ve.empty;
  class lf extends be {
    constructor(e) {
      let { start: n, end: r } = $O(e);
      super(n ? -1 : 5e8, r ? 1 : -6e8, null, e), this.tagName = e.tagName || "span", this.class = e.class || "", this.attrs = e.attributes || null;
    }
    eq(e) {
      var n, r;
      return this == e || e instanceof lf && this.tagName == e.tagName && (this.class || ((n = this.attrs) === null || n === void 0 ? void 0 : n.class)) == (e.class || ((r = e.attrs) === null || r === void 0 ? void 0 : r.class)) && wp(this.attrs, e.attrs, "class");
    }
    range(e, n = e) {
      if (e >= n)
        throw new RangeError("Mark decorations may not be empty");
      return super.range(e, n);
    }
  }
  lf.prototype.point = false;
  class cf extends be {
    constructor(e) {
      super(-2e8, -2e8, null, e);
    }
    eq(e) {
      return e instanceof cf && this.spec.class == e.spec.class && wp(this.spec.attributes, e.spec.attributes);
    }
    range(e, n = e) {
      if (n != e)
        throw new RangeError("Line decoration ranges must be zero-length");
      return super.range(e, n);
    }
  }
  cf.prototype.mapMode = Zt.TrackBefore;
  cf.prototype.point = true;
  class Yo extends be {
    constructor(e, n, r, i, o, s) {
      super(n, r, o, e), this.block = i, this.isReplace = s, this.mapMode = i ? n <= 0 ? Zt.TrackBefore : Zt.TrackAfter : Zt.TrackDel;
    }
    get type() {
      return this.startSide != this.endSide ? Cn.WidgetRange : this.startSide <= 0 ? Cn.WidgetBefore : Cn.WidgetAfter;
    }
    get heightRelevant() {
      return this.block || !!this.widget && (this.widget.estimatedHeight >= 5 || this.widget.lineBreaks > 0);
    }
    eq(e) {
      return e instanceof Yo && h7(this.widget, e.widget) && this.block == e.block && this.startSide == e.startSide && this.endSide == e.endSide;
    }
    range(e, n = e) {
      if (this.isReplace && (e > n || e == n && this.startSide > 0 && this.endSide <= 0))
        throw new RangeError("Invalid range for replacement decoration");
      if (!this.isReplace && n != e)
        throw new RangeError("Widget decorations can only have zero-length ranges");
      return super.range(e, n);
    }
  }
  Yo.prototype.point = true;
  function $O(t, e = false) {
    let { inclusiveStart: n, inclusiveEnd: r } = t;
    return n == null && (n = t.inclusive), r == null && (r = t.inclusive), {
      start: n ?? e,
      end: r ?? e
    };
  }
  function h7(t, e) {
    return t == e || !!(t && e && t.compare(e));
  }
  function kd(t, e, n, r = 0) {
    let i = n.length - 1;
    i >= 0 && n[i] + r >= t ? n[i] = Math.max(n[i], e) : n.push(t, e);
  }
  class Pt extends Qe {
    constructor() {
      super(...arguments), this.children = [], this.length = 0, this.prevAttrs = void 0, this.attrs = null, this.breakAfter = 0;
    }
    merge(e, n, r, i, o, s) {
      if (r) {
        if (!(r instanceof Pt))
          return false;
        this.dom || r.transferDOM(this);
      }
      return i && this.setDeco(r ? r.attrs : null), DO(this, e, n, r ? r.children.slice() : [], o, s), true;
    }
    split(e) {
      let n = new Pt();
      if (n.breakAfter = this.breakAfter, this.length == 0)
        return n;
      let { i: r, off: i } = this.childPos(e);
      i && (n.append(this.children[r].split(i), 0), this.children[r].merge(i, this.children[r].length, null, false, 0, 0), r++);
      for (let o = r; o < this.children.length; o++)
        n.append(this.children[o], 0);
      for (; r > 0 && this.children[r - 1].length == 0; )
        this.children[--r].destroy();
      return this.children.length = r, this.markDirty(), this.length = e, n;
    }
    transferDOM(e) {
      !this.dom || (this.markDirty(), e.setDOM(this.dom), e.prevAttrs = this.prevAttrs === void 0 ? this.attrs : this.prevAttrs, this.prevAttrs = void 0, this.dom = null);
    }
    setDeco(e) {
      wp(this.attrs, e) || (this.dom && (this.prevAttrs = this.attrs, this.markDirty()), this.attrs = e);
    }
    append(e, n) {
      BO(this, e, n);
    }
    addLineDeco(e) {
      let n = e.spec.attributes, r = e.spec.class;
      n && (this.attrs = Zy(n, this.attrs || {})), r && (this.attrs = Zy({
        class: r
      }, this.attrs || {}));
    }
    domAtPos(e) {
      return IO(this, e);
    }
    reuseDOM(e) {
      e.nodeName == "DIV" && (this.setDOM(e), this.flags |= 6);
    }
    sync(e, n) {
      var r;
      this.dom ? this.flags & 4 && (EO(this.dom), this.dom.className = "cm-line", this.prevAttrs = this.attrs ? null : void 0) : (this.setDOM(document.createElement("div")), this.dom.className = "cm-line", this.prevAttrs = this.attrs ? null : void 0), this.prevAttrs !== void 0 && (e1(this.dom, this.prevAttrs, this.attrs), this.dom.classList.add("cm-line"), this.prevAttrs = void 0), super.sync(e, n);
      let i = this.dom.lastChild;
      for (; i && Qe.get(i) instanceof no; )
        i = i.lastChild;
      if (!i || !this.length || i.nodeName != "BR" && ((r = Qe.get(i)) === null || r === void 0 ? void 0 : r.isEditable) == false && (!fe.ios || !this.children.some((o) => o instanceof Kr))) {
        let o = document.createElement("BR");
        o.cmIgnore = true, this.dom.appendChild(o);
      }
    }
    measureTextSize() {
      if (this.children.length == 0 || this.length > 20)
        return null;
      let e = 0, n;
      for (let r of this.children) {
        if (!(r instanceof Kr) || /[^ -~]/.test(r.text))
          return null;
        let i = pl(r.dom);
        if (i.length != 1)
          return null;
        e += i[0].width, n = i[0].height;
      }
      return e ? {
        lineHeight: this.dom.getBoundingClientRect().height,
        charWidth: e / this.length,
        textHeight: n
      } : null;
    }
    coordsAt(e, n) {
      let r = NO(this, e, n);
      if (!this.children.length && r && this.parent) {
        let { heightOracle: i } = this.parent.view.viewState, o = r.bottom - r.top;
        if (Math.abs(o - i.lineHeight) < 2 && i.textHeight < o) {
          let s = (o - i.textHeight) / 2;
          return {
            top: r.top + s,
            bottom: r.bottom - s,
            left: r.left,
            right: r.left
          };
        }
      }
      return r;
    }
    become(e) {
      return e instanceof Pt && this.children.length == 0 && e.children.length == 0 && wp(this.attrs, e.attrs) && this.breakAfter == e.breakAfter;
    }
    covers() {
      return true;
    }
    static find(e, n) {
      for (let r = 0, i = 0; r < e.children.length; r++) {
        let o = e.children[r], s = i + o.length;
        if (s >= n) {
          if (o instanceof Pt)
            return o;
          if (s > n)
            break;
        }
        i = s + o.breakAfter;
      }
      return null;
    }
  }
  class qi extends Qe {
    constructor(e, n, r) {
      super(), this.widget = e, this.length = n, this.deco = r, this.breakAfter = 0, this.prevWidget = null;
    }
    merge(e, n, r, i, o, s) {
      return r && (!(r instanceof qi) || !this.widget.compare(r.widget) || e > 0 && o <= 0 || n < this.length && s <= 0) ? false : (this.length = e + (r ? r.length : 0) + (this.length - n), true);
    }
    domAtPos(e) {
      return e == 0 ? hn.before(this.dom) : hn.after(this.dom, e == this.length);
    }
    split(e) {
      let n = this.length - e;
      this.length = e;
      let r = new qi(this.widget, n, this.deco);
      return r.breakAfter = this.breakAfter, r;
    }
    get children() {
      return Ex;
    }
    sync(e) {
      (!this.dom || !this.widget.updateDOM(this.dom, e)) && (this.dom && this.prevWidget && this.prevWidget.destroy(this.dom), this.prevWidget = null, this.setDOM(this.widget.toDOM(e)), this.widget.editable || (this.dom.contentEditable = "false"));
    }
    get overrideDOMText() {
      return this.parent ? this.parent.view.state.doc.slice(this.posAtStart, this.posAtEnd) : He.empty;
    }
    domBoundsAround() {
      return null;
    }
    become(e) {
      return e instanceof qi && e.widget.constructor == this.widget.constructor ? (e.widget.compare(this.widget) || this.markDirty(true), this.dom && !this.prevWidget && (this.prevWidget = this.widget), this.widget = e.widget, this.length = e.length, this.deco = e.deco, this.breakAfter = e.breakAfter, true) : false;
    }
    ignoreMutation() {
      return true;
    }
    ignoreEvent(e) {
      return this.widget.ignoreEvent(e);
    }
    get isEditable() {
      return false;
    }
    get isWidget() {
      return true;
    }
    coordsAt(e, n) {
      let r = this.widget.coordsAt(this.dom, e, n);
      return r || (this.widget instanceof t1 ? null : af(this.dom.getBoundingClientRect(), this.length ? e == 0 : n <= 0));
    }
    destroy() {
      super.destroy(), this.dom && this.widget.destroy(this.dom);
    }
    covers(e) {
      let { startSide: n, endSide: r } = this.deco;
      return n == r ? false : e < 0 ? n < 0 : r > 0;
    }
  }
  class t1 extends oo {
    constructor(e) {
      super(), this.height = e;
    }
    toDOM() {
      let e = document.createElement("div");
      return e.className = "cm-gap", this.updateDOM(e), e;
    }
    eq(e) {
      return e.height == this.height;
    }
    updateDOM(e) {
      return e.style.height = this.height + "px", true;
    }
    get editable() {
      return true;
    }
    get estimatedHeight() {
      return this.height;
    }
    ignoreEvent() {
      return false;
    }
  }
  class Jc {
    constructor(e, n, r, i) {
      this.doc = e, this.pos = n, this.end = r, this.disallowBlockEffectsFor = i, this.content = [], this.curLine = null, this.breakAtStart = 0, this.pendingBuffer = 0, this.bufferMarks = [], this.atCursorPos = true, this.openStart = -1, this.openEnd = -1, this.text = "", this.textOff = 0, this.cursor = e.iter(), this.skip = n;
    }
    posCovered() {
      if (this.content.length == 0)
        return !this.breakAtStart && this.doc.lineAt(this.pos).from != this.pos;
      let e = this.content[this.content.length - 1];
      return !(e.breakAfter || e instanceof qi && e.deco.endSide < 0);
    }
    getLine() {
      return this.curLine || (this.content.push(this.curLine = new Pt()), this.atCursorPos = true), this.curLine;
    }
    flushBuffer(e = this.bufferMarks) {
      this.pendingBuffer && (this.curLine.append(Ch(new ml(-1), e), e.length), this.pendingBuffer = 0);
    }
    addBlockWidget(e) {
      this.flushBuffer(), this.curLine = null, this.content.push(e);
    }
    finish(e) {
      this.pendingBuffer && e <= this.bufferMarks.length ? this.flushBuffer() : this.pendingBuffer = 0, !this.posCovered() && !(e && this.content.length && this.content[this.content.length - 1] instanceof qi) && this.getLine();
    }
    buildText(e, n, r) {
      for (; e > 0; ) {
        if (this.textOff == this.text.length) {
          let { value: s, lineBreak: a, done: l } = this.cursor.next(this.skip);
          if (this.skip = 0, l)
            throw new Error("Ran out of text content when drawing inline views");
          if (a) {
            this.posCovered() || this.getLine(), this.content.length ? this.content[this.content.length - 1].breakAfter = 1 : this.breakAtStart = 1, this.flushBuffer(), this.curLine = null, this.atCursorPos = true, e--;
            continue;
          } else
            this.text = s, this.textOff = 0;
        }
        let i = Math.min(this.text.length - this.textOff, e), o = Math.min(i, 512);
        this.flushBuffer(n.slice(n.length - r)), this.getLine().append(Ch(new Kr(this.text.slice(this.textOff, this.textOff + o)), n), r), this.atCursorPos = true, this.textOff += o, e -= o, r = i <= o ? 0 : n.length;
      }
    }
    span(e, n, r, i) {
      this.buildText(n - e, r, i), this.pos = n, this.openStart < 0 && (this.openStart = i);
    }
    point(e, n, r, i, o, s) {
      if (this.disallowBlockEffectsFor[s] && r instanceof Yo) {
        if (r.block)
          throw new RangeError("Block decorations may not be specified via plugins");
        if (n > this.doc.lineAt(this.pos).to)
          throw new RangeError("Decorations that replace line breaks may not be specified via plugins");
      }
      let a = n - e;
      if (r instanceof Yo)
        if (r.block)
          r.startSide > 0 && !this.posCovered() && this.getLine(), this.addBlockWidget(new qi(r.widget || gl.block, a, r));
        else {
          let l = _o.create(r.widget || gl.inline, a, a ? 0 : r.startSide), c = this.atCursorPos && !l.isEditable && o <= i.length && (e < n || r.startSide > 0), u = !l.isEditable && (e < n || o > i.length || r.startSide <= 0), h = this.getLine();
          this.pendingBuffer == 2 && !c && !l.isEditable && (this.pendingBuffer = 0), this.flushBuffer(i), c && (h.append(Ch(new ml(1), i), o), o = i.length + Math.max(0, o - i.length)), h.append(Ch(l, i), o), this.atCursorPos = u, this.pendingBuffer = u ? e < n || o > i.length ? 1 : 2 : 0, this.pendingBuffer && (this.bufferMarks = i.slice());
        }
      else
        this.doc.lineAt(this.pos).from == this.pos && this.getLine().addLineDeco(r);
      a && (this.textOff + a <= this.text.length ? this.textOff += a : (this.skip += a - (this.text.length - this.textOff), this.text = "", this.textOff = 0), this.pos = n), this.openStart < 0 && (this.openStart = o);
    }
    static build(e, n, r, i, o) {
      let s = new Jc(e, n, r, o);
      return s.openEnd = Ve.spans(i, n, r, s), s.openStart < 0 && (s.openStart = s.openEnd), s.finish(s.openEnd), s;
    }
  }
  function Ch(t, e) {
    for (let n of e)
      t = new no(n, [
        t
      ], t.length);
    return t;
  }
  class gl extends oo {
    constructor(e) {
      super(), this.tag = e;
    }
    eq(e) {
      return e.tag == this.tag;
    }
    toDOM() {
      return document.createElement(this.tag);
    }
    updateDOM(e) {
      return e.nodeName.toLowerCase() == this.tag;
    }
    get isHidden() {
      return true;
    }
  }
  gl.inline = new gl("span");
  gl.block = new gl("div");
  var rt = function(t) {
    return t[t.LTR = 0] = "LTR", t[t.RTL = 1] = "RTL", t;
  }(rt || (rt = {}));
  const qs = rt.LTR, Px = rt.RTL;
  function zO(t) {
    let e = [];
    for (let n = 0; n < t.length; n++)
      e.push(1 << +t[n]);
    return e;
  }
  const d7 = zO("88888888888888888888888888888888888666888888787833333333337888888000000000000000000000000008888880000000000000000000000000088888888888888888888888888888888888887866668888088888663380888308888800000000000000000000000800000000000000000000000000000008"), p7 = zO("4444448826627288999999999992222222222222222222222222222222222222222222222229999999999999999999994444444444644222822222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222999999949999999229989999223333333333"), n1 = /* @__PURE__ */ Object.create(null), ri = [];
  for (let t of [
    "()",
    "[]",
    "{}"
  ]) {
    let e = t.charCodeAt(0), n = t.charCodeAt(1);
    n1[e] = n, n1[n] = -e;
  }
  function FO(t) {
    return t <= 247 ? d7[t] : 1424 <= t && t <= 1524 ? 2 : 1536 <= t && t <= 1785 ? p7[t - 1536] : 1774 <= t && t <= 2220 ? 4 : 8192 <= t && t <= 8204 ? 256 : 64336 <= t && t <= 65023 ? 4 : 1;
  }
  const m7 = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac\ufb50-\ufdff]/;
  class Do {
    get dir() {
      return this.level % 2 ? Px : qs;
    }
    constructor(e, n, r) {
      this.from = e, this.to = n, this.level = r;
    }
    side(e, n) {
      return this.dir == n == e ? this.to : this.from;
    }
    forward(e, n) {
      return e == (this.dir == n);
    }
    static find(e, n, r, i) {
      let o = -1;
      for (let s = 0; s < e.length; s++) {
        let a = e[s];
        if (a.from <= n && a.to >= n) {
          if (a.level == r)
            return s;
          (o < 0 || (i != 0 ? i < 0 ? a.from < n : a.to > n : e[o].level > a.level)) && (o = s);
        }
      }
      if (o < 0)
        throw new RangeError("Index out of range");
      return o;
    }
  }
  function VO(t, e) {
    if (t.length != e.length)
      return false;
    for (let n = 0; n < t.length; n++) {
      let r = t[n], i = e[n];
      if (r.from != i.from || r.to != i.to || r.direction != i.direction || !VO(r.inner, i.inner))
        return false;
    }
    return true;
  }
  const Ze = [];
  function g7(t, e, n, r, i) {
    for (let o = 0; o <= r.length; o++) {
      let s = o ? r[o - 1].to : e, a = o < r.length ? r[o].from : n, l = o ? 256 : i;
      for (let c = s, u = l, h = l; c < a; c++) {
        let p = FO(t.charCodeAt(c));
        p == 512 ? p = u : p == 8 && h == 4 && (p = 16), Ze[c] = p == 4 ? 2 : p, p & 7 && (h = p), u = p;
      }
      for (let c = s, u = l, h = l; c < a; c++) {
        let p = Ze[c];
        if (p == 128)
          c < a - 1 && u == Ze[c + 1] && u & 24 ? p = Ze[c] = u : Ze[c] = 256;
        else if (p == 64) {
          let v = c + 1;
          for (; v < a && Ze[v] == 64; )
            v++;
          let y = c && u == 8 || v < n && Ze[v] == 8 ? h == 1 ? 1 : 8 : 256;
          for (let x = c; x < v; x++)
            Ze[x] = y;
          c = v - 1;
        } else
          p == 8 && h == 1 && (Ze[c] = 1);
        u = p, p & 7 && (h = p);
      }
    }
  }
  function v7(t, e, n, r, i) {
    let o = i == 1 ? 2 : 1;
    for (let s = 0, a = 0, l = 0; s <= r.length; s++) {
      let c = s ? r[s - 1].to : e, u = s < r.length ? r[s].from : n;
      for (let h = c, p, v, y; h < u; h++)
        if (v = n1[p = t.charCodeAt(h)])
          if (v < 0) {
            for (let x = a - 3; x >= 0; x -= 3)
              if (ri[x + 1] == -v) {
                let T = ri[x + 2], w = T & 2 ? i : T & 4 ? T & 1 ? o : i : 0;
                w && (Ze[h] = Ze[ri[x]] = w), a = x;
                break;
              }
          } else {
            if (ri.length == 189)
              break;
            ri[a++] = h, ri[a++] = p, ri[a++] = l;
          }
        else if ((y = Ze[h]) == 2 || y == 1) {
          let x = y == i;
          l = x ? 0 : 1;
          for (let T = a - 3; T >= 0; T -= 3) {
            let w = ri[T + 2];
            if (w & 2)
              break;
            if (x)
              ri[T + 2] |= 2;
            else {
              if (w & 4)
                break;
              ri[T + 2] |= 4;
            }
          }
        }
    }
  }
  function y7(t, e, n, r) {
    for (let i = 0, o = r; i <= n.length; i++) {
      let s = i ? n[i - 1].to : t, a = i < n.length ? n[i].from : e;
      for (let l = s; l < a; ) {
        let c = Ze[l];
        if (c == 256) {
          let u = l + 1;
          for (; ; )
            if (u == a) {
              if (i == n.length)
                break;
              u = n[i++].to, a = i < n.length ? n[i].from : e;
            } else if (Ze[u] == 256)
              u++;
            else
              break;
          let h = o == 1, p = (u < e ? Ze[u] : r) == 1, v = h == p ? h ? 1 : 2 : r;
          for (let y = u, x = i, T = x ? n[x - 1].to : t; y > l; )
            y == T && (y = n[--x].from, T = x ? n[x - 1].to : t), Ze[--y] = v;
          l = u;
        } else
          o = c, l++;
      }
    }
  }
  function r1(t, e, n, r, i, o, s) {
    let a = r % 2 ? 2 : 1;
    if (r % 2 == i % 2)
      for (let l = e, c = 0; l < n; ) {
        let u = true, h = false;
        if (c == o.length || l < o[c].from) {
          let x = Ze[l];
          x != a && (u = false, h = x == 16);
        }
        let p = !u && a == 1 ? [] : null, v = u ? r : r + 1, y = l;
        e:
          for (; ; )
            if (c < o.length && y == o[c].from) {
              if (h)
                break e;
              let x = o[c];
              if (!u)
                for (let T = x.to, w = c + 1; ; ) {
                  if (T == n)
                    break e;
                  if (w < o.length && o[w].from == T)
                    T = o[w++].to;
                  else {
                    if (Ze[T] == a)
                      break e;
                    break;
                  }
                }
              if (c++, p)
                p.push(x);
              else {
                x.from > l && s.push(new Do(l, x.from, v));
                let T = x.direction == qs != !(v % 2);
                i1(t, T ? r + 1 : r, i, x.inner, x.from, x.to, s), l = x.to;
              }
              y = x.to;
            } else {
              if (y == n || (u ? Ze[y] != a : Ze[y] == a))
                break;
              y++;
            }
        p ? r1(t, l, y, r + 1, i, p, s) : l < y && s.push(new Do(l, y, v)), l = y;
      }
    else
      for (let l = n, c = o.length; l > e; ) {
        let u = true, h = false;
        if (!c || l > o[c - 1].to) {
          let x = Ze[l - 1];
          x != a && (u = false, h = x == 16);
        }
        let p = !u && a == 1 ? [] : null, v = u ? r : r + 1, y = l;
        e:
          for (; ; )
            if (c && y == o[c - 1].to) {
              if (h)
                break e;
              let x = o[--c];
              if (!u)
                for (let T = x.from, w = c; ; ) {
                  if (T == e)
                    break e;
                  if (w && o[w - 1].to == T)
                    T = o[--w].from;
                  else {
                    if (Ze[T - 1] == a)
                      break e;
                    break;
                  }
                }
              if (p)
                p.push(x);
              else {
                x.to < l && s.push(new Do(x.to, l, v));
                let T = x.direction == qs != !(v % 2);
                i1(t, T ? r + 1 : r, i, x.inner, x.from, x.to, s), l = x.from;
              }
              y = x.from;
            } else {
              if (y == e || (u ? Ze[y - 1] != a : Ze[y - 1] == a))
                break;
              y--;
            }
        p ? r1(t, y, l, r + 1, i, p, s) : y < l && s.push(new Do(y, l, v)), l = y;
      }
  }
  function i1(t, e, n, r, i, o, s) {
    let a = e % 2 ? 2 : 1;
    g7(t, i, o, r, a), v7(t, i, o, r, a), y7(i, o, r, a), r1(t, i, o, e, n, r, s);
  }
  function b7(t, e, n) {
    if (!t)
      return [
        new Do(0, 0, e == Px ? 1 : 0)
      ];
    if (e == qs && !n.length && !m7.test(t))
      return HO(t.length);
    if (n.length)
      for (; t.length > Ze.length; )
        Ze[Ze.length] = 256;
    let r = [], i = e == qs ? 0 : 1;
    return i1(t, i, i, n, 0, t.length, r), r;
  }
  function HO(t) {
    return [
      new Do(0, t, 0)
    ];
  }
  let jO = "";
  function x7(t, e, n, r, i) {
    var o;
    let s = r.head - t.from, a = Do.find(e, s, (o = r.bidiLevel) !== null && o !== void 0 ? o : -1, r.assoc), l = e[a], c = l.side(i, n);
    if (s == c) {
      let p = a += i ? 1 : -1;
      if (p < 0 || p >= e.length)
        return null;
      l = e[a = p], s = l.side(!i, n), c = l.side(i, n);
    }
    let u = en(t.text, s, l.forward(i, n));
    (u < l.from || u > l.to) && (u = c), jO = t.text.slice(Math.min(s, u), Math.max(s, u));
    let h = a == (i ? e.length - 1 : 0) ? null : e[a + (i ? 1 : -1)];
    return h && u == c && h.level + (i ? 0 : 1) < l.level ? q.cursor(h.side(!i, n) + t.from, h.forward(i, n) ? 1 : -1, h.level) : q.cursor(u + t.from, l.forward(i, n) ? -1 : 1, l.level);
  }
  function S7(t, e, n) {
    for (let r = e; r < n; r++) {
      let i = FO(t.charCodeAt(r));
      if (i == 1)
        return qs;
      if (i == 2 || i == 4)
        return Px;
    }
    return qs;
  }
  const WO = me.define(), UO = me.define(), KO = me.define(), qO = me.define(), o1 = me.define(), GO = me.define(), YO = me.define(), Ox = me.define(), Rx = me.define(), XO = me.define({
    combine: (t) => t.some((e) => e)
  }), QO = me.define({
    combine: (t) => t.some((e) => e)
  }), JO = me.define();
  class Qa {
    constructor(e, n = "nearest", r = "nearest", i = 5, o = 5, s = false) {
      this.range = e, this.y = n, this.x = r, this.yMargin = i, this.xMargin = o, this.isSnapshot = s;
    }
    map(e) {
      return e.empty ? this : new Qa(this.range.map(e), this.y, this.x, this.yMargin, this.xMargin, this.isSnapshot);
    }
    clip(e) {
      return this.range.to <= e.doc.length ? this : new Qa(q.cursor(e.doc.length), this.y, this.x, this.yMargin, this.xMargin, this.isSnapshot);
    }
  }
  const Th = Ee.define({
    map: (t, e) => t.map(e)
  }), ZO = Ee.define();
  function Bn(t, e, n) {
    let r = t.facet(qO);
    r.length ? r[0](e) : window.onerror && window.onerror(String(e), n, void 0, void 0, e) || (n ? console.error(n + ":", e) : console.error(e));
  }
  const Vi = me.define({
    combine: (t) => t.length ? t[0] : true
  });
  let w7 = 0;
  const _a = me.define({
    combine(t) {
      return t.filter((e, n) => {
        for (let r = 0; r < n; r++)
          if (t[r].plugin == e.plugin)
            return false;
        return true;
      });
    }
  });
  class Ct {
    constructor(e, n, r, i, o) {
      this.id = e, this.create = n, this.domEventHandlers = r, this.domEventObservers = i, this.baseExtensions = o(this), this.extension = this.baseExtensions.concat(_a.of({
        plugin: this,
        arg: void 0
      }));
    }
    of(e) {
      return this.baseExtensions.concat(_a.of({
        plugin: this,
        arg: e
      }));
    }
    static define(e, n) {
      const { eventHandlers: r, eventObservers: i, provide: o, decorations: s } = n || {};
      return new Ct(w7++, e, r, i, (a) => {
        let l = [];
        return s && l.push($u.of((c) => {
          let u = c.plugin(a);
          return u ? s(u) : be.none;
        })), o && l.push(o(a)), l;
      });
    }
    static fromClass(e, n) {
      return Ct.define((r, i) => new e(r, i), n);
    }
  }
  class _0 {
    constructor(e) {
      this.spec = e, this.mustUpdate = null, this.value = null;
    }
    get plugin() {
      return this.spec && this.spec.plugin;
    }
    update(e) {
      if (this.value) {
        if (this.mustUpdate) {
          let n = this.mustUpdate;
          if (this.mustUpdate = null, this.value.update)
            try {
              this.value.update(n);
            } catch (r) {
              if (Bn(n.state, r, "CodeMirror plugin crashed"), this.value.destroy)
                try {
                  this.value.destroy();
                } catch {
                }
              this.deactivate();
            }
        }
      } else if (this.spec)
        try {
          this.value = this.spec.plugin.create(e, this.spec.arg);
        } catch (n) {
          Bn(e.state, n, "CodeMirror plugin crashed"), this.deactivate();
        }
      return this;
    }
    destroy(e) {
      var n;
      if (!((n = this.value) === null || n === void 0) && n.destroy)
        try {
          this.value.destroy();
        } catch (r) {
          Bn(e.state, r, "CodeMirror plugin crashed");
        }
    }
    deactivate() {
      this.spec = this.value = null;
    }
  }
  const eR = me.define(), Lx = me.define(), $u = me.define(), tR = me.define(), uf = me.define(), nR = me.define();
  function PC(t, e) {
    let n = t.state.facet(nR);
    if (!n.length)
      return n;
    let r = n.map((o) => o instanceof Function ? o(t) : o), i = [];
    return Ve.spans(r, e.from, e.to, {
      point() {
      },
      span(o, s, a, l) {
        let c = o - e.from, u = s - e.from, h = i;
        for (let p = a.length - 1; p >= 0; p--, l--) {
          let v = a[p].spec.bidiIsolate, y;
          if (v == null && (v = S7(e.text, c, u)), l > 0 && h.length && (y = h[h.length - 1]).to == c && y.direction == v)
            y.to = u, h = y.inner;
          else {
            let x = {
              from: c,
              to: u,
              direction: v,
              inner: []
            };
            h.push(x), h = x.inner;
          }
        }
      }
    }), i;
  }
  const rR = me.define();
  function _x(t) {
    let e = 0, n = 0, r = 0, i = 0;
    for (let o of t.state.facet(rR)) {
      let s = o(t);
      s && (s.left != null && (e = Math.max(e, s.left)), s.right != null && (n = Math.max(n, s.right)), s.top != null && (r = Math.max(r, s.top)), s.bottom != null && (i = Math.max(i, s.bottom)));
    }
    return {
      left: e,
      right: n,
      top: r,
      bottom: i
    };
  }
  const xc = me.define();
  class xr {
    constructor(e, n, r, i) {
      this.fromA = e, this.toA = n, this.fromB = r, this.toB = i;
    }
    join(e) {
      return new xr(Math.min(this.fromA, e.fromA), Math.max(this.toA, e.toA), Math.min(this.fromB, e.fromB), Math.max(this.toB, e.toB));
    }
    addToSet(e) {
      let n = e.length, r = this;
      for (; n > 0; n--) {
        let i = e[n - 1];
        if (!(i.fromA > r.toA)) {
          if (i.toA < r.fromA)
            break;
          r = r.join(i), e.splice(n - 1, 1);
        }
      }
      return e.splice(n, 0, r), e;
    }
    static extendWithRanges(e, n) {
      if (n.length == 0)
        return e;
      let r = [];
      for (let i = 0, o = 0, s = 0, a = 0; ; i++) {
        let l = i == e.length ? null : e[i], c = s - a, u = l ? l.fromB : 1e9;
        for (; o < n.length && n[o] < u; ) {
          let h = n[o], p = n[o + 1], v = Math.max(a, h), y = Math.min(u, p);
          if (v <= y && new xr(v + c, y + c, v, y).addToSet(r), p > u)
            break;
          o += 2;
        }
        if (!l)
          return r;
        new xr(l.fromA, l.toA, l.fromB, l.toB).addToSet(r), s = l.toA, a = l.toB;
      }
    }
  }
  class kp {
    constructor(e, n, r) {
      this.view = e, this.state = n, this.transactions = r, this.flags = 0, this.startState = e.state, this.changes = Dt.empty(this.startState.doc.length);
      for (let o of r)
        this.changes = this.changes.compose(o.changes);
      let i = [];
      this.changes.iterChangedRanges((o, s, a, l) => i.push(new xr(o, s, a, l))), this.changedRanges = i;
    }
    static create(e, n, r) {
      return new kp(e, n, r);
    }
    get viewportChanged() {
      return (this.flags & 4) > 0;
    }
    get viewportMoved() {
      return (this.flags & 8) > 0;
    }
    get heightChanged() {
      return (this.flags & 2) > 0;
    }
    get geometryChanged() {
      return this.docChanged || (this.flags & 18) > 0;
    }
    get focusChanged() {
      return (this.flags & 1) > 0;
    }
    get docChanged() {
      return !this.changes.empty;
    }
    get selectionSet() {
      return this.transactions.some((e) => e.selection);
    }
    get empty() {
      return this.flags == 0 && this.transactions.length == 0;
    }
  }
  class OC extends Qe {
    get length() {
      return this.view.state.doc.length;
    }
    constructor(e) {
      super(), this.view = e, this.decorations = [], this.dynamicDecorationMap = [
        false
      ], this.domChanged = null, this.hasComposition = null, this.markedForComposition = /* @__PURE__ */ new Set(), this.editContextFormatting = be.none, this.lastCompositionAfterCursor = false, this.minWidth = 0, this.minWidthFrom = 0, this.minWidthTo = 0, this.impreciseAnchor = null, this.impreciseHead = null, this.forceSelection = false, this.lastUpdate = Date.now(), this.setDOM(e.contentDOM), this.children = [
        new Pt()
      ], this.children[0].setParent(this), this.updateDeco(), this.updateInner([
        new xr(0, 0, 0, e.state.doc.length)
      ], 0, null);
    }
    update(e) {
      var n;
      let r = e.changedRanges;
      this.minWidth > 0 && r.length && (r.every(({ fromA: c, toA: u }) => u < this.minWidthFrom || c > this.minWidthTo) ? (this.minWidthFrom = e.changes.mapPos(this.minWidthFrom, 1), this.minWidthTo = e.changes.mapPos(this.minWidthTo, 1)) : this.minWidth = this.minWidthFrom = this.minWidthTo = 0), this.updateEditContextFormatting(e);
      let i = -1;
      this.view.inputState.composing >= 0 && !this.view.observer.editContext && (!((n = this.domChanged) === null || n === void 0) && n.newSel ? i = this.domChanged.newSel.head : !P7(e.changes, this.hasComposition) && !e.selectionSet && (i = e.state.selection.main.head));
      let o = i > -1 ? C7(this.view, e.changes, i) : null;
      if (this.domChanged = null, this.hasComposition) {
        this.markedForComposition.clear();
        let { from: c, to: u } = this.hasComposition;
        r = new xr(c, u, e.changes.mapPos(c, -1), e.changes.mapPos(u, 1)).addToSet(r.slice());
      }
      this.hasComposition = o ? {
        from: o.range.fromB,
        to: o.range.toB
      } : null, (fe.ie || fe.chrome) && !o && e && e.state.doc.lines != e.startState.doc.lines && (this.forceSelection = true);
      let s = this.decorations, a = this.updateDeco(), l = A7(s, a, e.changes);
      return r = xr.extendWithRanges(r, l), !(this.flags & 7) && r.length == 0 ? false : (this.updateInner(r, e.startState.doc.length, o), e.transactions.length && (this.lastUpdate = Date.now()), true);
    }
    updateInner(e, n, r) {
      this.view.viewState.mustMeasureContent = true, this.updateChildren(e, n, r);
      let { observer: i } = this.view;
      i.ignore(() => {
        this.dom.style.height = this.view.viewState.contentHeight / this.view.scaleY + "px", this.dom.style.flexBasis = this.minWidth ? this.minWidth + "px" : "";
        let s = fe.chrome || fe.ios ? {
          node: i.selectionRange.focusNode,
          written: false
        } : void 0;
        this.sync(this.view, s), this.flags &= -8, s && (s.written || i.selectionRange.focusNode != s.node) && (this.forceSelection = true), this.dom.style.height = "";
      }), this.markedForComposition.forEach((s) => s.flags &= -9);
      let o = [];
      if (this.view.viewport.from || this.view.viewport.to < this.view.state.doc.length)
        for (let s of this.children)
          s instanceof qi && s.widget instanceof t1 && o.push(s.dom);
      i.updateGaps(o);
    }
    updateChildren(e, n, r) {
      let i = r ? r.range.addToSet(e.slice()) : e, o = this.childCursor(n);
      for (let s = i.length - 1; ; s--) {
        let a = s >= 0 ? i[s] : null;
        if (!a)
          break;
        let { fromA: l, toA: c, fromB: u, toB: h } = a, p, v, y, x;
        if (r && r.range.fromB < h && r.range.toB > u) {
          let P = Jc.build(this.view.state.doc, u, r.range.fromB, this.decorations, this.dynamicDecorationMap), R = Jc.build(this.view.state.doc, r.range.toB, h, this.decorations, this.dynamicDecorationMap);
          v = P.breakAtStart, y = P.openStart, x = R.openEnd;
          let L = this.compositionView(r);
          R.breakAtStart ? L.breakAfter = 1 : R.content.length && L.merge(L.length, L.length, R.content[0], false, R.openStart, 0) && (L.breakAfter = R.content[0].breakAfter, R.content.shift()), P.content.length && L.merge(0, 0, P.content[P.content.length - 1], true, 0, P.openEnd) && P.content.pop(), p = P.content.concat(L).concat(R.content);
        } else
          ({ content: p, breakAtStart: v, openStart: y, openEnd: x } = Jc.build(this.view.state.doc, u, h, this.decorations, this.dynamicDecorationMap));
        let { i: T, off: w } = o.findPos(c, 1), { i: k, off: C } = o.findPos(l, -1);
        _O(this, k, C, T, w, p, v, y, x);
      }
      r && this.fixCompositionDOM(r);
    }
    updateEditContextFormatting(e) {
      this.editContextFormatting = this.editContextFormatting.map(e.changes);
      for (let n of e.transactions)
        for (let r of n.effects)
          r.is(ZO) && (this.editContextFormatting = r.value);
    }
    compositionView(e) {
      let n = new Kr(e.text.nodeValue);
      n.flags |= 8;
      for (let { deco: i } of e.marks)
        n = new no(i, [
          n
        ], n.length);
      let r = new Pt();
      return r.append(n, 0), r;
    }
    fixCompositionDOM(e) {
      let n = (o, s) => {
        s.flags |= 8 | (s.children.some((l) => l.flags & 7) ? 1 : 0), this.markedForComposition.add(s);
        let a = Qe.get(o);
        a && a != s && (a.dom = null), s.setDOM(o);
      }, r = this.childPos(e.range.fromB, 1), i = this.children[r.i];
      n(e.line, i);
      for (let o = e.marks.length - 1; o >= -1; o--)
        r = i.childPos(r.off, 1), i = i.children[r.i], n(o >= 0 ? e.marks[o].node : e.text, i);
    }
    updateSelection(e = false, n = false) {
      (e || !this.view.observer.selectionRange.focusNode) && this.view.observer.readSelectionRange();
      let r = this.view.root.activeElement, i = r == this.dom, o = !i && !(this.view.state.facet(Vi) || this.dom.tabIndex > -1) && wd(this.dom, this.view.observer.selectionRange) && !(r && this.dom.contains(r));
      if (!(i || n || o))
        return;
      let s = this.forceSelection;
      this.forceSelection = false;
      let a = this.view.state.selection.main, l = this.moveToLine(this.domAtPos(a.anchor)), c = a.empty ? l : this.moveToLine(this.domAtPos(a.head));
      if (fe.gecko && a.empty && !this.hasComposition && k7(l)) {
        let h = document.createTextNode("");
        this.view.observer.ignore(() => l.node.insertBefore(h, l.node.childNodes[l.offset] || null)), l = c = new hn(h, 0), s = true;
      }
      let u = this.view.observer.selectionRange;
      (s || !u.focusNode || (!Qc(l.node, l.offset, u.anchorNode, u.anchorOffset) || !Qc(c.node, c.offset, u.focusNode, u.focusOffset)) && !this.suppressWidgetCursorChange(u, a)) && (this.view.observer.ignore(() => {
        fe.android && fe.chrome && this.dom.contains(u.focusNode) && E7(u.focusNode, this.dom) && (this.dom.blur(), this.dom.focus({
          preventScroll: true
        }));
        let h = Nu(this.view.root);
        if (h)
          if (a.empty) {
            if (fe.gecko) {
              let p = T7(l.node, l.offset);
              if (p && p != 3) {
                let v = (p == 1 ? OO : RO)(l.node, l.offset);
                v && (l = new hn(v.node, v.offset));
              }
            }
            h.collapse(l.node, l.offset), a.bidiLevel != null && h.caretBidiLevel !== void 0 && (h.caretBidiLevel = a.bidiLevel);
          } else if (h.extend) {
            h.collapse(l.node, l.offset);
            try {
              h.extend(c.node, c.offset);
            } catch {
            }
          } else {
            let p = document.createRange();
            a.anchor > a.head && ([l, c] = [
              c,
              l
            ]), p.setEnd(c.node, c.offset), p.setStart(l.node, l.offset), h.removeAllRanges(), h.addRange(p);
          }
        o && this.view.root.activeElement == this.dom && (this.dom.blur(), r && r.focus());
      }), this.view.observer.setSelectionRange(l, c)), this.impreciseAnchor = l.precise ? null : new hn(u.anchorNode, u.anchorOffset), this.impreciseHead = c.precise ? null : new hn(u.focusNode, u.focusOffset);
    }
    suppressWidgetCursorChange(e, n) {
      return this.hasComposition && n.empty && Qc(e.focusNode, e.focusOffset, e.anchorNode, e.anchorOffset) && this.posFromDOM(e.focusNode, e.focusOffset) == n.head;
    }
    enforceCursorAssoc() {
      if (this.hasComposition)
        return;
      let { view: e } = this, n = e.state.selection.main, r = Nu(e.root), { anchorNode: i, anchorOffset: o } = e.observer.selectionRange;
      if (!r || !n.empty || !n.assoc || !r.modify)
        return;
      let s = Pt.find(this, n.head);
      if (!s)
        return;
      let a = s.posAtStart;
      if (n.head == a || n.head == a + s.length)
        return;
      let l = this.coordsAt(n.head, -1), c = this.coordsAt(n.head, 1);
      if (!l || !c || l.bottom > c.top)
        return;
      let u = this.domAtPos(n.head + n.assoc);
      r.collapse(u.node, u.offset), r.modify("move", n.assoc < 0 ? "forward" : "backward", "lineboundary"), e.observer.readSelectionRange();
      let h = e.observer.selectionRange;
      e.docView.posFromDOM(h.anchorNode, h.anchorOffset) != n.from && r.collapse(i, o);
    }
    moveToLine(e) {
      let n = this.dom, r;
      if (e.node != n)
        return e;
      for (let i = e.offset; !r && i < n.childNodes.length; i++) {
        let o = Qe.get(n.childNodes[i]);
        o instanceof Pt && (r = o.domAtPos(0));
      }
      for (let i = e.offset - 1; !r && i >= 0; i--) {
        let o = Qe.get(n.childNodes[i]);
        o instanceof Pt && (r = o.domAtPos(o.length));
      }
      return r ? new hn(r.node, r.offset, true) : e;
    }
    nearest(e) {
      for (let n = e; n; ) {
        let r = Qe.get(n);
        if (r && r.rootView == this)
          return r;
        n = n.parentNode;
      }
      return null;
    }
    posFromDOM(e, n) {
      let r = this.nearest(e);
      if (!r)
        throw new RangeError("Trying to find position for a DOM position outside of the document");
      return r.localPosFromDOM(e, n) + r.posAtStart;
    }
    domAtPos(e) {
      let { i: n, off: r } = this.childCursor().findPos(e, -1);
      for (; n < this.children.length - 1; ) {
        let i = this.children[n];
        if (r < i.length || i instanceof Pt)
          break;
        n++, r = 0;
      }
      return this.children[n].domAtPos(r);
    }
    coordsAt(e, n) {
      let r = null, i = 0;
      for (let o = this.length, s = this.children.length - 1; s >= 0; s--) {
        let a = this.children[s], l = o - a.breakAfter, c = l - a.length;
        if (l < e)
          break;
        if (c <= e && (c < e || a.covers(-1)) && (l > e || a.covers(1)) && (!r || a instanceof Pt && !(r instanceof Pt && n >= 0)))
          r = a, i = c;
        else if (r && c == e && l == e && a instanceof qi && Math.abs(n) < 2) {
          if (a.deco.startSide < 0)
            break;
          s && (r = null);
        }
        o = c;
      }
      return r ? r.coordsAt(e - i, n) : null;
    }
    coordsForChar(e) {
      let { i: n, off: r } = this.childPos(e, 1), i = this.children[n];
      if (!(i instanceof Pt))
        return null;
      for (; i.children.length; ) {
        let { i: a, off: l } = i.childPos(r, 1);
        for (; ; a++) {
          if (a == i.children.length)
            return null;
          if ((i = i.children[a]).length)
            break;
        }
        r = l;
      }
      if (!(i instanceof Kr))
        return null;
      let o = en(i.text, r);
      if (o == r)
        return null;
      let s = Ks(i.dom, r, o).getClientRects();
      for (let a = 0; a < s.length; a++) {
        let l = s[a];
        if (a == s.length - 1 || l.top < l.bottom && l.left < l.right)
          return l;
      }
      return null;
    }
    measureVisibleLineHeights(e) {
      let n = [], { from: r, to: i } = e, o = this.view.contentDOM.clientWidth, s = o > Math.max(this.view.scrollDOM.clientWidth, this.minWidth) + 1, a = -1, l = this.view.textDirection == rt.LTR;
      for (let c = 0, u = 0; u < this.children.length; u++) {
        let h = this.children[u], p = c + h.length;
        if (p > i)
          break;
        if (c >= r) {
          let v = h.dom.getBoundingClientRect();
          if (n.push(v.height), s) {
            let y = h.dom.lastChild, x = y ? pl(y) : [];
            if (x.length) {
              let T = x[x.length - 1], w = l ? T.right - v.left : v.right - T.left;
              w > a && (a = w, this.minWidth = o, this.minWidthFrom = c, this.minWidthTo = p);
            }
          }
        }
        c = p + h.breakAfter;
      }
      return n;
    }
    textDirectionAt(e) {
      let { i: n } = this.childPos(e, 1);
      return getComputedStyle(this.children[n].dom).direction == "rtl" ? rt.RTL : rt.LTR;
    }
    measureTextSize() {
      for (let o of this.children)
        if (o instanceof Pt) {
          let s = o.measureTextSize();
          if (s)
            return s;
        }
      let e = document.createElement("div"), n, r, i;
      return e.className = "cm-line", e.style.width = "99999px", e.style.position = "absolute", e.textContent = "abc def ghi jkl mno pqr stu", this.view.observer.ignore(() => {
        this.dom.appendChild(e);
        let o = pl(e.firstChild)[0];
        n = e.getBoundingClientRect().height, r = o ? o.width / 27 : 7, i = o ? o.height : n, e.remove();
      }), {
        lineHeight: n,
        charWidth: r,
        textHeight: i
      };
    }
    childCursor(e = this.length) {
      let n = this.children.length;
      return n && (e -= this.children[--n].length), new LO(this.children, e, n);
    }
    computeBlockGapDeco() {
      let e = [], n = this.view.viewState;
      for (let r = 0, i = 0; ; i++) {
        let o = i == n.viewports.length ? null : n.viewports[i], s = o ? o.from - 1 : this.length;
        if (s > r) {
          let a = (n.lineBlockAt(s).bottom - n.lineBlockAt(r).top) / this.view.scaleY;
          e.push(be.replace({
            widget: new t1(a),
            block: true,
            inclusive: true,
            isBlockGap: true
          }).range(r, s));
        }
        if (!o)
          break;
        r = o.to + 1;
      }
      return be.set(e);
    }
    updateDeco() {
      let e = 1, n = this.view.state.facet($u).map((o) => (this.dynamicDecorationMap[e++] = typeof o == "function") ? o(this.view) : o), r = false, i = this.view.state.facet(tR).map((o, s) => {
        let a = typeof o == "function";
        return a && (r = true), a ? o(this.view) : o;
      });
      for (i.length && (this.dynamicDecorationMap[e++] = r, n.push(Ve.join(i))), this.decorations = [
        this.editContextFormatting,
        ...n,
        this.computeBlockGapDeco(),
        this.view.viewState.lineGapDeco
      ]; e < this.decorations.length; )
        this.dynamicDecorationMap[e++] = false;
      return this.decorations;
    }
    scrollIntoView(e) {
      if (e.isSnapshot) {
        let c = this.view.viewState.lineBlockAt(e.range.head);
        this.view.scrollDOM.scrollTop = c.top - e.yMargin, this.view.scrollDOM.scrollLeft = e.xMargin;
        return;
      }
      for (let c of this.view.state.facet(JO))
        try {
          if (c(this.view, e.range, e))
            return true;
        } catch (u) {
          Bn(this.view.state, u, "scroll handler");
        }
      let { range: n } = e, r = this.coordsAt(n.head, n.empty ? n.assoc : n.head > n.anchor ? -1 : 1), i;
      if (!r)
        return;
      !n.empty && (i = this.coordsAt(n.anchor, n.anchor > n.head ? -1 : 1)) && (r = {
        left: Math.min(r.left, i.left),
        top: Math.min(r.top, i.top),
        right: Math.max(r.right, i.right),
        bottom: Math.max(r.bottom, i.bottom)
      });
      let o = _x(this.view), s = {
        left: r.left - o.left,
        top: r.top - o.top,
        right: r.right + o.right,
        bottom: r.bottom + o.bottom
      }, { offsetWidth: a, offsetHeight: l } = this.view.scrollDOM;
      n7(this.view.scrollDOM, s, n.head < n.anchor ? -1 : 1, e.x, e.y, Math.max(Math.min(e.xMargin, a), -a), Math.max(Math.min(e.yMargin, l), -l), this.view.textDirection == rt.LTR);
    }
  }
  function k7(t) {
    return t.node.nodeType == 1 && t.node.firstChild && (t.offset == 0 || t.node.childNodes[t.offset - 1].contentEditable == "false") && (t.offset == t.node.childNodes.length || t.node.childNodes[t.offset].contentEditable == "false");
  }
  function iR(t, e) {
    let n = t.observer.selectionRange;
    if (!n.focusNode)
      return null;
    let r = OO(n.focusNode, n.focusOffset), i = RO(n.focusNode, n.focusOffset), o = r || i;
    if (i && r && i.node != r.node) {
      let a = Qe.get(i.node);
      if (!a || a instanceof Kr && a.text != i.node.nodeValue)
        o = i;
      else if (t.docView.lastCompositionAfterCursor) {
        let l = Qe.get(r.node);
        !l || l instanceof Kr && l.text != r.node.nodeValue || (o = i);
      }
    }
    if (t.docView.lastCompositionAfterCursor = o != r, !o)
      return null;
    let s = e - o.offset;
    return {
      from: s,
      to: s + o.node.nodeValue.length,
      node: o.node
    };
  }
  function C7(t, e, n) {
    let r = iR(t, n);
    if (!r)
      return null;
    let { node: i, from: o, to: s } = r, a = i.nodeValue;
    if (/[\n\r]/.test(a) || t.state.doc.sliceString(r.from, r.to) != a)
      return null;
    let l = e.invertedDesc, c = new xr(l.mapPos(o), l.mapPos(s), o, s), u = [];
    for (let h = i.parentNode; ; h = h.parentNode) {
      let p = Qe.get(h);
      if (p instanceof no)
        u.push({
          node: h,
          deco: p.mark
        });
      else {
        if (p instanceof Pt || h.nodeName == "DIV" && h.parentNode == t.contentDOM)
          return {
            range: c,
            text: i,
            marks: u,
            line: h
          };
        if (h != t.contentDOM)
          u.push({
            node: h,
            deco: new lf({
              inclusive: true,
              attributes: f7(h),
              tagName: h.tagName.toLowerCase()
            })
          });
        else
          return null;
      }
    }
  }
  function T7(t, e) {
    return t.nodeType != 1 ? 0 : (e && t.childNodes[e - 1].contentEditable == "false" ? 1 : 0) | (e < t.childNodes.length && t.childNodes[e].contentEditable == "false" ? 2 : 0);
  }
  let M7 = class {
    constructor() {
      this.changes = [];
    }
    compareRange(e, n) {
      kd(e, n, this.changes);
    }
    comparePoint(e, n) {
      kd(e, n, this.changes);
    }
    boundChange(e) {
      kd(e, e, this.changes);
    }
  };
  function A7(t, e, n) {
    let r = new M7();
    return Ve.compare(t, e, n, r), r.changes;
  }
  function E7(t, e) {
    for (let n = t; n && n != e; n = n.assignedSlot || n.parentNode)
      if (n.nodeType == 1 && n.contentEditable == "false")
        return true;
    return false;
  }
  function P7(t, e) {
    let n = false;
    return e && t.iterChangedRanges((r, i) => {
      r < e.to && i > e.from && (n = true);
    }), n;
  }
  function O7(t, e, n = 1) {
    let r = t.charCategorizer(e), i = t.doc.lineAt(e), o = e - i.from;
    if (i.length == 0)
      return q.cursor(e);
    o == 0 ? n = 1 : o == i.length && (n = -1);
    let s = o, a = o;
    n < 0 ? s = en(i.text, o, false) : a = en(i.text, o);
    let l = r(i.text.slice(s, a));
    for (; s > 0; ) {
      let c = en(i.text, s, false);
      if (r(i.text.slice(c, s)) != l)
        break;
      s = c;
    }
    for (; a < i.length; ) {
      let c = en(i.text, a);
      if (r(i.text.slice(a, c)) != l)
        break;
      a = c;
    }
    return q.range(s + i.from, a + i.from);
  }
  function R7(t, e) {
    return e.left > t ? e.left - t : Math.max(0, t - e.right);
  }
  function L7(t, e) {
    return e.top > t ? e.top - t : Math.max(0, t - e.bottom);
  }
  function D0(t, e) {
    return t.top < e.bottom - 1 && t.bottom > e.top + 1;
  }
  function RC(t, e) {
    return e < t.top ? {
      top: e,
      left: t.left,
      right: t.right,
      bottom: t.bottom
    } : t;
  }
  function LC(t, e) {
    return e > t.bottom ? {
      top: t.top,
      left: t.left,
      right: t.right,
      bottom: e
    } : t;
  }
  function s1(t, e, n) {
    let r, i, o, s, a = false, l, c, u, h;
    for (let y = t.firstChild; y; y = y.nextSibling) {
      let x = pl(y);
      for (let T = 0; T < x.length; T++) {
        let w = x[T];
        i && D0(i, w) && (w = RC(LC(w, i.bottom), i.top));
        let k = R7(e, w), C = L7(n, w);
        if (k == 0 && C == 0)
          return y.nodeType == 3 ? _C(y, e, n) : s1(y, e, n);
        (!r || s > C || s == C && o > k) && (r = y, i = w, o = k, s = C, a = k ? e < w.left ? T > 0 : T < x.length - 1 : true), k == 0 ? n > w.bottom && (!u || u.bottom < w.bottom) ? (l = y, u = w) : n < w.top && (!h || h.top > w.top) && (c = y, h = w) : u && D0(u, w) ? u = LC(u, w.bottom) : h && D0(h, w) && (h = RC(h, w.top));
      }
    }
    if (u && u.bottom >= n ? (r = l, i = u) : h && h.top <= n && (r = c, i = h), !r)
      return {
        node: t,
        offset: 0
      };
    let p = Math.max(i.left, Math.min(i.right, e));
    if (r.nodeType == 3)
      return _C(r, p, n);
    if (a && r.contentEditable != "false")
      return s1(r, p, n);
    let v = Array.prototype.indexOf.call(t.childNodes, r) + (e >= (i.left + i.right) / 2 ? 1 : 0);
    return {
      node: t,
      offset: v
    };
  }
  function _C(t, e, n) {
    let r = t.nodeValue.length, i = -1, o = 1e9, s = 0;
    for (let a = 0; a < r; a++) {
      let l = Ks(t, a, a + 1).getClientRects();
      for (let c = 0; c < l.length; c++) {
        let u = l[c];
        if (u.top == u.bottom)
          continue;
        s || (s = e - u.left);
        let h = (u.top > n ? u.top - n : n - u.bottom) - 1;
        if (u.left - 1 <= e && u.right + 1 >= e && h < o) {
          let p = e >= (u.left + u.right) / 2, v = p;
          if ((fe.chrome || fe.gecko) && Ks(t, a).getBoundingClientRect().left == u.right && (v = !p), h <= 0)
            return {
              node: t,
              offset: a + (v ? 1 : 0)
            };
          i = a + (v ? 1 : 0), o = h;
        }
      }
    }
    return {
      node: t,
      offset: i > -1 ? i : s > 0 ? t.nodeValue.length : 0
    };
  }
  function oR(t, e, n, r = -1) {
    var i, o;
    let s = t.contentDOM.getBoundingClientRect(), a = s.top + t.viewState.paddingTop, l, { docHeight: c } = t.viewState, { x: u, y: h } = e, p = h - a;
    if (p < 0)
      return 0;
    if (p > c)
      return t.state.doc.length;
    for (let P = t.viewState.heightOracle.textHeight / 2, R = false; l = t.elementAtHeight(p), l.type != Cn.Text; )
      for (; p = r > 0 ? l.bottom + P : l.top - P, !(p >= 0 && p <= c); ) {
        if (R)
          return n ? null : 0;
        R = true, r = -r;
      }
    h = a + p;
    let v = l.from;
    if (v < t.viewport.from)
      return t.viewport.from == 0 ? 0 : n ? null : DC(t, s, l, u, h);
    if (v > t.viewport.to)
      return t.viewport.to == t.state.doc.length ? t.state.doc.length : n ? null : DC(t, s, l, u, h);
    let y = t.dom.ownerDocument, x = t.root.elementFromPoint ? t.root : y, T = x.elementFromPoint(u, h);
    T && !t.contentDOM.contains(T) && (T = null), T || (u = Math.max(s.left + 1, Math.min(s.right - 1, u)), T = x.elementFromPoint(u, h), T && !t.contentDOM.contains(T) && (T = null));
    let w, k = -1;
    if (T && ((i = t.docView.nearest(T)) === null || i === void 0 ? void 0 : i.isEditable) != false) {
      if (y.caretPositionFromPoint) {
        let P = y.caretPositionFromPoint(u, h);
        P && ({ offsetNode: w, offset: k } = P);
      } else if (y.caretRangeFromPoint) {
        let P = y.caretRangeFromPoint(u, h);
        P && ({ startContainer: w, startOffset: k } = P);
      }
      w && (!t.contentDOM.contains(w) || fe.safari && _7(w, k, u) || fe.chrome && D7(w, k, u)) && (w = void 0), w && (k = Math.min(Ai(w), k));
    }
    if (!w || !t.docView.dom.contains(w)) {
      let P = Pt.find(t.docView, v);
      if (!P)
        return p > l.top + l.height / 2 ? l.to : l.from;
      ({ node: w, offset: k } = s1(P.dom, u, h));
    }
    let C = t.docView.nearest(w);
    if (!C)
      return null;
    if (C.isWidget && ((o = C.dom) === null || o === void 0 ? void 0 : o.nodeType) == 1) {
      let P = C.dom.getBoundingClientRect();
      return e.y < P.top || e.y <= P.bottom && e.x <= (P.left + P.right) / 2 ? C.posAtStart : C.posAtEnd;
    } else
      return C.localPosFromDOM(w, k) + C.posAtStart;
  }
  function DC(t, e, n, r, i) {
    let o = Math.round((r - e.left) * t.defaultCharacterWidth);
    if (t.lineWrapping && n.height > t.defaultLineHeight * 1.5) {
      let a = t.viewState.heightOracle.textHeight, l = Math.floor((i - n.top - (t.defaultLineHeight - a) * 0.5) / a);
      o += l * t.viewState.heightOracle.lineLength;
    }
    let s = t.state.sliceDoc(n.from, n.to);
    return n.from + Uy(s, o, t.state.tabSize);
  }
  function sR(t, e, n) {
    let r, i = t;
    if (t.nodeType != 3 || e != (r = t.nodeValue.length))
      return false;
    for (; ; ) {
      let o = i.nextSibling;
      if (o) {
        if (o.nodeName == "BR")
          break;
        return false;
      } else {
        let s = i.parentNode;
        if (!s || s.nodeName == "DIV")
          break;
        i = s;
      }
    }
    return Ks(t, r - 1, r).getBoundingClientRect().right > n;
  }
  function _7(t, e, n) {
    return sR(t, e, n);
  }
  function D7(t, e, n) {
    if (e != 0)
      return sR(t, e, n);
    for (let i = t; ; ) {
      let o = i.parentNode;
      if (!o || o.nodeType != 1 || o.firstChild != i)
        return false;
      if (o.classList.contains("cm-line"))
        break;
      i = o;
    }
    let r = t.nodeType == 1 ? t.getBoundingClientRect() : Ks(t, 0, Math.max(t.nodeValue.length, 1)).getBoundingClientRect();
    return n - r.left > 5;
  }
  function a1(t, e, n) {
    let r = t.lineBlockAt(e);
    if (Array.isArray(r.type)) {
      let i;
      for (let o of r.type) {
        if (o.from > e)
          break;
        if (!(o.to < e)) {
          if (o.from < e && o.to > e)
            return o;
          (!i || o.type == Cn.Text && (i.type != o.type || (n < 0 ? o.from < e : o.to > e))) && (i = o);
        }
      }
      return i || r;
    }
    return r;
  }
  function I7(t, e, n, r) {
    let i = a1(t, e.head, e.assoc || -1), o = !r || i.type != Cn.Text || !(t.lineWrapping || i.widgetLineBreaks) ? null : t.coordsAtPos(e.assoc < 0 && e.head > i.from ? e.head - 1 : e.head);
    if (o) {
      let s = t.dom.getBoundingClientRect(), a = t.textDirectionAt(i.from), l = t.posAtCoords({
        x: n == (a == rt.LTR) ? s.right - 1 : s.left + 1,
        y: (o.top + o.bottom) / 2
      });
      if (l != null)
        return q.cursor(l, n ? -1 : 1);
    }
    return q.cursor(n ? i.to : i.from, n ? -1 : 1);
  }
  function IC(t, e, n, r) {
    let i = t.state.doc.lineAt(e.head), o = t.bidiSpans(i), s = t.textDirectionAt(i.from);
    for (let a = e, l = null; ; ) {
      let c = x7(i, o, s, a, n), u = jO;
      if (!c) {
        if (i.number == (n ? t.state.doc.lines : 1))
          return a;
        u = `
`, i = t.state.doc.line(i.number + (n ? 1 : -1)), o = t.bidiSpans(i), c = t.visualLineSide(i, !n);
      }
      if (l) {
        if (!l(u))
          return a;
      } else {
        if (!r)
          return c;
        l = r(u);
      }
      a = c;
    }
  }
  function B7(t, e, n) {
    let r = t.state.charCategorizer(e), i = r(n);
    return (o) => {
      let s = r(o);
      return i == ht.Space && (i = s), i == s;
    };
  }
  function N7(t, e, n, r) {
    let i = e.head, o = n ? 1 : -1;
    if (i == (n ? t.state.doc.length : 0))
      return q.cursor(i, e.assoc);
    let s = e.goalColumn, a, l = t.contentDOM.getBoundingClientRect(), c = t.coordsAtPos(i, e.assoc || -1), u = t.documentTop;
    if (c)
      s == null && (s = c.left - l.left), a = o < 0 ? c.top : c.bottom;
    else {
      let v = t.viewState.lineBlockAt(i);
      s == null && (s = Math.min(l.right - l.left, t.defaultCharacterWidth * (i - v.from))), a = (o < 0 ? v.top : v.bottom) + u;
    }
    let h = l.left + s, p = r ?? t.viewState.heightOracle.textHeight >> 1;
    for (let v = 0; ; v += 10) {
      let y = a + (p + v) * o, x = oR(t, {
        x: h,
        y
      }, false, o);
      if (y < l.top || y > l.bottom || (o < 0 ? x < i : x > i)) {
        let T = t.docView.coordsForChar(x), w = !T || y < T.top ? -1 : 1;
        return q.cursor(x, w, void 0, s);
      }
    }
  }
  function Zc(t, e, n) {
    for (; ; ) {
      let r = 0;
      for (let i of t)
        i.between(e - 1, e + 1, (o, s, a) => {
          if (e > o && e < s) {
            let l = r || n || (e - o < s - e ? -1 : 1);
            e = l < 0 ? o : s, r = l;
          }
        });
      if (!r)
        return e;
    }
  }
  function aR(t, e) {
    let n = null;
    for (let r = 0; r < e.ranges.length; r++) {
      let i = e.ranges[r], o = null;
      if (i.empty) {
        let s = Zc(t, i.from, 0);
        s != i.from && (o = q.cursor(s, -1));
      } else {
        let s = Zc(t, i.from, -1), a = Zc(t, i.to, 1);
        (s != i.from || a != i.to) && (o = q.range(i.from == i.anchor ? s : a, i.from == i.head ? s : a));
      }
      o && (n || (n = e.ranges.slice()), n[r] = o);
    }
    return n ? q.create(n, e.mainIndex) : e;
  }
  function I0(t, e, n) {
    let r = Zc(t.state.facet(uf).map((i) => i(t)), n.from, e.head > n.from ? -1 : 1);
    return r == n.from ? n : q.cursor(r, r < n.from ? 1 : -1);
  }
  const Sc = "\uFFFF";
  class $7 {
    constructor(e, n) {
      this.points = e, this.text = "", this.lineSeparator = n.facet(Ne.lineSeparator);
    }
    append(e) {
      this.text += e;
    }
    lineBreak() {
      this.text += Sc;
    }
    readRange(e, n) {
      if (!e)
        return this;
      let r = e.parentNode;
      for (let i = e; ; ) {
        this.findPointBefore(r, i);
        let o = this.text.length;
        this.readNode(i);
        let s = i.nextSibling;
        if (s == n)
          break;
        let a = Qe.get(i), l = Qe.get(s);
        (a && l ? a.breakAfter : (a ? a.breakAfter : Sp(i)) || Sp(s) && (i.nodeName != "BR" || i.cmIgnore) && this.text.length > o) && !F7(s, n) && this.lineBreak(), i = s;
      }
      return this.findPointBefore(r, n), this;
    }
    readTextNode(e) {
      let n = e.nodeValue;
      for (let r of this.points)
        r.node == e && (r.pos = this.text.length + Math.min(r.offset, n.length));
      for (let r = 0, i = this.lineSeparator ? null : /\r\n?|\n/g; ; ) {
        let o = -1, s = 1, a;
        if (this.lineSeparator ? (o = n.indexOf(this.lineSeparator, r), s = this.lineSeparator.length) : (a = i.exec(n)) && (o = a.index, s = a[0].length), this.append(n.slice(r, o < 0 ? n.length : o)), o < 0)
          break;
        if (this.lineBreak(), s > 1)
          for (let l of this.points)
            l.node == e && l.pos > this.text.length && (l.pos -= s - 1);
        r = o + s;
      }
    }
    readNode(e) {
      if (e.cmIgnore)
        return;
      let n = Qe.get(e), r = n && n.overrideDOMText;
      if (r != null) {
        this.findPointInside(e, r.length);
        for (let i = r.iter(); !i.next().done; )
          i.lineBreak ? this.lineBreak() : this.append(i.value);
      } else
        e.nodeType == 3 ? this.readTextNode(e) : e.nodeName == "BR" ? e.nextSibling && this.lineBreak() : e.nodeType == 1 && this.readRange(e.firstChild, null);
    }
    findPointBefore(e, n) {
      for (let r of this.points)
        r.node == e && e.childNodes[r.offset] == n && (r.pos = this.text.length);
    }
    findPointInside(e, n) {
      for (let r of this.points)
        (e.nodeType == 3 ? r.node == e : e.contains(r.node)) && (r.pos = this.text.length + (z7(e, r.node, r.offset) ? n : 0));
    }
  }
  function z7(t, e, n) {
    for (; ; ) {
      if (!e || n < Ai(e))
        return false;
      if (e == t)
        return true;
      n = Us(e) + 1, e = e.parentNode;
    }
  }
  function F7(t, e) {
    let n;
    for (; !(t == e || !t); t = t.nextSibling) {
      let r = Qe.get(t);
      if (!((r == null ? void 0 : r.isWidget) || t.cmIgnore))
        return false;
      r && (n || (n = [])).push(r);
    }
    if (n)
      for (let r of n) {
        let i = r.overrideDOMText;
        if (i == null ? void 0 : i.length)
          return false;
      }
    return true;
  }
  class BC {
    constructor(e, n) {
      this.node = e, this.offset = n, this.pos = -1;
    }
  }
  class V7 {
    constructor(e, n, r, i) {
      this.typeOver = i, this.bounds = null, this.text = "", this.domChanged = n > -1;
      let { impreciseHead: o, impreciseAnchor: s } = e.docView;
      if (e.state.readOnly && n > -1)
        this.newSel = null;
      else if (n > -1 && (this.bounds = e.docView.domBoundsAround(n, r, 0))) {
        let a = o || s ? [] : j7(e), l = new $7(a, e.state);
        l.readRange(this.bounds.startDOM, this.bounds.endDOM), this.text = l.text, this.newSel = W7(a, this.bounds.from);
      } else {
        let a = e.observer.selectionRange, l = o && o.node == a.focusNode && o.offset == a.focusOffset || !Jy(e.contentDOM, a.focusNode) ? e.state.selection.main.head : e.docView.posFromDOM(a.focusNode, a.focusOffset), c = s && s.node == a.anchorNode && s.offset == a.anchorOffset || !Jy(e.contentDOM, a.anchorNode) ? e.state.selection.main.anchor : e.docView.posFromDOM(a.anchorNode, a.anchorOffset), u = e.viewport;
        if ((fe.ios || fe.chrome) && e.state.selection.main.empty && l != c && (u.from > 0 || u.to < e.state.doc.length)) {
          let h = Math.min(l, c), p = Math.max(l, c), v = u.from - h, y = u.to - p;
          (v == 0 || v == 1 || h == 0) && (y == 0 || y == -1 || p == e.state.doc.length) && (l = 0, c = e.state.doc.length);
        }
        this.newSel = q.single(c, l);
      }
    }
  }
  function lR(t, e) {
    let n, { newSel: r } = e, i = t.state.selection.main, o = t.inputState.lastKeyTime > Date.now() - 100 ? t.inputState.lastKeyCode : -1;
    if (e.bounds) {
      let { from: s, to: a } = e.bounds, l = i.from, c = null;
      (o === 8 || fe.android && e.text.length < a - s) && (l = i.to, c = "end");
      let u = cR(t.state.doc.sliceString(s, a, Sc), e.text, l - s, c);
      u && (fe.chrome && o == 13 && u.toB == u.from + 2 && e.text.slice(u.from, u.toB) == Sc + Sc && u.toB--, n = {
        from: s + u.from,
        to: s + u.toA,
        insert: He.of(e.text.slice(u.from, u.toB).split(Sc))
      });
    } else
      r && (!t.hasFocus && t.state.facet(Vi) || r.main.eq(i)) && (r = null);
    if (!n && !r)
      return false;
    if (!n && e.typeOver && !i.empty && r && r.main.empty ? n = {
      from: i.from,
      to: i.to,
      insert: t.state.doc.slice(i.from, i.to)
    } : (fe.mac || fe.android) && n && n.from == n.to && n.from == i.head - 1 && /^\. ?$/.test(n.insert.toString()) && t.contentDOM.getAttribute("autocorrect") == "off" ? (r && n.insert.length == 2 && (r = q.single(r.main.anchor - 1, r.main.head - 1)), n = {
      from: n.from,
      to: n.to,
      insert: He.of([
        n.insert.toString().replace(".", " ")
      ])
    }) : n && n.from >= i.from && n.to <= i.to && (n.from != i.from || n.to != i.to) && i.to - i.from - (n.to - n.from) <= 4 ? n = {
      from: i.from,
      to: i.to,
      insert: t.state.doc.slice(i.from, n.from).append(n.insert).append(t.state.doc.slice(n.to, i.to))
    } : fe.chrome && n && n.from == n.to && n.from == i.head && n.insert.toString() == `
 ` && t.lineWrapping && (r && (r = q.single(r.main.anchor - 1, r.main.head - 1)), n = {
      from: i.from,
      to: i.to,
      insert: He.of([
        " "
      ])
    }), n)
      return Dx(t, n, r, o);
    if (r && !r.main.eq(i)) {
      let s = false, a = "select";
      return t.inputState.lastSelectionTime > Date.now() - 50 && (t.inputState.lastSelectionOrigin == "select" && (s = true), a = t.inputState.lastSelectionOrigin, a == "select.pointer" && (r = aR(t.state.facet(uf).map((l) => l(t)), r))), t.dispatch({
        selection: r,
        scrollIntoView: s,
        userEvent: a
      }), true;
    } else
      return false;
  }
  function Dx(t, e, n, r = -1) {
    if (fe.ios && t.inputState.flushIOSKey(e))
      return true;
    let i = t.state.selection.main;
    if (fe.android && (e.to == i.to && (e.from == i.from || e.from == i.from - 1 && t.state.sliceDoc(e.from, i.from) == " ") && e.insert.length == 1 && e.insert.lines == 2 && Xa(t.contentDOM, "Enter", 13) || (e.from == i.from - 1 && e.to == i.to && e.insert.length == 0 || r == 8 && e.insert.length < e.to - e.from && e.to > i.head) && Xa(t.contentDOM, "Backspace", 8) || e.from == i.from && e.to == i.to + 1 && e.insert.length == 0 && Xa(t.contentDOM, "Delete", 46)))
      return true;
    let o = e.insert.toString();
    t.inputState.composing >= 0 && t.inputState.composing++;
    let s, a = () => s || (s = H7(t, e, n));
    return t.state.facet(GO).some((l) => l(t, e.from, e.to, o, a)) || t.dispatch(a()), true;
  }
  function H7(t, e, n) {
    let r, i = t.state, o = i.selection.main, s = -1;
    if (e.from == e.to && e.from < o.from || e.from > o.to) {
      let l = e.from < o.from ? -1 : 1, c = l < 0 ? o.from : o.to, u = Zc(i.facet(uf).map((h) => h(t)), c, l);
      e.from == u && (s = u);
    }
    if (s > -1)
      r = {
        changes: e,
        selection: q.cursor(e.from + e.insert.length, -1)
      };
    else if (e.from >= o.from && e.to <= o.to && e.to - e.from >= (o.to - o.from) / 3 && (!n || n.main.empty && n.main.from == e.from + e.insert.length) && t.inputState.composing < 0) {
      let l = o.from < e.from ? i.sliceDoc(o.from, e.from) : "", c = o.to > e.to ? i.sliceDoc(e.to, o.to) : "";
      r = i.replaceSelection(t.state.toText(l + e.insert.sliceString(0, void 0, t.state.lineBreak) + c));
    } else {
      let l = i.changes(e), c = n && n.main.to <= l.newLength ? n.main : void 0;
      if (i.selection.ranges.length > 1 && t.inputState.composing >= 0 && e.to <= o.to && e.to >= o.to - 10) {
        let u = t.state.sliceDoc(e.from, e.to), h, p = n && iR(t, n.main.head);
        if (p) {
          let x = e.insert.length - (e.to - e.from);
          h = {
            from: p.from,
            to: p.to - x
          };
        } else
          h = t.state.doc.lineAt(o.head);
        let v = o.to - e.to, y = o.to - o.from;
        r = i.changeByRange((x) => {
          if (x.from == o.from && x.to == o.to)
            return {
              changes: l,
              range: c || x.map(l)
            };
          let T = x.to - v, w = T - u.length;
          if (x.to - x.from != y || t.state.sliceDoc(w, T) != u || x.to >= h.from && x.from <= h.to)
            return {
              range: x
            };
          let k = i.changes({
            from: w,
            to: T,
            insert: e.insert
          }), C = x.to - o.to;
          return {
            changes: k,
            range: c ? q.range(Math.max(0, c.anchor + C), Math.max(0, c.head + C)) : x.map(k)
          };
        });
      } else
        r = {
          changes: l,
          selection: c && i.selection.replaceRange(c)
        };
    }
    let a = "input.type";
    return (t.composing || t.inputState.compositionPendingChange && t.inputState.compositionEndedAt > Date.now() - 50) && (t.inputState.compositionPendingChange = false, a += ".compose", t.inputState.compositionFirstChange && (a += ".start", t.inputState.compositionFirstChange = false)), i.update(r, {
      userEvent: a,
      scrollIntoView: true
    });
  }
  function cR(t, e, n, r) {
    let i = Math.min(t.length, e.length), o = 0;
    for (; o < i && t.charCodeAt(o) == e.charCodeAt(o); )
      o++;
    if (o == i && t.length == e.length)
      return null;
    let s = t.length, a = e.length;
    for (; s > 0 && a > 0 && t.charCodeAt(s - 1) == e.charCodeAt(a - 1); )
      s--, a--;
    if (r == "end") {
      let l = Math.max(0, o - Math.min(s, a));
      n -= s + l - o;
    }
    if (s < o && t.length < e.length) {
      let l = n <= o && n >= s ? o - n : 0;
      o -= l, a = o + (a - s), s = o;
    } else if (a < o) {
      let l = n <= o && n >= a ? o - n : 0;
      o -= l, s = o + (s - a), a = o;
    }
    return {
      from: o,
      toA: s,
      toB: a
    };
  }
  function j7(t) {
    let e = [];
    if (t.root.activeElement != t.contentDOM)
      return e;
    let { anchorNode: n, anchorOffset: r, focusNode: i, focusOffset: o } = t.observer.selectionRange;
    return n && (e.push(new BC(n, r)), (i != n || o != r) && e.push(new BC(i, o))), e;
  }
  function W7(t, e) {
    if (t.length == 0)
      return null;
    let n = t[0].pos, r = t.length == 2 ? t[1].pos : n;
    return n > -1 && r > -1 ? q.single(n + e, r + e) : null;
  }
  class U7 {
    setSelectionOrigin(e) {
      this.lastSelectionOrigin = e, this.lastSelectionTime = Date.now();
    }
    constructor(e) {
      this.view = e, this.lastKeyCode = 0, this.lastKeyTime = 0, this.lastTouchTime = 0, this.lastFocusTime = 0, this.lastScrollTop = 0, this.lastScrollLeft = 0, this.pendingIOSKey = void 0, this.tabFocusMode = -1, this.lastSelectionOrigin = null, this.lastSelectionTime = 0, this.lastContextMenu = 0, this.scrollHandlers = [], this.handlers = /* @__PURE__ */ Object.create(null), this.composing = -1, this.compositionFirstChange = null, this.compositionEndedAt = 0, this.compositionPendingKey = false, this.compositionPendingChange = false, this.mouseSelection = null, this.draggedContent = null, this.handleEvent = this.handleEvent.bind(this), this.notifiedFocused = e.hasFocus, fe.safari && e.contentDOM.addEventListener("input", () => null), fe.gecko && aU(e.contentDOM.ownerDocument);
    }
    handleEvent(e) {
      !Z7(this.view, e) || this.ignoreDuringComposition(e) || e.type == "keydown" && this.keydown(e) || (this.view.updateState != 0 ? Promise.resolve().then(() => this.runHandlers(e.type, e)) : this.runHandlers(e.type, e));
    }
    runHandlers(e, n) {
      let r = this.handlers[e];
      if (r) {
        for (let i of r.observers)
          i(this.view, n);
        for (let i of r.handlers) {
          if (n.defaultPrevented)
            break;
          if (i(this.view, n)) {
            n.preventDefault();
            break;
          }
        }
      }
    }
    ensureHandlers(e) {
      let n = K7(e), r = this.handlers, i = this.view.contentDOM;
      for (let o in n)
        if (o != "scroll") {
          let s = !n[o].handlers.length, a = r[o];
          a && s != !a.handlers.length && (i.removeEventListener(o, this.handleEvent), a = null), a || i.addEventListener(o, this.handleEvent, {
            passive: s
          });
        }
      for (let o in r)
        o != "scroll" && !n[o] && i.removeEventListener(o, this.handleEvent);
      this.handlers = n;
    }
    keydown(e) {
      if (this.lastKeyCode = e.keyCode, this.lastKeyTime = Date.now(), e.keyCode == 9 && this.tabFocusMode > -1 && (!this.tabFocusMode || Date.now() <= this.tabFocusMode))
        return true;
      if (this.tabFocusMode > 0 && e.keyCode != 27 && fR.indexOf(e.keyCode) < 0 && (this.tabFocusMode = -1), fe.android && fe.chrome && !e.synthetic && (e.keyCode == 13 || e.keyCode == 8))
        return this.view.observer.delayAndroidKey(e.key, e.keyCode), true;
      let n;
      return fe.ios && !e.synthetic && !e.altKey && !e.metaKey && ((n = uR.find((r) => r.keyCode == e.keyCode)) && !e.ctrlKey || q7.indexOf(e.key) > -1 && e.ctrlKey && !e.shiftKey) ? (this.pendingIOSKey = n || e, setTimeout(() => this.flushIOSKey(), 250), true) : (e.keyCode != 229 && this.view.observer.forceFlush(), false);
    }
    flushIOSKey(e) {
      let n = this.pendingIOSKey;
      return !n || n.key == "Enter" && e && e.from < e.to && /^\S+$/.test(e.insert.toString()) ? false : (this.pendingIOSKey = void 0, Xa(this.view.contentDOM, n.key, n.keyCode, n instanceof KeyboardEvent ? n : void 0));
    }
    ignoreDuringComposition(e) {
      return !/^key/.test(e.type) || e.synthetic ? false : this.composing > 0 ? true : fe.safari && !fe.ios && this.compositionPendingKey && Date.now() - this.compositionEndedAt < 100 ? (this.compositionPendingKey = false, true) : false;
    }
    startMouseSelection(e) {
      this.mouseSelection && this.mouseSelection.destroy(), this.mouseSelection = e;
    }
    update(e) {
      this.view.observer.update(e), this.mouseSelection && this.mouseSelection.update(e), this.draggedContent && e.docChanged && (this.draggedContent = this.draggedContent.map(e.changes)), e.transactions.length && (this.lastKeyCode = this.lastSelectionTime = 0);
    }
    destroy() {
      this.mouseSelection && this.mouseSelection.destroy();
    }
  }
  function NC(t, e) {
    return (n, r) => {
      try {
        return e.call(t, r, n);
      } catch (i) {
        Bn(n.state, i);
      }
    };
  }
  function K7(t) {
    let e = /* @__PURE__ */ Object.create(null);
    function n(r) {
      return e[r] || (e[r] = {
        observers: [],
        handlers: []
      });
    }
    for (let r of t) {
      let i = r.spec, o = i && i.plugin.domEventHandlers, s = i && i.plugin.domEventObservers;
      if (o)
        for (let a in o) {
          let l = o[a];
          l && n(a).handlers.push(NC(r.value, l));
        }
      if (s)
        for (let a in s) {
          let l = s[a];
          l && n(a).observers.push(NC(r.value, l));
        }
    }
    for (let r in qr)
      n(r).handlers.push(qr[r]);
    for (let r in Cr)
      n(r).observers.push(Cr[r]);
    return e;
  }
  const uR = [
    {
      key: "Backspace",
      keyCode: 8,
      inputType: "deleteContentBackward"
    },
    {
      key: "Enter",
      keyCode: 13,
      inputType: "insertParagraph"
    },
    {
      key: "Enter",
      keyCode: 13,
      inputType: "insertLineBreak"
    },
    {
      key: "Delete",
      keyCode: 46,
      inputType: "deleteContentForward"
    }
  ], q7 = "dthko", fR = [
    16,
    17,
    18,
    20,
    91,
    92,
    224,
    225
  ], Mh = 6;
  function Ah(t) {
    return Math.max(0, t) * 0.7 + 8;
  }
  function G7(t, e) {
    return Math.max(Math.abs(t.clientX - e.clientX), Math.abs(t.clientY - e.clientY));
  }
  class Y7 {
    constructor(e, n, r, i) {
      this.view = e, this.startEvent = n, this.style = r, this.mustSelect = i, this.scrollSpeed = {
        x: 0,
        y: 0
      }, this.scrolling = -1, this.lastEvent = n, this.scrollParents = r7(e.contentDOM), this.atoms = e.state.facet(uf).map((s) => s(e));
      let o = e.contentDOM.ownerDocument;
      o.addEventListener("mousemove", this.move = this.move.bind(this)), o.addEventListener("mouseup", this.up = this.up.bind(this)), this.extend = n.shiftKey, this.multiple = e.state.facet(Ne.allowMultipleSelections) && X7(e, n), this.dragging = J7(e, n) && pR(n) == 1 ? null : false;
    }
    start(e) {
      this.dragging === false && this.select(e);
    }
    move(e) {
      if (e.buttons == 0)
        return this.destroy();
      if (this.dragging || this.dragging == null && G7(this.startEvent, e) < 10)
        return;
      this.select(this.lastEvent = e);
      let n = 0, r = 0, i = 0, o = 0, s = this.view.win.innerWidth, a = this.view.win.innerHeight;
      this.scrollParents.x && ({ left: i, right: s } = this.scrollParents.x.getBoundingClientRect()), this.scrollParents.y && ({ top: o, bottom: a } = this.scrollParents.y.getBoundingClientRect());
      let l = _x(this.view);
      e.clientX - l.left <= i + Mh ? n = -Ah(i - e.clientX) : e.clientX + l.right >= s - Mh && (n = Ah(e.clientX - s)), e.clientY - l.top <= o + Mh ? r = -Ah(o - e.clientY) : e.clientY + l.bottom >= a - Mh && (r = Ah(e.clientY - a)), this.setScrollSpeed(n, r);
    }
    up(e) {
      this.dragging == null && this.select(this.lastEvent), this.dragging || e.preventDefault(), this.destroy();
    }
    destroy() {
      this.setScrollSpeed(0, 0);
      let e = this.view.contentDOM.ownerDocument;
      e.removeEventListener("mousemove", this.move), e.removeEventListener("mouseup", this.up), this.view.inputState.mouseSelection = this.view.inputState.draggedContent = null;
    }
    setScrollSpeed(e, n) {
      this.scrollSpeed = {
        x: e,
        y: n
      }, e || n ? this.scrolling < 0 && (this.scrolling = setInterval(() => this.scroll(), 50)) : this.scrolling > -1 && (clearInterval(this.scrolling), this.scrolling = -1);
    }
    scroll() {
      let { x: e, y: n } = this.scrollSpeed;
      e && this.scrollParents.x && (this.scrollParents.x.scrollLeft += e, e = 0), n && this.scrollParents.y && (this.scrollParents.y.scrollTop += n, n = 0), (e || n) && this.view.win.scrollBy(e, n), this.dragging === false && this.select(this.lastEvent);
    }
    select(e) {
      let { view: n } = this, r = aR(this.atoms, this.style.get(e, this.extend, this.multiple));
      (this.mustSelect || !r.eq(n.state.selection, this.dragging === false)) && this.view.dispatch({
        selection: r,
        userEvent: "select.pointer"
      }), this.mustSelect = false;
    }
    update(e) {
      e.transactions.some((n) => n.isUserEvent("input.type")) ? this.destroy() : this.style.update(e) && setTimeout(() => this.select(this.lastEvent), 20);
    }
  }
  function X7(t, e) {
    let n = t.state.facet(WO);
    return n.length ? n[0](e) : fe.mac ? e.metaKey : e.ctrlKey;
  }
  function Q7(t, e) {
    let n = t.state.facet(UO);
    return n.length ? n[0](e) : fe.mac ? !e.altKey : !e.ctrlKey;
  }
  function J7(t, e) {
    let { main: n } = t.state.selection;
    if (n.empty)
      return false;
    let r = Nu(t.root);
    if (!r || r.rangeCount == 0)
      return true;
    let i = r.getRangeAt(0).getClientRects();
    for (let o = 0; o < i.length; o++) {
      let s = i[o];
      if (s.left <= e.clientX && s.right >= e.clientX && s.top <= e.clientY && s.bottom >= e.clientY)
        return true;
    }
    return false;
  }
  function Z7(t, e) {
    if (!e.bubbles)
      return true;
    if (e.defaultPrevented)
      return false;
    for (let n = e.target, r; n != t.contentDOM; n = n.parentNode)
      if (!n || n.nodeType == 11 || (r = Qe.get(n)) && r.ignoreEvent(e))
        return false;
    return true;
  }
  const qr = /* @__PURE__ */ Object.create(null), Cr = /* @__PURE__ */ Object.create(null), hR = fe.ie && fe.ie_version < 15 || fe.ios && fe.webkit_version < 604;
  function eU(t) {
    let e = t.dom.parentNode;
    if (!e)
      return;
    let n = e.appendChild(document.createElement("textarea"));
    n.style.cssText = "position: fixed; left: -10000px; top: 10px", n.focus(), setTimeout(() => {
      t.focus(), n.remove(), dR(t, n.value);
    }, 50);
  }
  function Fm(t, e, n) {
    for (let r of t.facet(e))
      n = r(n, t);
    return n;
  }
  function dR(t, e) {
    e = Fm(t.state, Ox, e);
    let { state: n } = t, r, i = 1, o = n.toText(e), s = o.lines == n.selection.ranges.length;
    if (l1 != null && n.selection.ranges.every((l) => l.empty) && l1 == o.toString()) {
      let l = -1;
      r = n.changeByRange((c) => {
        let u = n.doc.lineAt(c.from);
        if (u.from == l)
          return {
            range: c
          };
        l = u.from;
        let h = n.toText((s ? o.line(i++).text : e) + n.lineBreak);
        return {
          changes: {
            from: u.from,
            insert: h
          },
          range: q.cursor(c.from + h.length)
        };
      });
    } else
      s ? r = n.changeByRange((l) => {
        let c = o.line(i++);
        return {
          changes: {
            from: l.from,
            to: l.to,
            insert: c.text
          },
          range: q.cursor(l.from + c.length)
        };
      }) : r = n.replaceSelection(o);
    t.dispatch(r, {
      userEvent: "input.paste",
      scrollIntoView: true
    });
  }
  Cr.scroll = (t) => {
    t.inputState.lastScrollTop = t.scrollDOM.scrollTop, t.inputState.lastScrollLeft = t.scrollDOM.scrollLeft;
  };
  qr.keydown = (t, e) => (t.inputState.setSelectionOrigin("select"), e.keyCode == 27 && t.inputState.tabFocusMode != 0 && (t.inputState.tabFocusMode = Date.now() + 2e3), false);
  Cr.touchstart = (t, e) => {
    t.inputState.lastTouchTime = Date.now(), t.inputState.setSelectionOrigin("select.pointer");
  };
  Cr.touchmove = (t) => {
    t.inputState.setSelectionOrigin("select.pointer");
  };
  qr.mousedown = (t, e) => {
    if (t.observer.flush(), t.inputState.lastTouchTime > Date.now() - 2e3)
      return false;
    let n = null;
    for (let r of t.state.facet(KO))
      if (n = r(t, e), n)
        break;
    if (!n && e.button == 0 && (n = rU(t, e)), n) {
      let r = !t.hasFocus;
      t.inputState.startMouseSelection(new Y7(t, e, n, r)), r && t.observer.ignore(() => {
        AO(t.contentDOM);
        let o = t.root.activeElement;
        o && !o.contains(t.contentDOM) && o.blur();
      });
      let i = t.inputState.mouseSelection;
      if (i)
        return i.start(e), i.dragging === false;
    } else
      t.inputState.setSelectionOrigin("select.pointer");
    return false;
  };
  function $C(t, e, n, r) {
    if (r == 1)
      return q.cursor(e, n);
    if (r == 2)
      return O7(t.state, e, n);
    {
      let i = Pt.find(t.docView, e), o = t.state.doc.lineAt(i ? i.posAtEnd : e), s = i ? i.posAtStart : o.from, a = i ? i.posAtEnd : o.to;
      return a < t.state.doc.length && a == o.to && a++, q.range(s, a);
    }
  }
  let zC = (t, e, n) => e >= n.top && e <= n.bottom && t >= n.left && t <= n.right;
  function tU(t, e, n, r) {
    let i = Pt.find(t.docView, e);
    if (!i)
      return 1;
    let o = e - i.posAtStart;
    if (o == 0)
      return 1;
    if (o == i.length)
      return -1;
    let s = i.coordsAt(o, -1);
    if (s && zC(n, r, s))
      return -1;
    let a = i.coordsAt(o, 1);
    return a && zC(n, r, a) ? 1 : s && s.bottom >= r ? -1 : 1;
  }
  function FC(t, e) {
    let n = t.posAtCoords({
      x: e.clientX,
      y: e.clientY
    }, false);
    return {
      pos: n,
      bias: tU(t, n, e.clientX, e.clientY)
    };
  }
  const nU = fe.ie && fe.ie_version <= 11;
  let VC = null, HC = 0, jC = 0;
  function pR(t) {
    if (!nU)
      return t.detail;
    let e = VC, n = jC;
    return VC = t, jC = Date.now(), HC = !e || n > Date.now() - 400 && Math.abs(e.clientX - t.clientX) < 2 && Math.abs(e.clientY - t.clientY) < 2 ? (HC + 1) % 3 : 1;
  }
  function rU(t, e) {
    let n = FC(t, e), r = pR(e), i = t.state.selection;
    return {
      update(o) {
        o.docChanged && (n.pos = o.changes.mapPos(n.pos), i = i.map(o.changes));
      },
      get(o, s, a) {
        let l = FC(t, o), c, u = $C(t, l.pos, l.bias, r);
        if (n.pos != l.pos && !s) {
          let h = $C(t, n.pos, n.bias, r), p = Math.min(h.from, u.from), v = Math.max(h.to, u.to);
          u = p < u.from ? q.range(p, v) : q.range(v, p);
        }
        return s ? i.replaceRange(i.main.extend(u.from, u.to)) : a && r == 1 && i.ranges.length > 1 && (c = iU(i, l.pos)) ? c : a ? i.addRange(u) : q.create([
          u
        ]);
      }
    };
  }
  function iU(t, e) {
    for (let n = 0; n < t.ranges.length; n++) {
      let { from: r, to: i } = t.ranges[n];
      if (r <= e && i >= e)
        return q.create(t.ranges.slice(0, n).concat(t.ranges.slice(n + 1)), t.mainIndex == n ? 0 : t.mainIndex - (t.mainIndex > n ? 1 : 0));
    }
    return null;
  }
  qr.dragstart = (t, e) => {
    let { selection: { main: n } } = t.state;
    if (e.target.draggable) {
      let i = t.docView.nearest(e.target);
      if (i && i.isWidget) {
        let o = i.posAtStart, s = o + i.length;
        (o >= n.to || s <= n.from) && (n = q.range(o, s));
      }
    }
    let { inputState: r } = t;
    return r.mouseSelection && (r.mouseSelection.dragging = true), r.draggedContent = n, e.dataTransfer && (e.dataTransfer.setData("Text", Fm(t.state, Rx, t.state.sliceDoc(n.from, n.to))), e.dataTransfer.effectAllowed = "copyMove"), false;
  };
  qr.dragend = (t) => (t.inputState.draggedContent = null, false);
  function WC(t, e, n, r) {
    if (n = Fm(t.state, Ox, n), !n)
      return;
    let i = t.posAtCoords({
      x: e.clientX,
      y: e.clientY
    }, false), { draggedContent: o } = t.inputState, s = r && o && Q7(t, e) ? {
      from: o.from,
      to: o.to
    } : null, a = {
      from: i,
      insert: n
    }, l = t.state.changes(s ? [
      s,
      a
    ] : a);
    t.focus(), t.dispatch({
      changes: l,
      selection: {
        anchor: l.mapPos(i, -1),
        head: l.mapPos(i, 1)
      },
      userEvent: s ? "move.drop" : "input.drop"
    }), t.inputState.draggedContent = null;
  }
  qr.drop = (t, e) => {
    if (!e.dataTransfer)
      return false;
    if (t.state.readOnly)
      return true;
    let n = e.dataTransfer.files;
    if (n && n.length) {
      let r = Array(n.length), i = 0, o = () => {
        ++i == n.length && WC(t, e, r.filter((s) => s != null).join(t.state.lineBreak), false);
      };
      for (let s = 0; s < n.length; s++) {
        let a = new FileReader();
        a.onerror = o, a.onload = () => {
          /[\x00-\x08\x0e-\x1f]{2}/.test(a.result) || (r[s] = a.result), o();
        }, a.readAsText(n[s]);
      }
      return true;
    } else {
      let r = e.dataTransfer.getData("Text");
      if (r)
        return WC(t, e, r, true), true;
    }
    return false;
  };
  qr.paste = (t, e) => {
    if (t.state.readOnly)
      return true;
    t.observer.flush();
    let n = hR ? null : e.clipboardData;
    return n ? (dR(t, n.getData("text/plain") || n.getData("text/uri-list")), true) : (eU(t), false);
  };
  function oU(t, e) {
    let n = t.dom.parentNode;
    if (!n)
      return;
    let r = n.appendChild(document.createElement("textarea"));
    r.style.cssText = "position: fixed; left: -10000px; top: 10px", r.value = e, r.focus(), r.selectionEnd = e.length, r.selectionStart = 0, setTimeout(() => {
      r.remove(), t.focus();
    }, 50);
  }
  function sU(t) {
    let e = [], n = [], r = false;
    for (let i of t.selection.ranges)
      i.empty || (e.push(t.sliceDoc(i.from, i.to)), n.push(i));
    if (!e.length) {
      let i = -1;
      for (let { from: o } of t.selection.ranges) {
        let s = t.doc.lineAt(o);
        s.number > i && (e.push(s.text), n.push({
          from: s.from,
          to: Math.min(t.doc.length, s.to + 1)
        })), i = s.number;
      }
      r = true;
    }
    return {
      text: Fm(t, Rx, e.join(t.lineBreak)),
      ranges: n,
      linewise: r
    };
  }
  let l1 = null;
  qr.copy = qr.cut = (t, e) => {
    let { text: n, ranges: r, linewise: i } = sU(t.state);
    if (!n && !i)
      return false;
    l1 = i ? n : null, e.type == "cut" && !t.state.readOnly && t.dispatch({
      changes: r,
      scrollIntoView: true,
      userEvent: "delete.cut"
    });
    let o = hR ? null : e.clipboardData;
    return o ? (o.clearData(), o.setData("text/plain", n), true) : (oU(t, n), false);
  };
  const mR = Pi.define();
  function gR(t, e) {
    let n = [];
    for (let r of t.facet(YO)) {
      let i = r(t, e);
      i && n.push(i);
    }
    return n.length ? t.update({
      effects: n,
      annotations: mR.of(true)
    }) : null;
  }
  function vR(t) {
    setTimeout(() => {
      let e = t.hasFocus;
      if (e != t.inputState.notifiedFocused) {
        let n = gR(t.state, e);
        n ? t.dispatch(n) : t.update([]);
      }
    }, 10);
  }
  Cr.focus = (t) => {
    t.inputState.lastFocusTime = Date.now(), !t.scrollDOM.scrollTop && (t.inputState.lastScrollTop || t.inputState.lastScrollLeft) && (t.scrollDOM.scrollTop = t.inputState.lastScrollTop, t.scrollDOM.scrollLeft = t.inputState.lastScrollLeft), vR(t);
  };
  Cr.blur = (t) => {
    t.observer.clearSelectionRange(), vR(t);
  };
  Cr.compositionstart = Cr.compositionupdate = (t) => {
    t.observer.editContext || (t.inputState.compositionFirstChange == null && (t.inputState.compositionFirstChange = true), t.inputState.composing < 0 && (t.inputState.composing = 0));
  };
  Cr.compositionend = (t) => {
    t.observer.editContext || (t.inputState.composing = -1, t.inputState.compositionEndedAt = Date.now(), t.inputState.compositionPendingKey = true, t.inputState.compositionPendingChange = t.observer.pendingRecords().length > 0, t.inputState.compositionFirstChange = null, fe.chrome && fe.android ? t.observer.flushSoon() : t.inputState.compositionPendingChange ? Promise.resolve().then(() => t.observer.flush()) : setTimeout(() => {
      t.inputState.composing < 0 && t.docView.hasComposition && t.update([]);
    }, 50));
  };
  Cr.contextmenu = (t) => {
    t.inputState.lastContextMenu = Date.now();
  };
  qr.beforeinput = (t, e) => {
    var n, r;
    if (e.inputType == "insertReplacementText" && t.observer.editContext) {
      let o = (n = e.dataTransfer) === null || n === void 0 ? void 0 : n.getData("text/plain"), s = e.getTargetRanges();
      if (o && s.length) {
        let a = s[0], l = t.posAtDOM(a.startContainer, a.startOffset), c = t.posAtDOM(a.endContainer, a.endOffset);
        return Dx(t, {
          from: l,
          to: c,
          insert: t.state.toText(o)
        }, null), true;
      }
    }
    let i;
    if (fe.chrome && fe.android && (i = uR.find((o) => o.inputType == e.inputType)) && (t.observer.delayAndroidKey(i.key, i.keyCode), i.key == "Backspace" || i.key == "Delete")) {
      let o = ((r = window.visualViewport) === null || r === void 0 ? void 0 : r.height) || 0;
      setTimeout(() => {
        var s;
        (((s = window.visualViewport) === null || s === void 0 ? void 0 : s.height) || 0) > o + 10 && t.hasFocus && (t.contentDOM.blur(), t.focus());
      }, 100);
    }
    return fe.ios && e.inputType == "deleteContentForward" && t.observer.flushSoon(), fe.safari && e.inputType == "insertText" && t.inputState.composing >= 0 && setTimeout(() => Cr.compositionend(t, e), 20), false;
  };
  const UC = /* @__PURE__ */ new Set();
  function aU(t) {
    UC.has(t) || (UC.add(t), t.addEventListener("copy", () => {
    }), t.addEventListener("cut", () => {
    }));
  }
  const KC = [
    "pre-wrap",
    "normal",
    "pre-line",
    "break-spaces"
  ];
  let vl = false;
  function qC() {
    vl = false;
  }
  class lU {
    constructor(e) {
      this.lineWrapping = e, this.doc = He.empty, this.heightSamples = {}, this.lineHeight = 14, this.charWidth = 7, this.textHeight = 14, this.lineLength = 30;
    }
    heightForGap(e, n) {
      let r = this.doc.lineAt(n).number - this.doc.lineAt(e).number + 1;
      return this.lineWrapping && (r += Math.max(0, Math.ceil((n - e - r * this.lineLength * 0.5) / this.lineLength))), this.lineHeight * r;
    }
    heightForLine(e) {
      return this.lineWrapping ? (1 + Math.max(0, Math.ceil((e - this.lineLength) / Math.max(1, this.lineLength - 5)))) * this.lineHeight : this.lineHeight;
    }
    setDoc(e) {
      return this.doc = e, this;
    }
    mustRefreshForWrapping(e) {
      return KC.indexOf(e) > -1 != this.lineWrapping;
    }
    mustRefreshForHeights(e) {
      let n = false;
      for (let r = 0; r < e.length; r++) {
        let i = e[r];
        i < 0 ? r++ : this.heightSamples[Math.floor(i * 10)] || (n = true, this.heightSamples[Math.floor(i * 10)] = true);
      }
      return n;
    }
    refresh(e, n, r, i, o, s) {
      let a = KC.indexOf(e) > -1, l = Math.round(n) != Math.round(this.lineHeight) || this.lineWrapping != a;
      if (this.lineWrapping = a, this.lineHeight = n, this.charWidth = r, this.textHeight = i, this.lineLength = o, l) {
        this.heightSamples = {};
        for (let c = 0; c < s.length; c++) {
          let u = s[c];
          u < 0 ? c++ : this.heightSamples[Math.floor(u * 10)] = true;
        }
      }
      return l;
    }
  }
  class cU {
    constructor(e, n) {
      this.from = e, this.heights = n, this.index = 0;
    }
    get more() {
      return this.index < this.heights.length;
    }
  }
  class gi {
    constructor(e, n, r, i, o) {
      this.from = e, this.length = n, this.top = r, this.height = i, this._content = o;
    }
    get type() {
      return typeof this._content == "number" ? Cn.Text : Array.isArray(this._content) ? this._content : this._content.type;
    }
    get to() {
      return this.from + this.length;
    }
    get bottom() {
      return this.top + this.height;
    }
    get widget() {
      return this._content instanceof Yo ? this._content.widget : null;
    }
    get widgetLineBreaks() {
      return typeof this._content == "number" ? this._content : 0;
    }
    join(e) {
      let n = (Array.isArray(this._content) ? this._content : [
        this
      ]).concat(Array.isArray(e._content) ? e._content : [
        e
      ]);
      return new gi(this.from, this.length + e.length, this.top, this.height + e.height, n);
    }
  }
  var at = function(t) {
    return t[t.ByPos = 0] = "ByPos", t[t.ByHeight = 1] = "ByHeight", t[t.ByPosNoHeight = 2] = "ByPosNoHeight", t;
  }(at || (at = {}));
  const Cd = 1e-3;
  class Tn {
    constructor(e, n, r = 2) {
      this.length = e, this.height = n, this.flags = r;
    }
    get outdated() {
      return (this.flags & 2) > 0;
    }
    set outdated(e) {
      this.flags = (e ? 2 : 0) | this.flags & -3;
    }
    setHeight(e) {
      this.height != e && (Math.abs(this.height - e) > Cd && (vl = true), this.height = e);
    }
    replace(e, n, r) {
      return Tn.of(r);
    }
    decomposeLeft(e, n) {
      n.push(this);
    }
    decomposeRight(e, n) {
      n.push(this);
    }
    applyChanges(e, n, r, i) {
      let o = this, s = r.doc;
      for (let a = i.length - 1; a >= 0; a--) {
        let { fromA: l, toA: c, fromB: u, toB: h } = i[a], p = o.lineAt(l, at.ByPosNoHeight, r.setDoc(n), 0, 0), v = p.to >= c ? p : o.lineAt(c, at.ByPosNoHeight, r, 0, 0);
        for (h += v.to - c, c = v.to; a > 0 && p.from <= i[a - 1].toA; )
          l = i[a - 1].fromA, u = i[a - 1].fromB, a--, l < p.from && (p = o.lineAt(l, at.ByPosNoHeight, r, 0, 0));
        u += p.from - l, l = p.from;
        let y = Ix.build(r.setDoc(s), e, u, h);
        o = Cp(o, o.replace(l, c, y));
      }
      return o.updateHeight(r, 0);
    }
    static empty() {
      return new Un(0, 0);
    }
    static of(e) {
      if (e.length == 1)
        return e[0];
      let n = 0, r = e.length, i = 0, o = 0;
      for (; ; )
        if (n == r)
          if (i > o * 2) {
            let a = e[n - 1];
            a.break ? e.splice(--n, 1, a.left, null, a.right) : e.splice(--n, 1, a.left, a.right), r += 1 + a.break, i -= a.size;
          } else if (o > i * 2) {
            let a = e[r];
            a.break ? e.splice(r, 1, a.left, null, a.right) : e.splice(r, 1, a.left, a.right), r += 2 + a.break, o -= a.size;
          } else
            break;
        else if (i < o) {
          let a = e[n++];
          a && (i += a.size);
        } else {
          let a = e[--r];
          a && (o += a.size);
        }
      let s = 0;
      return e[n - 1] == null ? (s = 1, n--) : e[n] == null && (s = 1, r++), new uU(Tn.of(e.slice(0, n)), s, Tn.of(e.slice(r)));
    }
  }
  function Cp(t, e) {
    return t == e ? t : (t.constructor != e.constructor && (vl = true), e);
  }
  Tn.prototype.size = 1;
  class yR extends Tn {
    constructor(e, n, r) {
      super(e, n), this.deco = r;
    }
    blockAt(e, n, r, i) {
      return new gi(i, this.length, r, this.height, this.deco || 0);
    }
    lineAt(e, n, r, i, o) {
      return this.blockAt(0, r, i, o);
    }
    forEachLine(e, n, r, i, o, s) {
      e <= o + this.length && n >= o && s(this.blockAt(0, r, i, o));
    }
    updateHeight(e, n = 0, r = false, i) {
      return i && i.from <= n && i.more && this.setHeight(i.heights[i.index++]), this.outdated = false, this;
    }
    toString() {
      return `block(${this.length})`;
    }
  }
  class Un extends yR {
    constructor(e, n) {
      super(e, n, null), this.collapsed = 0, this.widgetHeight = 0, this.breaks = 0;
    }
    blockAt(e, n, r, i) {
      return new gi(i, this.length, r, this.height, this.breaks);
    }
    replace(e, n, r) {
      let i = r[0];
      return r.length == 1 && (i instanceof Un || i instanceof Yt && i.flags & 4) && Math.abs(this.length - i.length) < 10 ? (i instanceof Yt ? i = new Un(i.length, this.height) : i.height = this.height, this.outdated || (i.outdated = false), i) : Tn.of(r);
    }
    updateHeight(e, n = 0, r = false, i) {
      return i && i.from <= n && i.more ? this.setHeight(i.heights[i.index++]) : (r || this.outdated) && this.setHeight(Math.max(this.widgetHeight, e.heightForLine(this.length - this.collapsed)) + this.breaks * e.lineHeight), this.outdated = false, this;
    }
    toString() {
      return `line(${this.length}${this.collapsed ? -this.collapsed : ""}${this.widgetHeight ? ":" + this.widgetHeight : ""})`;
    }
  }
  class Yt extends Tn {
    constructor(e) {
      super(e, 0);
    }
    heightMetrics(e, n) {
      let r = e.doc.lineAt(n).number, i = e.doc.lineAt(n + this.length).number, o = i - r + 1, s, a = 0;
      if (e.lineWrapping) {
        let l = Math.min(this.height, e.lineHeight * o);
        s = l / o, this.length > o + 1 && (a = (this.height - l) / (this.length - o - 1));
      } else
        s = this.height / o;
      return {
        firstLine: r,
        lastLine: i,
        perLine: s,
        perChar: a
      };
    }
    blockAt(e, n, r, i) {
      let { firstLine: o, lastLine: s, perLine: a, perChar: l } = this.heightMetrics(n, i);
      if (n.lineWrapping) {
        let c = i + (e < n.lineHeight ? 0 : Math.round(Math.max(0, Math.min(1, (e - r) / this.height)) * this.length)), u = n.doc.lineAt(c), h = a + u.length * l, p = Math.max(r, e - h / 2);
        return new gi(u.from, u.length, p, h, 0);
      } else {
        let c = Math.max(0, Math.min(s - o, Math.floor((e - r) / a))), { from: u, length: h } = n.doc.line(o + c);
        return new gi(u, h, r + a * c, a, 0);
      }
    }
    lineAt(e, n, r, i, o) {
      if (n == at.ByHeight)
        return this.blockAt(e, r, i, o);
      if (n == at.ByPosNoHeight) {
        let { from: v, to: y } = r.doc.lineAt(e);
        return new gi(v, y - v, 0, 0, 0);
      }
      let { firstLine: s, perLine: a, perChar: l } = this.heightMetrics(r, o), c = r.doc.lineAt(e), u = a + c.length * l, h = c.number - s, p = i + a * h + l * (c.from - o - h);
      return new gi(c.from, c.length, Math.max(i, Math.min(p, i + this.height - u)), u, 0);
    }
    forEachLine(e, n, r, i, o, s) {
      e = Math.max(e, o), n = Math.min(n, o + this.length);
      let { firstLine: a, perLine: l, perChar: c } = this.heightMetrics(r, o);
      for (let u = e, h = i; u <= n; ) {
        let p = r.doc.lineAt(u);
        if (u == e) {
          let y = p.number - a;
          h += l * y + c * (e - o - y);
        }
        let v = l + c * p.length;
        s(new gi(p.from, p.length, h, v, 0)), h += v, u = p.to + 1;
      }
    }
    replace(e, n, r) {
      let i = this.length - n;
      if (i > 0) {
        let o = r[r.length - 1];
        o instanceof Yt ? r[r.length - 1] = new Yt(o.length + i) : r.push(null, new Yt(i - 1));
      }
      if (e > 0) {
        let o = r[0];
        o instanceof Yt ? r[0] = new Yt(e + o.length) : r.unshift(new Yt(e - 1), null);
      }
      return Tn.of(r);
    }
    decomposeLeft(e, n) {
      n.push(new Yt(e - 1), null);
    }
    decomposeRight(e, n) {
      n.push(null, new Yt(this.length - e - 1));
    }
    updateHeight(e, n = 0, r = false, i) {
      let o = n + this.length;
      if (i && i.from <= n + this.length && i.more) {
        let s = [], a = Math.max(n, i.from), l = -1;
        for (i.from > n && s.push(new Yt(i.from - n - 1).updateHeight(e, n)); a <= o && i.more; ) {
          let u = e.doc.lineAt(a).length;
          s.length && s.push(null);
          let h = i.heights[i.index++];
          l == -1 ? l = h : Math.abs(h - l) >= Cd && (l = -2);
          let p = new Un(u, h);
          p.outdated = false, s.push(p), a += u + 1;
        }
        a <= o && s.push(null, new Yt(o - a).updateHeight(e, a));
        let c = Tn.of(s);
        return (l < 0 || Math.abs(c.height - this.height) >= Cd || Math.abs(l - this.heightMetrics(e, n).perLine) >= Cd) && (vl = true), Cp(this, c);
      } else
        (r || this.outdated) && (this.setHeight(e.heightForGap(n, n + this.length)), this.outdated = false);
      return this;
    }
    toString() {
      return `gap(${this.length})`;
    }
  }
  class uU extends Tn {
    constructor(e, n, r) {
      super(e.length + n + r.length, e.height + r.height, n | (e.outdated || r.outdated ? 2 : 0)), this.left = e, this.right = r, this.size = e.size + r.size;
    }
    get break() {
      return this.flags & 1;
    }
    blockAt(e, n, r, i) {
      let o = r + this.left.height;
      return e < o ? this.left.blockAt(e, n, r, i) : this.right.blockAt(e, n, o, i + this.left.length + this.break);
    }
    lineAt(e, n, r, i, o) {
      let s = i + this.left.height, a = o + this.left.length + this.break, l = n == at.ByHeight ? e < s : e < a, c = l ? this.left.lineAt(e, n, r, i, o) : this.right.lineAt(e, n, r, s, a);
      if (this.break || (l ? c.to < a : c.from > a))
        return c;
      let u = n == at.ByPosNoHeight ? at.ByPosNoHeight : at.ByPos;
      return l ? c.join(this.right.lineAt(a, u, r, s, a)) : this.left.lineAt(a, u, r, i, o).join(c);
    }
    forEachLine(e, n, r, i, o, s) {
      let a = i + this.left.height, l = o + this.left.length + this.break;
      if (this.break)
        e < l && this.left.forEachLine(e, n, r, i, o, s), n >= l && this.right.forEachLine(e, n, r, a, l, s);
      else {
        let c = this.lineAt(l, at.ByPos, r, i, o);
        e < c.from && this.left.forEachLine(e, c.from - 1, r, i, o, s), c.to >= e && c.from <= n && s(c), n > c.to && this.right.forEachLine(c.to + 1, n, r, a, l, s);
      }
    }
    replace(e, n, r) {
      let i = this.left.length + this.break;
      if (n < i)
        return this.balanced(this.left.replace(e, n, r), this.right);
      if (e > this.left.length)
        return this.balanced(this.left, this.right.replace(e - i, n - i, r));
      let o = [];
      e > 0 && this.decomposeLeft(e, o);
      let s = o.length;
      for (let a of r)
        o.push(a);
      if (e > 0 && GC(o, s - 1), n < this.length) {
        let a = o.length;
        this.decomposeRight(n, o), GC(o, a);
      }
      return Tn.of(o);
    }
    decomposeLeft(e, n) {
      let r = this.left.length;
      if (e <= r)
        return this.left.decomposeLeft(e, n);
      n.push(this.left), this.break && (r++, e >= r && n.push(null)), e > r && this.right.decomposeLeft(e - r, n);
    }
    decomposeRight(e, n) {
      let r = this.left.length, i = r + this.break;
      if (e >= i)
        return this.right.decomposeRight(e - i, n);
      e < r && this.left.decomposeRight(e, n), this.break && e < i && n.push(null), n.push(this.right);
    }
    balanced(e, n) {
      return e.size > 2 * n.size || n.size > 2 * e.size ? Tn.of(this.break ? [
        e,
        null,
        n
      ] : [
        e,
        n
      ]) : (this.left = Cp(this.left, e), this.right = Cp(this.right, n), this.setHeight(e.height + n.height), this.outdated = e.outdated || n.outdated, this.size = e.size + n.size, this.length = e.length + this.break + n.length, this);
    }
    updateHeight(e, n = 0, r = false, i) {
      let { left: o, right: s } = this, a = n + o.length + this.break, l = null;
      return i && i.from <= n + o.length && i.more ? l = o = o.updateHeight(e, n, r, i) : o.updateHeight(e, n, r), i && i.from <= a + s.length && i.more ? l = s = s.updateHeight(e, a, r, i) : s.updateHeight(e, a, r), l ? this.balanced(o, s) : (this.height = this.left.height + this.right.height, this.outdated = false, this);
    }
    toString() {
      return this.left + (this.break ? " " : "-") + this.right;
    }
  }
  function GC(t, e) {
    let n, r;
    t[e] == null && (n = t[e - 1]) instanceof Yt && (r = t[e + 1]) instanceof Yt && t.splice(e - 1, 3, new Yt(n.length + 1 + r.length));
  }
  const fU = 5;
  class Ix {
    constructor(e, n) {
      this.pos = e, this.oracle = n, this.nodes = [], this.lineStart = -1, this.lineEnd = -1, this.covering = null, this.writtenTo = e;
    }
    get isCovered() {
      return this.covering && this.nodes[this.nodes.length - 1] == this.covering;
    }
    span(e, n) {
      if (this.lineStart > -1) {
        let r = Math.min(n, this.lineEnd), i = this.nodes[this.nodes.length - 1];
        i instanceof Un ? i.length += r - this.pos : (r > this.pos || !this.isCovered) && this.nodes.push(new Un(r - this.pos, -1)), this.writtenTo = r, n > r && (this.nodes.push(null), this.writtenTo++, this.lineStart = -1);
      }
      this.pos = n;
    }
    point(e, n, r) {
      if (e < n || r.heightRelevant) {
        let i = r.widget ? r.widget.estimatedHeight : 0, o = r.widget ? r.widget.lineBreaks : 0;
        i < 0 && (i = this.oracle.lineHeight);
        let s = n - e;
        r.block ? this.addBlock(new yR(s, i, r)) : (s || o || i >= fU) && this.addLineDeco(i, o, s);
      } else
        n > e && this.span(e, n);
      this.lineEnd > -1 && this.lineEnd < this.pos && (this.lineEnd = this.oracle.doc.lineAt(this.pos).to);
    }
    enterLine() {
      if (this.lineStart > -1)
        return;
      let { from: e, to: n } = this.oracle.doc.lineAt(this.pos);
      this.lineStart = e, this.lineEnd = n, this.writtenTo < e && ((this.writtenTo < e - 1 || this.nodes[this.nodes.length - 1] == null) && this.nodes.push(this.blankContent(this.writtenTo, e - 1)), this.nodes.push(null)), this.pos > e && this.nodes.push(new Un(this.pos - e, -1)), this.writtenTo = this.pos;
    }
    blankContent(e, n) {
      let r = new Yt(n - e);
      return this.oracle.doc.lineAt(e).to == n && (r.flags |= 4), r;
    }
    ensureLine() {
      this.enterLine();
      let e = this.nodes.length ? this.nodes[this.nodes.length - 1] : null;
      if (e instanceof Un)
        return e;
      let n = new Un(0, -1);
      return this.nodes.push(n), n;
    }
    addBlock(e) {
      this.enterLine();
      let n = e.deco;
      n && n.startSide > 0 && !this.isCovered && this.ensureLine(), this.nodes.push(e), this.writtenTo = this.pos = this.pos + e.length, n && n.endSide > 0 && (this.covering = e);
    }
    addLineDeco(e, n, r) {
      let i = this.ensureLine();
      i.length += r, i.collapsed += r, i.widgetHeight = Math.max(i.widgetHeight, e), i.breaks += n, this.writtenTo = this.pos = this.pos + r;
    }
    finish(e) {
      let n = this.nodes.length == 0 ? null : this.nodes[this.nodes.length - 1];
      this.lineStart > -1 && !(n instanceof Un) && !this.isCovered ? this.nodes.push(new Un(0, -1)) : (this.writtenTo < this.pos || n == null) && this.nodes.push(this.blankContent(this.writtenTo, this.pos));
      let r = e;
      for (let i of this.nodes)
        i instanceof Un && i.updateHeight(this.oracle, r), r += i ? i.length : 1;
      return this.nodes;
    }
    static build(e, n, r, i) {
      let o = new Ix(r, e);
      return Ve.spans(n, r, i, o, 0), o.finish(r);
    }
  }
  function hU(t, e, n) {
    let r = new dU();
    return Ve.compare(t, e, n, r, 0), r.changes;
  }
  class dU {
    constructor() {
      this.changes = [];
    }
    compareRange() {
    }
    comparePoint(e, n, r, i) {
      (e < n || r && r.heightRelevant || i && i.heightRelevant) && kd(e, n, this.changes, 5);
    }
  }
  function pU(t, e) {
    let n = t.getBoundingClientRect(), r = t.ownerDocument, i = r.defaultView || window, o = Math.max(0, n.left), s = Math.min(i.innerWidth, n.right), a = Math.max(0, n.top), l = Math.min(i.innerHeight, n.bottom);
    for (let c = t.parentNode; c && c != r.body; )
      if (c.nodeType == 1) {
        let u = c, h = window.getComputedStyle(u);
        if ((u.scrollHeight > u.clientHeight || u.scrollWidth > u.clientWidth) && h.overflow != "visible") {
          let p = u.getBoundingClientRect();
          o = Math.max(o, p.left), s = Math.min(s, p.right), a = Math.max(a, p.top), l = Math.min(c == t.parentNode ? i.innerHeight : l, p.bottom);
        }
        c = h.position == "absolute" || h.position == "fixed" ? u.offsetParent : u.parentNode;
      } else if (c.nodeType == 11)
        c = c.host;
      else
        break;
    return {
      left: o - n.left,
      right: Math.max(o, s) - n.left,
      top: a - (n.top + e),
      bottom: Math.max(a, l) - (n.top + e)
    };
  }
  function mU(t) {
    let e = t.getBoundingClientRect(), n = t.ownerDocument.defaultView || window;
    return e.left < n.innerWidth && e.right > 0 && e.top < n.innerHeight && e.bottom > 0;
  }
  function gU(t, e) {
    let n = t.getBoundingClientRect();
    return {
      left: 0,
      right: n.right - n.left,
      top: e,
      bottom: n.bottom - (n.top + e)
    };
  }
  class B0 {
    constructor(e, n, r, i) {
      this.from = e, this.to = n, this.size = r, this.displaySize = i;
    }
    static same(e, n) {
      if (e.length != n.length)
        return false;
      for (let r = 0; r < e.length; r++) {
        let i = e[r], o = n[r];
        if (i.from != o.from || i.to != o.to || i.size != o.size)
          return false;
      }
      return true;
    }
    draw(e, n) {
      return be.replace({
        widget: new vU(this.displaySize * (n ? e.scaleY : e.scaleX), n)
      }).range(this.from, this.to);
    }
  }
  class vU extends oo {
    constructor(e, n) {
      super(), this.size = e, this.vertical = n;
    }
    eq(e) {
      return e.size == this.size && e.vertical == this.vertical;
    }
    toDOM() {
      let e = document.createElement("div");
      return this.vertical ? e.style.height = this.size + "px" : (e.style.width = this.size + "px", e.style.height = "2px", e.style.display = "inline-block"), e;
    }
    get estimatedHeight() {
      return this.vertical ? this.size : -1;
    }
  }
  class YC {
    constructor(e) {
      this.state = e, this.pixelViewport = {
        left: 0,
        right: window.innerWidth,
        top: 0,
        bottom: 0
      }, this.inView = true, this.paddingTop = 0, this.paddingBottom = 0, this.contentDOMWidth = 0, this.contentDOMHeight = 0, this.editorHeight = 0, this.editorWidth = 0, this.scrollTop = 0, this.scrolledToBottom = false, this.scaleX = 1, this.scaleY = 1, this.scrollAnchorPos = 0, this.scrollAnchorHeight = -1, this.scaler = XC, this.scrollTarget = null, this.printing = false, this.mustMeasureContent = true, this.defaultTextDirection = rt.LTR, this.visibleRanges = [], this.mustEnforceCursorAssoc = false;
      let n = e.facet(Lx).some((r) => typeof r != "function" && r.class == "cm-lineWrapping");
      this.heightOracle = new lU(n), this.stateDeco = e.facet($u).filter((r) => typeof r != "function"), this.heightMap = Tn.empty().applyChanges(this.stateDeco, He.empty, this.heightOracle.setDoc(e.doc), [
        new xr(0, 0, 0, e.doc.length)
      ]);
      for (let r = 0; r < 2 && (this.viewport = this.getViewport(0, null), !!this.updateForViewport()); r++)
        ;
      this.updateViewportLines(), this.lineGaps = this.ensureLineGaps([]), this.lineGapDeco = be.set(this.lineGaps.map((r) => r.draw(this, false))), this.computeVisibleRanges();
    }
    updateForViewport() {
      let e = [
        this.viewport
      ], { main: n } = this.state.selection;
      for (let r = 0; r <= 1; r++) {
        let i = r ? n.head : n.anchor;
        if (!e.some(({ from: o, to: s }) => i >= o && i <= s)) {
          let { from: o, to: s } = this.lineBlockAt(i);
          e.push(new Eh(o, s));
        }
      }
      return this.viewports = e.sort((r, i) => r.from - i.from), this.updateScaler();
    }
    updateScaler() {
      let e = this.scaler;
      return this.scaler = this.heightMap.height <= 7e6 ? XC : new Bx(this.heightOracle, this.heightMap, this.viewports), e.eq(this.scaler) ? 0 : 2;
    }
    updateViewportLines() {
      this.viewportLines = [], this.heightMap.forEachLine(this.viewport.from, this.viewport.to, this.heightOracle.setDoc(this.state.doc), 0, 0, (e) => {
        this.viewportLines.push(wc(e, this.scaler));
      });
    }
    update(e, n = null) {
      this.state = e.state;
      let r = this.stateDeco;
      this.stateDeco = this.state.facet($u).filter((u) => typeof u != "function");
      let i = e.changedRanges, o = xr.extendWithRanges(i, hU(r, this.stateDeco, e ? e.changes : Dt.empty(this.state.doc.length))), s = this.heightMap.height, a = this.scrolledToBottom ? null : this.scrollAnchorAt(this.scrollTop);
      qC(), this.heightMap = this.heightMap.applyChanges(this.stateDeco, e.startState.doc, this.heightOracle.setDoc(this.state.doc), o), (this.heightMap.height != s || vl) && (e.flags |= 2), a ? (this.scrollAnchorPos = e.changes.mapPos(a.from, -1), this.scrollAnchorHeight = a.top) : (this.scrollAnchorPos = -1, this.scrollAnchorHeight = s);
      let l = o.length ? this.mapViewport(this.viewport, e.changes) : this.viewport;
      (n && (n.range.head < l.from || n.range.head > l.to) || !this.viewportIsAppropriate(l)) && (l = this.getViewport(0, n));
      let c = l.from != this.viewport.from || l.to != this.viewport.to;
      this.viewport = l, e.flags |= this.updateForViewport(), (c || !e.changes.empty || e.flags & 2) && this.updateViewportLines(), (this.lineGaps.length || this.viewport.to - this.viewport.from > 2e3 << 1) && this.updateLineGaps(this.ensureLineGaps(this.mapLineGaps(this.lineGaps, e.changes))), e.flags |= this.computeVisibleRanges(e.changes), n && (this.scrollTarget = n), !this.mustEnforceCursorAssoc && e.selectionSet && e.view.lineWrapping && e.state.selection.main.empty && e.state.selection.main.assoc && !e.state.facet(QO) && (this.mustEnforceCursorAssoc = true);
    }
    measure(e) {
      let n = e.contentDOM, r = window.getComputedStyle(n), i = this.heightOracle, o = r.whiteSpace;
      this.defaultTextDirection = r.direction == "rtl" ? rt.RTL : rt.LTR;
      let s = this.heightOracle.mustRefreshForWrapping(o), a = n.getBoundingClientRect(), l = s || this.mustMeasureContent || this.contentDOMHeight != a.height;
      this.contentDOMHeight = a.height, this.mustMeasureContent = false;
      let c = 0, u = 0;
      if (a.width && a.height) {
        let { scaleX: P, scaleY: R } = MO(n, a);
        (P > 5e-3 && Math.abs(this.scaleX - P) > 5e-3 || R > 5e-3 && Math.abs(this.scaleY - R) > 5e-3) && (this.scaleX = P, this.scaleY = R, c |= 16, s = l = true);
      }
      let h = (parseInt(r.paddingTop) || 0) * this.scaleY, p = (parseInt(r.paddingBottom) || 0) * this.scaleY;
      (this.paddingTop != h || this.paddingBottom != p) && (this.paddingTop = h, this.paddingBottom = p, c |= 18), this.editorWidth != e.scrollDOM.clientWidth && (i.lineWrapping && (l = true), this.editorWidth = e.scrollDOM.clientWidth, c |= 16);
      let v = e.scrollDOM.scrollTop * this.scaleY;
      this.scrollTop != v && (this.scrollAnchorHeight = -1, this.scrollTop = v), this.scrolledToBottom = PO(e.scrollDOM);
      let y = (this.printing ? gU : pU)(n, this.paddingTop), x = y.top - this.pixelViewport.top, T = y.bottom - this.pixelViewport.bottom;
      this.pixelViewport = y;
      let w = this.pixelViewport.bottom > this.pixelViewport.top && this.pixelViewport.right > this.pixelViewport.left;
      if (w != this.inView && (this.inView = w, w && (l = true)), !this.inView && !this.scrollTarget && !mU(e.dom))
        return 0;
      let k = a.width;
      if ((this.contentDOMWidth != k || this.editorHeight != e.scrollDOM.clientHeight) && (this.contentDOMWidth = a.width, this.editorHeight = e.scrollDOM.clientHeight, c |= 16), l) {
        let P = e.docView.measureVisibleLineHeights(this.viewport);
        if (i.mustRefreshForHeights(P) && (s = true), s || i.lineWrapping && Math.abs(k - this.contentDOMWidth) > i.charWidth) {
          let { lineHeight: R, charWidth: L, textHeight: _ } = e.docView.measureTextSize();
          s = R > 0 && i.refresh(o, R, L, _, Math.max(5, k / L), P), s && (e.docView.minWidth = 0, c |= 16);
        }
        x > 0 && T > 0 ? u = Math.max(x, T) : x < 0 && T < 0 && (u = Math.min(x, T)), qC();
        for (let R of this.viewports) {
          let L = R.from == this.viewport.from ? P : e.docView.measureVisibleLineHeights(R);
          this.heightMap = (s ? Tn.empty().applyChanges(this.stateDeco, He.empty, this.heightOracle, [
            new xr(0, 0, 0, e.state.doc.length)
          ]) : this.heightMap).updateHeight(i, 0, s, new cU(R.from, L));
        }
        vl && (c |= 2);
      }
      let C = !this.viewportIsAppropriate(this.viewport, u) || this.scrollTarget && (this.scrollTarget.range.head < this.viewport.from || this.scrollTarget.range.head > this.viewport.to);
      return C && (c & 2 && (c |= this.updateScaler()), this.viewport = this.getViewport(u, this.scrollTarget), c |= this.updateForViewport()), (c & 2 || C) && this.updateViewportLines(), (this.lineGaps.length || this.viewport.to - this.viewport.from > 2e3 << 1) && this.updateLineGaps(this.ensureLineGaps(s ? [] : this.lineGaps, e)), c |= this.computeVisibleRanges(), this.mustEnforceCursorAssoc && (this.mustEnforceCursorAssoc = false, e.docView.enforceCursorAssoc()), c;
    }
    get visibleTop() {
      return this.scaler.fromDOM(this.pixelViewport.top);
    }
    get visibleBottom() {
      return this.scaler.fromDOM(this.pixelViewport.bottom);
    }
    getViewport(e, n) {
      let r = 0.5 - Math.max(-0.5, Math.min(0.5, e / 1e3 / 2)), i = this.heightMap, o = this.heightOracle, { visibleTop: s, visibleBottom: a } = this, l = new Eh(i.lineAt(s - r * 1e3, at.ByHeight, o, 0, 0).from, i.lineAt(a + (1 - r) * 1e3, at.ByHeight, o, 0, 0).to);
      if (n) {
        let { head: c } = n.range;
        if (c < l.from || c > l.to) {
          let u = Math.min(this.editorHeight, this.pixelViewport.bottom - this.pixelViewport.top), h = i.lineAt(c, at.ByPos, o, 0, 0), p;
          n.y == "center" ? p = (h.top + h.bottom) / 2 - u / 2 : n.y == "start" || n.y == "nearest" && c < l.from ? p = h.top : p = h.bottom - u, l = new Eh(i.lineAt(p - 1e3 / 2, at.ByHeight, o, 0, 0).from, i.lineAt(p + u + 1e3 / 2, at.ByHeight, o, 0, 0).to);
        }
      }
      return l;
    }
    mapViewport(e, n) {
      let r = n.mapPos(e.from, -1), i = n.mapPos(e.to, 1);
      return new Eh(this.heightMap.lineAt(r, at.ByPos, this.heightOracle, 0, 0).from, this.heightMap.lineAt(i, at.ByPos, this.heightOracle, 0, 0).to);
    }
    viewportIsAppropriate({ from: e, to: n }, r = 0) {
      if (!this.inView)
        return true;
      let { top: i } = this.heightMap.lineAt(e, at.ByPos, this.heightOracle, 0, 0), { bottom: o } = this.heightMap.lineAt(n, at.ByPos, this.heightOracle, 0, 0), { visibleTop: s, visibleBottom: a } = this;
      return (e == 0 || i <= s - Math.max(10, Math.min(-r, 250))) && (n == this.state.doc.length || o >= a + Math.max(10, Math.min(r, 250))) && i > s - 2 * 1e3 && o < a + 2 * 1e3;
    }
    mapLineGaps(e, n) {
      if (!e.length || n.empty)
        return e;
      let r = [];
      for (let i of e)
        n.touchesRange(i.from, i.to) || r.push(new B0(n.mapPos(i.from), n.mapPos(i.to), i.size, i.displaySize));
      return r;
    }
    ensureLineGaps(e, n) {
      let r = this.heightOracle.lineWrapping, i = r ? 1e4 : 2e3, o = i >> 1, s = i << 1;
      if (this.defaultTextDirection != rt.LTR && !r)
        return [];
      let a = [], l = (u, h, p, v) => {
        if (h - u < o)
          return;
        let y = this.state.selection.main, x = [
          y.from
        ];
        y.empty || x.push(y.to);
        for (let w of x)
          if (w > u && w < h) {
            l(u, w - 10, p, v), l(w + 10, h, p, v);
            return;
          }
        let T = bU(e, (w) => w.from >= p.from && w.to <= p.to && Math.abs(w.from - u) < o && Math.abs(w.to - h) < o && !x.some((k) => w.from < k && w.to > k));
        if (!T) {
          if (h < p.to && n && r && n.visibleRanges.some((C) => C.from <= h && C.to >= h)) {
            let C = n.moveToLineBoundary(q.cursor(h), false, true).head;
            C > u && (h = C);
          }
          let w = this.gapSize(p, u, h, v), k = r || w < 2e6 ? w : 2e6;
          T = new B0(u, h, w, k);
        }
        a.push(T);
      }, c = (u) => {
        if (u.length < s || u.type != Cn.Text)
          return;
        let h = yU(u.from, u.to, this.stateDeco);
        if (h.total < s)
          return;
        let p = this.scrollTarget ? this.scrollTarget.range.head : null, v, y;
        if (r) {
          let x = i / this.heightOracle.lineLength * this.heightOracle.lineHeight, T, w;
          if (p != null) {
            let k = Oh(h, p), C = ((this.visibleBottom - this.visibleTop) / 2 + x) / u.height;
            T = k - C, w = k + C;
          } else
            T = (this.visibleTop - u.top - x) / u.height, w = (this.visibleBottom - u.top + x) / u.height;
          v = Ph(h, T), y = Ph(h, w);
        } else {
          let x = h.total * this.heightOracle.charWidth, T = i * this.heightOracle.charWidth, w = 0;
          if (x > 2e6)
            for (let L of e)
              L.from >= u.from && L.from < u.to && L.size != L.displaySize && L.from * this.heightOracle.charWidth + w < this.pixelViewport.left && (w = L.size - L.displaySize);
          let k = this.pixelViewport.left + w, C = this.pixelViewport.right + w, P, R;
          if (p != null) {
            let L = Oh(h, p), _ = ((C - k) / 2 + T) / x;
            P = L - _, R = L + _;
          } else
            P = (k - T) / x, R = (C + T) / x;
          v = Ph(h, P), y = Ph(h, R);
        }
        v > u.from && l(u.from, v, u, h), y < u.to && l(y, u.to, u, h);
      };
      for (let u of this.viewportLines)
        Array.isArray(u.type) ? u.type.forEach(c) : c(u);
      return a;
    }
    gapSize(e, n, r, i) {
      let o = Oh(i, r) - Oh(i, n);
      return this.heightOracle.lineWrapping ? e.height * o : i.total * this.heightOracle.charWidth * o;
    }
    updateLineGaps(e) {
      B0.same(e, this.lineGaps) || (this.lineGaps = e, this.lineGapDeco = be.set(e.map((n) => n.draw(this, this.heightOracle.lineWrapping))));
    }
    computeVisibleRanges(e) {
      let n = this.stateDeco;
      this.lineGaps.length && (n = n.concat(this.lineGapDeco));
      let r = [];
      Ve.spans(n, this.viewport.from, this.viewport.to, {
        span(o, s) {
          r.push({
            from: o,
            to: s
          });
        },
        point() {
        }
      }, 20);
      let i = 0;
      if (r.length != this.visibleRanges.length)
        i = 12;
      else
        for (let o = 0; o < r.length && !(i & 8); o++) {
          let s = this.visibleRanges[o], a = r[o];
          (s.from != a.from || s.to != a.to) && (i |= 4, e && e.mapPos(s.from, -1) == a.from && e.mapPos(s.to, 1) == a.to || (i |= 8));
        }
      return this.visibleRanges = r, i;
    }
    lineBlockAt(e) {
      return e >= this.viewport.from && e <= this.viewport.to && this.viewportLines.find((n) => n.from <= e && n.to >= e) || wc(this.heightMap.lineAt(e, at.ByPos, this.heightOracle, 0, 0), this.scaler);
    }
    lineBlockAtHeight(e) {
      return e >= this.viewportLines[0].top && e <= this.viewportLines[this.viewportLines.length - 1].bottom && this.viewportLines.find((n) => n.top <= e && n.bottom >= e) || wc(this.heightMap.lineAt(this.scaler.fromDOM(e), at.ByHeight, this.heightOracle, 0, 0), this.scaler);
    }
    scrollAnchorAt(e) {
      let n = this.lineBlockAtHeight(e + 8);
      return n.from >= this.viewport.from || this.viewportLines[0].top - e > 200 ? n : this.viewportLines[0];
    }
    elementAtHeight(e) {
      return wc(this.heightMap.blockAt(this.scaler.fromDOM(e), this.heightOracle, 0, 0), this.scaler);
    }
    get docHeight() {
      return this.scaler.toDOM(this.heightMap.height);
    }
    get contentHeight() {
      return this.docHeight + this.paddingTop + this.paddingBottom;
    }
  }
  class Eh {
    constructor(e, n) {
      this.from = e, this.to = n;
    }
  }
  function yU(t, e, n) {
    let r = [], i = t, o = 0;
    return Ve.spans(n, t, e, {
      span() {
      },
      point(s, a) {
        s > i && (r.push({
          from: i,
          to: s
        }), o += s - i), i = a;
      }
    }, 20), i < e && (r.push({
      from: i,
      to: e
    }), o += e - i), {
      total: o,
      ranges: r
    };
  }
  function Ph({ total: t, ranges: e }, n) {
    if (n <= 0)
      return e[0].from;
    if (n >= 1)
      return e[e.length - 1].to;
    let r = Math.floor(t * n);
    for (let i = 0; ; i++) {
      let { from: o, to: s } = e[i], a = s - o;
      if (r <= a)
        return o + r;
      r -= a;
    }
  }
  function Oh(t, e) {
    let n = 0;
    for (let { from: r, to: i } of t.ranges) {
      if (e <= i) {
        n += e - r;
        break;
      }
      n += i - r;
    }
    return n / t.total;
  }
  function bU(t, e) {
    for (let n of t)
      if (e(n))
        return n;
  }
  const XC = {
    toDOM(t) {
      return t;
    },
    fromDOM(t) {
      return t;
    },
    scale: 1,
    eq(t) {
      return t == this;
    }
  };
  class Bx {
    constructor(e, n, r) {
      let i = 0, o = 0, s = 0;
      this.viewports = r.map(({ from: a, to: l }) => {
        let c = n.lineAt(a, at.ByPos, e, 0, 0).top, u = n.lineAt(l, at.ByPos, e, 0, 0).bottom;
        return i += u - c, {
          from: a,
          to: l,
          top: c,
          bottom: u,
          domTop: 0,
          domBottom: 0
        };
      }), this.scale = (7e6 - i) / (n.height - i);
      for (let a of this.viewports)
        a.domTop = s + (a.top - o) * this.scale, s = a.domBottom = a.domTop + (a.bottom - a.top), o = a.bottom;
    }
    toDOM(e) {
      for (let n = 0, r = 0, i = 0; ; n++) {
        let o = n < this.viewports.length ? this.viewports[n] : null;
        if (!o || e < o.top)
          return i + (e - r) * this.scale;
        if (e <= o.bottom)
          return o.domTop + (e - o.top);
        r = o.bottom, i = o.domBottom;
      }
    }
    fromDOM(e) {
      for (let n = 0, r = 0, i = 0; ; n++) {
        let o = n < this.viewports.length ? this.viewports[n] : null;
        if (!o || e < o.domTop)
          return r + (e - i) / this.scale;
        if (e <= o.domBottom)
          return o.top + (e - o.domTop);
        r = o.bottom, i = o.domBottom;
      }
    }
    eq(e) {
      return e instanceof Bx ? this.scale == e.scale && this.viewports.length == e.viewports.length && this.viewports.every((n, r) => n.from == e.viewports[r].from && n.to == e.viewports[r].to) : false;
    }
  }
  function wc(t, e) {
    if (e.scale == 1)
      return t;
    let n = e.toDOM(t.top), r = e.toDOM(t.bottom);
    return new gi(t.from, t.length, n, r - n, Array.isArray(t._content) ? t._content.map((i) => wc(i, e)) : t._content);
  }
  const Rh = me.define({
    combine: (t) => t.join(" ")
  }), c1 = me.define({
    combine: (t) => t.indexOf(true) > -1
  }), u1 = qo.newName(), bR = qo.newName(), xR = qo.newName(), SR = {
    "&light": "." + bR,
    "&dark": "." + xR
  };
  function f1(t, e, n) {
    return new qo(e, {
      finish(r) {
        return /&/.test(r) ? r.replace(/&\w*/, (i) => {
          if (i == "&")
            return t;
          if (!n || !n[i])
            throw new RangeError(`Unsupported selector: ${i}`);
          return n[i];
        }) : t + " " + r;
      }
    });
  }
  const xU = f1("." + u1, {
    "&": {
      position: "relative !important",
      boxSizing: "border-box",
      "&.cm-focused": {
        outline: "1px dotted #212121"
      },
      display: "flex !important",
      flexDirection: "column"
    },
    ".cm-scroller": {
      display: "flex !important",
      alignItems: "flex-start !important",
      fontFamily: "monospace",
      lineHeight: 1.4,
      height: "100%",
      overflowX: "auto",
      position: "relative",
      zIndex: 0,
      overflowAnchor: "none"
    },
    ".cm-content": {
      margin: 0,
      flexGrow: 2,
      flexShrink: 0,
      display: "block",
      whiteSpace: "pre",
      wordWrap: "normal",
      boxSizing: "border-box",
      minHeight: "100%",
      padding: "4px 0",
      outline: "none",
      "&[contenteditable=true]": {
        WebkitUserModify: "read-write-plaintext-only"
      }
    },
    ".cm-lineWrapping": {
      whiteSpace_fallback: "pre-wrap",
      whiteSpace: "break-spaces",
      wordBreak: "break-word",
      overflowWrap: "anywhere",
      flexShrink: 1
    },
    "&light .cm-content": {
      caretColor: "black"
    },
    "&dark .cm-content": {
      caretColor: "white"
    },
    ".cm-line": {
      display: "block",
      padding: "0 2px 0 6px"
    },
    ".cm-layer": {
      position: "absolute",
      left: 0,
      top: 0,
      contain: "size style",
      "& > *": {
        position: "absolute"
      }
    },
    "&light .cm-selectionBackground": {
      background: "#d9d9d9"
    },
    "&dark .cm-selectionBackground": {
      background: "#222"
    },
    "&light.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground": {
      background: "#d7d4f0"
    },
    "&dark.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground": {
      background: "#233"
    },
    ".cm-cursorLayer": {
      pointerEvents: "none"
    },
    "&.cm-focused > .cm-scroller > .cm-cursorLayer": {
      animation: "steps(1) cm-blink 1.2s infinite"
    },
    "@keyframes cm-blink": {
      "0%": {},
      "50%": {
        opacity: 0
      },
      "100%": {}
    },
    "@keyframes cm-blink2": {
      "0%": {},
      "50%": {
        opacity: 0
      },
      "100%": {}
    },
    ".cm-cursor, .cm-dropCursor": {
      borderLeft: "1.2px solid black",
      marginLeft: "-0.6px",
      pointerEvents: "none"
    },
    ".cm-cursor": {
      display: "none"
    },
    "&dark .cm-cursor": {
      borderLeftColor: "#ddd"
    },
    ".cm-dropCursor": {
      position: "absolute"
    },
    "&.cm-focused > .cm-scroller > .cm-cursorLayer .cm-cursor": {
      display: "block"
    },
    ".cm-iso": {
      unicodeBidi: "isolate"
    },
    ".cm-announced": {
      position: "fixed",
      top: "-10000px"
    },
    "@media print": {
      ".cm-announced": {
        display: "none"
      }
    },
    "&light .cm-activeLine": {
      backgroundColor: "#cceeff44"
    },
    "&dark .cm-activeLine": {
      backgroundColor: "#99eeff33"
    },
    "&light .cm-specialChar": {
      color: "red"
    },
    "&dark .cm-specialChar": {
      color: "#f78"
    },
    ".cm-gutters": {
      flexShrink: 0,
      display: "flex",
      height: "100%",
      boxSizing: "border-box",
      zIndex: 200
    },
    ".cm-gutters-before": {
      insetInlineStart: 0
    },
    ".cm-gutters-after": {
      insetInlineEnd: 0
    },
    "&light .cm-gutters": {
      backgroundColor: "#f5f5f5",
      color: "#6c6c6c",
      border: "0px solid #ddd",
      "&.cm-gutters-before": {
        borderRightWidth: "1px"
      },
      "&.cm-gutters-after": {
        borderLeftWidth: "1px"
      }
    },
    "&dark .cm-gutters": {
      backgroundColor: "#333338",
      color: "#ccc"
    },
    ".cm-gutter": {
      display: "flex !important",
      flexDirection: "column",
      flexShrink: 0,
      boxSizing: "border-box",
      minHeight: "100%",
      overflow: "hidden"
    },
    ".cm-gutterElement": {
      boxSizing: "border-box"
    },
    ".cm-lineNumbers .cm-gutterElement": {
      padding: "0 3px 0 5px",
      minWidth: "20px",
      textAlign: "right",
      whiteSpace: "nowrap"
    },
    "&light .cm-activeLineGutter": {
      backgroundColor: "#e2f2ff"
    },
    "&dark .cm-activeLineGutter": {
      backgroundColor: "#222227"
    },
    ".cm-panels": {
      boxSizing: "border-box",
      position: "sticky",
      left: 0,
      right: 0,
      zIndex: 300
    },
    "&light .cm-panels": {
      backgroundColor: "#f5f5f5",
      color: "black"
    },
    "&light .cm-panels-top": {
      borderBottom: "1px solid #ddd"
    },
    "&light .cm-panels-bottom": {
      borderTop: "1px solid #ddd"
    },
    "&dark .cm-panels": {
      backgroundColor: "#333338",
      color: "white"
    },
    ".cm-dialog": {
      padding: "2px 19px 4px 6px",
      position: "relative",
      "& label": {
        fontSize: "80%"
      }
    },
    ".cm-dialog-close": {
      position: "absolute",
      top: "3px",
      right: "4px",
      backgroundColor: "inherit",
      border: "none",
      font: "inherit",
      fontSize: "14px",
      padding: "0"
    },
    ".cm-tab": {
      display: "inline-block",
      overflow: "hidden",
      verticalAlign: "bottom"
    },
    ".cm-widgetBuffer": {
      verticalAlign: "text-top",
      height: "1em",
      width: 0,
      display: "inline"
    },
    ".cm-placeholder": {
      color: "#888",
      display: "inline-block",
      verticalAlign: "top",
      userSelect: "none"
    },
    ".cm-highlightSpace": {
      backgroundImage: "radial-gradient(circle at 50% 55%, #aaa 20%, transparent 5%)",
      backgroundPosition: "center"
    },
    ".cm-highlightTab": {
      backgroundImage: `url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="200" height="20"><path stroke="%23888" stroke-width="1" fill="none" d="M1 10H196L190 5M190 15L196 10M197 4L197 16"/></svg>')`,
      backgroundSize: "auto 100%",
      backgroundPosition: "right 90%",
      backgroundRepeat: "no-repeat"
    },
    ".cm-trailingSpace": {
      backgroundColor: "#ff332255"
    },
    ".cm-button": {
      verticalAlign: "middle",
      color: "inherit",
      fontSize: "70%",
      padding: ".2em 1em",
      borderRadius: "1px"
    },
    "&light .cm-button": {
      backgroundImage: "linear-gradient(#eff1f5, #d9d9df)",
      border: "1px solid #888",
      "&:active": {
        backgroundImage: "linear-gradient(#b4b4b4, #d0d3d6)"
      }
    },
    "&dark .cm-button": {
      backgroundImage: "linear-gradient(#393939, #111)",
      border: "1px solid #888",
      "&:active": {
        backgroundImage: "linear-gradient(#111, #333)"
      }
    },
    ".cm-textfield": {
      verticalAlign: "middle",
      color: "inherit",
      fontSize: "70%",
      border: "1px solid silver",
      padding: ".2em .5em"
    },
    "&light .cm-textfield": {
      backgroundColor: "white"
    },
    "&dark .cm-textfield": {
      border: "1px solid #555",
      backgroundColor: "inherit"
    }
  }, SR), SU = {
    childList: true,
    characterData: true,
    subtree: true,
    attributes: true,
    characterDataOldValue: true
  }, N0 = fe.ie && fe.ie_version <= 11;
  class wU {
    constructor(e) {
      this.view = e, this.active = false, this.editContext = null, this.selectionRange = new i7(), this.selectionChanged = false, this.delayedFlush = -1, this.resizeTimeout = -1, this.queue = [], this.delayedAndroidKey = null, this.flushingAndroidKey = -1, this.lastChange = 0, this.scrollTargets = [], this.intersection = null, this.resizeScroll = null, this.intersecting = false, this.gapIntersection = null, this.gaps = [], this.printQuery = null, this.parentCheck = -1, this.dom = e.contentDOM, this.observer = new MutationObserver((n) => {
        for (let r of n)
          this.queue.push(r);
        (fe.ie && fe.ie_version <= 11 || fe.ios && e.composing) && n.some((r) => r.type == "childList" && r.removedNodes.length || r.type == "characterData" && r.oldValue.length > r.target.nodeValue.length) ? this.flushSoon() : this.flush();
      }), window.EditContext && fe.android && e.constructor.EDIT_CONTEXT !== false && !(fe.chrome && fe.chrome_version < 126) && (this.editContext = new CU(e), e.state.facet(Vi) && (e.contentDOM.editContext = this.editContext.editContext)), N0 && (this.onCharData = (n) => {
        this.queue.push({
          target: n.target,
          type: "characterData",
          oldValue: n.prevValue
        }), this.flushSoon();
      }), this.onSelectionChange = this.onSelectionChange.bind(this), this.onResize = this.onResize.bind(this), this.onPrint = this.onPrint.bind(this), this.onScroll = this.onScroll.bind(this), window.matchMedia && (this.printQuery = window.matchMedia("print")), typeof ResizeObserver == "function" && (this.resizeScroll = new ResizeObserver(() => {
        var n;
        ((n = this.view.docView) === null || n === void 0 ? void 0 : n.lastUpdate) < Date.now() - 75 && this.onResize();
      }), this.resizeScroll.observe(e.scrollDOM)), this.addWindowListeners(this.win = e.win), this.start(), typeof IntersectionObserver == "function" && (this.intersection = new IntersectionObserver((n) => {
        this.parentCheck < 0 && (this.parentCheck = setTimeout(this.listenForScroll.bind(this), 1e3)), n.length > 0 && n[n.length - 1].intersectionRatio > 0 != this.intersecting && (this.intersecting = !this.intersecting, this.intersecting != this.view.inView && this.onScrollChanged(document.createEvent("Event")));
      }, {
        threshold: [
          0,
          1e-3
        ]
      }), this.intersection.observe(this.dom), this.gapIntersection = new IntersectionObserver((n) => {
        n.length > 0 && n[n.length - 1].intersectionRatio > 0 && this.onScrollChanged(document.createEvent("Event"));
      }, {})), this.listenForScroll(), this.readSelectionRange();
    }
    onScrollChanged(e) {
      this.view.inputState.runHandlers("scroll", e), this.intersecting && this.view.measure();
    }
    onScroll(e) {
      this.intersecting && this.flush(false), this.editContext && this.view.requestMeasure(this.editContext.measureReq), this.onScrollChanged(e);
    }
    onResize() {
      this.resizeTimeout < 0 && (this.resizeTimeout = setTimeout(() => {
        this.resizeTimeout = -1, this.view.requestMeasure();
      }, 50));
    }
    onPrint(e) {
      (e.type == "change" || !e.type) && !e.matches || (this.view.viewState.printing = true, this.view.measure(), setTimeout(() => {
        this.view.viewState.printing = false, this.view.requestMeasure();
      }, 500));
    }
    updateGaps(e) {
      if (this.gapIntersection && (e.length != this.gaps.length || this.gaps.some((n, r) => n != e[r]))) {
        this.gapIntersection.disconnect();
        for (let n of e)
          this.gapIntersection.observe(n);
        this.gaps = e;
      }
    }
    onSelectionChange(e) {
      let n = this.selectionChanged;
      if (!this.readSelectionRange() || this.delayedAndroidKey)
        return;
      let { view: r } = this, i = this.selectionRange;
      if (r.state.facet(Vi) ? r.root.activeElement != this.dom : !wd(this.dom, i))
        return;
      let o = i.anchorNode && r.docView.nearest(i.anchorNode);
      if (o && o.ignoreEvent(e)) {
        n || (this.selectionChanged = false);
        return;
      }
      (fe.ie && fe.ie_version <= 11 || fe.android && fe.chrome) && !r.state.selection.main.empty && i.focusNode && Qc(i.focusNode, i.focusOffset, i.anchorNode, i.anchorOffset) ? this.flushSoon() : this.flush(false);
    }
    readSelectionRange() {
      let { view: e } = this, n = Nu(e.root);
      if (!n)
        return false;
      let r = fe.safari && e.root.nodeType == 11 && e.root.activeElement == this.dom && kU(this.view, n) || n;
      if (!r || this.selectionRange.eq(r))
        return false;
      let i = wd(this.dom, r);
      return i && !this.selectionChanged && e.inputState.lastFocusTime > Date.now() - 200 && e.inputState.lastTouchTime < Date.now() - 300 && s7(this.dom, r) ? (this.view.inputState.lastFocusTime = 0, e.docView.updateSelection(), false) : (this.selectionRange.setRange(r), i && (this.selectionChanged = true), true);
    }
    setSelectionRange(e, n) {
      this.selectionRange.set(e.node, e.offset, n.node, n.offset), this.selectionChanged = false;
    }
    clearSelectionRange() {
      this.selectionRange.set(null, 0, null, 0);
    }
    listenForScroll() {
      this.parentCheck = -1;
      let e = 0, n = null;
      for (let r = this.dom; r; )
        if (r.nodeType == 1)
          !n && e < this.scrollTargets.length && this.scrollTargets[e] == r ? e++ : n || (n = this.scrollTargets.slice(0, e)), n && n.push(r), r = r.assignedSlot || r.parentNode;
        else if (r.nodeType == 11)
          r = r.host;
        else
          break;
      if (e < this.scrollTargets.length && !n && (n = this.scrollTargets.slice(0, e)), n) {
        for (let r of this.scrollTargets)
          r.removeEventListener("scroll", this.onScroll);
        for (let r of this.scrollTargets = n)
          r.addEventListener("scroll", this.onScroll);
      }
    }
    ignore(e) {
      if (!this.active)
        return e();
      try {
        return this.stop(), e();
      } finally {
        this.start(), this.clear();
      }
    }
    start() {
      this.active || (this.observer.observe(this.dom, SU), N0 && this.dom.addEventListener("DOMCharacterDataModified", this.onCharData), this.active = true);
    }
    stop() {
      !this.active || (this.active = false, this.observer.disconnect(), N0 && this.dom.removeEventListener("DOMCharacterDataModified", this.onCharData));
    }
    clear() {
      this.processRecords(), this.queue.length = 0, this.selectionChanged = false;
    }
    delayAndroidKey(e, n) {
      var r;
      if (!this.delayedAndroidKey) {
        let i = () => {
          let o = this.delayedAndroidKey;
          o && (this.clearDelayedAndroidKey(), this.view.inputState.lastKeyCode = o.keyCode, this.view.inputState.lastKeyTime = Date.now(), !this.flush() && o.force && Xa(this.dom, o.key, o.keyCode));
        };
        this.flushingAndroidKey = this.view.win.requestAnimationFrame(i);
      }
      (!this.delayedAndroidKey || e == "Enter") && (this.delayedAndroidKey = {
        key: e,
        keyCode: n,
        force: this.lastChange < Date.now() - 50 || !!(!((r = this.delayedAndroidKey) === null || r === void 0) && r.force)
      });
    }
    clearDelayedAndroidKey() {
      this.win.cancelAnimationFrame(this.flushingAndroidKey), this.delayedAndroidKey = null, this.flushingAndroidKey = -1;
    }
    flushSoon() {
      this.delayedFlush < 0 && (this.delayedFlush = this.view.win.requestAnimationFrame(() => {
        this.delayedFlush = -1, this.flush();
      }));
    }
    forceFlush() {
      this.delayedFlush >= 0 && (this.view.win.cancelAnimationFrame(this.delayedFlush), this.delayedFlush = -1), this.flush();
    }
    pendingRecords() {
      for (let e of this.observer.takeRecords())
        this.queue.push(e);
      return this.queue;
    }
    processRecords() {
      let e = this.pendingRecords();
      e.length && (this.queue = []);
      let n = -1, r = -1, i = false;
      for (let o of e) {
        let s = this.readMutation(o);
        !s || (s.typeOver && (i = true), n == -1 ? { from: n, to: r } = s : (n = Math.min(s.from, n), r = Math.max(s.to, r)));
      }
      return {
        from: n,
        to: r,
        typeOver: i
      };
    }
    readChange() {
      let { from: e, to: n, typeOver: r } = this.processRecords(), i = this.selectionChanged && wd(this.dom, this.selectionRange);
      if (e < 0 && !i)
        return null;
      e > -1 && (this.lastChange = Date.now()), this.view.inputState.lastFocusTime = 0, this.selectionChanged = false;
      let o = new V7(this.view, e, n, r);
      return this.view.docView.domChanged = {
        newSel: o.newSel ? o.newSel.main : null
      }, o;
    }
    flush(e = true) {
      if (this.delayedFlush >= 0 || this.delayedAndroidKey)
        return false;
      e && this.readSelectionRange();
      let n = this.readChange();
      if (!n)
        return this.view.requestMeasure(), false;
      let r = this.view.state, i = lR(this.view, n);
      return this.view.state == r && (n.domChanged || n.newSel && !n.newSel.main.eq(this.view.state.selection.main)) && this.view.update([]), i;
    }
    readMutation(e) {
      let n = this.view.docView.nearest(e.target);
      if (!n || n.ignoreMutation(e))
        return null;
      if (n.markDirty(e.type == "attributes"), e.type == "attributes" && (n.flags |= 4), e.type == "childList") {
        let r = QC(n, e.previousSibling || e.target.previousSibling, -1), i = QC(n, e.nextSibling || e.target.nextSibling, 1);
        return {
          from: r ? n.posAfter(r) : n.posAtStart,
          to: i ? n.posBefore(i) : n.posAtEnd,
          typeOver: false
        };
      } else
        return e.type == "characterData" ? {
          from: n.posAtStart,
          to: n.posAtEnd,
          typeOver: e.target.nodeValue == e.oldValue
        } : null;
    }
    setWindow(e) {
      e != this.win && (this.removeWindowListeners(this.win), this.win = e, this.addWindowListeners(this.win));
    }
    addWindowListeners(e) {
      e.addEventListener("resize", this.onResize), this.printQuery ? this.printQuery.addEventListener ? this.printQuery.addEventListener("change", this.onPrint) : this.printQuery.addListener(this.onPrint) : e.addEventListener("beforeprint", this.onPrint), e.addEventListener("scroll", this.onScroll), e.document.addEventListener("selectionchange", this.onSelectionChange);
    }
    removeWindowListeners(e) {
      e.removeEventListener("scroll", this.onScroll), e.removeEventListener("resize", this.onResize), this.printQuery ? this.printQuery.removeEventListener ? this.printQuery.removeEventListener("change", this.onPrint) : this.printQuery.removeListener(this.onPrint) : e.removeEventListener("beforeprint", this.onPrint), e.document.removeEventListener("selectionchange", this.onSelectionChange);
    }
    update(e) {
      this.editContext && (this.editContext.update(e), e.startState.facet(Vi) != e.state.facet(Vi) && (e.view.contentDOM.editContext = e.state.facet(Vi) ? this.editContext.editContext : null));
    }
    destroy() {
      var e, n, r;
      this.stop(), (e = this.intersection) === null || e === void 0 || e.disconnect(), (n = this.gapIntersection) === null || n === void 0 || n.disconnect(), (r = this.resizeScroll) === null || r === void 0 || r.disconnect();
      for (let i of this.scrollTargets)
        i.removeEventListener("scroll", this.onScroll);
      this.removeWindowListeners(this.win), clearTimeout(this.parentCheck), clearTimeout(this.resizeTimeout), this.win.cancelAnimationFrame(this.delayedFlush), this.win.cancelAnimationFrame(this.flushingAndroidKey), this.editContext && (this.view.contentDOM.editContext = null, this.editContext.destroy());
    }
  }
  function QC(t, e, n) {
    for (; e; ) {
      let r = Qe.get(e);
      if (r && r.parent == t)
        return r;
      let i = e.parentNode;
      e = i != t.dom ? i : n > 0 ? e.nextSibling : e.previousSibling;
    }
    return null;
  }
  function JC(t, e) {
    let n = e.startContainer, r = e.startOffset, i = e.endContainer, o = e.endOffset, s = t.docView.domAtPos(t.state.selection.main.anchor);
    return Qc(s.node, s.offset, i, o) && ([n, r, i, o] = [
      i,
      o,
      n,
      r
    ]), {
      anchorNode: n,
      anchorOffset: r,
      focusNode: i,
      focusOffset: o
    };
  }
  function kU(t, e) {
    if (e.getComposedRanges) {
      let i = e.getComposedRanges(t.root)[0];
      if (i)
        return JC(t, i);
    }
    let n = null;
    function r(i) {
      i.preventDefault(), i.stopImmediatePropagation(), n = i.getTargetRanges()[0];
    }
    return t.contentDOM.addEventListener("beforeinput", r, true), t.dom.ownerDocument.execCommand("indent"), t.contentDOM.removeEventListener("beforeinput", r, true), n ? JC(t, n) : null;
  }
  class CU {
    constructor(e) {
      this.from = 0, this.to = 0, this.pendingContextChange = null, this.handlers = /* @__PURE__ */ Object.create(null), this.composing = null, this.resetRange(e.state);
      let n = this.editContext = new window.EditContext({
        text: e.state.doc.sliceString(this.from, this.to),
        selectionStart: this.toContextPos(Math.max(this.from, Math.min(this.to, e.state.selection.main.anchor))),
        selectionEnd: this.toContextPos(e.state.selection.main.head)
      });
      this.handlers.textupdate = (r) => {
        let i = e.state.selection.main, { anchor: o, head: s } = i, a = this.toEditorPos(r.updateRangeStart), l = this.toEditorPos(r.updateRangeEnd);
        e.inputState.composing >= 0 && !this.composing && (this.composing = {
          contextBase: r.updateRangeStart,
          editorBase: a,
          drifted: false
        });
        let c = l - a > r.text.length;
        a == this.from && o < this.from ? a = o : l == this.to && o > this.to && (l = o);
        let u = cR(e.state.sliceDoc(a, l), r.text, (c ? i.from : i.to) - a, c ? "end" : null);
        if (!u) {
          let p = q.single(this.toEditorPos(r.selectionStart), this.toEditorPos(r.selectionEnd));
          p.main.eq(i) || e.dispatch({
            selection: p,
            userEvent: "select"
          });
          return;
        }
        let h = {
          from: u.from + a,
          to: u.toA + a,
          insert: He.of(r.text.slice(u.from, u.toB).split(`
`))
        };
        if ((fe.mac || fe.android) && h.from == s - 1 && /^\. ?$/.test(r.text) && e.contentDOM.getAttribute("autocorrect") == "off" && (h = {
          from: a,
          to: l,
          insert: He.of([
            r.text.replace(".", " ")
          ])
        }), this.pendingContextChange = h, !e.state.readOnly) {
          let p = this.to - this.from + (h.to - h.from + h.insert.length);
          Dx(e, h, q.single(this.toEditorPos(r.selectionStart, p), this.toEditorPos(r.selectionEnd, p)));
        }
        this.pendingContextChange && (this.revertPending(e.state), this.setSelection(e.state)), h.from < h.to && !h.insert.length && e.inputState.composing >= 0 && !/[\\p{Alphabetic}\\p{Number}_]/.test(n.text.slice(Math.max(0, r.updateRangeStart - 1), Math.min(n.text.length, r.updateRangeStart + 1))) && this.handlers.compositionend(r);
      }, this.handlers.characterboundsupdate = (r) => {
        let i = [], o = null;
        for (let s = this.toEditorPos(r.rangeStart), a = this.toEditorPos(r.rangeEnd); s < a; s++) {
          let l = e.coordsForChar(s);
          o = l && new DOMRect(l.left, l.top, l.right - l.left, l.bottom - l.top) || o || new DOMRect(), i.push(o);
        }
        n.updateCharacterBounds(r.rangeStart, i);
      }, this.handlers.textformatupdate = (r) => {
        let i = [];
        for (let o of r.getTextFormats()) {
          let s = o.underlineStyle, a = o.underlineThickness;
          if (!/none/i.test(s) && !/none/i.test(a)) {
            let l = this.toEditorPos(o.rangeStart), c = this.toEditorPos(o.rangeEnd);
            if (l < c) {
              let u = `text-decoration: underline ${/^[a-z]/.test(s) ? s + " " : s == "Dashed" ? "dashed " : s == "Squiggle" ? "wavy " : ""}${/thin/i.test(a) ? 1 : 2}px`;
              i.push(be.mark({
                attributes: {
                  style: u
                }
              }).range(l, c));
            }
          }
        }
        e.dispatch({
          effects: ZO.of(be.set(i))
        });
      }, this.handlers.compositionstart = () => {
        e.inputState.composing < 0 && (e.inputState.composing = 0, e.inputState.compositionFirstChange = true);
      }, this.handlers.compositionend = () => {
        if (e.inputState.composing = -1, e.inputState.compositionFirstChange = null, this.composing) {
          let { drifted: r } = this.composing;
          this.composing = null, r && this.reset(e.state);
        }
      };
      for (let r in this.handlers)
        n.addEventListener(r, this.handlers[r]);
      this.measureReq = {
        read: (r) => {
          this.editContext.updateControlBounds(r.contentDOM.getBoundingClientRect());
          let i = Nu(r.root);
          i && i.rangeCount && this.editContext.updateSelectionBounds(i.getRangeAt(0).getBoundingClientRect());
        }
      };
    }
    applyEdits(e) {
      let n = 0, r = false, i = this.pendingContextChange;
      return e.changes.iterChanges((o, s, a, l, c) => {
        if (r)
          return;
        let u = c.length - (s - o);
        if (i && s >= i.to)
          if (i.from == o && i.to == s && i.insert.eq(c)) {
            i = this.pendingContextChange = null, n += u, this.to += u;
            return;
          } else
            i = null, this.revertPending(e.state);
        if (o += n, s += n, s <= this.from)
          this.from += u, this.to += u;
        else if (o < this.to) {
          if (o < this.from || s > this.to || this.to - this.from + c.length > 3e4) {
            r = true;
            return;
          }
          this.editContext.updateText(this.toContextPos(o), this.toContextPos(s), c.toString()), this.to += u;
        }
        n += u;
      }), i && !r && this.revertPending(e.state), !r;
    }
    update(e) {
      let n = this.pendingContextChange, r = e.startState.selection.main;
      this.composing && (this.composing.drifted || !e.changes.touchesRange(r.from, r.to) && e.transactions.some((i) => !i.isUserEvent("input.type") && i.changes.touchesRange(this.from, this.to))) ? (this.composing.drifted = true, this.composing.editorBase = e.changes.mapPos(this.composing.editorBase)) : !this.applyEdits(e) || !this.rangeIsValid(e.state) ? (this.pendingContextChange = null, this.reset(e.state)) : (e.docChanged || e.selectionSet || n) && this.setSelection(e.state), (e.geometryChanged || e.docChanged || e.selectionSet) && e.view.requestMeasure(this.measureReq);
    }
    resetRange(e) {
      let { head: n } = e.selection.main;
      this.from = Math.max(0, n - 1e4), this.to = Math.min(e.doc.length, n + 1e4);
    }
    reset(e) {
      this.resetRange(e), this.editContext.updateText(0, this.editContext.text.length, e.doc.sliceString(this.from, this.to)), this.setSelection(e);
    }
    revertPending(e) {
      let n = this.pendingContextChange;
      this.pendingContextChange = null, this.editContext.updateText(this.toContextPos(n.from), this.toContextPos(n.from + n.insert.length), e.doc.sliceString(n.from, n.to));
    }
    setSelection(e) {
      let { main: n } = e.selection, r = this.toContextPos(Math.max(this.from, Math.min(this.to, n.anchor))), i = this.toContextPos(n.head);
      (this.editContext.selectionStart != r || this.editContext.selectionEnd != i) && this.editContext.updateSelection(r, i);
    }
    rangeIsValid(e) {
      let { head: n } = e.selection.main;
      return !(this.from > 0 && n - this.from < 500 || this.to < e.doc.length && this.to - n < 500 || this.to - this.from > 1e4 * 3);
    }
    toEditorPos(e, n = this.to - this.from) {
      e = Math.min(e, n);
      let r = this.composing;
      return r && r.drifted ? r.editorBase + (e - r.contextBase) : e + this.from;
    }
    toContextPos(e) {
      let n = this.composing;
      return n && n.drifted ? n.contextBase + (e - n.editorBase) : e - this.from;
    }
    destroy() {
      for (let e in this.handlers)
        this.editContext.removeEventListener(e, this.handlers[e]);
    }
  }
  class ue {
    get state() {
      return this.viewState.state;
    }
    get viewport() {
      return this.viewState.viewport;
    }
    get visibleRanges() {
      return this.viewState.visibleRanges;
    }
    get inView() {
      return this.viewState.inView;
    }
    get composing() {
      return !!this.inputState && this.inputState.composing > 0;
    }
    get compositionStarted() {
      return !!this.inputState && this.inputState.composing >= 0;
    }
    get root() {
      return this._root;
    }
    get win() {
      return this.dom.ownerDocument.defaultView || window;
    }
    constructor(e = {}) {
      var n;
      this.plugins = [], this.pluginMap = /* @__PURE__ */ new Map(), this.editorAttrs = {}, this.contentAttrs = {}, this.bidiCache = [], this.destroyed = false, this.updateState = 2, this.measureScheduled = -1, this.measureRequests = [], this.contentDOM = document.createElement("div"), this.scrollDOM = document.createElement("div"), this.scrollDOM.tabIndex = -1, this.scrollDOM.className = "cm-scroller", this.scrollDOM.appendChild(this.contentDOM), this.announceDOM = document.createElement("div"), this.announceDOM.className = "cm-announced", this.announceDOM.setAttribute("aria-live", "polite"), this.dom = document.createElement("div"), this.dom.appendChild(this.announceDOM), this.dom.appendChild(this.scrollDOM), e.parent && e.parent.appendChild(this.dom);
      let { dispatch: r } = e;
      this.dispatchTransactions = e.dispatchTransactions || r && ((i) => i.forEach((o) => r(o, this))) || ((i) => this.update(i)), this.dispatch = this.dispatch.bind(this), this._root = e.root || o7(e.parent) || document, this.viewState = new YC(e.state || Ne.create(e)), e.scrollTo && e.scrollTo.is(Th) && (this.viewState.scrollTarget = e.scrollTo.value.clip(this.viewState.state)), this.plugins = this.state.facet(_a).map((i) => new _0(i));
      for (let i of this.plugins)
        i.update(this);
      this.observer = new wU(this), this.inputState = new U7(this), this.inputState.ensureHandlers(this.plugins), this.docView = new OC(this), this.mountStyles(), this.updateAttrs(), this.updateState = 0, this.requestMeasure(), !((n = document.fonts) === null || n === void 0) && n.ready && document.fonts.ready.then(() => this.requestMeasure());
    }
    dispatch(...e) {
      let n = e.length == 1 && e[0] instanceof Bt ? e : e.length == 1 && Array.isArray(e[0]) ? e[0] : [
        this.state.update(...e)
      ];
      this.dispatchTransactions(n, this);
    }
    update(e) {
      if (this.updateState != 0)
        throw new Error("Calls to EditorView.update are not allowed while an update is in progress");
      let n = false, r = false, i, o = this.state;
      for (let p of e) {
        if (p.startState != o)
          throw new RangeError("Trying to update state with a transaction that doesn't start from the previous state.");
        o = p.state;
      }
      if (this.destroyed) {
        this.viewState.state = o;
        return;
      }
      let s = this.hasFocus, a = 0, l = null;
      e.some((p) => p.annotation(mR)) ? (this.inputState.notifiedFocused = s, a = 1) : s != this.inputState.notifiedFocused && (this.inputState.notifiedFocused = s, l = gR(o, s), l || (a = 1));
      let c = this.observer.delayedAndroidKey, u = null;
      if (c ? (this.observer.clearDelayedAndroidKey(), u = this.observer.readChange(), (u && !this.state.doc.eq(o.doc) || !this.state.selection.eq(o.selection)) && (u = null)) : this.observer.clear(), o.facet(Ne.phrases) != this.state.facet(Ne.phrases))
        return this.setState(o);
      i = kp.create(this, o, e), i.flags |= a;
      let h = this.viewState.scrollTarget;
      try {
        this.updateState = 2;
        for (let p of e) {
          if (h && (h = h.map(p.changes)), p.scrollIntoView) {
            let { main: v } = p.state.selection;
            h = new Qa(v.empty ? v : q.cursor(v.head, v.head > v.anchor ? -1 : 1));
          }
          for (let v of p.effects)
            v.is(Th) && (h = v.value.clip(this.state));
        }
        this.viewState.update(i, h), this.bidiCache = Tp.update(this.bidiCache, i.changes), i.empty || (this.updatePlugins(i), this.inputState.update(i)), n = this.docView.update(i), this.state.facet(xc) != this.styleModules && this.mountStyles(), r = this.updateAttrs(), this.showAnnouncements(e), this.docView.updateSelection(n, e.some((p) => p.isUserEvent("select.pointer")));
      } finally {
        this.updateState = 0;
      }
      if (i.startState.facet(Rh) != i.state.facet(Rh) && (this.viewState.mustMeasureContent = true), (n || r || h || this.viewState.mustEnforceCursorAssoc || this.viewState.mustMeasureContent) && this.requestMeasure(), n && this.docViewUpdate(), !i.empty)
        for (let p of this.state.facet(o1))
          try {
            p(i);
          } catch (v) {
            Bn(this.state, v, "update listener");
          }
      (l || u) && Promise.resolve().then(() => {
        l && this.state == l.startState && this.dispatch(l), u && !lR(this, u) && c.force && Xa(this.contentDOM, c.key, c.keyCode);
      });
    }
    setState(e) {
      if (this.updateState != 0)
        throw new Error("Calls to EditorView.setState are not allowed while an update is in progress");
      if (this.destroyed) {
        this.viewState.state = e;
        return;
      }
      this.updateState = 2;
      let n = this.hasFocus;
      try {
        for (let r of this.plugins)
          r.destroy(this);
        this.viewState = new YC(e), this.plugins = e.facet(_a).map((r) => new _0(r)), this.pluginMap.clear();
        for (let r of this.plugins)
          r.update(this);
        this.docView.destroy(), this.docView = new OC(this), this.inputState.ensureHandlers(this.plugins), this.mountStyles(), this.updateAttrs(), this.bidiCache = [];
      } finally {
        this.updateState = 0;
      }
      n && this.focus(), this.requestMeasure();
    }
    updatePlugins(e) {
      let n = e.startState.facet(_a), r = e.state.facet(_a);
      if (n != r) {
        let i = [];
        for (let o of r) {
          let s = n.indexOf(o);
          if (s < 0)
            i.push(new _0(o));
          else {
            let a = this.plugins[s];
            a.mustUpdate = e, i.push(a);
          }
        }
        for (let o of this.plugins)
          o.mustUpdate != e && o.destroy(this);
        this.plugins = i, this.pluginMap.clear();
      } else
        for (let i of this.plugins)
          i.mustUpdate = e;
      for (let i = 0; i < this.plugins.length; i++)
        this.plugins[i].update(this);
      n != r && this.inputState.ensureHandlers(this.plugins);
    }
    docViewUpdate() {
      for (let e of this.plugins) {
        let n = e.value;
        if (n && n.docViewUpdate)
          try {
            n.docViewUpdate(this);
          } catch (r) {
            Bn(this.state, r, "doc view update listener");
          }
      }
    }
    measure(e = true) {
      if (this.destroyed)
        return;
      if (this.measureScheduled > -1 && this.win.cancelAnimationFrame(this.measureScheduled), this.observer.delayedAndroidKey) {
        this.measureScheduled = -1, this.requestMeasure();
        return;
      }
      this.measureScheduled = 0, e && this.observer.forceFlush();
      let n = null, r = this.scrollDOM, i = r.scrollTop * this.scaleY, { scrollAnchorPos: o, scrollAnchorHeight: s } = this.viewState;
      Math.abs(i - this.viewState.scrollTop) > 1 && (s = -1), this.viewState.scrollAnchorHeight = -1;
      try {
        for (let a = 0; ; a++) {
          if (s < 0)
            if (PO(r))
              o = -1, s = this.viewState.heightMap.height;
            else {
              let v = this.viewState.scrollAnchorAt(i);
              o = v.from, s = v.top;
            }
          this.updateState = 1;
          let l = this.viewState.measure(this);
          if (!l && !this.measureRequests.length && this.viewState.scrollTarget == null)
            break;
          if (a > 5) {
            console.warn(this.measureRequests.length ? "Measure loop restarted more than 5 times" : "Viewport failed to stabilize");
            break;
          }
          let c = [];
          l & 4 || ([this.measureRequests, c] = [
            c,
            this.measureRequests
          ]);
          let u = c.map((v) => {
            try {
              return v.read(this);
            } catch (y) {
              return Bn(this.state, y), ZC;
            }
          }), h = kp.create(this, this.state, []), p = false;
          h.flags |= l, n ? n.flags |= l : n = h, this.updateState = 2, h.empty || (this.updatePlugins(h), this.inputState.update(h), this.updateAttrs(), p = this.docView.update(h), p && this.docViewUpdate());
          for (let v = 0; v < c.length; v++)
            if (u[v] != ZC)
              try {
                let y = c[v];
                y.write && y.write(u[v], this);
              } catch (y) {
                Bn(this.state, y);
              }
          if (p && this.docView.updateSelection(true), !h.viewportChanged && this.measureRequests.length == 0) {
            if (this.viewState.editorHeight)
              if (this.viewState.scrollTarget) {
                this.docView.scrollIntoView(this.viewState.scrollTarget), this.viewState.scrollTarget = null, s = -1;
                continue;
              } else {
                let y = (o < 0 ? this.viewState.heightMap.height : this.viewState.lineBlockAt(o).top) - s;
                if (y > 1 || y < -1) {
                  i = i + y, r.scrollTop = i / this.scaleY, s = -1;
                  continue;
                }
              }
            break;
          }
        }
      } finally {
        this.updateState = 0, this.measureScheduled = -1;
      }
      if (n && !n.empty)
        for (let a of this.state.facet(o1))
          a(n);
    }
    get themeClasses() {
      return u1 + " " + (this.state.facet(c1) ? xR : bR) + " " + this.state.facet(Rh);
    }
    updateAttrs() {
      let e = eT(this, eR, {
        class: "cm-editor" + (this.hasFocus ? " cm-focused " : " ") + this.themeClasses
      }), n = {
        spellcheck: "false",
        autocorrect: "off",
        autocapitalize: "off",
        writingsuggestions: "false",
        translate: "no",
        contenteditable: this.state.facet(Vi) ? "true" : "false",
        class: "cm-content",
        style: `${fe.tabSize}: ${this.state.tabSize}`,
        role: "textbox",
        "aria-multiline": "true"
      };
      this.state.readOnly && (n["aria-readonly"] = "true"), eT(this, Lx, n);
      let r = this.observer.ignore(() => {
        let i = e1(this.contentDOM, this.contentAttrs, n), o = e1(this.dom, this.editorAttrs, e);
        return i || o;
      });
      return this.editorAttrs = e, this.contentAttrs = n, r;
    }
    showAnnouncements(e) {
      let n = true;
      for (let r of e)
        for (let i of r.effects)
          if (i.is(ue.announce)) {
            n && (this.announceDOM.textContent = ""), n = false;
            let o = this.announceDOM.appendChild(document.createElement("div"));
            o.textContent = i.value;
          }
    }
    mountStyles() {
      this.styleModules = this.state.facet(xc);
      let e = this.state.facet(ue.cspNonce);
      qo.mount(this.root, this.styleModules.concat(xU).reverse(), e ? {
        nonce: e
      } : void 0);
    }
    readMeasured() {
      if (this.updateState == 2)
        throw new Error("Reading the editor layout isn't allowed during an update");
      this.updateState == 0 && this.measureScheduled > -1 && this.measure(false);
    }
    requestMeasure(e) {
      if (this.measureScheduled < 0 && (this.measureScheduled = this.win.requestAnimationFrame(() => this.measure())), e) {
        if (this.measureRequests.indexOf(e) > -1)
          return;
        if (e.key != null) {
          for (let n = 0; n < this.measureRequests.length; n++)
            if (this.measureRequests[n].key === e.key) {
              this.measureRequests[n] = e;
              return;
            }
        }
        this.measureRequests.push(e);
      }
    }
    plugin(e) {
      let n = this.pluginMap.get(e);
      return (n === void 0 || n && n.plugin != e) && this.pluginMap.set(e, n = this.plugins.find((r) => r.plugin == e) || null), n && n.update(this).value;
    }
    get documentTop() {
      return this.contentDOM.getBoundingClientRect().top + this.viewState.paddingTop;
    }
    get documentPadding() {
      return {
        top: this.viewState.paddingTop,
        bottom: this.viewState.paddingBottom
      };
    }
    get scaleX() {
      return this.viewState.scaleX;
    }
    get scaleY() {
      return this.viewState.scaleY;
    }
    elementAtHeight(e) {
      return this.readMeasured(), this.viewState.elementAtHeight(e);
    }
    lineBlockAtHeight(e) {
      return this.readMeasured(), this.viewState.lineBlockAtHeight(e);
    }
    get viewportLineBlocks() {
      return this.viewState.viewportLines;
    }
    lineBlockAt(e) {
      return this.viewState.lineBlockAt(e);
    }
    get contentHeight() {
      return this.viewState.contentHeight;
    }
    moveByChar(e, n, r) {
      return I0(this, e, IC(this, e, n, r));
    }
    moveByGroup(e, n) {
      return I0(this, e, IC(this, e, n, (r) => B7(this, e.head, r)));
    }
    visualLineSide(e, n) {
      let r = this.bidiSpans(e), i = this.textDirectionAt(e.from), o = r[n ? r.length - 1 : 0];
      return q.cursor(o.side(n, i) + e.from, o.forward(!n, i) ? 1 : -1);
    }
    moveToLineBoundary(e, n, r = true) {
      return I7(this, e, n, r);
    }
    moveVertically(e, n, r) {
      return I0(this, e, N7(this, e, n, r));
    }
    domAtPos(e) {
      return this.docView.domAtPos(e);
    }
    posAtDOM(e, n = 0) {
      return this.docView.posFromDOM(e, n);
    }
    posAtCoords(e, n = true) {
      return this.readMeasured(), oR(this, e, n);
    }
    coordsAtPos(e, n = 1) {
      this.readMeasured();
      let r = this.docView.coordsAt(e, n);
      if (!r || r.left == r.right)
        return r;
      let i = this.state.doc.lineAt(e), o = this.bidiSpans(i), s = o[Do.find(o, e - i.from, -1, n)];
      return af(r, s.dir == rt.LTR == n > 0);
    }
    coordsForChar(e) {
      return this.readMeasured(), this.docView.coordsForChar(e);
    }
    get defaultCharacterWidth() {
      return this.viewState.heightOracle.charWidth;
    }
    get defaultLineHeight() {
      return this.viewState.heightOracle.lineHeight;
    }
    get textDirection() {
      return this.viewState.defaultTextDirection;
    }
    textDirectionAt(e) {
      return !this.state.facet(XO) || e < this.viewport.from || e > this.viewport.to ? this.textDirection : (this.readMeasured(), this.docView.textDirectionAt(e));
    }
    get lineWrapping() {
      return this.viewState.heightOracle.lineWrapping;
    }
    bidiSpans(e) {
      if (e.length > TU)
        return HO(e.length);
      let n = this.textDirectionAt(e.from), r;
      for (let o of this.bidiCache)
        if (o.from == e.from && o.dir == n && (o.fresh || VO(o.isolates, r = PC(this, e))))
          return o.order;
      r || (r = PC(this, e));
      let i = b7(e.text, n, r);
      return this.bidiCache.push(new Tp(e.from, e.to, n, r, true, i)), i;
    }
    get hasFocus() {
      var e;
      return (this.dom.ownerDocument.hasFocus() || fe.safari && ((e = this.inputState) === null || e === void 0 ? void 0 : e.lastContextMenu) > Date.now() - 3e4) && this.root.activeElement == this.contentDOM;
    }
    focus() {
      this.observer.ignore(() => {
        AO(this.contentDOM), this.docView.updateSelection();
      });
    }
    setRoot(e) {
      this._root != e && (this._root = e, this.observer.setWindow((e.nodeType == 9 ? e : e.ownerDocument).defaultView || window), this.mountStyles());
    }
    destroy() {
      this.root.activeElement == this.contentDOM && this.contentDOM.blur();
      for (let e of this.plugins)
        e.destroy(this);
      this.plugins = [], this.inputState.destroy(), this.docView.destroy(), this.dom.remove(), this.observer.destroy(), this.measureScheduled > -1 && this.win.cancelAnimationFrame(this.measureScheduled), this.destroyed = true;
    }
    static scrollIntoView(e, n = {}) {
      return Th.of(new Qa(typeof e == "number" ? q.cursor(e) : e, n.y, n.x, n.yMargin, n.xMargin));
    }
    scrollSnapshot() {
      let { scrollTop: e, scrollLeft: n } = this.scrollDOM, r = this.viewState.scrollAnchorAt(e);
      return Th.of(new Qa(q.cursor(r.from), "start", "start", r.top - e, n, true));
    }
    setTabFocusMode(e) {
      e == null ? this.inputState.tabFocusMode = this.inputState.tabFocusMode < 0 ? 0 : -1 : typeof e == "boolean" ? this.inputState.tabFocusMode = e ? 0 : -1 : this.inputState.tabFocusMode != 0 && (this.inputState.tabFocusMode = Date.now() + e);
    }
    static domEventHandlers(e) {
      return Ct.define(() => ({}), {
        eventHandlers: e
      });
    }
    static domEventObservers(e) {
      return Ct.define(() => ({}), {
        eventObservers: e
      });
    }
    static theme(e, n) {
      let r = qo.newName(), i = [
        Rh.of(r),
        xc.of(f1(`.${r}`, e))
      ];
      return n && n.dark && i.push(c1.of(true)), i;
    }
    static baseTheme(e) {
      return ns.lowest(xc.of(f1("." + u1, e, SR)));
    }
    static findFromDOM(e) {
      var n;
      let r = e.querySelector(".cm-content"), i = r && Qe.get(r) || Qe.get(e);
      return ((n = i == null ? void 0 : i.rootView) === null || n === void 0 ? void 0 : n.view) || null;
    }
  }
  ue.styleModule = xc;
  ue.inputHandler = GO;
  ue.clipboardInputFilter = Ox;
  ue.clipboardOutputFilter = Rx;
  ue.scrollHandler = JO;
  ue.focusChangeEffect = YO;
  ue.perLineTextDirection = XO;
  ue.exceptionSink = qO;
  ue.updateListener = o1;
  ue.editable = Vi;
  ue.mouseSelectionStyle = KO;
  ue.dragMovesSelection = UO;
  ue.clickAddsSelectionRange = WO;
  ue.decorations = $u;
  ue.outerDecorations = tR;
  ue.atomicRanges = uf;
  ue.bidiIsolatedRanges = nR;
  ue.scrollMargins = rR;
  ue.darkTheme = c1;
  ue.cspNonce = me.define({
    combine: (t) => t.length ? t[0] : ""
  });
  ue.contentAttributes = Lx;
  ue.editorAttributes = eR;
  ue.lineWrapping = ue.contentAttributes.of({
    class: "cm-lineWrapping"
  });
  ue.announce = Ee.define();
  const TU = 4096, ZC = {};
  class Tp {
    constructor(e, n, r, i, o, s) {
      this.from = e, this.to = n, this.dir = r, this.isolates = i, this.fresh = o, this.order = s;
    }
    static update(e, n) {
      if (n.empty && !e.some((o) => o.fresh))
        return e;
      let r = [], i = e.length ? e[e.length - 1].dir : rt.LTR;
      for (let o = Math.max(0, e.length - 10); o < e.length; o++) {
        let s = e[o];
        s.dir == i && !n.touchesRange(s.from, s.to) && r.push(new Tp(n.mapPos(s.from, 1), n.mapPos(s.to, -1), s.dir, s.isolates, false, s.order));
      }
      return r;
    }
  }
  function eT(t, e, n) {
    for (let r = t.state.facet(e), i = r.length - 1; i >= 0; i--) {
      let o = r[i], s = typeof o == "function" ? o(t) : o;
      s && Zy(s, n);
    }
    return n;
  }
  const MU = fe.mac ? "mac" : fe.windows ? "win" : fe.linux ? "linux" : "key";
  function AU(t, e) {
    const n = t.split(/-(?!$)/);
    let r = n[n.length - 1];
    r == "Space" && (r = " ");
    let i, o, s, a;
    for (let l = 0; l < n.length - 1; ++l) {
      const c = n[l];
      if (/^(cmd|meta|m)$/i.test(c))
        a = true;
      else if (/^a(lt)?$/i.test(c))
        i = true;
      else if (/^(c|ctrl|control)$/i.test(c))
        o = true;
      else if (/^s(hift)?$/i.test(c))
        s = true;
      else if (/^mod$/i.test(c))
        e == "mac" ? a = true : o = true;
      else
        throw new Error("Unrecognized modifier name: " + c);
    }
    return i && (r = "Alt-" + r), o && (r = "Ctrl-" + r), a && (r = "Meta-" + r), s && (r = "Shift-" + r), r;
  }
  function Lh(t, e, n) {
    return e.altKey && (t = "Alt-" + t), e.ctrlKey && (t = "Ctrl-" + t), e.metaKey && (t = "Meta-" + t), n !== false && e.shiftKey && (t = "Shift-" + t), t;
  }
  const EU = ns.default(ue.domEventHandlers({
    keydown(t, e) {
      return kR(wR(e.state), t, e, "editor");
    }
  })), Vm = me.define({
    enables: EU
  }), tT = /* @__PURE__ */ new WeakMap();
  function wR(t) {
    let e = t.facet(Vm), n = tT.get(e);
    return n || tT.set(e, n = OU(e.reduce((r, i) => r.concat(i), []))), n;
  }
  function xs(t, e, n) {
    return kR(wR(t.state), e, t, n);
  }
  let Mo = null;
  const PU = 4e3;
  function OU(t, e = MU) {
    let n = /* @__PURE__ */ Object.create(null), r = /* @__PURE__ */ Object.create(null), i = (s, a) => {
      let l = r[s];
      if (l == null)
        r[s] = a;
      else if (l != a)
        throw new Error("Key binding " + s + " is used both as a regular binding and as a multi-stroke prefix");
    }, o = (s, a, l, c, u) => {
      var h, p;
      let v = n[s] || (n[s] = /* @__PURE__ */ Object.create(null)), y = a.split(/ (?!$)/).map((w) => AU(w, e));
      for (let w = 1; w < y.length; w++) {
        let k = y.slice(0, w).join(" ");
        i(k, true), v[k] || (v[k] = {
          preventDefault: true,
          stopPropagation: false,
          run: [
            (C) => {
              let P = Mo = {
                view: C,
                prefix: k,
                scope: s
              };
              return setTimeout(() => {
                Mo == P && (Mo = null);
              }, PU), true;
            }
          ]
        });
      }
      let x = y.join(" ");
      i(x, false);
      let T = v[x] || (v[x] = {
        preventDefault: false,
        stopPropagation: false,
        run: ((p = (h = v._any) === null || h === void 0 ? void 0 : h.run) === null || p === void 0 ? void 0 : p.slice()) || []
      });
      l && T.run.push(l), c && (T.preventDefault = true), u && (T.stopPropagation = true);
    };
    for (let s of t) {
      let a = s.scope ? s.scope.split(" ") : [
        "editor"
      ];
      if (s.any)
        for (let c of a) {
          let u = n[c] || (n[c] = /* @__PURE__ */ Object.create(null));
          u._any || (u._any = {
            preventDefault: false,
            stopPropagation: false,
            run: []
          });
          let { any: h } = s;
          for (let p in u)
            u[p].run.push((v) => h(v, h1));
        }
      let l = s[e] || s.key;
      if (!!l)
        for (let c of a)
          o(c, l, s.run, s.preventDefault, s.stopPropagation), s.shift && o(c, "Shift-" + l, s.shift, s.preventDefault, s.stopPropagation);
    }
    return n;
  }
  let h1 = null;
  function kR(t, e, n, r) {
    h1 = e;
    let i = e7(e), o = Ln(i, 0), s = mi(o) == i.length && i != " ", a = "", l = false, c = false, u = false;
    Mo && Mo.view == n && Mo.scope == r && (a = Mo.prefix + " ", fR.indexOf(e.keyCode) < 0 && (c = true, Mo = null));
    let h = /* @__PURE__ */ new Set(), p = (T) => {
      if (T) {
        for (let w of T.run)
          if (!h.has(w) && (h.add(w), w(n)))
            return T.stopPropagation && (u = true), true;
        T.preventDefault && (T.stopPropagation && (u = true), c = true);
      }
      return false;
    }, v = t[r], y, x;
    return v && (p(v[a + Lh(i, e, !s)]) ? l = true : s && (e.altKey || e.metaKey || e.ctrlKey) && !(fe.windows && e.ctrlKey && e.altKey) && !(fe.mac && e.altKey && !(e.ctrlKey || e.metaKey)) && (y = Go[e.keyCode]) && y != i ? (p(v[a + Lh(y, e, true)]) || e.shiftKey && (x = Bu[e.keyCode]) != i && x != y && p(v[a + Lh(x, e, false)])) && (l = true) : s && e.shiftKey && p(v[a + Lh(i, e, true)]) && (l = true), !l && p(v._any) && (l = true)), c && (l = true), l && u && e.stopPropagation(), h1 = null, l;
  }
  class ff {
    constructor(e, n, r, i, o) {
      this.className = e, this.left = n, this.top = r, this.width = i, this.height = o;
    }
    draw() {
      let e = document.createElement("div");
      return e.className = this.className, this.adjust(e), e;
    }
    update(e, n) {
      return n.className != this.className ? false : (this.adjust(e), true);
    }
    adjust(e) {
      e.style.left = this.left + "px", e.style.top = this.top + "px", this.width != null && (e.style.width = this.width + "px"), e.style.height = this.height + "px";
    }
    eq(e) {
      return this.left == e.left && this.top == e.top && this.width == e.width && this.height == e.height && this.className == e.className;
    }
    static forRange(e, n, r) {
      if (r.empty) {
        let i = e.coordsAtPos(r.head, r.assoc || 1);
        if (!i)
          return [];
        let o = CR(e);
        return [
          new ff(n, i.left - o.left, i.top - o.top, null, i.bottom - i.top)
        ];
      } else
        return RU(e, n, r);
    }
  }
  function CR(t) {
    let e = t.scrollDOM.getBoundingClientRect();
    return {
      left: (t.textDirection == rt.LTR ? e.left : e.right - t.scrollDOM.clientWidth * t.scaleX) - t.scrollDOM.scrollLeft * t.scaleX,
      top: e.top - t.scrollDOM.scrollTop * t.scaleY
    };
  }
  function nT(t, e, n, r) {
    let i = t.coordsAtPos(e, n * 2);
    if (!i)
      return r;
    let o = t.dom.getBoundingClientRect(), s = (i.top + i.bottom) / 2, a = t.posAtCoords({
      x: o.left + 1,
      y: s
    }), l = t.posAtCoords({
      x: o.right - 1,
      y: s
    });
    return a == null || l == null ? r : {
      from: Math.max(r.from, Math.min(a, l)),
      to: Math.min(r.to, Math.max(a, l))
    };
  }
  function RU(t, e, n) {
    if (n.to <= t.viewport.from || n.from >= t.viewport.to)
      return [];
    let r = Math.max(n.from, t.viewport.from), i = Math.min(n.to, t.viewport.to), o = t.textDirection == rt.LTR, s = t.contentDOM, a = s.getBoundingClientRect(), l = CR(t), c = s.querySelector(".cm-line"), u = c && window.getComputedStyle(c), h = a.left + (u ? parseInt(u.paddingLeft) + Math.min(0, parseInt(u.textIndent)) : 0), p = a.right - (u ? parseInt(u.paddingRight) : 0), v = a1(t, r, 1), y = a1(t, i, -1), x = v.type == Cn.Text ? v : null, T = y.type == Cn.Text ? y : null;
    if (x && (t.lineWrapping || v.widgetLineBreaks) && (x = nT(t, r, 1, x)), T && (t.lineWrapping || y.widgetLineBreaks) && (T = nT(t, i, -1, T)), x && T && x.from == T.from && x.to == T.to)
      return k(C(n.from, n.to, x));
    {
      let R = x ? C(n.from, null, x) : P(v, false), L = T ? C(null, n.to, T) : P(y, true), _ = [];
      return (x || v).to < (T || y).from - (x && T ? 1 : 0) || v.widgetLineBreaks > 1 && R.bottom + t.defaultLineHeight / 2 < L.top ? _.push(w(h, R.bottom, p, L.top)) : R.bottom < L.top && t.elementAtHeight((R.bottom + L.top) / 2).type == Cn.Text && (R.bottom = L.top = (R.bottom + L.top) / 2), k(R).concat(_).concat(k(L));
    }
    function w(R, L, _, F) {
      return new ff(e, R - l.left, L - l.top, _ - R, F - L);
    }
    function k({ top: R, bottom: L, horizontal: _ }) {
      let F = [];
      for (let K = 0; K < _.length; K += 2)
        F.push(w(_[K], R, _[K + 1], L));
      return F;
    }
    function C(R, L, _) {
      let F = 1e9, K = -1e9, Y = [];
      function te(ye, Ce, Re, ee, V) {
        let oe = t.coordsAtPos(ye, ye == _.to ? -2 : 2), de = t.coordsAtPos(Re, Re == _.from ? 2 : -2);
        !oe || !de || (F = Math.min(oe.top, de.top, F), K = Math.max(oe.bottom, de.bottom, K), V == rt.LTR ? Y.push(o && Ce ? h : oe.left, o && ee ? p : de.right) : Y.push(!o && ee ? h : de.left, !o && Ce ? p : oe.right));
      }
      let ne = R ?? _.from, ae = L ?? _.to;
      for (let ye of t.visibleRanges)
        if (ye.to > ne && ye.from < ae)
          for (let Ce = Math.max(ye.from, ne), Re = Math.min(ye.to, ae); ; ) {
            let ee = t.state.doc.lineAt(Ce);
            for (let V of t.bidiSpans(ee)) {
              let oe = V.from + ee.from, de = V.to + ee.from;
              if (oe >= Re)
                break;
              de > Ce && te(Math.max(oe, Ce), R == null && oe <= ne, Math.min(de, Re), L == null && de >= ae, V.dir);
            }
            if (Ce = ee.to + 1, Ce >= Re)
              break;
          }
      return Y.length == 0 && te(ne, R == null, ae, L == null, t.textDirection), {
        top: F,
        bottom: K,
        horizontal: Y
      };
    }
    function P(R, L) {
      let _ = a.top + (L ? R.top : R.bottom);
      return {
        top: _,
        bottom: _,
        horizontal: []
      };
    }
  }
  function LU(t, e) {
    return t.constructor == e.constructor && t.eq(e);
  }
  class _U {
    constructor(e, n) {
      this.view = e, this.layer = n, this.drawn = [], this.scaleX = 1, this.scaleY = 1, this.measureReq = {
        read: this.measure.bind(this),
        write: this.draw.bind(this)
      }, this.dom = e.scrollDOM.appendChild(document.createElement("div")), this.dom.classList.add("cm-layer"), n.above && this.dom.classList.add("cm-layer-above"), n.class && this.dom.classList.add(n.class), this.scale(), this.dom.setAttribute("aria-hidden", "true"), this.setOrder(e.state), e.requestMeasure(this.measureReq), n.mount && n.mount(this.dom, e);
    }
    update(e) {
      e.startState.facet(Td) != e.state.facet(Td) && this.setOrder(e.state), (this.layer.update(e, this.dom) || e.geometryChanged) && (this.scale(), e.view.requestMeasure(this.measureReq));
    }
    docViewUpdate(e) {
      this.layer.updateOnDocViewUpdate !== false && e.requestMeasure(this.measureReq);
    }
    setOrder(e) {
      let n = 0, r = e.facet(Td);
      for (; n < r.length && r[n] != this.layer; )
        n++;
      this.dom.style.zIndex = String((this.layer.above ? 150 : -1) - n);
    }
    measure() {
      return this.layer.markers(this.view);
    }
    scale() {
      let { scaleX: e, scaleY: n } = this.view;
      (e != this.scaleX || n != this.scaleY) && (this.scaleX = e, this.scaleY = n, this.dom.style.transform = `scale(${1 / e}, ${1 / n})`);
    }
    draw(e) {
      if (e.length != this.drawn.length || e.some((n, r) => !LU(n, this.drawn[r]))) {
        let n = this.dom.firstChild, r = 0;
        for (let i of e)
          i.update && n && i.constructor && this.drawn[r].constructor && i.update(n, this.drawn[r]) ? (n = n.nextSibling, r++) : this.dom.insertBefore(i.draw(), n);
        for (; n; ) {
          let i = n.nextSibling;
          n.remove(), n = i;
        }
        this.drawn = e, fe.safari && fe.safari_version >= 26 && (this.dom.style.display = this.dom.firstChild ? "" : "none");
      }
    }
    destroy() {
      this.layer.destroy && this.layer.destroy(this.dom, this.view), this.dom.remove();
    }
  }
  const Td = me.define();
  function TR(t) {
    return [
      Ct.define((e) => new _U(e, t)),
      Td.of(t)
    ];
  }
  const yl = me.define({
    combine(t) {
      return Oi(t, {
        cursorBlinkRate: 1200,
        drawRangeCursor: true
      }, {
        cursorBlinkRate: (e, n) => Math.min(e, n),
        drawRangeCursor: (e, n) => e || n
      });
    }
  });
  function DU(t = {}) {
    return [
      yl.of(t),
      BU,
      NU,
      $U,
      QO.of(true)
    ];
  }
  function IU(t) {
    return t.facet(yl);
  }
  function MR(t) {
    return t.startState.facet(yl) != t.state.facet(yl);
  }
  const BU = TR({
    above: true,
    markers(t) {
      let { state: e } = t, n = e.facet(yl), r = [];
      for (let i of e.selection.ranges) {
        let o = i == e.selection.main;
        if (i.empty || n.drawRangeCursor) {
          let s = o ? "cm-cursor cm-cursor-primary" : "cm-cursor cm-cursor-secondary", a = i.empty ? i : q.cursor(i.head, i.head > i.anchor ? -1 : 1);
          for (let l of ff.forRange(t, s, a))
            r.push(l);
        }
      }
      return r;
    },
    update(t, e) {
      t.transactions.some((r) => r.selection) && (e.style.animationName = e.style.animationName == "cm-blink" ? "cm-blink2" : "cm-blink");
      let n = MR(t);
      return n && rT(t.state, e), t.docChanged || t.selectionSet || n;
    },
    mount(t, e) {
      rT(e.state, t);
    },
    class: "cm-cursorLayer"
  });
  function rT(t, e) {
    e.style.animationDuration = t.facet(yl).cursorBlinkRate + "ms";
  }
  const NU = TR({
    above: false,
    markers(t) {
      return t.state.selection.ranges.map((e) => e.empty ? [] : ff.forRange(t, "cm-selectionBackground", e)).reduce((e, n) => e.concat(n));
    },
    update(t, e) {
      return t.docChanged || t.selectionSet || t.viewportChanged || MR(t);
    },
    class: "cm-selectionLayer"
  }), $U = ns.highest(ue.theme({
    ".cm-line": {
      "& ::selection, &::selection": {
        backgroundColor: "transparent !important"
      },
      caretColor: "transparent !important"
    },
    ".cm-content": {
      caretColor: "transparent !important",
      "& :focus": {
        caretColor: "initial !important",
        "&::selection, & ::selection": {
          backgroundColor: "Highlight !important"
        }
      }
    }
  })), AR = Ee.define({
    map(t, e) {
      return t == null ? null : e.mapPos(t);
    }
  }), kc = Ut.define({
    create() {
      return null;
    },
    update(t, e) {
      return t != null && (t = e.changes.mapPos(t)), e.effects.reduce((n, r) => r.is(AR) ? r.value : n, t);
    }
  }), zU = Ct.fromClass(class {
    constructor(t) {
      this.view = t, this.cursor = null, this.measureReq = {
        read: this.readPos.bind(this),
        write: this.drawCursor.bind(this)
      };
    }
    update(t) {
      var e;
      let n = t.state.field(kc);
      n == null ? this.cursor != null && ((e = this.cursor) === null || e === void 0 || e.remove(), this.cursor = null) : (this.cursor || (this.cursor = this.view.scrollDOM.appendChild(document.createElement("div")), this.cursor.className = "cm-dropCursor"), (t.startState.field(kc) != n || t.docChanged || t.geometryChanged) && this.view.requestMeasure(this.measureReq));
    }
    readPos() {
      let { view: t } = this, e = t.state.field(kc), n = e != null && t.coordsAtPos(e);
      if (!n)
        return null;
      let r = t.scrollDOM.getBoundingClientRect();
      return {
        left: n.left - r.left + t.scrollDOM.scrollLeft * t.scaleX,
        top: n.top - r.top + t.scrollDOM.scrollTop * t.scaleY,
        height: n.bottom - n.top
      };
    }
    drawCursor(t) {
      if (this.cursor) {
        let { scaleX: e, scaleY: n } = this.view;
        t ? (this.cursor.style.left = t.left / e + "px", this.cursor.style.top = t.top / n + "px", this.cursor.style.height = t.height / n + "px") : this.cursor.style.left = "-100000px";
      }
    }
    destroy() {
      this.cursor && this.cursor.remove();
    }
    setDropPos(t) {
      this.view.state.field(kc) != t && this.view.dispatch({
        effects: AR.of(t)
      });
    }
  }, {
    eventObservers: {
      dragover(t) {
        this.setDropPos(this.view.posAtCoords({
          x: t.clientX,
          y: t.clientY
        }));
      },
      dragleave(t) {
        (t.target == this.view.contentDOM || !this.view.contentDOM.contains(t.relatedTarget)) && this.setDropPos(null);
      },
      dragend() {
        this.setDropPos(null);
      },
      drop() {
        this.setDropPos(null);
      }
    }
  });
  function FU() {
    return [
      kc,
      zU
    ];
  }
  function iT(t, e, n, r, i) {
    e.lastIndex = 0;
    for (let o = t.iterRange(n, r), s = n, a; !o.next().done; s += o.value.length)
      if (!o.lineBreak)
        for (; a = e.exec(o.value); )
          i(s + a.index, a);
  }
  function VU(t, e) {
    let n = t.visibleRanges;
    if (n.length == 1 && n[0].from == t.viewport.from && n[0].to == t.viewport.to)
      return n;
    let r = [];
    for (let { from: i, to: o } of n)
      i = Math.max(t.state.doc.lineAt(i).from, i - e), o = Math.min(t.state.doc.lineAt(o).to, o + e), r.length && r[r.length - 1].to >= i ? r[r.length - 1].to = o : r.push({
        from: i,
        to: o
      });
    return r;
  }
  class HU {
    constructor(e) {
      const { regexp: n, decoration: r, decorate: i, boundary: o, maxLength: s = 1e3 } = e;
      if (!n.global)
        throw new RangeError("The regular expression given to MatchDecorator should have its 'g' flag set");
      if (this.regexp = n, i)
        this.addMatch = (a, l, c, u) => i(u, c, c + a[0].length, a, l);
      else if (typeof r == "function")
        this.addMatch = (a, l, c, u) => {
          let h = r(a, l, c);
          h && u(c, c + a[0].length, h);
        };
      else if (r)
        this.addMatch = (a, l, c, u) => u(c, c + a[0].length, r);
      else
        throw new RangeError("Either 'decorate' or 'decoration' should be provided to MatchDecorator");
      this.boundary = o, this.maxLength = s;
    }
    createDeco(e) {
      let n = new Mi(), r = n.add.bind(n);
      for (let { from: i, to: o } of VU(e, this.maxLength))
        iT(e.state.doc, this.regexp, i, o, (s, a) => this.addMatch(a, e, s, r));
      return n.finish();
    }
    updateDeco(e, n) {
      let r = 1e9, i = -1;
      return e.docChanged && e.changes.iterChanges((o, s, a, l) => {
        l >= e.view.viewport.from && a <= e.view.viewport.to && (r = Math.min(a, r), i = Math.max(l, i));
      }), e.viewportMoved || i - r > 1e3 ? this.createDeco(e.view) : i > -1 ? this.updateRange(e.view, n.map(e.changes), r, i) : n;
    }
    updateRange(e, n, r, i) {
      for (let o of e.visibleRanges) {
        let s = Math.max(o.from, r), a = Math.min(o.to, i);
        if (a >= s) {
          let l = e.state.doc.lineAt(s), c = l.to < a ? e.state.doc.lineAt(a) : l, u = Math.max(o.from, l.from), h = Math.min(o.to, c.to);
          if (this.boundary) {
            for (; s > l.from; s--)
              if (this.boundary.test(l.text[s - 1 - l.from])) {
                u = s;
                break;
              }
            for (; a < c.to; a++)
              if (this.boundary.test(c.text[a - c.from])) {
                h = a;
                break;
              }
          }
          let p = [], v, y = (x, T, w) => p.push(w.range(x, T));
          if (l == c)
            for (this.regexp.lastIndex = u - l.from; (v = this.regexp.exec(l.text)) && v.index < h - l.from; )
              this.addMatch(v, e, v.index + l.from, y);
          else
            iT(e.state.doc, this.regexp, u, h, (x, T) => this.addMatch(T, e, x, y));
          n = n.update({
            filterFrom: u,
            filterTo: h,
            filter: (x, T) => x < u || T > h,
            add: p
          });
        }
      }
      return n;
    }
  }
  const d1 = /x/.unicode != null ? "gu" : "g", jU = new RegExp(`[\0-\b
-\x7F-\x9F\xAD\u061C\u200B\u200E\u200F\u2028\u2029\u202D\u202E\u2066\u2067\u2069\uFEFF\uFFF9-\uFFFC]`, d1), WU = {
    0: "null",
    7: "bell",
    8: "backspace",
    10: "newline",
    11: "vertical tab",
    13: "carriage return",
    27: "escape",
    8203: "zero width space",
    8204: "zero width non-joiner",
    8205: "zero width joiner",
    8206: "left-to-right mark",
    8207: "right-to-left mark",
    8232: "line separator",
    8237: "left-to-right override",
    8238: "right-to-left override",
    8294: "left-to-right isolate",
    8295: "right-to-left isolate",
    8297: "pop directional isolate",
    8233: "paragraph separator",
    65279: "zero width no-break space",
    65532: "object replacement"
  };
  let $0 = null;
  function UU() {
    var t;
    if ($0 == null && typeof document < "u" && document.body) {
      let e = document.body.style;
      $0 = ((t = e.tabSize) !== null && t !== void 0 ? t : e.MozTabSize) != null;
    }
    return $0 || false;
  }
  const Md = me.define({
    combine(t) {
      let e = Oi(t, {
        render: null,
        specialChars: jU,
        addSpecialChars: null
      });
      return (e.replaceTabs = !UU()) && (e.specialChars = new RegExp("	|" + e.specialChars.source, d1)), e.addSpecialChars && (e.specialChars = new RegExp(e.specialChars.source + "|" + e.addSpecialChars.source, d1)), e;
    }
  });
  function KU(t = {}) {
    return [
      Md.of(t),
      qU()
    ];
  }
  let oT = null;
  function qU() {
    return oT || (oT = Ct.fromClass(class {
      constructor(t) {
        this.view = t, this.decorations = be.none, this.decorationCache = /* @__PURE__ */ Object.create(null), this.decorator = this.makeDecorator(t.state.facet(Md)), this.decorations = this.decorator.createDeco(t);
      }
      makeDecorator(t) {
        return new HU({
          regexp: t.specialChars,
          decoration: (e, n, r) => {
            let { doc: i } = n.state, o = Ln(e[0], 0);
            if (o == 9) {
              let s = i.lineAt(r), a = n.state.tabSize, l = Pl(s.text, a, r - s.from);
              return be.replace({
                widget: new QU((a - l % a) * this.view.defaultCharacterWidth / this.view.scaleX)
              });
            }
            return this.decorationCache[o] || (this.decorationCache[o] = be.replace({
              widget: new XU(t, o)
            }));
          },
          boundary: t.replaceTabs ? void 0 : /[^]/
        });
      }
      update(t) {
        let e = t.state.facet(Md);
        t.startState.facet(Md) != e ? (this.decorator = this.makeDecorator(e), this.decorations = this.decorator.createDeco(t.view)) : this.decorations = this.decorator.updateDeco(t, this.decorations);
      }
    }, {
      decorations: (t) => t.decorations
    }));
  }
  const GU = "\u2022";
  function YU(t) {
    return t >= 32 ? GU : t == 10 ? "\u2424" : String.fromCharCode(9216 + t);
  }
  class XU extends oo {
    constructor(e, n) {
      super(), this.options = e, this.code = n;
    }
    eq(e) {
      return e.code == this.code;
    }
    toDOM(e) {
      let n = YU(this.code), r = e.state.phrase("Control character") + " " + (WU[this.code] || "0x" + this.code.toString(16)), i = this.options.render && this.options.render(this.code, r, n);
      if (i)
        return i;
      let o = document.createElement("span");
      return o.textContent = n, o.title = r, o.setAttribute("aria-label", r), o.className = "cm-specialChar", o;
    }
    ignoreEvent() {
      return false;
    }
  }
  class QU extends oo {
    constructor(e) {
      super(), this.width = e;
    }
    eq(e) {
      return e.width == this.width;
    }
    toDOM() {
      let e = document.createElement("span");
      return e.textContent = "	", e.className = "cm-tab", e.style.width = this.width + "px", e;
    }
    ignoreEvent() {
      return false;
    }
  }
  function JU() {
    return eK;
  }
  const ZU = be.line({
    class: "cm-activeLine"
  }), eK = Ct.fromClass(class {
    constructor(t) {
      this.decorations = this.getDeco(t);
    }
    update(t) {
      (t.docChanged || t.selectionSet) && (this.decorations = this.getDeco(t.view));
    }
    getDeco(t) {
      let e = -1, n = [];
      for (let r of t.state.selection.ranges) {
        let i = t.lineBlockAt(r.head);
        i.from > e && (n.push(ZU.range(i.from)), e = i.from);
      }
      return be.set(n);
    }
  }, {
    decorations: (t) => t.decorations
  });
  class tK extends oo {
    constructor(e) {
      super(), this.content = e;
    }
    toDOM(e) {
      let n = document.createElement("span");
      return n.className = "cm-placeholder", n.style.pointerEvents = "none", n.appendChild(typeof this.content == "string" ? document.createTextNode(this.content) : typeof this.content == "function" ? this.content(e) : this.content.cloneNode(true)), n.setAttribute("aria-hidden", "true"), n;
    }
    coordsAt(e) {
      let n = e.firstChild ? pl(e.firstChild) : [];
      if (!n.length)
        return null;
      let r = window.getComputedStyle(e.parentNode), i = af(n[0], r.direction != "rtl"), o = parseInt(r.lineHeight);
      return i.bottom - i.top > o * 1.5 ? {
        left: i.left,
        right: i.right,
        top: i.top,
        bottom: i.top + o
      } : i;
    }
    ignoreEvent() {
      return false;
    }
  }
  function nK(t) {
    let e = Ct.fromClass(class {
      constructor(n) {
        this.view = n, this.placeholder = t ? be.set([
          be.widget({
            widget: new tK(t),
            side: 1
          }).range(0)
        ]) : be.none;
      }
      get decorations() {
        return this.view.state.doc.length ? be.none : this.placeholder;
      }
    }, {
      decorations: (n) => n.decorations
    });
    return typeof t == "string" ? [
      e,
      ue.contentAttributes.of({
        "aria-placeholder": t
      })
    ] : e;
  }
  const p1 = 2e3;
  function rK(t, e, n) {
    let r = Math.min(e.line, n.line), i = Math.max(e.line, n.line), o = [];
    if (e.off > p1 || n.off > p1 || e.col < 0 || n.col < 0) {
      let s = Math.min(e.off, n.off), a = Math.max(e.off, n.off);
      for (let l = r; l <= i; l++) {
        let c = t.doc.line(l);
        c.length <= a && o.push(q.range(c.from + s, c.to + a));
      }
    } else {
      let s = Math.min(e.col, n.col), a = Math.max(e.col, n.col);
      for (let l = r; l <= i; l++) {
        let c = t.doc.line(l), u = Uy(c.text, s, t.tabSize, true);
        if (u < 0)
          o.push(q.cursor(c.to));
        else {
          let h = Uy(c.text, a, t.tabSize);
          o.push(q.range(c.from + u, c.from + h));
        }
      }
    }
    return o;
  }
  function iK(t, e) {
    let n = t.coordsAtPos(t.viewport.from);
    return n ? Math.round(Math.abs((n.left - e) / t.defaultCharacterWidth)) : -1;
  }
  function sT(t, e) {
    let n = t.posAtCoords({
      x: e.clientX,
      y: e.clientY
    }, false), r = t.state.doc.lineAt(n), i = n - r.from, o = i > p1 ? -1 : i == r.length ? iK(t, e.clientX) : Pl(r.text, t.state.tabSize, n - r.from);
    return {
      line: r.number,
      col: o,
      off: i
    };
  }
  function oK(t, e) {
    let n = sT(t, e), r = t.state.selection;
    return n ? {
      update(i) {
        if (i.docChanged) {
          let o = i.changes.mapPos(i.startState.doc.line(n.line).from), s = i.state.doc.lineAt(o);
          n = {
            line: s.number,
            col: n.col,
            off: Math.min(n.off, s.length)
          }, r = r.map(i.changes);
        }
      },
      get(i, o, s) {
        let a = sT(t, i);
        if (!a)
          return r;
        let l = rK(t.state, n, a);
        return l.length ? s ? q.create(l.concat(r.ranges)) : q.create(l) : r;
      }
    } : null;
  }
  function sK(t) {
    let e = (t == null ? void 0 : t.eventFilter) || ((n) => n.altKey && n.button == 0);
    return ue.mouseSelectionStyle.of((n, r) => e(r) ? oK(n, r) : null);
  }
  const aK = {
    Alt: [
      18,
      (t) => !!t.altKey
    ],
    Control: [
      17,
      (t) => !!t.ctrlKey
    ],
    Shift: [
      16,
      (t) => !!t.shiftKey
    ],
    Meta: [
      91,
      (t) => !!t.metaKey
    ]
  }, lK = {
    style: "cursor: crosshair"
  };
  function cK(t = {}) {
    let [e, n] = aK[t.key || "Alt"], r = Ct.fromClass(class {
      constructor(i) {
        this.view = i, this.isDown = false;
      }
      set(i) {
        this.isDown != i && (this.isDown = i, this.view.update([]));
      }
    }, {
      eventObservers: {
        keydown(i) {
          this.set(i.keyCode == e || n(i));
        },
        keyup(i) {
          (i.keyCode == e || !n(i)) && this.set(false);
        },
        mousemove(i) {
          this.set(n(i));
        }
      }
    });
    return [
      r,
      ue.contentAttributes.of((i) => {
        var o;
        return !((o = i.plugin(r)) === null || o === void 0) && o.isDown ? lK : null;
      })
    ];
  }
  const ac = "-10000px";
  class ER {
    constructor(e, n, r, i) {
      this.facet = n, this.createTooltipView = r, this.removeTooltipView = i, this.input = e.state.facet(n), this.tooltips = this.input.filter((s) => s);
      let o = null;
      this.tooltipViews = this.tooltips.map((s) => o = r(s, o));
    }
    update(e, n) {
      var r;
      let i = e.state.facet(this.facet), o = i.filter((l) => l);
      if (i === this.input) {
        for (let l of this.tooltipViews)
          l.update && l.update(e);
        return false;
      }
      let s = [], a = n ? [] : null;
      for (let l = 0; l < o.length; l++) {
        let c = o[l], u = -1;
        if (!!c) {
          for (let h = 0; h < this.tooltips.length; h++) {
            let p = this.tooltips[h];
            p && p.create == c.create && (u = h);
          }
          if (u < 0)
            s[l] = this.createTooltipView(c, l ? s[l - 1] : null), a && (a[l] = !!c.above);
          else {
            let h = s[l] = this.tooltipViews[u];
            a && (a[l] = n[u]), h.update && h.update(e);
          }
        }
      }
      for (let l of this.tooltipViews)
        s.indexOf(l) < 0 && (this.removeTooltipView(l), (r = l.destroy) === null || r === void 0 || r.call(l));
      return n && (a.forEach((l, c) => n[c] = l), n.length = a.length), this.input = i, this.tooltips = o, this.tooltipViews = s, true;
    }
  }
  function uK(t) {
    let e = t.dom.ownerDocument.documentElement;
    return {
      top: 0,
      left: 0,
      bottom: e.clientHeight,
      right: e.clientWidth
    };
  }
  const z0 = me.define({
    combine: (t) => {
      var e, n, r;
      return {
        position: fe.ios ? "absolute" : ((e = t.find((i) => i.position)) === null || e === void 0 ? void 0 : e.position) || "fixed",
        parent: ((n = t.find((i) => i.parent)) === null || n === void 0 ? void 0 : n.parent) || null,
        tooltipSpace: ((r = t.find((i) => i.tooltipSpace)) === null || r === void 0 ? void 0 : r.tooltipSpace) || uK
      };
    }
  }), aT = /* @__PURE__ */ new WeakMap(), Nx = Ct.fromClass(class {
    constructor(t) {
      this.view = t, this.above = [], this.inView = true, this.madeAbsolute = false, this.lastTransaction = 0, this.measureTimeout = -1;
      let e = t.state.facet(z0);
      this.position = e.position, this.parent = e.parent, this.classes = t.themeClasses, this.createContainer(), this.measureReq = {
        read: this.readMeasure.bind(this),
        write: this.writeMeasure.bind(this),
        key: this
      }, this.resizeObserver = typeof ResizeObserver == "function" ? new ResizeObserver(() => this.measureSoon()) : null, this.manager = new ER(t, $x, (n, r) => this.createTooltip(n, r), (n) => {
        this.resizeObserver && this.resizeObserver.unobserve(n.dom), n.dom.remove();
      }), this.above = this.manager.tooltips.map((n) => !!n.above), this.intersectionObserver = typeof IntersectionObserver == "function" ? new IntersectionObserver((n) => {
        Date.now() > this.lastTransaction - 50 && n.length > 0 && n[n.length - 1].intersectionRatio < 1 && this.measureSoon();
      }, {
        threshold: [
          1
        ]
      }) : null, this.observeIntersection(), t.win.addEventListener("resize", this.measureSoon = this.measureSoon.bind(this)), this.maybeMeasure();
    }
    createContainer() {
      this.parent ? (this.container = document.createElement("div"), this.container.style.position = "relative", this.container.className = this.view.themeClasses, this.parent.appendChild(this.container)) : this.container = this.view.dom;
    }
    observeIntersection() {
      if (this.intersectionObserver) {
        this.intersectionObserver.disconnect();
        for (let t of this.manager.tooltipViews)
          this.intersectionObserver.observe(t.dom);
      }
    }
    measureSoon() {
      this.measureTimeout < 0 && (this.measureTimeout = setTimeout(() => {
        this.measureTimeout = -1, this.maybeMeasure();
      }, 50));
    }
    update(t) {
      t.transactions.length && (this.lastTransaction = Date.now());
      let e = this.manager.update(t, this.above);
      e && this.observeIntersection();
      let n = e || t.geometryChanged, r = t.state.facet(z0);
      if (r.position != this.position && !this.madeAbsolute) {
        this.position = r.position;
        for (let i of this.manager.tooltipViews)
          i.dom.style.position = this.position;
        n = true;
      }
      if (r.parent != this.parent) {
        this.parent && this.container.remove(), this.parent = r.parent, this.createContainer();
        for (let i of this.manager.tooltipViews)
          this.container.appendChild(i.dom);
        n = true;
      } else
        this.parent && this.view.themeClasses != this.classes && (this.classes = this.container.className = this.view.themeClasses);
      n && this.maybeMeasure();
    }
    createTooltip(t, e) {
      let n = t.create(this.view), r = e ? e.dom : null;
      if (n.dom.classList.add("cm-tooltip"), t.arrow && !n.dom.querySelector(".cm-tooltip > .cm-tooltip-arrow")) {
        let i = document.createElement("div");
        i.className = "cm-tooltip-arrow", n.dom.appendChild(i);
      }
      return n.dom.style.position = this.position, n.dom.style.top = ac, n.dom.style.left = "0px", this.container.insertBefore(n.dom, r), n.mount && n.mount(this.view), this.resizeObserver && this.resizeObserver.observe(n.dom), n;
    }
    destroy() {
      var t, e, n;
      this.view.win.removeEventListener("resize", this.measureSoon);
      for (let r of this.manager.tooltipViews)
        r.dom.remove(), (t = r.destroy) === null || t === void 0 || t.call(r);
      this.parent && this.container.remove(), (e = this.resizeObserver) === null || e === void 0 || e.disconnect(), (n = this.intersectionObserver) === null || n === void 0 || n.disconnect(), clearTimeout(this.measureTimeout);
    }
    readMeasure() {
      let t = 1, e = 1, n = false;
      if (this.position == "fixed" && this.manager.tooltipViews.length) {
        let { dom: o } = this.manager.tooltipViews[0];
        if (fe.gecko)
          n = o.offsetParent != this.container.ownerDocument.body;
        else if (o.style.top == ac && o.style.left == "0px") {
          let s = o.getBoundingClientRect();
          n = Math.abs(s.top + 1e4) > 1 || Math.abs(s.left) > 1;
        }
      }
      if (n || this.position == "absolute")
        if (this.parent) {
          let o = this.parent.getBoundingClientRect();
          o.width && o.height && (t = o.width / this.parent.offsetWidth, e = o.height / this.parent.offsetHeight);
        } else
          ({ scaleX: t, scaleY: e } = this.view.viewState);
      let r = this.view.scrollDOM.getBoundingClientRect(), i = _x(this.view);
      return {
        visible: {
          left: r.left + i.left,
          top: r.top + i.top,
          right: r.right - i.right,
          bottom: r.bottom - i.bottom
        },
        parent: this.parent ? this.container.getBoundingClientRect() : this.view.dom.getBoundingClientRect(),
        pos: this.manager.tooltips.map((o, s) => {
          let a = this.manager.tooltipViews[s];
          return a.getCoords ? a.getCoords(o.pos) : this.view.coordsAtPos(o.pos);
        }),
        size: this.manager.tooltipViews.map(({ dom: o }) => o.getBoundingClientRect()),
        space: this.view.state.facet(z0).tooltipSpace(this.view),
        scaleX: t,
        scaleY: e,
        makeAbsolute: n
      };
    }
    writeMeasure(t) {
      var e;
      if (t.makeAbsolute) {
        this.madeAbsolute = true, this.position = "absolute";
        for (let a of this.manager.tooltipViews)
          a.dom.style.position = "absolute";
      }
      let { visible: n, space: r, scaleX: i, scaleY: o } = t, s = [];
      for (let a = 0; a < this.manager.tooltips.length; a++) {
        let l = this.manager.tooltips[a], c = this.manager.tooltipViews[a], { dom: u } = c, h = t.pos[a], p = t.size[a];
        if (!h || l.clip !== false && (h.bottom <= Math.max(n.top, r.top) || h.top >= Math.min(n.bottom, r.bottom) || h.right < Math.max(n.left, r.left) - 0.1 || h.left > Math.min(n.right, r.right) + 0.1)) {
          u.style.top = ac;
          continue;
        }
        let v = l.arrow ? c.dom.querySelector(".cm-tooltip-arrow") : null, y = v ? 7 : 0, x = p.right - p.left, T = (e = aT.get(c)) !== null && e !== void 0 ? e : p.bottom - p.top, w = c.offset || hK, k = this.view.textDirection == rt.LTR, C = p.width > r.right - r.left ? k ? r.left : r.right - p.width : k ? Math.max(r.left, Math.min(h.left - (v ? 14 : 0) + w.x, r.right - x)) : Math.min(Math.max(r.left, h.left - x + (v ? 14 : 0) - w.x), r.right - x), P = this.above[a];
        !l.strictSide && (P ? h.top - T - y - w.y < r.top : h.bottom + T + y + w.y > r.bottom) && P == r.bottom - h.bottom > h.top - r.top && (P = this.above[a] = !P);
        let R = (P ? h.top - r.top : r.bottom - h.bottom) - y;
        if (R < T && c.resize !== false) {
          if (R < this.view.defaultLineHeight) {
            u.style.top = ac;
            continue;
          }
          aT.set(c, T), u.style.height = (T = R) / o + "px";
        } else
          u.style.height && (u.style.height = "");
        let L = P ? h.top - T - y - w.y : h.bottom + y + w.y, _ = C + x;
        if (c.overlap !== true)
          for (let F of s)
            F.left < _ && F.right > C && F.top < L + T && F.bottom > L && (L = P ? F.top - T - 2 - y : F.bottom + y + 2);
        if (this.position == "absolute" ? (u.style.top = (L - t.parent.top) / o + "px", lT(u, (C - t.parent.left) / i)) : (u.style.top = L / o + "px", lT(u, C / i)), v) {
          let F = h.left + (k ? w.x : -w.x) - (C + 14 - 7);
          v.style.left = F / i + "px";
        }
        c.overlap !== true && s.push({
          left: C,
          top: L,
          right: _,
          bottom: L + T
        }), u.classList.toggle("cm-tooltip-above", P), u.classList.toggle("cm-tooltip-below", !P), c.positioned && c.positioned(t.space);
      }
    }
    maybeMeasure() {
      if (this.manager.tooltips.length && (this.view.inView && this.view.requestMeasure(this.measureReq), this.inView != this.view.inView && (this.inView = this.view.inView, !this.inView)))
        for (let t of this.manager.tooltipViews)
          t.dom.style.top = ac;
    }
  }, {
    eventObservers: {
      scroll() {
        this.maybeMeasure();
      }
    }
  });
  function lT(t, e) {
    let n = parseInt(t.style.left, 10);
    (isNaN(n) || Math.abs(e - n) > 1) && (t.style.left = e + "px");
  }
  const fK = ue.baseTheme({
    ".cm-tooltip": {
      zIndex: 500,
      boxSizing: "border-box"
    },
    "&light .cm-tooltip": {
      border: "1px solid #bbb",
      backgroundColor: "#f5f5f5"
    },
    "&light .cm-tooltip-section:not(:first-child)": {
      borderTop: "1px solid #bbb"
    },
    "&dark .cm-tooltip": {
      backgroundColor: "#333338",
      color: "white"
    },
    ".cm-tooltip-arrow": {
      height: `${7}px`,
      width: `${7 * 2}px`,
      position: "absolute",
      zIndex: -1,
      overflow: "hidden",
      "&:before, &:after": {
        content: "''",
        position: "absolute",
        width: 0,
        height: 0,
        borderLeft: `${7}px solid transparent`,
        borderRight: `${7}px solid transparent`
      },
      ".cm-tooltip-above &": {
        bottom: `-${7}px`,
        "&:before": {
          borderTop: `${7}px solid #bbb`
        },
        "&:after": {
          borderTop: `${7}px solid #f5f5f5`,
          bottom: "1px"
        }
      },
      ".cm-tooltip-below &": {
        top: `-${7}px`,
        "&:before": {
          borderBottom: `${7}px solid #bbb`
        },
        "&:after": {
          borderBottom: `${7}px solid #f5f5f5`,
          top: "1px"
        }
      }
    },
    "&dark .cm-tooltip .cm-tooltip-arrow": {
      "&:before": {
        borderTopColor: "#333338",
        borderBottomColor: "#333338"
      },
      "&:after": {
        borderTopColor: "transparent",
        borderBottomColor: "transparent"
      }
    }
  }), hK = {
    x: 0,
    y: 0
  }, $x = me.define({
    enables: [
      Nx,
      fK
    ]
  }), Mp = me.define({
    combine: (t) => t.reduce((e, n) => e.concat(n), [])
  });
  class Hm {
    static create(e) {
      return new Hm(e);
    }
    constructor(e) {
      this.view = e, this.mounted = false, this.dom = document.createElement("div"), this.dom.classList.add("cm-tooltip-hover"), this.manager = new ER(e, Mp, (n, r) => this.createHostedView(n, r), (n) => n.dom.remove());
    }
    createHostedView(e, n) {
      let r = e.create(this.view);
      return r.dom.classList.add("cm-tooltip-section"), this.dom.insertBefore(r.dom, n ? n.dom.nextSibling : this.dom.firstChild), this.mounted && r.mount && r.mount(this.view), r;
    }
    mount(e) {
      for (let n of this.manager.tooltipViews)
        n.mount && n.mount(e);
      this.mounted = true;
    }
    positioned(e) {
      for (let n of this.manager.tooltipViews)
        n.positioned && n.positioned(e);
    }
    update(e) {
      this.manager.update(e);
    }
    destroy() {
      var e;
      for (let n of this.manager.tooltipViews)
        (e = n.destroy) === null || e === void 0 || e.call(n);
    }
    passProp(e) {
      let n;
      for (let r of this.manager.tooltipViews) {
        let i = r[e];
        if (i !== void 0) {
          if (n === void 0)
            n = i;
          else if (n !== i)
            return;
        }
      }
      return n;
    }
    get offset() {
      return this.passProp("offset");
    }
    get getCoords() {
      return this.passProp("getCoords");
    }
    get overlap() {
      return this.passProp("overlap");
    }
    get resize() {
      return this.passProp("resize");
    }
  }
  const dK = $x.compute([
    Mp
  ], (t) => {
    let e = t.facet(Mp);
    return e.length === 0 ? null : {
      pos: Math.min(...e.map((n) => n.pos)),
      end: Math.max(...e.map((n) => {
        var r;
        return (r = n.end) !== null && r !== void 0 ? r : n.pos;
      })),
      create: Hm.create,
      above: e[0].above,
      arrow: e.some((n) => n.arrow)
    };
  });
  class pK {
    constructor(e, n, r, i, o) {
      this.view = e, this.source = n, this.field = r, this.setHover = i, this.hoverTime = o, this.hoverTimeout = -1, this.restartTimeout = -1, this.pending = null, this.lastMove = {
        x: 0,
        y: 0,
        target: e.dom,
        time: 0
      }, this.checkHover = this.checkHover.bind(this), e.dom.addEventListener("mouseleave", this.mouseleave = this.mouseleave.bind(this)), e.dom.addEventListener("mousemove", this.mousemove = this.mousemove.bind(this));
    }
    update() {
      this.pending && (this.pending = null, clearTimeout(this.restartTimeout), this.restartTimeout = setTimeout(() => this.startHover(), 20));
    }
    get active() {
      return this.view.state.field(this.field);
    }
    checkHover() {
      if (this.hoverTimeout = -1, this.active.length)
        return;
      let e = Date.now() - this.lastMove.time;
      e < this.hoverTime ? this.hoverTimeout = setTimeout(this.checkHover, this.hoverTime - e) : this.startHover();
    }
    startHover() {
      clearTimeout(this.restartTimeout);
      let { view: e, lastMove: n } = this, r = e.docView.nearest(n.target);
      if (!r)
        return;
      let i, o = 1;
      if (r instanceof _o)
        i = r.posAtStart;
      else {
        if (i = e.posAtCoords(n), i == null)
          return;
        let a = e.coordsAtPos(i);
        if (!a || n.y < a.top || n.y > a.bottom || n.x < a.left - e.defaultCharacterWidth || n.x > a.right + e.defaultCharacterWidth)
          return;
        let l = e.bidiSpans(e.state.doc.lineAt(i)).find((u) => u.from <= i && u.to >= i), c = l && l.dir == rt.RTL ? -1 : 1;
        o = n.x < a.left ? -c : c;
      }
      let s = this.source(e, i, o);
      if (s == null ? void 0 : s.then) {
        let a = this.pending = {
          pos: i
        };
        s.then((l) => {
          this.pending == a && (this.pending = null, l && !(Array.isArray(l) && !l.length) && e.dispatch({
            effects: this.setHover.of(Array.isArray(l) ? l : [
              l
            ])
          }));
        }, (l) => Bn(e.state, l, "hover tooltip"));
      } else
        s && !(Array.isArray(s) && !s.length) && e.dispatch({
          effects: this.setHover.of(Array.isArray(s) ? s : [
            s
          ])
        });
    }
    get tooltip() {
      let e = this.view.plugin(Nx), n = e ? e.manager.tooltips.findIndex((r) => r.create == Hm.create) : -1;
      return n > -1 ? e.manager.tooltipViews[n] : null;
    }
    mousemove(e) {
      var n, r;
      this.lastMove = {
        x: e.clientX,
        y: e.clientY,
        target: e.target,
        time: Date.now()
      }, this.hoverTimeout < 0 && (this.hoverTimeout = setTimeout(this.checkHover, this.hoverTime));
      let { active: i, tooltip: o } = this;
      if (i.length && o && !mK(o.dom, e) || this.pending) {
        let { pos: s } = i[0] || this.pending, a = (r = (n = i[0]) === null || n === void 0 ? void 0 : n.end) !== null && r !== void 0 ? r : s;
        (s == a ? this.view.posAtCoords(this.lastMove) != s : !gK(this.view, s, a, e.clientX, e.clientY)) && (this.view.dispatch({
          effects: this.setHover.of([])
        }), this.pending = null);
      }
    }
    mouseleave(e) {
      clearTimeout(this.hoverTimeout), this.hoverTimeout = -1;
      let { active: n } = this;
      if (n.length) {
        let { tooltip: r } = this;
        r && r.dom.contains(e.relatedTarget) ? this.watchTooltipLeave(r.dom) : this.view.dispatch({
          effects: this.setHover.of([])
        });
      }
    }
    watchTooltipLeave(e) {
      let n = (r) => {
        e.removeEventListener("mouseleave", n), this.active.length && !this.view.dom.contains(r.relatedTarget) && this.view.dispatch({
          effects: this.setHover.of([])
        });
      };
      e.addEventListener("mouseleave", n);
    }
    destroy() {
      clearTimeout(this.hoverTimeout), this.view.dom.removeEventListener("mouseleave", this.mouseleave), this.view.dom.removeEventListener("mousemove", this.mousemove);
    }
  }
  const _h = 4;
  function mK(t, e) {
    let { left: n, right: r, top: i, bottom: o } = t.getBoundingClientRect(), s;
    if (s = t.querySelector(".cm-tooltip-arrow")) {
      let a = s.getBoundingClientRect();
      i = Math.min(a.top, i), o = Math.max(a.bottom, o);
    }
    return e.clientX >= n - _h && e.clientX <= r + _h && e.clientY >= i - _h && e.clientY <= o + _h;
  }
  function gK(t, e, n, r, i, o) {
    let s = t.scrollDOM.getBoundingClientRect(), a = t.documentTop + t.documentPadding.top + t.contentHeight;
    if (s.left > r || s.right < r || s.top > i || Math.min(s.bottom, a) < i)
      return false;
    let l = t.posAtCoords({
      x: r,
      y: i
    }, false);
    return l >= e && l <= n;
  }
  function vK(t, e = {}) {
    let n = Ee.define(), r = Ut.define({
      create() {
        return [];
      },
      update(i, o) {
        if (i.length && (e.hideOnChange && (o.docChanged || o.selection) ? i = [] : e.hideOn && (i = i.filter((s) => !e.hideOn(o, s))), o.docChanged)) {
          let s = [];
          for (let a of i) {
            let l = o.changes.mapPos(a.pos, -1, Zt.TrackDel);
            if (l != null) {
              let c = Object.assign(/* @__PURE__ */ Object.create(null), a);
              c.pos = l, c.end != null && (c.end = o.changes.mapPos(c.end)), s.push(c);
            }
          }
          i = s;
        }
        for (let s of o.effects)
          s.is(n) && (i = s.value), s.is(yK) && (i = []);
        return i;
      },
      provide: (i) => Mp.from(i)
    });
    return {
      active: r,
      extension: [
        r,
        Ct.define((i) => new pK(i, t, r, n, e.hoverTime || 300)),
        dK
      ]
    };
  }
  function PR(t, e) {
    let n = t.plugin(Nx);
    if (!n)
      return null;
    let r = n.manager.tooltips.indexOf(e);
    return r < 0 ? null : n.manager.tooltipViews[r];
  }
  const yK = Ee.define(), cT = me.define({
    combine(t) {
      let e, n;
      for (let r of t)
        e = e || r.topContainer, n = n || r.bottomContainer;
      return {
        topContainer: e,
        bottomContainer: n
      };
    }
  });
  function zu(t, e) {
    let n = t.plugin(OR), r = n ? n.specs.indexOf(e) : -1;
    return r > -1 ? n.panels[r] : null;
  }
  const OR = Ct.fromClass(class {
    constructor(t) {
      this.input = t.state.facet(Gs), this.specs = this.input.filter((n) => n), this.panels = this.specs.map((n) => n(t));
      let e = t.state.facet(cT);
      this.top = new Dh(t, true, e.topContainer), this.bottom = new Dh(t, false, e.bottomContainer), this.top.sync(this.panels.filter((n) => n.top)), this.bottom.sync(this.panels.filter((n) => !n.top));
      for (let n of this.panels)
        n.dom.classList.add("cm-panel"), n.mount && n.mount();
    }
    update(t) {
      let e = t.state.facet(cT);
      this.top.container != e.topContainer && (this.top.sync([]), this.top = new Dh(t.view, true, e.topContainer)), this.bottom.container != e.bottomContainer && (this.bottom.sync([]), this.bottom = new Dh(t.view, false, e.bottomContainer)), this.top.syncClasses(), this.bottom.syncClasses();
      let n = t.state.facet(Gs);
      if (n != this.input) {
        let r = n.filter((l) => l), i = [], o = [], s = [], a = [];
        for (let l of r) {
          let c = this.specs.indexOf(l), u;
          c < 0 ? (u = l(t.view), a.push(u)) : (u = this.panels[c], u.update && u.update(t)), i.push(u), (u.top ? o : s).push(u);
        }
        this.specs = r, this.panels = i, this.top.sync(o), this.bottom.sync(s);
        for (let l of a)
          l.dom.classList.add("cm-panel"), l.mount && l.mount();
      } else
        for (let r of this.panels)
          r.update && r.update(t);
    }
    destroy() {
      this.top.sync([]), this.bottom.sync([]);
    }
  }, {
    provide: (t) => ue.scrollMargins.of((e) => {
      let n = e.plugin(t);
      return n && {
        top: n.top.scrollMargin(),
        bottom: n.bottom.scrollMargin()
      };
    })
  });
  class Dh {
    constructor(e, n, r) {
      this.view = e, this.top = n, this.container = r, this.dom = void 0, this.classes = "", this.panels = [], this.syncClasses();
    }
    sync(e) {
      for (let n of this.panels)
        n.destroy && e.indexOf(n) < 0 && n.destroy();
      this.panels = e, this.syncDOM();
    }
    syncDOM() {
      if (this.panels.length == 0) {
        this.dom && (this.dom.remove(), this.dom = void 0);
        return;
      }
      if (!this.dom) {
        this.dom = document.createElement("div"), this.dom.className = this.top ? "cm-panels cm-panels-top" : "cm-panels cm-panels-bottom", this.dom.style[this.top ? "top" : "bottom"] = "0";
        let n = this.container || this.view.dom;
        n.insertBefore(this.dom, this.top ? n.firstChild : null);
      }
      let e = this.dom.firstChild;
      for (let n of this.panels)
        if (n.dom.parentNode == this.dom) {
          for (; e != n.dom; )
            e = uT(e);
          e = e.nextSibling;
        } else
          this.dom.insertBefore(n.dom, e);
      for (; e; )
        e = uT(e);
    }
    scrollMargin() {
      return !this.dom || this.container ? 0 : Math.max(0, this.top ? this.dom.getBoundingClientRect().bottom - Math.max(0, this.view.scrollDOM.getBoundingClientRect().top) : Math.min(innerHeight, this.view.scrollDOM.getBoundingClientRect().bottom) - this.dom.getBoundingClientRect().top);
    }
    syncClasses() {
      if (!(!this.container || this.classes == this.view.themeClasses)) {
        for (let e of this.classes.split(" "))
          e && this.container.classList.remove(e);
        for (let e of (this.classes = this.view.themeClasses).split(" "))
          e && this.container.classList.add(e);
      }
    }
  }
  function uT(t) {
    let e = t.nextSibling;
    return t.remove(), e;
  }
  const Gs = me.define({
    enables: OR
  });
  class ro extends Ws {
    compare(e) {
      return this == e || this.constructor == e.constructor && this.eq(e);
    }
    eq(e) {
      return false;
    }
    destroy(e) {
    }
  }
  ro.prototype.elementClass = "";
  ro.prototype.toDOM = void 0;
  ro.prototype.mapMode = Zt.TrackBefore;
  ro.prototype.startSide = ro.prototype.endSide = -1;
  ro.prototype.point = true;
  const Ad = me.define(), bK = me.define(), xK = {
    class: "",
    renderEmptyElements: false,
    elementStyle: "",
    markers: () => Ve.empty,
    lineMarker: () => null,
    widgetMarker: () => null,
    lineMarkerChange: null,
    initialSpacer: null,
    updateSpacer: null,
    domEventHandlers: {},
    side: "before"
  }, eu = me.define();
  function SK(t) {
    return [
      RR(),
      eu.of({
        ...xK,
        ...t
      })
    ];
  }
  const m1 = me.define({
    combine: (t) => t.some((e) => e)
  });
  function RR(t) {
    let e = [
      wK
    ];
    return t && t.fixed === false && e.push(m1.of(true)), e;
  }
  const wK = Ct.fromClass(class {
    constructor(t) {
      this.view = t, this.domAfter = null, this.prevViewport = t.viewport, this.dom = document.createElement("div"), this.dom.className = "cm-gutters cm-gutters-before", this.dom.setAttribute("aria-hidden", "true"), this.dom.style.minHeight = this.view.contentHeight / this.view.scaleY + "px", this.gutters = t.state.facet(eu).map((e) => new hT(t, e)), this.fixed = !t.state.facet(m1);
      for (let e of this.gutters)
        e.config.side == "after" ? this.getDOMAfter().appendChild(e.dom) : this.dom.appendChild(e.dom);
      this.fixed && (this.dom.style.position = "sticky"), this.syncGutters(false), t.scrollDOM.insertBefore(this.dom, t.contentDOM);
    }
    getDOMAfter() {
      return this.domAfter || (this.domAfter = document.createElement("div"), this.domAfter.className = "cm-gutters cm-gutters-after", this.domAfter.setAttribute("aria-hidden", "true"), this.domAfter.style.minHeight = this.view.contentHeight / this.view.scaleY + "px", this.domAfter.style.position = this.fixed ? "sticky" : "", this.view.scrollDOM.appendChild(this.domAfter)), this.domAfter;
    }
    update(t) {
      if (this.updateGutters(t)) {
        let e = this.prevViewport, n = t.view.viewport, r = Math.min(e.to, n.to) - Math.max(e.from, n.from);
        this.syncGutters(r < (n.to - n.from) * 0.8);
      }
      if (t.geometryChanged) {
        let e = this.view.contentHeight / this.view.scaleY + "px";
        this.dom.style.minHeight = e, this.domAfter && (this.domAfter.style.minHeight = e);
      }
      this.view.state.facet(m1) != !this.fixed && (this.fixed = !this.fixed, this.dom.style.position = this.fixed ? "sticky" : "", this.domAfter && (this.domAfter.style.position = this.fixed ? "sticky" : "")), this.prevViewport = t.view.viewport;
    }
    syncGutters(t) {
      let e = this.dom.nextSibling;
      t && (this.dom.remove(), this.domAfter && this.domAfter.remove());
      let n = Ve.iter(this.view.state.facet(Ad), this.view.viewport.from), r = [], i = this.gutters.map((o) => new kK(o, this.view.viewport, -this.view.documentPadding.top));
      for (let o of this.view.viewportLineBlocks)
        if (r.length && (r = []), Array.isArray(o.type)) {
          let s = true;
          for (let a of o.type)
            if (a.type == Cn.Text && s) {
              g1(n, r, a.from);
              for (let l of i)
                l.line(this.view, a, r);
              s = false;
            } else if (a.widget)
              for (let l of i)
                l.widget(this.view, a);
        } else if (o.type == Cn.Text) {
          g1(n, r, o.from);
          for (let s of i)
            s.line(this.view, o, r);
        } else if (o.widget)
          for (let s of i)
            s.widget(this.view, o);
      for (let o of i)
        o.finish();
      t && (this.view.scrollDOM.insertBefore(this.dom, e), this.domAfter && this.view.scrollDOM.appendChild(this.domAfter));
    }
    updateGutters(t) {
      let e = t.startState.facet(eu), n = t.state.facet(eu), r = t.docChanged || t.heightChanged || t.viewportChanged || !Ve.eq(t.startState.facet(Ad), t.state.facet(Ad), t.view.viewport.from, t.view.viewport.to);
      if (e == n)
        for (let i of this.gutters)
          i.update(t) && (r = true);
      else {
        r = true;
        let i = [];
        for (let o of n) {
          let s = e.indexOf(o);
          s < 0 ? i.push(new hT(this.view, o)) : (this.gutters[s].update(t), i.push(this.gutters[s]));
        }
        for (let o of this.gutters)
          o.dom.remove(), i.indexOf(o) < 0 && o.destroy();
        for (let o of i)
          o.config.side == "after" ? this.getDOMAfter().appendChild(o.dom) : this.dom.appendChild(o.dom);
        this.gutters = i;
      }
      return r;
    }
    destroy() {
      for (let t of this.gutters)
        t.destroy();
      this.dom.remove(), this.domAfter && this.domAfter.remove();
    }
  }, {
    provide: (t) => ue.scrollMargins.of((e) => {
      let n = e.plugin(t);
      if (!n || n.gutters.length == 0 || !n.fixed)
        return null;
      let r = n.dom.offsetWidth * e.scaleX, i = n.domAfter ? n.domAfter.offsetWidth * e.scaleX : 0;
      return e.textDirection == rt.LTR ? {
        left: r,
        right: i
      } : {
        right: r,
        left: i
      };
    })
  });
  function fT(t) {
    return Array.isArray(t) ? t : [
      t
    ];
  }
  function g1(t, e, n) {
    for (; t.value && t.from <= n; )
      t.from == n && e.push(t.value), t.next();
  }
  class kK {
    constructor(e, n, r) {
      this.gutter = e, this.height = r, this.i = 0, this.cursor = Ve.iter(e.markers, n.from);
    }
    addElement(e, n, r) {
      let { gutter: i } = this, o = (n.top - this.height) / e.scaleY, s = n.height / e.scaleY;
      if (this.i == i.elements.length) {
        let a = new LR(e, s, o, r);
        i.elements.push(a), i.dom.appendChild(a.dom);
      } else
        i.elements[this.i].update(e, s, o, r);
      this.height = n.bottom, this.i++;
    }
    line(e, n, r) {
      let i = [];
      g1(this.cursor, i, n.from), r.length && (i = i.concat(r));
      let o = this.gutter.config.lineMarker(e, n, i);
      o && i.unshift(o);
      let s = this.gutter;
      i.length == 0 && !s.config.renderEmptyElements || this.addElement(e, n, i);
    }
    widget(e, n) {
      let r = this.gutter.config.widgetMarker(e, n.widget, n), i = r ? [
        r
      ] : null;
      for (let o of e.state.facet(bK)) {
        let s = o(e, n.widget, n);
        s && (i || (i = [])).push(s);
      }
      i && this.addElement(e, n, i);
    }
    finish() {
      let e = this.gutter;
      for (; e.elements.length > this.i; ) {
        let n = e.elements.pop();
        e.dom.removeChild(n.dom), n.destroy();
      }
    }
  }
  class hT {
    constructor(e, n) {
      this.view = e, this.config = n, this.elements = [], this.spacer = null, this.dom = document.createElement("div"), this.dom.className = "cm-gutter" + (this.config.class ? " " + this.config.class : "");
      for (let r in n.domEventHandlers)
        this.dom.addEventListener(r, (i) => {
          let o = i.target, s;
          if (o != this.dom && this.dom.contains(o)) {
            for (; o.parentNode != this.dom; )
              o = o.parentNode;
            let l = o.getBoundingClientRect();
            s = (l.top + l.bottom) / 2;
          } else
            s = i.clientY;
          let a = e.lineBlockAtHeight(s - e.documentTop);
          n.domEventHandlers[r](e, a, i) && i.preventDefault();
        });
      this.markers = fT(n.markers(e)), n.initialSpacer && (this.spacer = new LR(e, 0, 0, [
        n.initialSpacer(e)
      ]), this.dom.appendChild(this.spacer.dom), this.spacer.dom.style.cssText += "visibility: hidden; pointer-events: none");
    }
    update(e) {
      let n = this.markers;
      if (this.markers = fT(this.config.markers(e.view)), this.spacer && this.config.updateSpacer) {
        let i = this.config.updateSpacer(this.spacer.markers[0], e);
        i != this.spacer.markers[0] && this.spacer.update(e.view, 0, 0, [
          i
        ]);
      }
      let r = e.view.viewport;
      return !Ve.eq(this.markers, n, r.from, r.to) || (this.config.lineMarkerChange ? this.config.lineMarkerChange(e) : false);
    }
    destroy() {
      for (let e of this.elements)
        e.destroy();
    }
  }
  class LR {
    constructor(e, n, r, i) {
      this.height = -1, this.above = 0, this.markers = [], this.dom = document.createElement("div"), this.dom.className = "cm-gutterElement", this.update(e, n, r, i);
    }
    update(e, n, r, i) {
      this.height != n && (this.height = n, this.dom.style.height = n + "px"), this.above != r && (this.dom.style.marginTop = (this.above = r) ? r + "px" : ""), CK(this.markers, i) || this.setMarkers(e, i);
    }
    setMarkers(e, n) {
      let r = "cm-gutterElement", i = this.dom.firstChild;
      for (let o = 0, s = 0; ; ) {
        let a = s, l = o < n.length ? n[o++] : null, c = false;
        if (l) {
          let u = l.elementClass;
          u && (r += " " + u);
          for (let h = s; h < this.markers.length; h++)
            if (this.markers[h].compare(l)) {
              a = h, c = true;
              break;
            }
        } else
          a = this.markers.length;
        for (; s < a; ) {
          let u = this.markers[s++];
          if (u.toDOM) {
            u.destroy(i);
            let h = i.nextSibling;
            i.remove(), i = h;
          }
        }
        if (!l)
          break;
        l.toDOM && (c ? i = i.nextSibling : this.dom.insertBefore(l.toDOM(e), i)), c && s++;
      }
      this.dom.className = r, this.markers = n;
    }
    destroy() {
      this.setMarkers(null, []);
    }
  }
  function CK(t, e) {
    if (t.length != e.length)
      return false;
    for (let n = 0; n < t.length; n++)
      if (!t[n].compare(e[n]))
        return false;
    return true;
  }
  const TK = me.define(), MK = me.define(), Da = me.define({
    combine(t) {
      return Oi(t, {
        formatNumber: String,
        domEventHandlers: {}
      }, {
        domEventHandlers(e, n) {
          let r = Object.assign({}, e);
          for (let i in n) {
            let o = r[i], s = n[i];
            r[i] = o ? (a, l, c) => o(a, l, c) || s(a, l, c) : s;
          }
          return r;
        }
      });
    }
  });
  class F0 extends ro {
    constructor(e) {
      super(), this.number = e;
    }
    eq(e) {
      return this.number == e.number;
    }
    toDOM() {
      return document.createTextNode(this.number);
    }
  }
  function V0(t, e) {
    return t.state.facet(Da).formatNumber(e, t.state);
  }
  const AK = eu.compute([
    Da
  ], (t) => ({
    class: "cm-lineNumbers",
    renderEmptyElements: false,
    markers(e) {
      return e.state.facet(TK);
    },
    lineMarker(e, n, r) {
      return r.some((i) => i.toDOM) ? null : new F0(V0(e, e.state.doc.lineAt(n.from).number));
    },
    widgetMarker: (e, n, r) => {
      for (let i of e.state.facet(MK)) {
        let o = i(e, n, r);
        if (o)
          return o;
      }
      return null;
    },
    lineMarkerChange: (e) => e.startState.facet(Da) != e.state.facet(Da),
    initialSpacer(e) {
      return new F0(V0(e, dT(e.state.doc.lines)));
    },
    updateSpacer(e, n) {
      let r = V0(n.view, dT(n.view.state.doc.lines));
      return r == e.number ? e : new F0(r);
    },
    domEventHandlers: t.facet(Da).domEventHandlers,
    side: "before"
  }));
  function EK(t = {}) {
    return [
      Da.of(t),
      RR(),
      AK
    ];
  }
  function dT(t) {
    let e = 9;
    for (; e < t; )
      e = e * 10 + 9;
    return e;
  }
  const PK = new class extends ro {
    constructor() {
      super(...arguments), this.elementClass = "cm-activeLineGutter";
    }
  }(), OK = Ad.compute([
    "selection"
  ], (t) => {
    let e = [], n = -1;
    for (let r of t.selection.ranges) {
      let i = t.doc.lineAt(r.head).from;
      i > n && (n = i, e.push(PK.range(i)));
    }
    return Ve.of(e);
  });
  function RK() {
    return OK;
  }
  const LK = 1024;
  let _K = 0;
  class H0 {
    constructor(e, n) {
      this.from = e, this.to = n;
    }
  }
  class $e {
    constructor(e = {}) {
      this.id = _K++, this.perNode = !!e.perNode, this.deserialize = e.deserialize || (() => {
        throw new Error("This node type doesn't define a deserialize function");
      }), this.combine = e.combine || null;
    }
    add(e) {
      if (this.perNode)
        throw new RangeError("Can't add per-node props to node types");
      return typeof e != "function" && (e = Tr.match(e)), (n) => {
        let r = e(n);
        return r === void 0 ? null : [
          this,
          r
        ];
      };
    }
  }
  $e.closedBy = new $e({
    deserialize: (t) => t.split(" ")
  });
  $e.openedBy = new $e({
    deserialize: (t) => t.split(" ")
  });
  $e.group = new $e({
    deserialize: (t) => t.split(" ")
  });
  $e.isolate = new $e({
    deserialize: (t) => {
      if (t && t != "rtl" && t != "ltr" && t != "auto")
        throw new RangeError("Invalid value for isolate: " + t);
      return t || "auto";
    }
  });
  $e.contextHash = new $e({
    perNode: true
  });
  $e.lookAhead = new $e({
    perNode: true
  });
  $e.mounted = new $e({
    perNode: true
  });
  class Ap {
    constructor(e, n, r) {
      this.tree = e, this.overlay = n, this.parser = r;
    }
    static get(e) {
      return e && e.props && e.props[$e.mounted.id];
    }
  }
  const DK = /* @__PURE__ */ Object.create(null);
  class Tr {
    constructor(e, n, r, i = 0) {
      this.name = e, this.props = n, this.id = r, this.flags = i;
    }
    static define(e) {
      let n = e.props && e.props.length ? /* @__PURE__ */ Object.create(null) : DK, r = (e.top ? 1 : 0) | (e.skipped ? 2 : 0) | (e.error ? 4 : 0) | (e.name == null ? 8 : 0), i = new Tr(e.name || "", n, e.id, r);
      if (e.props) {
        for (let o of e.props)
          if (Array.isArray(o) || (o = o(i)), o) {
            if (o[0].perNode)
              throw new RangeError("Can't store a per-node prop on a node type");
            n[o[0].id] = o[1];
          }
      }
      return i;
    }
    prop(e) {
      return this.props[e.id];
    }
    get isTop() {
      return (this.flags & 1) > 0;
    }
    get isSkipped() {
      return (this.flags & 2) > 0;
    }
    get isError() {
      return (this.flags & 4) > 0;
    }
    get isAnonymous() {
      return (this.flags & 8) > 0;
    }
    is(e) {
      if (typeof e == "string") {
        if (this.name == e)
          return true;
        let n = this.prop($e.group);
        return n ? n.indexOf(e) > -1 : false;
      }
      return this.id == e;
    }
    static match(e) {
      let n = /* @__PURE__ */ Object.create(null);
      for (let r in e)
        for (let i of r.split(" "))
          n[i] = e[r];
      return (r) => {
        for (let i = r.prop($e.group), o = -1; o < (i ? i.length : 0); o++) {
          let s = n[o < 0 ? r.name : i[o]];
          if (s)
            return s;
        }
      };
    }
  }
  Tr.none = new Tr("", /* @__PURE__ */ Object.create(null), 0, 8);
  const Ih = /* @__PURE__ */ new WeakMap(), pT = /* @__PURE__ */ new WeakMap();
  var Jt;
  (function(t) {
    t[t.ExcludeBuffers = 1] = "ExcludeBuffers", t[t.IncludeAnonymous = 2] = "IncludeAnonymous", t[t.IgnoreMounts = 4] = "IgnoreMounts", t[t.IgnoreOverlays = 8] = "IgnoreOverlays";
  })(Jt || (Jt = {}));
  class dn {
    constructor(e, n, r, i, o) {
      if (this.type = e, this.children = n, this.positions = r, this.length = i, this.props = null, o && o.length) {
        this.props = /* @__PURE__ */ Object.create(null);
        for (let [s, a] of o)
          this.props[typeof s == "number" ? s : s.id] = a;
      }
    }
    toString() {
      let e = Ap.get(this);
      if (e && !e.overlay)
        return e.tree.toString();
      let n = "";
      for (let r of this.children) {
        let i = r.toString();
        i && (n && (n += ","), n += i);
      }
      return this.type.name ? (/\W/.test(this.type.name) && !this.type.isError ? JSON.stringify(this.type.name) : this.type.name) + (n.length ? "(" + n + ")" : "") : n;
    }
    cursor(e = 0) {
      return new y1(this.topNode, e);
    }
    cursorAt(e, n = 0, r = 0) {
      let i = Ih.get(this) || this.topNode, o = new y1(i);
      return o.moveTo(e, n), Ih.set(this, o._tree), o;
    }
    get topNode() {
      return new Sr(this, 0, 0, null);
    }
    resolve(e, n = 0) {
      let r = Fu(Ih.get(this) || this.topNode, e, n, false);
      return Ih.set(this, r), r;
    }
    resolveInner(e, n = 0) {
      let r = Fu(pT.get(this) || this.topNode, e, n, true);
      return pT.set(this, r), r;
    }
    resolveStack(e, n = 0) {
      return NK(this, e, n);
    }
    iterate(e) {
      let { enter: n, leave: r, from: i = 0, to: o = this.length } = e, s = e.mode || 0, a = (s & Jt.IncludeAnonymous) > 0;
      for (let l = this.cursor(s | Jt.IncludeAnonymous); ; ) {
        let c = false;
        if (l.from <= o && l.to >= i && (!a && l.type.isAnonymous || n(l) !== false)) {
          if (l.firstChild())
            continue;
          c = true;
        }
        for (; c && r && (a || !l.type.isAnonymous) && r(l), !l.nextSibling(); ) {
          if (!l.parent())
            return;
          c = true;
        }
      }
    }
    prop(e) {
      return e.perNode ? this.props ? this.props[e.id] : void 0 : this.type.prop(e);
    }
    get propValues() {
      let e = [];
      if (this.props)
        for (let n in this.props)
          e.push([
            +n,
            this.props[n]
          ]);
      return e;
    }
    balance(e = {}) {
      return this.children.length <= 8 ? this : Vx(Tr.none, this.children, this.positions, 0, this.children.length, 0, this.length, (n, r, i) => new dn(this.type, n, r, i, this.propValues), e.makeTree || ((n, r, i) => new dn(Tr.none, n, r, i)));
    }
    static build(e) {
      return $K(e);
    }
  }
  dn.empty = new dn(Tr.none, [], [], 0);
  class zx {
    constructor(e, n) {
      this.buffer = e, this.index = n;
    }
    get id() {
      return this.buffer[this.index - 4];
    }
    get start() {
      return this.buffer[this.index - 3];
    }
    get end() {
      return this.buffer[this.index - 2];
    }
    get size() {
      return this.buffer[this.index - 1];
    }
    get pos() {
      return this.index;
    }
    next() {
      this.index -= 4;
    }
    fork() {
      return new zx(this.buffer, this.index);
    }
  }
  class Xo {
    constructor(e, n, r) {
      this.buffer = e, this.length = n, this.set = r;
    }
    get type() {
      return Tr.none;
    }
    toString() {
      let e = [];
      for (let n = 0; n < this.buffer.length; )
        e.push(this.childString(n)), n = this.buffer[n + 3];
      return e.join(",");
    }
    childString(e) {
      let n = this.buffer[e], r = this.buffer[e + 3], i = this.set.types[n], o = i.name;
      if (/\W/.test(o) && !i.isError && (o = JSON.stringify(o)), e += 4, r == e)
        return o;
      let s = [];
      for (; e < r; )
        s.push(this.childString(e)), e = this.buffer[e + 3];
      return o + "(" + s.join(",") + ")";
    }
    findChild(e, n, r, i, o) {
      let { buffer: s } = this, a = -1;
      for (let l = e; l != n && !(_R(o, i, s[l + 1], s[l + 2]) && (a = l, r > 0)); l = s[l + 3])
        ;
      return a;
    }
    slice(e, n, r) {
      let i = this.buffer, o = new Uint16Array(n - e), s = 0;
      for (let a = e, l = 0; a < n; ) {
        o[l++] = i[a++], o[l++] = i[a++] - r;
        let c = o[l++] = i[a++] - r;
        o[l++] = i[a++] - e, s = Math.max(s, c);
      }
      return new Xo(o, s, this.set);
    }
  }
  function _R(t, e, n, r) {
    switch (t) {
      case -2:
        return n < e;
      case -1:
        return r >= e && n < e;
      case 0:
        return n < e && r > e;
      case 1:
        return n <= e && r > e;
      case 2:
        return r > e;
      case 4:
        return true;
    }
  }
  function Fu(t, e, n, r) {
    for (var i; t.from == t.to || (n < 1 ? t.from >= e : t.from > e) || (n > -1 ? t.to <= e : t.to < e); ) {
      let s = !r && t instanceof Sr && t.index < 0 ? null : t.parent;
      if (!s)
        return t;
      t = s;
    }
    let o = r ? 0 : Jt.IgnoreOverlays;
    if (r)
      for (let s = t, a = s.parent; a; s = a, a = s.parent)
        s instanceof Sr && s.index < 0 && ((i = a.enter(e, n, o)) === null || i === void 0 ? void 0 : i.from) != s.from && (t = a);
    for (; ; ) {
      let s = t.enter(e, n, o);
      if (!s)
        return t;
      t = s;
    }
  }
  class DR {
    cursor(e = 0) {
      return new y1(this, e);
    }
    getChild(e, n = null, r = null) {
      let i = mT(this, e, n, r);
      return i.length ? i[0] : null;
    }
    getChildren(e, n = null, r = null) {
      return mT(this, e, n, r);
    }
    resolve(e, n = 0) {
      return Fu(this, e, n, false);
    }
    resolveInner(e, n = 0) {
      return Fu(this, e, n, true);
    }
    matchContext(e) {
      return v1(this.parent, e);
    }
    enterUnfinishedNodesBefore(e) {
      let n = this.childBefore(e), r = this;
      for (; n; ) {
        let i = n.lastChild;
        if (!i || i.to != n.to)
          break;
        i.type.isError && i.from == i.to ? (r = n, n = i.prevSibling) : n = i;
      }
      return r;
    }
    get node() {
      return this;
    }
    get next() {
      return this.parent;
    }
  }
  class Sr extends DR {
    constructor(e, n, r, i) {
      super(), this._tree = e, this.from = n, this.index = r, this._parent = i;
    }
    get type() {
      return this._tree.type;
    }
    get name() {
      return this._tree.type.name;
    }
    get to() {
      return this.from + this._tree.length;
    }
    nextChild(e, n, r, i, o = 0) {
      for (let s = this; ; ) {
        for (let { children: a, positions: l } = s._tree, c = n > 0 ? a.length : -1; e != c; e += n) {
          let u = a[e], h = l[e] + s.from;
          if (!!_R(i, r, h, h + u.length)) {
            if (u instanceof Xo) {
              if (o & Jt.ExcludeBuffers)
                continue;
              let p = u.findChild(0, u.buffer.length, n, r - h, i);
              if (p > -1)
                return new Io(new IK(s, u, e, h), null, p);
            } else if (o & Jt.IncludeAnonymous || !u.type.isAnonymous || Fx(u)) {
              let p;
              if (!(o & Jt.IgnoreMounts) && (p = Ap.get(u)) && !p.overlay)
                return new Sr(p.tree, h, e, s);
              let v = new Sr(u, h, e, s);
              return o & Jt.IncludeAnonymous || !v.type.isAnonymous ? v : v.nextChild(n < 0 ? u.children.length - 1 : 0, n, r, i);
            }
          }
        }
        if (o & Jt.IncludeAnonymous || !s.type.isAnonymous || (s.index >= 0 ? e = s.index + n : e = n < 0 ? -1 : s._parent._tree.children.length, s = s._parent, !s))
          return null;
      }
    }
    get firstChild() {
      return this.nextChild(0, 1, 0, 4);
    }
    get lastChild() {
      return this.nextChild(this._tree.children.length - 1, -1, 0, 4);
    }
    childAfter(e) {
      return this.nextChild(0, 1, e, 2);
    }
    childBefore(e) {
      return this.nextChild(this._tree.children.length - 1, -1, e, -2);
    }
    enter(e, n, r = 0) {
      let i;
      if (!(r & Jt.IgnoreOverlays) && (i = Ap.get(this._tree)) && i.overlay) {
        let o = e - this.from;
        for (let { from: s, to: a } of i.overlay)
          if ((n > 0 ? s <= o : s < o) && (n < 0 ? a >= o : a > o))
            return new Sr(i.tree, i.overlay[0].from + this.from, -1, this);
      }
      return this.nextChild(0, 1, e, n, r);
    }
    nextSignificantParent() {
      let e = this;
      for (; e.type.isAnonymous && e._parent; )
        e = e._parent;
      return e;
    }
    get parent() {
      return this._parent ? this._parent.nextSignificantParent() : null;
    }
    get nextSibling() {
      return this._parent && this.index >= 0 ? this._parent.nextChild(this.index + 1, 1, 0, 4) : null;
    }
    get prevSibling() {
      return this._parent && this.index >= 0 ? this._parent.nextChild(this.index - 1, -1, 0, 4) : null;
    }
    get tree() {
      return this._tree;
    }
    toTree() {
      return this._tree;
    }
    toString() {
      return this._tree.toString();
    }
  }
  function mT(t, e, n, r) {
    let i = t.cursor(), o = [];
    if (!i.firstChild())
      return o;
    if (n != null) {
      for (let s = false; !s; )
        if (s = i.type.is(n), !i.nextSibling())
          return o;
    }
    for (; ; ) {
      if (r != null && i.type.is(r))
        return o;
      if (i.type.is(e) && o.push(i.node), !i.nextSibling())
        return r == null ? o : [];
    }
  }
  function v1(t, e, n = e.length - 1) {
    for (let r = t; n >= 0; r = r.parent) {
      if (!r)
        return false;
      if (!r.type.isAnonymous) {
        if (e[n] && e[n] != r.name)
          return false;
        n--;
      }
    }
    return true;
  }
  class IK {
    constructor(e, n, r, i) {
      this.parent = e, this.buffer = n, this.index = r, this.start = i;
    }
  }
  class Io extends DR {
    get name() {
      return this.type.name;
    }
    get from() {
      return this.context.start + this.context.buffer.buffer[this.index + 1];
    }
    get to() {
      return this.context.start + this.context.buffer.buffer[this.index + 2];
    }
    constructor(e, n, r) {
      super(), this.context = e, this._parent = n, this.index = r, this.type = e.buffer.set.types[e.buffer.buffer[r]];
    }
    child(e, n, r) {
      let { buffer: i } = this.context, o = i.findChild(this.index + 4, i.buffer[this.index + 3], e, n - this.context.start, r);
      return o < 0 ? null : new Io(this.context, this, o);
    }
    get firstChild() {
      return this.child(1, 0, 4);
    }
    get lastChild() {
      return this.child(-1, 0, 4);
    }
    childAfter(e) {
      return this.child(1, e, 2);
    }
    childBefore(e) {
      return this.child(-1, e, -2);
    }
    enter(e, n, r = 0) {
      if (r & Jt.ExcludeBuffers)
        return null;
      let { buffer: i } = this.context, o = i.findChild(this.index + 4, i.buffer[this.index + 3], n > 0 ? 1 : -1, e - this.context.start, n);
      return o < 0 ? null : new Io(this.context, this, o);
    }
    get parent() {
      return this._parent || this.context.parent.nextSignificantParent();
    }
    externalSibling(e) {
      return this._parent ? null : this.context.parent.nextChild(this.context.index + e, e, 0, 4);
    }
    get nextSibling() {
      let { buffer: e } = this.context, n = e.buffer[this.index + 3];
      return n < (this._parent ? e.buffer[this._parent.index + 3] : e.buffer.length) ? new Io(this.context, this._parent, n) : this.externalSibling(1);
    }
    get prevSibling() {
      let { buffer: e } = this.context, n = this._parent ? this._parent.index + 4 : 0;
      return this.index == n ? this.externalSibling(-1) : new Io(this.context, this._parent, e.findChild(n, this.index, -1, 0, 4));
    }
    get tree() {
      return null;
    }
    toTree() {
      let e = [], n = [], { buffer: r } = this.context, i = this.index + 4, o = r.buffer[this.index + 3];
      if (o > i) {
        let s = r.buffer[this.index + 1];
        e.push(r.slice(i, o, s)), n.push(0);
      }
      return new dn(this.type, e, n, this.to - this.from);
    }
    toString() {
      return this.context.buffer.childString(this.index);
    }
  }
  function IR(t) {
    if (!t.length)
      return null;
    let e = 0, n = t[0];
    for (let o = 1; o < t.length; o++) {
      let s = t[o];
      (s.from > n.from || s.to < n.to) && (n = s, e = o);
    }
    let r = n instanceof Sr && n.index < 0 ? null : n.parent, i = t.slice();
    return r ? i[e] = r : i.splice(e, 1), new BK(i, n);
  }
  class BK {
    constructor(e, n) {
      this.heads = e, this.node = n;
    }
    get next() {
      return IR(this.heads);
    }
  }
  function NK(t, e, n) {
    let r = t.resolveInner(e, n), i = null;
    for (let o = r instanceof Sr ? r : r.context.parent; o; o = o.parent)
      if (o.index < 0) {
        let s = o.parent;
        (i || (i = [
          r
        ])).push(s.resolve(e, n)), o = s;
      } else {
        let s = Ap.get(o.tree);
        if (s && s.overlay && s.overlay[0].from <= e && s.overlay[s.overlay.length - 1].to >= e) {
          let a = new Sr(s.tree, s.overlay[0].from + o.from, -1, o);
          (i || (i = [
            r
          ])).push(Fu(a, e, n, false));
        }
      }
    return i ? IR(i) : r;
  }
  class y1 {
    get name() {
      return this.type.name;
    }
    constructor(e, n = 0) {
      if (this.mode = n, this.buffer = null, this.stack = [], this.index = 0, this.bufferNode = null, e instanceof Sr)
        this.yieldNode(e);
      else {
        this._tree = e.context.parent, this.buffer = e.context;
        for (let r = e._parent; r; r = r._parent)
          this.stack.unshift(r.index);
        this.bufferNode = e, this.yieldBuf(e.index);
      }
    }
    yieldNode(e) {
      return e ? (this._tree = e, this.type = e.type, this.from = e.from, this.to = e.to, true) : false;
    }
    yieldBuf(e, n) {
      this.index = e;
      let { start: r, buffer: i } = this.buffer;
      return this.type = n || i.set.types[i.buffer[e]], this.from = r + i.buffer[e + 1], this.to = r + i.buffer[e + 2], true;
    }
    yield(e) {
      return e ? e instanceof Sr ? (this.buffer = null, this.yieldNode(e)) : (this.buffer = e.context, this.yieldBuf(e.index, e.type)) : false;
    }
    toString() {
      return this.buffer ? this.buffer.buffer.childString(this.index) : this._tree.toString();
    }
    enterChild(e, n, r) {
      if (!this.buffer)
        return this.yield(this._tree.nextChild(e < 0 ? this._tree._tree.children.length - 1 : 0, e, n, r, this.mode));
      let { buffer: i } = this.buffer, o = i.findChild(this.index + 4, i.buffer[this.index + 3], e, n - this.buffer.start, r);
      return o < 0 ? false : (this.stack.push(this.index), this.yieldBuf(o));
    }
    firstChild() {
      return this.enterChild(1, 0, 4);
    }
    lastChild() {
      return this.enterChild(-1, 0, 4);
    }
    childAfter(e) {
      return this.enterChild(1, e, 2);
    }
    childBefore(e) {
      return this.enterChild(-1, e, -2);
    }
    enter(e, n, r = this.mode) {
      return this.buffer ? r & Jt.ExcludeBuffers ? false : this.enterChild(1, e, n) : this.yield(this._tree.enter(e, n, r));
    }
    parent() {
      if (!this.buffer)
        return this.yieldNode(this.mode & Jt.IncludeAnonymous ? this._tree._parent : this._tree.parent);
      if (this.stack.length)
        return this.yieldBuf(this.stack.pop());
      let e = this.mode & Jt.IncludeAnonymous ? this.buffer.parent : this.buffer.parent.nextSignificantParent();
      return this.buffer = null, this.yieldNode(e);
    }
    sibling(e) {
      if (!this.buffer)
        return this._tree._parent ? this.yield(this._tree.index < 0 ? null : this._tree._parent.nextChild(this._tree.index + e, e, 0, 4, this.mode)) : false;
      let { buffer: n } = this.buffer, r = this.stack.length - 1;
      if (e < 0) {
        let i = r < 0 ? 0 : this.stack[r] + 4;
        if (this.index != i)
          return this.yieldBuf(n.findChild(i, this.index, -1, 0, 4));
      } else {
        let i = n.buffer[this.index + 3];
        if (i < (r < 0 ? n.buffer.length : n.buffer[this.stack[r] + 3]))
          return this.yieldBuf(i);
      }
      return r < 0 ? this.yield(this.buffer.parent.nextChild(this.buffer.index + e, e, 0, 4, this.mode)) : false;
    }
    nextSibling() {
      return this.sibling(1);
    }
    prevSibling() {
      return this.sibling(-1);
    }
    atLastNode(e) {
      let n, r, { buffer: i } = this;
      if (i) {
        if (e > 0) {
          if (this.index < i.buffer.buffer.length)
            return false;
        } else
          for (let o = 0; o < this.index; o++)
            if (i.buffer.buffer[o + 3] < this.index)
              return false;
        ({ index: n, parent: r } = i);
      } else
        ({ index: n, _parent: r } = this._tree);
      for (; r; { index: n, _parent: r } = r)
        if (n > -1)
          for (let o = n + e, s = e < 0 ? -1 : r._tree.children.length; o != s; o += e) {
            let a = r._tree.children[o];
            if (this.mode & Jt.IncludeAnonymous || a instanceof Xo || !a.type.isAnonymous || Fx(a))
              return false;
          }
      return true;
    }
    move(e, n) {
      if (n && this.enterChild(e, 0, 4))
        return true;
      for (; ; ) {
        if (this.sibling(e))
          return true;
        if (this.atLastNode(e) || !this.parent())
          return false;
      }
    }
    next(e = true) {
      return this.move(1, e);
    }
    prev(e = true) {
      return this.move(-1, e);
    }
    moveTo(e, n = 0) {
      for (; (this.from == this.to || (n < 1 ? this.from >= e : this.from > e) || (n > -1 ? this.to <= e : this.to < e)) && this.parent(); )
        ;
      for (; this.enterChild(1, e, n); )
        ;
      return this;
    }
    get node() {
      if (!this.buffer)
        return this._tree;
      let e = this.bufferNode, n = null, r = 0;
      if (e && e.context == this.buffer) {
        e:
          for (let i = this.index, o = this.stack.length; o >= 0; ) {
            for (let s = e; s; s = s._parent)
              if (s.index == i) {
                if (i == this.index)
                  return s;
                n = s, r = o + 1;
                break e;
              }
            i = this.stack[--o];
          }
      }
      for (let i = r; i < this.stack.length; i++)
        n = new Io(this.buffer, n, this.stack[i]);
      return this.bufferNode = new Io(this.buffer, n, this.index);
    }
    get tree() {
      return this.buffer ? null : this._tree._tree;
    }
    iterate(e, n) {
      for (let r = 0; ; ) {
        let i = false;
        if (this.type.isAnonymous || e(this) !== false) {
          if (this.firstChild()) {
            r++;
            continue;
          }
          this.type.isAnonymous || (i = true);
        }
        for (; ; ) {
          if (i && n && n(this), i = this.type.isAnonymous, !r)
            return;
          if (this.nextSibling())
            break;
          this.parent(), r--, i = true;
        }
      }
    }
    matchContext(e) {
      if (!this.buffer)
        return v1(this.node.parent, e);
      let { buffer: n } = this.buffer, { types: r } = n.set;
      for (let i = e.length - 1, o = this.stack.length - 1; i >= 0; o--) {
        if (o < 0)
          return v1(this._tree, e, i);
        let s = r[n.buffer[this.stack[o]]];
        if (!s.isAnonymous) {
          if (e[i] && e[i] != s.name)
            return false;
          i--;
        }
      }
      return true;
    }
  }
  function Fx(t) {
    return t.children.some((e) => e instanceof Xo || !e.type.isAnonymous || Fx(e));
  }
  function $K(t) {
    var e;
    let { buffer: n, nodeSet: r, maxBufferLength: i = LK, reused: o = [], minRepeatType: s = r.types.length } = t, a = Array.isArray(n) ? new zx(n, n.length) : n, l = r.types, c = 0, u = 0;
    function h(R, L, _, F, K, Y) {
      let { id: te, start: ne, end: ae, size: ye } = a, Ce = u, Re = c;
      if (ye < 0)
        if (a.next(), ye == -1) {
          let Se = o[te];
          _.push(Se), F.push(ne - R);
          return;
        } else if (ye == -3) {
          c = te;
          return;
        } else if (ye == -4) {
          u = te;
          return;
        } else
          throw new RangeError(`Unrecognized record size: ${ye}`);
      let ee = l[te], V, oe, de = ne - R;
      if (ae - ne <= i && (oe = T(a.pos - L, K))) {
        let Se = new Uint16Array(oe.size - oe.skip), ve = a.pos - oe.size, le = Se.length;
        for (; a.pos > ve; )
          le = w(oe.start, Se, le);
        V = new Xo(Se, ae - oe.start, r), de = oe.start - R;
      } else {
        let Se = a.pos - ye;
        a.next();
        let ve = [], le = [], re = te >= s ? te : -1, se = 0, _e2 = ae;
        for (; a.pos > Se; )
          re >= 0 && a.id == re && a.size >= 0 ? (a.end <= _e2 - i && (y(ve, le, ne, se, a.end, _e2, re, Ce, Re), se = ve.length, _e2 = a.end), a.next()) : Y > 2500 ? p(ne, Se, ve, le) : h(ne, Se, ve, le, re, Y + 1);
        if (re >= 0 && se > 0 && se < ve.length && y(ve, le, ne, se, ne, _e2, re, Ce, Re), ve.reverse(), le.reverse(), re > -1 && se > 0) {
          let yt = v(ee, Re);
          V = Vx(ee, ve, le, 0, ve.length, 0, ae - ne, yt, yt);
        } else
          V = x(ee, ve, le, ae - ne, Ce - ae, Re);
      }
      _.push(V), F.push(de);
    }
    function p(R, L, _, F) {
      let K = [], Y = 0, te = -1;
      for (; a.pos > L; ) {
        let { id: ne, start: ae, end: ye, size: Ce } = a;
        if (Ce > 4)
          a.next();
        else {
          if (te > -1 && ae < te)
            break;
          te < 0 && (te = ye - i), K.push(ne, ae, ye), Y++, a.next();
        }
      }
      if (Y) {
        let ne = new Uint16Array(Y * 4), ae = K[K.length - 2];
        for (let ye = K.length - 3, Ce = 0; ye >= 0; ye -= 3)
          ne[Ce++] = K[ye], ne[Ce++] = K[ye + 1] - ae, ne[Ce++] = K[ye + 2] - ae, ne[Ce++] = Ce;
        _.push(new Xo(ne, K[2] - ae, r)), F.push(ae - R);
      }
    }
    function v(R, L) {
      return (_, F, K) => {
        let Y = 0, te = _.length - 1, ne, ae;
        if (te >= 0 && (ne = _[te]) instanceof dn) {
          if (!te && ne.type == R && ne.length == K)
            return ne;
          (ae = ne.prop($e.lookAhead)) && (Y = F[te] + ne.length + ae);
        }
        return x(R, _, F, K, Y, L);
      };
    }
    function y(R, L, _, F, K, Y, te, ne, ae) {
      let ye = [], Ce = [];
      for (; R.length > F; )
        ye.push(R.pop()), Ce.push(L.pop() + _ - K);
      R.push(x(r.types[te], ye, Ce, Y - K, ne - Y, ae)), L.push(K - _);
    }
    function x(R, L, _, F, K, Y, te) {
      if (Y) {
        let ne = [
          $e.contextHash,
          Y
        ];
        te = te ? [
          ne
        ].concat(te) : [
          ne
        ];
      }
      if (K > 25) {
        let ne = [
          $e.lookAhead,
          K
        ];
        te = te ? [
          ne
        ].concat(te) : [
          ne
        ];
      }
      return new dn(R, L, _, F, te);
    }
    function T(R, L) {
      let _ = a.fork(), F = 0, K = 0, Y = 0, te = _.end - i, ne = {
        size: 0,
        start: 0,
        skip: 0
      };
      e:
        for (let ae = _.pos - R; _.pos > ae; ) {
          let ye = _.size;
          if (_.id == L && ye >= 0) {
            ne.size = F, ne.start = K, ne.skip = Y, Y += 4, F += 4, _.next();
            continue;
          }
          let Ce = _.pos - ye;
          if (ye < 0 || Ce < ae || _.start < te)
            break;
          let Re = _.id >= s ? 4 : 0, ee = _.start;
          for (_.next(); _.pos > Ce; ) {
            if (_.size < 0)
              if (_.size == -3)
                Re += 4;
              else
                break e;
            else
              _.id >= s && (Re += 4);
            _.next();
          }
          K = ee, F += ye, Y += Re;
        }
      return (L < 0 || F == R) && (ne.size = F, ne.start = K, ne.skip = Y), ne.size > 4 ? ne : void 0;
    }
    function w(R, L, _) {
      let { id: F, start: K, end: Y, size: te } = a;
      if (a.next(), te >= 0 && F < s) {
        let ne = _;
        if (te > 4) {
          let ae = a.pos - (te - 4);
          for (; a.pos > ae; )
            _ = w(R, L, _);
        }
        L[--_] = ne, L[--_] = Y - R, L[--_] = K - R, L[--_] = F;
      } else
        te == -3 ? c = F : te == -4 && (u = F);
      return _;
    }
    let k = [], C = [];
    for (; a.pos > 0; )
      h(t.start || 0, t.bufferStart || 0, k, C, -1, 0);
    let P = (e = t.length) !== null && e !== void 0 ? e : k.length ? C[0] + k[0].length : 0;
    return new dn(l[t.topID], k.reverse(), C.reverse(), P);
  }
  const gT = /* @__PURE__ */ new WeakMap();
  function Ed(t, e) {
    if (!t.isAnonymous || e instanceof Xo || e.type != t)
      return 1;
    let n = gT.get(e);
    if (n == null) {
      n = 1;
      for (let r of e.children) {
        if (r.type != t || !(r instanceof dn)) {
          n = 1;
          break;
        }
        n += Ed(t, r);
      }
      gT.set(e, n);
    }
    return n;
  }
  function Vx(t, e, n, r, i, o, s, a, l) {
    let c = 0;
    for (let y = r; y < i; y++)
      c += Ed(t, e[y]);
    let u = Math.ceil(c * 1.5 / 8), h = [], p = [];
    function v(y, x, T, w, k) {
      for (let C = T; C < w; ) {
        let P = C, R = x[C], L = Ed(t, y[C]);
        for (C++; C < w; C++) {
          let _ = Ed(t, y[C]);
          if (L + _ >= u)
            break;
          L += _;
        }
        if (C == P + 1) {
          if (L > u) {
            let _ = y[P];
            v(_.children, _.positions, 0, _.children.length, x[P] + k);
            continue;
          }
          h.push(y[P]);
        } else {
          let _ = x[C - 1] + y[C - 1].length - R;
          h.push(Vx(t, y, x, P, C, R, _, null, l));
        }
        p.push(R + k - o);
      }
    }
    return v(e, n, r, i, 0), (a || l)(h, p, s);
  }
  class Bs {
    constructor(e, n, r, i, o = false, s = false) {
      this.from = e, this.to = n, this.tree = r, this.offset = i, this.open = (o ? 1 : 0) | (s ? 2 : 0);
    }
    get openStart() {
      return (this.open & 1) > 0;
    }
    get openEnd() {
      return (this.open & 2) > 0;
    }
    static addTree(e, n = [], r = false) {
      let i = [
        new Bs(0, e.length, e, 0, false, r)
      ];
      for (let o of n)
        o.to > e.length && i.push(o);
      return i;
    }
    static applyChanges(e, n, r = 128) {
      if (!n.length)
        return e;
      let i = [], o = 1, s = e.length ? e[0] : null;
      for (let a = 0, l = 0, c = 0; ; a++) {
        let u = a < n.length ? n[a] : null, h = u ? u.fromA : 1e9;
        if (h - l >= r)
          for (; s && s.from < h; ) {
            let p = s;
            if (l >= p.from || h <= p.to || c) {
              let v = Math.max(p.from, l) - c, y = Math.min(p.to, h) - c;
              p = v >= y ? null : new Bs(v, y, p.tree, p.offset + c, a > 0, !!u);
            }
            if (p && i.push(p), s.to > h)
              break;
            s = o < e.length ? e[o++] : null;
          }
        if (!u)
          break;
        l = u.toA, c = u.toA - u.toB;
      }
      return i;
    }
  }
  class zK {
    startParse(e, n, r) {
      return typeof e == "string" && (e = new FK(e)), r = r ? r.length ? r.map((i) => new H0(i.from, i.to)) : [
        new H0(0, 0)
      ] : [
        new H0(0, e.length)
      ], this.createParse(e, n || [], r);
    }
    parse(e, n, r) {
      let i = this.startParse(e, n, r);
      for (; ; ) {
        let o = i.advance();
        if (o)
          return o;
      }
    }
  }
  class FK {
    constructor(e) {
      this.string = e;
    }
    get length() {
      return this.string.length;
    }
    chunk(e) {
      return this.string.slice(e);
    }
    get lineChunks() {
      return false;
    }
    read(e, n) {
      return this.string.slice(e, n);
    }
  }
  new $e({
    perNode: true
  });
  let VK = 0;
  class dr {
    constructor(e, n, r, i) {
      this.name = e, this.set = n, this.base = r, this.modified = i, this.id = VK++;
    }
    toString() {
      let { name: e } = this;
      for (let n of this.modified)
        n.name && (e = `${n.name}(${e})`);
      return e;
    }
    static define(e, n) {
      let r = typeof e == "string" ? e : "?";
      if (e instanceof dr && (n = e), n == null ? void 0 : n.base)
        throw new Error("Can not derive from a modified tag");
      let i = new dr(r, [], null, []);
      if (i.set.push(i), n)
        for (let o of n.set)
          i.set.push(o);
      return i;
    }
    static defineModifier(e) {
      let n = new Ep(e);
      return (r) => r.modified.indexOf(n) > -1 ? r : Ep.get(r.base || r, r.modified.concat(n).sort((i, o) => i.id - o.id));
    }
  }
  let HK = 0;
  class Ep {
    constructor(e) {
      this.name = e, this.instances = [], this.id = HK++;
    }
    static get(e, n) {
      if (!n.length)
        return e;
      let r = n[0].instances.find((a) => a.base == e && jK(n, a.modified));
      if (r)
        return r;
      let i = [], o = new dr(e.name, i, e, n);
      for (let a of n)
        a.instances.push(o);
      let s = WK(n);
      for (let a of e.set)
        if (!a.modified.length)
          for (let l of s)
            i.push(Ep.get(a, l));
      return o;
    }
  }
  function jK(t, e) {
    return t.length == e.length && t.every((n, r) => n == e[r]);
  }
  function WK(t) {
    let e = [
      []
    ];
    for (let n = 0; n < t.length; n++)
      for (let r = 0, i = e.length; r < i; r++)
        e.push(e[r].concat(t[n]));
    return e.sort((n, r) => r.length - n.length);
  }
  function UK(t) {
    let e = /* @__PURE__ */ Object.create(null);
    for (let n in t) {
      let r = t[n];
      Array.isArray(r) || (r = [
        r
      ]);
      for (let i of n.split(" "))
        if (i) {
          let o = [], s = 2, a = i;
          for (let h = 0; ; ) {
            if (a == "..." && h > 0 && h + 3 == i.length) {
              s = 1;
              break;
            }
            let p = /^"(?:[^"\\]|\\.)*?"|[^\/!]+/.exec(a);
            if (!p)
              throw new RangeError("Invalid path: " + i);
            if (o.push(p[0] == "*" ? "" : p[0][0] == '"' ? JSON.parse(p[0]) : p[0]), h += p[0].length, h == i.length)
              break;
            let v = i[h++];
            if (h == i.length && v == "!") {
              s = 0;
              break;
            }
            if (v != "/")
              throw new RangeError("Invalid path: " + i);
            a = i.slice(h);
          }
          let l = o.length - 1, c = o[l];
          if (!c)
            throw new RangeError("Invalid path: " + i);
          let u = new Vu(r, s, l > 0 ? o.slice(0, l) : null);
          e[c] = u.sort(e[c]);
        }
    }
    return BR.add(e);
  }
  const BR = new $e({
    combine(t, e) {
      let n, r, i;
      for (; t || e; ) {
        !t || t.depth > e.depth ? (i = e, e = e.next) : (i = t, t = t.next);
        let o = new Vu(i.tags, i.mode, i.context);
        n ? n.next = o : r = o, n = o;
      }
      return r;
    }
  });
  class Vu {
    constructor(e, n, r, i) {
      this.tags = e, this.mode = n, this.context = r, this.next = i;
    }
    get opaque() {
      return this.mode == 0;
    }
    get inherit() {
      return this.mode == 1;
    }
    sort(e) {
      return !e || e.depth < this.depth ? (this.next = e, this) : (e.next = this.sort(e.next), e);
    }
    get depth() {
      return this.context ? this.context.length : 0;
    }
  }
  Vu.empty = new Vu([], 2, null);
  function NR(t, e) {
    let n = /* @__PURE__ */ Object.create(null);
    for (let o of t)
      if (!Array.isArray(o.tag))
        n[o.tag.id] = o.class;
      else
        for (let s of o.tag)
          n[s.id] = o.class;
    let { scope: r, all: i = null } = e || {};
    return {
      style: (o) => {
        let s = i;
        for (let a of o)
          for (let l of a.set) {
            let c = n[l.id];
            if (c) {
              s = s ? s + " " + c : c;
              break;
            }
          }
        return s;
      },
      scope: r
    };
  }
  function KK(t, e) {
    let n = null;
    for (let r of t) {
      let i = r.style(e);
      i && (n = n ? n + " " + i : i);
    }
    return n;
  }
  function qK(t, e, n, r = 0, i = t.length) {
    let o = new GK(r, Array.isArray(e) ? e : [
      e
    ], n);
    o.highlightRange(t.cursor(), r, i, "", o.highlighters), o.flush(i);
  }
  class GK {
    constructor(e, n, r) {
      this.at = e, this.highlighters = n, this.span = r, this.class = "";
    }
    startSpan(e, n) {
      n != this.class && (this.flush(e), e > this.at && (this.at = e), this.class = n);
    }
    flush(e) {
      e > this.at && this.class && this.span(this.at, e, this.class);
    }
    highlightRange(e, n, r, i, o) {
      let { type: s, from: a, to: l } = e;
      if (a >= r || l <= n)
        return;
      s.isTop && (o = this.highlighters.filter((v) => !v.scope || v.scope(s)));
      let c = i, u = YK(e) || Vu.empty, h = KK(o, u.tags);
      if (h && (c && (c += " "), c += h, u.mode == 1 && (i += (i ? " " : "") + h)), this.startSpan(Math.max(n, a), c), u.opaque)
        return;
      let p = e.tree && e.tree.prop($e.mounted);
      if (p && p.overlay) {
        let v = e.node.enter(p.overlay[0].from + a, 1), y = this.highlighters.filter((T) => !T.scope || T.scope(p.tree.type)), x = e.firstChild();
        for (let T = 0, w = a; ; T++) {
          let k = T < p.overlay.length ? p.overlay[T] : null, C = k ? k.from + a : l, P = Math.max(n, w), R = Math.min(r, C);
          if (P < R && x)
            for (; e.from < R && (this.highlightRange(e, P, R, i, o), this.startSpan(Math.min(R, e.to), c), !(e.to >= C || !e.nextSibling())); )
              ;
          if (!k || C > r)
            break;
          w = k.to + a, w > n && (this.highlightRange(v.cursor(), Math.max(n, k.from + a), Math.min(r, w), "", y), this.startSpan(Math.min(r, w), c));
        }
        x && e.parent();
      } else if (e.firstChild()) {
        p && (i = "");
        do
          if (!(e.to <= n)) {
            if (e.from >= r)
              break;
            this.highlightRange(e, n, r, i, o), this.startSpan(Math.min(r, e.to), c);
          }
        while (e.nextSibling());
        e.parent();
      }
    }
  }
  function YK(t) {
    let e = t.type.prop(BR);
    for (; e && e.context && !t.matchContext(e.context); )
      e = e.next;
    return e || null;
  }
  const ce = dr.define, Bh = ce(), So = ce(), vT = ce(So), yT = ce(So), wo = ce(), Nh = ce(wo), j0 = ce(wo), si = ce(), ms = ce(si), ii = ce(), oi = ce(), b1 = ce(), lc = ce(b1), $h = ce(), G = {
    comment: Bh,
    lineComment: ce(Bh),
    blockComment: ce(Bh),
    docComment: ce(Bh),
    name: So,
    variableName: ce(So),
    typeName: vT,
    tagName: ce(vT),
    propertyName: yT,
    attributeName: ce(yT),
    className: ce(So),
    labelName: ce(So),
    namespace: ce(So),
    macroName: ce(So),
    literal: wo,
    string: Nh,
    docString: ce(Nh),
    character: ce(Nh),
    attributeValue: ce(Nh),
    number: j0,
    integer: ce(j0),
    float: ce(j0),
    bool: ce(wo),
    regexp: ce(wo),
    escape: ce(wo),
    color: ce(wo),
    url: ce(wo),
    keyword: ii,
    self: ce(ii),
    null: ce(ii),
    atom: ce(ii),
    unit: ce(ii),
    modifier: ce(ii),
    operatorKeyword: ce(ii),
    controlKeyword: ce(ii),
    definitionKeyword: ce(ii),
    moduleKeyword: ce(ii),
    operator: oi,
    derefOperator: ce(oi),
    arithmeticOperator: ce(oi),
    logicOperator: ce(oi),
    bitwiseOperator: ce(oi),
    compareOperator: ce(oi),
    updateOperator: ce(oi),
    definitionOperator: ce(oi),
    typeOperator: ce(oi),
    controlOperator: ce(oi),
    punctuation: b1,
    separator: ce(b1),
    bracket: lc,
    angleBracket: ce(lc),
    squareBracket: ce(lc),
    paren: ce(lc),
    brace: ce(lc),
    content: si,
    heading: ms,
    heading1: ce(ms),
    heading2: ce(ms),
    heading3: ce(ms),
    heading4: ce(ms),
    heading5: ce(ms),
    heading6: ce(ms),
    contentSeparator: ce(si),
    list: ce(si),
    quote: ce(si),
    emphasis: ce(si),
    strong: ce(si),
    link: ce(si),
    monospace: ce(si),
    strikethrough: ce(si),
    inserted: ce(),
    deleted: ce(),
    changed: ce(),
    invalid: ce(),
    meta: $h,
    documentMeta: ce($h),
    annotation: ce($h),
    processingInstruction: ce($h),
    definition: dr.defineModifier("definition"),
    constant: dr.defineModifier("constant"),
    function: dr.defineModifier("function"),
    standard: dr.defineModifier("standard"),
    local: dr.defineModifier("local"),
    special: dr.defineModifier("special")
  };
  for (let t in G) {
    let e = G[t];
    e instanceof dr && (e.name = t);
  }
  NR([
    {
      tag: G.link,
      class: "tok-link"
    },
    {
      tag: G.heading,
      class: "tok-heading"
    },
    {
      tag: G.emphasis,
      class: "tok-emphasis"
    },
    {
      tag: G.strong,
      class: "tok-strong"
    },
    {
      tag: G.keyword,
      class: "tok-keyword"
    },
    {
      tag: G.atom,
      class: "tok-atom"
    },
    {
      tag: G.bool,
      class: "tok-bool"
    },
    {
      tag: G.url,
      class: "tok-url"
    },
    {
      tag: G.labelName,
      class: "tok-labelName"
    },
    {
      tag: G.inserted,
      class: "tok-inserted"
    },
    {
      tag: G.deleted,
      class: "tok-deleted"
    },
    {
      tag: G.literal,
      class: "tok-literal"
    },
    {
      tag: G.string,
      class: "tok-string"
    },
    {
      tag: G.number,
      class: "tok-number"
    },
    {
      tag: [
        G.regexp,
        G.escape,
        G.special(G.string)
      ],
      class: "tok-string2"
    },
    {
      tag: G.variableName,
      class: "tok-variableName"
    },
    {
      tag: G.local(G.variableName),
      class: "tok-variableName tok-local"
    },
    {
      tag: G.definition(G.variableName),
      class: "tok-variableName tok-definition"
    },
    {
      tag: G.special(G.variableName),
      class: "tok-variableName2"
    },
    {
      tag: G.definition(G.propertyName),
      class: "tok-propertyName tok-definition"
    },
    {
      tag: G.typeName,
      class: "tok-typeName"
    },
    {
      tag: G.namespace,
      class: "tok-namespace"
    },
    {
      tag: G.className,
      class: "tok-className"
    },
    {
      tag: G.macroName,
      class: "tok-macroName"
    },
    {
      tag: G.propertyName,
      class: "tok-propertyName"
    },
    {
      tag: G.operator,
      class: "tok-operator"
    },
    {
      tag: G.comment,
      class: "tok-comment"
    },
    {
      tag: G.meta,
      class: "tok-meta"
    },
    {
      tag: G.invalid,
      class: "tok-invalid"
    },
    {
      tag: G.punctuation,
      class: "tok-punctuation"
    }
  ]);
  var W0;
  const Cc = new $e(), XK = new $e();
  class zr {
    constructor(e, n, r = [], i = "") {
      this.data = e, this.name = i, Ne.prototype.hasOwnProperty("tree") || Object.defineProperty(Ne.prototype, "tree", {
        get() {
          return mn(this);
        }
      }), this.parser = n, this.extension = [
        Qo.of(this),
        Ne.languageData.of((o, s, a) => {
          let l = bT(o, s, a), c = l.type.prop(Cc);
          if (!c)
            return [];
          let u = o.facet(c), h = l.type.prop(XK);
          if (h) {
            let p = l.resolve(s - l.from, a);
            for (let v of h)
              if (v.test(p, o)) {
                let y = o.facet(v.facet);
                return v.type == "replace" ? y : y.concat(u);
              }
          }
          return u;
        })
      ].concat(r);
    }
    isActiveAt(e, n, r = -1) {
      return bT(e, n, r).type.prop(Cc) == this.data;
    }
    findRegions(e) {
      let n = e.facet(Qo);
      if ((n == null ? void 0 : n.data) == this.data)
        return [
          {
            from: 0,
            to: e.doc.length
          }
        ];
      if (!n || !n.allowsNesting)
        return [];
      let r = [], i = (o, s) => {
        if (o.prop(Cc) == this.data) {
          r.push({
            from: s,
            to: s + o.length
          });
          return;
        }
        let a = o.prop($e.mounted);
        if (a) {
          if (a.tree.prop(Cc) == this.data) {
            if (a.overlay)
              for (let l of a.overlay)
                r.push({
                  from: l.from + s,
                  to: l.to + s
                });
            else
              r.push({
                from: s,
                to: s + o.length
              });
            return;
          } else if (a.overlay) {
            let l = r.length;
            if (i(a.tree, a.overlay[0].from + s), r.length > l)
              return;
          }
        }
        for (let l = 0; l < o.children.length; l++) {
          let c = o.children[l];
          c instanceof dn && i(c, o.positions[l] + s);
        }
      };
      return i(mn(e), 0), r;
    }
    get allowsNesting() {
      return true;
    }
  }
  zr.setState = Ee.define();
  function bT(t, e, n) {
    let r = t.facet(Qo), i = mn(t).topNode;
    if (!r || r.allowsNesting)
      for (let o = i; o; o = o.enter(e, n, Jt.ExcludeBuffers))
        o.type.isTop && (i = o);
    return i;
  }
  function mn(t) {
    let e = t.field(zr.state, false);
    return e ? e.tree : dn.empty;
  }
  function $R(t, e, n = 50) {
    var r;
    let i = (r = t.field(zr.state, false)) === null || r === void 0 ? void 0 : r.context;
    if (!i)
      return null;
    let o = i.viewport;
    i.updateViewport({
      from: 0,
      to: e
    });
    let s = i.isDone(e) || i.work(n, e) ? i.tree : null;
    return i.updateViewport(o), s;
  }
  class QK {
    constructor(e) {
      this.doc = e, this.cursorPos = 0, this.string = "", this.cursor = e.iter();
    }
    get length() {
      return this.doc.length;
    }
    syncTo(e) {
      return this.string = this.cursor.next(e - this.cursorPos).value, this.cursorPos = e + this.string.length, this.cursorPos - this.string.length;
    }
    chunk(e) {
      return this.syncTo(e), this.string;
    }
    get lineChunks() {
      return true;
    }
    read(e, n) {
      let r = this.cursorPos - this.string.length;
      return e < r || n >= this.cursorPos ? this.doc.sliceString(e, n) : this.string.slice(e - r, n - r);
    }
  }
  let cc = null;
  class Pp {
    constructor(e, n, r = [], i, o, s, a, l) {
      this.parser = e, this.state = n, this.fragments = r, this.tree = i, this.treeLen = o, this.viewport = s, this.skipped = a, this.scheduleOn = l, this.parse = null, this.tempSkipped = [];
    }
    static create(e, n, r) {
      return new Pp(e, n, [], dn.empty, 0, r, [], null);
    }
    startParse() {
      return this.parser.startParse(new QK(this.state.doc), this.fragments);
    }
    work(e, n) {
      return n != null && n >= this.state.doc.length && (n = void 0), this.tree != dn.empty && this.isDone(n ?? this.state.doc.length) ? (this.takeTree(), true) : this.withContext(() => {
        var r;
        if (typeof e == "number") {
          let i = Date.now() + e;
          e = () => Date.now() > i;
        }
        for (this.parse || (this.parse = this.startParse()), n != null && (this.parse.stoppedAt == null || this.parse.stoppedAt > n) && n < this.state.doc.length && this.parse.stopAt(n); ; ) {
          let i = this.parse.advance();
          if (i)
            if (this.fragments = this.withoutTempSkipped(Bs.addTree(i, this.fragments, this.parse.stoppedAt != null)), this.treeLen = (r = this.parse.stoppedAt) !== null && r !== void 0 ? r : this.state.doc.length, this.tree = i, this.parse = null, this.treeLen < (n ?? this.state.doc.length))
              this.parse = this.startParse();
            else
              return true;
          if (e())
            return false;
        }
      });
    }
    takeTree() {
      let e, n;
      this.parse && (e = this.parse.parsedPos) >= this.treeLen && ((this.parse.stoppedAt == null || this.parse.stoppedAt > e) && this.parse.stopAt(e), this.withContext(() => {
        for (; !(n = this.parse.advance()); )
          ;
      }), this.treeLen = e, this.tree = n, this.fragments = this.withoutTempSkipped(Bs.addTree(this.tree, this.fragments, true)), this.parse = null);
    }
    withContext(e) {
      let n = cc;
      cc = this;
      try {
        return e();
      } finally {
        cc = n;
      }
    }
    withoutTempSkipped(e) {
      for (let n; n = this.tempSkipped.pop(); )
        e = xT(e, n.from, n.to);
      return e;
    }
    changes(e, n) {
      let { fragments: r, tree: i, treeLen: o, viewport: s, skipped: a } = this;
      if (this.takeTree(), !e.empty) {
        let l = [];
        if (e.iterChangedRanges((c, u, h, p) => l.push({
          fromA: c,
          toA: u,
          fromB: h,
          toB: p
        })), r = Bs.applyChanges(r, l), i = dn.empty, o = 0, s = {
          from: e.mapPos(s.from, -1),
          to: e.mapPos(s.to, 1)
        }, this.skipped.length) {
          a = [];
          for (let c of this.skipped) {
            let u = e.mapPos(c.from, 1), h = e.mapPos(c.to, -1);
            u < h && a.push({
              from: u,
              to: h
            });
          }
        }
      }
      return new Pp(this.parser, n, r, i, o, s, a, this.scheduleOn);
    }
    updateViewport(e) {
      if (this.viewport.from == e.from && this.viewport.to == e.to)
        return false;
      this.viewport = e;
      let n = this.skipped.length;
      for (let r = 0; r < this.skipped.length; r++) {
        let { from: i, to: o } = this.skipped[r];
        i < e.to && o > e.from && (this.fragments = xT(this.fragments, i, o), this.skipped.splice(r--, 1));
      }
      return this.skipped.length >= n ? false : (this.reset(), true);
    }
    reset() {
      this.parse && (this.takeTree(), this.parse = null);
    }
    skipUntilInView(e, n) {
      this.skipped.push({
        from: e,
        to: n
      });
    }
    static getSkippingParser(e) {
      return new class extends zK {
        createParse(n, r, i) {
          let o = i[0].from, s = i[i.length - 1].to;
          return {
            parsedPos: o,
            advance() {
              let l = cc;
              if (l) {
                for (let c of i)
                  l.tempSkipped.push(c);
                e && (l.scheduleOn = l.scheduleOn ? Promise.all([
                  l.scheduleOn,
                  e
                ]) : e);
              }
              return this.parsedPos = s, new dn(Tr.none, [], [], s - o);
            },
            stoppedAt: null,
            stopAt() {
            }
          };
        }
      }();
    }
    isDone(e) {
      e = Math.min(e, this.state.doc.length);
      let n = this.fragments;
      return this.treeLen >= e && n.length && n[0].from == 0 && n[0].to >= e;
    }
    static get() {
      return cc;
    }
  }
  function xT(t, e, n) {
    return Bs.applyChanges(t, [
      {
        fromA: e,
        toA: n,
        fromB: e,
        toB: n
      }
    ]);
  }
  class bl {
    constructor(e) {
      this.context = e, this.tree = e.tree;
    }
    apply(e) {
      if (!e.docChanged && this.tree == this.context.tree)
        return this;
      let n = this.context.changes(e.changes, e.state), r = this.context.treeLen == e.startState.doc.length ? void 0 : Math.max(e.changes.mapPos(this.context.treeLen), n.viewport.to);
      return n.work(20, r) || n.takeTree(), new bl(n);
    }
    static init(e) {
      let n = Math.min(3e3, e.doc.length), r = Pp.create(e.facet(Qo).parser, e, {
        from: 0,
        to: n
      });
      return r.work(20, n) || r.takeTree(), new bl(r);
    }
  }
  zr.state = Ut.define({
    create: bl.init,
    update(t, e) {
      for (let n of e.effects)
        if (n.is(zr.setState))
          return n.value;
      return e.startState.facet(Qo) != e.state.facet(Qo) ? bl.init(e.state) : t.apply(e);
    }
  });
  let zR = (t) => {
    let e = setTimeout(() => t(), 500);
    return () => clearTimeout(e);
  };
  typeof requestIdleCallback < "u" && (zR = (t) => {
    let e = -1, n = setTimeout(() => {
      e = requestIdleCallback(t, {
        timeout: 500 - 100
      });
    }, 100);
    return () => e < 0 ? clearTimeout(n) : cancelIdleCallback(e);
  });
  const U0 = typeof navigator < "u" && ((W0 = navigator.scheduling) === null || W0 === void 0 ? void 0 : W0.isInputPending) ? () => navigator.scheduling.isInputPending() : null, JK = Ct.fromClass(class {
    constructor(e) {
      this.view = e, this.working = null, this.workScheduled = 0, this.chunkEnd = -1, this.chunkBudget = -1, this.work = this.work.bind(this), this.scheduleWork();
    }
    update(e) {
      let n = this.view.state.field(zr.state).context;
      (n.updateViewport(e.view.viewport) || this.view.viewport.to > n.treeLen) && this.scheduleWork(), (e.docChanged || e.selectionSet) && (this.view.hasFocus && (this.chunkBudget += 50), this.scheduleWork()), this.checkAsyncSchedule(n);
    }
    scheduleWork() {
      if (this.working)
        return;
      let { state: e } = this.view, n = e.field(zr.state);
      (n.tree != n.context.tree || !n.context.isDone(e.doc.length)) && (this.working = zR(this.work));
    }
    work(e) {
      this.working = null;
      let n = Date.now();
      if (this.chunkEnd < n && (this.chunkEnd < 0 || this.view.hasFocus) && (this.chunkEnd = n + 3e4, this.chunkBudget = 3e3), this.chunkBudget <= 0)
        return;
      let { state: r, viewport: { to: i } } = this.view, o = r.field(zr.state);
      if (o.tree == o.context.tree && o.context.isDone(i + 1e5))
        return;
      let s = Date.now() + Math.min(this.chunkBudget, 100, e && !U0 ? Math.max(25, e.timeRemaining() - 5) : 1e9), a = o.context.treeLen < i && r.doc.length > i + 1e3, l = o.context.work(() => U0 && U0() || Date.now() > s, i + (a ? 0 : 1e5));
      this.chunkBudget -= Date.now() - n, (l || this.chunkBudget <= 0) && (o.context.takeTree(), this.view.dispatch({
        effects: zr.setState.of(new bl(o.context))
      })), this.chunkBudget > 0 && !(l && !a) && this.scheduleWork(), this.checkAsyncSchedule(o.context);
    }
    checkAsyncSchedule(e) {
      e.scheduleOn && (this.workScheduled++, e.scheduleOn.then(() => this.scheduleWork()).catch((n) => Bn(this.view.state, n)).then(() => this.workScheduled--), e.scheduleOn = null);
    }
    destroy() {
      this.working && this.working();
    }
    isWorking() {
      return !!(this.working || this.workScheduled > 0);
    }
  }, {
    eventHandlers: {
      focus() {
        this.scheduleWork();
      }
    }
  }), Qo = me.define({
    combine(t) {
      return t.length ? t[0] : null;
    },
    enables: (t) => [
      zr.state,
      JK,
      ue.contentAttributes.compute([
        t
      ], (e) => {
        let n = e.facet(t);
        return n && n.name ? {
          "data-language": n.name
        } : {};
      })
    ]
  }), ZK = me.define(), xl = me.define({
    combine: (t) => {
      if (!t.length)
        return "  ";
      let e = t[0];
      if (!e || /\S/.test(e) || Array.from(e).some((n) => n != e[0]))
        throw new Error("Invalid indent unit: " + JSON.stringify(t[0]));
      return e;
    }
  });
  function Op(t) {
    let e = t.facet(xl);
    return e.charCodeAt(0) == 9 ? t.tabSize * e.length : e.length;
  }
  function Hu(t, e) {
    let n = "", r = t.tabSize, i = t.facet(xl)[0];
    if (i == "	") {
      for (; e >= r; )
        n += "	", e -= r;
      i = " ";
    }
    for (let o = 0; o < e; o++)
      n += i;
    return n;
  }
  function Hx(t, e) {
    t instanceof Ne && (t = new jm(t));
    for (let r of t.state.facet(ZK)) {
      let i = r(t, e);
      if (i !== void 0)
        return i;
    }
    let n = mn(t.state);
    return n.length >= e ? tq(t, n, e) : null;
  }
  class jm {
    constructor(e, n = {}) {
      this.state = e, this.options = n, this.unit = Op(e);
    }
    lineAt(e, n = 1) {
      let r = this.state.doc.lineAt(e), { simulateBreak: i, simulateDoubleBreak: o } = this.options;
      return i != null && i >= r.from && i <= r.to ? o && i == e ? {
        text: "",
        from: e
      } : (n < 0 ? i < e : i <= e) ? {
        text: r.text.slice(i - r.from),
        from: i
      } : {
        text: r.text.slice(0, i - r.from),
        from: r.from
      } : r;
    }
    textAfterPos(e, n = 1) {
      if (this.options.simulateDoubleBreak && e == this.options.simulateBreak)
        return "";
      let { text: r, from: i } = this.lineAt(e, n);
      return r.slice(e - i, Math.min(r.length, e + 100 - i));
    }
    column(e, n = 1) {
      let { text: r, from: i } = this.lineAt(e, n), o = this.countColumn(r, e - i), s = this.options.overrideIndentation ? this.options.overrideIndentation(i) : -1;
      return s > -1 && (o += s - this.countColumn(r, r.search(/\S|$/))), o;
    }
    countColumn(e, n = e.length) {
      return Pl(e, this.state.tabSize, n);
    }
    lineIndent(e, n = 1) {
      let { text: r, from: i } = this.lineAt(e, n), o = this.options.overrideIndentation;
      if (o) {
        let s = o(i);
        if (s > -1)
          return s;
      }
      return this.countColumn(r, r.search(/\S|$/));
    }
    get simulatedBreak() {
      return this.options.simulateBreak || null;
    }
  }
  const eq = new $e();
  function tq(t, e, n) {
    let r = e.resolveStack(n), i = e.resolveInner(n, -1).resolve(n, 0).enterUnfinishedNodesBefore(n);
    if (i != r.node) {
      let o = [];
      for (let s = i; s && !(s.from < r.node.from || s.to > r.node.to || s.from == r.node.from && s.type == r.node.type); s = s.parent)
        o.push(s);
      for (let s = o.length - 1; s >= 0; s--)
        r = {
          node: o[s],
          next: r
        };
    }
    return FR(r, t, n);
  }
  function FR(t, e, n) {
    for (let r = t; r; r = r.next) {
      let i = rq(r.node);
      if (i)
        return i(jx.create(e, n, r));
    }
    return 0;
  }
  function nq(t) {
    return t.pos == t.options.simulateBreak && t.options.simulateDoubleBreak;
  }
  function rq(t) {
    let e = t.type.prop(eq);
    if (e)
      return e;
    let n = t.firstChild, r;
    if (n && (r = n.type.prop($e.closedBy))) {
      let i = t.lastChild, o = i && r.indexOf(i.name) > -1;
      return (s) => aq(s, true, 1, void 0, o && !nq(s) ? i.from : void 0);
    }
    return t.parent == null ? iq : null;
  }
  function iq() {
    return 0;
  }
  class jx extends jm {
    constructor(e, n, r) {
      super(e.state, e.options), this.base = e, this.pos = n, this.context = r;
    }
    get node() {
      return this.context.node;
    }
    static create(e, n, r) {
      return new jx(e, n, r);
    }
    get textAfter() {
      return this.textAfterPos(this.pos);
    }
    get baseIndent() {
      return this.baseIndentFor(this.node);
    }
    baseIndentFor(e) {
      let n = this.state.doc.lineAt(e.from);
      for (; ; ) {
        let r = e.resolve(n.from);
        for (; r.parent && r.parent.from == r.from; )
          r = r.parent;
        if (oq(r, e))
          break;
        n = this.state.doc.lineAt(r.from);
      }
      return this.lineIndent(n.from);
    }
    continue() {
      return FR(this.context.next, this.base, this.pos);
    }
  }
  function oq(t, e) {
    for (let n = e; n; n = n.parent)
      if (t == n)
        return true;
    return false;
  }
  function sq(t) {
    let e = t.node, n = e.childAfter(e.from), r = e.lastChild;
    if (!n)
      return null;
    let i = t.options.simulateBreak, o = t.state.doc.lineAt(n.from), s = i == null || i <= o.from ? o.to : Math.min(o.to, i);
    for (let a = n.to; ; ) {
      let l = e.childAfter(a);
      if (!l || l == r)
        return null;
      if (!l.type.isSkipped) {
        if (l.from >= s)
          return null;
        let c = /^ */.exec(o.text.slice(n.to - o.from))[0].length;
        return {
          from: n.from,
          to: n.to + c
        };
      }
      a = l.to;
    }
  }
  function aq(t, e, n, r, i) {
    let o = t.textAfter, s = o.match(/^\s*/)[0].length, a = r && o.slice(s, s + r.length) == r || i == t.pos + s, l = e ? sq(t) : null;
    return l ? a ? t.column(l.from) : t.column(l.to) : t.baseIndent + (a ? 0 : t.unit * n);
  }
  const lq = 200;
  function cq() {
    return Ne.transactionFilter.of((t) => {
      if (!t.docChanged || !t.isUserEvent("input.type") && !t.isUserEvent("input.complete"))
        return t;
      let e = t.startState.languageDataAt("indentOnInput", t.startState.selection.main.head);
      if (!e.length)
        return t;
      let n = t.newDoc, { head: r } = t.newSelection.main, i = n.lineAt(r);
      if (r > i.from + lq)
        return t;
      let o = n.sliceString(i.from, r);
      if (!e.some((c) => c.test(o)))
        return t;
      let { state: s } = t, a = -1, l = [];
      for (let { head: c } of s.selection.ranges) {
        let u = s.doc.lineAt(c);
        if (u.from == a)
          continue;
        a = u.from;
        let h = Hx(s, u.from);
        if (h == null)
          continue;
        let p = /^\s*/.exec(u.text)[0], v = Hu(s, h);
        p != v && l.push({
          from: u.from,
          to: u.from + p.length,
          insert: v
        });
      }
      return l.length ? [
        t,
        {
          changes: l,
          sequential: true
        }
      ] : t;
    });
  }
  const uq = me.define(), fq = new $e();
  function hq(t, e, n) {
    let r = mn(t);
    if (r.length < n)
      return null;
    let i = r.resolveStack(n, 1), o = null;
    for (let s = i; s; s = s.next) {
      let a = s.node;
      if (a.to <= n || a.from > n)
        continue;
      if (o && a.from < e)
        break;
      let l = a.type.prop(fq);
      if (l && (a.to < r.length - 50 || r.length == t.doc.length || !dq(a))) {
        let c = l(a, t);
        c && c.from <= n && c.from >= e && c.to > n && (o = c);
      }
    }
    return o;
  }
  function dq(t) {
    let e = t.lastChild;
    return e && e.to == t.to && e.type.isError;
  }
  function Rp(t, e, n) {
    for (let r of t.facet(uq)) {
      let i = r(t, e, n);
      if (i)
        return i;
    }
    return hq(t, e, n);
  }
  function VR(t, e) {
    let n = e.mapPos(t.from, 1), r = e.mapPos(t.to, -1);
    return n >= r ? void 0 : {
      from: n,
      to: r
    };
  }
  const Wm = Ee.define({
    map: VR
  }), hf = Ee.define({
    map: VR
  });
  function HR(t) {
    let e = [];
    for (let { head: n } of t.state.selection.ranges)
      e.some((r) => r.from <= n && r.to >= n) || e.push(t.lineBlockAt(n));
    return e;
  }
  const Ys = Ut.define({
    create() {
      return be.none;
    },
    update(t, e) {
      e.isUserEvent("delete") && e.changes.iterChangedRanges((n, r) => t = ST(t, n, r)), t = t.map(e.changes);
      for (let n of e.effects)
        if (n.is(Wm) && !pq(t, n.value.from, n.value.to)) {
          let { preparePlaceholder: r } = e.state.facet(Wx), i = r ? be.replace({
            widget: new xq(r(e.state, n.value))
          }) : wT;
          t = t.update({
            add: [
              i.range(n.value.from, n.value.to)
            ]
          });
        } else
          n.is(hf) && (t = t.update({
            filter: (r, i) => n.value.from != r || n.value.to != i,
            filterFrom: n.value.from,
            filterTo: n.value.to
          }));
      return e.selection && (t = ST(t, e.selection.main.head)), t;
    },
    provide: (t) => ue.decorations.from(t),
    toJSON(t, e) {
      let n = [];
      return t.between(0, e.doc.length, (r, i) => {
        n.push(r, i);
      }), n;
    },
    fromJSON(t) {
      if (!Array.isArray(t) || t.length % 2)
        throw new RangeError("Invalid JSON for fold state");
      let e = [];
      for (let n = 0; n < t.length; ) {
        let r = t[n++], i = t[n++];
        if (typeof r != "number" || typeof i != "number")
          throw new RangeError("Invalid JSON for fold state");
        e.push(wT.range(r, i));
      }
      return be.set(e, true);
    }
  });
  function ST(t, e, n = e) {
    let r = false;
    return t.between(e, n, (i, o) => {
      i < n && o > e && (r = true);
    }), r ? t.update({
      filterFrom: e,
      filterTo: n,
      filter: (i, o) => i >= n || o <= e
    }) : t;
  }
  function Lp(t, e, n) {
    var r;
    let i = null;
    return (r = t.field(Ys, false)) === null || r === void 0 || r.between(e, n, (o, s) => {
      (!i || i.from > o) && (i = {
        from: o,
        to: s
      });
    }), i;
  }
  function pq(t, e, n) {
    let r = false;
    return t.between(e, e, (i, o) => {
      i == e && o == n && (r = true);
    }), r;
  }
  function jR(t, e) {
    return t.field(Ys, false) ? e : e.concat(Ee.appendConfig.of(KR()));
  }
  const WR = (t) => {
    for (let e of HR(t)) {
      let n = Rp(t.state, e.from, e.to);
      if (n)
        return t.dispatch({
          effects: jR(t.state, [
            Wm.of(n),
            UR(t, n)
          ])
        }), true;
    }
    return false;
  }, mq = (t) => {
    if (!t.state.field(Ys, false))
      return false;
    let e = [];
    for (let n of HR(t)) {
      let r = Lp(t.state, n.from, n.to);
      r && e.push(hf.of(r), UR(t, r, false));
    }
    return e.length && t.dispatch({
      effects: e
    }), e.length > 0;
  };
  function UR(t, e, n = true) {
    let r = t.state.doc.lineAt(e.from).number, i = t.state.doc.lineAt(e.to).number;
    return ue.announce.of(`${t.state.phrase(n ? "Folded lines" : "Unfolded lines")} ${r} ${t.state.phrase("to")} ${i}.`);
  }
  const gq = (t) => {
    let { state: e } = t, n = [];
    for (let r = 0; r < e.doc.length; ) {
      let i = t.lineBlockAt(r), o = Rp(e, i.from, i.to);
      o && n.push(Wm.of(o)), r = (o ? t.lineBlockAt(o.to) : i).to + 1;
    }
    return n.length && t.dispatch({
      effects: jR(t.state, n)
    }), !!n.length;
  }, vq = (t) => {
    let e = t.state.field(Ys, false);
    if (!e || !e.size)
      return false;
    let n = [];
    return e.between(0, t.state.doc.length, (r, i) => {
      n.push(hf.of({
        from: r,
        to: i
      }));
    }), t.dispatch({
      effects: n
    }), true;
  }, yq = [
    {
      key: "Ctrl-Shift-[",
      mac: "Cmd-Alt-[",
      run: WR
    },
    {
      key: "Ctrl-Shift-]",
      mac: "Cmd-Alt-]",
      run: mq
    },
    {
      key: "Ctrl-Alt-[",
      run: gq
    },
    {
      key: "Ctrl-Alt-]",
      run: vq
    }
  ], bq = {
    placeholderDOM: null,
    preparePlaceholder: null,
    placeholderText: "\u2026"
  }, Wx = me.define({
    combine(t) {
      return Oi(t, bq);
    }
  });
  function KR(t) {
    let e = [
      Ys,
      kq
    ];
    return t && e.push(Wx.of(t)), e;
  }
  function qR(t, e) {
    let { state: n } = t, r = n.facet(Wx), i = (s) => {
      let a = t.lineBlockAt(t.posAtDOM(s.target)), l = Lp(t.state, a.from, a.to);
      l && t.dispatch({
        effects: hf.of(l)
      }), s.preventDefault();
    };
    if (r.placeholderDOM)
      return r.placeholderDOM(t, i, e);
    let o = document.createElement("span");
    return o.textContent = r.placeholderText, o.setAttribute("aria-label", n.phrase("folded code")), o.title = n.phrase("unfold"), o.className = "cm-foldPlaceholder", o.onclick = i, o;
  }
  const wT = be.replace({
    widget: new class extends oo {
      toDOM(t) {
        return qR(t, null);
      }
    }()
  });
  class xq extends oo {
    constructor(e) {
      super(), this.value = e;
    }
    eq(e) {
      return this.value == e.value;
    }
    toDOM(e) {
      return qR(e, this.value);
    }
  }
  const Sq = {
    openText: "\u2304",
    closedText: "\u203A",
    markerDOM: null,
    domEventHandlers: {},
    foldingChanged: () => false
  };
  class K0 extends ro {
    constructor(e, n) {
      super(), this.config = e, this.open = n;
    }
    eq(e) {
      return this.config == e.config && this.open == e.open;
    }
    toDOM(e) {
      if (this.config.markerDOM)
        return this.config.markerDOM(this.open);
      let n = document.createElement("span");
      return n.textContent = this.open ? this.config.openText : this.config.closedText, n.title = e.state.phrase(this.open ? "Fold line" : "Unfold line"), n;
    }
  }
  function wq(t = {}) {
    let e = {
      ...Sq,
      ...t
    }, n = new K0(e, true), r = new K0(e, false), i = Ct.fromClass(class {
      constructor(s) {
        this.from = s.viewport.from, this.markers = this.buildMarkers(s);
      }
      update(s) {
        (s.docChanged || s.viewportChanged || s.startState.facet(Qo) != s.state.facet(Qo) || s.startState.field(Ys, false) != s.state.field(Ys, false) || mn(s.startState) != mn(s.state) || e.foldingChanged(s)) && (this.markers = this.buildMarkers(s.view));
      }
      buildMarkers(s) {
        let a = new Mi();
        for (let l of s.viewportLineBlocks) {
          let c = Lp(s.state, l.from, l.to) ? r : Rp(s.state, l.from, l.to) ? n : null;
          c && a.add(l.from, l.from, c);
        }
        return a.finish();
      }
    }), { domEventHandlers: o } = e;
    return [
      i,
      SK({
        class: "cm-foldGutter",
        markers(s) {
          var a;
          return ((a = s.plugin(i)) === null || a === void 0 ? void 0 : a.markers) || Ve.empty;
        },
        initialSpacer() {
          return new K0(e, false);
        },
        domEventHandlers: {
          ...o,
          click: (s, a, l) => {
            if (o.click && o.click(s, a, l))
              return true;
            let c = Lp(s.state, a.from, a.to);
            if (c)
              return s.dispatch({
                effects: hf.of(c)
              }), true;
            let u = Rp(s.state, a.from, a.to);
            return u ? (s.dispatch({
              effects: Wm.of(u)
            }), true) : false;
          }
        }
      }),
      KR()
    ];
  }
  const kq = ue.baseTheme({
    ".cm-foldPlaceholder": {
      backgroundColor: "#eee",
      border: "1px solid #ddd",
      color: "#888",
      borderRadius: ".2em",
      margin: "0 1px",
      padding: "0 1px",
      cursor: "pointer"
    },
    ".cm-foldGutter span": {
      padding: "0 1px",
      cursor: "pointer"
    }
  });
  class df {
    constructor(e, n) {
      this.specs = e;
      let r;
      function i(a) {
        let l = qo.newName();
        return (r || (r = /* @__PURE__ */ Object.create(null)))["." + l] = a, l;
      }
      const o = typeof n.all == "string" ? n.all : n.all ? i(n.all) : void 0, s = n.scope;
      this.scope = s instanceof zr ? (a) => a.prop(Cc) == s.data : s ? (a) => a == s : void 0, this.style = NR(e.map((a) => ({
        tag: a.tag,
        class: a.class || i(Object.assign({}, a, {
          tag: null
        }))
      })), {
        all: o
      }).style, this.module = r ? new qo(r) : null, this.themeType = n.themeType;
    }
    static define(e, n) {
      return new df(e, n || {});
    }
  }
  const x1 = me.define(), GR = me.define({
    combine(t) {
      return t.length ? [
        t[0]
      ] : null;
    }
  });
  function q0(t) {
    let e = t.facet(x1);
    return e.length ? e : t.facet(GR);
  }
  function YR(t, e) {
    let n = [
      Tq
    ], r;
    return t instanceof df && (t.module && n.push(ue.styleModule.of(t.module)), r = t.themeType), (e == null ? void 0 : e.fallback) ? n.push(GR.of(t)) : r ? n.push(x1.computeN([
      ue.darkTheme
    ], (i) => i.facet(ue.darkTheme) == (r == "dark") ? [
      t
    ] : [])) : n.push(x1.of(t)), n;
  }
  class Cq {
    constructor(e) {
      this.markCache = /* @__PURE__ */ Object.create(null), this.tree = mn(e.state), this.decorations = this.buildDeco(e, q0(e.state)), this.decoratedTo = e.viewport.to;
    }
    update(e) {
      let n = mn(e.state), r = q0(e.state), i = r != q0(e.startState), { viewport: o } = e.view, s = e.changes.mapPos(this.decoratedTo, 1);
      n.length < o.to && !i && n.type == this.tree.type && s >= o.to ? (this.decorations = this.decorations.map(e.changes), this.decoratedTo = s) : (n != this.tree || e.viewportChanged || i) && (this.tree = n, this.decorations = this.buildDeco(e.view, r), this.decoratedTo = o.to);
    }
    buildDeco(e, n) {
      if (!n || !this.tree.length)
        return be.none;
      let r = new Mi();
      for (let { from: i, to: o } of e.visibleRanges)
        qK(this.tree, n, (s, a, l) => {
          r.add(s, a, this.markCache[l] || (this.markCache[l] = be.mark({
            class: l
          })));
        }, i, o);
      return r.finish();
    }
  }
  const Tq = ns.high(Ct.fromClass(Cq, {
    decorations: (t) => t.decorations
  })), Mq = df.define([
    {
      tag: G.meta,
      color: "#404740"
    },
    {
      tag: G.link,
      textDecoration: "underline"
    },
    {
      tag: G.heading,
      textDecoration: "underline",
      fontWeight: "bold"
    },
    {
      tag: G.emphasis,
      fontStyle: "italic"
    },
    {
      tag: G.strong,
      fontWeight: "bold"
    },
    {
      tag: G.strikethrough,
      textDecoration: "line-through"
    },
    {
      tag: G.keyword,
      color: "#708"
    },
    {
      tag: [
        G.atom,
        G.bool,
        G.url,
        G.contentSeparator,
        G.labelName
      ],
      color: "#219"
    },
    {
      tag: [
        G.literal,
        G.inserted
      ],
      color: "#164"
    },
    {
      tag: [
        G.string,
        G.deleted
      ],
      color: "#a11"
    },
    {
      tag: [
        G.regexp,
        G.escape,
        G.special(G.string)
      ],
      color: "#e40"
    },
    {
      tag: G.definition(G.variableName),
      color: "#00f"
    },
    {
      tag: G.local(G.variableName),
      color: "#30a"
    },
    {
      tag: [
        G.typeName,
        G.namespace
      ],
      color: "#085"
    },
    {
      tag: G.className,
      color: "#167"
    },
    {
      tag: [
        G.special(G.variableName),
        G.macroName
      ],
      color: "#256"
    },
    {
      tag: G.definition(G.propertyName),
      color: "#00c"
    },
    {
      tag: G.comment,
      color: "#940"
    },
    {
      tag: G.invalid,
      color: "#f00"
    }
  ]), Aq = ue.baseTheme({
    "&.cm-focused .cm-matchingBracket": {
      backgroundColor: "#328c8252"
    },
    "&.cm-focused .cm-nonmatchingBracket": {
      backgroundColor: "#bb555544"
    }
  }), XR = 1e4, QR = "()[]{}", JR = me.define({
    combine(t) {
      return Oi(t, {
        afterCursor: true,
        brackets: QR,
        maxScanDistance: XR,
        renderMatch: Oq
      });
    }
  }), Eq = be.mark({
    class: "cm-matchingBracket"
  }), Pq = be.mark({
    class: "cm-nonmatchingBracket"
  });
  function Oq(t) {
    let e = [], n = t.matched ? Eq : Pq;
    return e.push(n.range(t.start.from, t.start.to)), t.end && e.push(n.range(t.end.from, t.end.to)), e;
  }
  const Rq = Ut.define({
    create() {
      return be.none;
    },
    update(t, e) {
      if (!e.docChanged && !e.selection)
        return t;
      let n = [], r = e.state.facet(JR);
      for (let i of e.state.selection.ranges) {
        if (!i.empty)
          continue;
        let o = mr(e.state, i.head, -1, r) || i.head > 0 && mr(e.state, i.head - 1, 1, r) || r.afterCursor && (mr(e.state, i.head, 1, r) || i.head < e.state.doc.length && mr(e.state, i.head + 1, -1, r));
        o && (n = n.concat(r.renderMatch(o, e.state)));
      }
      return be.set(n, true);
    },
    provide: (t) => ue.decorations.from(t)
  }), Lq = [
    Rq,
    Aq
  ];
  function _q(t = {}) {
    return [
      JR.of(t),
      Lq
    ];
  }
  const Dq = new $e();
  function S1(t, e, n) {
    let r = t.prop(e < 0 ? $e.openedBy : $e.closedBy);
    if (r)
      return r;
    if (t.name.length == 1) {
      let i = n.indexOf(t.name);
      if (i > -1 && i % 2 == (e < 0 ? 1 : 0))
        return [
          n[i + e]
        ];
    }
    return null;
  }
  function w1(t) {
    let e = t.type.prop(Dq);
    return e ? e(t.node) : t;
  }
  function mr(t, e, n, r = {}) {
    let i = r.maxScanDistance || XR, o = r.brackets || QR, s = mn(t), a = s.resolveInner(e, n);
    for (let l = a; l; l = l.parent) {
      let c = S1(l.type, n, o);
      if (c && l.from < l.to) {
        let u = w1(l);
        if (u && (n > 0 ? e >= u.from && e < u.to : e > u.from && e <= u.to))
          return Iq(t, e, n, l, u, c, o);
      }
    }
    return Bq(t, e, n, s, a.type, i, o);
  }
  function Iq(t, e, n, r, i, o, s) {
    let a = r.parent, l = {
      from: i.from,
      to: i.to
    }, c = 0, u = a == null ? void 0 : a.cursor();
    if (u && (n < 0 ? u.childBefore(r.from) : u.childAfter(r.to)))
      do
        if (n < 0 ? u.to <= r.from : u.from >= r.to) {
          if (c == 0 && o.indexOf(u.type.name) > -1 && u.from < u.to) {
            let h = w1(u);
            return {
              start: l,
              end: h ? {
                from: h.from,
                to: h.to
              } : void 0,
              matched: true
            };
          } else if (S1(u.type, n, s))
            c++;
          else if (S1(u.type, -n, s)) {
            if (c == 0) {
              let h = w1(u);
              return {
                start: l,
                end: h && h.from < h.to ? {
                  from: h.from,
                  to: h.to
                } : void 0,
                matched: false
              };
            }
            c--;
          }
        }
      while (n < 0 ? u.prevSibling() : u.nextSibling());
    return {
      start: l,
      matched: false
    };
  }
  function Bq(t, e, n, r, i, o, s) {
    let a = n < 0 ? t.sliceDoc(e - 1, e) : t.sliceDoc(e, e + 1), l = s.indexOf(a);
    if (l < 0 || l % 2 == 0 != n > 0)
      return null;
    let c = {
      from: n < 0 ? e - 1 : e,
      to: n > 0 ? e + 1 : e
    }, u = t.doc.iterRange(e, n > 0 ? t.doc.length : 0), h = 0;
    for (let p = 0; !u.next().done && p <= o; ) {
      let v = u.value;
      n < 0 && (p += v.length);
      let y = e + p * n;
      for (let x = n > 0 ? 0 : v.length - 1, T = n > 0 ? v.length : -1; x != T; x += n) {
        let w = s.indexOf(v[x]);
        if (!(w < 0 || r.resolveInner(y + x, 1).type != i))
          if (w % 2 == 0 == n > 0)
            h++;
          else {
            if (h == 1)
              return {
                start: c,
                end: {
                  from: y + x,
                  to: y + x + 1
                },
                matched: w >> 1 == l >> 1
              };
            h--;
          }
      }
      n > 0 && (p += v.length);
    }
    return u.done ? {
      start: c,
      matched: false
    } : null;
  }
  function kT(t, e, n, r = 0, i = 0) {
    e == null && (e = t.search(/[^\s\u00a0]/), e == -1 && (e = t.length));
    let o = i;
    for (let s = r; s < e; s++)
      t.charCodeAt(s) == 9 ? o += n - o % n : o++;
    return o;
  }
  class Nq {
    constructor(e, n, r, i) {
      this.string = e, this.tabSize = n, this.indentUnit = r, this.overrideIndent = i, this.pos = 0, this.start = 0, this.lastColumnPos = 0, this.lastColumnValue = 0;
    }
    eol() {
      return this.pos >= this.string.length;
    }
    sol() {
      return this.pos == 0;
    }
    peek() {
      return this.string.charAt(this.pos) || void 0;
    }
    next() {
      if (this.pos < this.string.length)
        return this.string.charAt(this.pos++);
    }
    eat(e) {
      let n = this.string.charAt(this.pos), r;
      if (typeof e == "string" ? r = n == e : r = n && (e instanceof RegExp ? e.test(n) : e(n)), r)
        return ++this.pos, n;
    }
    eatWhile(e) {
      let n = this.pos;
      for (; this.eat(e); )
        ;
      return this.pos > n;
    }
    eatSpace() {
      let e = this.pos;
      for (; /[\s\u00a0]/.test(this.string.charAt(this.pos)); )
        ++this.pos;
      return this.pos > e;
    }
    skipToEnd() {
      this.pos = this.string.length;
    }
    skipTo(e) {
      let n = this.string.indexOf(e, this.pos);
      if (n > -1)
        return this.pos = n, true;
    }
    backUp(e) {
      this.pos -= e;
    }
    column() {
      return this.lastColumnPos < this.start && (this.lastColumnValue = kT(this.string, this.start, this.tabSize, this.lastColumnPos, this.lastColumnValue), this.lastColumnPos = this.start), this.lastColumnValue;
    }
    indentation() {
      var e;
      return (e = this.overrideIndent) !== null && e !== void 0 ? e : kT(this.string, null, this.tabSize);
    }
    match(e, n, r) {
      if (typeof e == "string") {
        let i = (s) => r ? s.toLowerCase() : s, o = this.string.substr(this.pos, e.length);
        return i(o) == i(e) ? (n !== false && (this.pos += e.length), true) : null;
      } else {
        let i = this.string.slice(this.pos).match(e);
        return i && i.index > 0 ? null : (i && n !== false && (this.pos += i[0].length), i);
      }
    }
    current() {
      return this.string.slice(this.start, this.pos);
    }
  }
  const $q = /* @__PURE__ */ Object.create(null), CT = [
    Tr.none
  ], TT = [], MT = /* @__PURE__ */ Object.create(null), zq = /* @__PURE__ */ Object.create(null);
  for (let [t, e] of [
    [
      "variable",
      "variableName"
    ],
    [
      "variable-2",
      "variableName.special"
    ],
    [
      "string-2",
      "string.special"
    ],
    [
      "def",
      "variableName.definition"
    ],
    [
      "tag",
      "tagName"
    ],
    [
      "attribute",
      "attributeName"
    ],
    [
      "type",
      "typeName"
    ],
    [
      "builtin",
      "variableName.standard"
    ],
    [
      "qualifier",
      "modifier"
    ],
    [
      "error",
      "invalid"
    ],
    [
      "header",
      "heading"
    ],
    [
      "property",
      "propertyName"
    ]
  ])
    zq[t] = Fq($q, e);
  function G0(t, e) {
    TT.indexOf(t) > -1 || (TT.push(t), console.warn(e));
  }
  function Fq(t, e) {
    let n = [];
    for (let a of e.split(" ")) {
      let l = [];
      for (let c of a.split(".")) {
        let u = t[c] || G[c];
        u ? typeof u == "function" ? l.length ? l = l.map(u) : G0(c, `Modifier ${c} used at start of tag`) : l.length ? G0(c, `Tag ${c} used as modifier`) : l = Array.isArray(u) ? u : [
          u
        ] : G0(c, `Unknown highlighting tag ${c}`);
      }
      for (let c of l)
        n.push(c);
    }
    if (!n.length)
      return 0;
    let r = e.replace(/ /g, "_"), i = r + " " + n.map((a) => a.id), o = MT[i];
    if (o)
      return o.id;
    let s = MT[i] = Tr.define({
      id: CT.length,
      name: r,
      props: [
        UK({
          [r]: n
        })
      ]
    });
    return CT.push(s), s.id;
  }
  rt.RTL, rt.LTR;
  const Vq = (t) => {
    let { state: e } = t, n = e.doc.lineAt(e.selection.main.from), r = Kx(t.state, n.from);
    return r.line ? Hq(t) : r.block ? Wq(t) : false;
  };
  function Ux(t, e) {
    return ({ state: n, dispatch: r }) => {
      if (n.readOnly)
        return false;
      let i = t(e, n);
      return i ? (r(n.update(i)), true) : false;
    };
  }
  const Hq = Ux(qq, 0), jq = Ux(ZR, 0), Wq = Ux((t, e) => ZR(t, e, Kq(e)), 0);
  function Kx(t, e) {
    let n = t.languageDataAt("commentTokens", e, 1);
    return n.length ? n[0] : {};
  }
  const uc = 50;
  function Uq(t, { open: e, close: n }, r, i) {
    let o = t.sliceDoc(r - uc, r), s = t.sliceDoc(i, i + uc), a = /\s*$/.exec(o)[0].length, l = /^\s*/.exec(s)[0].length, c = o.length - a;
    if (o.slice(c - e.length, c) == e && s.slice(l, l + n.length) == n)
      return {
        open: {
          pos: r - a,
          margin: a && 1
        },
        close: {
          pos: i + l,
          margin: l && 1
        }
      };
    let u, h;
    i - r <= 2 * uc ? u = h = t.sliceDoc(r, i) : (u = t.sliceDoc(r, r + uc), h = t.sliceDoc(i - uc, i));
    let p = /^\s*/.exec(u)[0].length, v = /\s*$/.exec(h)[0].length, y = h.length - v - n.length;
    return u.slice(p, p + e.length) == e && h.slice(y, y + n.length) == n ? {
      open: {
        pos: r + p + e.length,
        margin: /\s/.test(u.charAt(p + e.length)) ? 1 : 0
      },
      close: {
        pos: i - v - n.length,
        margin: /\s/.test(h.charAt(y - 1)) ? 1 : 0
      }
    } : null;
  }
  function Kq(t) {
    let e = [];
    for (let n of t.selection.ranges) {
      let r = t.doc.lineAt(n.from), i = n.to <= r.to ? r : t.doc.lineAt(n.to);
      i.from > r.from && i.from == n.to && (i = n.to == r.to + 1 ? r : t.doc.lineAt(n.to - 1));
      let o = e.length - 1;
      o >= 0 && e[o].to > r.from ? e[o].to = i.to : e.push({
        from: r.from + /^\s*/.exec(r.text)[0].length,
        to: i.to
      });
    }
    return e;
  }
  function ZR(t, e, n = e.selection.ranges) {
    let r = n.map((o) => Kx(e, o.from).block);
    if (!r.every((o) => o))
      return null;
    let i = n.map((o, s) => Uq(e, r[s], o.from, o.to));
    if (t != 2 && !i.every((o) => o))
      return {
        changes: e.changes(n.map((o, s) => i[s] ? [] : [
          {
            from: o.from,
            insert: r[s].open + " "
          },
          {
            from: o.to,
            insert: " " + r[s].close
          }
        ]))
      };
    if (t != 1 && i.some((o) => o)) {
      let o = [];
      for (let s = 0, a; s < i.length; s++)
        if (a = i[s]) {
          let l = r[s], { open: c, close: u } = a;
          o.push({
            from: c.pos - l.open.length,
            to: c.pos + c.margin
          }, {
            from: u.pos - u.margin,
            to: u.pos + l.close.length
          });
        }
      return {
        changes: o
      };
    }
    return null;
  }
  function qq(t, e, n = e.selection.ranges) {
    let r = [], i = -1;
    for (let { from: o, to: s } of n) {
      let a = r.length, l = 1e9, c = Kx(e, o).line;
      if (!!c) {
        for (let u = o; u <= s; ) {
          let h = e.doc.lineAt(u);
          if (h.from > i && (o == s || s > h.from)) {
            i = h.from;
            let p = /^\s*/.exec(h.text)[0].length, v = p == h.length, y = h.text.slice(p, p + c.length) == c ? p : -1;
            p < h.text.length && p < l && (l = p), r.push({
              line: h,
              comment: y,
              token: c,
              indent: p,
              empty: v,
              single: false
            });
          }
          u = h.to + 1;
        }
        if (l < 1e9)
          for (let u = a; u < r.length; u++)
            r[u].indent < r[u].line.text.length && (r[u].indent = l);
        r.length == a + 1 && (r[a].single = true);
      }
    }
    if (t != 2 && r.some((o) => o.comment < 0 && (!o.empty || o.single))) {
      let o = [];
      for (let { line: a, token: l, indent: c, empty: u, single: h } of r)
        (h || !u) && o.push({
          from: a.from + c,
          insert: l + " "
        });
      let s = e.changes(o);
      return {
        changes: s,
        selection: e.selection.map(s, 1)
      };
    } else if (t != 1 && r.some((o) => o.comment >= 0)) {
      let o = [];
      for (let { line: s, comment: a, token: l } of r)
        if (a >= 0) {
          let c = s.from + a, u = c + l.length;
          s.text[u - s.from] == " " && u++, o.push({
            from: c,
            to: u
          });
        }
      return {
        changes: o
      };
    }
    return null;
  }
  const k1 = Pi.define(), Gq = Pi.define(), Yq = me.define(), eL = me.define({
    combine(t) {
      return Oi(t, {
        minDepth: 100,
        newGroupDelay: 500,
        joinToEvent: (e, n) => n
      }, {
        minDepth: Math.max,
        newGroupDelay: Math.min,
        joinToEvent: (e, n) => (r, i) => e(r, i) || n(r, i)
      });
    }
  }), tL = Ut.define({
    create() {
      return bi.empty;
    },
    update(t, e) {
      let n = e.state.facet(eL), r = e.annotation(k1);
      if (r) {
        let l = Nn.fromTransaction(e, r.selection), c = r.side, u = c == 0 ? t.undone : t.done;
        return l ? u = Dp(u, u.length, n.minDepth, l) : u = rL(u, e.startState.selection), new bi(c == 0 ? r.rest : u, c == 0 ? u : r.rest);
      }
      let i = e.annotation(Gq);
      if ((i == "full" || i == "before") && (t = t.isolate()), e.annotation(Bt.addToHistory) === false)
        return e.changes.empty ? t : t.addMapping(e.changes.desc);
      let o = Nn.fromTransaction(e), s = e.annotation(Bt.time), a = e.annotation(Bt.userEvent);
      return o ? t = t.addChanges(o, s, a, n, e) : e.selection && (t = t.addSelection(e.startState.selection, s, a, n.newGroupDelay)), (i == "full" || i == "after") && (t = t.isolate()), t;
    },
    toJSON(t) {
      return {
        done: t.done.map((e) => e.toJSON()),
        undone: t.undone.map((e) => e.toJSON())
      };
    },
    fromJSON(t) {
      return new bi(t.done.map(Nn.fromJSON), t.undone.map(Nn.fromJSON));
    }
  });
  function Xq(t = {}) {
    return [
      tL,
      eL.of(t),
      ue.domEventHandlers({
        beforeinput(e, n) {
          let r = e.inputType == "historyUndo" ? qx : e.inputType == "historyRedo" ? _p : null;
          return r ? (e.preventDefault(), r(n)) : false;
        }
      })
    ];
  }
  function Um(t, e) {
    return function({ state: n, dispatch: r }) {
      if (!e && n.readOnly)
        return false;
      let i = n.field(tL, false);
      if (!i)
        return false;
      let o = i.pop(t, n, e);
      return o ? (r(o), true) : false;
    };
  }
  const qx = Um(0, false), _p = Um(1, false), Qq = Um(0, true), Jq = Um(1, true);
  class Nn {
    constructor(e, n, r, i, o) {
      this.changes = e, this.effects = n, this.mapped = r, this.startSelection = i, this.selectionsAfter = o;
    }
    setSelAfter(e) {
      return new Nn(this.changes, this.effects, this.mapped, this.startSelection, e);
    }
    toJSON() {
      var e, n, r;
      return {
        changes: (e = this.changes) === null || e === void 0 ? void 0 : e.toJSON(),
        mapped: (n = this.mapped) === null || n === void 0 ? void 0 : n.toJSON(),
        startSelection: (r = this.startSelection) === null || r === void 0 ? void 0 : r.toJSON(),
        selectionsAfter: this.selectionsAfter.map((i) => i.toJSON())
      };
    }
    static fromJSON(e) {
      return new Nn(e.changes && Dt.fromJSON(e.changes), [], e.mapped && Ti.fromJSON(e.mapped), e.startSelection && q.fromJSON(e.startSelection), e.selectionsAfter.map(q.fromJSON));
    }
    static fromTransaction(e, n) {
      let r = gr;
      for (let i of e.startState.facet(Yq)) {
        let o = i(e);
        o.length && (r = r.concat(o));
      }
      return !r.length && e.changes.empty ? null : new Nn(e.changes.invert(e.startState.doc), r, void 0, n || e.startState.selection, gr);
    }
    static selection(e) {
      return new Nn(void 0, gr, void 0, void 0, e);
    }
  }
  function Dp(t, e, n, r) {
    let i = e + 1 > n + 20 ? e - n - 1 : 0, o = t.slice(i, e);
    return o.push(r), o;
  }
  function Zq(t, e) {
    let n = [], r = false;
    return t.iterChangedRanges((i, o) => n.push(i, o)), e.iterChangedRanges((i, o, s, a) => {
      for (let l = 0; l < n.length; ) {
        let c = n[l++], u = n[l++];
        a >= c && s <= u && (r = true);
      }
    }), r;
  }
  function eG(t, e) {
    return t.ranges.length == e.ranges.length && t.ranges.filter((n, r) => n.empty != e.ranges[r].empty).length === 0;
  }
  function nL(t, e) {
    return t.length ? e.length ? t.concat(e) : t : e;
  }
  const gr = [], tG = 200;
  function rL(t, e) {
    if (t.length) {
      let n = t[t.length - 1], r = n.selectionsAfter.slice(Math.max(0, n.selectionsAfter.length - tG));
      return r.length && r[r.length - 1].eq(e) ? t : (r.push(e), Dp(t, t.length - 1, 1e9, n.setSelAfter(r)));
    } else
      return [
        Nn.selection([
          e
        ])
      ];
  }
  function nG(t) {
    let e = t[t.length - 1], n = t.slice();
    return n[t.length - 1] = e.setSelAfter(e.selectionsAfter.slice(0, e.selectionsAfter.length - 1)), n;
  }
  function Y0(t, e) {
    if (!t.length)
      return t;
    let n = t.length, r = gr;
    for (; n; ) {
      let i = rG(t[n - 1], e, r);
      if (i.changes && !i.changes.empty || i.effects.length) {
        let o = t.slice(0, n);
        return o[n - 1] = i, o;
      } else
        e = i.mapped, n--, r = i.selectionsAfter;
    }
    return r.length ? [
      Nn.selection(r)
    ] : gr;
  }
  function rG(t, e, n) {
    let r = nL(t.selectionsAfter.length ? t.selectionsAfter.map((a) => a.map(e)) : gr, n);
    if (!t.changes)
      return Nn.selection(r);
    let i = t.changes.map(e), o = e.mapDesc(t.changes, true), s = t.mapped ? t.mapped.composeDesc(o) : o;
    return new Nn(i, Ee.mapEffects(t.effects, e), s, t.startSelection.map(o), r);
  }
  const iG = /^(input\.type|delete)($|\.)/;
  class bi {
    constructor(e, n, r = 0, i = void 0) {
      this.done = e, this.undone = n, this.prevTime = r, this.prevUserEvent = i;
    }
    isolate() {
      return this.prevTime ? new bi(this.done, this.undone) : this;
    }
    addChanges(e, n, r, i, o) {
      let s = this.done, a = s[s.length - 1];
      return a && a.changes && !a.changes.empty && e.changes && (!r || iG.test(r)) && (!a.selectionsAfter.length && n - this.prevTime < i.newGroupDelay && i.joinToEvent(o, Zq(a.changes, e.changes)) || r == "input.type.compose") ? s = Dp(s, s.length - 1, i.minDepth, new Nn(e.changes.compose(a.changes), nL(Ee.mapEffects(e.effects, a.changes), a.effects), a.mapped, a.startSelection, gr)) : s = Dp(s, s.length, i.minDepth, e), new bi(s, gr, n, r);
    }
    addSelection(e, n, r, i) {
      let o = this.done.length ? this.done[this.done.length - 1].selectionsAfter : gr;
      return o.length > 0 && n - this.prevTime < i && r == this.prevUserEvent && r && /^select($|\.)/.test(r) && eG(o[o.length - 1], e) ? this : new bi(rL(this.done, e), this.undone, n, r);
    }
    addMapping(e) {
      return new bi(Y0(this.done, e), Y0(this.undone, e), this.prevTime, this.prevUserEvent);
    }
    pop(e, n, r) {
      let i = e == 0 ? this.done : this.undone;
      if (i.length == 0)
        return null;
      let o = i[i.length - 1], s = o.selectionsAfter[0] || n.selection;
      if (r && o.selectionsAfter.length)
        return n.update({
          selection: o.selectionsAfter[o.selectionsAfter.length - 1],
          annotations: k1.of({
            side: e,
            rest: nG(i),
            selection: s
          }),
          userEvent: e == 0 ? "select.undo" : "select.redo",
          scrollIntoView: true
        });
      if (o.changes) {
        let a = i.length == 1 ? gr : i.slice(0, i.length - 1);
        return o.mapped && (a = Y0(a, o.mapped)), n.update({
          changes: o.changes,
          selection: o.startSelection,
          effects: o.effects,
          annotations: k1.of({
            side: e,
            rest: a,
            selection: s
          }),
          filter: false,
          userEvent: e == 0 ? "undo" : "redo",
          scrollIntoView: true
        });
      } else
        return null;
    }
  }
  bi.empty = new bi(gr, gr);
  const oG = [
    {
      key: "Mod-z",
      run: qx,
      preventDefault: true
    },
    {
      key: "Mod-y",
      mac: "Mod-Shift-z",
      run: _p,
      preventDefault: true
    },
    {
      linux: "Ctrl-Shift-z",
      run: _p,
      preventDefault: true
    },
    {
      key: "Mod-u",
      run: Qq,
      preventDefault: true
    },
    {
      key: "Alt-u",
      mac: "Mod-Shift-u",
      run: Jq,
      preventDefault: true
    }
  ];
  function Ol(t, e) {
    return q.create(t.ranges.map(e), t.mainIndex);
  }
  function Yr(t, e) {
    return t.update({
      selection: e,
      scrollIntoView: true,
      userEvent: "select"
    });
  }
  function Xr({ state: t, dispatch: e }, n) {
    let r = Ol(t.selection, n);
    return r.eq(t.selection, true) ? false : (e(Yr(t, r)), true);
  }
  function Km(t, e) {
    return q.cursor(e ? t.to : t.from);
  }
  function Gx(t, e) {
    return Xr(t, (n) => n.empty ? t.moveByChar(n, e) : Km(n, e));
  }
  function gn(t) {
    return t.textDirectionAt(t.state.selection.main.head) == rt.LTR;
  }
  const Yx = (t) => Gx(t, !gn(t)), iL = (t) => Gx(t, gn(t)), sG = (t) => Gx(t, false);
  function oL(t, e) {
    return Xr(t, (n) => n.empty ? t.moveByGroup(n, e) : Km(n, e));
  }
  const aG = (t) => oL(t, !gn(t)), lG = (t) => oL(t, gn(t));
  function cG(t, e, n) {
    if (e.type.prop(n))
      return true;
    let r = e.to - e.from;
    return r && (r > 2 || /[^\s,.;:]/.test(t.sliceDoc(e.from, e.to))) || e.firstChild;
  }
  function qm(t, e, n) {
    let r = mn(t).resolveInner(e.head), i = n ? $e.closedBy : $e.openedBy;
    for (let l = e.head; ; ) {
      let c = n ? r.childAfter(l) : r.childBefore(l);
      if (!c)
        break;
      cG(t, c, i) ? r = c : l = n ? c.to : c.from;
    }
    let o = r.type.prop(i), s, a;
    return o && (s = n ? mr(t, r.from, 1) : mr(t, r.to, -1)) && s.matched ? a = n ? s.end.to : s.end.from : a = n ? r.to : r.from, q.cursor(a, n ? -1 : 1);
  }
  const uG = (t) => Xr(t, (e) => qm(t.state, e, !gn(t))), fG = (t) => Xr(t, (e) => qm(t.state, e, gn(t)));
  function sL(t, e) {
    return Xr(t, (n) => {
      if (!n.empty)
        return Km(n, e);
      let r = t.moveVertically(n, e);
      return r.head != n.head ? r : t.moveToLineBoundary(n, e);
    });
  }
  const aL = (t) => sL(t, false), lL = (t) => sL(t, true);
  function cL(t) {
    let e = t.scrollDOM.clientHeight < t.scrollDOM.scrollHeight - 2, n = 0, r = 0, i;
    if (e) {
      for (let o of t.state.facet(ue.scrollMargins)) {
        let s = o(t);
        (s == null ? void 0 : s.top) && (n = Math.max(s == null ? void 0 : s.top, n)), (s == null ? void 0 : s.bottom) && (r = Math.max(s == null ? void 0 : s.bottom, r));
      }
      i = t.scrollDOM.clientHeight - n - r;
    } else
      i = (t.dom.ownerDocument.defaultView || window).innerHeight;
    return {
      marginTop: n,
      marginBottom: r,
      selfScroll: e,
      height: Math.max(t.defaultLineHeight, i - 5)
    };
  }
  function uL(t, e) {
    let n = cL(t), { state: r } = t, i = Ol(r.selection, (s) => s.empty ? t.moveVertically(s, e, n.height) : Km(s, e));
    if (i.eq(r.selection))
      return false;
    let o;
    if (n.selfScroll) {
      let s = t.coordsAtPos(r.selection.main.head), a = t.scrollDOM.getBoundingClientRect(), l = a.top + n.marginTop, c = a.bottom - n.marginBottom;
      s && s.top > l && s.bottom < c && (o = ue.scrollIntoView(i.main.head, {
        y: "start",
        yMargin: s.top - l
      }));
    }
    return t.dispatch(Yr(r, i), {
      effects: o
    }), true;
  }
  const AT = (t) => uL(t, false), C1 = (t) => uL(t, true);
  function rs(t, e, n) {
    let r = t.lineBlockAt(e.head), i = t.moveToLineBoundary(e, n);
    if (i.head == e.head && i.head != (n ? r.to : r.from) && (i = t.moveToLineBoundary(e, n, false)), !n && i.head == r.from && r.length) {
      let o = /^\s*/.exec(t.state.sliceDoc(r.from, Math.min(r.from + 100, r.to)))[0].length;
      o && e.head != r.from + o && (i = q.cursor(r.from + o));
    }
    return i;
  }
  const fL = (t) => Xr(t, (e) => rs(t, e, true)), hL = (t) => Xr(t, (e) => rs(t, e, false)), hG = (t) => Xr(t, (e) => rs(t, e, !gn(t))), dG = (t) => Xr(t, (e) => rs(t, e, gn(t))), pG = (t) => Xr(t, (e) => q.cursor(t.lineBlockAt(e.head).from, 1)), mG = (t) => Xr(t, (e) => q.cursor(t.lineBlockAt(e.head).to, -1));
  function gG(t, e, n) {
    let r = false, i = Ol(t.selection, (o) => {
      let s = mr(t, o.head, -1) || mr(t, o.head, 1) || o.head > 0 && mr(t, o.head - 1, 1) || o.head < t.doc.length && mr(t, o.head + 1, -1);
      if (!s || !s.end)
        return o;
      r = true;
      let a = s.start.from == o.head ? s.end.to : s.end.from;
      return n ? q.range(o.anchor, a) : q.cursor(a);
    });
    return r ? (e(Yr(t, i)), true) : false;
  }
  const vG = ({ state: t, dispatch: e }) => gG(t, e, false);
  function Er(t, e) {
    let n = Ol(t.state.selection, (r) => {
      let i = e(r);
      return q.range(r.anchor, i.head, i.goalColumn, i.bidiLevel || void 0);
    });
    return n.eq(t.state.selection) ? false : (t.dispatch(Yr(t.state, n)), true);
  }
  function dL(t, e) {
    return Er(t, (n) => t.moveByChar(n, e));
  }
  const pL = (t) => dL(t, !gn(t)), mL = (t) => dL(t, gn(t));
  function gL(t, e) {
    return Er(t, (n) => t.moveByGroup(n, e));
  }
  const yG = (t) => gL(t, !gn(t)), bG = (t) => gL(t, gn(t)), xG = (t) => Er(t, (e) => qm(t.state, e, !gn(t))), SG = (t) => Er(t, (e) => qm(t.state, e, gn(t)));
  function vL(t, e) {
    return Er(t, (n) => t.moveVertically(n, e));
  }
  const yL = (t) => vL(t, false), bL = (t) => vL(t, true);
  function xL(t, e) {
    return Er(t, (n) => t.moveVertically(n, e, cL(t).height));
  }
  const ET = (t) => xL(t, false), PT = (t) => xL(t, true), wG = (t) => Er(t, (e) => rs(t, e, true)), kG = (t) => Er(t, (e) => rs(t, e, false)), CG = (t) => Er(t, (e) => rs(t, e, !gn(t))), TG = (t) => Er(t, (e) => rs(t, e, gn(t))), MG = (t) => Er(t, (e) => q.cursor(t.lineBlockAt(e.head).from)), AG = (t) => Er(t, (e) => q.cursor(t.lineBlockAt(e.head).to)), OT = ({ state: t, dispatch: e }) => (e(Yr(t, {
    anchor: 0
  })), true), RT = ({ state: t, dispatch: e }) => (e(Yr(t, {
    anchor: t.doc.length
  })), true), LT = ({ state: t, dispatch: e }) => (e(Yr(t, {
    anchor: t.selection.main.anchor,
    head: 0
  })), true), _T = ({ state: t, dispatch: e }) => (e(Yr(t, {
    anchor: t.selection.main.anchor,
    head: t.doc.length
  })), true), EG = ({ state: t, dispatch: e }) => (e(t.update({
    selection: {
      anchor: 0,
      head: t.doc.length
    },
    userEvent: "select"
  })), true), PG = ({ state: t, dispatch: e }) => {
    let n = Gm(t).map(({ from: r, to: i }) => q.range(r, Math.min(i + 1, t.doc.length)));
    return e(t.update({
      selection: q.create(n),
      userEvent: "select"
    })), true;
  }, OG = ({ state: t, dispatch: e }) => {
    let n = Ol(t.selection, (r) => {
      let i = mn(t), o = i.resolveStack(r.from, 1);
      if (r.empty) {
        let s = i.resolveStack(r.from, -1);
        s.node.from >= o.node.from && s.node.to <= o.node.to && (o = s);
      }
      for (let s = o; s; s = s.next) {
        let { node: a } = s;
        if ((a.from < r.from && a.to >= r.to || a.to > r.to && a.from <= r.from) && s.next)
          return q.range(a.to, a.from);
      }
      return r;
    });
    return n.eq(t.selection) ? false : (e(Yr(t, n)), true);
  };
  function SL(t, e) {
    let { state: n } = t, r = n.selection, i = n.selection.ranges.slice();
    for (let o of n.selection.ranges) {
      let s = n.doc.lineAt(o.head);
      if (e ? s.to < t.state.doc.length : s.from > 0)
        for (let a = o; ; ) {
          let l = t.moveVertically(a, e);
          if (l.head < s.from || l.head > s.to) {
            i.some((c) => c.head == l.head) || i.push(l);
            break;
          } else {
            if (l.head == a.head)
              break;
            a = l;
          }
        }
    }
    return i.length == r.ranges.length ? false : (t.dispatch(Yr(n, q.create(i, i.length - 1))), true);
  }
  const RG = (t) => SL(t, false), LG = (t) => SL(t, true), _G = ({ state: t, dispatch: e }) => {
    let n = t.selection, r = null;
    return n.ranges.length > 1 ? r = q.create([
      n.main
    ]) : n.main.empty || (r = q.create([
      q.cursor(n.main.head)
    ])), r ? (e(Yr(t, r)), true) : false;
  };
  function pf(t, e) {
    if (t.state.readOnly)
      return false;
    let n = "delete.selection", { state: r } = t, i = r.changeByRange((o) => {
      let { from: s, to: a } = o;
      if (s == a) {
        let l = e(o);
        l < s ? (n = "delete.backward", l = zh(t, l, false)) : l > s && (n = "delete.forward", l = zh(t, l, true)), s = Math.min(s, l), a = Math.max(a, l);
      } else
        s = zh(t, s, false), a = zh(t, a, true);
      return s == a ? {
        range: o
      } : {
        changes: {
          from: s,
          to: a
        },
        range: q.cursor(s, s < o.head ? -1 : 1)
      };
    });
    return i.changes.empty ? false : (t.dispatch(r.update(i, {
      scrollIntoView: true,
      userEvent: n,
      effects: n == "delete.selection" ? ue.announce.of(r.phrase("Selection deleted")) : void 0
    })), true);
  }
  function zh(t, e, n) {
    if (t instanceof ue)
      for (let r of t.state.facet(ue.atomicRanges).map((i) => i(t)))
        r.between(e, e, (i, o) => {
          i < e && o > e && (e = n ? o : i);
        });
    return e;
  }
  const wL = (t, e, n) => pf(t, (r) => {
    let i = r.from, { state: o } = t, s = o.doc.lineAt(i), a, l;
    if (n && !e && i > s.from && i < s.from + 200 && !/[^ \t]/.test(a = s.text.slice(0, i - s.from))) {
      if (a[a.length - 1] == "	")
        return i - 1;
      let c = Pl(a, o.tabSize), u = c % Op(o) || Op(o);
      for (let h = 0; h < u && a[a.length - 1 - h] == " "; h++)
        i--;
      l = i;
    } else
      l = en(s.text, i - s.from, e, e) + s.from, l == i && s.number != (e ? o.doc.lines : 1) ? l += e ? 1 : -1 : !e && /[\ufe00-\ufe0f]/.test(s.text.slice(l - s.from, i - s.from)) && (l = en(s.text, l - s.from, false, false) + s.from);
    return l;
  }), T1 = (t) => wL(t, false, true), kL = (t) => wL(t, true, false), CL = (t, e) => pf(t, (n) => {
    let r = n.head, { state: i } = t, o = i.doc.lineAt(r), s = i.charCategorizer(r);
    for (let a = null; ; ) {
      if (r == (e ? o.to : o.from)) {
        r == n.head && o.number != (e ? i.doc.lines : 1) && (r += e ? 1 : -1);
        break;
      }
      let l = en(o.text, r - o.from, e) + o.from, c = o.text.slice(Math.min(r, l) - o.from, Math.max(r, l) - o.from), u = s(c);
      if (a != null && u != a)
        break;
      (c != " " || r != n.head) && (a = u), r = l;
    }
    return r;
  }), TL = (t) => CL(t, false), DG = (t) => CL(t, true), IG = (t) => pf(t, (e) => {
    let n = t.lineBlockAt(e.head).to;
    return e.head < n ? n : Math.min(t.state.doc.length, e.head + 1);
  }), BG = (t) => pf(t, (e) => {
    let n = t.moveToLineBoundary(e, false).head;
    return e.head > n ? n : Math.max(0, e.head - 1);
  }), NG = (t) => pf(t, (e) => {
    let n = t.moveToLineBoundary(e, true).head;
    return e.head < n ? n : Math.min(t.state.doc.length, e.head + 1);
  }), $G = ({ state: t, dispatch: e }) => {
    if (t.readOnly)
      return false;
    let n = t.changeByRange((r) => ({
      changes: {
        from: r.from,
        to: r.to,
        insert: He.of([
          "",
          ""
        ])
      },
      range: q.cursor(r.from)
    }));
    return e(t.update(n, {
      scrollIntoView: true,
      userEvent: "input"
    })), true;
  }, zG = ({ state: t, dispatch: e }) => {
    if (t.readOnly)
      return false;
    let n = t.changeByRange((r) => {
      if (!r.empty || r.from == 0 || r.from == t.doc.length)
        return {
          range: r
        };
      let i = r.from, o = t.doc.lineAt(i), s = i == o.from ? i - 1 : en(o.text, i - o.from, false) + o.from, a = i == o.to ? i + 1 : en(o.text, i - o.from, true) + o.from;
      return {
        changes: {
          from: s,
          to: a,
          insert: t.doc.slice(i, a).append(t.doc.slice(s, i))
        },
        range: q.cursor(a)
      };
    });
    return n.changes.empty ? false : (e(t.update(n, {
      scrollIntoView: true,
      userEvent: "move.character"
    })), true);
  };
  function Gm(t) {
    let e = [], n = -1;
    for (let r of t.selection.ranges) {
      let i = t.doc.lineAt(r.from), o = t.doc.lineAt(r.to);
      if (!r.empty && r.to == o.from && (o = t.doc.lineAt(r.to - 1)), n >= i.number) {
        let s = e[e.length - 1];
        s.to = o.to, s.ranges.push(r);
      } else
        e.push({
          from: i.from,
          to: o.to,
          ranges: [
            r
          ]
        });
      n = o.number + 1;
    }
    return e;
  }
  function ML(t, e, n) {
    if (t.readOnly)
      return false;
    let r = [], i = [];
    for (let o of Gm(t)) {
      if (n ? o.to == t.doc.length : o.from == 0)
        continue;
      let s = t.doc.lineAt(n ? o.to + 1 : o.from - 1), a = s.length + 1;
      if (n) {
        r.push({
          from: o.to,
          to: s.to
        }, {
          from: o.from,
          insert: s.text + t.lineBreak
        });
        for (let l of o.ranges)
          i.push(q.range(Math.min(t.doc.length, l.anchor + a), Math.min(t.doc.length, l.head + a)));
      } else {
        r.push({
          from: s.from,
          to: o.from
        }, {
          from: o.to,
          insert: t.lineBreak + s.text
        });
        for (let l of o.ranges)
          i.push(q.range(l.anchor - a, l.head - a));
      }
    }
    return r.length ? (e(t.update({
      changes: r,
      scrollIntoView: true,
      selection: q.create(i, t.selection.mainIndex),
      userEvent: "move.line"
    })), true) : false;
  }
  const FG = ({ state: t, dispatch: e }) => ML(t, e, false), VG = ({ state: t, dispatch: e }) => ML(t, e, true);
  function AL(t, e, n) {
    if (t.readOnly)
      return false;
    let r = [];
    for (let i of Gm(t))
      n ? r.push({
        from: i.from,
        insert: t.doc.slice(i.from, i.to) + t.lineBreak
      }) : r.push({
        from: i.to,
        insert: t.lineBreak + t.doc.slice(i.from, i.to)
      });
    return e(t.update({
      changes: r,
      scrollIntoView: true,
      userEvent: "input.copyline"
    })), true;
  }
  const HG = ({ state: t, dispatch: e }) => AL(t, e, false), jG = ({ state: t, dispatch: e }) => AL(t, e, true), WG = (t) => {
    if (t.state.readOnly)
      return false;
    let { state: e } = t, n = e.changes(Gm(e).map(({ from: i, to: o }) => (i > 0 ? i-- : o < e.doc.length && o++, {
      from: i,
      to: o
    }))), r = Ol(e.selection, (i) => {
      let o;
      if (t.lineWrapping) {
        let s = t.lineBlockAt(i.head), a = t.coordsAtPos(i.head, i.assoc || 1);
        a && (o = s.bottom + t.documentTop - a.bottom + t.defaultLineHeight / 2);
      }
      return t.moveVertically(i, true, o);
    }).map(n);
    return t.dispatch({
      changes: n,
      selection: r,
      scrollIntoView: true,
      userEvent: "delete.line"
    }), true;
  };
  function UG(t, e) {
    if (/\(\)|\[\]|\{\}/.test(t.sliceDoc(e - 1, e + 1)))
      return {
        from: e,
        to: e
      };
    let n = mn(t).resolveInner(e), r = n.childBefore(e), i = n.childAfter(e), o;
    return r && i && r.to <= e && i.from >= e && (o = r.type.prop($e.closedBy)) && o.indexOf(i.name) > -1 && t.doc.lineAt(r.to).from == t.doc.lineAt(i.from).from && !/\S/.test(t.sliceDoc(r.to, i.from)) ? {
      from: r.to,
      to: i.from
    } : null;
  }
  const M1 = EL(false), KG = EL(true);
  function EL(t) {
    return ({ state: e, dispatch: n }) => {
      if (e.readOnly)
        return false;
      let r = e.changeByRange((i) => {
        let { from: o, to: s } = i, a = e.doc.lineAt(o), l = !t && o == s && UG(e, o);
        t && (o = s = (s <= a.to ? a : e.doc.lineAt(s)).to);
        let c = new jm(e, {
          simulateBreak: o,
          simulateDoubleBreak: !!l
        }), u = Hx(c, o);
        for (u == null && (u = Pl(/^\s*/.exec(e.doc.lineAt(o).text)[0], e.tabSize)); s < a.to && /\s/.test(a.text[s - a.from]); )
          s++;
        l ? { from: o, to: s } = l : o > a.from && o < a.from + 100 && !/\S/.test(a.text.slice(0, o)) && (o = a.from);
        let h = [
          "",
          Hu(e, u)
        ];
        return l && h.push(Hu(e, c.lineIndent(a.from, -1))), {
          changes: {
            from: o,
            to: s,
            insert: He.of(h)
          },
          range: q.cursor(o + 1 + h[1].length)
        };
      });
      return n(e.update(r, {
        scrollIntoView: true,
        userEvent: "input"
      })), true;
    };
  }
  function Xx(t, e) {
    let n = -1;
    return t.changeByRange((r) => {
      let i = [];
      for (let s = r.from; s <= r.to; ) {
        let a = t.doc.lineAt(s);
        a.number > n && (r.empty || r.to > a.from) && (e(a, i, r), n = a.number), s = a.to + 1;
      }
      let o = t.changes(i);
      return {
        changes: i,
        range: q.range(o.mapPos(r.anchor, 1), o.mapPos(r.head, 1))
      };
    });
  }
  const PL = ({ state: t, dispatch: e }) => {
    if (t.readOnly)
      return false;
    let n = /* @__PURE__ */ Object.create(null), r = new jm(t, {
      overrideIndentation: (o) => {
        let s = n[o];
        return s ?? -1;
      }
    }), i = Xx(t, (o, s, a) => {
      let l = Hx(r, o.from);
      if (l == null)
        return;
      /\S/.test(o.text) || (l = 0);
      let c = /^\s*/.exec(o.text)[0], u = Hu(t, l);
      (c != u || a.from < o.from + c.length) && (n[o.from] = l, s.push({
        from: o.from,
        to: o.from + c.length,
        insert: u
      }));
    });
    return i.changes.empty || e(t.update(i, {
      userEvent: "indent"
    })), true;
  }, Qx = ({ state: t, dispatch: e }) => t.readOnly ? false : (e(t.update(Xx(t, (n, r) => {
    r.push({
      from: n.from,
      insert: t.facet(xl)
    });
  }), {
    userEvent: "input.indent"
  })), true), Jx = ({ state: t, dispatch: e }) => t.readOnly ? false : (e(t.update(Xx(t, (n, r) => {
    let i = /^\s*/.exec(n.text)[0];
    if (!i)
      return;
    let o = Pl(i, t.tabSize), s = 0, a = Hu(t, Math.max(0, o - Op(t)));
    for (; s < i.length && s < a.length && i.charCodeAt(s) == a.charCodeAt(s); )
      s++;
    r.push({
      from: n.from + s,
      to: n.from + i.length,
      insert: a.slice(s)
    });
  }), {
    userEvent: "delete.dedent"
  })), true), qG = (t) => (t.setTabFocusMode(), true), GG = [
    {
      key: "Ctrl-b",
      run: Yx,
      shift: pL,
      preventDefault: true
    },
    {
      key: "Ctrl-f",
      run: iL,
      shift: mL
    },
    {
      key: "Ctrl-p",
      run: aL,
      shift: yL
    },
    {
      key: "Ctrl-n",
      run: lL,
      shift: bL
    },
    {
      key: "Ctrl-a",
      run: pG,
      shift: MG
    },
    {
      key: "Ctrl-e",
      run: mG,
      shift: AG
    },
    {
      key: "Ctrl-d",
      run: kL
    },
    {
      key: "Ctrl-h",
      run: T1
    },
    {
      key: "Ctrl-k",
      run: IG
    },
    {
      key: "Ctrl-Alt-h",
      run: TL
    },
    {
      key: "Ctrl-o",
      run: $G
    },
    {
      key: "Ctrl-t",
      run: zG
    },
    {
      key: "Ctrl-v",
      run: C1
    }
  ], YG = [
    {
      key: "ArrowLeft",
      run: Yx,
      shift: pL,
      preventDefault: true
    },
    {
      key: "Mod-ArrowLeft",
      mac: "Alt-ArrowLeft",
      run: aG,
      shift: yG,
      preventDefault: true
    },
    {
      mac: "Cmd-ArrowLeft",
      run: hG,
      shift: CG,
      preventDefault: true
    },
    {
      key: "ArrowRight",
      run: iL,
      shift: mL,
      preventDefault: true
    },
    {
      key: "Mod-ArrowRight",
      mac: "Alt-ArrowRight",
      run: lG,
      shift: bG,
      preventDefault: true
    },
    {
      mac: "Cmd-ArrowRight",
      run: dG,
      shift: TG,
      preventDefault: true
    },
    {
      key: "ArrowUp",
      run: aL,
      shift: yL,
      preventDefault: true
    },
    {
      mac: "Cmd-ArrowUp",
      run: OT,
      shift: LT
    },
    {
      mac: "Ctrl-ArrowUp",
      run: AT,
      shift: ET
    },
    {
      key: "ArrowDown",
      run: lL,
      shift: bL,
      preventDefault: true
    },
    {
      mac: "Cmd-ArrowDown",
      run: RT,
      shift: _T
    },
    {
      mac: "Ctrl-ArrowDown",
      run: C1,
      shift: PT
    },
    {
      key: "PageUp",
      run: AT,
      shift: ET
    },
    {
      key: "PageDown",
      run: C1,
      shift: PT
    },
    {
      key: "Home",
      run: hL,
      shift: kG,
      preventDefault: true
    },
    {
      key: "Mod-Home",
      run: OT,
      shift: LT
    },
    {
      key: "End",
      run: fL,
      shift: wG,
      preventDefault: true
    },
    {
      key: "Mod-End",
      run: RT,
      shift: _T
    },
    {
      key: "Enter",
      run: M1,
      shift: M1
    },
    {
      key: "Mod-a",
      run: EG
    },
    {
      key: "Backspace",
      run: T1,
      shift: T1,
      preventDefault: true
    },
    {
      key: "Delete",
      run: kL,
      preventDefault: true
    },
    {
      key: "Mod-Backspace",
      mac: "Alt-Backspace",
      run: TL,
      preventDefault: true
    },
    {
      key: "Mod-Delete",
      mac: "Alt-Delete",
      run: DG,
      preventDefault: true
    },
    {
      mac: "Mod-Backspace",
      run: BG,
      preventDefault: true
    },
    {
      mac: "Mod-Delete",
      run: NG,
      preventDefault: true
    }
  ].concat(GG.map((t) => ({
    mac: t.key,
    run: t.run,
    shift: t.shift
  }))), XG = [
    {
      key: "Alt-ArrowLeft",
      mac: "Ctrl-ArrowLeft",
      run: uG,
      shift: xG
    },
    {
      key: "Alt-ArrowRight",
      mac: "Ctrl-ArrowRight",
      run: fG,
      shift: SG
    },
    {
      key: "Alt-ArrowUp",
      run: FG
    },
    {
      key: "Shift-Alt-ArrowUp",
      run: HG
    },
    {
      key: "Alt-ArrowDown",
      run: VG
    },
    {
      key: "Shift-Alt-ArrowDown",
      run: jG
    },
    {
      key: "Mod-Alt-ArrowUp",
      run: RG
    },
    {
      key: "Mod-Alt-ArrowDown",
      run: LG
    },
    {
      key: "Escape",
      run: _G
    },
    {
      key: "Mod-Enter",
      run: KG
    },
    {
      key: "Alt-l",
      mac: "Ctrl-l",
      run: PG
    },
    {
      key: "Mod-i",
      run: OG,
      preventDefault: true
    },
    {
      key: "Mod-[",
      run: Jx
    },
    {
      key: "Mod-]",
      run: Qx
    },
    {
      key: "Mod-Alt-\\",
      run: PL
    },
    {
      key: "Shift-Mod-k",
      run: WG
    },
    {
      key: "Shift-Mod-\\",
      run: vG
    },
    {
      key: "Mod-/",
      run: Vq
    },
    {
      key: "Alt-A",
      run: jq
    },
    {
      key: "Ctrl-m",
      mac: "Shift-Alt-m",
      run: qG
    }
  ].concat(YG), QG = {
    key: "Tab",
    run: Qx,
    shift: Jx
  }, DT = typeof String.prototype.normalize == "function" ? (t) => t.normalize("NFKD") : (t) => t;
  class Sl {
    constructor(e, n, r = 0, i = e.length, o, s) {
      this.test = s, this.value = {
        from: 0,
        to: 0
      }, this.done = false, this.matches = [], this.buffer = "", this.bufferPos = 0, this.iter = e.iterRange(r, i), this.bufferStart = r, this.normalize = o ? (a) => o(DT(a)) : DT, this.query = this.normalize(n);
    }
    peek() {
      if (this.bufferPos == this.buffer.length) {
        if (this.bufferStart += this.buffer.length, this.iter.next(), this.iter.done)
          return -1;
        this.bufferPos = 0, this.buffer = this.iter.value;
      }
      return Ln(this.buffer, this.bufferPos);
    }
    next() {
      for (; this.matches.length; )
        this.matches.pop();
      return this.nextOverlapping();
    }
    nextOverlapping() {
      for (; ; ) {
        let e = this.peek();
        if (e < 0)
          return this.done = true, this;
        let n = Cx(e), r = this.bufferStart + this.bufferPos;
        this.bufferPos += mi(e);
        let i = this.normalize(n);
        if (i.length)
          for (let o = 0, s = r; ; o++) {
            let a = i.charCodeAt(o), l = this.match(a, s, this.bufferPos + this.bufferStart);
            if (o == i.length - 1) {
              if (l)
                return this.value = l, this;
              break;
            }
            s == r && o < n.length && n.charCodeAt(o) == a && s++;
          }
      }
    }
    match(e, n, r) {
      let i = null;
      for (let o = 0; o < this.matches.length; o += 2) {
        let s = this.matches[o], a = false;
        this.query.charCodeAt(s) == e && (s == this.query.length - 1 ? i = {
          from: this.matches[o + 1],
          to: r
        } : (this.matches[o]++, a = true)), a || (this.matches.splice(o, 2), o -= 2);
      }
      return this.query.charCodeAt(0) == e && (this.query.length == 1 ? i = {
        from: n,
        to: r
      } : this.matches.push(1, n)), i && this.test && !this.test(i.from, i.to, this.buffer, this.bufferStart) && (i = null), i;
    }
  }
  typeof Symbol < "u" && (Sl.prototype[Symbol.iterator] = function() {
    return this;
  });
  const OL = {
    from: -1,
    to: -1,
    match: /.*/.exec("")
  }, Zx = "gm" + (/x/.unicode == null ? "" : "u");
  class eS {
    constructor(e, n, r, i = 0, o = e.length) {
      if (this.text = e, this.to = o, this.curLine = "", this.done = false, this.value = OL, /\\[sWDnr]|\n|\r|\[\^/.test(n))
        return new RL(e, n, r, i, o);
      this.re = new RegExp(n, Zx + ((r == null ? void 0 : r.ignoreCase) ? "i" : "")), this.test = r == null ? void 0 : r.test, this.iter = e.iter();
      let s = e.lineAt(i);
      this.curLineStart = s.from, this.matchPos = Ip(e, i), this.getLine(this.curLineStart);
    }
    getLine(e) {
      this.iter.next(e), this.iter.lineBreak ? this.curLine = "" : (this.curLine = this.iter.value, this.curLineStart + this.curLine.length > this.to && (this.curLine = this.curLine.slice(0, this.to - this.curLineStart)), this.iter.next());
    }
    nextLine() {
      this.curLineStart = this.curLineStart + this.curLine.length + 1, this.curLineStart > this.to ? this.curLine = "" : this.getLine(0);
    }
    next() {
      for (let e = this.matchPos - this.curLineStart; ; ) {
        this.re.lastIndex = e;
        let n = this.matchPos <= this.to && this.re.exec(this.curLine);
        if (n) {
          let r = this.curLineStart + n.index, i = r + n[0].length;
          if (this.matchPos = Ip(this.text, i + (r == i ? 1 : 0)), r == this.curLineStart + this.curLine.length && this.nextLine(), (r < i || r > this.value.to) && (!this.test || this.test(r, i, n)))
            return this.value = {
              from: r,
              to: i,
              match: n
            }, this;
          e = this.matchPos - this.curLineStart;
        } else if (this.curLineStart + this.curLine.length < this.to)
          this.nextLine(), e = 0;
        else
          return this.done = true, this;
      }
    }
  }
  const X0 = /* @__PURE__ */ new WeakMap();
  class Ja {
    constructor(e, n) {
      this.from = e, this.text = n;
    }
    get to() {
      return this.from + this.text.length;
    }
    static get(e, n, r) {
      let i = X0.get(e);
      if (!i || i.from >= r || i.to <= n) {
        let a = new Ja(n, e.sliceString(n, r));
        return X0.set(e, a), a;
      }
      if (i.from == n && i.to == r)
        return i;
      let { text: o, from: s } = i;
      return s > n && (o = e.sliceString(n, s) + o, s = n), i.to < r && (o += e.sliceString(i.to, r)), X0.set(e, new Ja(s, o)), new Ja(n, o.slice(n - s, r - s));
    }
  }
  class RL {
    constructor(e, n, r, i, o) {
      this.text = e, this.to = o, this.done = false, this.value = OL, this.matchPos = Ip(e, i), this.re = new RegExp(n, Zx + ((r == null ? void 0 : r.ignoreCase) ? "i" : "")), this.test = r == null ? void 0 : r.test, this.flat = Ja.get(e, i, this.chunkEnd(i + 5e3));
    }
    chunkEnd(e) {
      return e >= this.to ? this.to : this.text.lineAt(e).to;
    }
    next() {
      for (; ; ) {
        let e = this.re.lastIndex = this.matchPos - this.flat.from, n = this.re.exec(this.flat.text);
        if (n && !n[0] && n.index == e && (this.re.lastIndex = e + 1, n = this.re.exec(this.flat.text)), n) {
          let r = this.flat.from + n.index, i = r + n[0].length;
          if ((this.flat.to >= this.to || n.index + n[0].length <= this.flat.text.length - 10) && (!this.test || this.test(r, i, n)))
            return this.value = {
              from: r,
              to: i,
              match: n
            }, this.matchPos = Ip(this.text, i + (r == i ? 1 : 0)), this;
        }
        if (this.flat.to == this.to)
          return this.done = true, this;
        this.flat = Ja.get(this.text, this.flat.from, this.chunkEnd(this.flat.from + this.flat.text.length * 2));
      }
    }
  }
  typeof Symbol < "u" && (eS.prototype[Symbol.iterator] = RL.prototype[Symbol.iterator] = function() {
    return this;
  });
  function JG(t) {
    try {
      return new RegExp(t, Zx), true;
    } catch {
      return false;
    }
  }
  function Ip(t, e) {
    if (e >= t.length)
      return e;
    let n = t.lineAt(e), r;
    for (; e < n.to && (r = n.text.charCodeAt(e - n.from)) >= 56320 && r < 57344; )
      e++;
    return e;
  }
  function A1(t) {
    let e = String(t.state.doc.lineAt(t.state.selection.main.head).number), n = Je("input", {
      class: "cm-textfield",
      name: "line",
      value: e
    }), r = Je("form", {
      class: "cm-gotoLine",
      onkeydown: (o) => {
        o.keyCode == 27 ? (o.preventDefault(), t.dispatch({
          effects: tu.of(false)
        }), t.focus()) : o.keyCode == 13 && (o.preventDefault(), i());
      },
      onsubmit: (o) => {
        o.preventDefault(), i();
      }
    }, Je("label", t.state.phrase("Go to line"), ": ", n), " ", Je("button", {
      class: "cm-button",
      type: "submit"
    }, t.state.phrase("go")), Je("button", {
      name: "close",
      onclick: () => {
        t.dispatch({
          effects: tu.of(false)
        }), t.focus();
      },
      "aria-label": t.state.phrase("close"),
      type: "button"
    }, [
      "\xD7"
    ]));
    function i() {
      let o = /^([+-])?(\d+)?(:\d+)?(%)?$/.exec(n.value);
      if (!o)
        return;
      let { state: s } = t, a = s.doc.lineAt(s.selection.main.head), [, l, c, u, h] = o, p = u ? +u.slice(1) : 0, v = c ? +c : a.number;
      if (c && h) {
        let T = v / 100;
        l && (T = T * (l == "-" ? -1 : 1) + a.number / s.doc.lines), v = Math.round(s.doc.lines * T);
      } else
        c && l && (v = v * (l == "-" ? -1 : 1) + a.number);
      let y = s.doc.line(Math.max(1, Math.min(s.doc.lines, v))), x = q.cursor(y.from + Math.max(0, Math.min(p, y.length)));
      t.dispatch({
        effects: [
          tu.of(false),
          ue.scrollIntoView(x.from, {
            y: "center"
          })
        ],
        selection: x
      }), t.focus();
    }
    return {
      dom: r
    };
  }
  const tu = Ee.define(), IT = Ut.define({
    create() {
      return true;
    },
    update(t, e) {
      for (let n of e.effects)
        n.is(tu) && (t = n.value);
      return t;
    },
    provide: (t) => Gs.from(t, (e) => e ? A1 : null)
  }), ZG = (t) => {
    let e = zu(t, A1);
    if (!e) {
      let n = [
        tu.of(true)
      ];
      t.state.field(IT, false) == null && n.push(Ee.appendConfig.of([
        IT,
        eY
      ])), t.dispatch({
        effects: n
      }), e = zu(t, A1);
    }
    return e && e.dom.querySelector("input").select(), true;
  }, eY = ue.baseTheme({
    ".cm-panel.cm-gotoLine": {
      padding: "2px 6px 4px",
      position: "relative",
      "& label": {
        fontSize: "80%"
      },
      "& [name=close]": {
        position: "absolute",
        top: "0",
        bottom: "0",
        right: "4px",
        backgroundColor: "inherit",
        border: "none",
        font: "inherit",
        padding: "0"
      }
    }
  }), tY = {
    highlightWordAroundCursor: false,
    minSelectionLength: 1,
    maxMatches: 100,
    wholeWords: false
  }, LL = me.define({
    combine(t) {
      return Oi(t, tY, {
        highlightWordAroundCursor: (e, n) => e || n,
        minSelectionLength: Math.min,
        maxMatches: Math.min
      });
    }
  });
  function nY(t) {
    let e = [
      aY,
      sY
    ];
    return t && e.push(LL.of(t)), e;
  }
  const rY = be.mark({
    class: "cm-selectionMatch"
  }), iY = be.mark({
    class: "cm-selectionMatch cm-selectionMatch-main"
  });
  function BT(t, e, n, r) {
    return (n == 0 || t(e.sliceDoc(n - 1, n)) != ht.Word) && (r == e.doc.length || t(e.sliceDoc(r, r + 1)) != ht.Word);
  }
  function oY(t, e, n, r) {
    return t(e.sliceDoc(n, n + 1)) == ht.Word && t(e.sliceDoc(r - 1, r)) == ht.Word;
  }
  const sY = Ct.fromClass(class {
    constructor(t) {
      this.decorations = this.getDeco(t);
    }
    update(t) {
      (t.selectionSet || t.docChanged || t.viewportChanged) && (this.decorations = this.getDeco(t.view));
    }
    getDeco(t) {
      let e = t.state.facet(LL), { state: n } = t, r = n.selection;
      if (r.ranges.length > 1)
        return be.none;
      let i = r.main, o, s = null;
      if (i.empty) {
        if (!e.highlightWordAroundCursor)
          return be.none;
        let l = n.wordAt(i.head);
        if (!l)
          return be.none;
        s = n.charCategorizer(i.head), o = n.sliceDoc(l.from, l.to);
      } else {
        let l = i.to - i.from;
        if (l < e.minSelectionLength || l > 200)
          return be.none;
        if (e.wholeWords) {
          if (o = n.sliceDoc(i.from, i.to), s = n.charCategorizer(i.head), !(BT(s, n, i.from, i.to) && oY(s, n, i.from, i.to)))
            return be.none;
        } else if (o = n.sliceDoc(i.from, i.to), !o)
          return be.none;
      }
      let a = [];
      for (let l of t.visibleRanges) {
        let c = new Sl(n.doc, o, l.from, l.to);
        for (; !c.next().done; ) {
          let { from: u, to: h } = c.value;
          if ((!s || BT(s, n, u, h)) && (i.empty && u <= i.from && h >= i.to ? a.push(iY.range(u, h)) : (u >= i.to || h <= i.from) && a.push(rY.range(u, h)), a.length > e.maxMatches))
            return be.none;
        }
      }
      return be.set(a);
    }
  }, {
    decorations: (t) => t.decorations
  }), aY = ue.baseTheme({
    ".cm-selectionMatch": {
      backgroundColor: "#99ff7780"
    },
    ".cm-searchMatch .cm-selectionMatch": {
      backgroundColor: "transparent"
    }
  }), lY = ({ state: t, dispatch: e }) => {
    let { selection: n } = t, r = q.create(n.ranges.map((i) => t.wordAt(i.head) || q.cursor(i.head)), n.mainIndex);
    return r.eq(n) ? false : (e(t.update({
      selection: r
    })), true);
  };
  function cY(t, e) {
    let { main: n, ranges: r } = t.selection, i = t.wordAt(n.head), o = i && i.from == n.from && i.to == n.to;
    for (let s = false, a = new Sl(t.doc, e, r[r.length - 1].to); ; )
      if (a.next(), a.done) {
        if (s)
          return null;
        a = new Sl(t.doc, e, 0, Math.max(0, r[r.length - 1].from - 1)), s = true;
      } else {
        if (s && r.some((l) => l.from == a.value.from))
          continue;
        if (o) {
          let l = t.wordAt(a.value.from);
          if (!l || l.from != a.value.from || l.to != a.value.to)
            continue;
        }
        return a.value;
      }
  }
  const uY = ({ state: t, dispatch: e }) => {
    let { ranges: n } = t.selection;
    if (n.some((o) => o.from === o.to))
      return lY({
        state: t,
        dispatch: e
      });
    let r = t.sliceDoc(n[0].from, n[0].to);
    if (t.selection.ranges.some((o) => t.sliceDoc(o.from, o.to) != r))
      return false;
    let i = cY(t, r);
    return i ? (e(t.update({
      selection: t.selection.addRange(q.range(i.from, i.to), false),
      effects: ue.scrollIntoView(i.to)
    })), true) : false;
  }, Rl = me.define({
    combine(t) {
      return Oi(t, {
        top: false,
        caseSensitive: false,
        literal: false,
        regexp: false,
        wholeWord: false,
        createPanel: (e) => new wY(e),
        scrollToMatch: (e) => ue.scrollIntoView(e)
      });
    }
  });
  class tS {
    constructor(e) {
      this.search = e.search, this.caseSensitive = !!e.caseSensitive, this.literal = !!e.literal, this.regexp = !!e.regexp, this.replace = e.replace || "", this.valid = !!this.search && (!this.regexp || JG(this.search)), this.unquoted = this.unquote(this.search), this.wholeWord = !!e.wholeWord;
    }
    unquote(e) {
      return this.literal ? e : e.replace(/\\([nrt\\])/g, (n, r) => r == "n" ? `
` : r == "r" ? "\r" : r == "t" ? "	" : "\\");
    }
    eq(e) {
      return this.search == e.search && this.replace == e.replace && this.caseSensitive == e.caseSensitive && this.regexp == e.regexp && this.wholeWord == e.wholeWord;
    }
    create() {
      return this.regexp ? new pY(this) : new hY(this);
    }
    getCursor(e, n = 0, r) {
      let i = e.doc ? e : Ne.create({
        doc: e
      });
      return r == null && (r = i.doc.length), this.regexp ? ha(this, i, n, r) : fa(this, i, n, r);
    }
  }
  class _L {
    constructor(e) {
      this.spec = e;
    }
  }
  function fa(t, e, n, r) {
    return new Sl(e.doc, t.unquoted, n, r, t.caseSensitive ? void 0 : (i) => i.toLowerCase(), t.wholeWord ? fY(e.doc, e.charCategorizer(e.selection.main.head)) : void 0);
  }
  function fY(t, e) {
    return (n, r, i, o) => ((o > n || o + i.length < r) && (o = Math.max(0, n - 2), i = t.sliceString(o, Math.min(t.length, r + 2))), (e(Bp(i, n - o)) != ht.Word || e(Np(i, n - o)) != ht.Word) && (e(Np(i, r - o)) != ht.Word || e(Bp(i, r - o)) != ht.Word));
  }
  class hY extends _L {
    constructor(e) {
      super(e);
    }
    nextMatch(e, n, r) {
      let i = fa(this.spec, e, r, e.doc.length).nextOverlapping();
      if (i.done) {
        let o = Math.min(e.doc.length, n + this.spec.unquoted.length);
        i = fa(this.spec, e, 0, o).nextOverlapping();
      }
      return i.done || i.value.from == n && i.value.to == r ? null : i.value;
    }
    prevMatchInRange(e, n, r) {
      for (let i = r; ; ) {
        let o = Math.max(n, i - 1e4 - this.spec.unquoted.length), s = fa(this.spec, e, o, i), a = null;
        for (; !s.nextOverlapping().done; )
          a = s.value;
        if (a)
          return a;
        if (o == n)
          return null;
        i -= 1e4;
      }
    }
    prevMatch(e, n, r) {
      let i = this.prevMatchInRange(e, 0, n);
      return i || (i = this.prevMatchInRange(e, Math.max(0, r - this.spec.unquoted.length), e.doc.length)), i && (i.from != n || i.to != r) ? i : null;
    }
    getReplacement(e) {
      return this.spec.unquote(this.spec.replace);
    }
    matchAll(e, n) {
      let r = fa(this.spec, e, 0, e.doc.length), i = [];
      for (; !r.next().done; ) {
        if (i.length >= n)
          return null;
        i.push(r.value);
      }
      return i;
    }
    highlight(e, n, r, i) {
      let o = fa(this.spec, e, Math.max(0, n - this.spec.unquoted.length), Math.min(r + this.spec.unquoted.length, e.doc.length));
      for (; !o.next().done; )
        i(o.value.from, o.value.to);
    }
  }
  function ha(t, e, n, r) {
    return new eS(e.doc, t.search, {
      ignoreCase: !t.caseSensitive,
      test: t.wholeWord ? dY(e.charCategorizer(e.selection.main.head)) : void 0
    }, n, r);
  }
  function Bp(t, e) {
    return t.slice(en(t, e, false), e);
  }
  function Np(t, e) {
    return t.slice(e, en(t, e));
  }
  function dY(t) {
    return (e, n, r) => !r[0].length || (t(Bp(r.input, r.index)) != ht.Word || t(Np(r.input, r.index)) != ht.Word) && (t(Np(r.input, r.index + r[0].length)) != ht.Word || t(Bp(r.input, r.index + r[0].length)) != ht.Word);
  }
  class pY extends _L {
    nextMatch(e, n, r) {
      let i = ha(this.spec, e, r, e.doc.length).next();
      return i.done && (i = ha(this.spec, e, 0, n).next()), i.done ? null : i.value;
    }
    prevMatchInRange(e, n, r) {
      for (let i = 1; ; i++) {
        let o = Math.max(n, r - i * 1e4), s = ha(this.spec, e, o, r), a = null;
        for (; !s.next().done; )
          a = s.value;
        if (a && (o == n || a.from > o + 10))
          return a;
        if (o == n)
          return null;
      }
    }
    prevMatch(e, n, r) {
      return this.prevMatchInRange(e, 0, n) || this.prevMatchInRange(e, r, e.doc.length);
    }
    getReplacement(e) {
      return this.spec.unquote(this.spec.replace).replace(/\$([$&]|\d+)/g, (n, r) => {
        if (r == "&")
          return e.match[0];
        if (r == "$")
          return "$";
        for (let i = r.length; i > 0; i--) {
          let o = +r.slice(0, i);
          if (o > 0 && o < e.match.length)
            return e.match[o] + r.slice(i);
        }
        return n;
      });
    }
    matchAll(e, n) {
      let r = ha(this.spec, e, 0, e.doc.length), i = [];
      for (; !r.next().done; ) {
        if (i.length >= n)
          return null;
        i.push(r.value);
      }
      return i;
    }
    highlight(e, n, r, i) {
      let o = ha(this.spec, e, Math.max(0, n - 250), Math.min(r + 250, e.doc.length));
      for (; !o.next().done; )
        i(o.value.from, o.value.to);
    }
  }
  const Jo = Ee.define(), nS = Ee.define(), Wo = Ut.define({
    create(t) {
      return new Q0(E1(t).create(), null);
    },
    update(t, e) {
      for (let n of e.effects)
        n.is(Jo) ? t = new Q0(n.value.create(), t.panel) : n.is(nS) && (t = new Q0(t.query, n.value ? rS : null));
      return t;
    },
    provide: (t) => Gs.from(t, (e) => e.panel)
  });
  class Q0 {
    constructor(e, n) {
      this.query = e, this.panel = n;
    }
  }
  const mY = be.mark({
    class: "cm-searchMatch"
  }), gY = be.mark({
    class: "cm-searchMatch cm-searchMatch-selected"
  }), vY = Ct.fromClass(class {
    constructor(t) {
      this.view = t, this.decorations = this.highlight(t.state.field(Wo));
    }
    update(t) {
      let e = t.state.field(Wo);
      (e != t.startState.field(Wo) || t.docChanged || t.selectionSet || t.viewportChanged) && (this.decorations = this.highlight(e));
    }
    highlight({ query: t, panel: e }) {
      if (!e || !t.spec.valid)
        return be.none;
      let { view: n } = this, r = new Mi();
      for (let i = 0, o = n.visibleRanges, s = o.length; i < s; i++) {
        let { from: a, to: l } = o[i];
        for (; i < s - 1 && l > o[i + 1].from - 2 * 250; )
          l = o[++i].to;
        t.highlight(n.state, a, l, (c, u) => {
          let h = n.state.selection.ranges.some((p) => p.from == c && p.to == u);
          r.add(c, u, h ? gY : mY);
        });
      }
      return r.finish();
    }
  }, {
    decorations: (t) => t.decorations
  });
  function mf(t) {
    return (e) => {
      let n = e.state.field(Wo, false);
      return n && n.query.spec.valid ? t(e, n) : BL(e);
    };
  }
  const $p = mf((t, { query: e }) => {
    let { to: n } = t.state.selection.main, r = e.nextMatch(t.state, n, n);
    if (!r)
      return false;
    let i = q.single(r.from, r.to), o = t.state.facet(Rl);
    return t.dispatch({
      selection: i,
      effects: [
        iS(t, r),
        o.scrollToMatch(i.main, t)
      ],
      userEvent: "select.search"
    }), IL(t), true;
  }), zp = mf((t, { query: e }) => {
    let { state: n } = t, { from: r } = n.selection.main, i = e.prevMatch(n, r, r);
    if (!i)
      return false;
    let o = q.single(i.from, i.to), s = t.state.facet(Rl);
    return t.dispatch({
      selection: o,
      effects: [
        iS(t, i),
        s.scrollToMatch(o.main, t)
      ],
      userEvent: "select.search"
    }), IL(t), true;
  }), yY = mf((t, { query: e }) => {
    let n = e.matchAll(t.state, 1e3);
    return !n || !n.length ? false : (t.dispatch({
      selection: q.create(n.map((r) => q.range(r.from, r.to))),
      userEvent: "select.search.matches"
    }), true);
  }), bY = ({ state: t, dispatch: e }) => {
    let n = t.selection;
    if (n.ranges.length > 1 || n.main.empty)
      return false;
    let { from: r, to: i } = n.main, o = [], s = 0;
    for (let a = new Sl(t.doc, t.sliceDoc(r, i)); !a.next().done; ) {
      if (o.length > 1e3)
        return false;
      a.value.from == r && (s = o.length), o.push(q.range(a.value.from, a.value.to));
    }
    return e(t.update({
      selection: q.create(o, s),
      userEvent: "select.search.matches"
    })), true;
  }, NT = mf((t, { query: e }) => {
    let { state: n } = t, { from: r, to: i } = n.selection.main;
    if (n.readOnly)
      return false;
    let o = e.nextMatch(n, r, r);
    if (!o)
      return false;
    let s = o, a = [], l, c, u = [];
    s.from == r && s.to == i && (c = n.toText(e.getReplacement(s)), a.push({
      from: s.from,
      to: s.to,
      insert: c
    }), s = e.nextMatch(n, s.from, s.to), u.push(ue.announce.of(n.phrase("replaced match on line $", n.doc.lineAt(r).number) + ".")));
    let h = t.state.changes(a);
    return s && (l = q.single(s.from, s.to).map(h), u.push(iS(t, s)), u.push(n.facet(Rl).scrollToMatch(l.main, t))), t.dispatch({
      changes: h,
      selection: l,
      effects: u,
      userEvent: "input.replace"
    }), true;
  }), xY = mf((t, { query: e }) => {
    if (t.state.readOnly)
      return false;
    let n = e.matchAll(t.state, 1e9).map((i) => {
      let { from: o, to: s } = i;
      return {
        from: o,
        to: s,
        insert: e.getReplacement(i)
      };
    });
    if (!n.length)
      return false;
    let r = t.state.phrase("replaced $ matches", n.length) + ".";
    return t.dispatch({
      changes: n,
      effects: ue.announce.of(r),
      userEvent: "input.replace.all"
    }), true;
  });
  function rS(t) {
    return t.state.facet(Rl).createPanel(t);
  }
  function E1(t, e) {
    var n, r, i, o, s;
    let a = t.selection.main, l = a.empty || a.to > a.from + 100 ? "" : t.sliceDoc(a.from, a.to);
    if (e && !l)
      return e;
    let c = t.facet(Rl);
    return new tS({
      search: ((n = e == null ? void 0 : e.literal) !== null && n !== void 0 ? n : c.literal) ? l : l.replace(/\n/g, "\\n"),
      caseSensitive: (r = e == null ? void 0 : e.caseSensitive) !== null && r !== void 0 ? r : c.caseSensitive,
      literal: (i = e == null ? void 0 : e.literal) !== null && i !== void 0 ? i : c.literal,
      regexp: (o = e == null ? void 0 : e.regexp) !== null && o !== void 0 ? o : c.regexp,
      wholeWord: (s = e == null ? void 0 : e.wholeWord) !== null && s !== void 0 ? s : c.wholeWord
    });
  }
  function DL(t) {
    let e = zu(t, rS);
    return e && e.dom.querySelector("[main-field]");
  }
  function IL(t) {
    let e = DL(t);
    e && e == t.root.activeElement && e.select();
  }
  const BL = (t) => {
    let e = t.state.field(Wo, false);
    if (e && e.panel) {
      let n = DL(t);
      if (n && n != t.root.activeElement) {
        let r = E1(t.state, e.query.spec);
        r.valid && t.dispatch({
          effects: Jo.of(r)
        }), n.focus(), n.select();
      }
    } else
      t.dispatch({
        effects: [
          nS.of(true),
          e ? Jo.of(E1(t.state, e.query.spec)) : Ee.appendConfig.of(CY)
        ]
      });
    return true;
  }, NL = (t) => {
    let e = t.state.field(Wo, false);
    if (!e || !e.panel)
      return false;
    let n = zu(t, rS);
    return n && n.dom.contains(t.root.activeElement) && t.focus(), t.dispatch({
      effects: nS.of(false)
    }), true;
  }, SY = [
    {
      key: "Mod-f",
      run: BL,
      scope: "editor search-panel"
    },
    {
      key: "F3",
      run: $p,
      shift: zp,
      scope: "editor search-panel",
      preventDefault: true
    },
    {
      key: "Mod-g",
      run: $p,
      shift: zp,
      scope: "editor search-panel",
      preventDefault: true
    },
    {
      key: "Escape",
      run: NL,
      scope: "editor search-panel"
    },
    {
      key: "Mod-Shift-l",
      run: bY
    },
    {
      key: "Mod-Alt-g",
      run: ZG
    },
    {
      key: "Mod-d",
      run: uY,
      preventDefault: true
    }
  ];
  class wY {
    constructor(e) {
      this.view = e;
      let n = this.query = e.state.field(Wo).query.spec;
      this.commit = this.commit.bind(this), this.searchField = Je("input", {
        value: n.search,
        placeholder: Hn(e, "Find"),
        "aria-label": Hn(e, "Find"),
        class: "cm-textfield",
        name: "search",
        form: "",
        "main-field": "true",
        onchange: this.commit,
        onkeyup: this.commit
      }), this.replaceField = Je("input", {
        value: n.replace,
        placeholder: Hn(e, "Replace"),
        "aria-label": Hn(e, "Replace"),
        class: "cm-textfield",
        name: "replace",
        form: "",
        onchange: this.commit,
        onkeyup: this.commit
      }), this.caseField = Je("input", {
        type: "checkbox",
        name: "case",
        form: "",
        checked: n.caseSensitive,
        onchange: this.commit
      }), this.reField = Je("input", {
        type: "checkbox",
        name: "re",
        form: "",
        checked: n.regexp,
        onchange: this.commit
      }), this.wordField = Je("input", {
        type: "checkbox",
        name: "word",
        form: "",
        checked: n.wholeWord,
        onchange: this.commit
      });
      function r(i, o, s) {
        return Je("button", {
          class: "cm-button",
          name: i,
          onclick: o,
          type: "button"
        }, s);
      }
      this.dom = Je("div", {
        onkeydown: (i) => this.keydown(i),
        class: "cm-search"
      }, [
        this.searchField,
        r("next", () => $p(e), [
          Hn(e, "next")
        ]),
        r("prev", () => zp(e), [
          Hn(e, "previous")
        ]),
        r("select", () => yY(e), [
          Hn(e, "all")
        ]),
        Je("label", null, [
          this.caseField,
          Hn(e, "match case")
        ]),
        Je("label", null, [
          this.reField,
          Hn(e, "regexp")
        ]),
        Je("label", null, [
          this.wordField,
          Hn(e, "by word")
        ]),
        ...e.state.readOnly ? [] : [
          Je("br"),
          this.replaceField,
          r("replace", () => NT(e), [
            Hn(e, "replace")
          ]),
          r("replaceAll", () => xY(e), [
            Hn(e, "replace all")
          ])
        ],
        Je("button", {
          name: "close",
          onclick: () => NL(e),
          "aria-label": Hn(e, "close"),
          type: "button"
        }, [
          "\xD7"
        ])
      ]);
    }
    commit() {
      let e = new tS({
        search: this.searchField.value,
        caseSensitive: this.caseField.checked,
        regexp: this.reField.checked,
        wholeWord: this.wordField.checked,
        replace: this.replaceField.value
      });
      e.eq(this.query) || (this.query = e, this.view.dispatch({
        effects: Jo.of(e)
      }));
    }
    keydown(e) {
      xs(this.view, e, "search-panel") ? e.preventDefault() : e.keyCode == 13 && e.target == this.searchField ? (e.preventDefault(), (e.shiftKey ? zp : $p)(this.view)) : e.keyCode == 13 && e.target == this.replaceField && (e.preventDefault(), NT(this.view));
    }
    update(e) {
      for (let n of e.transactions)
        for (let r of n.effects)
          r.is(Jo) && !r.value.eq(this.query) && this.setQuery(r.value);
    }
    setQuery(e) {
      this.query = e, this.searchField.value = e.search, this.replaceField.value = e.replace, this.caseField.checked = e.caseSensitive, this.reField.checked = e.regexp, this.wordField.checked = e.wholeWord;
    }
    mount() {
      this.searchField.select();
    }
    get pos() {
      return 80;
    }
    get top() {
      return this.view.state.facet(Rl).top;
    }
  }
  function Hn(t, e) {
    return t.state.phrase(e);
  }
  const Fh = 30, Vh = /[\s\.,:;?!]/;
  function iS(t, { from: e, to: n }) {
    let r = t.state.doc.lineAt(e), i = t.state.doc.lineAt(n).to, o = Math.max(r.from, e - Fh), s = Math.min(i, n + Fh), a = t.state.sliceDoc(o, s);
    if (o != r.from) {
      for (let l = 0; l < Fh; l++)
        if (!Vh.test(a[l + 1]) && Vh.test(a[l])) {
          a = a.slice(l);
          break;
        }
    }
    if (s != i) {
      for (let l = a.length - 1; l > a.length - Fh; l--)
        if (!Vh.test(a[l - 1]) && Vh.test(a[l])) {
          a = a.slice(0, l);
          break;
        }
    }
    return ue.announce.of(`${t.state.phrase("current match")}. ${a} ${t.state.phrase("on line")} ${r.number}.`);
  }
  const kY = ue.baseTheme({
    ".cm-panel.cm-search": {
      padding: "2px 6px 4px",
      position: "relative",
      "& [name=close]": {
        position: "absolute",
        top: "0",
        right: "4px",
        backgroundColor: "inherit",
        border: "none",
        font: "inherit",
        padding: 0,
        margin: 0
      },
      "& input, & button, & label": {
        margin: ".2em .6em .2em 0"
      },
      "& input[type=checkbox]": {
        marginRight: ".2em"
      },
      "& label": {
        fontSize: "80%",
        whiteSpace: "pre"
      }
    },
    "&light .cm-searchMatch": {
      backgroundColor: "#ffff0054"
    },
    "&dark .cm-searchMatch": {
      backgroundColor: "#00ffff8a"
    },
    "&light .cm-searchMatch-selected": {
      backgroundColor: "#ff6a0054"
    },
    "&dark .cm-searchMatch-selected": {
      backgroundColor: "#ff00ff8a"
    }
  }), CY = [
    Wo,
    ns.low(vY),
    kY
  ];
  class $L {
    constructor(e, n, r, i) {
      this.state = e, this.pos = n, this.explicit = r, this.view = i, this.abortListeners = [], this.abortOnDocChange = false;
    }
    tokenBefore(e) {
      let n = mn(this.state).resolveInner(this.pos, -1);
      for (; n && e.indexOf(n.name) < 0; )
        n = n.parent;
      return n ? {
        from: n.from,
        to: this.pos,
        text: this.state.sliceDoc(n.from, this.pos),
        type: n.type
      } : null;
    }
    matchBefore(e) {
      let n = this.state.doc.lineAt(this.pos), r = Math.max(n.from, this.pos - 250), i = n.text.slice(r - n.from, this.pos - n.from), o = i.search(zL(e, false));
      return o < 0 ? null : {
        from: r + o,
        to: this.pos,
        text: i.slice(o)
      };
    }
    get aborted() {
      return this.abortListeners == null;
    }
    addEventListener(e, n, r) {
      e == "abort" && this.abortListeners && (this.abortListeners.push(n), r && r.onDocChange && (this.abortOnDocChange = true));
    }
  }
  function $T(t) {
    let e = Object.keys(t).join(""), n = /\w/.test(e);
    return n && (e = e.replace(/\w/g, "")), `[${n ? "\\w" : ""}${e.replace(/[^\w\s]/g, "\\$&")}]`;
  }
  function TY(t) {
    let e = /* @__PURE__ */ Object.create(null), n = /* @__PURE__ */ Object.create(null);
    for (let { label: i } of t) {
      e[i[0]] = true;
      for (let o = 1; o < i.length; o++)
        n[i[o]] = true;
    }
    let r = $T(e) + $T(n) + "*$";
    return [
      new RegExp("^" + r),
      new RegExp(r)
    ];
  }
  function MY(t) {
    let e = t.map((i) => typeof i == "string" ? {
      label: i
    } : i), [n, r] = e.every((i) => /^\w+$/.test(i.label)) ? [
      /\w*$/,
      /\w+$/
    ] : TY(e);
    return (i) => {
      let o = i.matchBefore(r);
      return o || i.explicit ? {
        from: o ? o.from : i.pos,
        options: e,
        validFor: n
      } : null;
    };
  }
  class zT {
    constructor(e, n, r, i) {
      this.completion = e, this.source = n, this.match = r, this.score = i;
    }
  }
  function Ns(t) {
    return t.selection.main.from;
  }
  function zL(t, e) {
    var n;
    let { source: r } = t, i = e && r[0] != "^", o = r[r.length - 1] != "$";
    return !i && !o ? t : new RegExp(`${i ? "^" : ""}(?:${r})${o ? "$" : ""}`, (n = t.flags) !== null && n !== void 0 ? n : t.ignoreCase ? "i" : "");
  }
  const FL = Pi.define();
  function AY(t, e, n, r) {
    let { main: i } = t.selection, o = n - i.from, s = r - i.from;
    return {
      ...t.changeByRange((a) => {
        if (a != i && n != r && t.sliceDoc(a.from + o, a.from + s) != t.sliceDoc(n, r))
          return {
            range: a
          };
        let l = t.toText(e);
        return {
          changes: {
            from: a.from + o,
            to: r == i.from ? a.to : a.from + s,
            insert: l
          },
          range: q.cursor(a.from + o + l.length)
        };
      }),
      scrollIntoView: true,
      userEvent: "input.complete"
    };
  }
  const FT = /* @__PURE__ */ new WeakMap();
  function EY(t) {
    if (!Array.isArray(t))
      return t;
    let e = FT.get(t);
    return e || FT.set(t, e = MY(t)), e;
  }
  const Fp = Ee.define(), ju = Ee.define();
  class PY {
    constructor(e) {
      this.pattern = e, this.chars = [], this.folded = [], this.any = [], this.precise = [], this.byWord = [], this.score = 0, this.matched = [];
      for (let n = 0; n < e.length; ) {
        let r = Ln(e, n), i = mi(r);
        this.chars.push(r);
        let o = e.slice(n, n + i), s = o.toUpperCase();
        this.folded.push(Ln(s == o ? o.toLowerCase() : s, 0)), n += i;
      }
      this.astral = e.length != this.chars.length;
    }
    ret(e, n) {
      return this.score = e, this.matched = n, this;
    }
    match(e) {
      if (this.pattern.length == 0)
        return this.ret(-100, []);
      if (e.length < this.pattern.length)
        return null;
      let { chars: n, folded: r, any: i, precise: o, byWord: s } = this;
      if (n.length == 1) {
        let k = Ln(e, 0), C = mi(k), P = C == e.length ? 0 : -100;
        if (k != n[0])
          if (k == r[0])
            P += -200;
          else
            return null;
        return this.ret(P, [
          0,
          C
        ]);
      }
      let a = e.indexOf(this.pattern);
      if (a == 0)
        return this.ret(e.length == this.pattern.length ? 0 : -100, [
          0,
          this.pattern.length
        ]);
      let l = n.length, c = 0;
      if (a < 0) {
        for (let k = 0, C = Math.min(e.length, 200); k < C && c < l; ) {
          let P = Ln(e, k);
          (P == n[c] || P == r[c]) && (i[c++] = k), k += mi(P);
        }
        if (c < l)
          return null;
      }
      let u = 0, h = 0, p = false, v = 0, y = -1, x = -1, T = /[a-z]/.test(e), w = true;
      for (let k = 0, C = Math.min(e.length, 200), P = 0; k < C && h < l; ) {
        let R = Ln(e, k);
        a < 0 && (u < l && R == n[u] && (o[u++] = k), v < l && (R == n[v] || R == r[v] ? (v == 0 && (y = k), x = k + 1, v++) : v = 0));
        let L, _ = R < 255 ? R >= 48 && R <= 57 || R >= 97 && R <= 122 ? 2 : R >= 65 && R <= 90 ? 1 : 0 : (L = Cx(R)) != L.toLowerCase() ? 1 : L != L.toUpperCase() ? 2 : 0;
        (!k || _ == 1 && T || P == 0 && _ != 0) && (n[h] == R || r[h] == R && (p = true) ? s[h++] = k : s.length && (w = false)), P = _, k += mi(R);
      }
      return h == l && s[0] == 0 && w ? this.result(-100 + (p ? -200 : 0), s, e) : v == l && y == 0 ? this.ret(-200 - e.length + (x == e.length ? 0 : -100), [
        0,
        x
      ]) : a > -1 ? this.ret(-700 - e.length, [
        a,
        a + this.pattern.length
      ]) : v == l ? this.ret(-200 + -700 - e.length, [
        y,
        x
      ]) : h == l ? this.result(-100 + (p ? -200 : 0) + -700 + (w ? 0 : -1100), s, e) : n.length == 2 ? null : this.result((i[0] ? -700 : 0) + -200 + -1100, i, e);
    }
    result(e, n, r) {
      let i = [], o = 0;
      for (let s of n) {
        let a = s + (this.astral ? mi(Ln(r, s)) : 1);
        o && i[o - 1] == s ? i[o - 1] = a : (i[o++] = s, i[o++] = a);
      }
      return this.ret(e - r.length, i);
    }
  }
  class OY {
    constructor(e) {
      this.pattern = e, this.matched = [], this.score = 0, this.folded = e.toLowerCase();
    }
    match(e) {
      if (e.length < this.pattern.length)
        return null;
      let n = e.slice(0, this.pattern.length), r = n == this.pattern ? 0 : n.toLowerCase() == this.folded ? -200 : null;
      return r == null ? null : (this.matched = [
        0,
        n.length
      ], this.score = r + (e.length == this.pattern.length ? 0 : -100), this);
    }
  }
  const Ht = me.define({
    combine(t) {
      return Oi(t, {
        activateOnTyping: true,
        activateOnCompletion: () => false,
        activateOnTypingDelay: 100,
        selectOnOpen: true,
        override: null,
        closeOnBlur: true,
        maxRenderedOptions: 100,
        defaultKeymap: true,
        tooltipClass: () => "",
        optionClass: () => "",
        aboveCursor: false,
        icons: true,
        addToOptions: [],
        positionInfo: RY,
        filterStrict: false,
        compareCompletions: (e, n) => e.label.localeCompare(n.label),
        interactionDelay: 75,
        updateSyncTime: 100
      }, {
        defaultKeymap: (e, n) => e && n,
        closeOnBlur: (e, n) => e && n,
        icons: (e, n) => e && n,
        tooltipClass: (e, n) => (r) => VT(e(r), n(r)),
        optionClass: (e, n) => (r) => VT(e(r), n(r)),
        addToOptions: (e, n) => e.concat(n),
        filterStrict: (e, n) => e || n
      });
    }
  });
  function VT(t, e) {
    return t ? e ? t + " " + e : t : e;
  }
  function RY(t, e, n, r, i, o) {
    let s = t.textDirection == rt.RTL, a = s, l = false, c = "top", u, h, p = e.left - i.left, v = i.right - e.right, y = r.right - r.left, x = r.bottom - r.top;
    if (a && p < Math.min(y, v) ? a = false : !a && v < Math.min(y, p) && (a = true), y <= (a ? p : v))
      u = Math.max(i.top, Math.min(n.top, i.bottom - x)) - e.top, h = Math.min(400, a ? p : v);
    else {
      l = true, h = Math.min(400, (s ? e.right : i.right - e.left) - 30);
      let k = i.bottom - e.bottom;
      k >= x || k > e.top ? u = n.bottom - e.top : (c = "bottom", u = e.bottom - n.top);
    }
    let T = (e.bottom - e.top) / o.offsetHeight, w = (e.right - e.left) / o.offsetWidth;
    return {
      style: `${c}: ${u / T}px; max-width: ${h / w}px`,
      class: "cm-completionInfo-" + (l ? s ? "left-narrow" : "right-narrow" : a ? "left" : "right")
    };
  }
  function LY(t) {
    let e = t.addToOptions.slice();
    return t.icons && e.push({
      render(n) {
        let r = document.createElement("div");
        return r.classList.add("cm-completionIcon"), n.type && r.classList.add(...n.type.split(/\s+/g).map((i) => "cm-completionIcon-" + i)), r.setAttribute("aria-hidden", "true"), r;
      },
      position: 20
    }), e.push({
      render(n, r, i, o) {
        let s = document.createElement("span");
        s.className = "cm-completionLabel";
        let a = n.displayLabel || n.label, l = 0;
        for (let c = 0; c < o.length; ) {
          let u = o[c++], h = o[c++];
          u > l && s.appendChild(document.createTextNode(a.slice(l, u)));
          let p = s.appendChild(document.createElement("span"));
          p.appendChild(document.createTextNode(a.slice(u, h))), p.className = "cm-completionMatchedText", l = h;
        }
        return l < a.length && s.appendChild(document.createTextNode(a.slice(l))), s;
      },
      position: 50
    }, {
      render(n) {
        if (!n.detail)
          return null;
        let r = document.createElement("span");
        return r.className = "cm-completionDetail", r.textContent = n.detail, r;
      },
      position: 80
    }), e.sort((n, r) => n.position - r.position).map((n) => n.render);
  }
  function J0(t, e, n) {
    if (t <= n)
      return {
        from: 0,
        to: t
      };
    if (e < 0 && (e = 0), e <= t >> 1) {
      let i = Math.floor(e / n);
      return {
        from: i * n,
        to: (i + 1) * n
      };
    }
    let r = Math.floor((t - e) / n);
    return {
      from: t - (r + 1) * n,
      to: t - r * n
    };
  }
  class _Y {
    constructor(e, n, r) {
      this.view = e, this.stateField = n, this.applyCompletion = r, this.info = null, this.infoDestroy = null, this.placeInfoReq = {
        read: () => this.measureInfo(),
        write: (l) => this.placeInfo(l),
        key: this
      }, this.space = null, this.currentClass = "";
      let i = e.state.field(n), { options: o, selected: s } = i.open, a = e.state.facet(Ht);
      this.optionContent = LY(a), this.optionClass = a.optionClass, this.tooltipClass = a.tooltipClass, this.range = J0(o.length, s, a.maxRenderedOptions), this.dom = document.createElement("div"), this.dom.className = "cm-tooltip-autocomplete", this.updateTooltipClass(e.state), this.dom.addEventListener("mousedown", (l) => {
        let { options: c } = e.state.field(n).open;
        for (let u = l.target, h; u && u != this.dom; u = u.parentNode)
          if (u.nodeName == "LI" && (h = /-(\d+)$/.exec(u.id)) && +h[1] < c.length) {
            this.applyCompletion(e, c[+h[1]]), l.preventDefault();
            return;
          }
      }), this.dom.addEventListener("focusout", (l) => {
        let c = e.state.field(this.stateField, false);
        c && c.tooltip && e.state.facet(Ht).closeOnBlur && l.relatedTarget != e.contentDOM && e.dispatch({
          effects: ju.of(null)
        });
      }), this.showOptions(o, i.id);
    }
    mount() {
      this.updateSel();
    }
    showOptions(e, n) {
      this.list && this.list.remove(), this.list = this.dom.appendChild(this.createListBox(e, n, this.range)), this.list.addEventListener("scroll", () => {
        this.info && this.view.requestMeasure(this.placeInfoReq);
      });
    }
    update(e) {
      var n;
      let r = e.state.field(this.stateField), i = e.startState.field(this.stateField);
      if (this.updateTooltipClass(e.state), r != i) {
        let { options: o, selected: s, disabled: a } = r.open;
        (!i.open || i.open.options != o) && (this.range = J0(o.length, s, e.state.facet(Ht).maxRenderedOptions), this.showOptions(o, r.id)), this.updateSel(), a != ((n = i.open) === null || n === void 0 ? void 0 : n.disabled) && this.dom.classList.toggle("cm-tooltip-autocomplete-disabled", !!a);
      }
    }
    updateTooltipClass(e) {
      let n = this.tooltipClass(e);
      if (n != this.currentClass) {
        for (let r of this.currentClass.split(" "))
          r && this.dom.classList.remove(r);
        for (let r of n.split(" "))
          r && this.dom.classList.add(r);
        this.currentClass = n;
      }
    }
    positioned(e) {
      this.space = e, this.info && this.view.requestMeasure(this.placeInfoReq);
    }
    updateSel() {
      let e = this.view.state.field(this.stateField), n = e.open;
      (n.selected > -1 && n.selected < this.range.from || n.selected >= this.range.to) && (this.range = J0(n.options.length, n.selected, this.view.state.facet(Ht).maxRenderedOptions), this.showOptions(n.options, e.id));
      let r = this.updateSelectedOption(n.selected);
      if (r) {
        this.destroyInfo();
        let { completion: i } = n.options[n.selected], { info: o } = i;
        if (!o)
          return;
        let s = typeof o == "string" ? document.createTextNode(o) : o(i);
        if (!s)
          return;
        "then" in s ? s.then((a) => {
          a && this.view.state.field(this.stateField, false) == e && this.addInfoPane(a, i);
        }).catch((a) => Bn(this.view.state, a, "completion info")) : (this.addInfoPane(s, i), r.setAttribute("aria-describedby", this.info.id));
      }
    }
    addInfoPane(e, n) {
      this.destroyInfo();
      let r = this.info = document.createElement("div");
      if (r.className = "cm-tooltip cm-completionInfo", r.id = "cm-completionInfo-" + Math.floor(Math.random() * 65535).toString(16), e.nodeType != null)
        r.appendChild(e), this.infoDestroy = null;
      else {
        let { dom: i, destroy: o } = e;
        r.appendChild(i), this.infoDestroy = o || null;
      }
      this.dom.appendChild(r), this.view.requestMeasure(this.placeInfoReq);
    }
    updateSelectedOption(e) {
      let n = null;
      for (let r = this.list.firstChild, i = this.range.from; r; r = r.nextSibling, i++)
        r.nodeName != "LI" || !r.id ? i-- : i == e ? r.hasAttribute("aria-selected") || (r.setAttribute("aria-selected", "true"), n = r) : r.hasAttribute("aria-selected") && (r.removeAttribute("aria-selected"), r.removeAttribute("aria-describedby"));
      return n && IY(this.list, n), n;
    }
    measureInfo() {
      let e = this.dom.querySelector("[aria-selected]");
      if (!e || !this.info)
        return null;
      let n = this.dom.getBoundingClientRect(), r = this.info.getBoundingClientRect(), i = e.getBoundingClientRect(), o = this.space;
      if (!o) {
        let s = this.dom.ownerDocument.documentElement;
        o = {
          left: 0,
          top: 0,
          right: s.clientWidth,
          bottom: s.clientHeight
        };
      }
      return i.top > Math.min(o.bottom, n.bottom) - 10 || i.bottom < Math.max(o.top, n.top) + 10 ? null : this.view.state.facet(Ht).positionInfo(this.view, n, i, r, o, this.dom);
    }
    placeInfo(e) {
      this.info && (e ? (e.style && (this.info.style.cssText = e.style), this.info.className = "cm-tooltip cm-completionInfo " + (e.class || "")) : this.info.style.cssText = "top: -1e6px");
    }
    createListBox(e, n, r) {
      const i = document.createElement("ul");
      i.id = n, i.setAttribute("role", "listbox"), i.setAttribute("aria-expanded", "true"), i.setAttribute("aria-label", this.view.state.phrase("Completions")), i.addEventListener("mousedown", (s) => {
        s.target == i && s.preventDefault();
      });
      let o = null;
      for (let s = r.from; s < r.to; s++) {
        let { completion: a, match: l } = e[s], { section: c } = a;
        if (c) {
          let p = typeof c == "string" ? c : c.name;
          if (p != o && (s > r.from || r.from == 0))
            if (o = p, typeof c != "string" && c.header)
              i.appendChild(c.header(c));
            else {
              let v = i.appendChild(document.createElement("completion-section"));
              v.textContent = p;
            }
        }
        const u = i.appendChild(document.createElement("li"));
        u.id = n + "-" + s, u.setAttribute("role", "option");
        let h = this.optionClass(a);
        h && (u.className = h);
        for (let p of this.optionContent) {
          let v = p(a, this.view.state, this.view, l);
          v && u.appendChild(v);
        }
      }
      return r.from && i.classList.add("cm-completionListIncompleteTop"), r.to < e.length && i.classList.add("cm-completionListIncompleteBottom"), i;
    }
    destroyInfo() {
      this.info && (this.infoDestroy && this.infoDestroy(), this.info.remove(), this.info = null);
    }
    destroy() {
      this.destroyInfo();
    }
  }
  function DY(t, e) {
    return (n) => new _Y(n, t, e);
  }
  function IY(t, e) {
    let n = t.getBoundingClientRect(), r = e.getBoundingClientRect(), i = n.height / t.offsetHeight;
    r.top < n.top ? t.scrollTop -= (n.top - r.top) / i : r.bottom > n.bottom && (t.scrollTop += (r.bottom - n.bottom) / i);
  }
  function HT(t) {
    return (t.boost || 0) * 100 + (t.apply ? 10 : 0) + (t.info ? 5 : 0) + (t.type ? 1 : 0);
  }
  function BY(t, e) {
    let n = [], r = null, i = null, o = (u) => {
      n.push(u);
      let { section: h } = u.completion;
      if (h) {
        r || (r = []);
        let p = typeof h == "string" ? h : h.name;
        r.some((v) => v.name == p) || r.push(typeof h == "string" ? {
          name: p
        } : h);
      }
    }, s = e.facet(Ht);
    for (let u of t)
      if (u.hasResult()) {
        let h = u.result.getMatch;
        if (u.result.filter === false)
          for (let p of u.result.options)
            o(new zT(p, u.source, h ? h(p) : [], 1e9 - n.length));
        else {
          let p = e.sliceDoc(u.from, u.to), v, y = s.filterStrict ? new OY(p) : new PY(p);
          for (let x of u.result.options)
            if (v = y.match(x.label)) {
              let T = x.displayLabel ? h ? h(x, v.matched) : [] : v.matched, w = v.score + (x.boost || 0);
              if (o(new zT(x, u.source, T, w)), typeof x.section == "object" && x.section.rank === "dynamic") {
                let { name: k } = x.section;
                i || (i = /* @__PURE__ */ Object.create(null)), i[k] = Math.max(w, i[k] || -1e9);
              }
            }
        }
      }
    if (r) {
      let u = /* @__PURE__ */ Object.create(null), h = 0, p = (v, y) => (v.rank === "dynamic" && y.rank === "dynamic" ? i[y.name] - i[v.name] : 0) || (typeof v.rank == "number" ? v.rank : 1e9) - (typeof y.rank == "number" ? y.rank : 1e9) || (v.name < y.name ? -1 : 1);
      for (let v of r.sort(p))
        h -= 1e5, u[v.name] = h;
      for (let v of n) {
        let { section: y } = v.completion;
        y && (v.score += u[typeof y == "string" ? y : y.name]);
      }
    }
    let a = [], l = null, c = s.compareCompletions;
    for (let u of n.sort((h, p) => p.score - h.score || c(h.completion, p.completion))) {
      let h = u.completion;
      !l || l.label != h.label || l.detail != h.detail || l.type != null && h.type != null && l.type != h.type || l.apply != h.apply || l.boost != h.boost ? a.push(u) : HT(u.completion) > HT(l) && (a[a.length - 1] = u), l = u.completion;
    }
    return a;
  }
  class Ia {
    constructor(e, n, r, i, o, s) {
      this.options = e, this.attrs = n, this.tooltip = r, this.timestamp = i, this.selected = o, this.disabled = s;
    }
    setSelected(e, n) {
      return e == this.selected || e >= this.options.length ? this : new Ia(this.options, jT(n, e), this.tooltip, this.timestamp, e, this.disabled);
    }
    static build(e, n, r, i, o, s) {
      if (i && !s && e.some((c) => c.isPending))
        return i.setDisabled();
      let a = BY(e, n);
      if (!a.length)
        return i && e.some((c) => c.isPending) ? i.setDisabled() : null;
      let l = n.facet(Ht).selectOnOpen ? 0 : -1;
      if (i && i.selected != l && i.selected != -1) {
        let c = i.options[i.selected].completion;
        for (let u = 0; u < a.length; u++)
          if (a[u].completion == c) {
            l = u;
            break;
          }
      }
      return new Ia(a, jT(r, l), {
        pos: e.reduce((c, u) => u.hasResult() ? Math.min(c, u.from) : c, 1e8),
        create: HY,
        above: o.aboveCursor
      }, i ? i.timestamp : Date.now(), l, false);
    }
    map(e) {
      return new Ia(this.options, this.attrs, {
        ...this.tooltip,
        pos: e.mapPos(this.tooltip.pos)
      }, this.timestamp, this.selected, this.disabled);
    }
    setDisabled() {
      return new Ia(this.options, this.attrs, this.tooltip, this.timestamp, this.selected, true);
    }
  }
  class Vp {
    constructor(e, n, r) {
      this.active = e, this.id = n, this.open = r;
    }
    static start() {
      return new Vp(FY, "cm-ac-" + Math.floor(Math.random() * 2e6).toString(36), null);
    }
    update(e) {
      let { state: n } = e, r = n.facet(Ht), o = (r.override || n.languageDataAt("autocomplete", Ns(n)).map(EY)).map((l) => (this.active.find((u) => u.source == l) || new vr(l, this.active.some((u) => u.state != 0) ? 1 : 0)).update(e, r));
      o.length == this.active.length && o.every((l, c) => l == this.active[c]) && (o = this.active);
      let s = this.open, a = e.effects.some((l) => l.is(oS));
      s && e.docChanged && (s = s.map(e.changes)), e.selection || o.some((l) => l.hasResult() && e.changes.touchesRange(l.from, l.to)) || !NY(o, this.active) || a ? s = Ia.build(o, n, this.id, s, r, a) : s && s.disabled && !o.some((l) => l.isPending) && (s = null), !s && o.every((l) => !l.isPending) && o.some((l) => l.hasResult()) && (o = o.map((l) => l.hasResult() ? new vr(l.source, 0) : l));
      for (let l of e.effects)
        l.is(HL) && (s = s && s.setSelected(l.value, this.id));
      return o == this.active && s == this.open ? this : new Vp(o, this.id, s);
    }
    get tooltip() {
      return this.open ? this.open.tooltip : null;
    }
    get attrs() {
      return this.open ? this.open.attrs : this.active.length ? $Y : zY;
    }
  }
  function NY(t, e) {
    if (t == e)
      return true;
    for (let n = 0, r = 0; ; ) {
      for (; n < t.length && !t[n].hasResult(); )
        n++;
      for (; r < e.length && !e[r].hasResult(); )
        r++;
      let i = n == t.length, o = r == e.length;
      if (i || o)
        return i == o;
      if (t[n++].result != e[r++].result)
        return false;
    }
  }
  const $Y = {
    "aria-autocomplete": "list"
  }, zY = {};
  function jT(t, e) {
    let n = {
      "aria-autocomplete": "list",
      "aria-haspopup": "listbox",
      "aria-controls": t
    };
    return e > -1 && (n["aria-activedescendant"] = t + "-" + e), n;
  }
  const FY = [];
  function VL(t, e) {
    if (t.isUserEvent("input.complete")) {
      let r = t.annotation(FL);
      if (r && e.activateOnCompletion(r))
        return 12;
    }
    let n = t.isUserEvent("input.type");
    return n && e.activateOnTyping ? 5 : n ? 1 : t.isUserEvent("delete.backward") ? 2 : t.selection ? 8 : t.docChanged ? 16 : 0;
  }
  class vr {
    constructor(e, n, r = false) {
      this.source = e, this.state = n, this.explicit = r;
    }
    hasResult() {
      return false;
    }
    get isPending() {
      return this.state == 1;
    }
    update(e, n) {
      let r = VL(e, n), i = this;
      (r & 8 || r & 16 && this.touches(e)) && (i = new vr(i.source, 0)), r & 4 && i.state == 0 && (i = new vr(this.source, 1)), i = i.updateFor(e, r);
      for (let o of e.effects)
        if (o.is(Fp))
          i = new vr(i.source, 1, o.value);
        else if (o.is(ju))
          i = new vr(i.source, 0);
        else if (o.is(oS))
          for (let s of o.value)
            s.source == i.source && (i = s);
      return i;
    }
    updateFor(e, n) {
      return this.map(e.changes);
    }
    map(e) {
      return this;
    }
    touches(e) {
      return e.changes.touchesRange(Ns(e.state));
    }
  }
  class Za extends vr {
    constructor(e, n, r, i, o, s) {
      super(e, 3, n), this.limit = r, this.result = i, this.from = o, this.to = s;
    }
    hasResult() {
      return true;
    }
    updateFor(e, n) {
      var r;
      if (!(n & 3))
        return this.map(e.changes);
      let i = this.result;
      i.map && !e.changes.empty && (i = i.map(i, e.changes));
      let o = e.changes.mapPos(this.from), s = e.changes.mapPos(this.to, 1), a = Ns(e.state);
      if (a > s || !i || n & 2 && (Ns(e.startState) == this.from || a < this.limit))
        return new vr(this.source, n & 4 ? 1 : 0);
      let l = e.changes.mapPos(this.limit);
      return VY(i.validFor, e.state, o, s) ? new Za(this.source, this.explicit, l, i, o, s) : i.update && (i = i.update(i, o, s, new $L(e.state, a, false))) ? new Za(this.source, this.explicit, l, i, i.from, (r = i.to) !== null && r !== void 0 ? r : Ns(e.state)) : new vr(this.source, 1, this.explicit);
    }
    map(e) {
      return e.empty ? this : (this.result.map ? this.result.map(this.result, e) : this.result) ? new Za(this.source, this.explicit, e.mapPos(this.limit), this.result, e.mapPos(this.from), e.mapPos(this.to, 1)) : new vr(this.source, 0);
    }
    touches(e) {
      return e.changes.touchesRange(this.from, this.to);
    }
  }
  function VY(t, e, n, r) {
    if (!t)
      return false;
    let i = e.sliceDoc(n, r);
    return typeof t == "function" ? t(i, n, r, e) : zL(t, true).test(i);
  }
  const oS = Ee.define({
    map(t, e) {
      return t.map((n) => n.map(e));
    }
  }), HL = Ee.define(), _n = Ut.define({
    create() {
      return Vp.start();
    },
    update(t, e) {
      return t.update(e);
    },
    provide: (t) => [
      $x.from(t, (e) => e.tooltip),
      ue.contentAttributes.from(t, (e) => e.attrs)
    ]
  });
  function sS(t, e) {
    const n = e.completion.apply || e.completion.label;
    let r = t.state.field(_n).active.find((i) => i.source == e.source);
    return r instanceof Za ? (typeof n == "string" ? t.dispatch({
      ...AY(t.state, n, r.from, r.to),
      annotations: FL.of(e.completion)
    }) : n(t, e.completion, r.from, r.to), true) : false;
  }
  const HY = DY(_n, sS);
  function Hh(t, e = "option") {
    return (n) => {
      let r = n.state.field(_n, false);
      if (!r || !r.open || r.open.disabled || Date.now() - r.open.timestamp < n.state.facet(Ht).interactionDelay)
        return false;
      let i = 1, o;
      e == "page" && (o = PR(n, r.open.tooltip)) && (i = Math.max(2, Math.floor(o.dom.offsetHeight / o.dom.querySelector("li").offsetHeight) - 1));
      let { length: s } = r.open.options, a = r.open.selected > -1 ? r.open.selected + i * (t ? 1 : -1) : t ? 0 : s - 1;
      return a < 0 ? a = e == "page" ? 0 : s - 1 : a >= s && (a = e == "page" ? s - 1 : 0), n.dispatch({
        effects: HL.of(a)
      }), true;
    };
  }
  const jY = (t) => {
    let e = t.state.field(_n, false);
    return t.state.readOnly || !e || !e.open || e.open.selected < 0 || e.open.disabled || Date.now() - e.open.timestamp < t.state.facet(Ht).interactionDelay ? false : sS(t, e.open.options[e.open.selected]);
  }, Z0 = (t) => t.state.field(_n, false) ? (t.dispatch({
    effects: Fp.of(true)
  }), true) : false, WY = (t) => {
    let e = t.state.field(_n, false);
    return !e || !e.active.some((n) => n.state != 0) ? false : (t.dispatch({
      effects: ju.of(null)
    }), true);
  };
  class UY {
    constructor(e, n) {
      this.active = e, this.context = n, this.time = Date.now(), this.updates = [], this.done = void 0;
    }
  }
  const KY = 50, qY = 1e3, GY = Ct.fromClass(class {
    constructor(t) {
      this.view = t, this.debounceUpdate = -1, this.running = [], this.debounceAccept = -1, this.pendingStart = false, this.composing = 0;
      for (let e of t.state.field(_n).active)
        e.isPending && this.startQuery(e);
    }
    update(t) {
      let e = t.state.field(_n), n = t.state.facet(Ht);
      if (!t.selectionSet && !t.docChanged && t.startState.field(_n) == e)
        return;
      let r = t.transactions.some((o) => {
        let s = VL(o, n);
        return s & 8 || (o.selection || o.docChanged) && !(s & 3);
      });
      for (let o = 0; o < this.running.length; o++) {
        let s = this.running[o];
        if (r || s.context.abortOnDocChange && t.docChanged || s.updates.length + t.transactions.length > KY && Date.now() - s.time > qY) {
          for (let a of s.context.abortListeners)
            try {
              a();
            } catch (l) {
              Bn(this.view.state, l);
            }
          s.context.abortListeners = null, this.running.splice(o--, 1);
        } else
          s.updates.push(...t.transactions);
      }
      this.debounceUpdate > -1 && clearTimeout(this.debounceUpdate), t.transactions.some((o) => o.effects.some((s) => s.is(Fp))) && (this.pendingStart = true);
      let i = this.pendingStart ? 50 : n.activateOnTypingDelay;
      if (this.debounceUpdate = e.active.some((o) => o.isPending && !this.running.some((s) => s.active.source == o.source)) ? setTimeout(() => this.startUpdate(), i) : -1, this.composing != 0)
        for (let o of t.transactions)
          o.isUserEvent("input.type") ? this.composing = 2 : this.composing == 2 && o.selection && (this.composing = 3);
    }
    startUpdate() {
      this.debounceUpdate = -1, this.pendingStart = false;
      let { state: t } = this.view, e = t.field(_n);
      for (let n of e.active)
        n.isPending && !this.running.some((r) => r.active.source == n.source) && this.startQuery(n);
      this.running.length && e.open && e.open.disabled && (this.debounceAccept = setTimeout(() => this.accept(), this.view.state.facet(Ht).updateSyncTime));
    }
    startQuery(t) {
      let { state: e } = this.view, n = Ns(e), r = new $L(e, n, t.explicit, this.view), i = new UY(t, r);
      this.running.push(i), Promise.resolve(t.source(r)).then((o) => {
        i.context.aborted || (i.done = o || null, this.scheduleAccept());
      }, (o) => {
        this.view.dispatch({
          effects: ju.of(null)
        }), Bn(this.view.state, o);
      });
    }
    scheduleAccept() {
      this.running.every((t) => t.done !== void 0) ? this.accept() : this.debounceAccept < 0 && (this.debounceAccept = setTimeout(() => this.accept(), this.view.state.facet(Ht).updateSyncTime));
    }
    accept() {
      var t;
      this.debounceAccept > -1 && clearTimeout(this.debounceAccept), this.debounceAccept = -1;
      let e = [], n = this.view.state.facet(Ht), r = this.view.state.field(_n);
      for (let i = 0; i < this.running.length; i++) {
        let o = this.running[i];
        if (o.done === void 0)
          continue;
        if (this.running.splice(i--, 1), o.done) {
          let a = Ns(o.updates.length ? o.updates[0].startState : this.view.state), l = Math.min(a, o.done.from + (o.active.explicit ? 0 : 1)), c = new Za(o.active.source, o.active.explicit, l, o.done, o.done.from, (t = o.done.to) !== null && t !== void 0 ? t : a);
          for (let u of o.updates)
            c = c.update(u, n);
          if (c.hasResult()) {
            e.push(c);
            continue;
          }
        }
        let s = r.active.find((a) => a.source == o.active.source);
        if (s && s.isPending)
          if (o.done == null) {
            let a = new vr(o.active.source, 0);
            for (let l of o.updates)
              a = a.update(l, n);
            a.isPending || e.push(a);
          } else
            this.startQuery(s);
      }
      (e.length || r.open && r.open.disabled) && this.view.dispatch({
        effects: oS.of(e)
      });
    }
  }, {
    eventHandlers: {
      blur(t) {
        let e = this.view.state.field(_n, false);
        if (e && e.tooltip && this.view.state.facet(Ht).closeOnBlur) {
          let n = e.open && PR(this.view, e.open.tooltip);
          (!n || !n.dom.contains(t.relatedTarget)) && setTimeout(() => this.view.dispatch({
            effects: ju.of(null)
          }), 10);
        }
      },
      compositionstart() {
        this.composing = 1;
      },
      compositionend() {
        this.composing == 3 && setTimeout(() => this.view.dispatch({
          effects: Fp.of(false)
        }), 20), this.composing = 0;
      }
    }
  }), YY = typeof navigator == "object" && /Win/.test(navigator.platform), XY = ns.highest(ue.domEventHandlers({
    keydown(t, e) {
      let n = e.state.field(_n, false);
      if (!n || !n.open || n.open.disabled || n.open.selected < 0 || t.key.length > 1 || t.ctrlKey && !(YY && t.altKey) || t.metaKey)
        return false;
      let r = n.open.options[n.open.selected], i = n.active.find((s) => s.source == r.source), o = r.completion.commitCharacters || i.result.commitCharacters;
      return o && o.indexOf(t.key) > -1 && sS(e, r), false;
    }
  })), QY = ue.baseTheme({
    ".cm-tooltip.cm-tooltip-autocomplete": {
      "& > ul": {
        fontFamily: "monospace",
        whiteSpace: "nowrap",
        overflow: "hidden auto",
        maxWidth_fallback: "700px",
        maxWidth: "min(700px, 95vw)",
        minWidth: "250px",
        maxHeight: "10em",
        height: "100%",
        listStyle: "none",
        margin: 0,
        padding: 0,
        "& > li, & > completion-section": {
          padding: "1px 3px",
          lineHeight: 1.2
        },
        "& > li": {
          overflowX: "hidden",
          textOverflow: "ellipsis",
          cursor: "pointer"
        },
        "& > completion-section": {
          display: "list-item",
          borderBottom: "1px solid silver",
          paddingLeft: "0.5em",
          opacity: 0.7
        }
      }
    },
    "&light .cm-tooltip-autocomplete ul li[aria-selected]": {
      background: "#17c",
      color: "white"
    },
    "&light .cm-tooltip-autocomplete-disabled ul li[aria-selected]": {
      background: "#777"
    },
    "&dark .cm-tooltip-autocomplete ul li[aria-selected]": {
      background: "#347",
      color: "white"
    },
    "&dark .cm-tooltip-autocomplete-disabled ul li[aria-selected]": {
      background: "#444"
    },
    ".cm-completionListIncompleteTop:before, .cm-completionListIncompleteBottom:after": {
      content: '"\xB7\xB7\xB7"',
      opacity: 0.5,
      display: "block",
      textAlign: "center"
    },
    ".cm-tooltip.cm-completionInfo": {
      position: "absolute",
      padding: "3px 9px",
      width: "max-content",
      maxWidth: `${400}px`,
      boxSizing: "border-box",
      whiteSpace: "pre-line"
    },
    ".cm-completionInfo.cm-completionInfo-left": {
      right: "100%"
    },
    ".cm-completionInfo.cm-completionInfo-right": {
      left: "100%"
    },
    ".cm-completionInfo.cm-completionInfo-left-narrow": {
      right: `${30}px`
    },
    ".cm-completionInfo.cm-completionInfo-right-narrow": {
      left: `${30}px`
    },
    "&light .cm-snippetField": {
      backgroundColor: "#00000022"
    },
    "&dark .cm-snippetField": {
      backgroundColor: "#ffffff22"
    },
    ".cm-snippetFieldPosition": {
      verticalAlign: "text-top",
      width: 0,
      height: "1.15em",
      display: "inline-block",
      margin: "0 -0.7px -.7em",
      borderLeft: "1.4px dotted #888"
    },
    ".cm-completionMatchedText": {
      textDecoration: "underline"
    },
    ".cm-completionDetail": {
      marginLeft: "0.5em",
      fontStyle: "italic"
    },
    ".cm-completionIcon": {
      fontSize: "90%",
      width: ".8em",
      display: "inline-block",
      textAlign: "center",
      paddingRight: ".6em",
      opacity: "0.6",
      boxSizing: "content-box"
    },
    ".cm-completionIcon-function, .cm-completionIcon-method": {
      "&:after": {
        content: "'\u0192'"
      }
    },
    ".cm-completionIcon-class": {
      "&:after": {
        content: "'\u25CB'"
      }
    },
    ".cm-completionIcon-interface": {
      "&:after": {
        content: "'\u25CC'"
      }
    },
    ".cm-completionIcon-variable": {
      "&:after": {
        content: "'\u{1D465}'"
      }
    },
    ".cm-completionIcon-constant": {
      "&:after": {
        content: "'\u{1D436}'"
      }
    },
    ".cm-completionIcon-type": {
      "&:after": {
        content: "'\u{1D461}'"
      }
    },
    ".cm-completionIcon-enum": {
      "&:after": {
        content: "'\u222A'"
      }
    },
    ".cm-completionIcon-property": {
      "&:after": {
        content: "'\u25A1'"
      }
    },
    ".cm-completionIcon-keyword": {
      "&:after": {
        content: "'\u{1F511}\uFE0E'"
      }
    },
    ".cm-completionIcon-namespace": {
      "&:after": {
        content: "'\u25A2'"
      }
    },
    ".cm-completionIcon-text": {
      "&:after": {
        content: "'abc'",
        fontSize: "50%",
        verticalAlign: "middle"
      }
    }
  }), Wu = {
    brackets: [
      "(",
      "[",
      "{",
      "'",
      '"'
    ],
    before: ")]}:;>",
    stringPrefixes: []
  }, Os = Ee.define({
    map(t, e) {
      let n = e.mapPos(t, -1, Zt.TrackAfter);
      return n ?? void 0;
    }
  }), aS = new class extends Ws {
  }();
  aS.startSide = 1;
  aS.endSide = -1;
  const jL = Ut.define({
    create() {
      return Ve.empty;
    },
    update(t, e) {
      if (t = t.map(e.changes), e.selection) {
        let n = e.state.doc.lineAt(e.selection.main.head);
        t = t.update({
          filter: (r) => r >= n.from && r <= n.to
        });
      }
      for (let n of e.effects)
        n.is(Os) && (t = t.update({
          add: [
            aS.range(n.value, n.value + 1)
          ]
        }));
      return t;
    }
  });
  function JY() {
    return [
      eX,
      jL
    ];
  }
  const ev = "()[]{}<>\xAB\xBB\xBB\xAB\uFF3B\uFF3D\uFF5B\uFF5D";
  function WL(t) {
    for (let e = 0; e < ev.length; e += 2)
      if (ev.charCodeAt(e) == t)
        return ev.charAt(e + 1);
    return Cx(t < 128 ? t : t + 1);
  }
  function UL(t, e) {
    return t.languageDataAt("closeBrackets", e)[0] || Wu;
  }
  const ZY = typeof navigator == "object" && /Android\b/.test(navigator.userAgent), eX = ue.inputHandler.of((t, e, n, r) => {
    if ((ZY ? t.composing : t.compositionStarted) || t.state.readOnly)
      return false;
    let i = t.state.selection.main;
    if (r.length > 2 || r.length == 2 && mi(Ln(r, 0)) == 1 || e != i.from || n != i.to)
      return false;
    let o = rX(t.state, r);
    return o ? (t.dispatch(o), true) : false;
  }), tX = ({ state: t, dispatch: e }) => {
    if (t.readOnly)
      return false;
    let r = UL(t, t.selection.main.head).brackets || Wu.brackets, i = null, o = t.changeByRange((s) => {
      if (s.empty) {
        let a = iX(t.doc, s.head);
        for (let l of r)
          if (l == a && Ym(t.doc, s.head) == WL(Ln(l, 0)))
            return {
              changes: {
                from: s.head - l.length,
                to: s.head + l.length
              },
              range: q.cursor(s.head - l.length)
            };
      }
      return {
        range: i = s
      };
    });
    return i || e(t.update(o, {
      scrollIntoView: true,
      userEvent: "delete.backward"
    })), !i;
  }, nX = [
    {
      key: "Backspace",
      run: tX
    }
  ];
  function rX(t, e) {
    let n = UL(t, t.selection.main.head), r = n.brackets || Wu.brackets;
    for (let i of r) {
      let o = WL(Ln(i, 0));
      if (e == i)
        return o == i ? aX(t, i, r.indexOf(i + i + i) > -1, n) : oX(t, i, o, n.before || Wu.before);
      if (e == o && KL(t, t.selection.main.from))
        return sX(t, i, o);
    }
    return null;
  }
  function KL(t, e) {
    let n = false;
    return t.field(jL).between(0, t.doc.length, (r) => {
      r == e && (n = true);
    }), n;
  }
  function Ym(t, e) {
    let n = t.sliceString(e, e + 2);
    return n.slice(0, mi(Ln(n, 0)));
  }
  function iX(t, e) {
    let n = t.sliceString(e - 2, e);
    return mi(Ln(n, 0)) == n.length ? n : n.slice(1);
  }
  function oX(t, e, n, r) {
    let i = null, o = t.changeByRange((s) => {
      if (!s.empty)
        return {
          changes: [
            {
              insert: e,
              from: s.from
            },
            {
              insert: n,
              from: s.to
            }
          ],
          effects: Os.of(s.to + e.length),
          range: q.range(s.anchor + e.length, s.head + e.length)
        };
      let a = Ym(t.doc, s.head);
      return !a || /\s/.test(a) || r.indexOf(a) > -1 ? {
        changes: {
          insert: e + n,
          from: s.head
        },
        effects: Os.of(s.head + e.length),
        range: q.cursor(s.head + e.length)
      } : {
        range: i = s
      };
    });
    return i ? null : t.update(o, {
      scrollIntoView: true,
      userEvent: "input.type"
    });
  }
  function sX(t, e, n) {
    let r = null, i = t.changeByRange((o) => o.empty && Ym(t.doc, o.head) == n ? {
      changes: {
        from: o.head,
        to: o.head + n.length,
        insert: n
      },
      range: q.cursor(o.head + n.length)
    } : r = {
      range: o
    });
    return r ? null : t.update(i, {
      scrollIntoView: true,
      userEvent: "input.type"
    });
  }
  function aX(t, e, n, r) {
    let i = r.stringPrefixes || Wu.stringPrefixes, o = null, s = t.changeByRange((a) => {
      if (!a.empty)
        return {
          changes: [
            {
              insert: e,
              from: a.from
            },
            {
              insert: e,
              from: a.to
            }
          ],
          effects: Os.of(a.to + e.length),
          range: q.range(a.anchor + e.length, a.head + e.length)
        };
      let l = a.head, c = Ym(t.doc, l), u;
      if (c == e) {
        if (WT(t, l))
          return {
            changes: {
              insert: e + e,
              from: l
            },
            effects: Os.of(l + e.length),
            range: q.cursor(l + e.length)
          };
        if (KL(t, l)) {
          let p = n && t.sliceDoc(l, l + e.length * 3) == e + e + e ? e + e + e : e;
          return {
            changes: {
              from: l,
              to: l + p.length,
              insert: p
            },
            range: q.cursor(l + p.length)
          };
        }
      } else {
        if (n && t.sliceDoc(l - 2 * e.length, l) == e + e && (u = UT(t, l - 2 * e.length, i)) > -1 && WT(t, u))
          return {
            changes: {
              insert: e + e + e + e,
              from: l
            },
            effects: Os.of(l + e.length),
            range: q.cursor(l + e.length)
          };
        if (t.charCategorizer(l)(c) != ht.Word && UT(t, l, i) > -1 && !lX(t, l, e, i))
          return {
            changes: {
              insert: e + e,
              from: l
            },
            effects: Os.of(l + e.length),
            range: q.cursor(l + e.length)
          };
      }
      return {
        range: o = a
      };
    });
    return o ? null : t.update(s, {
      scrollIntoView: true,
      userEvent: "input.type"
    });
  }
  function WT(t, e) {
    let n = mn(t).resolveInner(e + 1);
    return n.parent && n.from == e;
  }
  function lX(t, e, n, r) {
    let i = mn(t).resolveInner(e, -1), o = r.reduce((s, a) => Math.max(s, a.length), 0);
    for (let s = 0; s < 5; s++) {
      let a = t.sliceDoc(i.from, Math.min(i.to, i.from + n.length + o)), l = a.indexOf(n);
      if (!l || l > -1 && r.indexOf(a.slice(0, l)) > -1) {
        let u = i.firstChild;
        for (; u && u.from == i.from && u.to - u.from > n.length + l; ) {
          if (t.sliceDoc(u.to - n.length, u.to) == n)
            return false;
          u = u.firstChild;
        }
        return true;
      }
      let c = i.to == e && i.parent;
      if (!c)
        break;
      i = c;
    }
    return false;
  }
  function UT(t, e, n) {
    let r = t.charCategorizer(e);
    if (r(t.sliceDoc(e - 1, e)) != ht.Word)
      return e;
    for (let i of n) {
      let o = e - i.length;
      if (t.sliceDoc(o, e) == i && r(t.sliceDoc(o - 1, o)) != ht.Word)
        return o;
    }
    return -1;
  }
  function cX(t = {}) {
    return [
      XY,
      _n,
      Ht.of(t),
      GY,
      uX,
      QY
    ];
  }
  const qL = [
    {
      key: "Ctrl-Space",
      run: Z0
    },
    {
      mac: "Alt-`",
      run: Z0
    },
    {
      mac: "Alt-i",
      run: Z0
    },
    {
      key: "Escape",
      run: WY
    },
    {
      key: "ArrowDown",
      run: Hh(true)
    },
    {
      key: "ArrowUp",
      run: Hh(false)
    },
    {
      key: "PageDown",
      run: Hh(true, "page")
    },
    {
      key: "PageUp",
      run: Hh(false, "page")
    },
    {
      key: "Enter",
      run: jY
    }
  ], uX = ns.highest(Vm.computeN([
    Ht
  ], (t) => t.facet(Ht).defaultKeymap ? [
    qL
  ] : []));
  class KT {
    constructor(e, n, r) {
      this.from = e, this.to = n, this.diagnostic = r;
    }
  }
  class ks {
    constructor(e, n, r) {
      this.diagnostics = e, this.panel = n, this.selected = r;
    }
    static init(e, n, r) {
      let i = r.facet(Uu).markerFilter;
      i && (e = i(e, r));
      let o = e.slice().sort((p, v) => p.from - v.from || p.to - v.to), s = new Mi(), a = [], l = 0, c = r.doc.iter(), u = 0;
      for (let p = 0; ; ) {
        let v = p == o.length ? null : o[p];
        if (!v && !a.length)
          break;
        let y, x;
        for (a.length ? (y = l, x = a.reduce((k, C) => Math.min(k, C.to), v && v.from > y ? v.from : 1e8)) : (y = v.from, x = v.to, a.push(v), p++); p < o.length; ) {
          let k = o[p];
          if (k.from == y && (k.to > k.from || k.to == y))
            a.push(k), p++, x = Math.min(k.to, x);
          else {
            x = Math.min(k.from, x);
            break;
          }
        }
        let T = false;
        if (a.some((k) => k.from == y && k.to == x) && (T = y == x, !T && x - y < 10)) {
          let k = y - (u + c.value.length);
          k > 0 && (c.next(k), u = y);
          for (let C = y; ; ) {
            if (C >= x) {
              T = true;
              break;
            }
            if (!c.lineBreak && u + c.value.length > C)
              break;
            C = u + c.value.length, u += c.value.length, c.next();
          }
        }
        let w = kX(a);
        if (T)
          s.add(y, y, be.widget({
            widget: new bX(w),
            diagnostics: a.slice()
          }));
        else {
          let k = a.reduce((C, P) => P.markClass ? C + " " + P.markClass : C, "");
          s.add(y, x, be.mark({
            class: "cm-lintRange cm-lintRange-" + w + k,
            diagnostics: a.slice(),
            inclusiveEnd: a.some((C) => C.to > x)
          }));
        }
        l = x;
        for (let k = 0; k < a.length; k++)
          a[k].to <= l && a.splice(k--, 1);
      }
      let h = s.finish();
      return new ks(h, n, wl(h));
    }
  }
  function wl(t, e = null, n = 0) {
    let r = null;
    return t.between(n, 1e9, (i, o, { spec: s }) => {
      if (!(e && s.diagnostics.indexOf(e) < 0))
        if (!r)
          r = new KT(i, o, e || s.diagnostics[0]);
        else {
          if (s.diagnostics.indexOf(r.diagnostic) < 0)
            return false;
          r = new KT(r.from, o, r.diagnostic);
        }
    }), r;
  }
  function fX(t, e) {
    let n = e.pos, r = e.end || n, i = t.state.facet(Uu).hideOn(t, n, r);
    if (i != null)
      return i;
    let o = t.startState.doc.lineAt(e.pos);
    return !!(t.effects.some((s) => s.is(GL)) || t.changes.touchesRange(o.from, Math.max(o.to, r)));
  }
  function hX(t, e) {
    return t.field(qn, false) ? e : e.concat(Ee.appendConfig.of(CX));
  }
  const GL = Ee.define(), lS = Ee.define(), YL = Ee.define(), qn = Ut.define({
    create() {
      return new ks(be.none, null, null);
    },
    update(t, e) {
      if (e.docChanged && t.diagnostics.size) {
        let n = t.diagnostics.map(e.changes), r = null, i = t.panel;
        if (t.selected) {
          let o = e.changes.mapPos(t.selected.from, 1);
          r = wl(n, t.selected.diagnostic, o) || wl(n, null, o);
        }
        !n.size && i && e.state.facet(Uu).autoPanel && (i = null), t = new ks(n, i, r);
      }
      for (let n of e.effects)
        if (n.is(GL)) {
          let r = e.state.facet(Uu).autoPanel ? n.value.length ? Ku.open : null : t.panel;
          t = ks.init(n.value, r, e.state);
        } else
          n.is(lS) ? t = new ks(t.diagnostics, n.value ? Ku.open : null, t.selected) : n.is(YL) && (t = new ks(t.diagnostics, t.panel, n.value));
      return t;
    },
    provide: (t) => [
      Gs.from(t, (e) => e.panel),
      ue.decorations.from(t, (e) => e.diagnostics)
    ]
  }), dX = be.mark({
    class: "cm-lintRange cm-lintRange-active"
  });
  function pX(t, e, n) {
    let { diagnostics: r } = t.state.field(qn), i, o = -1, s = -1;
    r.between(e - (n < 0 ? 1 : 0), e + (n > 0 ? 1 : 0), (l, c, { spec: u }) => {
      if (e >= l && e <= c && (l == c || (e > l || n > 0) && (e < c || n < 0)))
        return i = u.diagnostics, o = l, s = c, false;
    });
    let a = t.state.facet(Uu).tooltipFilter;
    return i && a && (i = a(i, t.state)), i ? {
      pos: o,
      end: s,
      above: t.state.doc.lineAt(o).to < s,
      create() {
        return {
          dom: mX(t, i)
        };
      }
    } : null;
  }
  function mX(t, e) {
    return Je("ul", {
      class: "cm-tooltip-lint"
    }, e.map((n) => QL(t, n, false)));
  }
  const gX = (t) => {
    let e = t.state.field(qn, false);
    (!e || !e.panel) && t.dispatch({
      effects: hX(t.state, [
        lS.of(true)
      ])
    });
    let n = zu(t, Ku.open);
    return n && n.dom.querySelector(".cm-panel-lint ul").focus(), true;
  }, qT = (t) => {
    let e = t.state.field(qn, false);
    return !e || !e.panel ? false : (t.dispatch({
      effects: lS.of(false)
    }), true);
  }, vX = (t) => {
    let e = t.state.field(qn, false);
    if (!e)
      return false;
    let n = t.state.selection.main, r = e.diagnostics.iter(n.to + 1);
    return !r.value && (r = e.diagnostics.iter(0), !r.value || r.from == n.from && r.to == n.to) ? false : (t.dispatch({
      selection: {
        anchor: r.from,
        head: r.to
      },
      scrollIntoView: true
    }), true);
  }, yX = [
    {
      key: "Mod-Shift-m",
      run: gX,
      preventDefault: true
    },
    {
      key: "F8",
      run: vX
    }
  ], Uu = me.define({
    combine(t) {
      return {
        sources: t.map((e) => e.source).filter((e) => e != null),
        ...Oi(t.map((e) => e.config), {
          delay: 750,
          markerFilter: null,
          tooltipFilter: null,
          needsRefresh: null,
          hideOn: () => null
        }, {
          delay: Math.max,
          markerFilter: GT,
          tooltipFilter: GT,
          needsRefresh: (e, n) => e ? n ? (r) => e(r) || n(r) : e : n,
          hideOn: (e, n) => e ? n ? (r, i, o) => e(r, i, o) || n(r, i, o) : e : n,
          autoPanel: (e, n) => e || n
        })
      };
    }
  });
  function GT(t, e) {
    return t ? e ? (n, r) => e(t(n, r), r) : t : e;
  }
  function XL(t) {
    let e = [];
    if (t)
      e:
        for (let { name: n } of t) {
          for (let r = 0; r < n.length; r++) {
            let i = n[r];
            if (/[a-zA-Z]/.test(i) && !e.some((o) => o.toLowerCase() == i.toLowerCase())) {
              e.push(i);
              continue e;
            }
          }
          e.push("");
        }
    return e;
  }
  function QL(t, e, n) {
    var r;
    let i = n ? XL(e.actions) : [];
    return Je("li", {
      class: "cm-diagnostic cm-diagnostic-" + e.severity
    }, Je("span", {
      class: "cm-diagnosticText"
    }, e.renderMessage ? e.renderMessage(t) : e.message), (r = e.actions) === null || r === void 0 ? void 0 : r.map((o, s) => {
      let a = false, l = (v) => {
        if (v.preventDefault(), a)
          return;
        a = true;
        let y = wl(t.state.field(qn).diagnostics, e);
        y && o.apply(t, y.from, y.to);
      }, { name: c } = o, u = i[s] ? c.indexOf(i[s]) : -1, h = u < 0 ? c : [
        c.slice(0, u),
        Je("u", c.slice(u, u + 1)),
        c.slice(u + 1)
      ], p = o.markClass ? " " + o.markClass : "";
      return Je("button", {
        type: "button",
        class: "cm-diagnosticAction" + p,
        onclick: l,
        onmousedown: l,
        "aria-label": ` Action: ${c}${u < 0 ? "" : ` (access key "${i[s]})"`}.`
      }, h);
    }), e.source && Je("div", {
      class: "cm-diagnosticSource"
    }, e.source));
  }
  class bX extends oo {
    constructor(e) {
      super(), this.sev = e;
    }
    eq(e) {
      return e.sev == this.sev;
    }
    toDOM() {
      return Je("span", {
        class: "cm-lintPoint cm-lintPoint-" + this.sev
      });
    }
  }
  class YT {
    constructor(e, n) {
      this.diagnostic = n, this.id = "item_" + Math.floor(Math.random() * 4294967295).toString(16), this.dom = QL(e, n, true), this.dom.id = this.id, this.dom.setAttribute("role", "option");
    }
  }
  class Ku {
    constructor(e) {
      this.view = e, this.items = [];
      let n = (i) => {
        if (i.keyCode == 27)
          qT(this.view), this.view.focus();
        else if (i.keyCode == 38 || i.keyCode == 33)
          this.moveSelection((this.selectedIndex - 1 + this.items.length) % this.items.length);
        else if (i.keyCode == 40 || i.keyCode == 34)
          this.moveSelection((this.selectedIndex + 1) % this.items.length);
        else if (i.keyCode == 36)
          this.moveSelection(0);
        else if (i.keyCode == 35)
          this.moveSelection(this.items.length - 1);
        else if (i.keyCode == 13)
          this.view.focus();
        else if (i.keyCode >= 65 && i.keyCode <= 90 && this.selectedIndex >= 0) {
          let { diagnostic: o } = this.items[this.selectedIndex], s = XL(o.actions);
          for (let a = 0; a < s.length; a++)
            if (s[a].toUpperCase().charCodeAt(0) == i.keyCode) {
              let l = wl(this.view.state.field(qn).diagnostics, o);
              l && o.actions[a].apply(e, l.from, l.to);
            }
        } else
          return;
        i.preventDefault();
      }, r = (i) => {
        for (let o = 0; o < this.items.length; o++)
          this.items[o].dom.contains(i.target) && this.moveSelection(o);
      };
      this.list = Je("ul", {
        tabIndex: 0,
        role: "listbox",
        "aria-label": this.view.state.phrase("Diagnostics"),
        onkeydown: n,
        onclick: r
      }), this.dom = Je("div", {
        class: "cm-panel-lint"
      }, this.list, Je("button", {
        type: "button",
        name: "close",
        "aria-label": this.view.state.phrase("close"),
        onclick: () => qT(this.view)
      }, "\xD7")), this.update();
    }
    get selectedIndex() {
      let e = this.view.state.field(qn).selected;
      if (!e)
        return -1;
      for (let n = 0; n < this.items.length; n++)
        if (this.items[n].diagnostic == e.diagnostic)
          return n;
      return -1;
    }
    update() {
      let { diagnostics: e, selected: n } = this.view.state.field(qn), r = 0, i = false, o = null, s = /* @__PURE__ */ new Set();
      for (e.between(0, this.view.state.doc.length, (a, l, { spec: c }) => {
        for (let u of c.diagnostics) {
          if (s.has(u))
            continue;
          s.add(u);
          let h = -1, p;
          for (let v = r; v < this.items.length; v++)
            if (this.items[v].diagnostic == u) {
              h = v;
              break;
            }
          h < 0 ? (p = new YT(this.view, u), this.items.splice(r, 0, p), i = true) : (p = this.items[h], h > r && (this.items.splice(r, h - r), i = true)), n && p.diagnostic == n.diagnostic ? p.dom.hasAttribute("aria-selected") || (p.dom.setAttribute("aria-selected", "true"), o = p) : p.dom.hasAttribute("aria-selected") && p.dom.removeAttribute("aria-selected"), r++;
        }
      }); r < this.items.length && !(this.items.length == 1 && this.items[0].diagnostic.from < 0); )
        i = true, this.items.pop();
      this.items.length == 0 && (this.items.push(new YT(this.view, {
        from: -1,
        to: -1,
        severity: "info",
        message: this.view.state.phrase("No diagnostics")
      })), i = true), o ? (this.list.setAttribute("aria-activedescendant", o.id), this.view.requestMeasure({
        key: this,
        read: () => ({
          sel: o.dom.getBoundingClientRect(),
          panel: this.list.getBoundingClientRect()
        }),
        write: ({ sel: a, panel: l }) => {
          let c = l.height / this.list.offsetHeight;
          a.top < l.top ? this.list.scrollTop -= (l.top - a.top) / c : a.bottom > l.bottom && (this.list.scrollTop += (a.bottom - l.bottom) / c);
        }
      })) : this.selectedIndex < 0 && this.list.removeAttribute("aria-activedescendant"), i && this.sync();
    }
    sync() {
      let e = this.list.firstChild;
      function n() {
        let r = e;
        e = r.nextSibling, r.remove();
      }
      for (let r of this.items)
        if (r.dom.parentNode == this.list) {
          for (; e != r.dom; )
            n();
          e = r.dom.nextSibling;
        } else
          this.list.insertBefore(r.dom, e);
      for (; e; )
        n();
    }
    moveSelection(e) {
      if (this.selectedIndex < 0)
        return;
      let n = this.view.state.field(qn), r = wl(n.diagnostics, this.items[e].diagnostic);
      !r || this.view.dispatch({
        selection: {
          anchor: r.from,
          head: r.to
        },
        scrollIntoView: true,
        effects: YL.of(r)
      });
    }
    static open(e) {
      return new Ku(e);
    }
  }
  function xX(t, e = 'viewBox="0 0 40 40"') {
    return `url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" ${e}>${encodeURIComponent(t)}</svg>')`;
  }
  function jh(t) {
    return xX(`<path d="m0 2.5 l2 -1.5 l1 0 l2 1.5 l1 0" stroke="${t}" fill="none" stroke-width=".7"/>`, 'width="6" height="3"');
  }
  const SX = ue.baseTheme({
    ".cm-diagnostic": {
      padding: "3px 6px 3px 8px",
      marginLeft: "-1px",
      display: "block",
      whiteSpace: "pre-wrap"
    },
    ".cm-diagnostic-error": {
      borderLeft: "5px solid #d11"
    },
    ".cm-diagnostic-warning": {
      borderLeft: "5px solid orange"
    },
    ".cm-diagnostic-info": {
      borderLeft: "5px solid #999"
    },
    ".cm-diagnostic-hint": {
      borderLeft: "5px solid #66d"
    },
    ".cm-diagnosticAction": {
      font: "inherit",
      border: "none",
      padding: "2px 4px",
      backgroundColor: "#444",
      color: "white",
      borderRadius: "3px",
      marginLeft: "8px",
      cursor: "pointer"
    },
    ".cm-diagnosticSource": {
      fontSize: "70%",
      opacity: 0.7
    },
    ".cm-lintRange": {
      backgroundPosition: "left bottom",
      backgroundRepeat: "repeat-x",
      paddingBottom: "0.7px"
    },
    ".cm-lintRange-error": {
      backgroundImage: jh("#d11")
    },
    ".cm-lintRange-warning": {
      backgroundImage: jh("orange")
    },
    ".cm-lintRange-info": {
      backgroundImage: jh("#999")
    },
    ".cm-lintRange-hint": {
      backgroundImage: jh("#66d")
    },
    ".cm-lintRange-active": {
      backgroundColor: "#ffdd9980"
    },
    ".cm-tooltip-lint": {
      padding: 0,
      margin: 0
    },
    ".cm-lintPoint": {
      position: "relative",
      "&:after": {
        content: '""',
        position: "absolute",
        bottom: 0,
        left: "-2px",
        borderLeft: "3px solid transparent",
        borderRight: "3px solid transparent",
        borderBottom: "4px solid #d11"
      }
    },
    ".cm-lintPoint-warning": {
      "&:after": {
        borderBottomColor: "orange"
      }
    },
    ".cm-lintPoint-info": {
      "&:after": {
        borderBottomColor: "#999"
      }
    },
    ".cm-lintPoint-hint": {
      "&:after": {
        borderBottomColor: "#66d"
      }
    },
    ".cm-panel.cm-panel-lint": {
      position: "relative",
      "& ul": {
        maxHeight: "100px",
        overflowY: "auto",
        "& [aria-selected]": {
          backgroundColor: "#ddd",
          "& u": {
            textDecoration: "underline"
          }
        },
        "&:focus [aria-selected]": {
          background_fallback: "#bdf",
          backgroundColor: "Highlight",
          color_fallback: "white",
          color: "HighlightText"
        },
        "& u": {
          textDecoration: "none"
        },
        padding: 0,
        margin: 0
      },
      "& [name=close]": {
        position: "absolute",
        top: "0",
        right: "2px",
        background: "inherit",
        border: "none",
        font: "inherit",
        padding: 0,
        margin: 0
      }
    }
  });
  function wX(t) {
    return t == "error" ? 4 : t == "warning" ? 3 : t == "info" ? 2 : 1;
  }
  function kX(t) {
    let e = "hint", n = 1;
    for (let r of t) {
      let i = wX(r.severity);
      i > n && (n = i, e = r.severity);
    }
    return e;
  }
  const CX = [
    qn,
    ue.decorations.compute([
      qn
    ], (t) => {
      let { selected: e, panel: n } = t.field(qn);
      return !e || !n || e.from == e.to ? be.none : be.set([
        dX.range(e.from, e.to)
      ]);
    }),
    vK(pX, {
      hideOn: fX
    }),
    SX
  ];
  var XT = function(e) {
    e === void 0 && (e = {});
    var { crosshairCursor: n = false } = e, r = [];
    e.closeBracketsKeymap !== false && (r = r.concat(nX)), e.defaultKeymap !== false && (r = r.concat(XG)), e.searchKeymap !== false && (r = r.concat(SY)), e.historyKeymap !== false && (r = r.concat(oG)), e.foldKeymap !== false && (r = r.concat(yq)), e.completionKeymap !== false && (r = r.concat(qL)), e.lintKeymap !== false && (r = r.concat(yX));
    var i = [];
    return e.lineNumbers !== false && i.push(EK()), e.highlightActiveLineGutter !== false && i.push(RK()), e.highlightSpecialChars !== false && i.push(KU()), e.history !== false && i.push(Xq()), e.foldGutter !== false && i.push(wq()), e.drawSelection !== false && i.push(DU()), e.dropCursor !== false && i.push(FU()), e.allowMultipleSelections !== false && i.push(Ne.allowMultipleSelections.of(true)), e.indentOnInput !== false && i.push(cq()), e.syntaxHighlighting !== false && i.push(YR(Mq, {
      fallback: true
    })), e.bracketMatching !== false && i.push(_q()), e.closeBrackets !== false && i.push(JY()), e.autocompletion !== false && i.push(cX()), e.rectangularSelection !== false && i.push(sK()), n !== false && i.push(cK()), e.highlightActiveLine !== false && i.push(JU()), e.highlightSelectionMatches !== false && i.push(nY()), e.tabSize && typeof e.tabSize == "number" && i.push(xl.of(" ".repeat(e.tabSize))), i.concat([
      Vm.of(r.flat())
    ]).filter(Boolean);
  };
  const TX = "#e5c07b", QT = "#e06c75", MX = "#56b6c2", AX = "#ffffff", Pd = "#abb2bf", P1 = "#7d8799", EX = "#61afef", PX = "#98c379", JT = "#d19a66", OX = "#c678dd", RX = "#21252b", ZT = "#2c313a", eM = "#282c34", tv = "#353a42", LX = "#3E4451", tM = "#528bff", _X = ue.theme({
    "&": {
      color: Pd,
      backgroundColor: eM
    },
    ".cm-content": {
      caretColor: tM
    },
    ".cm-cursor, .cm-dropCursor": {
      borderLeftColor: tM
    },
    "&.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground, .cm-selectionBackground, .cm-content ::selection": {
      backgroundColor: LX
    },
    ".cm-panels": {
      backgroundColor: RX,
      color: Pd
    },
    ".cm-panels.cm-panels-top": {
      borderBottom: "2px solid black"
    },
    ".cm-panels.cm-panels-bottom": {
      borderTop: "2px solid black"
    },
    ".cm-searchMatch": {
      backgroundColor: "#72a1ff59",
      outline: "1px solid #457dff"
    },
    ".cm-searchMatch.cm-searchMatch-selected": {
      backgroundColor: "#6199ff2f"
    },
    ".cm-activeLine": {
      backgroundColor: "#6699ff0b"
    },
    ".cm-selectionMatch": {
      backgroundColor: "#aafe661a"
    },
    "&.cm-focused .cm-matchingBracket, &.cm-focused .cm-nonmatchingBracket": {
      backgroundColor: "#bad0f847"
    },
    ".cm-gutters": {
      backgroundColor: eM,
      color: P1,
      border: "none"
    },
    ".cm-activeLineGutter": {
      backgroundColor: ZT
    },
    ".cm-foldPlaceholder": {
      backgroundColor: "transparent",
      border: "none",
      color: "#ddd"
    },
    ".cm-tooltip": {
      border: "none",
      backgroundColor: tv
    },
    ".cm-tooltip .cm-tooltip-arrow:before": {
      borderTopColor: "transparent",
      borderBottomColor: "transparent"
    },
    ".cm-tooltip .cm-tooltip-arrow:after": {
      borderTopColor: tv,
      borderBottomColor: tv
    },
    ".cm-tooltip-autocomplete": {
      "& > ul > li[aria-selected]": {
        backgroundColor: ZT,
        color: Pd
      }
    }
  }, {
    dark: true
  }), DX = df.define([
    {
      tag: G.keyword,
      color: OX
    },
    {
      tag: [
        G.name,
        G.deleted,
        G.character,
        G.propertyName,
        G.macroName
      ],
      color: QT
    },
    {
      tag: [
        G.function(G.variableName),
        G.labelName
      ],
      color: EX
    },
    {
      tag: [
        G.color,
        G.constant(G.name),
        G.standard(G.name)
      ],
      color: JT
    },
    {
      tag: [
        G.definition(G.name),
        G.separator
      ],
      color: Pd
    },
    {
      tag: [
        G.typeName,
        G.className,
        G.number,
        G.changed,
        G.annotation,
        G.modifier,
        G.self,
        G.namespace
      ],
      color: TX
    },
    {
      tag: [
        G.operator,
        G.operatorKeyword,
        G.url,
        G.escape,
        G.regexp,
        G.link,
        G.special(G.string)
      ],
      color: MX
    },
    {
      tag: [
        G.meta,
        G.comment
      ],
      color: P1
    },
    {
      tag: G.strong,
      fontWeight: "bold"
    },
    {
      tag: G.emphasis,
      fontStyle: "italic"
    },
    {
      tag: G.strikethrough,
      textDecoration: "line-through"
    },
    {
      tag: G.link,
      color: P1,
      textDecoration: "underline"
    },
    {
      tag: G.heading,
      fontWeight: "bold",
      color: QT
    },
    {
      tag: [
        G.atom,
        G.bool,
        G.special(G.variableName)
      ],
      color: JT
    },
    {
      tag: [
        G.processingInstruction,
        G.string,
        G.inserted
      ],
      color: PX
    },
    {
      tag: G.invalid,
      color: AX
    }
  ]), IX = [
    _X,
    YR(DX)
  ];
  var BX = ue.theme({
    "&": {
      backgroundColor: "#fff"
    }
  }, {
    dark: false
  }), NX = function(e) {
    e === void 0 && (e = {});
    var { indentWithTab: n = true, editable: r = true, readOnly: i = false, theme: o = "light", placeholder: s = "", basicSetup: a = true } = e, l = [];
    switch (n && l.unshift(Vm.of([
      QG
    ])), a && (typeof a == "boolean" ? l.unshift(XT()) : l.unshift(XT(a))), s && l.unshift(nK(s)), o) {
      case "light":
        l.push(BX);
        break;
      case "dark":
        l.push(IX);
        break;
      case "none":
        break;
      default:
        l.push(o);
        break;
    }
    return r === false && l.push(ue.editable.of(false)), i && l.push(Ne.readOnly.of(true)), [
      ...l
    ];
  }, $X = (t) => ({
    line: t.state.doc.lineAt(t.state.selection.main.from),
    lineCount: t.state.doc.lines,
    lineBreak: t.state.lineBreak,
    length: t.state.doc.length,
    readOnly: t.state.readOnly,
    tabSize: t.state.tabSize,
    selection: t.state.selection,
    selectionAsSingle: t.state.selection.asSingle().main,
    ranges: t.state.selection.ranges,
    selectionCode: t.state.sliceDoc(t.state.selection.main.from, t.state.selection.main.to),
    selections: t.state.selection.ranges.map((e) => t.state.sliceDoc(e.from, e.to)),
    selectedText: t.state.selection.ranges.some((e) => !e.empty)
  });
  class zX {
    constructor(e, n) {
      this.timeLeftMS = void 0, this.timeoutMS = void 0, this.isCancelled = false, this.isTimeExhausted = false, this.callbacks = [], this.timeLeftMS = n, this.timeoutMS = n, this.callbacks.push(e);
    }
    tick() {
      if (!this.isCancelled && !this.isTimeExhausted && (this.timeLeftMS--, this.timeLeftMS <= 0)) {
        this.isTimeExhausted = true;
        var e = this.callbacks.slice();
        this.callbacks.length = 0, e.forEach((n) => {
          try {
            n();
          } catch (r) {
            console.error("TimeoutLatch callback error:", r);
          }
        });
      }
    }
    cancel() {
      this.isCancelled = true, this.callbacks.length = 0;
    }
    reset() {
      this.timeLeftMS = this.timeoutMS, this.isCancelled = false, this.isTimeExhausted = false;
    }
    get isDone() {
      return this.isCancelled || this.isTimeExhausted;
    }
  }
  class nM {
    constructor() {
      this.interval = null, this.latches = /* @__PURE__ */ new Set();
    }
    add(e) {
      this.latches.add(e), this.start();
    }
    remove(e) {
      this.latches.delete(e), this.latches.size === 0 && this.stop();
    }
    start() {
      this.interval === null && (this.interval = setInterval(() => {
        this.latches.forEach((e) => {
          e.tick(), e.isDone && this.remove(e);
        });
      }, 1));
    }
    stop() {
      this.interval !== null && (clearInterval(this.interval), this.interval = null);
    }
  }
  var nv = null, FX = () => typeof window > "u" ? new nM() : (nv || (nv = new nM()), nv), rM = Pi.define(), VX = 200, HX = [];
  function jX(t) {
    var { value: e, selection: n, onChange: r, onStatistics: i, onCreateEditor: o, onUpdate: s, extensions: a = HX, autoFocus: l, theme: c = "light", height: u = null, minHeight: h = null, maxHeight: p = null, width: v = null, minWidth: y = null, maxWidth: x = null, placeholder: T = "", editable: w = true, readOnly: k = false, indentWithTab: C = true, basicSetup: P = true, root: R, initialState: L } = t, [_, F] = z.exports.useState(), [K, Y] = z.exports.useState(), [te, ne] = z.exports.useState(), ae = z.exports.useState(() => ({
      current: null
    }))[0], ye = z.exports.useState(() => ({
      current: null
    }))[0], Ce = ue.theme({
      "&": {
        height: u,
        minHeight: h,
        maxHeight: p,
        width: v,
        minWidth: y,
        maxWidth: x
      },
      "& .cm-scroller": {
        height: "100% !important"
      }
    }), Re = ue.updateListener.of((oe) => {
      if (oe.docChanged && typeof r == "function" && !oe.transactions.some((ve) => ve.annotation(rM))) {
        ae.current ? ae.current.reset() : (ae.current = new zX(() => {
          if (ye.current) {
            var ve = ye.current;
            ye.current = null, ve();
          }
          ae.current = null;
        }, VX), FX().add(ae.current));
        var de = oe.state.doc, Se = de.toString();
        r(Se, oe);
      }
      i && i($X(oe));
    }), ee = NX({
      theme: c,
      editable: w,
      readOnly: k,
      placeholder: T,
      indentWithTab: C,
      basicSetup: P
    }), V = [
      Re,
      Ce,
      ...ee
    ];
    return s && typeof s == "function" && V.push(ue.updateListener.of(s)), V = V.concat(a), z.exports.useLayoutEffect(() => {
      if (_ && !te) {
        var oe = {
          doc: e,
          selection: n,
          extensions: V
        }, de = L ? Ne.fromJSON(L.json, oe, L.fields) : Ne.create(oe);
        if (ne(de), !K) {
          var Se = new ue({
            state: de,
            parent: _,
            root: R
          });
          Y(Se), o && o(Se, de);
        }
      }
      return () => {
        K && (ne(void 0), Y(void 0));
      };
    }, [
      _,
      te
    ]), z.exports.useEffect(() => {
      t.container && F(t.container);
    }, [
      t.container
    ]), z.exports.useEffect(() => () => {
      K && (K.destroy(), Y(void 0)), ae.current && (ae.current.cancel(), ae.current = null);
    }, [
      K
    ]), z.exports.useEffect(() => {
      l && K && K.focus();
    }, [
      l,
      K
    ]), z.exports.useEffect(() => {
      K && K.dispatch({
        effects: Ee.reconfigure.of(V)
      });
    }, [
      c,
      a,
      u,
      h,
      p,
      v,
      y,
      x,
      T,
      w,
      k,
      C,
      P,
      r,
      s
    ]), z.exports.useEffect(() => {
      if (e !== void 0) {
        var oe = K ? K.state.doc.toString() : "";
        if (K && e !== oe) {
          var de = ae.current && !ae.current.isDone, Se = () => {
            K && e !== K.state.doc.toString() && K.dispatch({
              changes: {
                from: 0,
                to: K.state.doc.toString().length,
                insert: e || ""
              },
              annotations: [
                rM.of(true)
              ]
            });
          };
          de ? ye.current = Se : Se();
        }
      }
    }, [
      e,
      K
    ]), {
      state: te,
      setState: ne,
      view: K,
      setView: Y,
      container: _,
      setContainer: F
    };
  }
  var WX = [
    "className",
    "value",
    "selection",
    "extensions",
    "onChange",
    "onStatistics",
    "onCreateEditor",
    "onUpdate",
    "autoFocus",
    "theme",
    "height",
    "minHeight",
    "maxHeight",
    "width",
    "minWidth",
    "maxWidth",
    "basicSetup",
    "placeholder",
    "indentWithTab",
    "editable",
    "readOnly",
    "root",
    "initialState"
  ], JL = z.exports.forwardRef((t, e) => {
    var { className: n, value: r = "", selection: i, extensions: o = [], onChange: s, onStatistics: a, onCreateEditor: l, onUpdate: c, autoFocus: u, theme: h = "light", height: p, minHeight: v, maxHeight: y, width: x, minWidth: T, maxWidth: w, basicSetup: k, placeholder: C, indentWithTab: P, editable: R, readOnly: L, root: _, initialState: F } = t, K = gW(t, WX), Y = z.exports.useRef(null), { state: te, view: ne, container: ae, setContainer: ye } = jX({
      root: _,
      value: r,
      autoFocus: u,
      theme: h,
      height: p,
      minHeight: v,
      maxHeight: y,
      width: x,
      minWidth: T,
      maxWidth: w,
      basicSetup: k,
      placeholder: C,
      indentWithTab: P,
      editable: R,
      readOnly: L,
      selection: i,
      onChange: s,
      onStatistics: a,
      onCreateEditor: l,
      onUpdate: c,
      extensions: o,
      initialState: F
    });
    z.exports.useImperativeHandle(e, () => ({
      editor: Y.current,
      state: te,
      view: ne
    }), [
      Y,
      ae,
      te,
      ne
    ]);
    var Ce = z.exports.useCallback((ee) => {
      Y.current = ee, ye(ee);
    }, [
      ye
    ]);
    if (typeof r != "string")
      throw new Error("value must be typeof string but got " + typeof r);
    var Re = typeof h == "string" ? "cm-theme-" + h : "cm-theme";
    return J("div", Tu({
      ref: Ce,
      className: "" + Re + (n ? " " + n : "")
    }, K));
  });
  JL.displayName = "CodeMirror";
  function UX(t) {
    var e = t.Pos;
    function n(f, d, m) {
      if (d.line === m.line && d.ch >= m.ch - 1) {
        var g = f.getLine(d.line), b = g.charCodeAt(d.ch);
        55296 <= b && b <= 55551 && (m.ch += 1);
      }
      return {
        start: d,
        end: m
      };
    }
    var r = [
      {
        keys: "<Left>",
        type: "keyToKey",
        toKeys: "h"
      },
      {
        keys: "<Right>",
        type: "keyToKey",
        toKeys: "l"
      },
      {
        keys: "<Up>",
        type: "keyToKey",
        toKeys: "k"
      },
      {
        keys: "<Down>",
        type: "keyToKey",
        toKeys: "j"
      },
      {
        keys: "g<Up>",
        type: "keyToKey",
        toKeys: "gk"
      },
      {
        keys: "g<Down>",
        type: "keyToKey",
        toKeys: "gj"
      },
      {
        keys: "<Space>",
        type: "keyToKey",
        toKeys: "l"
      },
      {
        keys: "<BS>",
        type: "keyToKey",
        toKeys: "h"
      },
      {
        keys: "<Del>",
        type: "keyToKey",
        toKeys: "x"
      },
      {
        keys: "<C-Space>",
        type: "keyToKey",
        toKeys: "W"
      },
      {
        keys: "<C-BS>",
        type: "keyToKey",
        toKeys: "B"
      },
      {
        keys: "<S-Space>",
        type: "keyToKey",
        toKeys: "w"
      },
      {
        keys: "<S-BS>",
        type: "keyToKey",
        toKeys: "b"
      },
      {
        keys: "<C-n>",
        type: "keyToKey",
        toKeys: "j"
      },
      {
        keys: "<C-p>",
        type: "keyToKey",
        toKeys: "k"
      },
      {
        keys: "<C-[>",
        type: "keyToKey",
        toKeys: "<Esc>"
      },
      {
        keys: "<C-c>",
        type: "keyToKey",
        toKeys: "<Esc>"
      },
      {
        keys: "<C-[>",
        type: "keyToKey",
        toKeys: "<Esc>",
        context: "insert"
      },
      {
        keys: "<C-c>",
        type: "keyToKey",
        toKeys: "<Esc>",
        context: "insert"
      },
      {
        keys: "<C-Esc>",
        type: "keyToKey",
        toKeys: "<Esc>"
      },
      {
        keys: "<C-Esc>",
        type: "keyToKey",
        toKeys: "<Esc>",
        context: "insert"
      },
      {
        keys: "s",
        type: "keyToKey",
        toKeys: "cl",
        context: "normal"
      },
      {
        keys: "s",
        type: "keyToKey",
        toKeys: "c",
        context: "visual"
      },
      {
        keys: "S",
        type: "keyToKey",
        toKeys: "cc",
        context: "normal"
      },
      {
        keys: "S",
        type: "keyToKey",
        toKeys: "VdO",
        context: "visual"
      },
      {
        keys: "<Home>",
        type: "keyToKey",
        toKeys: "0"
      },
      {
        keys: "<End>",
        type: "keyToKey",
        toKeys: "$"
      },
      {
        keys: "<PageUp>",
        type: "keyToKey",
        toKeys: "<C-b>"
      },
      {
        keys: "<PageDown>",
        type: "keyToKey",
        toKeys: "<C-f>"
      },
      {
        keys: "<CR>",
        type: "keyToKey",
        toKeys: "j^",
        context: "normal"
      },
      {
        keys: "<Ins>",
        type: "keyToKey",
        toKeys: "i",
        context: "normal"
      },
      {
        keys: "<Ins>",
        type: "action",
        action: "toggleOverwrite",
        context: "insert"
      },
      {
        keys: "H",
        type: "motion",
        motion: "moveToTopLine",
        motionArgs: {
          linewise: true,
          toJumplist: true
        }
      },
      {
        keys: "M",
        type: "motion",
        motion: "moveToMiddleLine",
        motionArgs: {
          linewise: true,
          toJumplist: true
        }
      },
      {
        keys: "L",
        type: "motion",
        motion: "moveToBottomLine",
        motionArgs: {
          linewise: true,
          toJumplist: true
        }
      },
      {
        keys: "h",
        type: "motion",
        motion: "moveByCharacters",
        motionArgs: {
          forward: false
        }
      },
      {
        keys: "l",
        type: "motion",
        motion: "moveByCharacters",
        motionArgs: {
          forward: true
        }
      },
      {
        keys: "j",
        type: "motion",
        motion: "moveByLines",
        motionArgs: {
          forward: true,
          linewise: true
        }
      },
      {
        keys: "k",
        type: "motion",
        motion: "moveByLines",
        motionArgs: {
          forward: false,
          linewise: true
        }
      },
      {
        keys: "gj",
        type: "motion",
        motion: "moveByDisplayLines",
        motionArgs: {
          forward: true
        }
      },
      {
        keys: "gk",
        type: "motion",
        motion: "moveByDisplayLines",
        motionArgs: {
          forward: false
        }
      },
      {
        keys: "w",
        type: "motion",
        motion: "moveByWords",
        motionArgs: {
          forward: true,
          wordEnd: false
        }
      },
      {
        keys: "W",
        type: "motion",
        motion: "moveByWords",
        motionArgs: {
          forward: true,
          wordEnd: false,
          bigWord: true
        }
      },
      {
        keys: "e",
        type: "motion",
        motion: "moveByWords",
        motionArgs: {
          forward: true,
          wordEnd: true,
          inclusive: true
        }
      },
      {
        keys: "E",
        type: "motion",
        motion: "moveByWords",
        motionArgs: {
          forward: true,
          wordEnd: true,
          bigWord: true,
          inclusive: true
        }
      },
      {
        keys: "b",
        type: "motion",
        motion: "moveByWords",
        motionArgs: {
          forward: false,
          wordEnd: false
        }
      },
      {
        keys: "B",
        type: "motion",
        motion: "moveByWords",
        motionArgs: {
          forward: false,
          wordEnd: false,
          bigWord: true
        }
      },
      {
        keys: "ge",
        type: "motion",
        motion: "moveByWords",
        motionArgs: {
          forward: false,
          wordEnd: true,
          inclusive: true
        }
      },
      {
        keys: "gE",
        type: "motion",
        motion: "moveByWords",
        motionArgs: {
          forward: false,
          wordEnd: true,
          bigWord: true,
          inclusive: true
        }
      },
      {
        keys: "{",
        type: "motion",
        motion: "moveByParagraph",
        motionArgs: {
          forward: false,
          toJumplist: true
        }
      },
      {
        keys: "}",
        type: "motion",
        motion: "moveByParagraph",
        motionArgs: {
          forward: true,
          toJumplist: true
        }
      },
      {
        keys: "(",
        type: "motion",
        motion: "moveBySentence",
        motionArgs: {
          forward: false
        }
      },
      {
        keys: ")",
        type: "motion",
        motion: "moveBySentence",
        motionArgs: {
          forward: true
        }
      },
      {
        keys: "<C-f>",
        type: "motion",
        motion: "moveByPage",
        motionArgs: {
          forward: true
        }
      },
      {
        keys: "<C-b>",
        type: "motion",
        motion: "moveByPage",
        motionArgs: {
          forward: false
        }
      },
      {
        keys: "<C-d>",
        type: "motion",
        motion: "moveByScroll",
        motionArgs: {
          forward: true,
          explicitRepeat: true
        }
      },
      {
        keys: "<C-u>",
        type: "motion",
        motion: "moveByScroll",
        motionArgs: {
          forward: false,
          explicitRepeat: true
        }
      },
      {
        keys: "gg",
        type: "motion",
        motion: "moveToLineOrEdgeOfDocument",
        motionArgs: {
          forward: false,
          explicitRepeat: true,
          linewise: true,
          toJumplist: true
        }
      },
      {
        keys: "G",
        type: "motion",
        motion: "moveToLineOrEdgeOfDocument",
        motionArgs: {
          forward: true,
          explicitRepeat: true,
          linewise: true,
          toJumplist: true
        }
      },
      {
        keys: "g$",
        type: "motion",
        motion: "moveToEndOfDisplayLine"
      },
      {
        keys: "g^",
        type: "motion",
        motion: "moveToStartOfDisplayLine"
      },
      {
        keys: "g0",
        type: "motion",
        motion: "moveToStartOfDisplayLine"
      },
      {
        keys: "0",
        type: "motion",
        motion: "moveToStartOfLine"
      },
      {
        keys: "^",
        type: "motion",
        motion: "moveToFirstNonWhiteSpaceCharacter"
      },
      {
        keys: "+",
        type: "motion",
        motion: "moveByLines",
        motionArgs: {
          forward: true,
          toFirstChar: true
        }
      },
      {
        keys: "-",
        type: "motion",
        motion: "moveByLines",
        motionArgs: {
          forward: false,
          toFirstChar: true
        }
      },
      {
        keys: "_",
        type: "motion",
        motion: "moveByLines",
        motionArgs: {
          forward: true,
          toFirstChar: true,
          repeatOffset: -1
        }
      },
      {
        keys: "$",
        type: "motion",
        motion: "moveToEol",
        motionArgs: {
          inclusive: true
        }
      },
      {
        keys: "%",
        type: "motion",
        motion: "moveToMatchedSymbol",
        motionArgs: {
          inclusive: true,
          toJumplist: true
        }
      },
      {
        keys: "f<character>",
        type: "motion",
        motion: "moveToCharacter",
        motionArgs: {
          forward: true,
          inclusive: true
        }
      },
      {
        keys: "F<character>",
        type: "motion",
        motion: "moveToCharacter",
        motionArgs: {
          forward: false
        }
      },
      {
        keys: "t<character>",
        type: "motion",
        motion: "moveTillCharacter",
        motionArgs: {
          forward: true,
          inclusive: true
        }
      },
      {
        keys: "T<character>",
        type: "motion",
        motion: "moveTillCharacter",
        motionArgs: {
          forward: false
        }
      },
      {
        keys: ";",
        type: "motion",
        motion: "repeatLastCharacterSearch",
        motionArgs: {
          forward: true
        }
      },
      {
        keys: ",",
        type: "motion",
        motion: "repeatLastCharacterSearch",
        motionArgs: {
          forward: false
        }
      },
      {
        keys: "'<register>",
        type: "motion",
        motion: "goToMark",
        motionArgs: {
          toJumplist: true,
          linewise: true
        }
      },
      {
        keys: "`<register>",
        type: "motion",
        motion: "goToMark",
        motionArgs: {
          toJumplist: true
        }
      },
      {
        keys: "]`",
        type: "motion",
        motion: "jumpToMark",
        motionArgs: {
          forward: true
        }
      },
      {
        keys: "[`",
        type: "motion",
        motion: "jumpToMark",
        motionArgs: {
          forward: false
        }
      },
      {
        keys: "]'",
        type: "motion",
        motion: "jumpToMark",
        motionArgs: {
          forward: true,
          linewise: true
        }
      },
      {
        keys: "['",
        type: "motion",
        motion: "jumpToMark",
        motionArgs: {
          forward: false,
          linewise: true
        }
      },
      {
        keys: "]p",
        type: "action",
        action: "paste",
        isEdit: true,
        actionArgs: {
          after: true,
          isEdit: true,
          matchIndent: true
        }
      },
      {
        keys: "[p",
        type: "action",
        action: "paste",
        isEdit: true,
        actionArgs: {
          after: false,
          isEdit: true,
          matchIndent: true
        }
      },
      {
        keys: "]<character>",
        type: "motion",
        motion: "moveToSymbol",
        motionArgs: {
          forward: true,
          toJumplist: true
        }
      },
      {
        keys: "[<character>",
        type: "motion",
        motion: "moveToSymbol",
        motionArgs: {
          forward: false,
          toJumplist: true
        }
      },
      {
        keys: "|",
        type: "motion",
        motion: "moveToColumn"
      },
      {
        keys: "o",
        type: "motion",
        motion: "moveToOtherHighlightedEnd",
        context: "visual"
      },
      {
        keys: "O",
        type: "motion",
        motion: "moveToOtherHighlightedEnd",
        motionArgs: {
          sameLine: true
        },
        context: "visual"
      },
      {
        keys: "d",
        type: "operator",
        operator: "delete"
      },
      {
        keys: "y",
        type: "operator",
        operator: "yank"
      },
      {
        keys: "c",
        type: "operator",
        operator: "change"
      },
      {
        keys: "=",
        type: "operator",
        operator: "indentAuto"
      },
      {
        keys: ">",
        type: "operator",
        operator: "indent",
        operatorArgs: {
          indentRight: true
        }
      },
      {
        keys: "<",
        type: "operator",
        operator: "indent",
        operatorArgs: {
          indentRight: false
        }
      },
      {
        keys: "g~",
        type: "operator",
        operator: "changeCase"
      },
      {
        keys: "gu",
        type: "operator",
        operator: "changeCase",
        operatorArgs: {
          toLower: true
        },
        isEdit: true
      },
      {
        keys: "gU",
        type: "operator",
        operator: "changeCase",
        operatorArgs: {
          toLower: false
        },
        isEdit: true
      },
      {
        keys: "n",
        type: "motion",
        motion: "findNext",
        motionArgs: {
          forward: true,
          toJumplist: true
        }
      },
      {
        keys: "N",
        type: "motion",
        motion: "findNext",
        motionArgs: {
          forward: false,
          toJumplist: true
        }
      },
      {
        keys: "gn",
        type: "motion",
        motion: "findAndSelectNextInclusive",
        motionArgs: {
          forward: true
        }
      },
      {
        keys: "gN",
        type: "motion",
        motion: "findAndSelectNextInclusive",
        motionArgs: {
          forward: false
        }
      },
      {
        keys: "gq",
        type: "operator",
        operator: "hardWrap"
      },
      {
        keys: "gw",
        type: "operator",
        operator: "hardWrap",
        operatorArgs: {
          keepCursor: true
        }
      },
      {
        keys: "g?",
        type: "operator",
        operator: "rot13"
      },
      {
        keys: "x",
        type: "operatorMotion",
        operator: "delete",
        motion: "moveByCharacters",
        motionArgs: {
          forward: true
        },
        operatorMotionArgs: {
          visualLine: false
        }
      },
      {
        keys: "X",
        type: "operatorMotion",
        operator: "delete",
        motion: "moveByCharacters",
        motionArgs: {
          forward: false
        },
        operatorMotionArgs: {
          visualLine: true
        }
      },
      {
        keys: "D",
        type: "operatorMotion",
        operator: "delete",
        motion: "moveToEol",
        motionArgs: {
          inclusive: true
        },
        context: "normal"
      },
      {
        keys: "D",
        type: "operator",
        operator: "delete",
        operatorArgs: {
          linewise: true
        },
        context: "visual"
      },
      {
        keys: "Y",
        type: "operatorMotion",
        operator: "yank",
        motion: "expandToLine",
        motionArgs: {
          linewise: true
        },
        context: "normal"
      },
      {
        keys: "Y",
        type: "operator",
        operator: "yank",
        operatorArgs: {
          linewise: true
        },
        context: "visual"
      },
      {
        keys: "C",
        type: "operatorMotion",
        operator: "change",
        motion: "moveToEol",
        motionArgs: {
          inclusive: true
        },
        context: "normal"
      },
      {
        keys: "C",
        type: "operator",
        operator: "change",
        operatorArgs: {
          linewise: true
        },
        context: "visual"
      },
      {
        keys: "~",
        type: "operatorMotion",
        operator: "changeCase",
        motion: "moveByCharacters",
        motionArgs: {
          forward: true
        },
        operatorArgs: {
          shouldMoveCursor: true
        },
        context: "normal"
      },
      {
        keys: "~",
        type: "operator",
        operator: "changeCase",
        context: "visual"
      },
      {
        keys: "<C-u>",
        type: "operatorMotion",
        operator: "delete",
        motion: "moveToStartOfLine",
        context: "insert"
      },
      {
        keys: "<C-w>",
        type: "operatorMotion",
        operator: "delete",
        motion: "moveByWords",
        motionArgs: {
          forward: false,
          wordEnd: false
        },
        context: "insert"
      },
      {
        keys: "<C-w>",
        type: "idle",
        context: "normal"
      },
      {
        keys: "<C-i>",
        type: "action",
        action: "jumpListWalk",
        actionArgs: {
          forward: true
        }
      },
      {
        keys: "<C-o>",
        type: "action",
        action: "jumpListWalk",
        actionArgs: {
          forward: false
        }
      },
      {
        keys: "<C-e>",
        type: "action",
        action: "scroll",
        actionArgs: {
          forward: true,
          linewise: true
        }
      },
      {
        keys: "<C-y>",
        type: "action",
        action: "scroll",
        actionArgs: {
          forward: false,
          linewise: true
        }
      },
      {
        keys: "a",
        type: "action",
        action: "enterInsertMode",
        isEdit: true,
        actionArgs: {
          insertAt: "charAfter"
        },
        context: "normal"
      },
      {
        keys: "A",
        type: "action",
        action: "enterInsertMode",
        isEdit: true,
        actionArgs: {
          insertAt: "eol"
        },
        context: "normal"
      },
      {
        keys: "A",
        type: "action",
        action: "enterInsertMode",
        isEdit: true,
        actionArgs: {
          insertAt: "endOfSelectedArea"
        },
        context: "visual"
      },
      {
        keys: "i",
        type: "action",
        action: "enterInsertMode",
        isEdit: true,
        actionArgs: {
          insertAt: "inplace"
        },
        context: "normal"
      },
      {
        keys: "gi",
        type: "action",
        action: "enterInsertMode",
        isEdit: true,
        actionArgs: {
          insertAt: "lastEdit"
        },
        context: "normal"
      },
      {
        keys: "I",
        type: "action",
        action: "enterInsertMode",
        isEdit: true,
        actionArgs: {
          insertAt: "firstNonBlank"
        },
        context: "normal"
      },
      {
        keys: "gI",
        type: "action",
        action: "enterInsertMode",
        isEdit: true,
        actionArgs: {
          insertAt: "bol"
        },
        context: "normal"
      },
      {
        keys: "I",
        type: "action",
        action: "enterInsertMode",
        isEdit: true,
        actionArgs: {
          insertAt: "startOfSelectedArea"
        },
        context: "visual"
      },
      {
        keys: "o",
        type: "action",
        action: "newLineAndEnterInsertMode",
        isEdit: true,
        interlaceInsertRepeat: true,
        actionArgs: {
          after: true
        },
        context: "normal"
      },
      {
        keys: "O",
        type: "action",
        action: "newLineAndEnterInsertMode",
        isEdit: true,
        interlaceInsertRepeat: true,
        actionArgs: {
          after: false
        },
        context: "normal"
      },
      {
        keys: "v",
        type: "action",
        action: "toggleVisualMode"
      },
      {
        keys: "V",
        type: "action",
        action: "toggleVisualMode",
        actionArgs: {
          linewise: true
        }
      },
      {
        keys: "<C-v>",
        type: "action",
        action: "toggleVisualMode",
        actionArgs: {
          blockwise: true
        }
      },
      {
        keys: "<C-q>",
        type: "action",
        action: "toggleVisualMode",
        actionArgs: {
          blockwise: true
        }
      },
      {
        keys: "gv",
        type: "action",
        action: "reselectLastSelection"
      },
      {
        keys: "J",
        type: "action",
        action: "joinLines",
        isEdit: true
      },
      {
        keys: "gJ",
        type: "action",
        action: "joinLines",
        actionArgs: {
          keepSpaces: true
        },
        isEdit: true
      },
      {
        keys: "p",
        type: "action",
        action: "paste",
        isEdit: true,
        actionArgs: {
          after: true,
          isEdit: true
        }
      },
      {
        keys: "P",
        type: "action",
        action: "paste",
        isEdit: true,
        actionArgs: {
          after: false,
          isEdit: true
        }
      },
      {
        keys: "r<character>",
        type: "action",
        action: "replace",
        isEdit: true
      },
      {
        keys: "@<register>",
        type: "action",
        action: "replayMacro"
      },
      {
        keys: "q<register>",
        type: "action",
        action: "enterMacroRecordMode"
      },
      {
        keys: "R",
        type: "action",
        action: "enterInsertMode",
        isEdit: true,
        actionArgs: {
          replace: true
        },
        context: "normal"
      },
      {
        keys: "R",
        type: "operator",
        operator: "change",
        operatorArgs: {
          linewise: true,
          fullLine: true
        },
        context: "visual",
        exitVisualBlock: true
      },
      {
        keys: "u",
        type: "action",
        action: "undo",
        context: "normal"
      },
      {
        keys: "u",
        type: "operator",
        operator: "changeCase",
        operatorArgs: {
          toLower: true
        },
        context: "visual",
        isEdit: true
      },
      {
        keys: "U",
        type: "operator",
        operator: "changeCase",
        operatorArgs: {
          toLower: false
        },
        context: "visual",
        isEdit: true
      },
      {
        keys: "<C-r>",
        type: "action",
        action: "redo"
      },
      {
        keys: "m<register>",
        type: "action",
        action: "setMark"
      },
      {
        keys: '"<register>',
        type: "action",
        action: "setRegister"
      },
      {
        keys: "<C-r><register>",
        type: "action",
        action: "insertRegister",
        context: "insert",
        isEdit: true
      },
      {
        keys: "<C-o>",
        type: "action",
        action: "oneNormalCommand",
        context: "insert"
      },
      {
        keys: "zz",
        type: "action",
        action: "scrollToCursor",
        actionArgs: {
          position: "center"
        }
      },
      {
        keys: "z.",
        type: "action",
        action: "scrollToCursor",
        actionArgs: {
          position: "center"
        },
        motion: "moveToFirstNonWhiteSpaceCharacter"
      },
      {
        keys: "zt",
        type: "action",
        action: "scrollToCursor",
        actionArgs: {
          position: "top"
        }
      },
      {
        keys: "z<CR>",
        type: "action",
        action: "scrollToCursor",
        actionArgs: {
          position: "top"
        },
        motion: "moveToFirstNonWhiteSpaceCharacter"
      },
      {
        keys: "zb",
        type: "action",
        action: "scrollToCursor",
        actionArgs: {
          position: "bottom"
        }
      },
      {
        keys: "z-",
        type: "action",
        action: "scrollToCursor",
        actionArgs: {
          position: "bottom"
        },
        motion: "moveToFirstNonWhiteSpaceCharacter"
      },
      {
        keys: ".",
        type: "action",
        action: "repeatLastEdit"
      },
      {
        keys: "<C-a>",
        type: "action",
        action: "incrementNumberToken",
        isEdit: true,
        actionArgs: {
          increase: true,
          backtrack: false
        }
      },
      {
        keys: "<C-x>",
        type: "action",
        action: "incrementNumberToken",
        isEdit: true,
        actionArgs: {
          increase: false,
          backtrack: false
        }
      },
      {
        keys: "<C-t>",
        type: "action",
        action: "indent",
        actionArgs: {
          indentRight: true
        },
        context: "insert"
      },
      {
        keys: "<C-d>",
        type: "action",
        action: "indent",
        actionArgs: {
          indentRight: false
        },
        context: "insert"
      },
      {
        keys: "a<register>",
        type: "motion",
        motion: "textObjectManipulation"
      },
      {
        keys: "i<register>",
        type: "motion",
        motion: "textObjectManipulation",
        motionArgs: {
          textObjectInner: true
        }
      },
      {
        keys: "/",
        type: "search",
        searchArgs: {
          forward: true,
          querySrc: "prompt",
          toJumplist: true
        }
      },
      {
        keys: "?",
        type: "search",
        searchArgs: {
          forward: false,
          querySrc: "prompt",
          toJumplist: true
        }
      },
      {
        keys: "*",
        type: "search",
        searchArgs: {
          forward: true,
          querySrc: "wordUnderCursor",
          wholeWordOnly: true,
          toJumplist: true
        }
      },
      {
        keys: "#",
        type: "search",
        searchArgs: {
          forward: false,
          querySrc: "wordUnderCursor",
          wholeWordOnly: true,
          toJumplist: true
        }
      },
      {
        keys: "g*",
        type: "search",
        searchArgs: {
          forward: true,
          querySrc: "wordUnderCursor",
          toJumplist: true
        }
      },
      {
        keys: "g#",
        type: "search",
        searchArgs: {
          forward: false,
          querySrc: "wordUnderCursor",
          toJumplist: true
        }
      },
      {
        keys: ":",
        type: "ex"
      }
    ], i = /* @__PURE__ */ Object.create(null), o = r.length, s = [
      {
        name: "colorscheme",
        shortName: "colo"
      },
      {
        name: "map"
      },
      {
        name: "imap",
        shortName: "im"
      },
      {
        name: "nmap",
        shortName: "nm"
      },
      {
        name: "vmap",
        shortName: "vm"
      },
      {
        name: "omap",
        shortName: "om"
      },
      {
        name: "noremap",
        shortName: "no"
      },
      {
        name: "nnoremap",
        shortName: "nn"
      },
      {
        name: "vnoremap",
        shortName: "vn"
      },
      {
        name: "inoremap",
        shortName: "ino"
      },
      {
        name: "onoremap",
        shortName: "ono"
      },
      {
        name: "unmap"
      },
      {
        name: "mapclear",
        shortName: "mapc"
      },
      {
        name: "nmapclear",
        shortName: "nmapc"
      },
      {
        name: "vmapclear",
        shortName: "vmapc"
      },
      {
        name: "imapclear",
        shortName: "imapc"
      },
      {
        name: "omapclear",
        shortName: "omapc"
      },
      {
        name: "write",
        shortName: "w"
      },
      {
        name: "undo",
        shortName: "u"
      },
      {
        name: "redo",
        shortName: "red"
      },
      {
        name: "set",
        shortName: "se"
      },
      {
        name: "setlocal",
        shortName: "setl"
      },
      {
        name: "setglobal",
        shortName: "setg"
      },
      {
        name: "sort",
        shortName: "sor"
      },
      {
        name: "substitute",
        shortName: "s",
        possiblyAsync: true
      },
      {
        name: "startinsert",
        shortName: "start"
      },
      {
        name: "nohlsearch",
        shortName: "noh"
      },
      {
        name: "yank",
        shortName: "y"
      },
      {
        name: "delmarks",
        shortName: "delm"
      },
      {
        name: "marks",
        excludeFromCommandHistory: true
      },
      {
        name: "registers",
        shortName: "reg",
        excludeFromCommandHistory: true
      },
      {
        name: "vglobal",
        shortName: "v"
      },
      {
        name: "delete",
        shortName: "d"
      },
      {
        name: "join",
        shortName: "j"
      },
      {
        name: "normal",
        shortName: "norm"
      },
      {
        name: "global",
        shortName: "g"
      }
    ], a = gf("");
    function l(f) {
      f.setOption("disableInput", true), f.setOption("showCursorWhenSelecting", false), t.signal(f, "vim-mode-change", {
        mode: "normal"
      }), f.on("cursorActivity", Ff), ee(f), t.on(f.getInputField(), "paste", u(f));
    }
    function c(f) {
      f.setOption("disableInput", false), f.off("cursorActivity", Ff), t.off(f.getInputField(), "paste", u(f)), f.state.vim = null, us && clearTimeout(us);
    }
    function u(f) {
      var d = f.state.vim;
      return d.onPasteFn || (d.onPasteFn = function() {
        d.insertMode || (f.setCursor(dt(f.getCursor(), 0, 1)), lo.enterInsertMode(f, {}, d));
      }), d.onPasteFn;
    }
    var h = /[\d]/, p = [
      t.isWordChar,
      function(f) {
        return f && !t.isWordChar(f) && !/\s/.test(f);
      }
    ], v = [
      function(f) {
        return /\S/.test(f);
      }
    ], y = [
      "<",
      ">"
    ], x = [
      "-",
      '"',
      ".",
      ":",
      "_",
      "/",
      "+"
    ], T = /^\w$/, w = /^[A-Z]$/;
    try {
      w = new RegExp("^[\\p{Lu}]$", "u");
    } catch {
    }
    function k(f, d) {
      return d >= f.firstLine() && d <= f.lastLine();
    }
    function C(f) {
      return /^[a-z]$/.test(f);
    }
    function P(f) {
      return "()[]{}".indexOf(f) != -1;
    }
    function R(f) {
      return h.test(f);
    }
    function L(f) {
      return w.test(f);
    }
    function _(f) {
      return /^\s*$/.test(f);
    }
    function F(f) {
      return ".?!".indexOf(f) != -1;
    }
    function K(f, d) {
      for (var m = 0; m < d.length; m++)
        if (d[m] == f)
          return true;
      return false;
    }
    var Y = {};
    function te(f, d, m, g, b) {
      if (d === void 0 && !b)
        throw Error("defaultValue is required unless callback is provided");
      if (m || (m = "string"), Y[f] = {
        type: m,
        defaultValue: d,
        callback: b
      }, g)
        for (var S = 0; S < g.length; S++)
          Y[g[S]] = Y[f];
      d && ne(f, d);
    }
    function ne(f, d, m, g) {
      var b = Y[f];
      g = g || {};
      var S = g.scope;
      if (!b)
        return new Error("Unknown option: " + f);
      if (b.type == "boolean") {
        if (d && d !== true)
          return new Error("Invalid argument: " + f + "=" + d);
        d !== false && (d = true);
      }
      b.callback ? (S !== "local" && b.callback(d, void 0), S !== "global" && m && b.callback(d, m)) : (S !== "local" && (b.value = b.type == "boolean" ? !!d : d), S !== "global" && m && (m.state.vim.options[f] = {
        value: d
      }));
    }
    function ae(f, d, m) {
      var g = Y[f];
      m = m || {};
      var b = m.scope;
      if (!g)
        return new Error("Unknown option: " + f);
      if (g.callback) {
        let S = d && g.callback(void 0, d);
        return b !== "global" && S !== void 0 ? S : b !== "local" ? g.callback() : void 0;
      } else
        return (b !== "global" && d && d.state.vim.options[f] || b !== "local" && g || {}).value;
    }
    te("filetype", void 0, "string", [
      "ft"
    ], function(f, d) {
      if (d !== void 0)
        if (f === void 0) {
          let m = d.getOption("mode");
          return m == "null" ? "" : m;
        } else {
          let m = f == "" ? "null" : f;
          d.setOption("mode", m);
        }
    }), te("textwidth", 80, "number", [
      "tw"
    ], function(f, d) {
      if (d !== void 0)
        if (f === void 0) {
          var m = d.getOption("textwidth");
          return m;
        } else {
          var g = Math.round(f);
          g > 1 && d.setOption("textwidth", g);
        }
    });
    var ye = function() {
      var f = 100, d = -1, m = 0, g = 0, b = new Array(f);
      function S(E, I, D) {
        var H = d % f, j = b[H];
        function W(X) {
          var Q = ++d % f, xe = b[Q];
          xe && xe.clear(), b[Q] = E.setBookmark(X);
        }
        if (j) {
          var $ = j.find();
          $ && !Kt($, I) && W(I);
        } else
          W(I);
        W(D), m = d, g = d - f + 1, g < 0 && (g = 0);
      }
      function M(E, I) {
        d += I, d > m ? d = m : d < g && (d = g);
        var D = b[(f + d) % f];
        if (D && !D.find()) {
          var H = I > 0 ? 1 : -1, j, W = E.getCursor();
          do
            if (d += H, D = b[(f + d) % f], D && (j = D.find()) && !Kt(W, j))
              break;
          while (d < m && d > g);
        }
        return D;
      }
      function A(E, I) {
        var D = d, H = M(E, I);
        return d = D, H && H.find();
      }
      return {
        cachedCursor: void 0,
        add: S,
        find: A,
        move: M
      };
    }, Ce = function(f) {
      return f ? {
        changes: f.changes,
        expectCursorActivityForChange: f.expectCursorActivityForChange
      } : {
        changes: [],
        expectCursorActivityForChange: false
      };
    };
    class Re {
      constructor() {
        this.latestRegister = void 0, this.isPlaying = false, this.isRecording = false, this.replaySearchQueries = [], this.onRecordingDone = void 0, this.lastInsertModeChanges = Ce();
      }
      exitMacroRecordMode() {
        var d = V.macroModeState;
        d.onRecordingDone && d.onRecordingDone(), d.onRecordingDone = void 0, d.isRecording = false;
      }
      enterMacroRecordMode(d, m) {
        var g = V.registerController.getRegister(m);
        if (g) {
          if (g.clear(), this.latestRegister = m, d.openDialog) {
            var b = on("span", {
              class: "cm-vim-message"
            }, "recording @" + m);
            this.onRecordingDone = d.openDialog(b, function() {
            }, {
              bottom: true
            });
          }
          this.isRecording = true;
        }
      }
    }
    function ee(f) {
      return f.state.vim || (f.state.vim = {
        inputState: new vf(),
        lastEditInputState: void 0,
        lastEditActionCommand: void 0,
        lastHPos: -1,
        lastHSPos: -1,
        lastMotion: null,
        marks: {},
        insertMode: false,
        insertModeReturn: false,
        insertModeRepeat: void 0,
        visualMode: false,
        visualLine: false,
        visualBlock: false,
        lastSelection: null,
        lastPastedText: void 0,
        sel: {
          anchor: new e(0, 0),
          head: new e(0, 0)
        },
        options: {},
        expectLiteralNext: false,
        status: ""
      }), f.state.vim;
    }
    var V;
    function oe() {
      V = {
        searchQuery: null,
        searchIsReversed: false,
        lastSubstituteReplacePart: void 0,
        jumpList: ye(),
        macroModeState: new Re(),
        lastCharacterSearch: {
          increment: 0,
          forward: true,
          selectedCharacter: ""
        },
        registerController: new Jm({}),
        searchHistoryController: new os(),
        exCommandHistoryController: new os()
      };
      for (var f in Y) {
        var d = Y[f];
        d.value = d.defaultValue;
      }
    }
    class de {
      constructor(d, m) {
        this.keyName = d, this.key = m.key, this.ctrlKey = m.ctrlKey, this.altKey = m.altKey, this.metaKey = m.metaKey, this.shiftKey = m.shiftKey;
      }
    }
    var Se, ve = {
      enterVimMode: l,
      leaveVimMode: c,
      buildKeyMap: function() {
      },
      getRegisterController: function() {
        return V.registerController;
      },
      resetVimGlobalState_: oe,
      getVimGlobalState_: function() {
        return V;
      },
      maybeInitVimState_: ee,
      suppressErrorLogging: false,
      InsertModeKey: de,
      map: function(f, d, m) {
        Ft.map(f, d, m);
      },
      unmap: function(f, d) {
        return Ft.unmap(f, d);
      },
      noremap: function(f, d, m) {
        Ft.map(f, d, m, true);
      },
      mapclear: function(f) {
        var d = r.length, m = o, g = r.slice(0, d - m);
        if (r = r.slice(d - m), f)
          for (var b = g.length - 1; b >= 0; b--) {
            var S = g[b];
            if (f !== S.context)
              if (S.context)
                this._mapCommand(S);
              else {
                var M = [
                  "normal",
                  "insert",
                  "visual"
                ];
                for (var A in M)
                  if (M[A] !== f) {
                    var E = Object.assign({}, S);
                    E.context = M[A], this._mapCommand(E);
                  }
              }
          }
      },
      langmap: Ll,
      vimKeyFromEvent: ao,
      setOption: ne,
      getOption: ae,
      defineOption: te,
      defineEx: function(f, d, m) {
        if (!d)
          d = f;
        else if (f.indexOf(d) !== 0)
          throw new Error('(Vim.defineEx) "' + d + '" is not a prefix of "' + f + '", command not registered');
        oa[f] = m, Ft.commandMap_[d] = {
          name: f,
          shortName: d,
          type: "api"
        };
      },
      handleKey: function(f, d, m) {
        var g = this.findKey(f, d, m);
        if (typeof g == "function")
          return g();
      },
      multiSelectHandleKey: pe,
      findKey: function(f, d, m) {
        var g = ee(f), b = f;
        function S() {
          var D = V.macroModeState;
          if (D.isRecording) {
            if (d == "q")
              return D.exitMacroRecordMode(), Et(b), true;
            m != "mapping" && wg(D, d);
          }
        }
        function M() {
          if (d == "<Esc>") {
            if (g.visualMode)
              ir(b);
            else if (g.insertMode)
              Zr(b);
            else
              return;
            return Et(b), true;
          }
        }
        function A() {
          if (M())
            return true;
          g.inputState.keyBuffer.push(d);
          var D = g.inputState.keyBuffer.join(""), H = d.length == 1, j = Pr.matchCommand(D, r, g.inputState, "insert"), W = g.inputState.changeQueue;
          if (j.type == "none")
            return Et(b), false;
          if (j.type == "partial") {
            if (j.expectLiteralNext && (g.expectLiteralNext = true), Se && window.clearTimeout(Se), Se = H && window.setTimeout(function() {
              g.insertMode && g.inputState.keyBuffer.length && Et(b);
            }, ae("insertModeEscKeysTimeout")), H) {
              var $ = b.listSelections();
              (!W || W.removed.length != $.length) && (W = g.inputState.changeQueue = new Xm()), W.inserted += d;
              for (var X = 0; X < $.length; X++) {
                var Q = zt($[X].anchor, $[X].head), xe = Jr($[X].anchor, $[X].head), he = b.getRange(Q, b.state.overwrite ? dt(xe, 0, 1) : xe);
                W.removed[X] = (W.removed[X] || "") + he;
              }
            }
            return !H;
          } else
            j.type == "full" && (g.inputState.keyBuffer.length = 0);
          if (g.expectLiteralNext = false, Se && window.clearTimeout(Se), j.command && W) {
            for (var $ = b.listSelections(), X = 0; X < $.length; X++) {
              var Ae = $[X].head;
              b.replaceRange(W.removed[X] || "", dt(Ae, 0, -W.inserted.length), Ae, "+input");
            }
            V.macroModeState.lastInsertModeChanges.changes.pop();
          }
          return j.command || Et(b), j.command;
        }
        function E() {
          if (S() || M())
            return true;
          g.inputState.keyBuffer.push(d);
          var D = g.inputState.keyBuffer.join("");
          if (/^[1-9]\d*$/.test(D))
            return true;
          var H = /^(\d*)(.*)$/.exec(D);
          if (!H)
            return Et(b), false;
          var j = g.visualMode ? "visual" : "normal", W = H[2] || H[1];
          g.inputState.operatorShortcut && g.inputState.operatorShortcut.slice(-1) == W && (W = g.inputState.operatorShortcut);
          var $ = Pr.matchCommand(W, r, g.inputState, j);
          return $.type == "none" ? (Et(b), false) : $.type == "partial" ? ($.expectLiteralNext && (g.expectLiteralNext = true), true) : $.type == "clear" ? (Et(b), true) : (g.expectLiteralNext = false, g.inputState.keyBuffer.length = 0, H = /^(\d*)(.*)$/.exec(D), H && H[1] && H[1] != "0" && g.inputState.pushRepeatDigit(H[1]), $.command);
        }
        var I = g.insertMode ? A() : E();
        if (I === false)
          return !g.insertMode && (d.length === 1 || t.isMac && /<A-.>/.test(d)) ? function() {
            return true;
          } : void 0;
        if (I === true)
          return function() {
            return true;
          };
        if (I)
          return function() {
            return b.operation(function() {
              b.curOp.isVimOp = true;
              try {
                if (typeof I != "object")
                  return;
                I.type == "keyToKey" ? yt(b, I.toKeys, I) : Pr.processCommand(b, g, I);
              } catch (D) {
                throw b.state.vim = void 0, ee(b), console.log(D), D;
              }
              return true;
            });
          };
      },
      handleEx: function(f, d) {
        Ft.processCommand(f, d);
      },
      defineMotion: Or,
      defineAction: ea,
      defineOperator: Zm,
      mapCommand: _i2,
      _mapCommand: sa,
      defineRegister: Qm,
      exitVisualMode: ir,
      exitInsertMode: Zr
    }, le = [], re = false, se;
    function _e2(f) {
      if (!se)
        throw new Error("No prompt to send key to");
      if (f[0] == "<") {
        var d = f.toLowerCase().slice(1, -1), m = d.split("-");
        if (d = m.pop() || "", d == "lt")
          f = "<";
        else if (d == "space")
          f = " ";
        else if (d == "cr")
          f = `
`;
        else if (Qr[d]) {
          var g = se.value || "", b = {
            key: Qr[d],
            target: {
              value: g,
              selectionEnd: g.length,
              selectionStart: g.length
            }
          };
          se.onKeyDown && se.onKeyDown(b, se.value, M), se && se.onKeyUp && se.onKeyUp(b, se.value, M);
          return;
        }
      }
      if (f == `
`) {
        var S = se;
        se = null, S.onClose && S.onClose(S.value);
      } else
        se.value = (se.value || "") + f;
      function M(A) {
        !se || (typeof A == "string" ? se.value = A : se = null);
      }
    }
    function yt(f, d, m) {
      var g = re;
      if (m) {
        if (le.indexOf(m) != -1)
          return;
        le.push(m), re = m.noremap != false;
      }
      try {
        for (var b = ee(f), S = /<(?:[CSMA]-)*\w+>|./gi, M; M = S.exec(d); ) {
          var A = M[0], E = b.insertMode;
          if (se) {
            _e2(A);
            continue;
          }
          var I = ve.handleKey(f, A, "mapping");
          if (!I && E && b.insertMode) {
            if (A[0] == "<") {
              var D = A.toLowerCase().slice(1, -1), H = D.split("-");
              if (D = H.pop() || "", D == "lt")
                A = "<";
              else if (D == "space")
                A = " ";
              else if (D == "cr")
                A = `
`;
              else if (Qr.hasOwnProperty(D)) {
                A = Qr[D], O(f, A);
                continue;
              } else
                A = A[0], S.lastIndex = M.index + 1;
            }
            f.replaceSelection(A);
          }
        }
      } finally {
        if (le.pop(), re = le.length ? g : false, !le.length && se) {
          var j = se;
          se = null, ta(f, j);
        }
      }
    }
    var En = {
      Return: "CR",
      Backspace: "BS",
      Delete: "Del",
      Escape: "Esc",
      Insert: "Ins",
      ArrowLeft: "Left",
      ArrowRight: "Right",
      ArrowUp: "Up",
      ArrowDown: "Down",
      Enter: "CR",
      " ": "Space"
    }, so = {
      Shift: 1,
      Alt: 1,
      Command: 1,
      Control: 1,
      CapsLock: 1,
      AltGraph: 1,
      Dead: 1,
      Unidentified: 1
    }, Qr = {};
    "Left|Right|Up|Down|End|Home".split("|").concat(Object.keys(En)).forEach(function(f) {
      Qr[(En[f] || "").toLowerCase()] = Qr[f.toLowerCase()] = f;
    });
    function ao(f, d) {
      var _a3;
      var m = f.key;
      if (!so[m]) {
        m.length > 1 && m[0] == "n" && (m = m.replace("Numpad", "")), m = En[m] || m;
        var g = "";
        if (f.ctrlKey && (g += "C-"), f.altKey && (g += "A-"), f.metaKey && (g += "M-"), t.isMac && g == "A-" && m.length == 1 && (g = g.slice(2)), (g || m.length > 1) && f.shiftKey && (g += "S-"), d && !d.expectLiteralNext && m.length == 1) {
          if (a.keymap && m in a.keymap)
            (a.remapCtrl != false || !g) && (m = a.keymap[m]);
          else if (m.charCodeAt(0) > 128 && !i[m]) {
            var b = ((_a3 = f.code) == null ? void 0 : _a3.slice(-1)) || "";
            f.shiftKey || (b = b.toLowerCase()), b && (m = b, !g && f.altKey && (g = "A-"));
          }
        }
        return g += m, g.length > 1 && (g = "<" + g + ">"), g;
      }
    }
    function Ll(f, d) {
      a.string !== f && (a = gf(f)), a.remapCtrl = d;
    }
    function gf(f) {
      let d = {};
      if (!f)
        return {
          keymap: d,
          string: ""
        };
      function m(g) {
        return g.split(/\\?(.)/).filter(Boolean);
      }
      return f.split(/((?:[^\\,]|\\.)+),/).map((g) => {
        if (!g)
          return;
        const b = g.split(/((?:[^\\;]|\\.)+);/);
        if (b.length == 3) {
          const S = m(b[1]), M = m(b[2]);
          if (S.length !== M.length)
            return;
          for (let A = 0; A < S.length; ++A)
            d[S[A]] = M[A];
        } else if (b.length == 1) {
          const S = m(g);
          if (S.length % 2 !== 0)
            return;
          for (let M = 0; M < S.length; M += 2)
            d[S[M]] = S[M + 1];
        }
      }), {
        keymap: d,
        string: f
      };
    }
    te("langmap", void 0, "string", [
      "lmap"
    ], function(f, d) {
      if (f === void 0)
        return a.string;
      Ll(f);
    });
    class vf {
      constructor() {
        this.prefixRepeat = [], this.motionRepeat = [], this.operator = null, this.operatorArgs = null, this.motion = null, this.motionArgs = null, this.keyBuffer = [], this.registerName = void 0, this.changeQueue = null;
      }
      pushRepeatDigit(d) {
        this.operator ? this.motionRepeat = this.motionRepeat.concat(d) : this.prefixRepeat = this.prefixRepeat.concat(d);
      }
      getRepeat() {
        var d = 0;
        return (this.prefixRepeat.length > 0 || this.motionRepeat.length > 0) && (d = 1, this.prefixRepeat.length > 0 && (d *= parseInt(this.prefixRepeat.join(""), 10)), this.motionRepeat.length > 0 && (d *= parseInt(this.motionRepeat.join(""), 10))), d;
      }
    }
    function Et(f, d) {
      f.state.vim.inputState = new vf(), f.state.vim.expectLiteralNext = false, t.signal(f, "vim-command-done", d);
    }
    function Xm() {
      this.removed = [], this.inserted = "";
    }
    class nr {
      constructor(d, m, g) {
        this.clear(), this.keyBuffer = [
          d || ""
        ], this.insertModeChanges = [], this.searchQueries = [], this.linewise = !!m, this.blockwise = !!g;
      }
      setText(d, m, g) {
        this.keyBuffer = [
          d || ""
        ], this.linewise = !!m, this.blockwise = !!g;
      }
      pushText(d, m) {
        m && (this.linewise || this.keyBuffer.push(`
`), this.linewise = true), this.keyBuffer.push(d);
      }
      pushInsertModeChanges(d) {
        this.insertModeChanges.push(Ce(d));
      }
      pushSearchQuery(d) {
        this.searchQueries.push(d);
      }
      clear() {
        this.keyBuffer = [], this.insertModeChanges = [], this.searchQueries = [], this.linewise = false;
      }
      toString() {
        return this.keyBuffer.join("");
      }
    }
    function Qm(f, d) {
      var m = V.registerController.registers;
      if (!f || f.length != 1)
        throw Error("Register name must be 1 character");
      if (m[f])
        throw Error("Register already defined " + f);
      m[f] = d, x.push(f);
    }
    class Jm {
      constructor(d) {
        this.registers = d, this.unnamedRegister = d['"'] = new nr(), d["."] = new nr(), d[":"] = new nr(), d["/"] = new nr(), d["+"] = new nr();
      }
      pushText(d, m, g, b, S) {
        if (d !== "_") {
          b && g.charAt(g.length - 1) !== `
` && (g += `
`);
          var M = this.isValidRegister(d) ? this.getRegister(d) : null;
          if (!M || !d) {
            switch (m) {
              case "yank":
                this.registers[0] = new nr(g, b, S);
                break;
              case "delete":
              case "change":
                g.indexOf(`
`) == -1 ? this.registers["-"] = new nr(g, b) : (this.shiftNumericRegisters_(), this.registers[1] = new nr(g, b));
                break;
            }
            this.unnamedRegister.setText(g, b, S);
            return;
          }
          var A = L(d);
          A ? M.pushText(g, b) : M.setText(g, b, S), d === "+" && navigator.clipboard.writeText(g), this.unnamedRegister.setText(M.toString(), b);
        }
      }
      getRegister(d) {
        return this.isValidRegister(d) ? (d = d.toLowerCase(), this.registers[d] || (this.registers[d] = new nr()), this.registers[d]) : this.unnamedRegister;
      }
      isValidRegister(d) {
        return d && (K(d, x) || T.test(d));
      }
      shiftNumericRegisters_() {
        for (var d = 9; d >= 2; d--)
          this.registers[d] = this.getRegister("" + (d - 1));
      }
    }
    class os {
      constructor() {
        this.historyBuffer = [], this.iterator = 0, this.initialPrefix = null;
      }
      nextMatch(d, m) {
        var g = this.historyBuffer, b = m ? -1 : 1;
        this.initialPrefix === null && (this.initialPrefix = d);
        for (var S = this.iterator + b; m ? S >= 0 : S < g.length; S += b)
          for (var M = g[S], A = 0; A <= M.length; A++)
            if (this.initialPrefix == M.substring(0, A))
              return this.iterator = S, M;
        if (S >= g.length)
          return this.iterator = g.length, this.initialPrefix;
        if (S < 0)
          return d;
      }
      pushInput(d) {
        var m = this.historyBuffer.indexOf(d);
        m > -1 && this.historyBuffer.splice(m, 1), d.length && this.historyBuffer.push(d);
      }
      reset() {
        this.initialPrefix = null, this.iterator = this.historyBuffer.length;
      }
    }
    var Pr = {
      matchCommand: function(f, d, m, g) {
        var b = yf(f, d, g, m), S = b.full[0];
        if (!S)
          return b.partial.length ? {
            type: "partial",
            expectLiteralNext: b.partial.length == 1 && b.partial[0].keys.slice(-11) == "<character>"
          } : {
            type: "none"
          };
        if (S.keys.slice(-11) == "<character>" || S.keys.slice(-10) == "<register>") {
          var M = eg(f);
          if (!M || M.length > 1)
            return {
              type: "clear"
            };
          m.selectedCharacter = M;
        }
        return {
          type: "full",
          command: S
        };
      },
      processCommand: function(f, d, m) {
        switch (d.inputState.repeatOverride = m.repeatOverride, m.type) {
          case "motion":
            this.processMotion(f, d, m);
            break;
          case "operator":
            this.processOperator(f, d, m);
            break;
          case "operatorMotion":
            this.processOperatorMotion(f, d, m);
            break;
          case "action":
            this.processAction(f, d, m);
            break;
          case "search":
            this.processSearch(f, d, m);
            break;
          case "ex":
          case "keyToEx":
            this.processEx(f, d, m);
            break;
        }
      },
      processMotion: function(f, d, m) {
        d.inputState.motion = m.motion, d.inputState.motionArgs = ss(m.motionArgs), this.evalInput(f, d);
      },
      processOperator: function(f, d, m) {
        var g = d.inputState;
        if (g.operator)
          if (g.operator == m.operator) {
            g.motion = "expandToLine", g.motionArgs = {
              linewise: true,
              repeat: 1
            }, this.evalInput(f, d);
            return;
          } else
            Et(f);
        g.operator = m.operator, g.operatorArgs = ss(m.operatorArgs), m.keys.length > 1 && (g.operatorShortcut = m.keys), m.exitVisualBlock && (d.visualBlock = false, co(f)), d.visualMode && this.evalInput(f, d);
      },
      processOperatorMotion: function(f, d, m) {
        var g = d.visualMode, b = ss(m.operatorMotionArgs);
        b && g && b.visualLine && (d.visualLine = true), this.processOperator(f, d, m), g || this.processMotion(f, d, m);
      },
      processAction: function(f, d, m) {
        var g = d.inputState, b = g.getRepeat(), S = !!b, M = ss(m.actionArgs) || {
          repeat: 1
        };
        g.selectedCharacter && (M.selectedCharacter = g.selectedCharacter), m.operator && this.processOperator(f, d, m), m.motion && this.processMotion(f, d, m), (m.motion || m.operator) && this.evalInput(f, d), M.repeat = b || 1, M.repeatIsExplicit = S, M.registerName = g.registerName, Et(f), d.lastMotion = null, m.isEdit && this.recordLastEdit(d, g, m), lo[m.action](f, M, d);
      },
      processSearch: function(f, d, m) {
        if (!f.getSearchCursor)
          return;
        var g = m.searchArgs.forward, b = m.searchArgs.wholeWordOnly;
        On(f).setReversed(!g);
        var S = g ? "/" : "?", M = On(f).getQuery(), A = f.getScrollInfo(), E = "";
        function I(he, Ae, Le) {
          V.searchHistoryController.pushInput(he), V.searchHistoryController.reset();
          try {
            cs(f, he, Ae, Le);
          } catch {
            De(f, "Invalid regex: " + he), Et(f);
            return;
          }
          Pr.processMotion(f, d, {
            keys: "",
            type: "motion",
            motion: "findNext",
            motionArgs: {
              forward: true,
              toJumplist: m.searchArgs.toJumplist
            }
          });
        }
        function D(he) {
          f.scrollTo(A.left, A.top), I(he, true, true);
          var Ae = V.macroModeState;
          Ae.isRecording && kg(Ae, he);
        }
        function H() {
          return ae("pcre") ? "(JavaScript regexp: set pcre)" : "(Vim regexp: set nopcre)";
        }
        function j(he, Ae, Le) {
          var Pe = ao(he), ut, pt;
          Pe == "<Up>" || Pe == "<Down>" ? (ut = Pe == "<Up>", pt = he.target ? he.target.selectionEnd : 0, Ae = V.searchHistoryController.nextMatch(Ae, ut) || "", Le(Ae), pt && he.target && (he.target.selectionEnd = he.target.selectionStart = Math.min(pt, he.target.value.length))) : Pe && Pe != "<Left>" && Pe != "<Right>" && V.searchHistoryController.reset(), E = Ae, W();
        }
        function W() {
          var he;
          try {
            he = cs(f, E, true, true);
          } catch {
          }
          he ? f.scrollIntoView(Bf(f, !g, he), 30) : (fo(f), f.scrollTo(A.left, A.top));
        }
        function $(he, Ae, Le) {
          var Pe = ao(he);
          Pe == "<Esc>" || Pe == "<C-c>" || Pe == "<C-[>" || Pe == "<BS>" && Ae == "" ? (V.searchHistoryController.pushInput(Ae), V.searchHistoryController.reset(), cs(f, (M == null ? void 0 : M.source) || ""), fo(f), f.scrollTo(A.left, A.top), t.e_stop(he), Et(f), Le(), f.focus()) : Pe == "<Up>" || Pe == "<Down>" ? t.e_stop(he) : Pe == "<C-u>" && (t.e_stop(he), Le(""));
        }
        switch (m.searchArgs.querySrc) {
          case "prompt":
            var X = V.macroModeState;
            if (X.isPlaying) {
              let Ae = X.replaySearchQueries.shift();
              I(Ae || "", true, false);
            } else
              ta(f, {
                onClose: D,
                prefix: S,
                desc: on("span", {
                  $cursor: "pointer",
                  onmousedown: function(Ae) {
                    Ae.preventDefault(), ne("pcre", !ae("pcre")), this.textContent = H(), W();
                  }
                }, H()),
                onKeyUp: j,
                onKeyDown: $
              });
            break;
          case "wordUnderCursor":
            var Q = Nl(f, {
              noSymbol: true
            }), xe = true;
            if (Q || (Q = Nl(f, {
              noSymbol: false
            }), xe = false), !Q) {
              De(f, "No word under cursor"), Et(f);
              return;
            }
            let he = f.getLine(Q.start.line).substring(Q.start.ch, Q.end.ch);
            xe && b ? he = "\\b" + he + "\\b" : he = Ri(he), V.jumpList.cachedCursor = f.getCursor(), f.setCursor(Q.start), I(he, true, false);
            break;
        }
      },
      processEx: function(f, d, m) {
        function g(A) {
          V.exCommandHistoryController.pushInput(A), V.exCommandHistoryController.reset(), Ft.processCommand(f, A), f.state.vim && Et(f), fo(f);
        }
        function b(A, E, I) {
          var D = ao(A), H, j;
          (D == "<Esc>" || D == "<C-c>" || D == "<C-[>" || D == "<BS>" && E == "") && (V.exCommandHistoryController.pushInput(E), V.exCommandHistoryController.reset(), t.e_stop(A), Et(f), fo(f), I(), f.focus()), D == "<Up>" || D == "<Down>" ? (t.e_stop(A), H = D == "<Up>", j = A.target ? A.target.selectionEnd : 0, E = V.exCommandHistoryController.nextMatch(E, H) || "", I(E), j && A.target && (A.target.selectionEnd = A.target.selectionStart = Math.min(j, A.target.value.length))) : D == "<C-u>" ? (t.e_stop(A), I("")) : D && D != "<Left>" && D != "<Right>" && V.exCommandHistoryController.reset();
        }
        function S(A, E) {
          var I = new t.StringStream(E), D = {};
          try {
            if (Ft.parseInput_(f, I, D), D.commandName != "s") {
              fo(f);
              return;
            }
            var H = Ft.matchCommand_(D.commandName);
            if (!H || (Ft.parseCommandArgs_(I, D, H), !D.argString))
              return;
            var j = Df(D.argString.slice(1), true, true);
            j && na(f, j);
          } catch {
          }
        }
        if (m.type == "keyToEx")
          Ft.processCommand(f, m.exArgs.input);
        else {
          var M = {
            onClose: g,
            onKeyDown: b,
            onKeyUp: S,
            prefix: ":"
          };
          d.visualMode && (M.value = "'<,'>", M.selectValueOnOpen = false), ta(f, M);
        }
      },
      evalInput: function(f, d) {
        var m = d.inputState, g = m.motion, b = m.motionArgs || {
          repeat: 1
        }, S = m.operator, M = m.operatorArgs || {}, A = m.registerName, E = d.sel, I = ze(d.visualMode ? $t(f, E.head) : f.getCursor("head")), D = ze(d.visualMode ? $t(f, E.anchor) : f.getCursor("anchor")), H = ze(I), j = ze(D), W, $, X;
        if (S && this.recordLastEdit(d, m), m.repeatOverride !== void 0 ? X = m.repeatOverride : X = m.getRepeat(), X > 0 && b.explicitRepeat ? b.repeatIsExplicit = true : (b.noRepeat || !b.explicitRepeat && X === 0) && (X = 1, b.repeatIsExplicit = false), m.selectedCharacter && (b.selectedCharacter = M.selectedCharacter = m.selectedCharacter), b.repeat = X, Et(f), g) {
          var Q = vn[g](f, I, b, d, m);
          if (d.lastMotion = vn[g], !Q)
            return;
          if (b.toJumplist) {
            var xe = V.jumpList, he = xe.cachedCursor;
            he ? (kf(f, he, Q), delete xe.cachedCursor) : kf(f, I, Q);
          }
          Q instanceof Array ? ($ = Q[0], W = Q[1]) : W = Q, W || (W = ze(I)), d.visualMode ? (d.visualBlock && W.ch === 1 / 0 || (W = $t(f, W, H)), $ && ($ = $t(f, $)), $ = $ || j, E.anchor = $, E.head = W, co(f), Pn(f, d, "<", ct($, W) ? $ : W), Pn(f, d, ">", ct($, W) ? W : $)) : S || (W = $t(f, W, H), f.setCursor(W.line, W.ch));
        }
        if (S) {
          if (M.lastSel) {
            $ = j;
            var Ae = M.lastSel, Le = Math.abs(Ae.head.line - Ae.anchor.line), Pe = Math.abs(Ae.head.ch - Ae.anchor.ch);
            Ae.visualLine ? W = new e(j.line + Le, j.ch) : Ae.visualBlock ? W = new e(j.line + Le, j.ch + Pe) : Ae.head.line == Ae.anchor.line ? W = new e(j.line, j.ch + Pe) : W = new e(j.line + Le, j.ch), d.visualMode = true, d.visualLine = Ae.visualLine, d.visualBlock = Ae.visualBlock, E = d.sel = {
              anchor: $,
              head: W
            }, co(f);
          } else
            d.visualMode && (M.lastSel = {
              anchor: ze(E.anchor),
              head: ze(E.head),
              visualBlock: d.visualBlock,
              visualLine: d.visualLine
            });
          var ut, pt, Fe, Me, et;
          if (d.visualMode) {
            ut = zt(E.head, E.anchor), pt = Jr(E.head, E.anchor), Fe = d.visualLine || M.linewise, Me = d.visualBlock ? "block" : Fe ? "line" : "char";
            var sr = n(f, ut, pt);
            if (et = Bl(f, {
              anchor: sr.start,
              head: sr.end
            }, Me), Fe) {
              var qt = et.ranges;
              if (Me == "block")
                for (var ar = 0; ar < qt.length; ar++)
                  qt[ar].head.ch = bt(f, qt[ar].head.line);
              else
                Me == "line" && (qt[0].head = new e(qt[0].head.line + 1, 0));
            }
          } else {
            if (ut = ze($ || j), pt = ze(W || H), ct(pt, ut)) {
              var hs = ut;
              ut = pt, pt = hs;
            }
            Fe = b.linewise || M.linewise, Fe ? sg(f, ut, pt) : b.forward && uo(f, ut, pt), Me = "char";
            var c_ = !b.inclusive || Fe, sr = n(f, ut, pt);
            et = Bl(f, {
              anchor: sr.start,
              head: sr.end
            }, Me, c_);
          }
          f.setSelections(et.ranges, et.primary), d.lastMotion = null, M.repeat = X, M.registerName = A, M.linewise = Fe;
          var Cg = Zs[S](f, M, et.ranges, j, W);
          d.visualMode && ir(f, Cg != null), Cg && f.setCursor(Cg);
        }
      },
      recordLastEdit: function(f, d, m) {
        var g = V.macroModeState;
        g.isPlaying || (f.lastEditInputState = d, f.lastEditActionCommand = m, g.lastInsertModeChanges.changes = [], g.lastInsertModeChanges.expectCursorActivityForChange = false, g.lastInsertModeChanges.visualBlock = f.visualBlock ? f.sel.head.line - f.sel.anchor.line : 0);
      }
    }, vn = {
      moveToTopLine: function(f, d, m) {
        var g = Fl(f).top + m.repeat - 1;
        return new e(g, or(f.getLine(g)));
      },
      moveToMiddleLine: function(f) {
        var d = Fl(f), m = Math.floor((d.top + d.bottom) * 0.5);
        return new e(m, or(f.getLine(m)));
      },
      moveToBottomLine: function(f, d, m) {
        var g = Fl(f).bottom - m.repeat + 1;
        return new e(g, or(f.getLine(g)));
      },
      expandToLine: function(f, d, m) {
        var g = d;
        return new e(g.line + m.repeat - 1, 1 / 0);
      },
      findNext: function(f, d, m) {
        var g = On(f), b = g.getQuery();
        if (!!b) {
          var S = !m.forward;
          S = g.isReversed() ? !S : S, na(f, b);
          var M = Bf(f, S, b, m.repeat);
          return M || De(f, "No match found " + b + (ae("pcre") ? " (set nopcre to use Vim regexps)" : "")), M;
        }
      },
      findAndSelectNextInclusive: function(f, d, m, g, b) {
        var S = On(f), M = S.getQuery();
        if (!!M) {
          var A = !m.forward;
          A = S.isReversed() ? !A : A;
          var E = Sg(f, A, M, m.repeat, g);
          if (!!E) {
            if (b.operator)
              return E;
            var I = E[0], D = new e(E[1].line, E[1].ch - 1);
            if (g.visualMode) {
              (g.visualLine || g.visualBlock) && (g.visualLine = false, g.visualBlock = false, t.signal(f, "vim-mode-change", {
                mode: "visual",
                subMode: ""
              }));
              var H = g.sel.anchor;
              if (H)
                return S.isReversed() ? m.forward ? [
                  H,
                  I
                ] : [
                  H,
                  D
                ] : m.forward ? [
                  H,
                  D
                ] : [
                  H,
                  I
                ];
            } else
              g.visualMode = true, g.visualLine = false, g.visualBlock = false, t.signal(f, "vim-mode-change", {
                mode: "visual",
                subMode: ""
              });
            return A ? [
              D,
              I
            ] : [
              I,
              D
            ];
          }
        }
      },
      goToMark: function(f, d, m, g) {
        var b = ra(f, g, m.selectedCharacter || "");
        return b ? m.linewise ? {
          line: b.line,
          ch: or(f.getLine(b.line))
        } : b : null;
      },
      moveToOtherHighlightedEnd: function(f, d, m, g) {
        var b = g.sel;
        return g.visualBlock && m.sameLine ? [
          $t(f, new e(b.anchor.line, b.head.ch)),
          $t(f, new e(b.head.line, b.anchor.ch))
        ] : [
          b.head,
          b.anchor
        ];
      },
      jumpToMark: function(f, d, m, g) {
        for (var b = d, S = 0; S < m.repeat; S++) {
          var M = b;
          for (var A in g.marks)
            if (!!C(A)) {
              var E = g.marks[A].find(), I = m.forward ? ct(E, M) : ct(M, E);
              if (!I && !(m.linewise && E.line == M.line)) {
                var D = Kt(M, b), H = m.forward ? Dl(M, E, b) : Dl(b, E, M);
                (D || H) && (b = E);
              }
            }
        }
        return m.linewise && (b = new e(b.line, or(f.getLine(b.line)))), b;
      },
      moveByCharacters: function(f, d, m) {
        var g = d, b = m.repeat, S = m.forward ? g.ch + b : g.ch - b;
        return new e(g.line, S);
      },
      moveByLines: function(f, d, m, g) {
        var b = d, S = b.ch;
        switch (g.lastMotion) {
          case this.moveByLines:
          case this.moveByDisplayLines:
          case this.moveByScroll:
          case this.moveToColumn:
          case this.moveToEol:
            S = g.lastHPos;
            break;
          default:
            g.lastHPos = S;
        }
        var M = m.repeat + (m.repeatOffset || 0), A = m.forward ? b.line + M : b.line - M, E = f.firstLine(), I = f.lastLine(), D = f.findPosV(b, m.forward ? M : -M, "line", g.lastHSPos), H = m.forward ? D.line > A : D.line < A;
        return H && (A = D.line, S = D.ch), A < E && b.line == E ? this.moveToStartOfLine(f, d, m, g) : A > I && b.line == I ? Mf(f, d, m, g, true) : (m.toFirstChar && (S = or(f.getLine(A)), g.lastHPos = S), g.lastHSPos = f.charCoords(new e(A, S), "div").left, new e(A, S));
      },
      moveByDisplayLines: function(f, d, m, g) {
        var b = d;
        switch (g.lastMotion) {
          case this.moveByDisplayLines:
          case this.moveByScroll:
          case this.moveByLines:
          case this.moveToColumn:
          case this.moveToEol:
            break;
          default:
            g.lastHSPos = f.charCoords(b, "div").left;
        }
        var S = m.repeat, M = f.findPosV(b, m.forward ? S : -S, "line", g.lastHSPos);
        if (M.hitSide)
          if (m.forward) {
            var A = f.charCoords(M, "div"), E = {
              top: A.top + 8,
              left: g.lastHSPos
            };
            M = f.coordsChar(E, "div");
          } else {
            var I = f.charCoords(new e(f.firstLine(), 0), "div");
            I.left = g.lastHSPos, M = f.coordsChar(I, "div");
          }
        return g.lastHPos = M.ch, M;
      },
      moveByPage: function(f, d, m) {
        var g = d, b = m.repeat;
        return f.findPosV(g, m.forward ? b : -b, "page");
      },
      moveByParagraph: function(f, d, m) {
        var g = m.forward ? 1 : -1;
        return Af(f, d, m.repeat, g).start;
      },
      moveBySentence: function(f, d, m) {
        var g = m.forward ? 1 : -1;
        return Ef(f, d, m.repeat, g);
      },
      moveByScroll: function(f, d, m, g) {
        var b = f.getScrollInfo(), S = null, M = m.repeat;
        M || (M = b.clientHeight / (2 * f.defaultTextHeight()));
        var A = f.charCoords(d, "local");
        if (m.repeat = M, S = vn.moveByDisplayLines(f, d, m, g), !S)
          return null;
        var E = f.charCoords(S, "local");
        return f.scrollTo(null, b.top + E.top - A.top), S;
      },
      moveByWords: function(f, d, m) {
        return ug(f, d, m.repeat, !!m.forward, !!m.wordEnd, !!m.bigWord);
      },
      moveTillCharacter: function(f, d, m) {
        var g = m.repeat, b = as(f, g, m.forward, m.selectedCharacter, d), S = m.forward ? -1 : 1;
        return Li(S, m), b ? (b.ch += S, b) : null;
      },
      moveToCharacter: function(f, d, m) {
        var g = m.repeat;
        return Li(0, m), as(f, g, m.forward, m.selectedCharacter, d) || d;
      },
      moveToSymbol: function(f, d, m) {
        var g = m.repeat;
        return m.selectedCharacter && cg(f, g, m.forward, m.selectedCharacter) || d;
      },
      moveToColumn: function(f, d, m, g) {
        var b = m.repeat;
        return g.lastHPos = b - 1, g.lastHSPos = f.charCoords(d, "div").left, fg(f, b);
      },
      moveToEol: function(f, d, m, g) {
        return Mf(f, d, m, g, false);
      },
      moveToFirstNonWhiteSpaceCharacter: function(f, d) {
        var m = d;
        return new e(m.line, or(f.getLine(m.line)));
      },
      moveToMatchedSymbol: function(f, d) {
        for (var m = d, g = m.line, b = m.ch, S = f.getLine(g), M; b < S.length; b++)
          if (M = S.charAt(b), M && P(M)) {
            var A = f.getTokenTypeAt(new e(g, b + 1));
            if (A !== "string" && A !== "comment")
              break;
          }
        if (b < S.length) {
          var E = M === "<" || M === ">" ? /[(){}[\]<>]/ : /[(){}[\]]/, I = f.findMatchingBracket(new e(g, b), {
            bracketRegex: E
          });
          return I.to;
        } else
          return m;
      },
      moveToStartOfLine: function(f, d) {
        return new e(d.line, 0);
      },
      moveToLineOrEdgeOfDocument: function(f, d, m) {
        var g = m.forward ? f.lastLine() : f.firstLine();
        return m.repeatIsExplicit && (g = m.repeat - f.getOption("firstLineNumber")), new e(g, or(f.getLine(g)));
      },
      moveToStartOfDisplayLine: function(f) {
        return f.execCommand("goLineLeft"), f.getCursor();
      },
      moveToEndOfDisplayLine: function(f) {
        f.execCommand("goLineRight");
        var d = f.getCursor();
        return d.sticky == "before" && d.ch--, d;
      },
      textObjectManipulation: function(f, d, m, g) {
        var b = {
          "(": ")",
          ")": "(",
          "{": "}",
          "}": "{",
          "[": "]",
          "]": "[",
          "<": ">",
          ">": "<"
        }, S = {
          "'": true,
          '"': true,
          "`": true
        }, M = m.selectedCharacter || "";
        M == "b" ? M = "(" : M == "B" && (M = "{");
        var A = !m.textObjectInner, E, I;
        if (b[M]) {
          if (I = true, E = Pf(f, d, M, A), !E) {
            var D = f.getSearchCursor(new RegExp("\\" + M, "g"), d);
            D.find() && (E = Pf(f, D.from(), M, A));
          }
        } else if (S[M])
          I = true, E = hg(f, d, M, A);
        else if (M === "W" || M === "w")
          for (var H = m.repeat || 1; H-- > 0; ) {
            var j = Nl(f, {
              inclusive: A,
              innerWord: !A,
              bigWord: M === "W",
              noSymbol: M === "W",
              multiline: true
            }, E && E.end);
            j && (E || (E = j), E.end = j.end);
          }
        else if (M === "p")
          if (E = Af(f, d, m.repeat, 0, A), m.linewise = true, g.visualMode)
            g.visualLine || (g.visualLine = true);
          else {
            var W = g.inputState.operatorArgs;
            W && (W.linewise = true), E.end.line--;
          }
        else if (M === "t")
          E = ag(f, d, A);
        else if (M === "s") {
          var $ = f.getLine(d.line);
          d.ch > 0 && F($[d.ch]) && (d.ch -= 1);
          var X = ls(f, d, m.repeat, 1, A), Q = ls(f, d, m.repeat, -1, A);
          _(f.getLine(Q.line)[Q.ch]) && _(f.getLine(X.line)[X.ch - 1]) && (Q = {
            line: Q.line,
            ch: Q.ch + 1
          }), E = {
            start: Q,
            end: X
          };
        }
        return E ? f.state.vim.visualMode ? ig(f, E.start, E.end, I) : [
          E.start,
          E.end
        ] : null;
      },
      repeatLastCharacterSearch: function(f, d, m) {
        var g = V.lastCharacterSearch, b = m.repeat, S = m.forward === g.forward, M = (g.increment ? 1 : 0) * (S ? -1 : 1);
        f.moveH(-M, "char"), m.inclusive = !!S;
        var A = as(f, b, S, g.selectedCharacter);
        return A ? (A.ch += M, A) : (f.moveH(M, "char"), d);
      }
    };
    function Or(f, d) {
      vn[f] = d;
    }
    function _l2(f, d) {
      for (var m = [], g = 0; g < d; g++)
        m.push(f);
      return m;
    }
    var Zs = {
      change: function(f, d, m) {
        var g, b, S = f.state.vim, M = m[0].anchor, A = m[0].head;
        if (S.visualMode)
          if (d.fullLine)
            A.ch = Number.MAX_VALUE, A.line--, f.setSelection(M, A), b = f.getSelection(), f.replaceSelection(""), g = M;
          else {
            b = f.getSelection();
            var D = _l2("", m.length);
            f.replaceSelections(D), g = zt(m[0].head, m[0].anchor);
          }
        else {
          b = f.getRange(M, A);
          var E = S.lastEditInputState;
          if ((E == null ? void 0 : E.motion) == "moveByWords" && !_(b)) {
            var I = /\s+$/.exec(b);
            I && E.motionArgs && E.motionArgs.forward && (A = dt(A, 0, -I[0].length), b = b.slice(0, -I[0].length));
          }
          d.linewise && (M = new e(M.line, or(f.getLine(M.line))), A.line > M.line && (A = new e(A.line - 1, Number.MAX_VALUE))), f.replaceRange("", M, A), g = M;
        }
        V.registerController.pushText(d.registerName, "change", b, d.linewise, m.length > 1), lo.enterInsertMode(f, {
          head: g
        }, f.state.vim);
      },
      delete: function(f, d, m) {
        var g, b, S = f.state.vim;
        if (S.visualBlock) {
          b = f.getSelection();
          var E = _l2("", m.length);
          f.replaceSelections(E), g = zt(m[0].head, m[0].anchor);
        } else {
          var M = m[0].anchor, A = m[0].head;
          d.linewise && A.line != f.firstLine() && M.line == f.lastLine() && M.line == A.line - 1 && (M.line == f.firstLine() ? M.ch = 0 : M = new e(M.line - 1, bt(f, M.line - 1))), b = f.getRange(M, A), f.replaceRange("", M, A), g = M, d.linewise && (g = vn.moveToFirstNonWhiteSpaceCharacter(f, M));
        }
        return V.registerController.pushText(d.registerName, "delete", b, d.linewise, S.visualBlock), $t(f, g);
      },
      indent: function(f, d, m) {
        var g = f.state.vim, b = g.visualMode && d.repeat || 1;
        if (g.visualBlock) {
          for (var S = f.getOption("tabSize"), M = f.getOption("indentWithTabs") ? "	" : " ".repeat(S), A, E = m.length - 1; E >= 0; E--)
            if (A = zt(m[E].anchor, m[E].head), d.indentRight)
              f.replaceRange(M.repeat(b), A, A);
            else {
              for (var I = f.getLine(A.line), D = 0, H = 0; H < b; H++) {
                var j = I[A.ch + D];
                if (j == "	")
                  D++;
                else if (j == " ") {
                  D++;
                  for (var W = 1; W < M.length && (j = I[A.ch + D], j === " "); W++)
                    D++;
                } else
                  break;
              }
              f.replaceRange("", A, dt(A, 0, D));
            }
          return A;
        } else if (f.indentMore)
          for (var H = 0; H < b; H++)
            d.indentRight ? f.indentMore() : f.indentLess();
        else {
          var $ = m[0].anchor.line, X = g.visualBlock ? m[m.length - 1].anchor.line : m[0].head.line;
          d.linewise && X--;
          for (var E = $; E <= X; E++)
            for (var H = 0; H < b; H++)
              f.indentLine(E, d.indentRight);
        }
        return vn.moveToFirstNonWhiteSpaceCharacter(f, m[0].anchor);
      },
      indentAuto: function(f, d, m) {
        return f.execCommand("indentAuto"), vn.moveToFirstNonWhiteSpaceCharacter(f, m[0].anchor);
      },
      hardWrap: function(f, d, m, g) {
        if (!!f.hardWrap) {
          var b = m[0].anchor.line, S = m[0].head.line;
          d.linewise && S--;
          var M = f.hardWrap({
            from: b,
            to: S
          });
          return M > b && d.linewise && M--, d.keepCursor ? g : new e(M, 0);
        }
      },
      changeCase: function(f, d, m, g, b) {
        for (var S = f.getSelections(), M = [], A = d.toLower, E = 0; E < S.length; E++) {
          var I = S[E], D = "";
          if (A === true)
            D = I.toLowerCase();
          else if (A === false)
            D = I.toUpperCase();
          else
            for (var H = 0; H < I.length; H++) {
              var j = I.charAt(H);
              D += L(j) ? j.toLowerCase() : j.toUpperCase();
            }
          M.push(D);
        }
        return f.replaceSelections(M), d.shouldMoveCursor ? b : !f.state.vim.visualMode && d.linewise && m[0].anchor.line + 1 == m[0].head.line ? vn.moveToFirstNonWhiteSpaceCharacter(f, g) : d.linewise ? g : zt(m[0].anchor, m[0].head);
      },
      yank: function(f, d, m, g) {
        var b = f.state.vim, S = f.getSelection(), M = b.visualMode ? zt(b.sel.anchor, b.sel.head, m[0].head, m[0].anchor) : g;
        return V.registerController.pushText(d.registerName, "yank", S, d.linewise, b.visualBlock), M;
      },
      rot13: function(f, d, m, g, b) {
        for (var S = f.getSelections(), M = [], A = 0; A < S.length; A++) {
          const E = S[A].split("").map((I) => {
            const D = I.charCodeAt(0);
            return D >= 65 && D <= 90 ? String.fromCharCode(65 + (D - 65 + 13) % 26) : D >= 97 && D <= 122 ? String.fromCharCode(97 + (D - 97 + 13) % 26) : I;
          }).join("");
          M.push(E);
        }
        return f.replaceSelections(M), d.shouldMoveCursor ? b : !f.state.vim.visualMode && d.linewise && m[0].anchor.line + 1 == m[0].head.line ? vn.moveToFirstNonWhiteSpaceCharacter(f, g) : d.linewise ? g : zt(m[0].anchor, m[0].head);
      }
    };
    function Zm(f, d) {
      Zs[f] = d;
    }
    var lo = {
      jumpListWalk: function(f, d, m) {
        if (!m.visualMode) {
          var g = d.repeat || 1, b = d.forward, S = V.jumpList, M = S.move(f, b ? g : -g), A = M ? M.find() : void 0;
          A = A || f.getCursor(), f.setCursor(A);
        }
      },
      scroll: function(f, d, m) {
        if (!m.visualMode) {
          var g = d.repeat || 1, b = f.defaultTextHeight(), S = f.getScrollInfo().top, M = b * g, A = d.forward ? S + M : S - M, E = ze(f.getCursor()), I = f.charCoords(E, "local");
          if (d.forward)
            A > I.top ? (E.line += (A - I.top) / b, E.line = Math.ceil(E.line), f.setCursor(E), I = f.charCoords(E, "local"), f.scrollTo(null, I.top)) : f.scrollTo(null, A);
          else {
            var D = A + f.getScrollInfo().clientHeight;
            D < I.bottom ? (E.line -= (I.bottom - D) / b, E.line = Math.floor(E.line), f.setCursor(E), I = f.charCoords(E, "local"), f.scrollTo(null, I.bottom - f.getScrollInfo().clientHeight)) : f.scrollTo(null, A);
          }
        }
      },
      scrollToCursor: function(f, d) {
        var m = f.getCursor().line, g = f.charCoords(new e(m, 0), "local"), b = f.getScrollInfo().clientHeight, S = g.top;
        switch (d.position) {
          case "center":
            S = g.bottom - b / 2;
            break;
          case "bottom":
            var M = new e(m, f.getLine(m).length - 1), A = f.charCoords(M, "local"), E = A.bottom - S;
            S = S - b + E;
            break;
        }
        f.scrollTo(null, S);
      },
      replayMacro: function(f, d, m) {
        var g = d.selectedCharacter || "", b = d.repeat || 1, S = V.macroModeState;
        for (g == "@" ? g = S.latestRegister || "" : S.latestRegister = g; b--; )
          fs(f, m, S, g);
      },
      enterMacroRecordMode: function(f, d) {
        var m = V.macroModeState, g = d.selectedCharacter;
        V.registerController.isValidRegister(g) && m.enterMacroRecordMode(f, g);
      },
      toggleOverwrite: function(f) {
        f.state.overwrite ? (f.toggleOverwrite(false), f.setOption("keyMap", "vim-insert"), t.signal(f, "vim-mode-change", {
          mode: "insert"
        })) : (f.toggleOverwrite(true), f.setOption("keyMap", "vim-replace"), t.signal(f, "vim-mode-change", {
          mode: "replace"
        }));
      },
      enterInsertMode: function(f, d, m) {
        if (!f.getOption("readOnly")) {
          m.insertMode = true, m.insertModeRepeat = d && d.repeat || 1;
          var g = d ? d.insertAt : null, b = m.sel, S = d.head || f.getCursor("head"), M = f.listSelections().length;
          if (g == "eol")
            S = new e(S.line, bt(f, S.line));
          else if (g == "bol")
            S = new e(S.line, 0);
          else if (g == "charAfter") {
            var A = n(f, S, dt(S, 0, 1));
            S = A.end;
          } else if (g == "firstNonBlank") {
            var A = n(f, S, vn.moveToFirstNonWhiteSpaceCharacter(f, S));
            S = A.end;
          } else if (g == "startOfSelectedArea") {
            if (!m.visualMode)
              return;
            m.visualBlock ? (S = new e(Math.min(b.head.line, b.anchor.line), Math.min(b.head.ch, b.anchor.ch)), M = Math.abs(b.head.line - b.anchor.line) + 1) : b.head.line < b.anchor.line ? S = b.head : S = new e(b.anchor.line, 0);
          } else if (g == "endOfSelectedArea") {
            if (!m.visualMode)
              return;
            m.visualBlock ? (S = new e(Math.min(b.head.line, b.anchor.line), Math.max(b.head.ch, b.anchor.ch) + 1), M = Math.abs(b.head.line - b.anchor.line) + 1) : b.head.line >= b.anchor.line ? S = dt(b.head, 0, 1) : S = new e(b.anchor.line, 0);
          } else if (g == "inplace") {
            if (m.visualMode)
              return;
          } else
            g == "lastEdit" && (S = Nf(f) || S);
          f.setOption("disableInput", false), d && d.replace ? (f.toggleOverwrite(true), f.setOption("keyMap", "vim-replace"), t.signal(f, "vim-mode-change", {
            mode: "replace"
          })) : (f.toggleOverwrite(false), f.setOption("keyMap", "vim-insert"), t.signal(f, "vim-mode-change", {
            mode: "insert"
          })), V.macroModeState.isPlaying || (f.on("change", jl), m.insertEnd && m.insertEnd.clear(), m.insertEnd = f.setBookmark(S, {
            insertLeft: true
          }), t.on(f.getInputField(), "keydown", Wl)), m.visualMode && ir(f), wf(f, S, M);
        }
      },
      toggleVisualMode: function(f, d, m) {
        var g = d.repeat, b = f.getCursor(), S;
        if (m.visualMode)
          m.visualLine != !!d.linewise || m.visualBlock != !!d.blockwise ? (m.visualLine = !!d.linewise, m.visualBlock = !!d.blockwise, t.signal(f, "vim-mode-change", {
            mode: "visual",
            subMode: m.visualLine ? "linewise" : m.visualBlock ? "blockwise" : ""
          }), co(f)) : ir(f);
        else {
          m.visualMode = true, m.visualLine = !!d.linewise, m.visualBlock = !!d.blockwise, S = $t(f, new e(b.line, b.ch + g - 1));
          var M = n(f, b, S);
          m.sel = {
            anchor: M.start,
            head: M.end
          }, t.signal(f, "vim-mode-change", {
            mode: "visual",
            subMode: m.visualLine ? "linewise" : m.visualBlock ? "blockwise" : ""
          }), co(f), Pn(f, m, "<", zt(b, S)), Pn(f, m, ">", Jr(b, S));
        }
      },
      reselectLastSelection: function(f, d, m) {
        var g = m.lastSelection;
        if (m.visualMode && rr(f, m), g) {
          var b = g.anchorMark.find(), S = g.headMark.find();
          if (!b || !S)
            return;
          m.sel = {
            anchor: b,
            head: S
          }, m.visualMode = true, m.visualLine = g.visualLine, m.visualBlock = g.visualBlock, co(f), Pn(f, m, "<", zt(b, S)), Pn(f, m, ">", Jr(b, S)), t.signal(f, "vim-mode-change", {
            mode: "visual",
            subMode: m.visualLine ? "linewise" : m.visualBlock ? "blockwise" : ""
          });
        }
      },
      joinLines: function(f, d, m) {
        var g, b;
        if (m.visualMode) {
          if (g = f.getCursor("anchor"), b = f.getCursor("head"), ct(b, g)) {
            var S = b;
            b = g, g = S;
          }
          b.ch = bt(f, b.line) - 1;
        } else {
          var M = Math.max(d.repeat, 2);
          g = f.getCursor(), b = $t(f, new e(g.line + M - 1, 1 / 0));
        }
        for (var A = 0, E = g.line; E < b.line; E++) {
          A = bt(f, g.line);
          var I = "", D = 0;
          if (!d.keepSpaces) {
            var H = f.getLine(g.line + 1);
            D = H.search(/\S/), D == -1 ? D = H.length : I = " ";
          }
          f.replaceRange(I, new e(g.line, A), new e(g.line + 1, D));
        }
        var j = $t(f, new e(g.line, A));
        m.visualMode && ir(f, false), f.setCursor(j);
      },
      newLineAndEnterInsertMode: function(f, d, m) {
        m.insertMode = true;
        var g = ze(f.getCursor());
        if (g.line === f.firstLine() && !d.after)
          f.replaceRange(`
`, new e(f.firstLine(), 0)), f.setCursor(f.firstLine(), 0);
        else {
          g.line = d.after ? g.line : g.line - 1, g.ch = bt(f, g.line), f.setCursor(g);
          var b = t.commands.newlineAndIndentContinueComment || t.commands.newlineAndIndent;
          b(f);
        }
        this.enterInsertMode(f, {
          repeat: d.repeat
        }, m);
      },
      paste: function(f, d, m) {
        var g = V.registerController.getRegister(d.registerName);
        if (d.registerName === "+")
          navigator.clipboard.readText().then((S) => {
            this.continuePaste(f, d, m, S, g);
          });
        else {
          var b = g.toString();
          this.continuePaste(f, d, m, b, g);
        }
      },
      continuePaste: function(f, d, m, g, b) {
        var S = ze(f.getCursor());
        if (!!g) {
          if (d.matchIndent) {
            var M = f.getOption("tabSize"), A = function(qt) {
              var ar = qt.split("	").length - 1, hs = qt.split(" ").length - 1;
              return ar * M + hs * 1;
            }, E = f.getLine(f.getCursor().line), I = A(E.match(/^\s*/)[0]), D = g.replace(/\n$/, ""), H = g !== D, j = A(g.match(/^\s*/)[0]), g = D.replace(/^\s*/gm, function(qt) {
              var ar = I + (A(qt) - j);
              if (ar < 0)
                return "";
              if (f.getOption("indentWithTabs")) {
                var hs = Math.floor(ar / M);
                return Array(hs + 1).join("	");
              } else
                return Array(ar + 1).join(" ");
            });
            g += H ? `
` : "";
          }
          d.repeat > 1 && (g = Array(d.repeat + 1).join(g));
          var W = b.linewise, $ = b.blockwise, X = $ ? g.split(`
`) : void 0;
          if (X) {
            W && X.pop();
            for (var Q = 0; Q < X.length; Q++)
              X[Q] = X[Q] == "" ? " " : X[Q];
            S.ch += d.after ? 1 : 0, S.ch = Math.min(bt(f, S.line), S.ch);
          } else
            W ? m.visualMode ? g = m.visualLine ? g.slice(0, -1) : `
` + g.slice(0, g.length - 1) + `
` : d.after ? (g = `
` + g.slice(0, g.length - 1), S.ch = bt(f, S.line)) : S.ch = 0 : S.ch += d.after ? 1 : 0;
          var xe;
          if (m.visualMode) {
            m.lastPastedText = g;
            var he, Ae = rg(f), Le = Ae[0], Pe = Ae[1], ut = f.getSelection(), pt = f.listSelections(), Fe = new Array(pt.length).join("1").split("1");
            m.lastSelection && (he = m.lastSelection.headMark.find()), V.registerController.unnamedRegister.setText(ut), $ ? (f.replaceSelections(Fe), Pe = new e(Le.line + g.length - 1, Le.ch), f.setCursor(Le), Sf(f, Pe), f.replaceSelections(g), xe = Le) : m.visualBlock ? (f.replaceSelections(Fe), f.setCursor(Le), f.replaceRange(g, Le, Le), xe = Le) : (f.replaceRange(g, Le, Pe), xe = f.posFromIndex(f.indexFromPos(Le) + g.length - 1)), he && (m.lastSelection.headMark = f.setBookmark(he)), W && (xe.ch = 0);
          } else if ($ && X) {
            f.setCursor(S);
            for (var Q = 0; Q < X.length; Q++) {
              var Me = S.line + Q;
              Me > f.lastLine() && f.replaceRange(`
`, new e(Me, 0));
              var et = bt(f, Me);
              et < S.ch && tg(f, Me, S.ch);
            }
            f.setCursor(S), Sf(f, new e(S.line + X.length - 1, S.ch)), f.replaceSelections(X), xe = S;
          } else if (f.replaceRange(g, S), W) {
            var Me = d.after ? S.line + 1 : S.line;
            xe = new e(Me, or(f.getLine(Me)));
          } else
            xe = ze(S), /\n/.test(g) || (xe.ch += g.length - (d.after ? 1 : 0));
          m.visualMode && ir(f, false), f.setCursor(xe);
        }
      },
      undo: function(f, d) {
        f.operation(function() {
          xf(f, t.commands.undo, d.repeat)(), f.setCursor($t(f, f.getCursor("start")));
        });
      },
      redo: function(f, d) {
        xf(f, t.commands.redo, d.repeat)();
      },
      setRegister: function(f, d, m) {
        m.inputState.registerName = d.selectedCharacter;
      },
      insertRegister: function(f, d, m) {
        var g = d.selectedCharacter, b = V.registerController.getRegister(g), S = b && b.toString();
        S && f.replaceSelection(S);
      },
      oneNormalCommand: function(f, d, m) {
        Zr(f, true), m.insertModeReturn = true, t.on(f, "vim-command-done", function g() {
          m.visualMode || (m.insertModeReturn && (m.insertModeReturn = false, m.insertMode || lo.enterInsertMode(f, {}, m)), t.off(f, "vim-command-done", g));
        });
      },
      setMark: function(f, d, m) {
        var g = d.selectedCharacter;
        g && Pn(f, m, g, f.getCursor());
      },
      replace: function(f, d, m) {
        var g = d.selectedCharacter || "", b = f.getCursor(), S, M, A = f.listSelections();
        if (m.visualMode)
          b = f.getCursor("start"), M = f.getCursor("end");
        else {
          var E = f.getLine(b.line);
          S = b.ch + d.repeat, S > E.length && (S = E.length), M = new e(b.line, S);
        }
        var I = n(f, b, M);
        if (b = I.start, M = I.end, g == `
`)
          m.visualMode || f.replaceRange("", b, M), (t.commands.newlineAndIndentContinueComment || t.commands.newlineAndIndent)(f);
        else {
          var D = f.getRange(b, M);
          if (D = D.replace(/[\uD800-\uDBFF][\uDC00-\uDFFF]/g, g), D = D.replace(/[^\n]/g, g), m.visualBlock) {
            var H = new Array(f.getOption("tabSize") + 1).join(" ");
            D = f.getSelection(), D = D.replace(/[\uD800-\uDBFF][\uDC00-\uDFFF]/g, g);
            var j = D.replace(/\t/g, H).replace(/[^\n]/g, g).split(`
`);
            f.replaceSelections(j);
          } else
            f.replaceRange(D, b, M);
          m.visualMode ? (b = ct(A[0].anchor, A[0].head) ? A[0].anchor : A[0].head, f.setCursor(b), ir(f, false)) : f.setCursor(dt(M, 0, -1));
        }
      },
      incrementNumberToken: function(f, d) {
        for (var m = f.getCursor(), g = f.getLine(m.line), b = /(-?)(?:(0x)([\da-f]+)|(0b|0|)(\d+))/gi, S, M, A, E; (S = b.exec(g)) !== null && (M = S.index, A = M + S[0].length, !(m.ch < A)); )
          ;
        if (!(!d.backtrack && A <= m.ch)) {
          if (S) {
            var I = S[2] || S[4], D = S[3] || S[5], H = d.increase ? 1 : -1, j = {
              "0b": 2,
              0: 8,
              "": 10,
              "0x": 16
            }[I.toLowerCase()], W = parseInt(S[1] + D, j) + H * d.repeat;
            E = W.toString(j);
            var $ = I ? new Array(D.length - E.length + 1 + S[1].length).join("0") : "";
            E.charAt(0) === "-" ? E = "-" + I + $ + E.substr(1) : E = I + $ + E;
            var X = new e(m.line, M), Q = new e(m.line, A);
            f.replaceRange(E, X, Q);
          } else
            return;
          f.setCursor(new e(m.line, M + E.length - 1));
        }
      },
      repeatLastEdit: function(f, d, m) {
        var g = m.lastEditInputState;
        if (!!g) {
          var b = d.repeat;
          b && d.repeatIsExplicit ? g.repeatOverride = b : b = g.repeatOverride || b, Hf(f, m, b, false);
        }
      },
      indent: function(f, d) {
        f.indentLine(f.getCursor().line, d.indentRight);
      },
      exitInsertMode: function(f, d) {
        Zr(f);
      }
    };
    function ea(f, d) {
      lo[f] = d;
    }
    function $t(f, d, m) {
      var g = f.state.vim, b = g.insertMode || g.visualMode, S = Math.min(Math.max(f.firstLine(), d.line), f.lastLine()), M = f.getLine(S), A = M.length - 1 + Number(!!b), E = Math.min(Math.max(0, d.ch), A), I = M.charCodeAt(E);
      if (56320 <= I && I <= 57343) {
        var D = 1;
        m && m.line == S && m.ch > E && (D = -1), E += D, E > A && (E -= 2);
      }
      return new e(S, E);
    }
    function ss(f) {
      var d = {};
      for (var m in f)
        Object.prototype.hasOwnProperty.call(f, m) && (d[m] = f[m]);
      return d;
    }
    function dt(f, d, m) {
      return typeof d == "object" && (m = d.ch, d = d.line), new e(f.line + d, f.ch + m);
    }
    function yf(f, d, m, g) {
      g.operator && (m = "operatorPending");
      for (var b, S = [], M = [], A = re ? d.length - o : 0, E = A; E < d.length; E++) {
        var I = d[E];
        m == "insert" && I.context != "insert" || I.context && I.context != m || g.operator && I.type == "action" || !(b = bf(f, I.keys)) || (b == "partial" && S.push(I), b == "full" && M.push(I));
      }
      return {
        partial: S,
        full: M
      };
    }
    function bf(f, d) {
      const m = d.slice(-11) == "<character>", g = d.slice(-10) == "<register>";
      if (m || g) {
        var b = d.length - (m ? 11 : 10), S = f.slice(0, b), M = d.slice(0, b);
        return S == M && f.length > b ? "full" : M.indexOf(S) == 0 ? "partial" : false;
      } else
        return f == d ? "full" : d.indexOf(f) == 0 ? "partial" : false;
    }
    function eg(f) {
      var d = /^.*(<[^>]+>)$/.exec(f), m = d ? d[1] : f.slice(-1);
      if (m.length > 1)
        switch (m) {
          case "<CR>":
          case "<S-CR>":
            m = `
`;
            break;
          case "<Space>":
          case "<S-Space>":
            m = " ";
            break;
          default:
            m = "";
            break;
        }
      return m;
    }
    function xf(f, d, m) {
      return function() {
        for (var g = 0; g < m; g++)
          d(f);
      };
    }
    function ze(f) {
      return new e(f.line, f.ch);
    }
    function Kt(f, d) {
      return f.ch == d.ch && f.line == d.line;
    }
    function ct(f, d) {
      return f.line < d.line || f.line == d.line && f.ch < d.ch;
    }
    function zt(f, d) {
      return arguments.length > 2 && (d = zt.apply(void 0, Array.prototype.slice.call(arguments, 1))), ct(f, d) ? f : d;
    }
    function Jr(f, d) {
      return arguments.length > 2 && (d = Jr.apply(void 0, Array.prototype.slice.call(arguments, 1))), ct(f, d) ? d : f;
    }
    function Dl(f, d, m) {
      var g = ct(f, d), b = ct(d, m);
      return g && b;
    }
    function bt(f, d) {
      return f.getLine(d).length;
    }
    function Il(f) {
      return f.trim ? f.trim() : f.replace(/^\s+|\s+$/g, "");
    }
    function Ri(f) {
      return f.replace(/([.?*+$\[\]\/\\(){}|\-])/g, "\\$1");
    }
    function tg(f, d, m) {
      var g = bt(f, d), b = new Array(m - g + 1).join(" ");
      f.setCursor(new e(d, g)), f.replaceRange(b, f.getCursor());
    }
    function Sf(f, d) {
      var m = [], g = f.listSelections(), b = ze(f.clipPos(d)), S = !Kt(d, b), M = f.getCursor("head"), A = ng(g, M), E = Kt(g[A].head, g[A].anchor), I = g.length - 1, D = I - A > A ? I : 0, H = g[D].anchor, j = Math.min(H.line, b.line), W = Math.max(H.line, b.line), $ = H.ch, X = b.ch, Q = g[D].head.ch - $, xe = X - $;
      Q > 0 && xe <= 0 ? ($++, S || X--) : Q < 0 && xe >= 0 ? ($--, E || X++) : Q < 0 && xe == -1 && ($--, X++);
      for (var he = j; he <= W; he++) {
        var Ae = {
          anchor: new e(he, $),
          head: new e(he, X)
        };
        m.push(Ae);
      }
      return f.setSelections(m), d.ch = X, H.ch = $, H;
    }
    function wf(f, d, m) {
      for (var g = [], b = 0; b < m; b++) {
        var S = dt(d, b, 0);
        g.push({
          anchor: S,
          head: S
        });
      }
      f.setSelections(g, 0);
    }
    function ng(f, d, m) {
      for (var g = 0; g < f.length; g++) {
        var b = Kt(f[g].anchor, d), S = Kt(f[g].head, d);
        if (b || S)
          return g;
      }
      return -1;
    }
    function rg(f, d) {
      var m = f.listSelections(), g = m[0], b = m[m.length - 1], S = ct(g.anchor, g.head) ? g.anchor : g.head, M = ct(b.anchor, b.head) ? b.head : b.anchor;
      return [
        S,
        M
      ];
    }
    function rr(f, d) {
      var m = d.sel.anchor, g = d.sel.head;
      d.lastPastedText && (g = f.posFromIndex(f.indexFromPos(m) + d.lastPastedText.length), d.lastPastedText = void 0), d.lastSelection = {
        anchorMark: f.setBookmark(m),
        headMark: f.setBookmark(g),
        anchor: ze(m),
        head: ze(g),
        visualMode: d.visualMode,
        visualLine: d.visualLine,
        visualBlock: d.visualBlock
      };
    }
    function ig(f, d, m, g) {
      var b = f.state.vim.sel, S = g ? d : b.head, M = g ? d : b.anchor, A;
      return ct(m, d) && (A = m, m = d, d = A), ct(S, M) ? (S = zt(d, S), M = Jr(M, m)) : (M = zt(d, M), S = Jr(S, m), S = dt(S, 0, -1), S.ch == -1 && S.line != f.firstLine() && (S = new e(S.line - 1, bt(f, S.line - 1)))), [
        M,
        S
      ];
    }
    function co(f, d, m) {
      var g = f.state.vim;
      d = d || g.sel, m || (m = g.visualLine ? "line" : g.visualBlock ? "block" : "char");
      var b = Bl(f, d, m);
      f.setSelections(b.ranges, b.primary);
    }
    function Bl(f, d, m, g) {
      var b = ze(d.head), S = ze(d.anchor);
      if (m == "char") {
        var M = !g && !ct(d.head, d.anchor) ? 1 : 0, A = ct(d.head, d.anchor) ? 1 : 0;
        return b = dt(d.head, 0, M), S = dt(d.anchor, 0, A), {
          ranges: [
            {
              anchor: S,
              head: b
            }
          ],
          primary: 0
        };
      } else if (m == "line") {
        if (ct(d.head, d.anchor))
          b.ch = 0, S.ch = bt(f, S.line);
        else {
          S.ch = 0;
          var E = f.lastLine();
          b.line > E && (b.line = E), b.ch = bt(f, b.line);
        }
        return {
          ranges: [
            {
              anchor: S,
              head: b
            }
          ],
          primary: 0
        };
      } else if (m == "block") {
        var I = Math.min(S.line, b.line), D = S.ch, H = Math.max(S.line, b.line), j = b.ch;
        D < j ? j += 1 : D += 1;
        for (var W = H - I + 1, $ = b.line == I ? 0 : W - 1, X = [], Q = 0; Q < W; Q++)
          X.push({
            anchor: new e(I + Q, D),
            head: new e(I + Q, j)
          });
        return {
          ranges: X,
          primary: $
        };
      }
      throw "never happens";
    }
    function og(f) {
      var d = f.getCursor("head");
      return f.getSelection().length == 1 && (d = zt(d, f.getCursor("anchor"))), d;
    }
    function ir(f, d) {
      var m = f.state.vim;
      d !== false && f.setCursor($t(f, m.sel.head)), rr(f, m), m.visualMode = false, m.visualLine = false, m.visualBlock = false, m.insertMode || t.signal(f, "vim-mode-change", {
        mode: "normal"
      });
    }
    function uo(f, d, m) {
      var g = f.getRange(d, m);
      if (/\n\s*$/.test(g)) {
        var b = g.split(`
`);
        b.pop();
        for (var S = b.pop(); b.length > 0 && S && _(S); S = b.pop())
          m.line--, m.ch = 0;
        S ? (m.line--, m.ch = bt(f, m.line)) : m.ch = 0;
      }
    }
    function sg(f, d, m) {
      d.ch = 0, m.ch = 0, m.line++;
    }
    function or(f) {
      if (!f)
        return 0;
      var d = f.search(/\S/);
      return d == -1 ? f.length : d;
    }
    function Nl(f, { inclusive: d, innerWord: m, bigWord: g, noSymbol: b, multiline: S }, M) {
      var A = M || og(f), E = f.getLine(A.line), I = E, D = A.line, H = D, j = A.ch, W, $ = b ? p[0] : v[0];
      if (m && /\s/.test(E.charAt(j)))
        $ = function(Le) {
          return /\s/.test(Le);
        };
      else {
        for (; !$(E.charAt(j)); )
          if (j++, j >= E.length) {
            if (!S)
              return null;
            j--, W = Tf(f, A, true, g, true);
            break;
          }
        g ? $ = v[0] : ($ = p[0], $(E.charAt(j)) || ($ = p[1]));
      }
      for (var X = j, Q = j; $(E.charAt(Q)) && Q >= 0; )
        Q--;
      if (Q++, W)
        X = W.to, H = W.line, I = f.getLine(H), !I && X == 0 && X++;
      else
        for (; $(E.charAt(X)) && X < E.length; )
          X++;
      if (d) {
        var xe = X, he = A.ch <= Q && /\s/.test(E.charAt(A.ch));
        if (!he)
          for (; /\s/.test(I.charAt(X)) && X < I.length; )
            X++;
        if (xe == X || he) {
          for (var Ae = Q; /\s/.test(E.charAt(Q - 1)) && Q > 0; )
            Q--;
          !Q && !he && (Q = Ae);
        }
      }
      return {
        start: new e(D, Q),
        end: new e(H, X)
      };
    }
    function ag(f, d, m) {
      var g = d;
      if (!t.findMatchingTag || !t.findEnclosingTag)
        return {
          start: g,
          end: g
        };
      var b = t.findMatchingTag(f, d) || t.findEnclosingTag(f, d);
      return !b || !b.open || !b.close ? {
        start: g,
        end: g
      } : m ? {
        start: b.open.from,
        end: b.close.to
      } : {
        start: b.open.to,
        end: b.close.from
      };
    }
    function kf(f, d, m) {
      Kt(d, m) || V.jumpList.add(f, d, m);
    }
    function Li(f, d) {
      V.lastCharacterSearch.increment = f, V.lastCharacterSearch.forward = d.forward, V.lastCharacterSearch.selectedCharacter = d.selectedCharacter;
    }
    var lg = {
      "(": "bracket",
      ")": "bracket",
      "{": "bracket",
      "}": "bracket",
      "[": "section",
      "]": "section",
      "*": "comment",
      "/": "comment",
      m: "method",
      M: "method",
      "#": "preprocess"
    }, Cf = {
      bracket: {
        isComplete: function(f) {
          if (f.nextCh === f.symb) {
            if (f.depth++, f.depth >= 1)
              return true;
          } else
            f.nextCh === f.reverseSymb && f.depth--;
          return false;
        }
      },
      section: {
        init: function(f) {
          f.curMoveThrough = true, f.symb = (f.forward ? "]" : "[") === f.symb ? "{" : "}";
        },
        isComplete: function(f) {
          return f.index === 0 && f.nextCh === f.symb;
        }
      },
      comment: {
        isComplete: function(f) {
          var d = f.lastCh === "*" && f.nextCh === "/";
          return f.lastCh = f.nextCh, d;
        }
      },
      method: {
        init: function(f) {
          f.symb = f.symb === "m" ? "{" : "}", f.reverseSymb = f.symb === "{" ? "}" : "{";
        },
        isComplete: function(f) {
          return f.nextCh === f.symb;
        }
      },
      preprocess: {
        init: function(f) {
          f.index = 0;
        },
        isComplete: function(f) {
          var _a3;
          if (f.nextCh === "#") {
            var d = (_a3 = f.lineText.match(/^#(\w+)/)) == null ? void 0 : _a3[1];
            if (d === "endif") {
              if (f.forward && f.depth === 0)
                return true;
              f.depth++;
            } else if (d === "if") {
              if (!f.forward && f.depth === 0)
                return true;
              f.depth--;
            }
            if (d === "else" && f.depth === 0)
              return true;
          }
          return false;
        }
      }
    };
    function cg(f, d, m, g) {
      var b = ze(f.getCursor()), S = m ? 1 : -1, M = m ? f.lineCount() : -1, A = b.ch, E = b.line, I = f.getLine(E), D = {
        lineText: I,
        nextCh: I.charAt(A),
        lastCh: null,
        index: A,
        symb: g,
        reverseSymb: (m ? {
          ")": "(",
          "}": "{"
        } : {
          "(": ")",
          "{": "}"
        })[g],
        forward: m,
        depth: 0,
        curMoveThrough: false
      }, H = lg[g];
      if (!H)
        return b;
      var j = Cf[H].init, W = Cf[H].isComplete;
      for (j && j(D); E !== M && d; ) {
        if (D.index += S, D.nextCh = D.lineText.charAt(D.index), !D.nextCh) {
          if (E += S, D.lineText = f.getLine(E) || "", S > 0)
            D.index = 0;
          else {
            var $ = D.lineText.length;
            D.index = $ > 0 ? $ - 1 : 0;
          }
          D.nextCh = D.lineText.charAt(D.index);
        }
        W(D) && (b.line = E, b.ch = D.index, d--);
      }
      return D.nextCh || D.curMoveThrough ? new e(E, D.index) : b;
    }
    function Tf(f, d, m, g, b) {
      var S = d.line, M = d.ch, A = f.getLine(S), E = m ? 1 : -1, I = g ? v : p;
      if (b && A == "") {
        if (S += E, A = f.getLine(S), !k(f, S))
          return null;
        M = m ? 0 : A.length;
      }
      for (; ; ) {
        if (b && A == "")
          return {
            from: 0,
            to: 0,
            line: S
          };
        for (var D = E > 0 ? A.length : -1, H = D, j = D; M != D; ) {
          for (var W = false, $ = 0; $ < I.length && !W; ++$)
            if (I[$](A.charAt(M))) {
              for (H = M; M != D && I[$](A.charAt(M)); )
                M += E;
              if (j = M, W = H != j, H == d.ch && S == d.line && j == H + E)
                continue;
              return {
                from: Math.min(H, j + 1),
                to: Math.max(H, j),
                line: S
              };
            }
          W || (M += E);
        }
        if (S += E, !k(f, S))
          return null;
        A = f.getLine(S), M = E > 0 ? 0 : A.length;
      }
    }
    function ug(f, d, m, g, b, S) {
      var M = ze(d), A = [];
      (g && !b || !g && b) && m++;
      for (var E = !(g && b), I = 0; I < m; I++) {
        var D = Tf(f, d, g, S, E);
        if (!D) {
          var H = bt(f, f.lastLine());
          A.push(g ? {
            line: f.lastLine(),
            from: H,
            to: H
          } : {
            line: 0,
            from: 0,
            to: 0
          });
          break;
        }
        A.push(D), d = new e(D.line, g ? D.to - 1 : D.from);
      }
      var j = A.length != m, W = A[0], $ = A.pop();
      return g && !b ? (!j && (W.from != M.ch || W.line != M.line) && ($ = A.pop()), $ && new e($.line, $.from)) : g && b ? $ && new e($.line, $.to - 1) : !g && b ? (!j && (W.to != M.ch || W.line != M.line) && ($ = A.pop()), $ && new e($.line, $.to)) : $ && new e($.line, $.from);
    }
    function Mf(f, d, m, g, b) {
      var S = d, M = new e(S.line + m.repeat - 1, 1 / 0), A = f.clipPos(M);
      return A.ch--, b || (g.lastHPos = 1 / 0, g.lastHSPos = f.charCoords(A, "div").left), M;
    }
    function as(f, d, m, g, b) {
      if (!!g) {
        for (var S = b || f.getCursor(), M = S.ch, A, E = 0; E < d; E++) {
          var I = f.getLine(S.line);
          if (A = $l(M, I, g, m), A == -1)
            return;
          M = A;
        }
        if (A != null)
          return new e(f.getCursor().line, A);
      }
    }
    function fg(f, d) {
      var m = f.getCursor().line;
      return $t(f, new e(m, d - 1));
    }
    function Pn(f, d, m, g) {
      !K(m, y) && !T.test(m) || (d.marks[m] && d.marks[m].clear(), d.marks[m] = f.setBookmark(g));
    }
    function $l(f, d, m, g, b) {
      var S;
      return g ? S = d.indexOf(m, f + 1) : S = d.lastIndexOf(m, f - 1), S;
    }
    function Af(f, d, m, g, b) {
      var S = d.line, M = f.firstLine(), A = f.lastLine(), E, I, D = S;
      function H(Q) {
        return !f.getLine(Q);
      }
      function j(Q, xe, he) {
        return he ? H(Q) != H(Q + xe) : !H(Q) && H(Q + xe);
      }
      if (g) {
        for (; M <= D && D <= A && m > 0; )
          j(D, g) && m--, D += g;
        return {
          start: new e(D, 0),
          end: d
        };
      }
      var W = f.state.vim;
      if (W.visualLine && j(S, 1, true)) {
        var $ = W.sel.anchor;
        j($.line, -1, true) && (!b || $.line != S) && (S += 1);
      }
      var X = H(S);
      for (D = S; D <= A && m; D++)
        j(D, 1, true) && (!b || H(D) != X) && m--;
      for (I = new e(D, 0), D > A && !X ? X = true : b = false, D = S; D > M && !((!b || H(D) == X || D == S) && j(D, -1, true)); D--)
        ;
      return E = new e(D, 0), {
        start: E,
        end: I
      };
    }
    function ls(f, d, m, g, b) {
      function S(I) {
        I.line !== null && (I.pos + I.dir < 0 || I.pos + I.dir >= I.line.length ? I.line = null : I.pos += I.dir);
      }
      function M(I, D, H, j) {
        var W = I.getLine(D), $ = {
          line: W,
          ln: D,
          pos: H,
          dir: j
        };
        if ($.line === "")
          return {
            ln: $.ln,
            pos: $.pos
          };
        var X = $.pos;
        for (S($); $.line !== null; ) {
          if (X = $.pos, F($.line[$.pos]))
            if (b) {
              for (S($); $.line !== null && _($.line[$.pos]); )
                X = $.pos, S($);
              return {
                ln: $.ln,
                pos: X + 1
              };
            } else
              return {
                ln: $.ln,
                pos: $.pos + 1
              };
          S($);
        }
        return {
          ln: $.ln,
          pos: X + 1
        };
      }
      function A(I, D, H, j) {
        var W = I.getLine(D), $ = {
          line: W,
          ln: D,
          pos: H,
          dir: j
        };
        if ($.line === "")
          return {
            ln: $.ln,
            pos: $.pos
          };
        var X = $.pos;
        for (S($); $.line !== null; ) {
          if (!_($.line[$.pos]) && !F($.line[$.pos]))
            X = $.pos;
          else if (F($.line[$.pos]))
            return b ? _($.line[$.pos + 1]) ? {
              ln: $.ln,
              pos: $.pos + 1
            } : {
              ln: $.ln,
              pos: X
            } : {
              ln: $.ln,
              pos: X
            };
          S($);
        }
        return $.line = W, b && _($.line[$.pos]) ? {
          ln: $.ln,
          pos: $.pos
        } : {
          ln: $.ln,
          pos: X
        };
      }
      for (var E = {
        ln: d.line,
        pos: d.ch
      }; m > 0; )
        g < 0 ? E = A(f, E.ln, E.pos, g) : E = M(f, E.ln, E.pos, g), m--;
      return new e(E.ln, E.pos);
    }
    function Ef(f, d, m, g) {
      function b(E, I) {
        if (I.line !== null)
          if (I.pos + I.dir < 0 || I.pos + I.dir >= I.line.length) {
            if (I.ln += I.dir, !k(E, I.ln)) {
              I.line = null;
              return;
            }
            I.line = E.getLine(I.ln), I.pos = I.dir > 0 ? 0 : I.line.length - 1;
          } else
            I.pos += I.dir;
      }
      function S(E, I, D, H) {
        var Q = E.getLine(I), j = Q === "", W = {
          line: Q,
          ln: I,
          pos: D,
          dir: H
        }, $ = {
          ln: W.ln,
          pos: W.pos
        }, X = W.line === "";
        for (b(E, W); W.line !== null; ) {
          if ($.ln = W.ln, $.pos = W.pos, W.line === "" && !X)
            return {
              ln: W.ln,
              pos: W.pos
            };
          if (j && W.line !== "" && !_(W.line[W.pos]))
            return {
              ln: W.ln,
              pos: W.pos
            };
          F(W.line[W.pos]) && !j && (W.pos === W.line.length - 1 || _(W.line[W.pos + 1])) && (j = true), b(E, W);
        }
        var Q = E.getLine($.ln);
        $.pos = 0;
        for (var xe = Q.length - 1; xe >= 0; --xe)
          if (!_(Q[xe])) {
            $.pos = xe;
            break;
          }
        return $;
      }
      function M(E, I, D, H) {
        var Q = E.getLine(I), j = {
          line: Q,
          ln: I,
          pos: D,
          dir: H
        }, W = j.ln, $ = null, X = j.line === "";
        for (b(E, j); j.line !== null; ) {
          if (j.line === "" && !X)
            return $ !== null ? {
              ln: W,
              pos: $
            } : {
              ln: j.ln,
              pos: j.pos
            };
          if (F(j.line[j.pos]) && $ !== null && !(j.ln === W && j.pos + 1 === $))
            return {
              ln: W,
              pos: $
            };
          j.line !== "" && !_(j.line[j.pos]) && (X = false, W = j.ln, $ = j.pos), b(E, j);
        }
        var Q = E.getLine(W);
        $ = 0;
        for (var xe = 0; xe < Q.length; ++xe)
          if (!_(Q[xe])) {
            $ = xe;
            break;
          }
        return {
          ln: W,
          pos: $
        };
      }
      for (var A = {
        ln: d.line,
        pos: d.ch
      }; m > 0; )
        g < 0 ? A = M(f, A.ln, A.pos, g) : A = S(f, A.ln, A.pos, g), m--;
      return new e(A.ln, A.pos);
    }
    function Pf(f, d, m, g) {
      var b = d, S = {
        "(": /[()]/,
        ")": /[()]/,
        "[": /[[\]]/,
        "]": /[[\]]/,
        "{": /[{}]/,
        "}": /[{}]/,
        "<": /[<>]/,
        ">": /[<>]/
      }[m], M = {
        "(": "(",
        ")": "(",
        "[": "[",
        "]": "[",
        "{": "{",
        "}": "{",
        "<": "<",
        ">": "<"
      }[m], A = f.getLine(b.line).charAt(b.ch), E = A === M ? 1 : 0, I = f.scanForBracket(new e(b.line, b.ch + E), -1, void 0, {
        bracketRegex: S
      }), D = f.scanForBracket(new e(b.line, b.ch + E), 1, void 0, {
        bracketRegex: S
      });
      if (!I || !D)
        return null;
      var H = I.pos, j = D.pos;
      if (H.line == j.line && H.ch > j.ch || H.line > j.line) {
        var W = H;
        H = j, j = W;
      }
      return g ? j.ch += 1 : H.ch += 1, {
        start: H,
        end: j
      };
    }
    function hg(f, d, m, g) {
      var b = ze(d), S = f.getLine(b.line), M = S.split(""), A, E, I, D, H = M.indexOf(m);
      if (b.ch < H)
        b.ch = H;
      else if (H < b.ch && M[b.ch] == m) {
        var j = /string/.test(f.getTokenTypeAt(dt(d, 0, 1))), W = /string/.test(f.getTokenTypeAt(d)), $ = j && !W;
        $ || (E = b.ch, --b.ch);
      }
      if (M[b.ch] == m && !E)
        A = b.ch + 1;
      else
        for (I = b.ch; I > -1 && !A; I--)
          M[I] == m && (A = I + 1);
      if (A && !E)
        for (I = A, D = M.length; I < D && !E; I++)
          M[I] == m && (E = I);
      return !A || !E ? {
        start: b,
        end: b
      } : (g && (--A, ++E), {
        start: new e(b.line, A),
        end: new e(b.line, E)
      });
    }
    te("pcre", true, "boolean");
    class dg {
      constructor() {
        this.highlightTimeout;
      }
      getQuery() {
        return V.query;
      }
      setQuery(d) {
        V.query = d;
      }
      getOverlay() {
        return this.searchOverlay;
      }
      setOverlay(d) {
        this.searchOverlay = d;
      }
      isReversed() {
        return V.isReversed;
      }
      setReversed(d) {
        V.isReversed = d;
      }
      getScrollbarAnnotate() {
        return this.annotate;
      }
      setScrollbarAnnotate(d) {
        this.annotate = d;
      }
    }
    function On(f) {
      var d = f.state.vim;
      return d.searchState_ || (d.searchState_ = new dg());
    }
    function pg(f) {
      return Of(f, "/");
    }
    function mg(f) {
      return Rf(f, "/");
    }
    function Of(f, d) {
      var m = Rf(f, d) || [];
      if (!m.length)
        return [];
      var g = [];
      if (m[0] === 0) {
        for (var b = 0; b < m.length; b++)
          typeof m[b] == "number" && g.push(f.substring(m[b] + 1, m[b + 1]));
        return g;
      }
    }
    function Rf(f, d) {
      d || (d = "/");
      for (var m = false, g = [], b = 0; b < f.length; b++) {
        var S = f.charAt(b);
        !m && S == d && g.push(b), m = !m && S == "\\";
      }
      return g;
    }
    function gg(f) {
      var d = {
        V: "|(){+?*.[$^",
        M: "|(){+?*.[",
        m: "|(){+?",
        v: "<>"
      }, m = {
        ">": "(?<=[\\w])(?=[^\\w]|$)",
        "<": "(?<=[^\\w]|^)(?=[\\w])"
      }, g = d.m, b = f.replace(/\\.|[\[|(){+*?.$^<>]/g, function(M) {
        if (M[0] === "\\") {
          var A = M[1];
          return A === "}" || g.indexOf(A) != -1 ? A : A in d ? (g = d[A], "") : A in m ? m[A] : M;
        } else
          return g.indexOf(M) != -1 ? m[M] || "\\" + M : M;
      }), S = b.indexOf("\\zs");
      return S != -1 && (b = "(?<=" + b.slice(0, S) + ")" + b.slice(S + 3)), S = b.indexOf("\\ze"), S != -1 && (b = b.slice(0, S) + "(?=" + b.slice(S + 3) + ")"), b;
    }
    var Lf = {
      "\\n": `
`,
      "\\r": "\r",
      "\\t": "	"
    };
    function vg(f) {
      for (var d = false, m = [], g = -1; g < f.length; g++) {
        var b = f.charAt(g) || "", S = f.charAt(g + 1) || "";
        Lf[b + S] ? (m.push(Lf[b + S]), g++) : d ? (m.push(b), d = false) : b === "\\" ? (d = true, R(S) || S === "$" ? m.push("$") : S !== "/" && S !== "\\" && m.push("\\")) : (b === "$" && m.push("$"), m.push(b), S === "/" && m.push("\\"));
      }
      return m.join("");
    }
    var _f2 = {
      "\\/": "/",
      "\\\\": "\\",
      "\\n": `
`,
      "\\r": "\r",
      "\\t": "	",
      "\\&": "&"
    };
    function yg(f) {
      for (var d = new t.StringStream(f), m = []; !d.eol(); ) {
        for (; d.peek() && d.peek() != "\\"; )
          m.push(d.next());
        var g = false;
        for (var b in _f2)
          if (d.match(b, true)) {
            g = true, m.push(_f2[b]);
            break;
          }
        g || m.push(d.next());
      }
      return m.join("");
    }
    function Df(f, d, m) {
      var g = V.registerController.getRegister("/");
      g.setText(f);
      var b = mg(f), S, M;
      if (!b.length)
        S = f;
      else {
        S = f.substring(0, b[0]);
        var A = f.substring(b[0]);
        M = A.indexOf("i") != -1;
      }
      if (!S)
        return null;
      ae("pcre") || (S = gg(S)), m && (d = /^[^A-Z]*$/.test(S));
      var E = new RegExp(S, d || M ? "im" : "m");
      return E;
    }
    function on(f) {
      typeof f == "string" && (f = document.createElement(f));
      for (var d = 1; d < arguments.length; d++) {
        var m = arguments[d];
        if (!!m)
          if (typeof m != "object" && (m = document.createTextNode(m)), m.nodeType)
            f.appendChild(m);
          else
            for (var g in m)
              !Object.prototype.hasOwnProperty.call(m, g) || (g[0] === "$" ? f.style[g.slice(1)] = m[g] : typeof m[g] == "function" ? f[g] = m[g] : f.setAttribute(g, m[g]));
      }
      return f;
    }
    function De(f, d, m) {
      var g = on("div", {
        $color: "red",
        $whiteSpace: "pre",
        class: "cm-vim-message"
      }, d);
      f.openNotification ? m ? (g = on("div", {}, g, on("div", {}, "Press ENTER or type command to continue")), f.state.closeVimNotification && f.state.closeVimNotification(), f.state.closeVimNotification = f.openNotification(g, {
        bottom: true,
        duration: 0
      })) : f.openNotification(g, {
        bottom: true,
        duration: 15e3
      }) : alert(g.innerText);
    }
    function bg(f, d) {
      return on("div", {
        $display: "flex",
        $flex: 1
      }, on("span", {
        $fontFamily: "monospace",
        $whiteSpace: "pre",
        $flex: 1,
        $display: "flex"
      }, f, on("input", {
        type: "text",
        autocorrect: "off",
        autocapitalize: "off",
        spellcheck: "false",
        $flex: 1
      })), d && on("span", {
        $color: "#888"
      }, d));
    }
    function ta(f, d) {
      var _a3;
      if (le.length) {
        d.value || (d.value = ""), se = d;
        return;
      }
      var m = bg(d.prefix, d.desc);
      if (f.openDialog)
        f.openDialog(m, d.onClose, {
          onKeyDown: d.onKeyDown,
          onKeyUp: d.onKeyUp,
          bottom: true,
          selectValueOnOpen: false,
          value: d.value
        });
      else {
        var g = "";
        typeof d.prefix != "string" && d.prefix && (g += d.prefix.textContent), d.desc && (g += " " + d.desc), (_a3 = d.onClose) == null ? void 0 : _a3.call(d, prompt(g, ""));
      }
    }
    function If(f, d) {
      return f instanceof RegExp && d instanceof RegExp ? f.flags == d.flags && f.source == d.source : false;
    }
    function cs(f, d, m, g) {
      if (!!d) {
        var b = On(f), S = Df(d, !!m, !!g);
        if (!!S)
          return na(f, S), If(S, b.getQuery()) || b.setQuery(S), S;
      }
    }
    function xg(f) {
      if (f.source.charAt(0) == "^")
        var d = true;
      return {
        token: function(m) {
          if (d && !m.sol()) {
            m.skipToEnd();
            return;
          }
          var g = m.match(f, false);
          if (g)
            return g[0].length == 0 ? (m.next(), "searching") : !m.sol() && (m.backUp(1), !f.exec(m.next() + g[0])) ? (m.next(), null) : (m.match(f), "searching");
          for (; !m.eol() && (m.next(), !m.match(f, false)); )
            ;
        },
        query: f
      };
    }
    var us = 0;
    function na(f, d) {
      clearTimeout(us);
      var m = On(f);
      m.highlightTimeout = us, us = setTimeout(function() {
        if (!!f.state.vim) {
          var g = On(f);
          g.highlightTimeout = void 0;
          var b = g.getOverlay();
          (!b || d != b.query) && (b && f.removeOverlay(b), b = xg(d), f.addOverlay(b), f.showMatchesOnScrollbar && (g.getScrollbarAnnotate() && g.getScrollbarAnnotate().clear(), g.setScrollbarAnnotate(f.showMatchesOnScrollbar(d))), g.setOverlay(b));
        }
      }, 50);
    }
    function Bf(f, d, m, g) {
      return f.operation(function() {
        g === void 0 && (g = 1);
        for (var b = f.getCursor(), S = f.getSearchCursor(m, b), M = 0; M < g; M++) {
          var A = S.find(d);
          if (M == 0 && A && Kt(S.from(), b)) {
            var E = d ? S.from() : S.to();
            A = S.find(d), A && !A[0] && Kt(S.from(), E) && f.getLine(E.line).length == E.ch && (A = S.find(d));
          }
          if (!A && (S = f.getSearchCursor(m, d ? new e(f.lastLine()) : new e(f.firstLine(), 0)), !S.find(d)))
            return;
        }
        return S.from();
      });
    }
    function Sg(f, d, m, g, b) {
      return f.operation(function() {
        g === void 0 && (g = 1);
        var S = f.getCursor(), M = f.getSearchCursor(m, S), A = M.find(!d);
        !b.visualMode && A && Kt(M.from(), S) && M.find(!d);
        for (var E = 0; E < g; E++)
          if (A = M.find(d), !A && (M = f.getSearchCursor(m, d ? new e(f.lastLine()) : new e(f.firstLine(), 0)), !M.find(d)))
            return;
        var I = M.from(), D = M.to();
        return I && D && [
          I,
          D
        ];
      });
    }
    function fo(f) {
      var d = On(f);
      d.highlightTimeout && (clearTimeout(d.highlightTimeout), d.highlightTimeout = void 0), f.removeOverlay(On(f).getOverlay()), d.setOverlay(null), d.getScrollbarAnnotate() && (d.getScrollbarAnnotate().clear(), d.setScrollbarAnnotate(null));
    }
    function zl(f, d, m) {
      return typeof f != "number" && (f = f.line), d instanceof Array ? K(f, d) : typeof m == "number" ? f >= d && f <= m : f == d;
    }
    function Fl(f) {
      var d = f.getScrollInfo(), m = 6, g = 10, b = f.coordsChar({
        left: 0,
        top: m + d.top
      }, "local"), S = d.clientHeight - g + d.top, M = f.coordsChar({
        left: 0,
        top: S
      }, "local");
      return {
        top: b.line,
        bottom: M.line
      };
    }
    function ra(f, d, m) {
      if (m == "'" || m == "`")
        return V.jumpList.find(f, -1) || new e(0, 0);
      if (m == ".")
        return Nf(f);
      var g = d.marks[m];
      return g && g.find();
    }
    function Nf(f) {
      if (f.getLastEditEnd)
        return f.getLastEditEnd();
      for (var d = f.doc.history.done, m = d.length; m--; )
        if (d[m].changes)
          return ze(d[m].changes[0].to);
    }
    class ia {
      constructor() {
        this.commandMap_, this.buildCommandMap_();
      }
      processCommand(d, m, g) {
        var b = this;
        d.operation(function() {
          d.curOp && (d.curOp.isVimOp = true), b._processCommand(d, m, g);
        });
      }
      _processCommand(d, m, g) {
        var b = d.state.vim, S = V.registerController.getRegister(":"), M = S.toString(), A = new t.StringStream(m);
        S.setText(m);
        var E = g || {};
        E.input = m;
        try {
          this.parseInput_(d, A, E);
        } catch (H) {
          throw De(d, H + ""), H;
        }
        b.visualMode && ir(d);
        var I, D;
        if (!E.commandName)
          E.line !== void 0 && (D = "move");
        else if (I = this.matchCommand_(E.commandName), I) {
          if (D = I.name, I.excludeFromCommandHistory && S.setText(M), this.parseCommandArgs_(A, E, I), I.type == "exToKey") {
            yt(d, I.toKeys || "", I);
            return;
          } else if (I.type == "exToEx") {
            this.processCommand(d, I.toInput || "");
            return;
          }
        }
        if (!D) {
          De(d, 'Not an editor command ":' + m + '"');
          return;
        }
        try {
          oa[D](d, E), (!I || !I.possiblyAsync) && E.callback && E.callback();
        } catch (H) {
          throw De(d, H + ""), H;
        }
      }
      parseInput_(d, m, g) {
        var _a3, _b3;
        m.eatWhile(":"), m.eat("%") ? (g.line = d.firstLine(), g.lineEnd = d.lastLine()) : (g.line = this.parseLineSpec_(d, m), g.line !== void 0 && m.eat(",") && (g.lineEnd = this.parseLineSpec_(d, m))), g.line == null ? d.state.vim.visualMode ? (g.selectionLine = (_a3 = ra(d, d.state.vim, "<")) == null ? void 0 : _a3.line, g.selectionLineEnd = (_b3 = ra(d, d.state.vim, ">")) == null ? void 0 : _b3.line) : g.selectionLine = d.getCursor().line : (g.selectionLine = g.line, g.selectionLineEnd = g.lineEnd);
        var b = m.match(/^(\w+|!!|@@|[!#&*<=>@~])/);
        return b ? g.commandName = b[1] : g.commandName = (m.match(/.*/) || [
          ""
        ])[0], g;
      }
      parseLineSpec_(d, m) {
        var g = m.match(/^(\d+)/);
        if (g)
          return parseInt(g[1], 10) - 1;
        switch (m.next()) {
          case ".":
            return this.parseLineSpecOffset_(m, d.getCursor().line);
          case "$":
            return this.parseLineSpecOffset_(m, d.lastLine());
          case "'":
            var b = m.next() || "", S = ra(d, d.state.vim, b);
            if (!S)
              throw new Error("Mark not set");
            return this.parseLineSpecOffset_(m, S.line);
          case "-":
          case "+":
            return m.backUp(1), this.parseLineSpecOffset_(m, d.getCursor().line);
          default:
            m.backUp(1);
            return;
        }
      }
      parseLineSpecOffset_(d, m) {
        var g = d.match(/^([+-])?(\d+)/);
        if (g) {
          var b = parseInt(g[2], 10);
          g[1] == "-" ? m -= b : m += b;
        }
        return m;
      }
      parseCommandArgs_(d, m, g) {
        var _a3;
        if (!d.eol()) {
          m.argString = (_a3 = d.match(/.*/)) == null ? void 0 : _a3[0];
          var b = g.argDelimiter || /\s+/, S = Il(m.argString || "").split(b);
          S.length && S[0] && (m.args = S);
        }
      }
      matchCommand_(d) {
        for (var m = d.length; m > 0; m--) {
          var g = d.substring(0, m);
          if (this.commandMap_[g]) {
            var b = this.commandMap_[g];
            if (b.name.indexOf(d) === 0)
              return b;
          }
        }
      }
      buildCommandMap_() {
        this.commandMap_ = {};
        for (var d = 0; d < s.length; d++) {
          var m = s[d], g = m.shortName || m.name;
          this.commandMap_[g] = m;
        }
      }
      map(d, m, g, b) {
        if (d != ":" && d.charAt(0) == ":") {
          if (g)
            throw Error("Mode not supported for ex mappings");
          var S = d.substring(1);
          m != ":" && m.charAt(0) == ":" ? this.commandMap_[S] = {
            name: S,
            type: "exToEx",
            toInput: m.substring(1),
            user: true
          } : this.commandMap_[S] = {
            name: S,
            type: "exToKey",
            toKeys: m,
            user: true
          };
        } else {
          var M = {
            keys: d,
            type: "keyToKey",
            toKeys: m,
            noremap: !!b
          };
          g && (M.context = g), sa(M);
        }
      }
      unmap(d, m) {
        if (d != ":" && d.charAt(0) == ":") {
          if (m)
            throw Error("Mode not supported for ex mappings");
          var g = d.substring(1);
          if (this.commandMap_[g] && this.commandMap_[g].user)
            return delete this.commandMap_[g], true;
        } else
          for (var b = d, S = 0; S < r.length; S++)
            if (b == r[S].keys && r[S].context === m)
              return r.splice(S, 1), $f(b), true;
      }
    }
    var oa = {
      colorscheme: function(f, d) {
        if (!d.args || d.args.length < 1) {
          De(f, f.getOption("theme"));
          return;
        }
        f.setOption("theme", d.args[0]);
      },
      map: function(f, d, m, g) {
        var b = d.args;
        if (!b || b.length < 2) {
          f && De(f, "Invalid mapping: " + d.input);
          return;
        }
        Ft.map(b[0], b[1], m, g);
      },
      imap: function(f, d) {
        this.map(f, d, "insert");
      },
      nmap: function(f, d) {
        this.map(f, d, "normal");
      },
      vmap: function(f, d) {
        this.map(f, d, "visual");
      },
      omap: function(f, d) {
        this.map(f, d, "operatorPending");
      },
      noremap: function(f, d) {
        this.map(f, d, void 0, true);
      },
      inoremap: function(f, d) {
        this.map(f, d, "insert", true);
      },
      nnoremap: function(f, d) {
        this.map(f, d, "normal", true);
      },
      vnoremap: function(f, d) {
        this.map(f, d, "visual", true);
      },
      onoremap: function(f, d) {
        this.map(f, d, "operatorPending", true);
      },
      unmap: function(f, d, m) {
        var g = d.args;
        (!g || g.length < 1 || !Ft.unmap(g[0], m)) && f && De(f, "No such mapping: " + d.input);
      },
      mapclear: function(f, d) {
        ve.mapclear();
      },
      imapclear: function(f, d) {
        ve.mapclear("insert");
      },
      nmapclear: function(f, d) {
        ve.mapclear("normal");
      },
      vmapclear: function(f, d) {
        ve.mapclear("visual");
      },
      omapclear: function(f, d) {
        ve.mapclear("operatorPending");
      },
      move: function(f, d) {
        Pr.processCommand(f, f.state.vim, {
          keys: "",
          type: "motion",
          motion: "moveToLineOrEdgeOfDocument",
          motionArgs: {
            forward: false,
            explicitRepeat: true,
            linewise: true
          },
          repeatOverride: d.line + 1
        });
      },
      set: function(f, d) {
        var m = d.args, g = d.setCfg || {};
        if (!m || m.length < 1) {
          f && De(f, "Invalid mapping: " + d.input);
          return;
        }
        var b = m[0].split("="), S = b.shift() || "", M = b.length > 0 ? b.join("=") : void 0, A = false, E = false;
        if (S.charAt(S.length - 1) == "?") {
          if (M)
            throw Error("Trailing characters: " + d.argString);
          S = S.substring(0, S.length - 1), A = true;
        } else
          S.charAt(S.length - 1) == "!" && (S = S.substring(0, S.length - 1), E = true);
        M === void 0 && S.substring(0, 2) == "no" && (S = S.substring(2), M = false);
        var I = Y[S] && Y[S].type == "boolean";
        if (I && (E ? M = !ae(S, f, g) : M == null && (M = true)), !I && M === void 0 || A) {
          var D = ae(S, f, g);
          D instanceof Error ? De(f, D.message) : D === true || D === false ? De(f, " " + (D ? "" : "no") + S) : De(f, "  " + S + "=" + D);
        } else {
          var H = ne(S, M, f, g);
          H instanceof Error && De(f, H.message);
        }
      },
      setlocal: function(f, d) {
        d.setCfg = {
          scope: "local"
        }, this.set(f, d);
      },
      setglobal: function(f, d) {
        d.setCfg = {
          scope: "global"
        }, this.set(f, d);
      },
      registers: function(f, d) {
        var m = d.args, g = V.registerController.registers, b = `----------Registers----------

`;
        if (m)
          for (var A = m.join(""), E = 0; E < A.length; E++) {
            var S = A.charAt(E);
            if (!!V.registerController.isValidRegister(S)) {
              var I = g[S] || new nr();
              b += '"' + S + "    " + I.toString() + `
`;
            }
          }
        else
          for (var S in g) {
            var M = g[S].toString();
            M.length && (b += '"' + S + "    " + M + `
`);
          }
        De(f, b, true);
      },
      marks: function(f, d) {
        var m = d.args, g = f.state.vim.marks, b = `-----------Marks-----------
mark	line	col

`;
        if (m)
          for (var A = m.join(""), E = 0; E < A.length; E++) {
            var S = A.charAt(E), M = g[S] && g[S].find();
            M && (b += S + "	" + M.line + "	" + M.ch + `
`);
          }
        else
          for (var S in g) {
            var M = g[S] && g[S].find();
            M && (b += S + "	" + M.line + "	" + M.ch + `
`);
          }
        De(f, b, true);
      },
      sort: function(f, d) {
        var m, g, b, S, M;
        function A() {
          if (d.argString) {
            var Fe = new t.StringStream(d.argString);
            if (Fe.eat("!") && (m = true), Fe.eol())
              return;
            if (!Fe.eatSpace())
              return "Invalid arguments";
            var Me = Fe.match(/([dinuox]+)?\s*(\/.+\/)?\s*/);
            if (!Me || !Fe.eol())
              return "Invalid arguments";
            if (Me[1]) {
              g = Me[1].indexOf("i") != -1, b = Me[1].indexOf("u") != -1;
              var et = Me[1].indexOf("d") != -1 || Me[1].indexOf("n") != -1, sr = Me[1].indexOf("x") != -1, qt = Me[1].indexOf("o") != -1;
              if (Number(et) + Number(sr) + Number(qt) > 1)
                return "Invalid arguments";
              S = et && "decimal" || sr && "hex" || qt && "octal";
            }
            Me[2] && (M = new RegExp(Me[2].substr(1, Me[2].length - 2), g ? "i" : ""));
          }
        }
        var E = A();
        if (E) {
          De(f, E + ": " + d.argString);
          return;
        }
        var I = d.line || f.firstLine(), D = d.lineEnd || d.line || f.lastLine();
        if (I == D)
          return;
        var H = new e(I, 0), j = new e(D, bt(f, D)), W = f.getRange(H, j).split(`
`), $ = S == "decimal" ? /(-?)([\d]+)/ : S == "hex" ? /(-?)(?:0x)?([0-9a-f]+)/i : S == "octal" ? /([0-7]+)/ : null, X = S == "decimal" ? 10 : S == "hex" ? 16 : S == "octal" ? 8 : void 0, Q = [], xe = [];
        if (S || M)
          for (var he = 0; he < W.length; he++) {
            var Ae = M ? W[he].match(M) : null;
            Ae && Ae[0] != "" ? Q.push(Ae) : $ && $.exec(W[he]) ? Q.push(W[he]) : xe.push(W[he]);
          }
        else
          xe = W;
        function Le(Fe, Me) {
          if (m) {
            var et;
            et = Fe, Fe = Me, Me = et;
          }
          g && (Fe = Fe.toLowerCase(), Me = Me.toLowerCase());
          var sr = $ && $.exec(Fe), qt = $ && $.exec(Me);
          if (!sr || !qt)
            return Fe < Me ? -1 : 1;
          var ar = parseInt((sr[1] + sr[2]).toLowerCase(), X), hs = parseInt((qt[1] + qt[2]).toLowerCase(), X);
          return ar - hs;
        }
        function Pe(Fe, Me) {
          if (m) {
            var et;
            et = Fe, Fe = Me, Me = et;
          }
          return g && (Fe[0] = Fe[0].toLowerCase(), Me[0] = Me[0].toLowerCase()), Fe[0] < Me[0] ? -1 : 1;
        }
        if (Q.sort(M ? Pe : Le), M)
          for (var he = 0; he < Q.length; he++)
            Q[he] = Q[he].input;
        else
          S || xe.sort(Le);
        if (W = m ? Q.concat(xe) : xe.concat(Q), b) {
          var ut = W, pt;
          W = [];
          for (var he = 0; he < ut.length; he++)
            ut[he] != pt && W.push(ut[he]), pt = ut[he];
        }
        f.replaceRange(W.join(`
`), H, j);
      },
      vglobal: function(f, d) {
        this.global(f, d);
      },
      normal: function(f, d) {
        var m = false, g = d.argString;
        if (g && g[0] == "!" && (g = g.slice(1), m = true), g = g.trimStart(), !g) {
          De(f, "Argument is required.");
          return;
        }
        var b = d.line;
        if (typeof b == "number")
          for (var S = isNaN(d.lineEnd) ? b : d.lineEnd, M = b; M <= S; M++)
            f.setCursor(M, 0), yt(f, d.argString.trimStart(), {
              noremap: m
            }), f.state.vim.insertMode && Zr(f, true);
        else
          yt(f, d.argString.trimStart(), {
            noremap: m
          }), f.state.vim.insertMode && Zr(f, true);
      },
      global: function(f, d) {
        var m = d.argString;
        if (!m) {
          De(f, "Regular Expression missing from global");
          return;
        }
        var g = d.commandName[0] === "v";
        m[0] === "!" && d.commandName[0] === "g" && (g = true, m = m.slice(1));
        var b = d.line !== void 0 ? d.line : f.firstLine(), S = d.lineEnd || d.line || f.lastLine(), M = pg(m), A = m, E = "";
        if (M && M.length && (A = M[0], E = M.slice(1, M.length).join("/")), A)
          try {
            cs(f, A, true, true);
          } catch {
            De(f, "Invalid regex: " + A);
            return;
          }
        for (var I = On(f).getQuery(), D = [], H = b; H <= S; H++) {
          var j = f.getLine(H), W = I.test(j);
          W !== g && D.push(E ? f.getLineHandle(H) : j);
        }
        if (!E) {
          De(f, D.join(`
`));
          return;
        }
        var $ = 0, X = function() {
          if ($ < D.length) {
            var Q = D[$++], xe = f.getLineNumber(Q);
            if (xe == null) {
              X();
              return;
            }
            var he = xe + 1 + E;
            Ft.processCommand(f, he, {
              callback: X
            });
          } else
            f.releaseLineHandles && f.releaseLineHandles();
        };
        X();
      },
      substitute: function(f, d) {
        if (!f.getSearchCursor)
          throw new Error("Search feature not available. Requires searchcursor.js or any other getSearchCursor implementation.");
        var m = d.argString, g = m ? Of(m, m[0]) : [], b = "", S = "", M, A, E, I = false, D = false;
        if (g && g.length)
          b = g[0], ae("pcre") && b !== "" && (b = new RegExp(b).source), S = g[1], S !== void 0 && (ae("pcre") ? S = yg(S.replace(/([^\\])&/g, "$1$$&")) : S = vg(S), V.lastSubstituteReplacePart = S), M = g[2] ? g[2].split(" ") : [];
        else if (m && m.length) {
          De(f, "Substitutions should be of the form :s/pattern/replace/");
          return;
        }
        if (M && (A = M[0], E = parseInt(M[1]), A && (A.indexOf("c") != -1 && (I = true), A.indexOf("g") != -1 && (D = true), ae("pcre") ? b = b + "/" + A : b = b.replace(/\//g, "\\/") + "/" + A)), b)
          try {
            cs(f, b, true, true);
          } catch {
            De(f, "Invalid regex: " + b);
            return;
          }
        if (S = S || V.lastSubstituteReplacePart, S === void 0) {
          De(f, "No previous substitute regular expression");
          return;
        }
        var H = On(f), j = H.getQuery(), W = d.line !== void 0 ? d.line : f.getCursor().line, $ = d.lineEnd || W;
        W == f.firstLine() && $ == f.lastLine() && ($ = 1 / 0), E && (W = $, $ = W + E - 1);
        var X = $t(f, new e(W, 0)), Q = f.getSearchCursor(j, X);
        Vl(f, I, D, W, $, Q, j, S, d.callback);
      },
      startinsert: function(f, d) {
        yt(f, d.argString == "!" ? "A" : "i", {});
      },
      redo: t.commands.redo,
      undo: t.commands.undo,
      write: function(f) {
        t.commands.save ? t.commands.save(f) : f.save && f.save();
      },
      nohlsearch: function(f) {
        fo(f);
      },
      yank: function(f) {
        var d = ze(f.getCursor()), m = d.line, g = f.getLine(m);
        V.registerController.pushText("0", "yank", g, true, true);
      },
      delete: function(f, d) {
        var m = d.selectionLine, g = isNaN(d.selectionLineEnd) ? m : d.selectionLineEnd;
        Zs.delete(f, {
          linewise: true
        }, [
          {
            anchor: new e(m, 0),
            head: new e(g + 1, 0)
          }
        ]);
      },
      join: function(f, d) {
        var m = d.selectionLine, g = isNaN(d.selectionLineEnd) ? m : d.selectionLineEnd;
        f.setCursor(new e(m, 0)), lo.joinLines(f, {
          repeat: g - m
        }, f.state.vim);
      },
      delmarks: function(f, d) {
        if (!d.argString || !Il(d.argString)) {
          De(f, "Argument required");
          return;
        }
        for (var m = f.state.vim, g = new t.StringStream(Il(d.argString)); !g.eol(); ) {
          g.eatSpace();
          var b = g.pos;
          if (!g.match(/[a-zA-Z]/, false)) {
            De(f, "Invalid argument: " + d.argString.substring(b));
            return;
          }
          var S = g.next();
          if (g.match("-", true)) {
            if (!g.match(/[a-zA-Z]/, false)) {
              De(f, "Invalid argument: " + d.argString.substring(b));
              return;
            }
            var M = S, A = g.next();
            if (M && A && C(M) == C(A)) {
              var E = M.charCodeAt(0), I = A.charCodeAt(0);
              if (E >= I) {
                De(f, "Invalid argument: " + d.argString.substring(b));
                return;
              }
              for (var D = 0; D <= I - E; D++) {
                var H = String.fromCharCode(E + D);
                delete m.marks[H];
              }
            } else {
              De(f, "Invalid argument: " + M + "-");
              return;
            }
          } else
            S && delete m.marks[S];
        }
      }
    }, Ft = new ia();
    ve.defineEx("version", "ve", (f) => {
      De(f, "Codemirror-vim version: 6.3.0");
    });
    function Vl(f, d, m, g, b, S, M, A, E) {
      f.state.vim.exMode = true;
      var I = false, D = 0, H, j, W;
      function $() {
        f.operation(function() {
          for (; !I; )
            X(), xe();
          he();
        });
      }
      function X() {
        var Le = "", Pe = S.match || S.pos && S.pos.match;
        if (Pe)
          Le = A.replace(/\$(\d{1,3}|[$&])/g, function(Fe, Me) {
            if (Me == "$")
              return "$";
            if (Me == "&")
              return Pe[0];
            for (var et = Me; parseInt(et) >= Pe.length && et.length > 0; )
              et = et.slice(0, et.length - 1);
            return et ? Pe[et] + Me.slice(et.length, Me.length) : Fe;
          });
        else {
          var ut = f.getRange(S.from(), S.to());
          Le = ut.replace(M, A);
        }
        var pt = S.to().line;
        S.replace(Le), j = S.to().line, b += j - pt, W = j < pt;
      }
      function Q() {
        var Le = H && ze(S.to()), Pe = S.findNext();
        return Pe && !Pe[0] && Le && Kt(S.from(), Le) && (Pe = S.findNext()), Pe && D++, Pe;
      }
      function xe() {
        for (; Q() && zl(S.from(), g, b); )
          if (!(!m && S.from().line == j && !W)) {
            f.scrollIntoView(S.from(), 30), f.setSelection(S.from(), S.to()), H = S.from(), I = false;
            return;
          }
        I = true;
      }
      function he(Le) {
        if (Le && Le(), f.focus(), H) {
          f.setCursor(H);
          var Pe = f.state.vim;
          Pe.exMode = false, Pe.lastHPos = Pe.lastHSPos = H.ch;
        }
        E ? E() : I && De(f, (D ? "Found " + D + " matches" : "No matches found") + " for pattern: " + M + (ae("pcre") ? " (set nopcre to use Vim regexps)" : ""));
      }
      function Ae(Le, Pe, ut) {
        t.e_stop(Le);
        var pt = ao(Le);
        switch (pt) {
          case "y":
            X(), xe();
            break;
          case "n":
            xe();
            break;
          case "a":
            var Fe = E;
            E = void 0, f.operation($), E = Fe;
            break;
          case "l":
            X();
          case "q":
          case "<Esc>":
          case "<C-c>":
          case "<C-[>":
            he(ut);
            break;
        }
        return I && he(ut), true;
      }
      if (xe(), I) {
        De(f, "No matches for " + M + (ae("pcre") ? " (set nopcre to use vim regexps)" : ""));
        return;
      }
      if (!d) {
        $(), E && E();
        return;
      }
      ta(f, {
        prefix: on("span", "replace with ", on("strong", A), " (y/n/a/q/l)"),
        onKeyDown: Ae
      });
    }
    function Zr(f, d) {
      var m = f.state.vim, g = V.macroModeState, b = V.registerController.getRegister("."), S = g.isPlaying, M = g.lastInsertModeChanges;
      S || (f.off("change", jl), m.insertEnd && m.insertEnd.clear(), m.insertEnd = void 0, t.off(f.getInputField(), "keydown", Wl)), !S && m.insertModeRepeat && m.insertModeRepeat > 1 && (Hf(f, m, m.insertModeRepeat - 1, true), m.lastEditInputState.repeatOverride = m.insertModeRepeat), delete m.insertModeRepeat, m.insertMode = false, d || f.setCursor(f.getCursor().line, f.getCursor().ch - 1), f.setOption("keyMap", "vim"), f.setOption("disableInput", true), f.toggleOverwrite(false), b.setText(M.changes.join("")), t.signal(f, "vim-mode-change", {
        mode: "normal"
      }), g.isRecording && zf(g);
    }
    function sa(f) {
      r.unshift(f), f.keys && Hl(f.keys);
    }
    function Hl(f) {
      f.split(/(<(?:[CSMA]-)*\w+>|.)/i).forEach(function(d) {
        d && (i[d] || (i[d] = 0), i[d]++);
      });
    }
    function $f(f) {
      f.split(/(<(?:[CSMA]-)*\w+>|.)/i).forEach(function(d) {
        i[d] && i[d]--;
      });
    }
    function _i2(f, d, m, g, b) {
      var S = {
        keys: f,
        type: d
      };
      S[d] = m, S[d + "Args"] = g;
      for (var M in b)
        S[M] = b[M];
      sa(S);
    }
    te("insertModeEscKeysTimeout", 200, "number");
    function fs(f, d, m, g) {
      var b = V.registerController.getRegister(g);
      if (g == ":") {
        b.keyBuffer[0] && Ft.processCommand(f, b.keyBuffer[0]), m.isPlaying = false;
        return;
      }
      var S = b.keyBuffer, M = 0;
      m.isPlaying = true, m.replaySearchQueries = b.searchQueries.slice(0);
      for (var A = 0; A < S.length; A++)
        for (var E = S[A], I, D, H = /<(?:[CSMA]-)*\w+>|./gi; I = H.exec(E); )
          if (D = I[0], ve.handleKey(f, D, "macro"), d.insertMode) {
            var j = b.insertModeChanges[M++].changes;
            V.macroModeState.lastInsertModeChanges.changes = j, B(f, j, 1), Zr(f);
          }
      m.isPlaying = false;
    }
    function wg(f, d) {
      if (!f.isPlaying) {
        var m = f.latestRegister, g = V.registerController.getRegister(m);
        g && g.pushText(d);
      }
    }
    function zf(f) {
      if (!f.isPlaying) {
        var d = f.latestRegister, m = V.registerController.getRegister(d);
        m && m.pushInsertModeChanges && m.pushInsertModeChanges(f.lastInsertModeChanges);
      }
    }
    function kg(f, d) {
      if (!f.isPlaying) {
        var m = f.latestRegister, g = V.registerController.getRegister(m);
        g && g.pushSearchQuery && g.pushSearchQuery(d);
      }
    }
    function jl(f, d) {
      var m = V.macroModeState, g = m.lastInsertModeChanges;
      if (!m.isPlaying)
        for (var b = f.state.vim; d; ) {
          if (g.expectCursorActivityForChange = true, g.ignoreCount > 1)
            g.ignoreCount--;
          else if (d.origin == "+input" || d.origin == "paste" || d.origin === void 0) {
            var S = f.listSelections().length;
            S > 1 && (g.ignoreCount = S);
            var M = d.text.join(`
`);
            if (g.maybeReset && (g.changes = [], g.maybeReset = false), M)
              if (f.state.overwrite && !/\n/.test(M))
                g.changes.push([
                  M
                ]);
              else {
                if (M.length > 1) {
                  var A = b && b.insertEnd && b.insertEnd.find(), E = f.getCursor();
                  if (A && A.line == E.line) {
                    var I = A.ch - E.ch;
                    I > 0 && I < M.length && (g.changes.push([
                      M,
                      I
                    ]), M = "");
                  }
                }
                M && g.changes.push(M);
              }
          }
          d = d.next;
        }
    }
    function Ff(f) {
      var _a3;
      var d = f.state.vim;
      if (d.insertMode) {
        var m = V.macroModeState;
        if (m.isPlaying)
          return;
        var g = m.lastInsertModeChanges;
        g.expectCursorActivityForChange ? g.expectCursorActivityForChange = false : (g.maybeReset = true, d.insertEnd && d.insertEnd.clear(), d.insertEnd = f.setBookmark(f.getCursor(), {
          insertLeft: true
        }));
      } else
        ((_a3 = f.curOp) == null ? void 0 : _a3.isVimOp) || Vf(f, d);
    }
    function Vf(f, d) {
      var m = f.getCursor("anchor"), g = f.getCursor("head");
      if (d.visualMode && !f.somethingSelected() ? ir(f, false) : !d.visualMode && !d.insertMode && f.somethingSelected() && (d.visualMode = true, d.visualLine = false, t.signal(f, "vim-mode-change", {
        mode: "visual"
      })), d.visualMode) {
        var b = ct(g, m) ? 0 : -1, S = ct(g, m) ? -1 : 0;
        g = dt(g, 0, b), m = dt(m, 0, S), d.sel = {
          anchor: m,
          head: g
        }, Pn(f, d, "<", zt(g, m)), Pn(f, d, ">", Jr(g, m));
      } else
        d.insertMode || (d.lastHPos = f.getCursor().ch);
    }
    function Wl(f) {
      var d = V.macroModeState, m = d.lastInsertModeChanges, g = t.keyName ? t.keyName(f) : f.key;
      !g || (g.indexOf("Delete") != -1 || g.indexOf("Backspace") != -1) && (m.maybeReset && (m.changes = [], m.maybeReset = false), m.changes.push(new de(g, f)));
    }
    function Hf(f, d, m, g) {
      var b = V.macroModeState;
      b.isPlaying = true;
      var S = d.lastEditActionCommand, M = d.inputState;
      function A() {
        S ? Pr.processAction(f, d, S) : Pr.evalInput(f, d);
      }
      function E(D) {
        if (b.lastInsertModeChanges.changes.length > 0) {
          D = d.lastEditActionCommand ? D : 1;
          var H = b.lastInsertModeChanges;
          B(f, H.changes, D);
        }
      }
      if (d.inputState = d.lastEditInputState, S && S.interlaceInsertRepeat)
        for (var I = 0; I < m; I++)
          A(), E(1);
      else
        g || A(), E(m);
      d.inputState = M, d.insertMode && !g && Zr(f), b.isPlaying = false;
    }
    function O(f, d) {
      t.lookupKey(d, "vim-insert", function(g) {
        return typeof g == "string" ? t.commands[g](f) : g(f), true;
      });
    }
    function B(f, d, m) {
      var g = f.getCursor("head"), b = V.macroModeState.lastInsertModeChanges.visualBlock;
      b && (wf(f, g, b + 1), m = f.listSelections().length, f.setCursor(g));
      for (var S = 0; S < m; S++) {
        b && f.setCursor(dt(g, S, 0));
        for (var M = 0; M < d.length; M++) {
          var A = d[M];
          if (A instanceof de)
            O(f, A.keyName);
          else if (typeof A == "string")
            f.replaceSelection(A);
          else {
            var E = f.getCursor(), I = dt(E, 0, A[0].length - (A[1] || 0));
            f.replaceRange(A[0], E, A[1] ? E : I), f.setCursor(I);
          }
        }
      }
      b && f.setCursor(dt(g, 0, 1));
    }
    function U(f) {
      var d = new f.constructor();
      return Object.keys(f).forEach(function(m) {
        if (m != "insertEnd") {
          var g = f[m];
          Array.isArray(g) ? g = g.slice() : g && typeof g == "object" && g.constructor != Object && (g = U(g)), d[m] = g;
        }
      }), f.sel && (d.sel = {
        head: f.sel.head && ze(f.sel.head),
        anchor: f.sel.anchor && ze(f.sel.anchor)
      }), d;
    }
    function pe(f, d, m) {
      var S = ee(f), g = f, b = false, S = ve.maybeInitVimState_(g), M = S.visualBlock || S.wasInVisualBlock;
      if (g.state.closeVimNotification) {
        var A = g.state.closeVimNotification;
        if (g.state.closeVimNotification = null, A(), d == "<CR>")
          return Et(g), true;
      }
      var E = g.isInMultiSelectMode();
      if (S.wasInVisualBlock && !E ? S.wasInVisualBlock = false : E && S.visualBlock && (S.wasInVisualBlock = true), d == "<Esc>" && !S.insertMode && !S.visualMode && E && S.status == "<Esc>")
        Et(g);
      else if (M || !E || g.inVirtualSelectionMode)
        b = ve.handleKey(g, d, m);
      else {
        var I = U(S), D = S.inputState.changeQueueList || [];
        g.operation(function() {
          var _a3;
          g.curOp && (g.curOp.isVimOp = true);
          var H = 0;
          g.forEachSelection(function() {
            g.state.vim.inputState.changeQueue = D[H];
            var j = g.getCursor("head"), W = g.getCursor("anchor"), $ = ct(j, W) ? 0 : -1, X = ct(j, W) ? -1 : 0;
            j = dt(j, 0, $), W = dt(W, 0, X), g.state.vim.sel.head = j, g.state.vim.sel.anchor = W, b = ve.handleKey(g, d, m), g.virtualSelection && (D[H] = g.state.vim.inputState.changeQueue, g.state.vim = U(I)), H++;
          }), ((_a3 = g.curOp) == null ? void 0 : _a3.cursorActivity) && !b && (g.curOp.cursorActivity = false), g.state.vim = S, S.inputState.changeQueueList = D, S.inputState.changeQueue = null;
        }, true);
      }
      return b && !S.visualMode && !S.insertMode && S.visualMode != g.somethingSelected() && Vf(g, S), b;
    }
    return oe(), ve;
  }
  function jn(t, e) {
    var n = e.ch, r = e.line + 1;
    r < 1 && (r = 1, n = 0), r > t.lines && (r = t.lines, n = Number.MAX_VALUE);
    var i = t.line(r);
    return Math.min(i.from + Math.max(0, n), i.to);
  }
  function ur(t, e) {
    let n = t.lineAt(e);
    return {
      line: n.number - 1,
      ch: e - n.from
    };
  }
  class hi {
    constructor(e, n) {
      this.line = e, this.ch = n;
    }
  }
  function ZL(t, e, n) {
    if (t.addEventListener)
      t.addEventListener(e, n, false);
    else {
      var r = t._handlers || (t._handlers = {});
      r[e] = (r[e] || []).concat(n);
    }
  }
  function e_(t, e, n) {
    if (t.removeEventListener)
      t.removeEventListener(e, n, false);
    else {
      var r = t._handlers, i = r && r[e];
      if (i) {
        var o = i.indexOf(n);
        o > -1 && (r[e] = i.slice(0, o).concat(i.slice(o + 1)));
      }
    }
  }
  function t_(t, e, ...n) {
    var r, i = (r = t._handlers) === null || r === void 0 ? void 0 : r[e];
    if (!!i)
      for (var o = 0; o < i.length; ++o)
        i[o](...n);
  }
  function iM(t, ...e) {
    if (!!t)
      for (var n = 0; n < t.length; ++n)
        t[n](...e);
  }
  let O1;
  try {
    O1 = new RegExp("[\\w\\p{Alphabetic}\\p{Number}_]", "u");
  } catch {
    O1 = /[\w]/;
  }
  function Tc(t, e) {
    var n = t.cm6;
    if (!n.state.readOnly) {
      var r = "input.type.compose";
      if (t.curOp && (t.curOp.lastChange || (r = "input.type.compose.start")), e.annotations)
        try {
          e.annotations.some(function(i) {
            i.value == "input" && (i.value = r);
          });
        } catch (i) {
          console.error(i);
        }
      else
        e.userEvent = r;
      return n.dispatch(e);
    }
  }
  function oM(t, e) {
    var n;
    t.curOp && (t.curOp.$changeStart = void 0), (e ? qx : _p)(t.cm6);
    let r = (n = t.curOp) === null || n === void 0 ? void 0 : n.$changeStart;
    r != null && t.cm6.dispatch({
      selection: {
        anchor: r
      }
    });
  }
  var KX = {
    Left: (t) => xs(t.cm6, {
      key: "Left"
    }, "editor"),
    Right: (t) => xs(t.cm6, {
      key: "Right"
    }, "editor"),
    Up: (t) => xs(t.cm6, {
      key: "Up"
    }, "editor"),
    Down: (t) => xs(t.cm6, {
      key: "Down"
    }, "editor"),
    Backspace: (t) => xs(t.cm6, {
      key: "Backspace"
    }, "editor"),
    Delete: (t) => xs(t.cm6, {
      key: "Delete"
    }, "editor")
  };
  class Oe {
    openDialog(e, n, r) {
      return GX(this, e, n, r);
    }
    openNotification(e, n) {
      return qX(this, e, n);
    }
    constructor(e) {
      this.state = {}, this.marks = /* @__PURE__ */ Object.create(null), this.$mid = 0, this.options = {}, this._handlers = {}, this.$lastChangeEndOffset = 0, this.virtualSelection = null, this.cm6 = e, this.onChange = this.onChange.bind(this), this.onSelectionChange = this.onSelectionChange.bind(this);
    }
    on(e, n) {
      ZL(this, e, n);
    }
    off(e, n) {
      e_(this, e, n);
    }
    signal(e, n, r) {
      t_(this, e, n, r);
    }
    indexFromPos(e) {
      return jn(this.cm6.state.doc, e);
    }
    posFromIndex(e) {
      return ur(this.cm6.state.doc, e);
    }
    foldCode(e) {
      let n = this.cm6, r = n.state.selection.ranges, i = this.cm6.state.doc, o = jn(i, e), s = q.create([
        q.range(o, o)
      ], 0).ranges;
      n.state.selection.ranges = s, WR(n), n.state.selection.ranges = r;
    }
    firstLine() {
      return 0;
    }
    lastLine() {
      return this.cm6.state.doc.lines - 1;
    }
    lineCount() {
      return this.cm6.state.doc.lines;
    }
    setCursor(e, n) {
      typeof e == "object" && (n = e.ch, e = e.line);
      var r = jn(this.cm6.state.doc, {
        line: e,
        ch: n || 0
      });
      this.cm6.dispatch({
        selection: {
          anchor: r
        }
      }, {
        scrollIntoView: !this.curOp
      }), this.curOp && !this.curOp.isVimOp && this.onBeforeEndOperation();
    }
    getCursor(e) {
      var n = this.cm6.state.selection.main, r = e == "head" || !e ? n.head : e == "anchor" ? n.anchor : e == "start" ? n.from : e == "end" ? n.to : null;
      if (r == null)
        throw new Error("Invalid cursor type");
      return this.posFromIndex(r);
    }
    listSelections() {
      var e = this.cm6.state.doc;
      return this.cm6.state.selection.ranges.map((n) => ({
        anchor: ur(e, n.anchor),
        head: ur(e, n.head)
      }));
    }
    setSelections(e, n) {
      var r = this.cm6.state.doc, i = e.map((o) => {
        var s = jn(r, o.head), a = jn(r, o.anchor);
        return s == a ? q.cursor(s, 1) : q.range(a, s);
      });
      this.cm6.dispatch({
        selection: q.create(i, n)
      });
    }
    setSelection(e, n, r) {
      this.setSelections([
        {
          anchor: e,
          head: n
        }
      ], 0), r && r.origin == "*mouse" && this.onBeforeEndOperation();
    }
    getLine(e) {
      var n = this.cm6.state.doc;
      return e < 0 || e >= n.lines ? "" : this.cm6.state.doc.line(e + 1).text;
    }
    getLineHandle(e) {
      return this.$lineHandleChanges || (this.$lineHandleChanges = []), {
        row: e,
        index: this.indexFromPos(new hi(e, 0))
      };
    }
    getLineNumber(e) {
      var n = this.$lineHandleChanges;
      if (!n)
        return null;
      for (var r = e.index, i = 0; i < n.length; i++)
        if (r = n[i].changes.mapPos(r, 1, Zt.TrackAfter), r == null)
          return null;
      var o = this.posFromIndex(r);
      return o.ch == 0 ? o.line : null;
    }
    releaseLineHandles() {
      this.$lineHandleChanges = void 0;
    }
    getRange(e, n) {
      var r = this.cm6.state.doc;
      return this.cm6.state.sliceDoc(jn(r, e), jn(r, n));
    }
    replaceRange(e, n, r, i) {
      r || (r = n);
      var o = this.cm6.state.doc, s = jn(o, n), a = jn(o, r);
      Tc(this, {
        changes: {
          from: s,
          to: a,
          insert: e
        }
      });
    }
    replaceSelection(e) {
      Tc(this, this.cm6.state.replaceSelection(e));
    }
    replaceSelections(e) {
      var n = this.cm6.state.selection.ranges, r = n.map((i, o) => ({
        from: i.from,
        to: i.to,
        insert: e[o] || ""
      }));
      Tc(this, {
        changes: r
      });
    }
    getSelection() {
      return this.getSelections().join(`
`);
    }
    getSelections() {
      var e = this.cm6;
      return e.state.selection.ranges.map((n) => e.state.sliceDoc(n.from, n.to));
    }
    somethingSelected() {
      return this.cm6.state.selection.ranges.some((e) => !e.empty);
    }
    getInputField() {
      return this.cm6.contentDOM;
    }
    clipPos(e) {
      var n = this.cm6.state.doc, r = e.ch, i = e.line + 1;
      i < 1 && (i = 1, r = 0), i > n.lines && (i = n.lines, r = Number.MAX_VALUE);
      var o = n.line(i);
      return r = Math.min(Math.max(0, r), o.to - o.from), new hi(i - 1, r);
    }
    getValue() {
      return this.cm6.state.doc.toString();
    }
    setValue(e) {
      var n = this.cm6;
      return n.dispatch({
        changes: {
          from: 0,
          to: n.state.doc.length,
          insert: e
        },
        selection: q.range(0, 0)
      });
    }
    focus() {
      return this.cm6.focus();
    }
    blur() {
      return this.cm6.contentDOM.blur();
    }
    defaultTextHeight() {
      return this.cm6.defaultLineHeight;
    }
    findMatchingBracket(e, n) {
      var r = this.cm6.state, i = jn(r.doc, e), o = mr(r, i + 1, -1);
      return o && o.end ? {
        to: ur(r.doc, o.end.from)
      } : (o = mr(r, i, 1), o && o.end ? {
        to: ur(r.doc, o.end.from)
      } : {
        to: void 0
      });
    }
    scanForBracket(e, n, r, i) {
      return QX(this, e, n, r, i);
    }
    indentLine(e, n) {
      n ? this.indentMore() : this.indentLess();
    }
    indentMore() {
      Qx(this.cm6);
    }
    indentLess() {
      Jx(this.cm6);
    }
    execCommand(e) {
      if (e == "indentAuto")
        Oe.commands.indentAuto(this);
      else if (e == "goLineLeft")
        hL(this.cm6);
      else if (e == "goLineRight") {
        fL(this.cm6);
        let n = this.cm6.state, r = n.selection.main.head;
        r < n.doc.length && n.sliceDoc(r, r + 1) !== `
` && sG(this.cm6);
      } else
        console.log(e + " is not implemented");
    }
    setBookmark(e, n) {
      var r = (n == null ? void 0 : n.insertLeft) ? 1 : -1, i = this.indexFromPos(e), o = new eQ(this, i, r);
      return o;
    }
    addOverlay({ query: e }) {
      let n = new tS({
        regexp: true,
        search: e.source,
        caseSensitive: !/i/.test(e.flags)
      });
      if (n.valid) {
        n.forVim = true, this.cm6Query = n;
        let r = Jo.of(n);
        return this.cm6.dispatch({
          effects: r
        }), n;
      }
    }
    removeOverlay(e) {
      if (!this.cm6Query)
        return;
      this.cm6Query.forVim = false;
      let n = Jo.of(this.cm6Query);
      this.cm6.dispatch({
        effects: n
      });
    }
    getSearchCursor(e, n) {
      var r = this, i = null, o = null, s = false;
      n.ch == null && (n.ch = Number.MAX_VALUE);
      var a = jn(r.cm6.state.doc, n), l = e.source.replace(/(\\.|{(?:\d+(?:,\d*)?|,\d+)})|[{}]/g, function(v, y) {
        return y || "\\" + v;
      });
      function c(v, y = 0, x = v.length) {
        return new eS(v, l, {
          ignoreCase: e.ignoreCase
        }, y, x);
      }
      function u(v) {
        var y = r.cm6.state.doc;
        if (v > y.length)
          return null;
        let x = c(y, v).next();
        return x.done ? null : x.value;
      }
      var h = 1e4;
      function p(v, y) {
        var x = r.cm6.state.doc;
        for (let T = 1; ; T++) {
          let w = Math.max(v, y - T * h), k = c(x, w, y), C = null;
          for (; !k.next().done; )
            C = k.value;
          if (C && (w == v || C.from > w + 10))
            return C;
          if (w == v)
            return null;
        }
      }
      return {
        findNext: function() {
          return this.find(false);
        },
        findPrevious: function() {
          return this.find(true);
        },
        find: function(v) {
          var y = r.cm6.state.doc;
          if (v) {
            let x = i ? s ? i.to - 1 : i.from : a;
            i = p(0, x);
          } else {
            let x = i ? s ? i.to + 1 : i.to : a;
            i = u(x);
          }
          return o = i && {
            from: ur(y, i.from),
            to: ur(y, i.to),
            match: i.match
          }, s = i ? i.from == i.to : false, i && i.match;
        },
        from: function() {
          return o == null ? void 0 : o.from;
        },
        to: function() {
          return o == null ? void 0 : o.to;
        },
        replace: function(v) {
          i && (Tc(r, {
            changes: {
              from: i.from,
              to: i.to,
              insert: v
            }
          }), i.to = i.from + v.length, o && (o.to = ur(r.cm6.state.doc, i.to)));
        },
        get match() {
          return o && o.match;
        }
      };
    }
    findPosV(e, n, r, i) {
      let { cm6: o } = this;
      const s = o.state.doc;
      let a = r == "page" ? o.dom.clientHeight : 0;
      const l = jn(s, e);
      let c = q.cursor(l, 1, void 0, i), u = Math.round(Math.abs(n));
      for (let p = 0; p < u; p++)
        r == "page" ? c = o.moveVertically(c, n > 0, a) : r == "line" && (c = o.moveVertically(c, n > 0));
      let h = ur(s, c.head);
      return (n < 0 && c.head == 0 && i != 0 && e.line == 0 && e.ch != 0 || n > 0 && c.head == s.length && h.ch != i && e.line == h.line) && (h.hitSide = true), h;
    }
    charCoords(e, n) {
      var r = this.cm6.contentDOM.getBoundingClientRect(), i = jn(this.cm6.state.doc, e), o = this.cm6.coordsAtPos(i), s = -r.top;
      return {
        left: ((o == null ? void 0 : o.left) || 0) - r.left,
        top: ((o == null ? void 0 : o.top) || 0) + s,
        bottom: ((o == null ? void 0 : o.bottom) || 0) + s
      };
    }
    coordsChar(e, n) {
      var r = this.cm6.contentDOM.getBoundingClientRect(), i = this.cm6.posAtCoords({
        x: e.left + r.left,
        y: e.top + r.top
      }) || 0;
      return ur(this.cm6.state.doc, i);
    }
    getScrollInfo() {
      var e = this.cm6.scrollDOM;
      return {
        left: e.scrollLeft,
        top: e.scrollTop,
        height: e.scrollHeight,
        width: e.scrollWidth,
        clientHeight: e.clientHeight,
        clientWidth: e.clientWidth
      };
    }
    scrollTo(e, n) {
      e != null && (this.cm6.scrollDOM.scrollLeft = e), n != null && (this.cm6.scrollDOM.scrollTop = n);
    }
    scrollIntoView(e, n) {
      if (e) {
        var r = this.indexFromPos(e);
        this.cm6.dispatch({
          effects: ue.scrollIntoView(r)
        });
      } else
        this.cm6.dispatch({
          scrollIntoView: true,
          userEvent: "scroll"
        });
    }
    getWrapperElement() {
      return this.cm6.dom;
    }
    getMode() {
      return {
        name: this.getOption("mode")
      };
    }
    setSize(e, n) {
      this.cm6.dom.style.width = e + 4 + "px", this.cm6.dom.style.height = n + "px", this.refresh();
    }
    refresh() {
      this.cm6.measure();
    }
    destroy() {
      this.removeOverlay();
    }
    getLastEditEnd() {
      return this.posFromIndex(this.$lastChangeEndOffset);
    }
    onChange(e) {
      this.$lineHandleChanges && this.$lineHandleChanges.push(e);
      for (let r in this.marks)
        this.marks[r].update(e.changes);
      this.virtualSelection && (this.virtualSelection.ranges = this.virtualSelection.ranges.map((r) => r.map(e.changes)));
      var n = this.curOp = this.curOp || {};
      e.changes.iterChanges((r, i, o, s, a) => {
        (n.$changeStart == null || n.$changeStart > o) && (n.$changeStart = o), this.$lastChangeEndOffset = s;
        var l = {
          text: a.toJSON()
        };
        n.lastChange ? n.lastChange.next = n.lastChange = l : n.lastChange = n.change = l;
      }, true), n.changeHandlers || (n.changeHandlers = this._handlers.change && this._handlers.change.slice());
    }
    onSelectionChange() {
      var e = this.curOp = this.curOp || {};
      e.cursorActivityHandlers || (e.cursorActivityHandlers = this._handlers.cursorActivity && this._handlers.cursorActivity.slice()), this.curOp.cursorActivity = true;
    }
    operation(e, n) {
      this.curOp || (this.curOp = {
        $d: 0
      }), this.curOp.$d++;
      try {
        var r = e();
      } finally {
        this.curOp && (this.curOp.$d--, this.curOp.$d || this.onBeforeEndOperation());
      }
      return r;
    }
    onBeforeEndOperation() {
      var e = this.curOp, n = false;
      e && (e.change && iM(e.changeHandlers, this, e.change), e && e.cursorActivity && (iM(e.cursorActivityHandlers, this, null), e.isVimOp && (n = true)), this.curOp = null), n && this.scrollIntoView();
    }
    moveH(e, n) {
      if (n == "char") {
        var r = this.getCursor();
        this.setCursor(r.line, r.ch + e);
      }
    }
    setOption(e, n) {
      switch (e) {
        case "keyMap":
          this.state.keyMap = n;
          break;
        case "textwidth":
          this.state.textwidth = n;
          break;
      }
    }
    getOption(e) {
      switch (e) {
        case "firstLineNumber":
          return 1;
        case "tabSize":
          return this.cm6.state.tabSize || 4;
        case "readOnly":
          return this.cm6.state.readOnly;
        case "indentWithTabs":
          return this.cm6.state.facet(xl) == "	";
        case "indentUnit":
          return this.cm6.state.facet(xl).length || 2;
        case "textwidth":
          return this.state.textwidth;
        case "keyMap":
          return this.state.keyMap || "vim";
      }
    }
    toggleOverwrite(e) {
      this.state.overwrite = e;
    }
    getTokenTypeAt(e) {
      var n, r = this.indexFromPos(e), i = $R(this.cm6.state, r), o = i == null ? void 0 : i.resolve(r), s = ((n = o == null ? void 0 : o.type) === null || n === void 0 ? void 0 : n.name) || "";
      return /comment/i.test(s) ? "comment" : /string/i.test(s) ? "string" : "";
    }
    overWriteSelection(e) {
      var n = this.cm6.state.doc, r = this.cm6.state.selection, i = r.ranges.map((o) => {
        if (o.empty) {
          var s = o.to < n.length ? n.sliceString(o.from, o.to + 1) : "";
          if (s && !/\n/.test(s))
            return q.range(o.from, o.to + 1);
        }
        return o;
      });
      this.cm6.dispatch({
        selection: q.create(i, r.mainIndex)
      }), this.replaceSelection(e);
    }
    isInMultiSelectMode() {
      return this.cm6.state.selection.ranges.length > 1;
    }
    virtualSelectionMode() {
      return !!this.virtualSelection;
    }
    forEachSelection(e) {
      var n = this.cm6.state.selection;
      this.virtualSelection = q.create(n.ranges, n.mainIndex);
      for (var r = 0; r < this.virtualSelection.ranges.length; r++) {
        var i = this.virtualSelection.ranges[r];
        !i || (this.cm6.dispatch({
          selection: q.create([
            i
          ])
        }), e(), this.virtualSelection.ranges[r] = this.cm6.state.selection.ranges[0]);
      }
      this.cm6.dispatch({
        selection: this.virtualSelection
      }), this.virtualSelection = null;
    }
    hardWrap(e) {
      return tQ(this, e);
    }
  }
  Oe.isMac = typeof navigator < "u" && /Mac/.test(navigator.platform);
  Oe.Pos = hi;
  Oe.StringStream = Nq;
  Oe.commands = {
    cursorCharLeft: function(t) {
      Yx(t.cm6);
    },
    redo: function(t) {
      oM(t, false);
    },
    undo: function(t) {
      oM(t, true);
    },
    newlineAndIndent: function(t) {
      M1({
        state: t.cm6.state,
        dispatch: (e) => Tc(t, e)
      });
    },
    indentAuto: function(t) {
      PL(t.cm6);
    },
    newlineAndIndentContinueComment: void 0,
    save: void 0
  };
  Oe.isWordChar = function(t) {
    return O1.test(t);
  };
  Oe.keys = KX;
  Oe.addClass = function(t, e) {
  };
  Oe.rmClass = function(t, e) {
  };
  Oe.e_preventDefault = function(t) {
    t.preventDefault();
  };
  Oe.e_stop = function(t) {
    var e, n;
    (e = t == null ? void 0 : t.stopPropagation) === null || e === void 0 || e.call(t), (n = t == null ? void 0 : t.preventDefault) === null || n === void 0 || n.call(t);
  };
  Oe.lookupKey = function(e, n, r) {
    var i = Oe.keys[e];
    !i && /^Arrow/.test(e) && (i = Oe.keys[e.slice(5)]), i && r(i);
  };
  Oe.on = ZL;
  Oe.off = e_;
  Oe.signal = t_;
  Oe.findMatchingTag = JX;
  Oe.findEnclosingTag = ZX;
  Oe.keyName = void 0;
  function n_(t, e, n) {
    var r = document.createElement("div");
    return r.appendChild(e), r;
  }
  function r_(t, e) {
    t.state.currentNotificationClose && t.state.currentNotificationClose(), t.state.currentNotificationClose = e;
  }
  function qX(t, e, n) {
    r_(t, a);
    var r = n_(t, e, n && n.bottom), i = false, o, s = n && typeof n.duration < "u" ? n.duration : 5e3;
    function a() {
      i || (i = true, clearTimeout(o), r.remove(), o_(t, r));
    }
    return r.onclick = function(l) {
      l.preventDefault(), a();
    }, i_(t, r), s && (o = setTimeout(a, s)), a;
  }
  function i_(t, e) {
    var n = t.state.dialog;
    t.state.dialog = e, e.style.flex = "1", e && n !== e && (n && n.contains(document.activeElement) && t.focus(), n && n.parentElement ? n.parentElement.replaceChild(e, n) : n && n.remove(), Oe.signal(t, "dialog"));
  }
  function o_(t, e) {
    t.state.dialog == e && (t.state.dialog = null, Oe.signal(t, "dialog"));
  }
  function GX(t, e, n, r) {
    r || (r = {}), r_(t, void 0);
    var i = n_(t, e, r.bottom), o = false;
    i_(t, i);
    function s(l) {
      if (typeof l == "string")
        a.value = l;
      else {
        if (o)
          return;
        o = true, o_(t, i), t.state.dialog || t.focus(), r.onClose && r.onClose(i);
      }
    }
    var a = i.getElementsByTagName("input")[0];
    return a && (r.value && (a.value = r.value, r.selectValueOnOpen !== false && a.select()), r.onInput && Oe.on(a, "input", function(l) {
      r.onInput(l, a.value, s);
    }), r.onKeyUp && Oe.on(a, "keyup", function(l) {
      r.onKeyUp(l, a.value, s);
    }), Oe.on(a, "keydown", function(l) {
      r && r.onKeyDown && r.onKeyDown(l, a.value, s) || (l.keyCode == 13 && n && n(a.value), (l.keyCode == 27 || r.closeOnEnter !== false && l.keyCode == 13) && (a.blur(), Oe.e_stop(l), s()));
    }), r.closeOnBlur !== false && Oe.on(a, "blur", function() {
      setTimeout(function() {
        document.activeElement !== a && s();
      });
    }), a.focus()), s;
  }
  var YX = {
    "(": ")>",
    ")": "(<",
    "[": "]>",
    "]": "[<",
    "{": "}>",
    "}": "{<",
    "<": ">>",
    ">": "<<"
  };
  function XX(t) {
    return t && t.bracketRegex || /[(){}[\]]/;
  }
  function QX(t, e, n, r, i) {
    for (var o = i && i.maxScanLineLength || 1e4, s = i && i.maxScanLines || 1e3, a = [], l = XX(i), c = n > 0 ? Math.min(e.line + s, t.lastLine() + 1) : Math.max(t.firstLine() - 1, e.line - s), u = e.line; u != c; u += n) {
      var h = t.getLine(u);
      if (!!h) {
        var p = n > 0 ? 0 : h.length - 1, v = n > 0 ? h.length : -1;
        if (!(h.length > o))
          for (u == e.line && (p = e.ch - (n < 0 ? 1 : 0)); p != v; p += n) {
            var y = h.charAt(p);
            if (l.test(y)) {
              var x = YX[y];
              if (x && x.charAt(1) == ">" == n > 0)
                a.push(y);
              else if (a.length)
                a.pop();
              else
                return {
                  pos: new hi(u, p),
                  ch: y
                };
            }
          }
      }
    }
    return u - n == (n > 0 ? t.lastLine() : t.firstLine()) ? false : null;
  }
  function JX(t, e) {
    return null;
  }
  function ZX(t, e) {
    var n, r, i = t.cm6.state, o = t.indexFromPos(e);
    if (o < i.doc.length) {
      var s = i.sliceDoc(o, o + 1);
      s == "<" && o++;
    }
    for (var a = $R(i, o), l = (a == null ? void 0 : a.resolve(o)) || null; l; ) {
      if (((n = l.firstChild) === null || n === void 0 ? void 0 : n.type.name) == "OpenTag" && ((r = l.lastChild) === null || r === void 0 ? void 0 : r.type.name) == "CloseTag")
        return {
          open: sM(i.doc, l.firstChild),
          close: sM(i.doc, l.lastChild)
        };
      l = l.parent;
    }
  }
  function sM(t, e) {
    return {
      from: ur(t, e.from),
      to: ur(t, e.to)
    };
  }
  class eQ {
    constructor(e, n, r) {
      this.cm = e, this.id = e.$mid++, this.offset = n, this.assoc = r, e.marks[this.id] = this;
    }
    clear() {
      delete this.cm.marks[this.id];
    }
    find() {
      return this.offset == null ? null : this.cm.posFromIndex(this.offset);
    }
    update(e) {
      this.offset != null && (this.offset = e.mapPos(this.offset, this.assoc, Zt.TrackDel));
    }
  }
  function tQ(t, e) {
    for (var n, r = e.column || t.getOption("textwidth") || 80, i = e.allowMerge != false, o = Math.min(e.from, e.to), s = Math.max(e.from, e.to); o <= s; ) {
      var a = t.getLine(o);
      if (a.length > r) {
        var l = y(a, r, 5);
        if (l) {
          var c = (n = /^\s*/.exec(a)) === null || n === void 0 ? void 0 : n[0];
          t.replaceRange(`
` + c, new hi(o, l.start), new hi(o, l.end));
        }
        s++;
      } else if (i && /\S/.test(a) && o != s) {
        var u = t.getLine(o + 1);
        if (u && /\S/.test(u)) {
          var h = a.replace(/\s+$/, ""), p = u.replace(/^\s+/, ""), v = h + " " + p, l = y(v, r, 5);
          l && l.start > h.length || v.length < r ? (t.replaceRange(" ", new hi(o, h.length), new hi(o + 1, u.length - p.length)), o--, s--) : h.length < a.length && t.replaceRange("", new hi(o, h.length), new hi(o, a.length));
        }
      }
      o++;
    }
    return o;
    function y(x, T, w) {
      if (!(x.length < T)) {
        var k = x.slice(0, T), C = x.slice(T), P = /^(?:(\s+)|(\S+)(\s+))/.exec(C), R = /(?:(\s+)|(\s+)(\S+))$/.exec(k), L = 0, _ = 0;
        if (R && !R[2] && (L = T - R[1].length, _ = T), P && !P[2] && (L || (L = T), _ = T + P[1].length), L)
          return {
            start: L,
            end: _
          };
        if (R && R[2] && R.index > w)
          return {
            start: R.index,
            end: R.index + R[2].length
          };
        if (P && P[2])
          return L = T + P[2].length, {
            start: L,
            end: L + P[3].length
          };
      }
    }
  }
  let R1 = IU || function() {
    let t = {
      cursorBlinkRate: 1200
    };
    return function() {
      return t;
    };
  }();
  class nQ {
    constructor(e, n, r, i, o, s, a, l, c, u) {
      this.left = e, this.top = n, this.height = r, this.fontFamily = i, this.fontSize = o, this.fontWeight = s, this.color = a, this.className = l, this.letter = c, this.partial = u;
    }
    draw() {
      let e = document.createElement("div");
      return e.className = this.className, this.adjust(e), e;
    }
    adjust(e) {
      e.style.left = this.left + "px", e.style.top = this.top + "px", e.style.height = this.height + "px", e.style.lineHeight = this.height + "px", e.style.fontFamily = this.fontFamily, e.style.fontSize = this.fontSize, e.style.fontWeight = this.fontWeight, e.style.color = this.partial ? "transparent" : this.color, e.className = this.className, e.textContent = this.letter;
    }
    eq(e) {
      return this.left == e.left && this.top == e.top && this.height == e.height && this.fontFamily == e.fontFamily && this.fontSize == e.fontSize && this.fontWeight == e.fontWeight && this.color == e.color && this.className == e.className && this.letter == e.letter;
    }
  }
  class rQ {
    constructor(e, n) {
      this.view = e, this.rangePieces = [], this.cursors = [], this.cm = n, this.measureReq = {
        read: this.readPos.bind(this),
        write: this.drawSel.bind(this)
      }, this.cursorLayer = e.scrollDOM.appendChild(document.createElement("div")), this.cursorLayer.className = "cm-cursorLayer cm-vimCursorLayer", this.cursorLayer.setAttribute("aria-hidden", "true"), e.requestMeasure(this.measureReq), this.setBlinkRate();
    }
    setBlinkRate() {
      let n = R1(this.cm.cm6.state).cursorBlinkRate;
      this.cursorLayer.style.animationDuration = n + "ms";
    }
    update(e) {
      (e.selectionSet || e.geometryChanged || e.viewportChanged) && (this.view.requestMeasure(this.measureReq), this.cursorLayer.style.animationName = this.cursorLayer.style.animationName == "cm-blink" ? "cm-blink2" : "cm-blink"), iQ(e) && this.setBlinkRate();
    }
    scheduleRedraw() {
      this.view.requestMeasure(this.measureReq);
    }
    readPos() {
      let { state: e } = this.view, n = [];
      for (let r of e.selection.ranges) {
        let i = r == e.selection.main, o = lQ(this.cm, this.view, r, i);
        o && n.push(o);
      }
      return {
        cursors: n
      };
    }
    drawSel({ cursors: e }) {
      if (e.length != this.cursors.length || e.some((n, r) => !n.eq(this.cursors[r]))) {
        let n = this.cursorLayer.children;
        if (n.length !== e.length) {
          this.cursorLayer.textContent = "";
          for (const r of e)
            this.cursorLayer.appendChild(r.draw());
        } else
          e.forEach((r, i) => r.adjust(n[i]));
        this.cursors = e;
      }
    }
    destroy() {
      this.cursorLayer.remove();
    }
  }
  function iQ(t) {
    return R1(t.startState) != R1(t.state);
  }
  const oQ = {
    ".cm-vimMode .cm-line": {
      "& ::selection": {
        backgroundColor: "transparent !important"
      },
      "&::selection": {
        backgroundColor: "transparent !important"
      },
      caretColor: "transparent !important"
    },
    ".cm-fat-cursor": {
      position: "absolute",
      background: "#ff9696",
      border: "none",
      whiteSpace: "pre"
    },
    "&:not(.cm-focused) .cm-fat-cursor": {
      background: "none",
      outline: "solid 1px #ff9696",
      color: "transparent !important"
    }
  }, sQ = ns.highest(ue.theme(oQ));
  function aQ(t) {
    let e = t.scrollDOM.getBoundingClientRect();
    return {
      left: (t.textDirection == rt.LTR ? e.left : e.right - t.scrollDOM.clientWidth) - t.scrollDOM.scrollLeft * t.scaleX,
      top: e.top - t.scrollDOM.scrollTop * t.scaleY
    };
  }
  function lQ(t, e, n, r) {
    var i, o, s, a;
    let l = n.head, c = false, u = 1, h = t.state.vim;
    if (h && (!h.insertMode || t.state.overwrite)) {
      if (c = true, h.visualBlock && !r)
        return null;
      n.anchor < n.head && (l < e.state.doc.length && e.state.sliceDoc(l, l + 1)) != `
` && l--, t.state.overwrite ? u = 0.2 : h.status && (u = 0.5);
    }
    if (c) {
      let v = l < e.state.doc.length && e.state.sliceDoc(l, l + 1);
      v && /[\uDC00-\uDFFF]/.test(v) && l > 1 && (l--, v = e.state.sliceDoc(l, l + 1));
      let y = e.coordsAtPos(l, 1);
      if (!y)
        return null;
      let x = aQ(e), T = e.domAtPos(l), w = T ? T.node : e.contentDOM;
      for (w instanceof Text && T.offset >= w.data.length && !((i = w.parentElement) === null || i === void 0) && i.nextSibling && (w = (o = w.parentElement) === null || o === void 0 ? void 0 : o.nextSibling, T = {
        node: w,
        offset: 0
      }); T && T.node instanceof HTMLElement; )
        w = T.node, T = {
          node: T.node.childNodes[T.offset],
          offset: 0
        };
      if (!(w instanceof HTMLElement)) {
        if (!w.parentNode)
          return null;
        w = w.parentNode;
      }
      let k = getComputedStyle(w), C = y.left, P = (a = (s = e).coordsForChar) === null || a === void 0 ? void 0 : a.call(s, l);
      if (P && (C = P.left), !v || v == `
` || v == "\r")
        v = "\xA0";
      else if (v == "	") {
        v = "\xA0";
        var p = e.coordsAtPos(l + 1, -1);
        p && (C = p.left - (p.left - y.left) / parseInt(k.tabSize));
      } else
        /[\uD800-\uDBFF]/.test(v) && l < e.state.doc.length - 1 && (v += e.state.sliceDoc(l + 1, l + 2));
      let R = y.bottom - y.top;
      return new nQ((C - x.left) / e.scaleX, (y.top - x.top + R * (1 - u)) / e.scaleY, R * u / e.scaleY, k.fontFamily, k.fontSize, k.fontWeight, k.color, r ? "cm-fat-cursor cm-cursor-primary" : "cm-fat-cursor cm-cursor-secondary", v, u != 1);
    } else
      return null;
  }
  var cQ = typeof navigator < "u" && /linux/i.test(navigator.platform) && / Gecko\/\d+/.exec(navigator.userAgent);
  const gs = UX(Oe), uQ = 250, fQ = ue.baseTheme({
    ".cm-vimMode .cm-cursorLayer:not(.cm-vimCursorLayer)": {
      display: "none"
    },
    ".cm-vim-panel": {
      padding: "0px 10px",
      fontFamily: "monospace",
      minHeight: "1.3em",
      display: "flex"
    },
    ".cm-vim-panel input": {
      border: "none",
      outline: "none",
      backgroundColor: "inherit"
    },
    "&light .cm-searchMatch": {
      backgroundColor: "#ffff0054"
    },
    "&dark .cm-searchMatch": {
      backgroundColor: "#00ffff8a"
    }
  }), hQ = Ct.fromClass(class {
    constructor(t) {
      this.status = "", this.query = null, this.decorations = be.none, this.waitForCopy = false, this.lastKeydown = "", this.useNextTextInput = false, this.compositionText = "", this.view = t;
      const e = this.cm = new Oe(t);
      gs.enterVimMode(this.cm), this.view.cm = this.cm, this.cm.state.vimPlugin = this, this.blockCursor = new rQ(t, e), this.updateClass(), this.cm.on("vim-command-done", () => {
        e.state.vim && (e.state.vim.status = ""), this.blockCursor.scheduleRedraw(), this.updateStatus();
      }), this.cm.on("vim-mode-change", (n) => {
        !e.state.vim || (e.state.vim.mode = n.mode, n.subMode && (e.state.vim.mode += " block"), e.state.vim.status = "", this.blockCursor.scheduleRedraw(), this.updateClass(), this.updateStatus());
      }), this.cm.on("dialog", () => {
        this.cm.state.statusbar ? this.updateStatus() : t.dispatch({
          effects: s_.of(!!this.cm.state.dialog)
        });
      }), this.dom = document.createElement("span"), this.spacer = document.createElement("span"), this.spacer.style.flex = "1", this.statusButton = document.createElement("span"), this.statusButton.onclick = (n) => {
        gs.handleKey(this.cm, "<Esc>", "user"), this.cm.focus();
      }, this.statusButton.style.cssText = "cursor: pointer";
    }
    update(t) {
      var e;
      if ((t.viewportChanged || t.docChanged) && this.query && this.highlight(this.query), t.docChanged && this.cm.onChange(t), t.selectionSet && this.cm.onSelectionChange(), t.viewportChanged, this.cm.curOp && !this.cm.curOp.isVimOp && this.cm.onBeforeEndOperation(), t.transactions) {
        for (let n of t.transactions)
          for (let r of n.effects)
            if (r.is(Jo))
              if (!((e = r.value) === null || e === void 0 ? void 0 : e.forVim))
                this.highlight(null);
              else {
                let o = r.value.create();
                this.highlight(o);
              }
      }
      this.blockCursor.update(t);
    }
    updateClass() {
      const t = this.cm.state;
      !t.vim || t.vim.insertMode && !t.overwrite ? this.view.scrollDOM.classList.remove("cm-vimMode") : this.view.scrollDOM.classList.add("cm-vimMode");
    }
    updateStatus() {
      let t = this.cm.state.statusbar, e = this.cm.state.vim;
      if (!t || !e)
        return;
      let n = this.cm.state.dialog;
      if (n)
        n.parentElement != t && (t.textContent = "", t.appendChild(n));
      else {
        t.textContent = "";
        var r = (e.mode || "normal").toUpperCase();
        e.insertModeReturn && (r += "(C-O)"), this.statusButton.textContent = `--${r}--`, t.appendChild(this.statusButton), t.appendChild(this.spacer);
      }
      this.dom.textContent = e.status, t.appendChild(this.dom);
    }
    destroy() {
      gs.leaveVimMode(this.cm), this.updateClass(), this.blockCursor.destroy(), delete this.view.cm;
    }
    highlight(t) {
      if (this.query = t, !t)
        return this.decorations = be.none;
      let { view: e } = this, n = new Mi();
      for (let r = 0, i = e.visibleRanges, o = i.length; r < o; r++) {
        let { from: s, to: a } = i[r];
        for (; r < o - 1 && a > i[r + 1].from - 2 * uQ; )
          a = i[++r].to;
        t.highlight(e.state, s, a, (l, c) => {
          n.add(l, c, pQ);
        });
      }
      return this.decorations = n.finish();
    }
    handleKey(t, e) {
      const n = this.cm;
      let r = n.state.vim;
      if (!r)
        return;
      const i = gs.vimKeyFromEvent(t, r);
      if (Oe.signal(this.cm, "inputEvent", {
        type: "handleKey",
        key: i
      }), !i)
        return;
      if (i == "<Esc>" && !r.insertMode && !r.visualMode && this.query) {
        const a = r.searchState_;
        a && (n.removeOverlay(a.getOverlay()), a.setOverlay(null));
      }
      if (i === "<C-c>" && !Oe.isMac && n.somethingSelected())
        return this.waitForCopy = true, true;
      r.status = (r.status || "") + i;
      let s = gs.multiSelectHandleKey(n, i, "user");
      return r = gs.maybeInitVimState_(n), !s && r.insertMode && n.state.overwrite && (t.key && t.key.length == 1 && !/\n/.test(t.key) ? (s = true, n.overWriteSelection(t.key)) : t.key == "Backspace" && (s = true, Oe.commands.cursorCharLeft(n))), s && (Oe.signal(this.cm, "vim-keypress", i), t.preventDefault(), t.stopPropagation(), this.blockCursor.scheduleRedraw()), this.updateStatus(), !!s;
    }
  }, {
    eventHandlers: {
      copy: function(t, e) {
        !this.waitForCopy || (this.waitForCopy = false, Promise.resolve().then(() => {
          var n = this.cm, r = n.state.vim;
          !r || (r.insertMode ? n.setSelection(n.getCursor(), n.getCursor()) : n.operation(() => {
            n.curOp && (n.curOp.isVimOp = true), gs.handleKey(n, "<Esc>", "user");
          }));
        }));
      },
      compositionstart: function(t, e) {
        this.useNextTextInput = true, Oe.signal(this.cm, "inputEvent", t);
      },
      compositionupdate: function(t, e) {
        Oe.signal(this.cm, "inputEvent", t);
      },
      compositionend: function(t, e) {
        Oe.signal(this.cm, "inputEvent", t);
      },
      keypress: function(t, e) {
        Oe.signal(this.cm, "inputEvent", t), this.lastKeydown == "Dead" && this.handleKey(t, e);
      },
      keydown: function(t, e) {
        Oe.signal(this.cm, "inputEvent", t), this.lastKeydown = t.key, this.lastKeydown == "Unidentified" || this.lastKeydown == "Process" || this.lastKeydown == "Dead" ? this.useNextTextInput = true : (this.useNextTextInput = false, this.handleKey(t, e));
      }
    },
    provide: () => [
      ue.inputHandler.of((t, e, n, r) => {
        var i, o, s = bQ(t);
        if (!s)
          return false;
        var a = (i = s.state) === null || i === void 0 ? void 0 : i.vim, l = s.state.vimPlugin;
        if (a && !a.insertMode && !(!((o = s.curOp) === null || o === void 0) && o.isVimOp)) {
          if (r === "\0\0")
            return true;
          if (Oe.signal(s, "inputEvent", {
            type: "text",
            text: r,
            from: e,
            to: n
          }), r.length == 1 && l.useNextTextInput) {
            if (a.expectLiteralNext && t.composing)
              return l.compositionText = r, false;
            if (l.compositionText) {
              var c = l.compositionText;
              l.compositionText = "";
              var u = t.state.selection.main.head, h = t.state.sliceDoc(u - c.length, u);
              if (c === h) {
                var p = s.getCursor();
                s.replaceRange("", s.posFromIndex(u - c.length), p);
              }
            }
            return l.handleKey({
              key: r,
              preventDefault: () => {
              },
              stopPropagation: () => {
              }
            }), dQ(t), true;
          }
        }
        return false;
      })
    ],
    decorations: (t) => t.decorations
  });
  function dQ(t) {
    var e = t.scrollDOM.parentElement;
    if (!!e) {
      if (cQ) {
        t.contentDOM.textContent = "\0\0", t.contentDOM.dispatchEvent(new CustomEvent("compositionend"));
        return;
      }
      var n = t.scrollDOM.nextSibling, r = window.getSelection(), i = r && {
        anchorNode: r.anchorNode,
        anchorOffset: r.anchorOffset,
        focusNode: r.focusNode,
        focusOffset: r.focusOffset
      };
      t.scrollDOM.remove(), e.insertBefore(t.scrollDOM, n);
      try {
        i && r && (r.setPosition(i.anchorNode, i.anchorOffset), i.focusNode && r.extend(i.focusNode, i.focusOffset));
      } catch (o) {
        console.error(o);
      }
      t.focus(), t.contentDOM.dispatchEvent(new CustomEvent("compositionend"));
    }
  }
  const pQ = be.mark({
    class: "cm-searchMatch"
  }), s_ = Ee.define(), mQ = Ut.define({
    create: () => false,
    update(t, e) {
      for (let n of e.effects)
        n.is(s_) && (t = n.value);
      return t;
    },
    provide: (t) => Gs.from(t, (e) => e ? gQ : null)
  });
  function gQ(t) {
    let e = document.createElement("div");
    e.className = "cm-vim-panel";
    let n = t.cm;
    return n.state.dialog && e.appendChild(n.state.dialog), {
      top: false,
      dom: e
    };
  }
  function vQ(t) {
    let e = document.createElement("div");
    e.className = "cm-vim-panel";
    let n = t.cm;
    return n.state.statusbar = e, n.state.vimPlugin.updateStatus(), {
      dom: e
    };
  }
  function yQ(t = {}) {
    return [
      fQ,
      hQ,
      sQ,
      t.status ? Gs.of(vQ) : mQ
    ];
  }
  function bQ(t) {
    return t.cm || null;
  }
  function aM(t) {
    return J(JL, {
      ...t == null ? void 0 : t.extra,
      value: t == null ? void 0 : t.code,
      height: "100%",
      extensions: [
        yQ()
      ],
      onChange: t == null ? void 0 : t.onChange
    });
  }
  var xQ = "Expected a function", lM = 0 / 0, SQ = "[object Symbol]", wQ = /^\s+|\s+$/g, kQ = /^[-+]0x[0-9a-f]+$/i, CQ = /^0b[01]+$/i, TQ = /^0o[0-7]+$/i, MQ = parseInt, AQ = typeof Ao == "object" && Ao && Ao.Object === Object && Ao, EQ = typeof self == "object" && self && self.Object === Object && self, PQ = AQ || EQ || Function("return this")(), OQ = Object.prototype, RQ = OQ.toString, LQ = Math.max, _Q = Math.min, rv = function() {
    return PQ.Date.now();
  };
  function DQ(t, e, n) {
    var r, i, o, s, a, l, c = 0, u = false, h = false, p = true;
    if (typeof t != "function")
      throw new TypeError(xQ);
    e = cM(e) || 0, L1(n) && (u = !!n.leading, h = "maxWait" in n, o = h ? LQ(cM(n.maxWait) || 0, e) : o, p = "trailing" in n ? !!n.trailing : p);
    function v(L) {
      var _ = r, F = i;
      return r = i = void 0, c = L, s = t.apply(F, _), s;
    }
    function y(L) {
      return c = L, a = setTimeout(w, e), u ? v(L) : s;
    }
    function x(L) {
      var _ = L - l, F = L - c, K = e - _;
      return h ? _Q(K, o - F) : K;
    }
    function T(L) {
      var _ = L - l, F = L - c;
      return l === void 0 || _ >= e || _ < 0 || h && F >= o;
    }
    function w() {
      var L = rv();
      if (T(L))
        return k(L);
      a = setTimeout(w, x(L));
    }
    function k(L) {
      return a = void 0, p && r ? v(L) : (r = i = void 0, s);
    }
    function C() {
      a !== void 0 && clearTimeout(a), c = 0, r = l = i = a = void 0;
    }
    function P() {
      return a === void 0 ? s : k(rv());
    }
    function R() {
      var L = rv(), _ = T(L);
      if (r = arguments, i = this, l = L, _) {
        if (a === void 0)
          return y(l);
        if (h)
          return a = setTimeout(w, e), v(l);
      }
      return a === void 0 && (a = setTimeout(w, e)), s;
    }
    return R.cancel = C, R.flush = P, R;
  }
  function L1(t) {
    var e = typeof t;
    return !!t && (e == "object" || e == "function");
  }
  function IQ(t) {
    return !!t && typeof t == "object";
  }
  function BQ(t) {
    return typeof t == "symbol" || IQ(t) && RQ.call(t) == SQ;
  }
  function cM(t) {
    if (typeof t == "number")
      return t;
    if (BQ(t))
      return lM;
    if (L1(t)) {
      var e = typeof t.valueOf == "function" ? t.valueOf() : t;
      t = L1(e) ? e + "" : e;
    }
    if (typeof t != "string")
      return t === 0 ? t : +t;
    t = t.replace(wQ, "");
    var n = CQ.test(t);
    return n || TQ.test(t) ? MQ(t.slice(2), n ? 2 : 8) : kQ.test(t) ? lM : +t;
  }
  var NQ = DQ;
  const $Q = async (t = {}, e) => {
    let n;
    if (e.startsWith("data:")) {
      const r = e.replace(/^data:.*?base64,/, "");
      let i;
      if (typeof Buffer == "function" && typeof Buffer.from == "function")
        i = Buffer.from(r, "base64");
      else if (typeof atob == "function") {
        const o = atob(r);
        i = new Uint8Array(o.length);
        for (let s = 0; s < o.length; s++)
          i[s] = o.charCodeAt(s);
      } else
        throw new Error("Cannot decode base64-encoded data URL");
      n = await WebAssembly.instantiate(i, t);
    } else {
      const r = await fetch(e), i = r.headers.get("Content-Type") || "";
      if ("instantiateStreaming" in WebAssembly && i.startsWith("application/wasm"))
        n = await WebAssembly.instantiateStreaming(r, t);
      else {
        const o = await r.arrayBuffer();
        n = await WebAssembly.instantiate(o, t);
      }
    }
    return n.instance.exports;
  };
  let yr;
  function zQ(t) {
    yr = t;
  }
  let Wh = null;
  function Od() {
    return (Wh === null || Wh.byteLength === 0) && (Wh = new Uint8Array(yr.memory.buffer)), Wh;
  }
  let Rd = new TextDecoder("utf-8", {
    ignoreBOM: true,
    fatal: true
  });
  Rd.decode();
  const FQ = 2146435072;
  let iv = 0;
  function VQ(t, e) {
    return iv += e, iv >= FQ && (Rd = new TextDecoder("utf-8", {
      ignoreBOM: true,
      fatal: true
    }), Rd.decode(), iv = e), Rd.decode(Od().subarray(t, t + e));
  }
  function cS(t, e) {
    return t = t >>> 0, VQ(t, e);
  }
  let Hp = 0;
  const nu = new TextEncoder();
  "encodeInto" in nu || (nu.encodeInto = function(t, e) {
    const n = nu.encode(t);
    return e.set(n), {
      read: t.length,
      written: n.length
    };
  });
  function a_(t, e, n) {
    if (n === void 0) {
      const a = nu.encode(t), l = e(a.length, 1) >>> 0;
      return Od().subarray(l, l + a.length).set(a), Hp = a.length, l;
    }
    let r = t.length, i = e(r, 1) >>> 0;
    const o = Od();
    let s = 0;
    for (; s < r; s++) {
      const a = t.charCodeAt(s);
      if (a > 127)
        break;
      o[i + s] = a;
    }
    if (s !== r) {
      s !== 0 && (t = t.slice(s)), i = n(i, r, r = s + t.length * 3, 1) >>> 0;
      const a = Od().subarray(i + s, i + r), l = nu.encodeInto(t, a);
      s += l.written, i = n(i, r, s, 1) >>> 0;
    }
    return Hp = s, i;
  }
  let ca = null;
  function uM() {
    return (ca === null || ca.buffer.detached === true || ca.buffer.detached === void 0 && ca.buffer !== yr.memory.buffer) && (ca = new DataView(yr.memory.buffer)), ca;
  }
  function HQ(t) {
    let e, n;
    try {
      const r = a_(t, yr.__wbindgen_malloc, yr.__wbindgen_realloc), i = Hp, o = yr.compile(r, i);
      return e = o[0], n = o[1], cS(o[0], o[1]);
    } finally {
      yr.__wbindgen_free(e, n, 1);
    }
  }
  function jQ(t, e) {
    let n, r;
    try {
      n = t, r = e, console.error(cS(t, e));
    } finally {
      yr.__wbindgen_free(n, r, 1);
    }
  }
  function WQ() {
    return new Error();
  }
  function UQ(t, e) {
    const n = e.stack, r = a_(n, yr.__wbindgen_malloc, yr.__wbindgen_realloc), i = Hp;
    uM().setInt32(t + 4 * 1, i, true), uM().setInt32(t + 4 * 0, r, true);
  }
  function KQ(t, e) {
    throw new Error(cS(t, e));
  }
  function qQ() {
    const t = yr.__wbindgen_export_3, e = t.grow(4);
    t.set(0, void 0), t.set(e + 0, void 0), t.set(e + 1, null), t.set(e + 2, true), t.set(e + 3, false);
  }
  const is = await $Q({
    "./monkey_wasm_bg.js": {
      __wbg_new_8a6f238a6ece86ea: WQ,
      __wbg_stack_0ed75d68575b0f3c: UQ,
      __wbg_error_7534b8e9a36f1ab4: jQ,
      __wbg_wbindgenthrow_451ec1a8469d7eb6: KQ,
      __wbindgen_init_externref_table: qQ
    }
  }, "/monkey-rust/assets/monkey_wasm_bg.db76e384.wasm?init"), GQ = is.memory, YQ = is.parse, XQ = is.compile, QQ = is.__wbindgen_free, JQ = is.__wbindgen_malloc, ZQ = is.__wbindgen_realloc, eJ = is.__wbindgen_export_3, l_ = is.__wbindgen_start, tJ = Object.freeze(Object.defineProperty({
    __proto__: null,
    memory: GQ,
    parse: YQ,
    compile: XQ,
    __wbindgen_free: QQ,
    __wbindgen_malloc: JQ,
    __wbindgen_realloc: ZQ,
    __wbindgen_export_3: eJ,
    __wbindgen_start: l_
  }, Symbol.toStringTag, {
    value: "Module"
  }));
  zQ(tJ);
  l_();
  const nJ = `
1 + 1;
if (true) { 10 }; 3333;
let a = [1, 2, 3];
`;
  function rJ() {
    let t = nJ.trimStart(), [e] = z.exports.useState(t);
    const n = (a) => {
      console.log(a), e = a, s(), console.log("change finished");
    };
    let [r, i] = z.exports.useState("");
    const o = () => {
      try {
        const a = HQ(e);
        i(a);
      } catch (a) {
        i(a.toString());
      }
    }, s = z.exports.useMemo(() => NQ(o, 200), [
      o
    ]);
    return z.exports.useEffect(() => {
      o();
    }, []), Xn(ZP, {
      templateColumns: "repeat(2, 1fr)",
      height: "100vh",
      gap: 6,
      children: [
        J(aM, {
          onChange: n,
          code: e
        }),
        Xn(nO, {
          size: "md",
          variant: "enclosed",
          children: [
            J(iO, {
              children: J(rO, {
                children: "Bytecode"
              })
            }),
            Xn(oO, {
              children: [
                J(_y, {
                  padding: 0,
                  children: J(aM, {
                    code: r,
                    extra: {
                      readOnly: true,
                      editable: false
                    }
                  })
                }),
                J(_y, {
                  children: J("p", {
                    children: "two!"
                  })
                })
              ]
            })
          ]
        })
      ]
    });
  }
  ov.createRoot(document.getElementById("root")).render(J(jp.StrictMode, {
    children: J(uW, {
      children: J(rJ, {})
    })
  }));
})();
