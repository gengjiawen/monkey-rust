var __getOwnPropNames = Object.getOwnPropertyNames;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var require_stdin = __commonJS({
  "<stdin>"(exports, module) {
    (async () => {
      var _a2, _b2, _c2, _d2, _e, _f, _g2, _h2, _i2, _j2, _k2, _l, _m2, _n2, _o2, _p2, _q2;
      function cD(t, e) {
        for (var n = 0; n < e.length; n++) {
          const r = e[n];
          if (typeof r != "string" && !Array.isArray(r)) {
            for (const i in r)
              if (i !== "default" && !(i in t)) {
                const o = Object.getOwnPropertyDescriptor(r, i);
                o && Object.defineProperty(t, i, o.get ? o : {
                  enumerable: true,
                  get: () => r[i]
                });
              }
          }
        }
        return Object.freeze(Object.defineProperty(t, Symbol.toStringTag, {
          value: "Module"
        }));
      }
      (function() {
        const e = document.createElement("link").relList;
        if (e && e.supports && e.supports("modulepreload"))
          return;
        for (const i of document.querySelectorAll('link[rel="modulepreload"]'))
          r(i);
        new MutationObserver((i) => {
          for (const o of i)
            if (o.type === "childList")
              for (const s of o.addedNodes)
                s.tagName === "LINK" && s.rel === "modulepreload" && r(s);
        }).observe(document, {
          childList: true,
          subtree: true
        });
        function n(i) {
          const o = {};
          return i.integrity && (o.integrity = i.integrity), i.referrerpolicy && (o.referrerPolicy = i.referrerpolicy), i.crossorigin === "use-credentials" ? o.credentials = "include" : i.crossorigin === "anonymous" ? o.credentials = "omit" : o.credentials = "same-origin", o;
        }
        function r(i) {
          if (i.ep)
            return;
          i.ep = true;
          const o = n(i);
          fetch(i.href, o);
        }
      })();
      var Ao = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
      function uD(t) {
        return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, "default") ? t.default : t;
      }
      var z = {
        exports: {}
      }, Ie = {};
      var Wu = Symbol.for("react.element"), fD = Symbol.for("react.portal"), hD = Symbol.for("react.fragment"), dD = Symbol.for("react.strict_mode"), pD = Symbol.for("react.profiler"), mD = Symbol.for("react.provider"), gD = Symbol.for("react.context"), vD = Symbol.for("react.forward_ref"), yD = Symbol.for("react.suspense"), bD = Symbol.for("react.memo"), xD = Symbol.for("react.lazy"), lS = Symbol.iterator;
      function SD(t) {
        return t === null || typeof t != "object" ? null : (t = lS && t[lS] || t["@@iterator"], typeof t == "function" ? t : null);
      }
      var aM = {
        isMounted: function() {
          return false;
        },
        enqueueForceUpdate: function() {
        },
        enqueueReplaceState: function() {
        },
        enqueueSetState: function() {
        }
      }, lM = Object.assign, cM = {};
      function Sl(t, e, n) {
        this.props = t, this.context = e, this.refs = cM, this.updater = n || aM;
      }
      Sl.prototype.isReactComponent = {};
      Sl.prototype.setState = function(t, e) {
        if (typeof t != "object" && typeof t != "function" && t != null)
          throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
        this.updater.enqueueSetState(this, t, e, "setState");
      };
      Sl.prototype.forceUpdate = function(t) {
        this.updater.enqueueForceUpdate(this, t, "forceUpdate");
      };
      function uM() {
      }
      uM.prototype = Sl.prototype;
      function O1(t, e, n) {
        this.props = t, this.context = e, this.refs = cM, this.updater = n || aM;
      }
      var R1 = O1.prototype = new uM();
      R1.constructor = O1;
      lM(R1, Sl.prototype);
      R1.isPureReactComponent = true;
      var cS = Array.isArray, fM = Object.prototype.hasOwnProperty, L1 = {
        current: null
      }, hM = {
        key: true,
        ref: true,
        __self: true,
        __source: true
      };
      function dM(t, e, n) {
        var r, i = {}, o = null, s = null;
        if (e != null)
          for (r in e.ref !== void 0 && (s = e.ref), e.key !== void 0 && (o = "" + e.key), e)
            fM.call(e, r) && !hM.hasOwnProperty(r) && (i[r] = e[r]);
        var a = arguments.length - 2;
        if (a === 1)
          i.children = n;
        else if (1 < a) {
          for (var l = Array(a), c = 0; c < a; c++)
            l[c] = arguments[c + 2];
          i.children = l;
        }
        if (t && t.defaultProps)
          for (r in a = t.defaultProps, a)
            i[r] === void 0 && (i[r] = a[r]);
        return {
          $$typeof: Wu,
          type: t,
          key: o,
          ref: s,
          props: i,
          _owner: L1.current
        };
      }
      function wD(t, e) {
        return {
          $$typeof: Wu,
          type: t.type,
          key: e,
          ref: t.ref,
          props: t.props,
          _owner: t._owner
        };
      }
      function D1(t) {
        return typeof t == "object" && t !== null && t.$$typeof === Wu;
      }
      function kD(t) {
        var e = {
          "=": "=0",
          ":": "=2"
        };
        return "$" + t.replace(/[=:]/g, function(n) {
          return e[n];
        });
      }
      var uS = /\/+/g;
      function Mg(t, e) {
        return typeof t == "object" && t !== null && t.key != null ? kD("" + t.key) : e.toString(36);
      }
      function Hh(t, e, n, r, i) {
        var o = typeof t;
        (o === "undefined" || o === "boolean") && (t = null);
        var s = false;
        if (t === null)
          s = true;
        else
          switch (o) {
            case "string":
            case "number":
              s = true;
              break;
            case "object":
              switch (t.$$typeof) {
                case Wu:
                case fD:
                  s = true;
              }
          }
        if (s)
          return s = t, i = i(s), t = r === "" ? "." + Mg(s, 0) : r, cS(i) ? (n = "", t != null && (n = t.replace(uS, "$&/") + "/"), Hh(i, e, n, "", function(c) {
            return c;
          })) : i != null && (D1(i) && (i = wD(i, n + (!i.key || s && s.key === i.key ? "" : ("" + i.key).replace(uS, "$&/") + "/") + t)), e.push(i)), 1;
        if (s = 0, r = r === "" ? "." : r + ":", cS(t))
          for (var a = 0; a < t.length; a++) {
            o = t[a];
            var l = r + Mg(o, a);
            s += Hh(o, e, n, l, i);
          }
        else if (l = SD(t), typeof l == "function")
          for (t = l.call(t), a = 0; !(o = t.next()).done; )
            o = o.value, l = r + Mg(o, a++), s += Hh(o, e, n, l, i);
        else if (o === "object")
          throw e = String(t), Error("Objects are not valid as a React child (found: " + (e === "[object Object]" ? "object with keys {" + Object.keys(t).join(", ") + "}" : e) + "). If you meant to render a collection of children, use an array instead.");
        return s;
      }
      function zf(t, e, n) {
        if (t == null)
          return t;
        var r = [], i = 0;
        return Hh(t, r, "", "", function(o) {
          return e.call(n, o, i++);
        }), r;
      }
      function CD(t) {
        if (t._status === -1) {
          var e = t._result;
          e = e(), e.then(function(n) {
            (t._status === 0 || t._status === -1) && (t._status = 1, t._result = n);
          }, function(n) {
            (t._status === 0 || t._status === -1) && (t._status = 2, t._result = n);
          }), t._status === -1 && (t._status = 0, t._result = e);
        }
        if (t._status === 1)
          return t._result.default;
        throw t._result;
      }
      var Tn = {
        current: null
      }, jh = {
        transition: null
      }, TD = {
        ReactCurrentDispatcher: Tn,
        ReactCurrentBatchConfig: jh,
        ReactCurrentOwner: L1
      };
      Ie.Children = {
        map: zf,
        forEach: function(t, e, n) {
          zf(t, function() {
            e.apply(this, arguments);
          }, n);
        },
        count: function(t) {
          var e = 0;
          return zf(t, function() {
            e++;
          }), e;
        },
        toArray: function(t) {
          return zf(t, function(e) {
            return e;
          }) || [];
        },
        only: function(t) {
          if (!D1(t))
            throw Error("React.Children.only expected to receive a single React element child.");
          return t;
        }
      };
      Ie.Component = Sl;
      Ie.Fragment = hD;
      Ie.Profiler = pD;
      Ie.PureComponent = O1;
      Ie.StrictMode = dD;
      Ie.Suspense = yD;
      Ie.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = TD;
      Ie.cloneElement = function(t, e, n) {
        if (t == null)
          throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + t + ".");
        var r = lM({}, t.props), i = t.key, o = t.ref, s = t._owner;
        if (e != null) {
          if (e.ref !== void 0 && (o = e.ref, s = L1.current), e.key !== void 0 && (i = "" + e.key), t.type && t.type.defaultProps)
            var a = t.type.defaultProps;
          for (l in e)
            fM.call(e, l) && !hM.hasOwnProperty(l) && (r[l] = e[l] === void 0 && a !== void 0 ? a[l] : e[l]);
        }
        var l = arguments.length - 2;
        if (l === 1)
          r.children = n;
        else if (1 < l) {
          a = Array(l);
          for (var c = 0; c < l; c++)
            a[c] = arguments[c + 2];
          r.children = a;
        }
        return {
          $$typeof: Wu,
          type: t.type,
          key: i,
          ref: o,
          props: r,
          _owner: s
        };
      };
      Ie.createContext = function(t) {
        return t = {
          $$typeof: gD,
          _currentValue: t,
          _currentValue2: t,
          _threadCount: 0,
          Provider: null,
          Consumer: null,
          _defaultValue: null,
          _globalName: null
        }, t.Provider = {
          $$typeof: mD,
          _context: t
        }, t.Consumer = t;
      };
      Ie.createElement = dM;
      Ie.createFactory = function(t) {
        var e = dM.bind(null, t);
        return e.type = t, e;
      };
      Ie.createRef = function() {
        return {
          current: null
        };
      };
      Ie.forwardRef = function(t) {
        return {
          $$typeof: vD,
          render: t
        };
      };
      Ie.isValidElement = D1;
      Ie.lazy = function(t) {
        return {
          $$typeof: xD,
          _payload: {
            _status: -1,
            _result: t
          },
          _init: CD
        };
      };
      Ie.memo = function(t, e) {
        return {
          $$typeof: bD,
          type: t,
          compare: e === void 0 ? null : e
        };
      };
      Ie.startTransition = function(t) {
        var e = jh.transition;
        jh.transition = {};
        try {
          t();
        } finally {
          jh.transition = e;
        }
      };
      Ie.unstable_act = function() {
        throw Error("act(...) is not supported in production builds of React.");
      };
      Ie.useCallback = function(t, e) {
        return Tn.current.useCallback(t, e);
      };
      Ie.useContext = function(t) {
        return Tn.current.useContext(t);
      };
      Ie.useDebugValue = function() {
      };
      Ie.useDeferredValue = function(t) {
        return Tn.current.useDeferredValue(t);
      };
      Ie.useEffect = function(t, e) {
        return Tn.current.useEffect(t, e);
      };
      Ie.useId = function() {
        return Tn.current.useId();
      };
      Ie.useImperativeHandle = function(t, e, n) {
        return Tn.current.useImperativeHandle(t, e, n);
      };
      Ie.useInsertionEffect = function(t, e) {
        return Tn.current.useInsertionEffect(t, e);
      };
      Ie.useLayoutEffect = function(t, e) {
        return Tn.current.useLayoutEffect(t, e);
      };
      Ie.useMemo = function(t, e) {
        return Tn.current.useMemo(t, e);
      };
      Ie.useReducer = function(t, e, n) {
        return Tn.current.useReducer(t, e, n);
      };
      Ie.useRef = function(t) {
        return Tn.current.useRef(t);
      };
      Ie.useState = function(t) {
        return Tn.current.useState(t);
      };
      Ie.useSyncExternalStore = function(t, e, n) {
        return Tn.current.useSyncExternalStore(t, e, n);
      };
      Ie.useTransition = function() {
        return Tn.current.useTransition();
      };
      Ie.version = "18.2.0";
      (function(t) {
        t.exports = Ie;
      })(z);
      const Wp = uD(z.exports), fS = cD({
        __proto__: null,
        default: Wp
      }, [
        z.exports
      ]);
      var rv = {}, Up = {
        exports: {}
      }, Zn = {}, pM = {
        exports: {}
      }, mM = {};
      (function(t) {
        function e(V, ae) {
          var ge = V.length;
          V.push(ae);
          e:
            for (; 0 < ge; ) {
              var Te = ge - 1 >>> 1, ve = V[Te];
              if (0 < i(ve, ae))
                V[Te] = ae, V[ge] = ve, ge = Te;
              else
                break e;
            }
        }
        function n(V) {
          return V.length === 0 ? null : V[0];
        }
        function r(V) {
          if (V.length === 0)
            return null;
          var ae = V[0], ge = V.pop();
          if (ge !== ae) {
            V[0] = ge;
            e:
              for (var Te = 0, ve = V.length, se = ve >>> 1; Te < se; ) {
                var re = 2 * (Te + 1) - 1, oe = V[re], De = re + 1, yt = V[De];
                if (0 > i(oe, ge))
                  De < ve && 0 > i(yt, oe) ? (V[Te] = yt, V[De] = ge, Te = De) : (V[Te] = oe, V[re] = ge, Te = re);
                else if (De < ve && 0 > i(yt, ge))
                  V[Te] = yt, V[De] = ge, Te = De;
                else
                  break e;
              }
          }
          return ae;
        }
        function i(V, ae) {
          var ge = V.sortIndex - ae.sortIndex;
          return ge !== 0 ? ge : V.id - ae.id;
        }
        if (typeof performance == "object" && typeof performance.now == "function") {
          var o = performance;
          t.unstable_now = function() {
            return o.now();
          };
        } else {
          var s = Date, a = s.now();
          t.unstable_now = function() {
            return s.now() - a;
          };
        }
        var l = [], c = [], u = 1, h = null, p = 3, v = false, y = false, S = false, C = typeof setTimeout == "function" ? setTimeout : null, w = typeof clearTimeout == "function" ? clearTimeout : null, k = typeof setImmediate < "u" ? setImmediate : null;
        typeof navigator < "u" && navigator.scheduling !== void 0 && navigator.scheduling.isInputPending !== void 0 && navigator.scheduling.isInputPending.bind(navigator.scheduling);
        function T(V) {
          for (var ae = n(c); ae !== null; ) {
            if (ae.callback === null)
              r(c);
            else if (ae.startTime <= V)
              r(c), ae.sortIndex = ae.expirationTime, e(l, ae);
            else
              break;
            ae = n(c);
          }
        }
        function P(V) {
          if (S = false, T(V), !y)
            if (n(l) !== null)
              y = true, Ee(R);
            else {
              var ae = n(c);
              ae !== null && Q(P, ae.startTime - V);
            }
        }
        function R(V, ae) {
          y = false, S && (S = false, w(F), F = -1), v = true;
          var ge = p;
          try {
            for (T(ae), h = n(l); h !== null && (!(h.expirationTime > ae) || V && !te()); ) {
              var Te = h.callback;
              if (typeof Te == "function") {
                h.callback = null, p = h.priorityLevel;
                var ve = Te(h.expirationTime <= ae);
                ae = t.unstable_now(), typeof ve == "function" ? h.callback = ve : h === n(l) && r(l), T(ae);
              } else
                r(l);
              h = n(l);
            }
            if (h !== null)
              var se = true;
            else {
              var re = n(c);
              re !== null && Q(P, re.startTime - ae), se = false;
            }
            return se;
          } finally {
            h = null, p = ge, v = false;
          }
        }
        var L = false, D = null, F = -1, K = 5, Y = -1;
        function te() {
          return !(t.unstable_now() - Y < K);
        }
        function ne() {
          if (D !== null) {
            var V = t.unstable_now();
            Y = V;
            var ae = true;
            try {
              ae = D(true, V);
            } finally {
              ae ? ue() : (L = false, D = null);
            }
          } else
            L = false;
        }
        var ue;
        if (typeof k == "function")
          ue = function() {
            k(ne);
          };
        else if (typeof MessageChannel < "u") {
          var ye = new MessageChannel(), ke = ye.port2;
          ye.port1.onmessage = ne, ue = function() {
            ke.postMessage(null);
          };
        } else
          ue = function() {
            C(ne, 0);
          };
        function Ee(V) {
          D = V, L || (L = true, ue());
        }
        function Q(V, ae) {
          F = C(function() {
            V(t.unstable_now());
          }, ae);
        }
        t.unstable_IdlePriority = 5, t.unstable_ImmediatePriority = 1, t.unstable_LowPriority = 4, t.unstable_NormalPriority = 3, t.unstable_Profiling = null, t.unstable_UserBlockingPriority = 2, t.unstable_cancelCallback = function(V) {
          V.callback = null;
        }, t.unstable_continueExecution = function() {
          y || v || (y = true, Ee(R));
        }, t.unstable_forceFrameRate = function(V) {
          0 > V || 125 < V ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : K = 0 < V ? Math.floor(1e3 / V) : 5;
        }, t.unstable_getCurrentPriorityLevel = function() {
          return p;
        }, t.unstable_getFirstCallbackNode = function() {
          return n(l);
        }, t.unstable_next = function(V) {
          switch (p) {
            case 1:
            case 2:
            case 3:
              var ae = 3;
              break;
            default:
              ae = p;
          }
          var ge = p;
          p = ae;
          try {
            return V();
          } finally {
            p = ge;
          }
        }, t.unstable_pauseExecution = function() {
        }, t.unstable_requestPaint = function() {
        }, t.unstable_runWithPriority = function(V, ae) {
          switch (V) {
            case 1:
            case 2:
            case 3:
            case 4:
            case 5:
              break;
            default:
              V = 3;
          }
          var ge = p;
          p = V;
          try {
            return ae();
          } finally {
            p = ge;
          }
        }, t.unstable_scheduleCallback = function(V, ae, ge) {
          var Te = t.unstable_now();
          switch (typeof ge == "object" && ge !== null ? (ge = ge.delay, ge = typeof ge == "number" && 0 < ge ? Te + ge : Te) : ge = Te, V) {
            case 1:
              var ve = -1;
              break;
            case 2:
              ve = 250;
              break;
            case 5:
              ve = 1073741823;
              break;
            case 4:
              ve = 1e4;
              break;
            default:
              ve = 5e3;
          }
          return ve = ge + ve, V = {
            id: u++,
            callback: ae,
            priorityLevel: V,
            startTime: ge,
            expirationTime: ve,
            sortIndex: -1
          }, ge > Te ? (V.sortIndex = ge, e(c, V), n(l) === null && V === n(c) && (S ? (w(F), F = -1) : S = true, Q(P, ge - Te))) : (V.sortIndex = ve, e(l, V), y || v || (y = true, Ee(R))), V;
        }, t.unstable_shouldYield = te, t.unstable_wrapCallback = function(V) {
          var ae = p;
          return function() {
            var ge = p;
            p = ae;
            try {
              return V.apply(this, arguments);
            } finally {
              p = ge;
            }
          };
        };
      })(mM);
      (function(t) {
        t.exports = mM;
      })(pM);
      var gM = z.exports, Jn = pM.exports;
      function ee(t) {
        for (var e = "https://reactjs.org/docs/error-decoder.html?invariant=" + t, n = 1; n < arguments.length; n++)
          e += "&args[]=" + encodeURIComponent(arguments[n]);
        return "Minified React error #" + t + "; visit " + e + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
      }
      var vM = /* @__PURE__ */ new Set(), tu = {};
      function Gs(t, e) {
        Ja(t, e), Ja(t + "Capture", e);
      }
      function Ja(t, e) {
        for (tu[t] = e, t = 0; t < e.length; t++)
          vM.add(e[t]);
      }
      var Gi = !(typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u"), iv = Object.prototype.hasOwnProperty, MD = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/, hS = {}, dS = {};
      function AD(t) {
        return iv.call(dS, t) ? true : iv.call(hS, t) ? false : MD.test(t) ? dS[t] = true : (hS[t] = true, false);
      }
      function ED(t, e, n, r) {
        if (n !== null && n.type === 0)
          return false;
        switch (typeof e) {
          case "function":
          case "symbol":
            return true;
          case "boolean":
            return r ? false : n !== null ? !n.acceptsBooleans : (t = t.toLowerCase().slice(0, 5), t !== "data-" && t !== "aria-");
          default:
            return false;
        }
      }
      function PD(t, e, n, r) {
        if (e === null || typeof e > "u" || ED(t, e, n, r))
          return true;
        if (r)
          return false;
        if (n !== null)
          switch (n.type) {
            case 3:
              return !e;
            case 4:
              return e === false;
            case 5:
              return isNaN(e);
            case 6:
              return isNaN(e) || 1 > e;
          }
        return false;
      }
      function Mn(t, e, n, r, i, o, s) {
        this.acceptsBooleans = e === 2 || e === 3 || e === 4, this.attributeName = r, this.attributeNamespace = i, this.mustUseProperty = n, this.propertyName = t, this.type = e, this.sanitizeURL = o, this.removeEmptyString = s;
      }
      var nn = {};
      "children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(t) {
        nn[t] = new Mn(t, 0, false, t, null, false, false);
      });
      [
        [
          "acceptCharset",
          "accept-charset"
        ],
        [
          "className",
          "class"
        ],
        [
          "htmlFor",
          "for"
        ],
        [
          "httpEquiv",
          "http-equiv"
        ]
      ].forEach(function(t) {
        var e = t[0];
        nn[e] = new Mn(e, 1, false, t[1], null, false, false);
      });
      [
        "contentEditable",
        "draggable",
        "spellCheck",
        "value"
      ].forEach(function(t) {
        nn[t] = new Mn(t, 2, false, t.toLowerCase(), null, false, false);
      });
      [
        "autoReverse",
        "externalResourcesRequired",
        "focusable",
        "preserveAlpha"
      ].forEach(function(t) {
        nn[t] = new Mn(t, 2, false, t, null, false, false);
      });
      "allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(t) {
        nn[t] = new Mn(t, 3, false, t.toLowerCase(), null, false, false);
      });
      [
        "checked",
        "multiple",
        "muted",
        "selected"
      ].forEach(function(t) {
        nn[t] = new Mn(t, 3, true, t, null, false, false);
      });
      [
        "capture",
        "download"
      ].forEach(function(t) {
        nn[t] = new Mn(t, 4, false, t, null, false, false);
      });
      [
        "cols",
        "rows",
        "size",
        "span"
      ].forEach(function(t) {
        nn[t] = new Mn(t, 6, false, t, null, false, false);
      });
      [
        "rowSpan",
        "start"
      ].forEach(function(t) {
        nn[t] = new Mn(t, 5, false, t.toLowerCase(), null, false, false);
      });
      var _1 = /[\-:]([a-z])/g;
      function I1(t) {
        return t[1].toUpperCase();
      }
      "accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(t) {
        var e = t.replace(_1, I1);
        nn[e] = new Mn(e, 1, false, t, null, false, false);
      });
      "xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(t) {
        var e = t.replace(_1, I1);
        nn[e] = new Mn(e, 1, false, t, "http://www.w3.org/1999/xlink", false, false);
      });
      [
        "xml:base",
        "xml:lang",
        "xml:space"
      ].forEach(function(t) {
        var e = t.replace(_1, I1);
        nn[e] = new Mn(e, 1, false, t, "http://www.w3.org/XML/1998/namespace", false, false);
      });
      [
        "tabIndex",
        "crossOrigin"
      ].forEach(function(t) {
        nn[t] = new Mn(t, 1, false, t.toLowerCase(), null, false, false);
      });
      nn.xlinkHref = new Mn("xlinkHref", 1, false, "xlink:href", "http://www.w3.org/1999/xlink", true, false);
      [
        "src",
        "href",
        "action",
        "formAction"
      ].forEach(function(t) {
        nn[t] = new Mn(t, 1, false, t.toLowerCase(), null, true, true);
      });
      function B1(t, e, n, r) {
        var i = nn.hasOwnProperty(e) ? nn[e] : null;
        (i !== null ? i.type !== 0 : r || !(2 < e.length) || e[0] !== "o" && e[0] !== "O" || e[1] !== "n" && e[1] !== "N") && (PD(e, n, i, r) && (n = null), r || i === null ? AD(e) && (n === null ? t.removeAttribute(e) : t.setAttribute(e, "" + n)) : i.mustUseProperty ? t[i.propertyName] = n === null ? i.type === 3 ? false : "" : n : (e = i.attributeName, r = i.attributeNamespace, n === null ? t.removeAttribute(e) : (i = i.type, n = i === 3 || i === 4 && n === true ? "" : "" + n, r ? t.setAttributeNS(r, e, n) : t.setAttribute(e, n))));
      }
      var io = gM.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, Ff = Symbol.for("react.element"), ha = Symbol.for("react.portal"), da = Symbol.for("react.fragment"), N1 = Symbol.for("react.strict_mode"), ov = Symbol.for("react.profiler"), yM = Symbol.for("react.provider"), bM = Symbol.for("react.context"), $1 = Symbol.for("react.forward_ref"), sv = Symbol.for("react.suspense"), av = Symbol.for("react.suspense_list"), z1 = Symbol.for("react.memo"), yo = Symbol.for("react.lazy"), xM = Symbol.for("react.offscreen"), pS = Symbol.iterator;
      function jl(t) {
        return t === null || typeof t != "object" ? null : (t = pS && t[pS] || t["@@iterator"], typeof t == "function" ? t : null);
      }
      var vt = Object.assign, Ag;
      function cc(t) {
        if (Ag === void 0)
          try {
            throw Error();
          } catch (n) {
            var e = n.stack.trim().match(/\n( *(at )?)/);
            Ag = e && e[1] || "";
          }
        return `
` + Ag + t;
      }
      var Eg = false;
      function Pg(t, e) {
        if (!t || Eg)
          return "";
        Eg = true;
        var n = Error.prepareStackTrace;
        Error.prepareStackTrace = void 0;
        try {
          if (e)
            if (e = function() {
              throw Error();
            }, Object.defineProperty(e.prototype, "props", {
              set: function() {
                throw Error();
              }
            }), typeof Reflect == "object" && Reflect.construct) {
              try {
                Reflect.construct(e, []);
              } catch (c) {
                var r = c;
              }
              Reflect.construct(t, [], e);
            } else {
              try {
                e.call();
              } catch (c) {
                r = c;
              }
              t.call(e.prototype);
            }
          else {
            try {
              throw Error();
            } catch (c) {
              r = c;
            }
            t();
          }
        } catch (c) {
          if (c && r && typeof c.stack == "string") {
            for (var i = c.stack.split(`
`), o = r.stack.split(`
`), s = i.length - 1, a = o.length - 1; 1 <= s && 0 <= a && i[s] !== o[a]; )
              a--;
            for (; 1 <= s && 0 <= a; s--, a--)
              if (i[s] !== o[a]) {
                if (s !== 1 || a !== 1)
                  do
                    if (s--, a--, 0 > a || i[s] !== o[a]) {
                      var l = `
` + i[s].replace(" at new ", " at ");
                      return t.displayName && l.includes("<anonymous>") && (l = l.replace("<anonymous>", t.displayName)), l;
                    }
                  while (1 <= s && 0 <= a);
                break;
              }
          }
        } finally {
          Eg = false, Error.prepareStackTrace = n;
        }
        return (t = t ? t.displayName || t.name : "") ? cc(t) : "";
      }
      function OD(t) {
        switch (t.tag) {
          case 5:
            return cc(t.type);
          case 16:
            return cc("Lazy");
          case 13:
            return cc("Suspense");
          case 19:
            return cc("SuspenseList");
          case 0:
          case 2:
          case 15:
            return t = Pg(t.type, false), t;
          case 11:
            return t = Pg(t.type.render, false), t;
          case 1:
            return t = Pg(t.type, true), t;
          default:
            return "";
        }
      }
      function lv(t) {
        if (t == null)
          return null;
        if (typeof t == "function")
          return t.displayName || t.name || null;
        if (typeof t == "string")
          return t;
        switch (t) {
          case da:
            return "Fragment";
          case ha:
            return "Portal";
          case ov:
            return "Profiler";
          case N1:
            return "StrictMode";
          case sv:
            return "Suspense";
          case av:
            return "SuspenseList";
        }
        if (typeof t == "object")
          switch (t.$$typeof) {
            case bM:
              return (t.displayName || "Context") + ".Consumer";
            case yM:
              return (t._context.displayName || "Context") + ".Provider";
            case $1:
              var e = t.render;
              return t = t.displayName, t || (t = e.displayName || e.name || "", t = t !== "" ? "ForwardRef(" + t + ")" : "ForwardRef"), t;
            case z1:
              return e = t.displayName || null, e !== null ? e : lv(t.type) || "Memo";
            case yo:
              e = t._payload, t = t._init;
              try {
                return lv(t(e));
              } catch {
              }
          }
        return null;
      }
      function RD(t) {
        var e = t.type;
        switch (t.tag) {
          case 24:
            return "Cache";
          case 9:
            return (e.displayName || "Context") + ".Consumer";
          case 10:
            return (e._context.displayName || "Context") + ".Provider";
          case 18:
            return "DehydratedFragment";
          case 11:
            return t = e.render, t = t.displayName || t.name || "", e.displayName || (t !== "" ? "ForwardRef(" + t + ")" : "ForwardRef");
          case 7:
            return "Fragment";
          case 5:
            return e;
          case 4:
            return "Portal";
          case 3:
            return "Root";
          case 6:
            return "Text";
          case 16:
            return lv(e);
          case 8:
            return e === N1 ? "StrictMode" : "Mode";
          case 22:
            return "Offscreen";
          case 12:
            return "Profiler";
          case 21:
            return "Scope";
          case 13:
            return "Suspense";
          case 19:
            return "SuspenseList";
          case 25:
            return "TracingMarker";
          case 1:
          case 0:
          case 17:
          case 2:
          case 14:
          case 15:
            if (typeof e == "function")
              return e.displayName || e.name || null;
            if (typeof e == "string")
              return e;
        }
        return null;
      }
      function Uo(t) {
        switch (typeof t) {
          case "boolean":
          case "number":
          case "string":
          case "undefined":
            return t;
          case "object":
            return t;
          default:
            return "";
        }
      }
      function SM(t) {
        var e = t.type;
        return (t = t.nodeName) && t.toLowerCase() === "input" && (e === "checkbox" || e === "radio");
      }
      function LD(t) {
        var e = SM(t) ? "checked" : "value", n = Object.getOwnPropertyDescriptor(t.constructor.prototype, e), r = "" + t[e];
        if (!t.hasOwnProperty(e) && typeof n < "u" && typeof n.get == "function" && typeof n.set == "function") {
          var i = n.get, o = n.set;
          return Object.defineProperty(t, e, {
            configurable: true,
            get: function() {
              return i.call(this);
            },
            set: function(s) {
              r = "" + s, o.call(this, s);
            }
          }), Object.defineProperty(t, e, {
            enumerable: n.enumerable
          }), {
            getValue: function() {
              return r;
            },
            setValue: function(s) {
              r = "" + s;
            },
            stopTracking: function() {
              t._valueTracker = null, delete t[e];
            }
          };
        }
      }
      function Vf(t) {
        t._valueTracker || (t._valueTracker = LD(t));
      }
      function wM(t) {
        if (!t)
          return false;
        var e = t._valueTracker;
        if (!e)
          return true;
        var n = e.getValue(), r = "";
        return t && (r = SM(t) ? t.checked ? "true" : "false" : t.value), t = r, t !== n ? (e.setValue(t), true) : false;
      }
      function Od(t) {
        if (t = t || (typeof document < "u" ? document : void 0), typeof t > "u")
          return null;
        try {
          return t.activeElement || t.body;
        } catch {
          return t.body;
        }
      }
      function cv(t, e) {
        var n = e.checked;
        return vt({}, e, {
          defaultChecked: void 0,
          defaultValue: void 0,
          value: void 0,
          checked: n ?? t._wrapperState.initialChecked
        });
      }
      function mS(t, e) {
        var n = e.defaultValue == null ? "" : e.defaultValue, r = e.checked != null ? e.checked : e.defaultChecked;
        n = Uo(e.value != null ? e.value : n), t._wrapperState = {
          initialChecked: r,
          initialValue: n,
          controlled: e.type === "checkbox" || e.type === "radio" ? e.checked != null : e.value != null
        };
      }
      function kM(t, e) {
        e = e.checked, e != null && B1(t, "checked", e, false);
      }
      function uv(t, e) {
        kM(t, e);
        var n = Uo(e.value), r = e.type;
        if (n != null)
          r === "number" ? (n === 0 && t.value === "" || t.value != n) && (t.value = "" + n) : t.value !== "" + n && (t.value = "" + n);
        else if (r === "submit" || r === "reset") {
          t.removeAttribute("value");
          return;
        }
        e.hasOwnProperty("value") ? fv(t, e.type, n) : e.hasOwnProperty("defaultValue") && fv(t, e.type, Uo(e.defaultValue)), e.checked == null && e.defaultChecked != null && (t.defaultChecked = !!e.defaultChecked);
      }
      function gS(t, e, n) {
        if (e.hasOwnProperty("value") || e.hasOwnProperty("defaultValue")) {
          var r = e.type;
          if (!(r !== "submit" && r !== "reset" || e.value !== void 0 && e.value !== null))
            return;
          e = "" + t._wrapperState.initialValue, n || e === t.value || (t.value = e), t.defaultValue = e;
        }
        n = t.name, n !== "" && (t.name = ""), t.defaultChecked = !!t._wrapperState.initialChecked, n !== "" && (t.name = n);
      }
      function fv(t, e, n) {
        (e !== "number" || Od(t.ownerDocument) !== t) && (n == null ? t.defaultValue = "" + t._wrapperState.initialValue : t.defaultValue !== "" + n && (t.defaultValue = "" + n));
      }
      var uc = Array.isArray;
      function _a(t, e, n, r) {
        if (t = t.options, e) {
          e = {};
          for (var i = 0; i < n.length; i++)
            e["$" + n[i]] = true;
          for (n = 0; n < t.length; n++)
            i = e.hasOwnProperty("$" + t[n].value), t[n].selected !== i && (t[n].selected = i), i && r && (t[n].defaultSelected = true);
        } else {
          for (n = "" + Uo(n), e = null, i = 0; i < t.length; i++) {
            if (t[i].value === n) {
              t[i].selected = true, r && (t[i].defaultSelected = true);
              return;
            }
            e !== null || t[i].disabled || (e = t[i]);
          }
          e !== null && (e.selected = true);
        }
      }
      function hv(t, e) {
        if (e.dangerouslySetInnerHTML != null)
          throw Error(ee(91));
        return vt({}, e, {
          value: void 0,
          defaultValue: void 0,
          children: "" + t._wrapperState.initialValue
        });
      }
      function vS(t, e) {
        var n = e.value;
        if (n == null) {
          if (n = e.children, e = e.defaultValue, n != null) {
            if (e != null)
              throw Error(ee(92));
            if (uc(n)) {
              if (1 < n.length)
                throw Error(ee(93));
              n = n[0];
            }
            e = n;
          }
          e == null && (e = ""), n = e;
        }
        t._wrapperState = {
          initialValue: Uo(n)
        };
      }
      function CM(t, e) {
        var n = Uo(e.value), r = Uo(e.defaultValue);
        n != null && (n = "" + n, n !== t.value && (t.value = n), e.defaultValue == null && t.defaultValue !== n && (t.defaultValue = n)), r != null && (t.defaultValue = "" + r);
      }
      function yS(t) {
        var e = t.textContent;
        e === t._wrapperState.initialValue && e !== "" && e !== null && (t.value = e);
      }
      function TM(t) {
        switch (t) {
          case "svg":
            return "http://www.w3.org/2000/svg";
          case "math":
            return "http://www.w3.org/1998/Math/MathML";
          default:
            return "http://www.w3.org/1999/xhtml";
        }
      }
      function dv(t, e) {
        return t == null || t === "http://www.w3.org/1999/xhtml" ? TM(e) : t === "http://www.w3.org/2000/svg" && e === "foreignObject" ? "http://www.w3.org/1999/xhtml" : t;
      }
      var Hf, MM = function(t) {
        return typeof MSApp < "u" && MSApp.execUnsafeLocalFunction ? function(e, n, r, i) {
          MSApp.execUnsafeLocalFunction(function() {
            return t(e, n, r, i);
          });
        } : t;
      }(function(t, e) {
        if (t.namespaceURI !== "http://www.w3.org/2000/svg" || "innerHTML" in t)
          t.innerHTML = e;
        else {
          for (Hf = Hf || document.createElement("div"), Hf.innerHTML = "<svg>" + e.valueOf().toString() + "</svg>", e = Hf.firstChild; t.firstChild; )
            t.removeChild(t.firstChild);
          for (; e.firstChild; )
            t.appendChild(e.firstChild);
        }
      });
      function nu(t, e) {
        if (e) {
          var n = t.firstChild;
          if (n && n === t.lastChild && n.nodeType === 3) {
            n.nodeValue = e;
            return;
          }
        }
        t.textContent = e;
      }
      var Tc = {
        animationIterationCount: true,
        aspectRatio: true,
        borderImageOutset: true,
        borderImageSlice: true,
        borderImageWidth: true,
        boxFlex: true,
        boxFlexGroup: true,
        boxOrdinalGroup: true,
        columnCount: true,
        columns: true,
        flex: true,
        flexGrow: true,
        flexPositive: true,
        flexShrink: true,
        flexNegative: true,
        flexOrder: true,
        gridArea: true,
        gridRow: true,
        gridRowEnd: true,
        gridRowSpan: true,
        gridRowStart: true,
        gridColumn: true,
        gridColumnEnd: true,
        gridColumnSpan: true,
        gridColumnStart: true,
        fontWeight: true,
        lineClamp: true,
        lineHeight: true,
        opacity: true,
        order: true,
        orphans: true,
        tabSize: true,
        widows: true,
        zIndex: true,
        zoom: true,
        fillOpacity: true,
        floodOpacity: true,
        stopOpacity: true,
        strokeDasharray: true,
        strokeDashoffset: true,
        strokeMiterlimit: true,
        strokeOpacity: true,
        strokeWidth: true
      }, DD = [
        "Webkit",
        "ms",
        "Moz",
        "O"
      ];
      Object.keys(Tc).forEach(function(t) {
        DD.forEach(function(e) {
          e = e + t.charAt(0).toUpperCase() + t.substring(1), Tc[e] = Tc[t];
        });
      });
      function AM(t, e, n) {
        return e == null || typeof e == "boolean" || e === "" ? "" : n || typeof e != "number" || e === 0 || Tc.hasOwnProperty(t) && Tc[t] ? ("" + e).trim() : e + "px";
      }
      function EM(t, e) {
        t = t.style;
        for (var n in e)
          if (e.hasOwnProperty(n)) {
            var r = n.indexOf("--") === 0, i = AM(n, e[n], r);
            n === "float" && (n = "cssFloat"), r ? t.setProperty(n, i) : t[n] = i;
          }
      }
      var _D = vt({
        menuitem: true
      }, {
        area: true,
        base: true,
        br: true,
        col: true,
        embed: true,
        hr: true,
        img: true,
        input: true,
        keygen: true,
        link: true,
        meta: true,
        param: true,
        source: true,
        track: true,
        wbr: true
      });
      function pv(t, e) {
        if (e) {
          if (_D[t] && (e.children != null || e.dangerouslySetInnerHTML != null))
            throw Error(ee(137, t));
          if (e.dangerouslySetInnerHTML != null) {
            if (e.children != null)
              throw Error(ee(60));
            if (typeof e.dangerouslySetInnerHTML != "object" || !("__html" in e.dangerouslySetInnerHTML))
              throw Error(ee(61));
          }
          if (e.style != null && typeof e.style != "object")
            throw Error(ee(62));
        }
      }
      function mv(t, e) {
        if (t.indexOf("-") === -1)
          return typeof e.is == "string";
        switch (t) {
          case "annotation-xml":
          case "color-profile":
          case "font-face":
          case "font-face-src":
          case "font-face-uri":
          case "font-face-format":
          case "font-face-name":
          case "missing-glyph":
            return false;
          default:
            return true;
        }
      }
      var gv = null;
      function F1(t) {
        return t = t.target || t.srcElement || window, t.correspondingUseElement && (t = t.correspondingUseElement), t.nodeType === 3 ? t.parentNode : t;
      }
      var vv = null, Ia = null, Ba = null;
      function bS(t) {
        if (t = qu(t)) {
          if (typeof vv != "function")
            throw Error(ee(280));
          var e = t.stateNode;
          e && (e = Xp(e), vv(t.stateNode, t.type, e));
        }
      }
      function PM(t) {
        Ia ? Ba ? Ba.push(t) : Ba = [
          t
        ] : Ia = t;
      }
      function OM() {
        if (Ia) {
          var t = Ia, e = Ba;
          if (Ba = Ia = null, bS(t), e)
            for (t = 0; t < e.length; t++)
              bS(e[t]);
        }
      }
      function RM(t, e) {
        return t(e);
      }
      function LM() {
      }
      var Og = false;
      function DM(t, e, n) {
        if (Og)
          return t(e, n);
        Og = true;
        try {
          return RM(t, e, n);
        } finally {
          Og = false, (Ia !== null || Ba !== null) && (LM(), OM());
        }
      }
      function ru(t, e) {
        var n = t.stateNode;
        if (n === null)
          return null;
        var r = Xp(n);
        if (r === null)
          return null;
        n = r[e];
        e:
          switch (e) {
            case "onClick":
            case "onClickCapture":
            case "onDoubleClick":
            case "onDoubleClickCapture":
            case "onMouseDown":
            case "onMouseDownCapture":
            case "onMouseMove":
            case "onMouseMoveCapture":
            case "onMouseUp":
            case "onMouseUpCapture":
            case "onMouseEnter":
              (r = !r.disabled) || (t = t.type, r = !(t === "button" || t === "input" || t === "select" || t === "textarea")), t = !r;
              break e;
            default:
              t = false;
          }
        if (t)
          return null;
        if (n && typeof n != "function")
          throw Error(ee(231, e, typeof n));
        return n;
      }
      var yv = false;
      if (Gi)
        try {
          var Wl = {};
          Object.defineProperty(Wl, "passive", {
            get: function() {
              yv = true;
            }
          }), window.addEventListener("test", Wl, Wl), window.removeEventListener("test", Wl, Wl);
        } catch {
          yv = false;
        }
      function ID(t, e, n, r, i, o, s, a, l) {
        var c = Array.prototype.slice.call(arguments, 3);
        try {
          e.apply(n, c);
        } catch (u) {
          this.onError(u);
        }
      }
      var Mc = false, Rd = null, Ld = false, bv = null, BD = {
        onError: function(t) {
          Mc = true, Rd = t;
        }
      };
      function ND(t, e, n, r, i, o, s, a, l) {
        Mc = false, Rd = null, ID.apply(BD, arguments);
      }
      function $D(t, e, n, r, i, o, s, a, l) {
        if (ND.apply(this, arguments), Mc) {
          if (Mc) {
            var c = Rd;
            Mc = false, Rd = null;
          } else
            throw Error(ee(198));
          Ld || (Ld = true, bv = c);
        }
      }
      function Ys(t) {
        var e = t, n = t;
        if (t.alternate)
          for (; e.return; )
            e = e.return;
        else {
          t = e;
          do
            e = t, (e.flags & 4098) !== 0 && (n = e.return), t = e.return;
          while (t);
        }
        return e.tag === 3 ? n : null;
      }
      function _M(t) {
        if (t.tag === 13) {
          var e = t.memoizedState;
          if (e === null && (t = t.alternate, t !== null && (e = t.memoizedState)), e !== null)
            return e.dehydrated;
        }
        return null;
      }
      function xS(t) {
        if (Ys(t) !== t)
          throw Error(ee(188));
      }
      function zD(t) {
        var e = t.alternate;
        if (!e) {
          if (e = Ys(t), e === null)
            throw Error(ee(188));
          return e !== t ? null : t;
        }
        for (var n = t, r = e; ; ) {
          var i = n.return;
          if (i === null)
            break;
          var o = i.alternate;
          if (o === null) {
            if (r = i.return, r !== null) {
              n = r;
              continue;
            }
            break;
          }
          if (i.child === o.child) {
            for (o = i.child; o; ) {
              if (o === n)
                return xS(i), t;
              if (o === r)
                return xS(i), e;
              o = o.sibling;
            }
            throw Error(ee(188));
          }
          if (n.return !== r.return)
            n = i, r = o;
          else {
            for (var s = false, a = i.child; a; ) {
              if (a === n) {
                s = true, n = i, r = o;
                break;
              }
              if (a === r) {
                s = true, r = i, n = o;
                break;
              }
              a = a.sibling;
            }
            if (!s) {
              for (a = o.child; a; ) {
                if (a === n) {
                  s = true, n = o, r = i;
                  break;
                }
                if (a === r) {
                  s = true, r = o, n = i;
                  break;
                }
                a = a.sibling;
              }
              if (!s)
                throw Error(ee(189));
            }
          }
          if (n.alternate !== r)
            throw Error(ee(190));
        }
        if (n.tag !== 3)
          throw Error(ee(188));
        return n.stateNode.current === n ? t : e;
      }
      function IM(t) {
        return t = zD(t), t !== null ? BM(t) : null;
      }
      function BM(t) {
        if (t.tag === 5 || t.tag === 6)
          return t;
        for (t = t.child; t !== null; ) {
          var e = BM(t);
          if (e !== null)
            return e;
          t = t.sibling;
        }
        return null;
      }
      var NM = Jn.unstable_scheduleCallback, SS = Jn.unstable_cancelCallback, FD = Jn.unstable_shouldYield, VD = Jn.unstable_requestPaint, Mt = Jn.unstable_now, HD = Jn.unstable_getCurrentPriorityLevel, V1 = Jn.unstable_ImmediatePriority, $M = Jn.unstable_UserBlockingPriority, Dd = Jn.unstable_NormalPriority, jD = Jn.unstable_LowPriority, zM = Jn.unstable_IdlePriority, Kp = null, yi = null;
      function WD(t) {
        if (yi && typeof yi.onCommitFiberRoot == "function")
          try {
            yi.onCommitFiberRoot(Kp, t, void 0, (t.current.flags & 128) === 128);
          } catch {
          }
      }
      var zr = Math.clz32 ? Math.clz32 : qD, UD = Math.log, KD = Math.LN2;
      function qD(t) {
        return t >>>= 0, t === 0 ? 32 : 31 - (UD(t) / KD | 0) | 0;
      }
      var jf = 64, Wf = 4194304;
      function fc(t) {
        switch (t & -t) {
          case 1:
            return 1;
          case 2:
            return 2;
          case 4:
            return 4;
          case 8:
            return 8;
          case 16:
            return 16;
          case 32:
            return 32;
          case 64:
          case 128:
          case 256:
          case 512:
          case 1024:
          case 2048:
          case 4096:
          case 8192:
          case 16384:
          case 32768:
          case 65536:
          case 131072:
          case 262144:
          case 524288:
          case 1048576:
          case 2097152:
            return t & 4194240;
          case 4194304:
          case 8388608:
          case 16777216:
          case 33554432:
          case 67108864:
            return t & 130023424;
          case 134217728:
            return 134217728;
          case 268435456:
            return 268435456;
          case 536870912:
            return 536870912;
          case 1073741824:
            return 1073741824;
          default:
            return t;
        }
      }
      function _d(t, e) {
        var n = t.pendingLanes;
        if (n === 0)
          return 0;
        var r = 0, i = t.suspendedLanes, o = t.pingedLanes, s = n & 268435455;
        if (s !== 0) {
          var a = s & ~i;
          a !== 0 ? r = fc(a) : (o &= s, o !== 0 && (r = fc(o)));
        } else
          s = n & ~i, s !== 0 ? r = fc(s) : o !== 0 && (r = fc(o));
        if (r === 0)
          return 0;
        if (e !== 0 && e !== r && (e & i) === 0 && (i = r & -r, o = e & -e, i >= o || i === 16 && (o & 4194240) !== 0))
          return e;
        if ((r & 4) !== 0 && (r |= n & 16), e = t.entangledLanes, e !== 0)
          for (t = t.entanglements, e &= r; 0 < e; )
            n = 31 - zr(e), i = 1 << n, r |= t[n], e &= ~i;
        return r;
      }
      function GD(t, e) {
        switch (t) {
          case 1:
          case 2:
          case 4:
            return e + 250;
          case 8:
          case 16:
          case 32:
          case 64:
          case 128:
          case 256:
          case 512:
          case 1024:
          case 2048:
          case 4096:
          case 8192:
          case 16384:
          case 32768:
          case 65536:
          case 131072:
          case 262144:
          case 524288:
          case 1048576:
          case 2097152:
            return e + 5e3;
          case 4194304:
          case 8388608:
          case 16777216:
          case 33554432:
          case 67108864:
            return -1;
          case 134217728:
          case 268435456:
          case 536870912:
          case 1073741824:
            return -1;
          default:
            return -1;
        }
      }
      function YD(t, e) {
        for (var n = t.suspendedLanes, r = t.pingedLanes, i = t.expirationTimes, o = t.pendingLanes; 0 < o; ) {
          var s = 31 - zr(o), a = 1 << s, l = i[s];
          l === -1 ? ((a & n) === 0 || (a & r) !== 0) && (i[s] = GD(a, e)) : l <= e && (t.expiredLanes |= a), o &= ~a;
        }
      }
      function xv(t) {
        return t = t.pendingLanes & -1073741825, t !== 0 ? t : t & 1073741824 ? 1073741824 : 0;
      }
      function FM() {
        var t = jf;
        return jf <<= 1, (jf & 4194240) === 0 && (jf = 64), t;
      }
      function Rg(t) {
        for (var e = [], n = 0; 31 > n; n++)
          e.push(t);
        return e;
      }
      function Uu(t, e, n) {
        t.pendingLanes |= e, e !== 536870912 && (t.suspendedLanes = 0, t.pingedLanes = 0), t = t.eventTimes, e = 31 - zr(e), t[e] = n;
      }
      function XD(t, e) {
        var n = t.pendingLanes & ~e;
        t.pendingLanes = e, t.suspendedLanes = 0, t.pingedLanes = 0, t.expiredLanes &= e, t.mutableReadLanes &= e, t.entangledLanes &= e, e = t.entanglements;
        var r = t.eventTimes;
        for (t = t.expirationTimes; 0 < n; ) {
          var i = 31 - zr(n), o = 1 << i;
          e[i] = 0, r[i] = -1, t[i] = -1, n &= ~o;
        }
      }
      function H1(t, e) {
        var n = t.entangledLanes |= e;
        for (t = t.entanglements; n; ) {
          var r = 31 - zr(n), i = 1 << r;
          i & e | t[r] & e && (t[r] |= e), n &= ~i;
        }
      }
      var Ye = 0;
      function VM(t) {
        return t &= -t, 1 < t ? 4 < t ? (t & 268435455) !== 0 ? 16 : 536870912 : 4 : 1;
      }
      var HM, j1, jM, WM, UM, Sv = false, Uf = [], Bo = null, No = null, $o = null, iu = /* @__PURE__ */ new Map(), ou = /* @__PURE__ */ new Map(), ko = [], QD = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");
      function wS(t, e) {
        switch (t) {
          case "focusin":
          case "focusout":
            Bo = null;
            break;
          case "dragenter":
          case "dragleave":
            No = null;
            break;
          case "mouseover":
          case "mouseout":
            $o = null;
            break;
          case "pointerover":
          case "pointerout":
            iu.delete(e.pointerId);
            break;
          case "gotpointercapture":
          case "lostpointercapture":
            ou.delete(e.pointerId);
        }
      }
      function Ul(t, e, n, r, i, o) {
        return t === null || t.nativeEvent !== o ? (t = {
          blockedOn: e,
          domEventName: n,
          eventSystemFlags: r,
          nativeEvent: o,
          targetContainers: [
            i
          ]
        }, e !== null && (e = qu(e), e !== null && j1(e)), t) : (t.eventSystemFlags |= r, e = t.targetContainers, i !== null && e.indexOf(i) === -1 && e.push(i), t);
      }
      function JD(t, e, n, r, i) {
        switch (e) {
          case "focusin":
            return Bo = Ul(Bo, t, e, n, r, i), true;
          case "dragenter":
            return No = Ul(No, t, e, n, r, i), true;
          case "mouseover":
            return $o = Ul($o, t, e, n, r, i), true;
          case "pointerover":
            var o = i.pointerId;
            return iu.set(o, Ul(iu.get(o) || null, t, e, n, r, i)), true;
          case "gotpointercapture":
            return o = i.pointerId, ou.set(o, Ul(ou.get(o) || null, t, e, n, r, i)), true;
        }
        return false;
      }
      function KM(t) {
        var e = ws(t.target);
        if (e !== null) {
          var n = Ys(e);
          if (n !== null) {
            if (e = n.tag, e === 13) {
              if (e = _M(n), e !== null) {
                t.blockedOn = e, UM(t.priority, function() {
                  jM(n);
                });
                return;
              }
            } else if (e === 3 && n.stateNode.current.memoizedState.isDehydrated) {
              t.blockedOn = n.tag === 3 ? n.stateNode.containerInfo : null;
              return;
            }
          }
        }
        t.blockedOn = null;
      }
      function Wh(t) {
        if (t.blockedOn !== null)
          return false;
        for (var e = t.targetContainers; 0 < e.length; ) {
          var n = wv(t.domEventName, t.eventSystemFlags, e[0], t.nativeEvent);
          if (n === null) {
            n = t.nativeEvent;
            var r = new n.constructor(n.type, n);
            gv = r, n.target.dispatchEvent(r), gv = null;
          } else
            return e = qu(n), e !== null && j1(e), t.blockedOn = n, false;
          e.shift();
        }
        return true;
      }
      function kS(t, e, n) {
        Wh(t) && n.delete(e);
      }
      function ZD() {
        Sv = false, Bo !== null && Wh(Bo) && (Bo = null), No !== null && Wh(No) && (No = null), $o !== null && Wh($o) && ($o = null), iu.forEach(kS), ou.forEach(kS);
      }
      function Kl(t, e) {
        t.blockedOn === e && (t.blockedOn = null, Sv || (Sv = true, Jn.unstable_scheduleCallback(Jn.unstable_NormalPriority, ZD)));
      }
      function su(t) {
        function e(i) {
          return Kl(i, t);
        }
        if (0 < Uf.length) {
          Kl(Uf[0], t);
          for (var n = 1; n < Uf.length; n++) {
            var r = Uf[n];
            r.blockedOn === t && (r.blockedOn = null);
          }
        }
        for (Bo !== null && Kl(Bo, t), No !== null && Kl(No, t), $o !== null && Kl($o, t), iu.forEach(e), ou.forEach(e), n = 0; n < ko.length; n++)
          r = ko[n], r.blockedOn === t && (r.blockedOn = null);
        for (; 0 < ko.length && (n = ko[0], n.blockedOn === null); )
          KM(n), n.blockedOn === null && ko.shift();
      }
      var Na = io.ReactCurrentBatchConfig, Id = true;
      function e_(t, e, n, r) {
        var i = Ye, o = Na.transition;
        Na.transition = null;
        try {
          Ye = 1, W1(t, e, n, r);
        } finally {
          Ye = i, Na.transition = o;
        }
      }
      function t_(t, e, n, r) {
        var i = Ye, o = Na.transition;
        Na.transition = null;
        try {
          Ye = 4, W1(t, e, n, r);
        } finally {
          Ye = i, Na.transition = o;
        }
      }
      function W1(t, e, n, r) {
        if (Id) {
          var i = wv(t, e, n, r);
          if (i === null)
            Vg(t, e, r, Bd, n), wS(t, r);
          else if (JD(i, t, e, n, r))
            r.stopPropagation();
          else if (wS(t, r), e & 4 && -1 < QD.indexOf(t)) {
            for (; i !== null; ) {
              var o = qu(i);
              if (o !== null && HM(o), o = wv(t, e, n, r), o === null && Vg(t, e, r, Bd, n), o === i)
                break;
              i = o;
            }
            i !== null && r.stopPropagation();
          } else
            Vg(t, e, r, null, n);
        }
      }
      var Bd = null;
      function wv(t, e, n, r) {
        if (Bd = null, t = F1(r), t = ws(t), t !== null)
          if (e = Ys(t), e === null)
            t = null;
          else if (n = e.tag, n === 13) {
            if (t = _M(e), t !== null)
              return t;
            t = null;
          } else if (n === 3) {
            if (e.stateNode.current.memoizedState.isDehydrated)
              return e.tag === 3 ? e.stateNode.containerInfo : null;
            t = null;
          } else
            e !== t && (t = null);
        return Bd = t, null;
      }
      function qM(t) {
        switch (t) {
          case "cancel":
          case "click":
          case "close":
          case "contextmenu":
          case "copy":
          case "cut":
          case "auxclick":
          case "dblclick":
          case "dragend":
          case "dragstart":
          case "drop":
          case "focusin":
          case "focusout":
          case "input":
          case "invalid":
          case "keydown":
          case "keypress":
          case "keyup":
          case "mousedown":
          case "mouseup":
          case "paste":
          case "pause":
          case "play":
          case "pointercancel":
          case "pointerdown":
          case "pointerup":
          case "ratechange":
          case "reset":
          case "resize":
          case "seeked":
          case "submit":
          case "touchcancel":
          case "touchend":
          case "touchstart":
          case "volumechange":
          case "change":
          case "selectionchange":
          case "textInput":
          case "compositionstart":
          case "compositionend":
          case "compositionupdate":
          case "beforeblur":
          case "afterblur":
          case "beforeinput":
          case "blur":
          case "fullscreenchange":
          case "focus":
          case "hashchange":
          case "popstate":
          case "select":
          case "selectstart":
            return 1;
          case "drag":
          case "dragenter":
          case "dragexit":
          case "dragleave":
          case "dragover":
          case "mousemove":
          case "mouseout":
          case "mouseover":
          case "pointermove":
          case "pointerout":
          case "pointerover":
          case "scroll":
          case "toggle":
          case "touchmove":
          case "wheel":
          case "mouseenter":
          case "mouseleave":
          case "pointerenter":
          case "pointerleave":
            return 4;
          case "message":
            switch (HD()) {
              case V1:
                return 1;
              case $M:
                return 4;
              case Dd:
              case jD:
                return 16;
              case zM:
                return 536870912;
              default:
                return 16;
            }
          default:
            return 16;
        }
      }
      var Eo = null, U1 = null, Uh = null;
      function GM() {
        if (Uh)
          return Uh;
        var t, e = U1, n = e.length, r, i = "value" in Eo ? Eo.value : Eo.textContent, o = i.length;
        for (t = 0; t < n && e[t] === i[t]; t++)
          ;
        var s = n - t;
        for (r = 1; r <= s && e[n - r] === i[o - r]; r++)
          ;
        return Uh = i.slice(t, 1 < r ? 1 - r : void 0);
      }
      function Kh(t) {
        var e = t.keyCode;
        return "charCode" in t ? (t = t.charCode, t === 0 && e === 13 && (t = 13)) : t = e, t === 10 && (t = 13), 32 <= t || t === 13 ? t : 0;
      }
      function Kf() {
        return true;
      }
      function CS() {
        return false;
      }
      function er(t) {
        function e(n, r, i, o, s) {
          this._reactName = n, this._targetInst = i, this.type = r, this.nativeEvent = o, this.target = s, this.currentTarget = null;
          for (var a in t)
            t.hasOwnProperty(a) && (n = t[a], this[a] = n ? n(o) : o[a]);
          return this.isDefaultPrevented = (o.defaultPrevented != null ? o.defaultPrevented : o.returnValue === false) ? Kf : CS, this.isPropagationStopped = CS, this;
        }
        return vt(e.prototype, {
          preventDefault: function() {
            this.defaultPrevented = true;
            var n = this.nativeEvent;
            n && (n.preventDefault ? n.preventDefault() : typeof n.returnValue != "unknown" && (n.returnValue = false), this.isDefaultPrevented = Kf);
          },
          stopPropagation: function() {
            var n = this.nativeEvent;
            n && (n.stopPropagation ? n.stopPropagation() : typeof n.cancelBubble != "unknown" && (n.cancelBubble = true), this.isPropagationStopped = Kf);
          },
          persist: function() {
          },
          isPersistent: Kf
        }), e;
      }
      var wl = {
        eventPhase: 0,
        bubbles: 0,
        cancelable: 0,
        timeStamp: function(t) {
          return t.timeStamp || Date.now();
        },
        defaultPrevented: 0,
        isTrusted: 0
      }, K1 = er(wl), Ku = vt({}, wl, {
        view: 0,
        detail: 0
      }), n_ = er(Ku), Lg, Dg, ql, qp = vt({}, Ku, {
        screenX: 0,
        screenY: 0,
        clientX: 0,
        clientY: 0,
        pageX: 0,
        pageY: 0,
        ctrlKey: 0,
        shiftKey: 0,
        altKey: 0,
        metaKey: 0,
        getModifierState: q1,
        button: 0,
        buttons: 0,
        relatedTarget: function(t) {
          return t.relatedTarget === void 0 ? t.fromElement === t.srcElement ? t.toElement : t.fromElement : t.relatedTarget;
        },
        movementX: function(t) {
          return "movementX" in t ? t.movementX : (t !== ql && (ql && t.type === "mousemove" ? (Lg = t.screenX - ql.screenX, Dg = t.screenY - ql.screenY) : Dg = Lg = 0, ql = t), Lg);
        },
        movementY: function(t) {
          return "movementY" in t ? t.movementY : Dg;
        }
      }), TS = er(qp), r_ = vt({}, qp, {
        dataTransfer: 0
      }), i_ = er(r_), o_ = vt({}, Ku, {
        relatedTarget: 0
      }), _g = er(o_), s_ = vt({}, wl, {
        animationName: 0,
        elapsedTime: 0,
        pseudoElement: 0
      }), a_ = er(s_), l_ = vt({}, wl, {
        clipboardData: function(t) {
          return "clipboardData" in t ? t.clipboardData : window.clipboardData;
        }
      }), c_ = er(l_), u_ = vt({}, wl, {
        data: 0
      }), MS = er(u_), f_ = {
        Esc: "Escape",
        Spacebar: " ",
        Left: "ArrowLeft",
        Up: "ArrowUp",
        Right: "ArrowRight",
        Down: "ArrowDown",
        Del: "Delete",
        Win: "OS",
        Menu: "ContextMenu",
        Apps: "ContextMenu",
        Scroll: "ScrollLock",
        MozPrintableKey: "Unidentified"
      }, h_ = {
        8: "Backspace",
        9: "Tab",
        12: "Clear",
        13: "Enter",
        16: "Shift",
        17: "Control",
        18: "Alt",
        19: "Pause",
        20: "CapsLock",
        27: "Escape",
        32: " ",
        33: "PageUp",
        34: "PageDown",
        35: "End",
        36: "Home",
        37: "ArrowLeft",
        38: "ArrowUp",
        39: "ArrowRight",
        40: "ArrowDown",
        45: "Insert",
        46: "Delete",
        112: "F1",
        113: "F2",
        114: "F3",
        115: "F4",
        116: "F5",
        117: "F6",
        118: "F7",
        119: "F8",
        120: "F9",
        121: "F10",
        122: "F11",
        123: "F12",
        144: "NumLock",
        145: "ScrollLock",
        224: "Meta"
      }, d_ = {
        Alt: "altKey",
        Control: "ctrlKey",
        Meta: "metaKey",
        Shift: "shiftKey"
      };
      function p_(t) {
        var e = this.nativeEvent;
        return e.getModifierState ? e.getModifierState(t) : (t = d_[t]) ? !!e[t] : false;
      }
      function q1() {
        return p_;
      }
      var m_ = vt({}, Ku, {
        key: function(t) {
          if (t.key) {
            var e = f_[t.key] || t.key;
            if (e !== "Unidentified")
              return e;
          }
          return t.type === "keypress" ? (t = Kh(t), t === 13 ? "Enter" : String.fromCharCode(t)) : t.type === "keydown" || t.type === "keyup" ? h_[t.keyCode] || "Unidentified" : "";
        },
        code: 0,
        location: 0,
        ctrlKey: 0,
        shiftKey: 0,
        altKey: 0,
        metaKey: 0,
        repeat: 0,
        locale: 0,
        getModifierState: q1,
        charCode: function(t) {
          return t.type === "keypress" ? Kh(t) : 0;
        },
        keyCode: function(t) {
          return t.type === "keydown" || t.type === "keyup" ? t.keyCode : 0;
        },
        which: function(t) {
          return t.type === "keypress" ? Kh(t) : t.type === "keydown" || t.type === "keyup" ? t.keyCode : 0;
        }
      }), g_ = er(m_), v_ = vt({}, qp, {
        pointerId: 0,
        width: 0,
        height: 0,
        pressure: 0,
        tangentialPressure: 0,
        tiltX: 0,
        tiltY: 0,
        twist: 0,
        pointerType: 0,
        isPrimary: 0
      }), AS = er(v_), y_ = vt({}, Ku, {
        touches: 0,
        targetTouches: 0,
        changedTouches: 0,
        altKey: 0,
        metaKey: 0,
        ctrlKey: 0,
        shiftKey: 0,
        getModifierState: q1
      }), b_ = er(y_), x_ = vt({}, wl, {
        propertyName: 0,
        elapsedTime: 0,
        pseudoElement: 0
      }), S_ = er(x_), w_ = vt({}, qp, {
        deltaX: function(t) {
          return "deltaX" in t ? t.deltaX : "wheelDeltaX" in t ? -t.wheelDeltaX : 0;
        },
        deltaY: function(t) {
          return "deltaY" in t ? t.deltaY : "wheelDeltaY" in t ? -t.wheelDeltaY : "wheelDelta" in t ? -t.wheelDelta : 0;
        },
        deltaZ: 0,
        deltaMode: 0
      }), k_ = er(w_), C_ = [
        9,
        13,
        27,
        32
      ], G1 = Gi && "CompositionEvent" in window, Ac = null;
      Gi && "documentMode" in document && (Ac = document.documentMode);
      var T_ = Gi && "TextEvent" in window && !Ac, YM = Gi && (!G1 || Ac && 8 < Ac && 11 >= Ac), ES = String.fromCharCode(32), PS = false;
      function XM(t, e) {
        switch (t) {
          case "keyup":
            return C_.indexOf(e.keyCode) !== -1;
          case "keydown":
            return e.keyCode !== 229;
          case "keypress":
          case "mousedown":
          case "focusout":
            return true;
          default:
            return false;
        }
      }
      function QM(t) {
        return t = t.detail, typeof t == "object" && "data" in t ? t.data : null;
      }
      var pa = false;
      function M_(t, e) {
        switch (t) {
          case "compositionend":
            return QM(e);
          case "keypress":
            return e.which !== 32 ? null : (PS = true, ES);
          case "textInput":
            return t = e.data, t === ES && PS ? null : t;
          default:
            return null;
        }
      }
      function A_(t, e) {
        if (pa)
          return t === "compositionend" || !G1 && XM(t, e) ? (t = GM(), Uh = U1 = Eo = null, pa = false, t) : null;
        switch (t) {
          case "paste":
            return null;
          case "keypress":
            if (!(e.ctrlKey || e.altKey || e.metaKey) || e.ctrlKey && e.altKey) {
              if (e.char && 1 < e.char.length)
                return e.char;
              if (e.which)
                return String.fromCharCode(e.which);
            }
            return null;
          case "compositionend":
            return YM && e.locale !== "ko" ? null : e.data;
          default:
            return null;
        }
      }
      var E_ = {
        color: true,
        date: true,
        datetime: true,
        "datetime-local": true,
        email: true,
        month: true,
        number: true,
        password: true,
        range: true,
        search: true,
        tel: true,
        text: true,
        time: true,
        url: true,
        week: true
      };
      function OS(t) {
        var e = t && t.nodeName && t.nodeName.toLowerCase();
        return e === "input" ? !!E_[t.type] : e === "textarea";
      }
      function JM(t, e, n, r) {
        PM(r), e = Nd(e, "onChange"), 0 < e.length && (n = new K1("onChange", "change", null, n, r), t.push({
          event: n,
          listeners: e
        }));
      }
      var Ec = null, au = null;
      function P_(t) {
        c2(t, 0);
      }
      function Gp(t) {
        var e = va(t);
        if (wM(e))
          return t;
      }
      function O_(t, e) {
        if (t === "change")
          return e;
      }
      var ZM = false;
      if (Gi) {
        var Ig;
        if (Gi) {
          var Bg = "oninput" in document;
          if (!Bg) {
            var RS = document.createElement("div");
            RS.setAttribute("oninput", "return;"), Bg = typeof RS.oninput == "function";
          }
          Ig = Bg;
        } else
          Ig = false;
        ZM = Ig && (!document.documentMode || 9 < document.documentMode);
      }
      function LS() {
        Ec && (Ec.detachEvent("onpropertychange", e2), au = Ec = null);
      }
      function e2(t) {
        if (t.propertyName === "value" && Gp(au)) {
          var e = [];
          JM(e, au, t, F1(t)), DM(P_, e);
        }
      }
      function R_(t, e, n) {
        t === "focusin" ? (LS(), Ec = e, au = n, Ec.attachEvent("onpropertychange", e2)) : t === "focusout" && LS();
      }
      function L_(t) {
        if (t === "selectionchange" || t === "keyup" || t === "keydown")
          return Gp(au);
      }
      function D_(t, e) {
        if (t === "click")
          return Gp(e);
      }
      function __(t, e) {
        if (t === "input" || t === "change")
          return Gp(e);
      }
      function I_(t, e) {
        return t === e && (t !== 0 || 1 / t === 1 / e) || t !== t && e !== e;
      }
      var Wr = typeof Object.is == "function" ? Object.is : I_;
      function lu(t, e) {
        if (Wr(t, e))
          return true;
        if (typeof t != "object" || t === null || typeof e != "object" || e === null)
          return false;
        var n = Object.keys(t), r = Object.keys(e);
        if (n.length !== r.length)
          return false;
        for (r = 0; r < n.length; r++) {
          var i = n[r];
          if (!iv.call(e, i) || !Wr(t[i], e[i]))
            return false;
        }
        return true;
      }
      function DS(t) {
        for (; t && t.firstChild; )
          t = t.firstChild;
        return t;
      }
      function _S(t, e) {
        var n = DS(t);
        t = 0;
        for (var r; n; ) {
          if (n.nodeType === 3) {
            if (r = t + n.textContent.length, t <= e && r >= e)
              return {
                node: n,
                offset: e - t
              };
            t = r;
          }
          e: {
            for (; n; ) {
              if (n.nextSibling) {
                n = n.nextSibling;
                break e;
              }
              n = n.parentNode;
            }
            n = void 0;
          }
          n = DS(n);
        }
      }
      function t2(t, e) {
        return t && e ? t === e ? true : t && t.nodeType === 3 ? false : e && e.nodeType === 3 ? t2(t, e.parentNode) : "contains" in t ? t.contains(e) : t.compareDocumentPosition ? !!(t.compareDocumentPosition(e) & 16) : false : false;
      }
      function n2() {
        for (var t = window, e = Od(); e instanceof t.HTMLIFrameElement; ) {
          try {
            var n = typeof e.contentWindow.location.href == "string";
          } catch {
            n = false;
          }
          if (n)
            t = e.contentWindow;
          else
            break;
          e = Od(t.document);
        }
        return e;
      }
      function Y1(t) {
        var e = t && t.nodeName && t.nodeName.toLowerCase();
        return e && (e === "input" && (t.type === "text" || t.type === "search" || t.type === "tel" || t.type === "url" || t.type === "password") || e === "textarea" || t.contentEditable === "true");
      }
      function B_(t) {
        var e = n2(), n = t.focusedElem, r = t.selectionRange;
        if (e !== n && n && n.ownerDocument && t2(n.ownerDocument.documentElement, n)) {
          if (r !== null && Y1(n)) {
            if (e = r.start, t = r.end, t === void 0 && (t = e), "selectionStart" in n)
              n.selectionStart = e, n.selectionEnd = Math.min(t, n.value.length);
            else if (t = (e = n.ownerDocument || document) && e.defaultView || window, t.getSelection) {
              t = t.getSelection();
              var i = n.textContent.length, o = Math.min(r.start, i);
              r = r.end === void 0 ? o : Math.min(r.end, i), !t.extend && o > r && (i = r, r = o, o = i), i = _S(n, o);
              var s = _S(n, r);
              i && s && (t.rangeCount !== 1 || t.anchorNode !== i.node || t.anchorOffset !== i.offset || t.focusNode !== s.node || t.focusOffset !== s.offset) && (e = e.createRange(), e.setStart(i.node, i.offset), t.removeAllRanges(), o > r ? (t.addRange(e), t.extend(s.node, s.offset)) : (e.setEnd(s.node, s.offset), t.addRange(e)));
            }
          }
          for (e = [], t = n; t = t.parentNode; )
            t.nodeType === 1 && e.push({
              element: t,
              left: t.scrollLeft,
              top: t.scrollTop
            });
          for (typeof n.focus == "function" && n.focus(), n = 0; n < e.length; n++)
            t = e[n], t.element.scrollLeft = t.left, t.element.scrollTop = t.top;
        }
      }
      var N_ = Gi && "documentMode" in document && 11 >= document.documentMode, ma = null, kv = null, Pc = null, Cv = false;
      function IS(t, e, n) {
        var r = n.window === n ? n.document : n.nodeType === 9 ? n : n.ownerDocument;
        Cv || ma == null || ma !== Od(r) || (r = ma, "selectionStart" in r && Y1(r) ? r = {
          start: r.selectionStart,
          end: r.selectionEnd
        } : (r = (r.ownerDocument && r.ownerDocument.defaultView || window).getSelection(), r = {
          anchorNode: r.anchorNode,
          anchorOffset: r.anchorOffset,
          focusNode: r.focusNode,
          focusOffset: r.focusOffset
        }), Pc && lu(Pc, r) || (Pc = r, r = Nd(kv, "onSelect"), 0 < r.length && (e = new K1("onSelect", "select", null, e, n), t.push({
          event: e,
          listeners: r
        }), e.target = ma)));
      }
      function qf(t, e) {
        var n = {};
        return n[t.toLowerCase()] = e.toLowerCase(), n["Webkit" + t] = "webkit" + e, n["Moz" + t] = "moz" + e, n;
      }
      var ga = {
        animationend: qf("Animation", "AnimationEnd"),
        animationiteration: qf("Animation", "AnimationIteration"),
        animationstart: qf("Animation", "AnimationStart"),
        transitionend: qf("Transition", "TransitionEnd")
      }, Ng = {}, r2 = {};
      Gi && (r2 = document.createElement("div").style, "AnimationEvent" in window || (delete ga.animationend.animation, delete ga.animationiteration.animation, delete ga.animationstart.animation), "TransitionEvent" in window || delete ga.transitionend.transition);
      function Yp(t) {
        if (Ng[t])
          return Ng[t];
        if (!ga[t])
          return t;
        var e = ga[t], n;
        for (n in e)
          if (e.hasOwnProperty(n) && n in r2)
            return Ng[t] = e[n];
        return t;
      }
      var i2 = Yp("animationend"), o2 = Yp("animationiteration"), s2 = Yp("animationstart"), a2 = Yp("transitionend"), l2 = /* @__PURE__ */ new Map(), BS = "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");
      function Zo(t, e) {
        l2.set(t, e), Gs(e, [
          t
        ]);
      }
      for (var $g = 0; $g < BS.length; $g++) {
        var zg = BS[$g], $_ = zg.toLowerCase(), z_ = zg[0].toUpperCase() + zg.slice(1);
        Zo($_, "on" + z_);
      }
      Zo(i2, "onAnimationEnd");
      Zo(o2, "onAnimationIteration");
      Zo(s2, "onAnimationStart");
      Zo("dblclick", "onDoubleClick");
      Zo("focusin", "onFocus");
      Zo("focusout", "onBlur");
      Zo(a2, "onTransitionEnd");
      Ja("onMouseEnter", [
        "mouseout",
        "mouseover"
      ]);
      Ja("onMouseLeave", [
        "mouseout",
        "mouseover"
      ]);
      Ja("onPointerEnter", [
        "pointerout",
        "pointerover"
      ]);
      Ja("onPointerLeave", [
        "pointerout",
        "pointerover"
      ]);
      Gs("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" "));
      Gs("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" "));
      Gs("onBeforeInput", [
        "compositionend",
        "keypress",
        "textInput",
        "paste"
      ]);
      Gs("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" "));
      Gs("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" "));
      Gs("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" "));
      var hc = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "), F_ = new Set("cancel close invalid load scroll toggle".split(" ").concat(hc));
      function NS(t, e, n) {
        var r = t.type || "unknown-event";
        t.currentTarget = n, $D(r, e, void 0, t), t.currentTarget = null;
      }
      function c2(t, e) {
        e = (e & 4) !== 0;
        for (var n = 0; n < t.length; n++) {
          var r = t[n], i = r.event;
          r = r.listeners;
          e: {
            var o = void 0;
            if (e)
              for (var s = r.length - 1; 0 <= s; s--) {
                var a = r[s], l = a.instance, c = a.currentTarget;
                if (a = a.listener, l !== o && i.isPropagationStopped())
                  break e;
                NS(i, a, c), o = l;
              }
            else
              for (s = 0; s < r.length; s++) {
                if (a = r[s], l = a.instance, c = a.currentTarget, a = a.listener, l !== o && i.isPropagationStopped())
                  break e;
                NS(i, a, c), o = l;
              }
          }
        }
        if (Ld)
          throw t = bv, Ld = false, bv = null, t;
      }
      function ot(t, e) {
        var n = e[Pv];
        n === void 0 && (n = e[Pv] = /* @__PURE__ */ new Set());
        var r = t + "__bubble";
        n.has(r) || (u2(e, t, 2, false), n.add(r));
      }
      function Fg(t, e, n) {
        var r = 0;
        e && (r |= 4), u2(n, t, r, e);
      }
      var Gf = "_reactListening" + Math.random().toString(36).slice(2);
      function cu(t) {
        if (!t[Gf]) {
          t[Gf] = true, vM.forEach(function(n) {
            n !== "selectionchange" && (F_.has(n) || Fg(n, false, t), Fg(n, true, t));
          });
          var e = t.nodeType === 9 ? t : t.ownerDocument;
          e === null || e[Gf] || (e[Gf] = true, Fg("selectionchange", false, e));
        }
      }
      function u2(t, e, n, r) {
        switch (qM(e)) {
          case 1:
            var i = e_;
            break;
          case 4:
            i = t_;
            break;
          default:
            i = W1;
        }
        n = i.bind(null, e, n, t), i = void 0, !yv || e !== "touchstart" && e !== "touchmove" && e !== "wheel" || (i = true), r ? i !== void 0 ? t.addEventListener(e, n, {
          capture: true,
          passive: i
        }) : t.addEventListener(e, n, true) : i !== void 0 ? t.addEventListener(e, n, {
          passive: i
        }) : t.addEventListener(e, n, false);
      }
      function Vg(t, e, n, r, i) {
        var o = r;
        if ((e & 1) === 0 && (e & 2) === 0 && r !== null)
          e:
            for (; ; ) {
              if (r === null)
                return;
              var s = r.tag;
              if (s === 3 || s === 4) {
                var a = r.stateNode.containerInfo;
                if (a === i || a.nodeType === 8 && a.parentNode === i)
                  break;
                if (s === 4)
                  for (s = r.return; s !== null; ) {
                    var l = s.tag;
                    if ((l === 3 || l === 4) && (l = s.stateNode.containerInfo, l === i || l.nodeType === 8 && l.parentNode === i))
                      return;
                    s = s.return;
                  }
                for (; a !== null; ) {
                  if (s = ws(a), s === null)
                    return;
                  if (l = s.tag, l === 5 || l === 6) {
                    r = o = s;
                    continue e;
                  }
                  a = a.parentNode;
                }
              }
              r = r.return;
            }
        DM(function() {
          var c = o, u = F1(n), h = [];
          e: {
            var p = l2.get(t);
            if (p !== void 0) {
              var v = K1, y = t;
              switch (t) {
                case "keypress":
                  if (Kh(n) === 0)
                    break e;
                case "keydown":
                case "keyup":
                  v = g_;
                  break;
                case "focusin":
                  y = "focus", v = _g;
                  break;
                case "focusout":
                  y = "blur", v = _g;
                  break;
                case "beforeblur":
                case "afterblur":
                  v = _g;
                  break;
                case "click":
                  if (n.button === 2)
                    break e;
                case "auxclick":
                case "dblclick":
                case "mousedown":
                case "mousemove":
                case "mouseup":
                case "mouseout":
                case "mouseover":
                case "contextmenu":
                  v = TS;
                  break;
                case "drag":
                case "dragend":
                case "dragenter":
                case "dragexit":
                case "dragleave":
                case "dragover":
                case "dragstart":
                case "drop":
                  v = i_;
                  break;
                case "touchcancel":
                case "touchend":
                case "touchmove":
                case "touchstart":
                  v = b_;
                  break;
                case i2:
                case o2:
                case s2:
                  v = a_;
                  break;
                case a2:
                  v = S_;
                  break;
                case "scroll":
                  v = n_;
                  break;
                case "wheel":
                  v = k_;
                  break;
                case "copy":
                case "cut":
                case "paste":
                  v = c_;
                  break;
                case "gotpointercapture":
                case "lostpointercapture":
                case "pointercancel":
                case "pointerdown":
                case "pointermove":
                case "pointerout":
                case "pointerover":
                case "pointerup":
                  v = AS;
              }
              var S = (e & 4) !== 0, C = !S && t === "scroll", w = S ? p !== null ? p + "Capture" : null : p;
              S = [];
              for (var k = c, T; k !== null; ) {
                T = k;
                var P = T.stateNode;
                if (T.tag === 5 && P !== null && (T = P, w !== null && (P = ru(k, w), P != null && S.push(uu(k, P, T)))), C)
                  break;
                k = k.return;
              }
              0 < S.length && (p = new v(p, y, null, n, u), h.push({
                event: p,
                listeners: S
              }));
            }
          }
          if ((e & 7) === 0) {
            e: {
              if (p = t === "mouseover" || t === "pointerover", v = t === "mouseout" || t === "pointerout", p && n !== gv && (y = n.relatedTarget || n.fromElement) && (ws(y) || y[Yi]))
                break e;
              if ((v || p) && (p = u.window === u ? u : (p = u.ownerDocument) ? p.defaultView || p.parentWindow : window, v ? (y = n.relatedTarget || n.toElement, v = c, y = y ? ws(y) : null, y !== null && (C = Ys(y), y !== C || y.tag !== 5 && y.tag !== 6) && (y = null)) : (v = null, y = c), v !== y)) {
                if (S = TS, P = "onMouseLeave", w = "onMouseEnter", k = "mouse", (t === "pointerout" || t === "pointerover") && (S = AS, P = "onPointerLeave", w = "onPointerEnter", k = "pointer"), C = v == null ? p : va(v), T = y == null ? p : va(y), p = new S(P, k + "leave", v, n, u), p.target = C, p.relatedTarget = T, P = null, ws(u) === c && (S = new S(w, k + "enter", y, n, u), S.target = T, S.relatedTarget = C, P = S), C = P, v && y)
                  t: {
                    for (S = v, w = y, k = 0, T = S; T; T = sa(T))
                      k++;
                    for (T = 0, P = w; P; P = sa(P))
                      T++;
                    for (; 0 < k - T; )
                      S = sa(S), k--;
                    for (; 0 < T - k; )
                      w = sa(w), T--;
                    for (; k--; ) {
                      if (S === w || w !== null && S === w.alternate)
                        break t;
                      S = sa(S), w = sa(w);
                    }
                    S = null;
                  }
                else
                  S = null;
                v !== null && $S(h, p, v, S, false), y !== null && C !== null && $S(h, C, y, S, true);
              }
            }
            e: {
              if (p = c ? va(c) : window, v = p.nodeName && p.nodeName.toLowerCase(), v === "select" || v === "input" && p.type === "file")
                var R = O_;
              else if (OS(p))
                if (ZM)
                  R = __;
                else {
                  R = L_;
                  var L = R_;
                }
              else
                (v = p.nodeName) && v.toLowerCase() === "input" && (p.type === "checkbox" || p.type === "radio") && (R = D_);
              if (R && (R = R(t, c))) {
                JM(h, R, n, u);
                break e;
              }
              L && L(t, p, c), t === "focusout" && (L = p._wrapperState) && L.controlled && p.type === "number" && fv(p, "number", p.value);
            }
            switch (L = c ? va(c) : window, t) {
              case "focusin":
                (OS(L) || L.contentEditable === "true") && (ma = L, kv = c, Pc = null);
                break;
              case "focusout":
                Pc = kv = ma = null;
                break;
              case "mousedown":
                Cv = true;
                break;
              case "contextmenu":
              case "mouseup":
              case "dragend":
                Cv = false, IS(h, n, u);
                break;
              case "selectionchange":
                if (N_)
                  break;
              case "keydown":
              case "keyup":
                IS(h, n, u);
            }
            var D;
            if (G1)
              e: {
                switch (t) {
                  case "compositionstart":
                    var F = "onCompositionStart";
                    break e;
                  case "compositionend":
                    F = "onCompositionEnd";
                    break e;
                  case "compositionupdate":
                    F = "onCompositionUpdate";
                    break e;
                }
                F = void 0;
              }
            else
              pa ? XM(t, n) && (F = "onCompositionEnd") : t === "keydown" && n.keyCode === 229 && (F = "onCompositionStart");
            F && (YM && n.locale !== "ko" && (pa || F !== "onCompositionStart" ? F === "onCompositionEnd" && pa && (D = GM()) : (Eo = u, U1 = "value" in Eo ? Eo.value : Eo.textContent, pa = true)), L = Nd(c, F), 0 < L.length && (F = new MS(F, t, null, n, u), h.push({
              event: F,
              listeners: L
            }), D ? F.data = D : (D = QM(n), D !== null && (F.data = D)))), (D = T_ ? M_(t, n) : A_(t, n)) && (c = Nd(c, "onBeforeInput"), 0 < c.length && (u = new MS("onBeforeInput", "beforeinput", null, n, u), h.push({
              event: u,
              listeners: c
            }), u.data = D));
          }
          c2(h, e);
        });
      }
      function uu(t, e, n) {
        return {
          instance: t,
          listener: e,
          currentTarget: n
        };
      }
      function Nd(t, e) {
        for (var n = e + "Capture", r = []; t !== null; ) {
          var i = t, o = i.stateNode;
          i.tag === 5 && o !== null && (i = o, o = ru(t, n), o != null && r.unshift(uu(t, o, i)), o = ru(t, e), o != null && r.push(uu(t, o, i))), t = t.return;
        }
        return r;
      }
      function sa(t) {
        if (t === null)
          return null;
        do
          t = t.return;
        while (t && t.tag !== 5);
        return t || null;
      }
      function $S(t, e, n, r, i) {
        for (var o = e._reactName, s = []; n !== null && n !== r; ) {
          var a = n, l = a.alternate, c = a.stateNode;
          if (l !== null && l === r)
            break;
          a.tag === 5 && c !== null && (a = c, i ? (l = ru(n, o), l != null && s.unshift(uu(n, l, a))) : i || (l = ru(n, o), l != null && s.push(uu(n, l, a)))), n = n.return;
        }
        s.length !== 0 && t.push({
          event: e,
          listeners: s
        });
      }
      var V_ = /\r\n?/g, H_ = /\u0000|\uFFFD/g;
      function zS(t) {
        return (typeof t == "string" ? t : "" + t).replace(V_, `
`).replace(H_, "");
      }
      function Yf(t, e, n) {
        if (e = zS(e), zS(t) !== e && n)
          throw Error(ee(425));
      }
      function $d() {
      }
      var Tv = null, Mv = null;
      function Av(t, e) {
        return t === "textarea" || t === "noscript" || typeof e.children == "string" || typeof e.children == "number" || typeof e.dangerouslySetInnerHTML == "object" && e.dangerouslySetInnerHTML !== null && e.dangerouslySetInnerHTML.__html != null;
      }
      var Ev = typeof setTimeout == "function" ? setTimeout : void 0, j_ = typeof clearTimeout == "function" ? clearTimeout : void 0, FS = typeof Promise == "function" ? Promise : void 0, W_ = typeof queueMicrotask == "function" ? queueMicrotask : typeof FS < "u" ? function(t) {
        return FS.resolve(null).then(t).catch(U_);
      } : Ev;
      function U_(t) {
        setTimeout(function() {
          throw t;
        });
      }
      function Hg(t, e) {
        var n = e, r = 0;
        do {
          var i = n.nextSibling;
          if (t.removeChild(n), i && i.nodeType === 8)
            if (n = i.data, n === "/$") {
              if (r === 0) {
                t.removeChild(i), su(e);
                return;
              }
              r--;
            } else
              n !== "$" && n !== "$?" && n !== "$!" || r++;
          n = i;
        } while (n);
        su(e);
      }
      function zo(t) {
        for (; t != null; t = t.nextSibling) {
          var e = t.nodeType;
          if (e === 1 || e === 3)
            break;
          if (e === 8) {
            if (e = t.data, e === "$" || e === "$!" || e === "$?")
              break;
            if (e === "/$")
              return null;
          }
        }
        return t;
      }
      function VS(t) {
        t = t.previousSibling;
        for (var e = 0; t; ) {
          if (t.nodeType === 8) {
            var n = t.data;
            if (n === "$" || n === "$!" || n === "$?") {
              if (e === 0)
                return t;
              e--;
            } else
              n === "/$" && e++;
          }
          t = t.previousSibling;
        }
        return null;
      }
      var kl = Math.random().toString(36).slice(2), fi = "__reactFiber$" + kl, fu = "__reactProps$" + kl, Yi = "__reactContainer$" + kl, Pv = "__reactEvents$" + kl, K_ = "__reactListeners$" + kl, q_ = "__reactHandles$" + kl;
      function ws(t) {
        var e = t[fi];
        if (e)
          return e;
        for (var n = t.parentNode; n; ) {
          if (e = n[Yi] || n[fi]) {
            if (n = e.alternate, e.child !== null || n !== null && n.child !== null)
              for (t = VS(t); t !== null; ) {
                if (n = t[fi])
                  return n;
                t = VS(t);
              }
            return e;
          }
          t = n, n = t.parentNode;
        }
        return null;
      }
      function qu(t) {
        return t = t[fi] || t[Yi], !t || t.tag !== 5 && t.tag !== 6 && t.tag !== 13 && t.tag !== 3 ? null : t;
      }
      function va(t) {
        if (t.tag === 5 || t.tag === 6)
          return t.stateNode;
        throw Error(ee(33));
      }
      function Xp(t) {
        return t[fu] || null;
      }
      var Ov = [], ya = -1;
      function es(t) {
        return {
          current: t
        };
      }
      function lt(t) {
        0 > ya || (t.current = Ov[ya], Ov[ya] = null, ya--);
      }
      function nt(t, e) {
        ya++, Ov[ya] = t.current, t.current = e;
      }
      var Ko = {}, pn = es(Ko), $n = es(false), Bs = Ko;
      function Za(t, e) {
        var n = t.type.contextTypes;
        if (!n)
          return Ko;
        var r = t.stateNode;
        if (r && r.__reactInternalMemoizedUnmaskedChildContext === e)
          return r.__reactInternalMemoizedMaskedChildContext;
        var i = {}, o;
        for (o in n)
          i[o] = e[o];
        return r && (t = t.stateNode, t.__reactInternalMemoizedUnmaskedChildContext = e, t.__reactInternalMemoizedMaskedChildContext = i), i;
      }
      function zn(t) {
        return t = t.childContextTypes, t != null;
      }
      function zd() {
        lt($n), lt(pn);
      }
      function HS(t, e, n) {
        if (pn.current !== Ko)
          throw Error(ee(168));
        nt(pn, e), nt($n, n);
      }
      function f2(t, e, n) {
        var r = t.stateNode;
        if (e = e.childContextTypes, typeof r.getChildContext != "function")
          return n;
        r = r.getChildContext();
        for (var i in r)
          if (!(i in e))
            throw Error(ee(108, RD(t) || "Unknown", i));
        return vt({}, n, r);
      }
      function Fd(t) {
        return t = (t = t.stateNode) && t.__reactInternalMemoizedMergedChildContext || Ko, Bs = pn.current, nt(pn, t), nt($n, $n.current), true;
      }
      function jS(t, e, n) {
        var r = t.stateNode;
        if (!r)
          throw Error(ee(169));
        n ? (t = f2(t, e, Bs), r.__reactInternalMemoizedMergedChildContext = t, lt($n), lt(pn), nt(pn, t)) : lt($n), nt($n, n);
      }
      var Bi = null, Qp = false, jg = false;
      function h2(t) {
        Bi === null ? Bi = [
          t
        ] : Bi.push(t);
      }
      function G_(t) {
        Qp = true, h2(t);
      }
      function ts() {
        if (!jg && Bi !== null) {
          jg = true;
          var t = 0, e = Ye;
          try {
            var n = Bi;
            for (Ye = 1; t < n.length; t++) {
              var r = n[t];
              do
                r = r(true);
              while (r !== null);
            }
            Bi = null, Qp = false;
          } catch (i) {
            throw Bi !== null && (Bi = Bi.slice(t + 1)), NM(V1, ts), i;
          } finally {
            Ye = e, jg = false;
          }
        }
        return null;
      }
      var ba = [], xa = 0, Vd = null, Hd = 0, fr = [], hr = 0, Ns = null, Hi = 1, ji = "";
      function gs(t, e) {
        ba[xa++] = Hd, ba[xa++] = Vd, Vd = t, Hd = e;
      }
      function d2(t, e, n) {
        fr[hr++] = Hi, fr[hr++] = ji, fr[hr++] = Ns, Ns = t;
        var r = Hi;
        t = ji;
        var i = 32 - zr(r) - 1;
        r &= ~(1 << i), n += 1;
        var o = 32 - zr(e) + i;
        if (30 < o) {
          var s = i - i % 5;
          o = (r & (1 << s) - 1).toString(32), r >>= s, i -= s, Hi = 1 << 32 - zr(e) + i | n << i | r, ji = o + t;
        } else
          Hi = 1 << o | n << i | r, ji = t;
      }
      function X1(t) {
        t.return !== null && (gs(t, 1), d2(t, 1, 0));
      }
      function Q1(t) {
        for (; t === Vd; )
          Vd = ba[--xa], ba[xa] = null, Hd = ba[--xa], ba[xa] = null;
        for (; t === Ns; )
          Ns = fr[--hr], fr[hr] = null, ji = fr[--hr], fr[hr] = null, Hi = fr[--hr], fr[hr] = null;
      }
      var Gn = null, Kn = null, ft = false, Br = null;
      function p2(t, e) {
        var n = pr(5, null, null, 0);
        n.elementType = "DELETED", n.stateNode = e, n.return = t, e = t.deletions, e === null ? (t.deletions = [
          n
        ], t.flags |= 16) : e.push(n);
      }
      function WS(t, e) {
        switch (t.tag) {
          case 5:
            var n = t.type;
            return e = e.nodeType !== 1 || n.toLowerCase() !== e.nodeName.toLowerCase() ? null : e, e !== null ? (t.stateNode = e, Gn = t, Kn = zo(e.firstChild), true) : false;
          case 6:
            return e = t.pendingProps === "" || e.nodeType !== 3 ? null : e, e !== null ? (t.stateNode = e, Gn = t, Kn = null, true) : false;
          case 13:
            return e = e.nodeType !== 8 ? null : e, e !== null ? (n = Ns !== null ? {
              id: Hi,
              overflow: ji
            } : null, t.memoizedState = {
              dehydrated: e,
              treeContext: n,
              retryLane: 1073741824
            }, n = pr(18, null, null, 0), n.stateNode = e, n.return = t, t.child = n, Gn = t, Kn = null, true) : false;
          default:
            return false;
        }
      }
      function Rv(t) {
        return (t.mode & 1) !== 0 && (t.flags & 128) === 0;
      }
      function Lv(t) {
        if (ft) {
          var e = Kn;
          if (e) {
            var n = e;
            if (!WS(t, e)) {
              if (Rv(t))
                throw Error(ee(418));
              e = zo(n.nextSibling);
              var r = Gn;
              e && WS(t, e) ? p2(r, n) : (t.flags = t.flags & -4097 | 2, ft = false, Gn = t);
            }
          } else {
            if (Rv(t))
              throw Error(ee(418));
            t.flags = t.flags & -4097 | 2, ft = false, Gn = t;
          }
        }
      }
      function US(t) {
        for (t = t.return; t !== null && t.tag !== 5 && t.tag !== 3 && t.tag !== 13; )
          t = t.return;
        Gn = t;
      }
      function Xf(t) {
        if (t !== Gn)
          return false;
        if (!ft)
          return US(t), ft = true, false;
        var e;
        if ((e = t.tag !== 3) && !(e = t.tag !== 5) && (e = t.type, e = e !== "head" && e !== "body" && !Av(t.type, t.memoizedProps)), e && (e = Kn)) {
          if (Rv(t))
            throw m2(), Error(ee(418));
          for (; e; )
            p2(t, e), e = zo(e.nextSibling);
        }
        if (US(t), t.tag === 13) {
          if (t = t.memoizedState, t = t !== null ? t.dehydrated : null, !t)
            throw Error(ee(317));
          e: {
            for (t = t.nextSibling, e = 0; t; ) {
              if (t.nodeType === 8) {
                var n = t.data;
                if (n === "/$") {
                  if (e === 0) {
                    Kn = zo(t.nextSibling);
                    break e;
                  }
                  e--;
                } else
                  n !== "$" && n !== "$!" && n !== "$?" || e++;
              }
              t = t.nextSibling;
            }
            Kn = null;
          }
        } else
          Kn = Gn ? zo(t.stateNode.nextSibling) : null;
        return true;
      }
      function m2() {
        for (var t = Kn; t; )
          t = zo(t.nextSibling);
      }
      function el() {
        Kn = Gn = null, ft = false;
      }
      function J1(t) {
        Br === null ? Br = [
          t
        ] : Br.push(t);
      }
      var Y_ = io.ReactCurrentBatchConfig;
      function Dr(t, e) {
        if (t && t.defaultProps) {
          e = vt({}, e), t = t.defaultProps;
          for (var n in t)
            e[n] === void 0 && (e[n] = t[n]);
          return e;
        }
        return e;
      }
      var jd = es(null), Wd = null, Sa = null, Z1 = null;
      function eb() {
        Z1 = Sa = Wd = null;
      }
      function tb(t) {
        var e = jd.current;
        lt(jd), t._currentValue = e;
      }
      function Dv(t, e, n) {
        for (; t !== null; ) {
          var r = t.alternate;
          if ((t.childLanes & e) !== e ? (t.childLanes |= e, r !== null && (r.childLanes |= e)) : r !== null && (r.childLanes & e) !== e && (r.childLanes |= e), t === n)
            break;
          t = t.return;
        }
      }
      function $a(t, e) {
        Wd = t, Z1 = Sa = null, t = t.dependencies, t !== null && t.firstContext !== null && ((t.lanes & e) !== 0 && (In = true), t.firstContext = null);
      }
      function Sr(t) {
        var e = t._currentValue;
        if (Z1 !== t)
          if (t = {
            context: t,
            memoizedValue: e,
            next: null
          }, Sa === null) {
            if (Wd === null)
              throw Error(ee(308));
            Sa = t, Wd.dependencies = {
              lanes: 0,
              firstContext: t
            };
          } else
            Sa = Sa.next = t;
        return e;
      }
      var ks = null;
      function nb(t) {
        ks === null ? ks = [
          t
        ] : ks.push(t);
      }
      function g2(t, e, n, r) {
        var i = e.interleaved;
        return i === null ? (n.next = n, nb(e)) : (n.next = i.next, i.next = n), e.interleaved = n, Xi(t, r);
      }
      function Xi(t, e) {
        t.lanes |= e;
        var n = t.alternate;
        for (n !== null && (n.lanes |= e), n = t, t = t.return; t !== null; )
          t.childLanes |= e, n = t.alternate, n !== null && (n.childLanes |= e), n = t, t = t.return;
        return n.tag === 3 ? n.stateNode : null;
      }
      var bo = false;
      function rb(t) {
        t.updateQueue = {
          baseState: t.memoizedState,
          firstBaseUpdate: null,
          lastBaseUpdate: null,
          shared: {
            pending: null,
            interleaved: null,
            lanes: 0
          },
          effects: null
        };
      }
      function v2(t, e) {
        t = t.updateQueue, e.updateQueue === t && (e.updateQueue = {
          baseState: t.baseState,
          firstBaseUpdate: t.firstBaseUpdate,
          lastBaseUpdate: t.lastBaseUpdate,
          shared: t.shared,
          effects: t.effects
        });
      }
      function Ui(t, e) {
        return {
          eventTime: t,
          lane: e,
          tag: 0,
          payload: null,
          callback: null,
          next: null
        };
      }
      function Fo(t, e, n) {
        var r = t.updateQueue;
        if (r === null)
          return null;
        if (r = r.shared, (je & 2) !== 0) {
          var i = r.pending;
          return i === null ? e.next = e : (e.next = i.next, i.next = e), r.pending = e, Xi(t, n);
        }
        return i = r.interleaved, i === null ? (e.next = e, nb(r)) : (e.next = i.next, i.next = e), r.interleaved = e, Xi(t, n);
      }
      function qh(t, e, n) {
        if (e = e.updateQueue, e !== null && (e = e.shared, (n & 4194240) !== 0)) {
          var r = e.lanes;
          r &= t.pendingLanes, n |= r, e.lanes = n, H1(t, n);
        }
      }
      function KS(t, e) {
        var n = t.updateQueue, r = t.alternate;
        if (r !== null && (r = r.updateQueue, n === r)) {
          var i = null, o = null;
          if (n = n.firstBaseUpdate, n !== null) {
            do {
              var s = {
                eventTime: n.eventTime,
                lane: n.lane,
                tag: n.tag,
                payload: n.payload,
                callback: n.callback,
                next: null
              };
              o === null ? i = o = s : o = o.next = s, n = n.next;
            } while (n !== null);
            o === null ? i = o = e : o = o.next = e;
          } else
            i = o = e;
          n = {
            baseState: r.baseState,
            firstBaseUpdate: i,
            lastBaseUpdate: o,
            shared: r.shared,
            effects: r.effects
          }, t.updateQueue = n;
          return;
        }
        t = n.lastBaseUpdate, t === null ? n.firstBaseUpdate = e : t.next = e, n.lastBaseUpdate = e;
      }
      function Ud(t, e, n, r) {
        var i = t.updateQueue;
        bo = false;
        var o = i.firstBaseUpdate, s = i.lastBaseUpdate, a = i.shared.pending;
        if (a !== null) {
          i.shared.pending = null;
          var l = a, c = l.next;
          l.next = null, s === null ? o = c : s.next = c, s = l;
          var u = t.alternate;
          u !== null && (u = u.updateQueue, a = u.lastBaseUpdate, a !== s && (a === null ? u.firstBaseUpdate = c : a.next = c, u.lastBaseUpdate = l));
        }
        if (o !== null) {
          var h = i.baseState;
          s = 0, u = c = l = null, a = o;
          do {
            var p = a.lane, v = a.eventTime;
            if ((r & p) === p) {
              u !== null && (u = u.next = {
                eventTime: v,
                lane: 0,
                tag: a.tag,
                payload: a.payload,
                callback: a.callback,
                next: null
              });
              e: {
                var y = t, S = a;
                switch (p = e, v = n, S.tag) {
                  case 1:
                    if (y = S.payload, typeof y == "function") {
                      h = y.call(v, h, p);
                      break e;
                    }
                    h = y;
                    break e;
                  case 3:
                    y.flags = y.flags & -65537 | 128;
                  case 0:
                    if (y = S.payload, p = typeof y == "function" ? y.call(v, h, p) : y, p == null)
                      break e;
                    h = vt({}, h, p);
                    break e;
                  case 2:
                    bo = true;
                }
              }
              a.callback !== null && a.lane !== 0 && (t.flags |= 64, p = i.effects, p === null ? i.effects = [
                a
              ] : p.push(a));
            } else
              v = {
                eventTime: v,
                lane: p,
                tag: a.tag,
                payload: a.payload,
                callback: a.callback,
                next: null
              }, u === null ? (c = u = v, l = h) : u = u.next = v, s |= p;
            if (a = a.next, a === null) {
              if (a = i.shared.pending, a === null)
                break;
              p = a, a = p.next, p.next = null, i.lastBaseUpdate = p, i.shared.pending = null;
            }
          } while (1);
          if (u === null && (l = h), i.baseState = l, i.firstBaseUpdate = c, i.lastBaseUpdate = u, e = i.shared.interleaved, e !== null) {
            i = e;
            do
              s |= i.lane, i = i.next;
            while (i !== e);
          } else
            o === null && (i.shared.lanes = 0);
          zs |= s, t.lanes = s, t.memoizedState = h;
        }
      }
      function qS(t, e, n) {
        if (t = e.effects, e.effects = null, t !== null)
          for (e = 0; e < t.length; e++) {
            var r = t[e], i = r.callback;
            if (i !== null) {
              if (r.callback = null, r = n, typeof i != "function")
                throw Error(ee(191, i));
              i.call(r);
            }
          }
      }
      var y2 = new gM.Component().refs;
      function _v(t, e, n, r) {
        e = t.memoizedState, n = n(r, e), n = n == null ? e : vt({}, e, n), t.memoizedState = n, t.lanes === 0 && (t.updateQueue.baseState = n);
      }
      var Jp = {
        isMounted: function(t) {
          return (t = t._reactInternals) ? Ys(t) === t : false;
        },
        enqueueSetState: function(t, e, n) {
          t = t._reactInternals;
          var r = Sn(), i = Ho(t), o = Ui(r, i);
          o.payload = e, n != null && (o.callback = n), e = Fo(t, o, i), e !== null && (Fr(e, t, i, r), qh(e, t, i));
        },
        enqueueReplaceState: function(t, e, n) {
          t = t._reactInternals;
          var r = Sn(), i = Ho(t), o = Ui(r, i);
          o.tag = 1, o.payload = e, n != null && (o.callback = n), e = Fo(t, o, i), e !== null && (Fr(e, t, i, r), qh(e, t, i));
        },
        enqueueForceUpdate: function(t, e) {
          t = t._reactInternals;
          var n = Sn(), r = Ho(t), i = Ui(n, r);
          i.tag = 2, e != null && (i.callback = e), e = Fo(t, i, r), e !== null && (Fr(e, t, r, n), qh(e, t, r));
        }
      };
      function GS(t, e, n, r, i, o, s) {
        return t = t.stateNode, typeof t.shouldComponentUpdate == "function" ? t.shouldComponentUpdate(r, o, s) : e.prototype && e.prototype.isPureReactComponent ? !lu(n, r) || !lu(i, o) : true;
      }
      function b2(t, e, n) {
        var r = false, i = Ko, o = e.contextType;
        return typeof o == "object" && o !== null ? o = Sr(o) : (i = zn(e) ? Bs : pn.current, r = e.contextTypes, o = (r = r != null) ? Za(t, i) : Ko), e = new e(n, o), t.memoizedState = e.state !== null && e.state !== void 0 ? e.state : null, e.updater = Jp, t.stateNode = e, e._reactInternals = t, r && (t = t.stateNode, t.__reactInternalMemoizedUnmaskedChildContext = i, t.__reactInternalMemoizedMaskedChildContext = o), e;
      }
      function YS(t, e, n, r) {
        t = e.state, typeof e.componentWillReceiveProps == "function" && e.componentWillReceiveProps(n, r), typeof e.UNSAFE_componentWillReceiveProps == "function" && e.UNSAFE_componentWillReceiveProps(n, r), e.state !== t && Jp.enqueueReplaceState(e, e.state, null);
      }
      function Iv(t, e, n, r) {
        var i = t.stateNode;
        i.props = n, i.state = t.memoizedState, i.refs = y2, rb(t);
        var o = e.contextType;
        typeof o == "object" && o !== null ? i.context = Sr(o) : (o = zn(e) ? Bs : pn.current, i.context = Za(t, o)), i.state = t.memoizedState, o = e.getDerivedStateFromProps, typeof o == "function" && (_v(t, e, o, n), i.state = t.memoizedState), typeof e.getDerivedStateFromProps == "function" || typeof i.getSnapshotBeforeUpdate == "function" || typeof i.UNSAFE_componentWillMount != "function" && typeof i.componentWillMount != "function" || (e = i.state, typeof i.componentWillMount == "function" && i.componentWillMount(), typeof i.UNSAFE_componentWillMount == "function" && i.UNSAFE_componentWillMount(), e !== i.state && Jp.enqueueReplaceState(i, i.state, null), Ud(t, n, i, r), i.state = t.memoizedState), typeof i.componentDidMount == "function" && (t.flags |= 4194308);
      }
      function Gl(t, e, n) {
        if (t = n.ref, t !== null && typeof t != "function" && typeof t != "object") {
          if (n._owner) {
            if (n = n._owner, n) {
              if (n.tag !== 1)
                throw Error(ee(309));
              var r = n.stateNode;
            }
            if (!r)
              throw Error(ee(147, t));
            var i = r, o = "" + t;
            return e !== null && e.ref !== null && typeof e.ref == "function" && e.ref._stringRef === o ? e.ref : (e = function(s) {
              var a = i.refs;
              a === y2 && (a = i.refs = {}), s === null ? delete a[o] : a[o] = s;
            }, e._stringRef = o, e);
          }
          if (typeof t != "string")
            throw Error(ee(284));
          if (!n._owner)
            throw Error(ee(290, t));
        }
        return t;
      }
      function Qf(t, e) {
        throw t = Object.prototype.toString.call(e), Error(ee(31, t === "[object Object]" ? "object with keys {" + Object.keys(e).join(", ") + "}" : t));
      }
      function XS(t) {
        var e = t._init;
        return e(t._payload);
      }
      function x2(t) {
        function e(w, k) {
          if (t) {
            var T = w.deletions;
            T === null ? (w.deletions = [
              k
            ], w.flags |= 16) : T.push(k);
          }
        }
        function n(w, k) {
          if (!t)
            return null;
          for (; k !== null; )
            e(w, k), k = k.sibling;
          return null;
        }
        function r(w, k) {
          for (w = /* @__PURE__ */ new Map(); k !== null; )
            k.key !== null ? w.set(k.key, k) : w.set(k.index, k), k = k.sibling;
          return w;
        }
        function i(w, k) {
          return w = jo(w, k), w.index = 0, w.sibling = null, w;
        }
        function o(w, k, T) {
          return w.index = T, t ? (T = w.alternate, T !== null ? (T = T.index, T < k ? (w.flags |= 2, k) : T) : (w.flags |= 2, k)) : (w.flags |= 1048576, k);
        }
        function s(w) {
          return t && w.alternate === null && (w.flags |= 2), w;
        }
        function a(w, k, T, P) {
          return k === null || k.tag !== 6 ? (k = Xg(T, w.mode, P), k.return = w, k) : (k = i(k, T), k.return = w, k);
        }
        function l(w, k, T, P) {
          var R = T.type;
          return R === da ? u(w, k, T.props.children, P, T.key) : k !== null && (k.elementType === R || typeof R == "object" && R !== null && R.$$typeof === yo && XS(R) === k.type) ? (P = i(k, T.props), P.ref = Gl(w, k, T), P.return = w, P) : (P = Zh(T.type, T.key, T.props, null, w.mode, P), P.ref = Gl(w, k, T), P.return = w, P);
        }
        function c(w, k, T, P) {
          return k === null || k.tag !== 4 || k.stateNode.containerInfo !== T.containerInfo || k.stateNode.implementation !== T.implementation ? (k = Qg(T, w.mode, P), k.return = w, k) : (k = i(k, T.children || []), k.return = w, k);
        }
        function u(w, k, T, P, R) {
          return k === null || k.tag !== 7 ? (k = Os(T, w.mode, P, R), k.return = w, k) : (k = i(k, T), k.return = w, k);
        }
        function h(w, k, T) {
          if (typeof k == "string" && k !== "" || typeof k == "number")
            return k = Xg("" + k, w.mode, T), k.return = w, k;
          if (typeof k == "object" && k !== null) {
            switch (k.$$typeof) {
              case Ff:
                return T = Zh(k.type, k.key, k.props, null, w.mode, T), T.ref = Gl(w, null, k), T.return = w, T;
              case ha:
                return k = Qg(k, w.mode, T), k.return = w, k;
              case yo:
                var P = k._init;
                return h(w, P(k._payload), T);
            }
            if (uc(k) || jl(k))
              return k = Os(k, w.mode, T, null), k.return = w, k;
            Qf(w, k);
          }
          return null;
        }
        function p(w, k, T, P) {
          var R = k !== null ? k.key : null;
          if (typeof T == "string" && T !== "" || typeof T == "number")
            return R !== null ? null : a(w, k, "" + T, P);
          if (typeof T == "object" && T !== null) {
            switch (T.$$typeof) {
              case Ff:
                return T.key === R ? l(w, k, T, P) : null;
              case ha:
                return T.key === R ? c(w, k, T, P) : null;
              case yo:
                return R = T._init, p(w, k, R(T._payload), P);
            }
            if (uc(T) || jl(T))
              return R !== null ? null : u(w, k, T, P, null);
            Qf(w, T);
          }
          return null;
        }
        function v(w, k, T, P, R) {
          if (typeof P == "string" && P !== "" || typeof P == "number")
            return w = w.get(T) || null, a(k, w, "" + P, R);
          if (typeof P == "object" && P !== null) {
            switch (P.$$typeof) {
              case Ff:
                return w = w.get(P.key === null ? T : P.key) || null, l(k, w, P, R);
              case ha:
                return w = w.get(P.key === null ? T : P.key) || null, c(k, w, P, R);
              case yo:
                var L = P._init;
                return v(w, k, T, L(P._payload), R);
            }
            if (uc(P) || jl(P))
              return w = w.get(T) || null, u(k, w, P, R, null);
            Qf(k, P);
          }
          return null;
        }
        function y(w, k, T, P) {
          for (var R = null, L = null, D = k, F = k = 0, K = null; D !== null && F < T.length; F++) {
            D.index > F ? (K = D, D = null) : K = D.sibling;
            var Y = p(w, D, T[F], P);
            if (Y === null) {
              D === null && (D = K);
              break;
            }
            t && D && Y.alternate === null && e(w, D), k = o(Y, k, F), L === null ? R = Y : L.sibling = Y, L = Y, D = K;
          }
          if (F === T.length)
            return n(w, D), ft && gs(w, F), R;
          if (D === null) {
            for (; F < T.length; F++)
              D = h(w, T[F], P), D !== null && (k = o(D, k, F), L === null ? R = D : L.sibling = D, L = D);
            return ft && gs(w, F), R;
          }
          for (D = r(w, D); F < T.length; F++)
            K = v(D, w, F, T[F], P), K !== null && (t && K.alternate !== null && D.delete(K.key === null ? F : K.key), k = o(K, k, F), L === null ? R = K : L.sibling = K, L = K);
          return t && D.forEach(function(te) {
            return e(w, te);
          }), ft && gs(w, F), R;
        }
        function S(w, k, T, P) {
          var R = jl(T);
          if (typeof R != "function")
            throw Error(ee(150));
          if (T = R.call(T), T == null)
            throw Error(ee(151));
          for (var L = R = null, D = k, F = k = 0, K = null, Y = T.next(); D !== null && !Y.done; F++, Y = T.next()) {
            D.index > F ? (K = D, D = null) : K = D.sibling;
            var te = p(w, D, Y.value, P);
            if (te === null) {
              D === null && (D = K);
              break;
            }
            t && D && te.alternate === null && e(w, D), k = o(te, k, F), L === null ? R = te : L.sibling = te, L = te, D = K;
          }
          if (Y.done)
            return n(w, D), ft && gs(w, F), R;
          if (D === null) {
            for (; !Y.done; F++, Y = T.next())
              Y = h(w, Y.value, P), Y !== null && (k = o(Y, k, F), L === null ? R = Y : L.sibling = Y, L = Y);
            return ft && gs(w, F), R;
          }
          for (D = r(w, D); !Y.done; F++, Y = T.next())
            Y = v(D, w, F, Y.value, P), Y !== null && (t && Y.alternate !== null && D.delete(Y.key === null ? F : Y.key), k = o(Y, k, F), L === null ? R = Y : L.sibling = Y, L = Y);
          return t && D.forEach(function(ne) {
            return e(w, ne);
          }), ft && gs(w, F), R;
        }
        function C(w, k, T, P) {
          if (typeof T == "object" && T !== null && T.type === da && T.key === null && (T = T.props.children), typeof T == "object" && T !== null) {
            switch (T.$$typeof) {
              case Ff:
                e: {
                  for (var R = T.key, L = k; L !== null; ) {
                    if (L.key === R) {
                      if (R = T.type, R === da) {
                        if (L.tag === 7) {
                          n(w, L.sibling), k = i(L, T.props.children), k.return = w, w = k;
                          break e;
                        }
                      } else if (L.elementType === R || typeof R == "object" && R !== null && R.$$typeof === yo && XS(R) === L.type) {
                        n(w, L.sibling), k = i(L, T.props), k.ref = Gl(w, L, T), k.return = w, w = k;
                        break e;
                      }
                      n(w, L);
                      break;
                    } else
                      e(w, L);
                    L = L.sibling;
                  }
                  T.type === da ? (k = Os(T.props.children, w.mode, P, T.key), k.return = w, w = k) : (P = Zh(T.type, T.key, T.props, null, w.mode, P), P.ref = Gl(w, k, T), P.return = w, w = P);
                }
                return s(w);
              case ha:
                e: {
                  for (L = T.key; k !== null; ) {
                    if (k.key === L)
                      if (k.tag === 4 && k.stateNode.containerInfo === T.containerInfo && k.stateNode.implementation === T.implementation) {
                        n(w, k.sibling), k = i(k, T.children || []), k.return = w, w = k;
                        break e;
                      } else {
                        n(w, k);
                        break;
                      }
                    else
                      e(w, k);
                    k = k.sibling;
                  }
                  k = Qg(T, w.mode, P), k.return = w, w = k;
                }
                return s(w);
              case yo:
                return L = T._init, C(w, k, L(T._payload), P);
            }
            if (uc(T))
              return y(w, k, T, P);
            if (jl(T))
              return S(w, k, T, P);
            Qf(w, T);
          }
          return typeof T == "string" && T !== "" || typeof T == "number" ? (T = "" + T, k !== null && k.tag === 6 ? (n(w, k.sibling), k = i(k, T), k.return = w, w = k) : (n(w, k), k = Xg(T, w.mode, P), k.return = w, w = k), s(w)) : n(w, k);
        }
        return C;
      }
      var tl = x2(true), S2 = x2(false), Gu = {}, bi = es(Gu), hu = es(Gu), du = es(Gu);
      function Cs(t) {
        if (t === Gu)
          throw Error(ee(174));
        return t;
      }
      function ib(t, e) {
        switch (nt(du, e), nt(hu, t), nt(bi, Gu), t = e.nodeType, t) {
          case 9:
          case 11:
            e = (e = e.documentElement) ? e.namespaceURI : dv(null, "");
            break;
          default:
            t = t === 8 ? e.parentNode : e, e = t.namespaceURI || null, t = t.tagName, e = dv(e, t);
        }
        lt(bi), nt(bi, e);
      }
      function nl() {
        lt(bi), lt(hu), lt(du);
      }
      function w2(t) {
        Cs(du.current);
        var e = Cs(bi.current), n = dv(e, t.type);
        e !== n && (nt(hu, t), nt(bi, n));
      }
      function ob(t) {
        hu.current === t && (lt(bi), lt(hu));
      }
      var mt = es(0);
      function Kd(t) {
        for (var e = t; e !== null; ) {
          if (e.tag === 13) {
            var n = e.memoizedState;
            if (n !== null && (n = n.dehydrated, n === null || n.data === "$?" || n.data === "$!"))
              return e;
          } else if (e.tag === 19 && e.memoizedProps.revealOrder !== void 0) {
            if ((e.flags & 128) !== 0)
              return e;
          } else if (e.child !== null) {
            e.child.return = e, e = e.child;
            continue;
          }
          if (e === t)
            break;
          for (; e.sibling === null; ) {
            if (e.return === null || e.return === t)
              return null;
            e = e.return;
          }
          e.sibling.return = e.return, e = e.sibling;
        }
        return null;
      }
      var Wg = [];
      function sb() {
        for (var t = 0; t < Wg.length; t++)
          Wg[t]._workInProgressVersionPrimary = null;
        Wg.length = 0;
      }
      var Gh = io.ReactCurrentDispatcher, Ug = io.ReactCurrentBatchConfig, $s = 0, gt = null, Dt = null, Vt = null, qd = false, Oc = false, pu = 0, X_ = 0;
      function sn() {
        throw Error(ee(321));
      }
      function ab(t, e) {
        if (e === null)
          return false;
        for (var n = 0; n < e.length && n < t.length; n++)
          if (!Wr(t[n], e[n]))
            return false;
        return true;
      }
      function lb(t, e, n, r, i, o) {
        if ($s = o, gt = e, e.memoizedState = null, e.updateQueue = null, e.lanes = 0, Gh.current = t === null || t.memoizedState === null ? eI : tI, t = n(r, i), Oc) {
          o = 0;
          do {
            if (Oc = false, pu = 0, 25 <= o)
              throw Error(ee(301));
            o += 1, Vt = Dt = null, e.updateQueue = null, Gh.current = nI, t = n(r, i);
          } while (Oc);
        }
        if (Gh.current = Gd, e = Dt !== null && Dt.next !== null, $s = 0, Vt = Dt = gt = null, qd = false, e)
          throw Error(ee(300));
        return t;
      }
      function cb() {
        var t = pu !== 0;
        return pu = 0, t;
      }
      function oi() {
        var t = {
          memoizedState: null,
          baseState: null,
          baseQueue: null,
          queue: null,
          next: null
        };
        return Vt === null ? gt.memoizedState = Vt = t : Vt = Vt.next = t, Vt;
      }
      function wr() {
        if (Dt === null) {
          var t = gt.alternate;
          t = t !== null ? t.memoizedState : null;
        } else
          t = Dt.next;
        var e = Vt === null ? gt.memoizedState : Vt.next;
        if (e !== null)
          Vt = e, Dt = t;
        else {
          if (t === null)
            throw Error(ee(310));
          Dt = t, t = {
            memoizedState: Dt.memoizedState,
            baseState: Dt.baseState,
            baseQueue: Dt.baseQueue,
            queue: Dt.queue,
            next: null
          }, Vt === null ? gt.memoizedState = Vt = t : Vt = Vt.next = t;
        }
        return Vt;
      }
      function mu(t, e) {
        return typeof e == "function" ? e(t) : e;
      }
      function Kg(t) {
        var e = wr(), n = e.queue;
        if (n === null)
          throw Error(ee(311));
        n.lastRenderedReducer = t;
        var r = Dt, i = r.baseQueue, o = n.pending;
        if (o !== null) {
          if (i !== null) {
            var s = i.next;
            i.next = o.next, o.next = s;
          }
          r.baseQueue = i = o, n.pending = null;
        }
        if (i !== null) {
          o = i.next, r = r.baseState;
          var a = s = null, l = null, c = o;
          do {
            var u = c.lane;
            if (($s & u) === u)
              l !== null && (l = l.next = {
                lane: 0,
                action: c.action,
                hasEagerState: c.hasEagerState,
                eagerState: c.eagerState,
                next: null
              }), r = c.hasEagerState ? c.eagerState : t(r, c.action);
            else {
              var h = {
                lane: u,
                action: c.action,
                hasEagerState: c.hasEagerState,
                eagerState: c.eagerState,
                next: null
              };
              l === null ? (a = l = h, s = r) : l = l.next = h, gt.lanes |= u, zs |= u;
            }
            c = c.next;
          } while (c !== null && c !== o);
          l === null ? s = r : l.next = a, Wr(r, e.memoizedState) || (In = true), e.memoizedState = r, e.baseState = s, e.baseQueue = l, n.lastRenderedState = r;
        }
        if (t = n.interleaved, t !== null) {
          i = t;
          do
            o = i.lane, gt.lanes |= o, zs |= o, i = i.next;
          while (i !== t);
        } else
          i === null && (n.lanes = 0);
        return [
          e.memoizedState,
          n.dispatch
        ];
      }
      function qg(t) {
        var e = wr(), n = e.queue;
        if (n === null)
          throw Error(ee(311));
        n.lastRenderedReducer = t;
        var r = n.dispatch, i = n.pending, o = e.memoizedState;
        if (i !== null) {
          n.pending = null;
          var s = i = i.next;
          do
            o = t(o, s.action), s = s.next;
          while (s !== i);
          Wr(o, e.memoizedState) || (In = true), e.memoizedState = o, e.baseQueue === null && (e.baseState = o), n.lastRenderedState = o;
        }
        return [
          o,
          r
        ];
      }
      function k2() {
      }
      function C2(t, e) {
        var n = gt, r = wr(), i = e(), o = !Wr(r.memoizedState, i);
        if (o && (r.memoizedState = i, In = true), r = r.queue, ub(A2.bind(null, n, r, t), [
          t
        ]), r.getSnapshot !== e || o || Vt !== null && Vt.memoizedState.tag & 1) {
          if (n.flags |= 2048, gu(9, M2.bind(null, n, r, i, e), void 0, null), jt === null)
            throw Error(ee(349));
          ($s & 30) !== 0 || T2(n, e, i);
        }
        return i;
      }
      function T2(t, e, n) {
        t.flags |= 16384, t = {
          getSnapshot: e,
          value: n
        }, e = gt.updateQueue, e === null ? (e = {
          lastEffect: null,
          stores: null
        }, gt.updateQueue = e, e.stores = [
          t
        ]) : (n = e.stores, n === null ? e.stores = [
          t
        ] : n.push(t));
      }
      function M2(t, e, n, r) {
        e.value = n, e.getSnapshot = r, E2(e) && P2(t);
      }
      function A2(t, e, n) {
        return n(function() {
          E2(e) && P2(t);
        });
      }
      function E2(t) {
        var e = t.getSnapshot;
        t = t.value;
        try {
          var n = e();
          return !Wr(t, n);
        } catch {
          return true;
        }
      }
      function P2(t) {
        var e = Xi(t, 1);
        e !== null && Fr(e, t, 1, -1);
      }
      function QS(t) {
        var e = oi();
        return typeof t == "function" && (t = t()), e.memoizedState = e.baseState = t, t = {
          pending: null,
          interleaved: null,
          lanes: 0,
          dispatch: null,
          lastRenderedReducer: mu,
          lastRenderedState: t
        }, e.queue = t, t = t.dispatch = Z_.bind(null, gt, t), [
          e.memoizedState,
          t
        ];
      }
      function gu(t, e, n, r) {
        return t = {
          tag: t,
          create: e,
          destroy: n,
          deps: r,
          next: null
        }, e = gt.updateQueue, e === null ? (e = {
          lastEffect: null,
          stores: null
        }, gt.updateQueue = e, e.lastEffect = t.next = t) : (n = e.lastEffect, n === null ? e.lastEffect = t.next = t : (r = n.next, n.next = t, t.next = r, e.lastEffect = t)), t;
      }
      function O2() {
        return wr().memoizedState;
      }
      function Yh(t, e, n, r) {
        var i = oi();
        gt.flags |= t, i.memoizedState = gu(1 | e, n, void 0, r === void 0 ? null : r);
      }
      function Zp(t, e, n, r) {
        var i = wr();
        r = r === void 0 ? null : r;
        var o = void 0;
        if (Dt !== null) {
          var s = Dt.memoizedState;
          if (o = s.destroy, r !== null && ab(r, s.deps)) {
            i.memoizedState = gu(e, n, o, r);
            return;
          }
        }
        gt.flags |= t, i.memoizedState = gu(1 | e, n, o, r);
      }
      function JS(t, e) {
        return Yh(8390656, 8, t, e);
      }
      function ub(t, e) {
        return Zp(2048, 8, t, e);
      }
      function R2(t, e) {
        return Zp(4, 2, t, e);
      }
      function L2(t, e) {
        return Zp(4, 4, t, e);
      }
      function D2(t, e) {
        if (typeof e == "function")
          return t = t(), e(t), function() {
            e(null);
          };
        if (e != null)
          return t = t(), e.current = t, function() {
            e.current = null;
          };
      }
      function _2(t, e, n) {
        return n = n != null ? n.concat([
          t
        ]) : null, Zp(4, 4, D2.bind(null, e, t), n);
      }
      function fb() {
      }
      function I2(t, e) {
        var n = wr();
        e = e === void 0 ? null : e;
        var r = n.memoizedState;
        return r !== null && e !== null && ab(e, r[1]) ? r[0] : (n.memoizedState = [
          t,
          e
        ], t);
      }
      function B2(t, e) {
        var n = wr();
        e = e === void 0 ? null : e;
        var r = n.memoizedState;
        return r !== null && e !== null && ab(e, r[1]) ? r[0] : (t = t(), n.memoizedState = [
          t,
          e
        ], t);
      }
      function N2(t, e, n) {
        return ($s & 21) === 0 ? (t.baseState && (t.baseState = false, In = true), t.memoizedState = n) : (Wr(n, e) || (n = FM(), gt.lanes |= n, zs |= n, t.baseState = true), e);
      }
      function Q_(t, e) {
        var n = Ye;
        Ye = n !== 0 && 4 > n ? n : 4, t(true);
        var r = Ug.transition;
        Ug.transition = {};
        try {
          t(false), e();
        } finally {
          Ye = n, Ug.transition = r;
        }
      }
      function $2() {
        return wr().memoizedState;
      }
      function J_(t, e, n) {
        var r = Ho(t);
        if (n = {
          lane: r,
          action: n,
          hasEagerState: false,
          eagerState: null,
          next: null
        }, z2(t))
          F2(e, n);
        else if (n = g2(t, e, n, r), n !== null) {
          var i = Sn();
          Fr(n, t, r, i), V2(n, e, r);
        }
      }
      function Z_(t, e, n) {
        var r = Ho(t), i = {
          lane: r,
          action: n,
          hasEagerState: false,
          eagerState: null,
          next: null
        };
        if (z2(t))
          F2(e, i);
        else {
          var o = t.alternate;
          if (t.lanes === 0 && (o === null || o.lanes === 0) && (o = e.lastRenderedReducer, o !== null))
            try {
              var s = e.lastRenderedState, a = o(s, n);
              if (i.hasEagerState = true, i.eagerState = a, Wr(a, s)) {
                var l = e.interleaved;
                l === null ? (i.next = i, nb(e)) : (i.next = l.next, l.next = i), e.interleaved = i;
                return;
              }
            } catch {
            } finally {
            }
          n = g2(t, e, i, r), n !== null && (i = Sn(), Fr(n, t, r, i), V2(n, e, r));
        }
      }
      function z2(t) {
        var e = t.alternate;
        return t === gt || e !== null && e === gt;
      }
      function F2(t, e) {
        Oc = qd = true;
        var n = t.pending;
        n === null ? e.next = e : (e.next = n.next, n.next = e), t.pending = e;
      }
      function V2(t, e, n) {
        if ((n & 4194240) !== 0) {
          var r = e.lanes;
          r &= t.pendingLanes, n |= r, e.lanes = n, H1(t, n);
        }
      }
      var Gd = {
        readContext: Sr,
        useCallback: sn,
        useContext: sn,
        useEffect: sn,
        useImperativeHandle: sn,
        useInsertionEffect: sn,
        useLayoutEffect: sn,
        useMemo: sn,
        useReducer: sn,
        useRef: sn,
        useState: sn,
        useDebugValue: sn,
        useDeferredValue: sn,
        useTransition: sn,
        useMutableSource: sn,
        useSyncExternalStore: sn,
        useId: sn,
        unstable_isNewReconciler: false
      }, eI = {
        readContext: Sr,
        useCallback: function(t, e) {
          return oi().memoizedState = [
            t,
            e === void 0 ? null : e
          ], t;
        },
        useContext: Sr,
        useEffect: JS,
        useImperativeHandle: function(t, e, n) {
          return n = n != null ? n.concat([
            t
          ]) : null, Yh(4194308, 4, D2.bind(null, e, t), n);
        },
        useLayoutEffect: function(t, e) {
          return Yh(4194308, 4, t, e);
        },
        useInsertionEffect: function(t, e) {
          return Yh(4, 2, t, e);
        },
        useMemo: function(t, e) {
          var n = oi();
          return e = e === void 0 ? null : e, t = t(), n.memoizedState = [
            t,
            e
          ], t;
        },
        useReducer: function(t, e, n) {
          var r = oi();
          return e = n !== void 0 ? n(e) : e, r.memoizedState = r.baseState = e, t = {
            pending: null,
            interleaved: null,
            lanes: 0,
            dispatch: null,
            lastRenderedReducer: t,
            lastRenderedState: e
          }, r.queue = t, t = t.dispatch = J_.bind(null, gt, t), [
            r.memoizedState,
            t
          ];
        },
        useRef: function(t) {
          var e = oi();
          return t = {
            current: t
          }, e.memoizedState = t;
        },
        useState: QS,
        useDebugValue: fb,
        useDeferredValue: function(t) {
          return oi().memoizedState = t;
        },
        useTransition: function() {
          var t = QS(false), e = t[0];
          return t = Q_.bind(null, t[1]), oi().memoizedState = t, [
            e,
            t
          ];
        },
        useMutableSource: function() {
        },
        useSyncExternalStore: function(t, e, n) {
          var r = gt, i = oi();
          if (ft) {
            if (n === void 0)
              throw Error(ee(407));
            n = n();
          } else {
            if (n = e(), jt === null)
              throw Error(ee(349));
            ($s & 30) !== 0 || T2(r, e, n);
          }
          i.memoizedState = n;
          var o = {
            value: n,
            getSnapshot: e
          };
          return i.queue = o, JS(A2.bind(null, r, o, t), [
            t
          ]), r.flags |= 2048, gu(9, M2.bind(null, r, o, n, e), void 0, null), n;
        },
        useId: function() {
          var t = oi(), e = jt.identifierPrefix;
          if (ft) {
            var n = ji, r = Hi;
            n = (r & ~(1 << 32 - zr(r) - 1)).toString(32) + n, e = ":" + e + "R" + n, n = pu++, 0 < n && (e += "H" + n.toString(32)), e += ":";
          } else
            n = X_++, e = ":" + e + "r" + n.toString(32) + ":";
          return t.memoizedState = e;
        },
        unstable_isNewReconciler: false
      }, tI = {
        readContext: Sr,
        useCallback: I2,
        useContext: Sr,
        useEffect: ub,
        useImperativeHandle: _2,
        useInsertionEffect: R2,
        useLayoutEffect: L2,
        useMemo: B2,
        useReducer: Kg,
        useRef: O2,
        useState: function() {
          return Kg(mu);
        },
        useDebugValue: fb,
        useDeferredValue: function(t) {
          var e = wr();
          return N2(e, Dt.memoizedState, t);
        },
        useTransition: function() {
          var t = Kg(mu)[0], e = wr().memoizedState;
          return [
            t,
            e
          ];
        },
        useMutableSource: k2,
        useSyncExternalStore: C2,
        useId: $2,
        unstable_isNewReconciler: false
      }, nI = {
        readContext: Sr,
        useCallback: I2,
        useContext: Sr,
        useEffect: ub,
        useImperativeHandle: _2,
        useInsertionEffect: R2,
        useLayoutEffect: L2,
        useMemo: B2,
        useReducer: qg,
        useRef: O2,
        useState: function() {
          return qg(mu);
        },
        useDebugValue: fb,
        useDeferredValue: function(t) {
          var e = wr();
          return Dt === null ? e.memoizedState = t : N2(e, Dt.memoizedState, t);
        },
        useTransition: function() {
          var t = qg(mu)[0], e = wr().memoizedState;
          return [
            t,
            e
          ];
        },
        useMutableSource: k2,
        useSyncExternalStore: C2,
        useId: $2,
        unstable_isNewReconciler: false
      };
      function rl(t, e) {
        try {
          var n = "", r = e;
          do
            n += OD(r), r = r.return;
          while (r);
          var i = n;
        } catch (o) {
          i = `
Error generating stack: ` + o.message + `
` + o.stack;
        }
        return {
          value: t,
          source: e,
          stack: i,
          digest: null
        };
      }
      function Gg(t, e, n) {
        return {
          value: t,
          source: null,
          stack: n ?? null,
          digest: e ?? null
        };
      }
      function Bv(t, e) {
        try {
          console.error(e.value);
        } catch (n) {
          setTimeout(function() {
            throw n;
          });
        }
      }
      var rI = typeof WeakMap == "function" ? WeakMap : Map;
      function H2(t, e, n) {
        n = Ui(-1, n), n.tag = 3, n.payload = {
          element: null
        };
        var r = e.value;
        return n.callback = function() {
          Xd || (Xd = true, Kv = r), Bv(t, e);
        }, n;
      }
      function j2(t, e, n) {
        n = Ui(-1, n), n.tag = 3;
        var r = t.type.getDerivedStateFromError;
        if (typeof r == "function") {
          var i = e.value;
          n.payload = function() {
            return r(i);
          }, n.callback = function() {
            Bv(t, e);
          };
        }
        var o = t.stateNode;
        return o !== null && typeof o.componentDidCatch == "function" && (n.callback = function() {
          Bv(t, e), typeof r != "function" && (Vo === null ? Vo = /* @__PURE__ */ new Set([
            this
          ]) : Vo.add(this));
          var s = e.stack;
          this.componentDidCatch(e.value, {
            componentStack: s !== null ? s : ""
          });
        }), n;
      }
      function ZS(t, e, n) {
        var r = t.pingCache;
        if (r === null) {
          r = t.pingCache = new rI();
          var i = /* @__PURE__ */ new Set();
          r.set(e, i);
        } else
          i = r.get(e), i === void 0 && (i = /* @__PURE__ */ new Set(), r.set(e, i));
        i.has(n) || (i.add(n), t = vI.bind(null, t, e, n), e.then(t, t));
      }
      function ew(t) {
        do {
          var e;
          if ((e = t.tag === 13) && (e = t.memoizedState, e = e !== null ? e.dehydrated !== null : true), e)
            return t;
          t = t.return;
        } while (t !== null);
        return null;
      }
      function tw(t, e, n, r, i) {
        return (t.mode & 1) === 0 ? (t === e ? t.flags |= 65536 : (t.flags |= 128, n.flags |= 131072, n.flags &= -52805, n.tag === 1 && (n.alternate === null ? n.tag = 17 : (e = Ui(-1, 1), e.tag = 2, Fo(n, e, 1))), n.lanes |= 1), t) : (t.flags |= 65536, t.lanes = i, t);
      }
      var iI = io.ReactCurrentOwner, In = false;
      function bn(t, e, n, r) {
        e.child = t === null ? S2(e, null, n, r) : tl(e, t.child, n, r);
      }
      function nw(t, e, n, r, i) {
        n = n.render;
        var o = e.ref;
        return $a(e, i), r = lb(t, e, n, r, o, i), n = cb(), t !== null && !In ? (e.updateQueue = t.updateQueue, e.flags &= -2053, t.lanes &= ~i, Qi(t, e, i)) : (ft && n && X1(e), e.flags |= 1, bn(t, e, r, i), e.child);
      }
      function rw(t, e, n, r, i) {
        if (t === null) {
          var o = n.type;
          return typeof o == "function" && !bb(o) && o.defaultProps === void 0 && n.compare === null && n.defaultProps === void 0 ? (e.tag = 15, e.type = o, W2(t, e, o, r, i)) : (t = Zh(n.type, null, r, e, e.mode, i), t.ref = e.ref, t.return = e, e.child = t);
        }
        if (o = t.child, (t.lanes & i) === 0) {
          var s = o.memoizedProps;
          if (n = n.compare, n = n !== null ? n : lu, n(s, r) && t.ref === e.ref)
            return Qi(t, e, i);
        }
        return e.flags |= 1, t = jo(o, r), t.ref = e.ref, t.return = e, e.child = t;
      }
      function W2(t, e, n, r, i) {
        if (t !== null) {
          var o = t.memoizedProps;
          if (lu(o, r) && t.ref === e.ref)
            if (In = false, e.pendingProps = r = o, (t.lanes & i) !== 0)
              (t.flags & 131072) !== 0 && (In = true);
            else
              return e.lanes = t.lanes, Qi(t, e, i);
        }
        return Nv(t, e, n, r, i);
      }
      function U2(t, e, n) {
        var r = e.pendingProps, i = r.children, o = t !== null ? t.memoizedState : null;
        if (r.mode === "hidden")
          if ((e.mode & 1) === 0)
            e.memoizedState = {
              baseLanes: 0,
              cachePool: null,
              transitions: null
            }, nt(ka, Wn), Wn |= n;
          else {
            if ((n & 1073741824) === 0)
              return t = o !== null ? o.baseLanes | n : n, e.lanes = e.childLanes = 1073741824, e.memoizedState = {
                baseLanes: t,
                cachePool: null,
                transitions: null
              }, e.updateQueue = null, nt(ka, Wn), Wn |= t, null;
            e.memoizedState = {
              baseLanes: 0,
              cachePool: null,
              transitions: null
            }, r = o !== null ? o.baseLanes : n, nt(ka, Wn), Wn |= r;
          }
        else
          o !== null ? (r = o.baseLanes | n, e.memoizedState = null) : r = n, nt(ka, Wn), Wn |= r;
        return bn(t, e, i, n), e.child;
      }
      function K2(t, e) {
        var n = e.ref;
        (t === null && n !== null || t !== null && t.ref !== n) && (e.flags |= 512, e.flags |= 2097152);
      }
      function Nv(t, e, n, r, i) {
        var o = zn(n) ? Bs : pn.current;
        return o = Za(e, o), $a(e, i), n = lb(t, e, n, r, o, i), r = cb(), t !== null && !In ? (e.updateQueue = t.updateQueue, e.flags &= -2053, t.lanes &= ~i, Qi(t, e, i)) : (ft && r && X1(e), e.flags |= 1, bn(t, e, n, i), e.child);
      }
      function iw(t, e, n, r, i) {
        if (zn(n)) {
          var o = true;
          Fd(e);
        } else
          o = false;
        if ($a(e, i), e.stateNode === null)
          Xh(t, e), b2(e, n, r), Iv(e, n, r, i), r = true;
        else if (t === null) {
          var s = e.stateNode, a = e.memoizedProps;
          s.props = a;
          var l = s.context, c = n.contextType;
          typeof c == "object" && c !== null ? c = Sr(c) : (c = zn(n) ? Bs : pn.current, c = Za(e, c));
          var u = n.getDerivedStateFromProps, h = typeof u == "function" || typeof s.getSnapshotBeforeUpdate == "function";
          h || typeof s.UNSAFE_componentWillReceiveProps != "function" && typeof s.componentWillReceiveProps != "function" || (a !== r || l !== c) && YS(e, s, r, c), bo = false;
          var p = e.memoizedState;
          s.state = p, Ud(e, r, s, i), l = e.memoizedState, a !== r || p !== l || $n.current || bo ? (typeof u == "function" && (_v(e, n, u, r), l = e.memoizedState), (a = bo || GS(e, n, a, r, p, l, c)) ? (h || typeof s.UNSAFE_componentWillMount != "function" && typeof s.componentWillMount != "function" || (typeof s.componentWillMount == "function" && s.componentWillMount(), typeof s.UNSAFE_componentWillMount == "function" && s.UNSAFE_componentWillMount()), typeof s.componentDidMount == "function" && (e.flags |= 4194308)) : (typeof s.componentDidMount == "function" && (e.flags |= 4194308), e.memoizedProps = r, e.memoizedState = l), s.props = r, s.state = l, s.context = c, r = a) : (typeof s.componentDidMount == "function" && (e.flags |= 4194308), r = false);
        } else {
          s = e.stateNode, v2(t, e), a = e.memoizedProps, c = e.type === e.elementType ? a : Dr(e.type, a), s.props = c, h = e.pendingProps, p = s.context, l = n.contextType, typeof l == "object" && l !== null ? l = Sr(l) : (l = zn(n) ? Bs : pn.current, l = Za(e, l));
          var v = n.getDerivedStateFromProps;
          (u = typeof v == "function" || typeof s.getSnapshotBeforeUpdate == "function") || typeof s.UNSAFE_componentWillReceiveProps != "function" && typeof s.componentWillReceiveProps != "function" || (a !== h || p !== l) && YS(e, s, r, l), bo = false, p = e.memoizedState, s.state = p, Ud(e, r, s, i);
          var y = e.memoizedState;
          a !== h || p !== y || $n.current || bo ? (typeof v == "function" && (_v(e, n, v, r), y = e.memoizedState), (c = bo || GS(e, n, c, r, p, y, l) || false) ? (u || typeof s.UNSAFE_componentWillUpdate != "function" && typeof s.componentWillUpdate != "function" || (typeof s.componentWillUpdate == "function" && s.componentWillUpdate(r, y, l), typeof s.UNSAFE_componentWillUpdate == "function" && s.UNSAFE_componentWillUpdate(r, y, l)), typeof s.componentDidUpdate == "function" && (e.flags |= 4), typeof s.getSnapshotBeforeUpdate == "function" && (e.flags |= 1024)) : (typeof s.componentDidUpdate != "function" || a === t.memoizedProps && p === t.memoizedState || (e.flags |= 4), typeof s.getSnapshotBeforeUpdate != "function" || a === t.memoizedProps && p === t.memoizedState || (e.flags |= 1024), e.memoizedProps = r, e.memoizedState = y), s.props = r, s.state = y, s.context = l, r = c) : (typeof s.componentDidUpdate != "function" || a === t.memoizedProps && p === t.memoizedState || (e.flags |= 4), typeof s.getSnapshotBeforeUpdate != "function" || a === t.memoizedProps && p === t.memoizedState || (e.flags |= 1024), r = false);
        }
        return $v(t, e, n, r, o, i);
      }
      function $v(t, e, n, r, i, o) {
        K2(t, e);
        var s = (e.flags & 128) !== 0;
        if (!r && !s)
          return i && jS(e, n, false), Qi(t, e, o);
        r = e.stateNode, iI.current = e;
        var a = s && typeof n.getDerivedStateFromError != "function" ? null : r.render();
        return e.flags |= 1, t !== null && s ? (e.child = tl(e, t.child, null, o), e.child = tl(e, null, a, o)) : bn(t, e, a, o), e.memoizedState = r.state, i && jS(e, n, true), e.child;
      }
      function q2(t) {
        var e = t.stateNode;
        e.pendingContext ? HS(t, e.pendingContext, e.pendingContext !== e.context) : e.context && HS(t, e.context, false), ib(t, e.containerInfo);
      }
      function ow(t, e, n, r, i) {
        return el(), J1(i), e.flags |= 256, bn(t, e, n, r), e.child;
      }
      var zv = {
        dehydrated: null,
        treeContext: null,
        retryLane: 0
      };
      function Fv(t) {
        return {
          baseLanes: t,
          cachePool: null,
          transitions: null
        };
      }
      function G2(t, e, n) {
        var r = e.pendingProps, i = mt.current, o = false, s = (e.flags & 128) !== 0, a;
        if ((a = s) || (a = t !== null && t.memoizedState === null ? false : (i & 2) !== 0), a ? (o = true, e.flags &= -129) : (t === null || t.memoizedState !== null) && (i |= 1), nt(mt, i & 1), t === null)
          return Lv(e), t = e.memoizedState, t !== null && (t = t.dehydrated, t !== null) ? ((e.mode & 1) === 0 ? e.lanes = 1 : t.data === "$!" ? e.lanes = 8 : e.lanes = 1073741824, null) : (s = r.children, t = r.fallback, o ? (r = e.mode, o = e.child, s = {
            mode: "hidden",
            children: s
          }, (r & 1) === 0 && o !== null ? (o.childLanes = 0, o.pendingProps = s) : o = nm(s, r, 0, null), t = Os(t, r, n, null), o.return = e, t.return = e, o.sibling = t, e.child = o, e.child.memoizedState = Fv(n), e.memoizedState = zv, t) : hb(e, s));
        if (i = t.memoizedState, i !== null && (a = i.dehydrated, a !== null))
          return oI(t, e, s, r, a, i, n);
        if (o) {
          o = r.fallback, s = e.mode, i = t.child, a = i.sibling;
          var l = {
            mode: "hidden",
            children: r.children
          };
          return (s & 1) === 0 && e.child !== i ? (r = e.child, r.childLanes = 0, r.pendingProps = l, e.deletions = null) : (r = jo(i, l), r.subtreeFlags = i.subtreeFlags & 14680064), a !== null ? o = jo(a, o) : (o = Os(o, s, n, null), o.flags |= 2), o.return = e, r.return = e, r.sibling = o, e.child = r, r = o, o = e.child, s = t.child.memoizedState, s = s === null ? Fv(n) : {
            baseLanes: s.baseLanes | n,
            cachePool: null,
            transitions: s.transitions
          }, o.memoizedState = s, o.childLanes = t.childLanes & ~n, e.memoizedState = zv, r;
        }
        return o = t.child, t = o.sibling, r = jo(o, {
          mode: "visible",
          children: r.children
        }), (e.mode & 1) === 0 && (r.lanes = n), r.return = e, r.sibling = null, t !== null && (n = e.deletions, n === null ? (e.deletions = [
          t
        ], e.flags |= 16) : n.push(t)), e.child = r, e.memoizedState = null, r;
      }
      function hb(t, e) {
        return e = nm({
          mode: "visible",
          children: e
        }, t.mode, 0, null), e.return = t, t.child = e;
      }
      function Jf(t, e, n, r) {
        return r !== null && J1(r), tl(e, t.child, null, n), t = hb(e, e.pendingProps.children), t.flags |= 2, e.memoizedState = null, t;
      }
      function oI(t, e, n, r, i, o, s) {
        if (n)
          return e.flags & 256 ? (e.flags &= -257, r = Gg(Error(ee(422))), Jf(t, e, s, r)) : e.memoizedState !== null ? (e.child = t.child, e.flags |= 128, null) : (o = r.fallback, i = e.mode, r = nm({
            mode: "visible",
            children: r.children
          }, i, 0, null), o = Os(o, i, s, null), o.flags |= 2, r.return = e, o.return = e, r.sibling = o, e.child = r, (e.mode & 1) !== 0 && tl(e, t.child, null, s), e.child.memoizedState = Fv(s), e.memoizedState = zv, o);
        if ((e.mode & 1) === 0)
          return Jf(t, e, s, null);
        if (i.data === "$!") {
          if (r = i.nextSibling && i.nextSibling.dataset, r)
            var a = r.dgst;
          return r = a, o = Error(ee(419)), r = Gg(o, r, void 0), Jf(t, e, s, r);
        }
        if (a = (s & t.childLanes) !== 0, In || a) {
          if (r = jt, r !== null) {
            switch (s & -s) {
              case 4:
                i = 2;
                break;
              case 16:
                i = 8;
                break;
              case 64:
              case 128:
              case 256:
              case 512:
              case 1024:
              case 2048:
              case 4096:
              case 8192:
              case 16384:
              case 32768:
              case 65536:
              case 131072:
              case 262144:
              case 524288:
              case 1048576:
              case 2097152:
              case 4194304:
              case 8388608:
              case 16777216:
              case 33554432:
              case 67108864:
                i = 32;
                break;
              case 536870912:
                i = 268435456;
                break;
              default:
                i = 0;
            }
            i = (i & (r.suspendedLanes | s)) !== 0 ? 0 : i, i !== 0 && i !== o.retryLane && (o.retryLane = i, Xi(t, i), Fr(r, t, i, -1));
          }
          return yb(), r = Gg(Error(ee(421))), Jf(t, e, s, r);
        }
        return i.data === "$?" ? (e.flags |= 128, e.child = t.child, e = yI.bind(null, t), i._reactRetry = e, null) : (t = o.treeContext, Kn = zo(i.nextSibling), Gn = e, ft = true, Br = null, t !== null && (fr[hr++] = Hi, fr[hr++] = ji, fr[hr++] = Ns, Hi = t.id, ji = t.overflow, Ns = e), e = hb(e, r.children), e.flags |= 4096, e);
      }
      function sw(t, e, n) {
        t.lanes |= e;
        var r = t.alternate;
        r !== null && (r.lanes |= e), Dv(t.return, e, n);
      }
      function Yg(t, e, n, r, i) {
        var o = t.memoizedState;
        o === null ? t.memoizedState = {
          isBackwards: e,
          rendering: null,
          renderingStartTime: 0,
          last: r,
          tail: n,
          tailMode: i
        } : (o.isBackwards = e, o.rendering = null, o.renderingStartTime = 0, o.last = r, o.tail = n, o.tailMode = i);
      }
      function Y2(t, e, n) {
        var r = e.pendingProps, i = r.revealOrder, o = r.tail;
        if (bn(t, e, r.children, n), r = mt.current, (r & 2) !== 0)
          r = r & 1 | 2, e.flags |= 128;
        else {
          if (t !== null && (t.flags & 128) !== 0)
            e:
              for (t = e.child; t !== null; ) {
                if (t.tag === 13)
                  t.memoizedState !== null && sw(t, n, e);
                else if (t.tag === 19)
                  sw(t, n, e);
                else if (t.child !== null) {
                  t.child.return = t, t = t.child;
                  continue;
                }
                if (t === e)
                  break e;
                for (; t.sibling === null; ) {
                  if (t.return === null || t.return === e)
                    break e;
                  t = t.return;
                }
                t.sibling.return = t.return, t = t.sibling;
              }
          r &= 1;
        }
        if (nt(mt, r), (e.mode & 1) === 0)
          e.memoizedState = null;
        else
          switch (i) {
            case "forwards":
              for (n = e.child, i = null; n !== null; )
                t = n.alternate, t !== null && Kd(t) === null && (i = n), n = n.sibling;
              n = i, n === null ? (i = e.child, e.child = null) : (i = n.sibling, n.sibling = null), Yg(e, false, i, n, o);
              break;
            case "backwards":
              for (n = null, i = e.child, e.child = null; i !== null; ) {
                if (t = i.alternate, t !== null && Kd(t) === null) {
                  e.child = i;
                  break;
                }
                t = i.sibling, i.sibling = n, n = i, i = t;
              }
              Yg(e, true, n, null, o);
              break;
            case "together":
              Yg(e, false, null, null, void 0);
              break;
            default:
              e.memoizedState = null;
          }
        return e.child;
      }
      function Xh(t, e) {
        (e.mode & 1) === 0 && t !== null && (t.alternate = null, e.alternate = null, e.flags |= 2);
      }
      function Qi(t, e, n) {
        if (t !== null && (e.dependencies = t.dependencies), zs |= e.lanes, (n & e.childLanes) === 0)
          return null;
        if (t !== null && e.child !== t.child)
          throw Error(ee(153));
        if (e.child !== null) {
          for (t = e.child, n = jo(t, t.pendingProps), e.child = n, n.return = e; t.sibling !== null; )
            t = t.sibling, n = n.sibling = jo(t, t.pendingProps), n.return = e;
          n.sibling = null;
        }
        return e.child;
      }
      function sI(t, e, n) {
        switch (e.tag) {
          case 3:
            q2(e), el();
            break;
          case 5:
            w2(e);
            break;
          case 1:
            zn(e.type) && Fd(e);
            break;
          case 4:
            ib(e, e.stateNode.containerInfo);
            break;
          case 10:
            var r = e.type._context, i = e.memoizedProps.value;
            nt(jd, r._currentValue), r._currentValue = i;
            break;
          case 13:
            if (r = e.memoizedState, r !== null)
              return r.dehydrated !== null ? (nt(mt, mt.current & 1), e.flags |= 128, null) : (n & e.child.childLanes) !== 0 ? G2(t, e, n) : (nt(mt, mt.current & 1), t = Qi(t, e, n), t !== null ? t.sibling : null);
            nt(mt, mt.current & 1);
            break;
          case 19:
            if (r = (n & e.childLanes) !== 0, (t.flags & 128) !== 0) {
              if (r)
                return Y2(t, e, n);
              e.flags |= 128;
            }
            if (i = e.memoizedState, i !== null && (i.rendering = null, i.tail = null, i.lastEffect = null), nt(mt, mt.current), r)
              break;
            return null;
          case 22:
          case 23:
            return e.lanes = 0, U2(t, e, n);
        }
        return Qi(t, e, n);
      }
      var X2, Vv, Q2, J2;
      X2 = function(t, e) {
        for (var n = e.child; n !== null; ) {
          if (n.tag === 5 || n.tag === 6)
            t.appendChild(n.stateNode);
          else if (n.tag !== 4 && n.child !== null) {
            n.child.return = n, n = n.child;
            continue;
          }
          if (n === e)
            break;
          for (; n.sibling === null; ) {
            if (n.return === null || n.return === e)
              return;
            n = n.return;
          }
          n.sibling.return = n.return, n = n.sibling;
        }
      };
      Vv = function() {
      };
      Q2 = function(t, e, n, r) {
        var i = t.memoizedProps;
        if (i !== r) {
          t = e.stateNode, Cs(bi.current);
          var o = null;
          switch (n) {
            case "input":
              i = cv(t, i), r = cv(t, r), o = [];
              break;
            case "select":
              i = vt({}, i, {
                value: void 0
              }), r = vt({}, r, {
                value: void 0
              }), o = [];
              break;
            case "textarea":
              i = hv(t, i), r = hv(t, r), o = [];
              break;
            default:
              typeof i.onClick != "function" && typeof r.onClick == "function" && (t.onclick = $d);
          }
          pv(n, r);
          var s;
          n = null;
          for (c in i)
            if (!r.hasOwnProperty(c) && i.hasOwnProperty(c) && i[c] != null)
              if (c === "style") {
                var a = i[c];
                for (s in a)
                  a.hasOwnProperty(s) && (n || (n = {}), n[s] = "");
              } else
                c !== "dangerouslySetInnerHTML" && c !== "children" && c !== "suppressContentEditableWarning" && c !== "suppressHydrationWarning" && c !== "autoFocus" && (tu.hasOwnProperty(c) ? o || (o = []) : (o = o || []).push(c, null));
          for (c in r) {
            var l = r[c];
            if (a = i == null ? void 0 : i[c], r.hasOwnProperty(c) && l !== a && (l != null || a != null))
              if (c === "style")
                if (a) {
                  for (s in a)
                    !a.hasOwnProperty(s) || l && l.hasOwnProperty(s) || (n || (n = {}), n[s] = "");
                  for (s in l)
                    l.hasOwnProperty(s) && a[s] !== l[s] && (n || (n = {}), n[s] = l[s]);
                } else
                  n || (o || (o = []), o.push(c, n)), n = l;
              else
                c === "dangerouslySetInnerHTML" ? (l = l ? l.__html : void 0, a = a ? a.__html : void 0, l != null && a !== l && (o = o || []).push(c, l)) : c === "children" ? typeof l != "string" && typeof l != "number" || (o = o || []).push(c, "" + l) : c !== "suppressContentEditableWarning" && c !== "suppressHydrationWarning" && (tu.hasOwnProperty(c) ? (l != null && c === "onScroll" && ot("scroll", t), o || a === l || (o = [])) : (o = o || []).push(c, l));
          }
          n && (o = o || []).push("style", n);
          var c = o;
          (e.updateQueue = c) && (e.flags |= 4);
        }
      };
      J2 = function(t, e, n, r) {
        n !== r && (e.flags |= 4);
      };
      function Yl(t, e) {
        if (!ft)
          switch (t.tailMode) {
            case "hidden":
              e = t.tail;
              for (var n = null; e !== null; )
                e.alternate !== null && (n = e), e = e.sibling;
              n === null ? t.tail = null : n.sibling = null;
              break;
            case "collapsed":
              n = t.tail;
              for (var r = null; n !== null; )
                n.alternate !== null && (r = n), n = n.sibling;
              r === null ? e || t.tail === null ? t.tail = null : t.tail.sibling = null : r.sibling = null;
          }
      }
      function an(t) {
        var e = t.alternate !== null && t.alternate.child === t.child, n = 0, r = 0;
        if (e)
          for (var i = t.child; i !== null; )
            n |= i.lanes | i.childLanes, r |= i.subtreeFlags & 14680064, r |= i.flags & 14680064, i.return = t, i = i.sibling;
        else
          for (i = t.child; i !== null; )
            n |= i.lanes | i.childLanes, r |= i.subtreeFlags, r |= i.flags, i.return = t, i = i.sibling;
        return t.subtreeFlags |= r, t.childLanes = n, e;
      }
      function aI(t, e, n) {
        var r = e.pendingProps;
        switch (Q1(e), e.tag) {
          case 2:
          case 16:
          case 15:
          case 0:
          case 11:
          case 7:
          case 8:
          case 12:
          case 9:
          case 14:
            return an(e), null;
          case 1:
            return zn(e.type) && zd(), an(e), null;
          case 3:
            return r = e.stateNode, nl(), lt($n), lt(pn), sb(), r.pendingContext && (r.context = r.pendingContext, r.pendingContext = null), (t === null || t.child === null) && (Xf(e) ? e.flags |= 4 : t === null || t.memoizedState.isDehydrated && (e.flags & 256) === 0 || (e.flags |= 1024, Br !== null && (Yv(Br), Br = null))), Vv(t, e), an(e), null;
          case 5:
            ob(e);
            var i = Cs(du.current);
            if (n = e.type, t !== null && e.stateNode != null)
              Q2(t, e, n, r, i), t.ref !== e.ref && (e.flags |= 512, e.flags |= 2097152);
            else {
              if (!r) {
                if (e.stateNode === null)
                  throw Error(ee(166));
                return an(e), null;
              }
              if (t = Cs(bi.current), Xf(e)) {
                r = e.stateNode, n = e.type;
                var o = e.memoizedProps;
                switch (r[fi] = e, r[fu] = o, t = (e.mode & 1) !== 0, n) {
                  case "dialog":
                    ot("cancel", r), ot("close", r);
                    break;
                  case "iframe":
                  case "object":
                  case "embed":
                    ot("load", r);
                    break;
                  case "video":
                  case "audio":
                    for (i = 0; i < hc.length; i++)
                      ot(hc[i], r);
                    break;
                  case "source":
                    ot("error", r);
                    break;
                  case "img":
                  case "image":
                  case "link":
                    ot("error", r), ot("load", r);
                    break;
                  case "details":
                    ot("toggle", r);
                    break;
                  case "input":
                    mS(r, o), ot("invalid", r);
                    break;
                  case "select":
                    r._wrapperState = {
                      wasMultiple: !!o.multiple
                    }, ot("invalid", r);
                    break;
                  case "textarea":
                    vS(r, o), ot("invalid", r);
                }
                pv(n, o), i = null;
                for (var s in o)
                  if (o.hasOwnProperty(s)) {
                    var a = o[s];
                    s === "children" ? typeof a == "string" ? r.textContent !== a && (o.suppressHydrationWarning !== true && Yf(r.textContent, a, t), i = [
                      "children",
                      a
                    ]) : typeof a == "number" && r.textContent !== "" + a && (o.suppressHydrationWarning !== true && Yf(r.textContent, a, t), i = [
                      "children",
                      "" + a
                    ]) : tu.hasOwnProperty(s) && a != null && s === "onScroll" && ot("scroll", r);
                  }
                switch (n) {
                  case "input":
                    Vf(r), gS(r, o, true);
                    break;
                  case "textarea":
                    Vf(r), yS(r);
                    break;
                  case "select":
                  case "option":
                    break;
                  default:
                    typeof o.onClick == "function" && (r.onclick = $d);
                }
                r = i, e.updateQueue = r, r !== null && (e.flags |= 4);
              } else {
                s = i.nodeType === 9 ? i : i.ownerDocument, t === "http://www.w3.org/1999/xhtml" && (t = TM(n)), t === "http://www.w3.org/1999/xhtml" ? n === "script" ? (t = s.createElement("div"), t.innerHTML = "<script><\/script>", t = t.removeChild(t.firstChild)) : typeof r.is == "string" ? t = s.createElement(n, {
                  is: r.is
                }) : (t = s.createElement(n), n === "select" && (s = t, r.multiple ? s.multiple = true : r.size && (s.size = r.size))) : t = s.createElementNS(t, n), t[fi] = e, t[fu] = r, X2(t, e, false, false), e.stateNode = t;
                e: {
                  switch (s = mv(n, r), n) {
                    case "dialog":
                      ot("cancel", t), ot("close", t), i = r;
                      break;
                    case "iframe":
                    case "object":
                    case "embed":
                      ot("load", t), i = r;
                      break;
                    case "video":
                    case "audio":
                      for (i = 0; i < hc.length; i++)
                        ot(hc[i], t);
                      i = r;
                      break;
                    case "source":
                      ot("error", t), i = r;
                      break;
                    case "img":
                    case "image":
                    case "link":
                      ot("error", t), ot("load", t), i = r;
                      break;
                    case "details":
                      ot("toggle", t), i = r;
                      break;
                    case "input":
                      mS(t, r), i = cv(t, r), ot("invalid", t);
                      break;
                    case "option":
                      i = r;
                      break;
                    case "select":
                      t._wrapperState = {
                        wasMultiple: !!r.multiple
                      }, i = vt({}, r, {
                        value: void 0
                      }), ot("invalid", t);
                      break;
                    case "textarea":
                      vS(t, r), i = hv(t, r), ot("invalid", t);
                      break;
                    default:
                      i = r;
                  }
                  pv(n, i), a = i;
                  for (o in a)
                    if (a.hasOwnProperty(o)) {
                      var l = a[o];
                      o === "style" ? EM(t, l) : o === "dangerouslySetInnerHTML" ? (l = l ? l.__html : void 0, l != null && MM(t, l)) : o === "children" ? typeof l == "string" ? (n !== "textarea" || l !== "") && nu(t, l) : typeof l == "number" && nu(t, "" + l) : o !== "suppressContentEditableWarning" && o !== "suppressHydrationWarning" && o !== "autoFocus" && (tu.hasOwnProperty(o) ? l != null && o === "onScroll" && ot("scroll", t) : l != null && B1(t, o, l, s));
                    }
                  switch (n) {
                    case "input":
                      Vf(t), gS(t, r, false);
                      break;
                    case "textarea":
                      Vf(t), yS(t);
                      break;
                    case "option":
                      r.value != null && t.setAttribute("value", "" + Uo(r.value));
                      break;
                    case "select":
                      t.multiple = !!r.multiple, o = r.value, o != null ? _a(t, !!r.multiple, o, false) : r.defaultValue != null && _a(t, !!r.multiple, r.defaultValue, true);
                      break;
                    default:
                      typeof i.onClick == "function" && (t.onclick = $d);
                  }
                  switch (n) {
                    case "button":
                    case "input":
                    case "select":
                    case "textarea":
                      r = !!r.autoFocus;
                      break e;
                    case "img":
                      r = true;
                      break e;
                    default:
                      r = false;
                  }
                }
                r && (e.flags |= 4);
              }
              e.ref !== null && (e.flags |= 512, e.flags |= 2097152);
            }
            return an(e), null;
          case 6:
            if (t && e.stateNode != null)
              J2(t, e, t.memoizedProps, r);
            else {
              if (typeof r != "string" && e.stateNode === null)
                throw Error(ee(166));
              if (n = Cs(du.current), Cs(bi.current), Xf(e)) {
                if (r = e.stateNode, n = e.memoizedProps, r[fi] = e, (o = r.nodeValue !== n) && (t = Gn, t !== null))
                  switch (t.tag) {
                    case 3:
                      Yf(r.nodeValue, n, (t.mode & 1) !== 0);
                      break;
                    case 5:
                      t.memoizedProps.suppressHydrationWarning !== true && Yf(r.nodeValue, n, (t.mode & 1) !== 0);
                  }
                o && (e.flags |= 4);
              } else
                r = (n.nodeType === 9 ? n : n.ownerDocument).createTextNode(r), r[fi] = e, e.stateNode = r;
            }
            return an(e), null;
          case 13:
            if (lt(mt), r = e.memoizedState, t === null || t.memoizedState !== null && t.memoizedState.dehydrated !== null) {
              if (ft && Kn !== null && (e.mode & 1) !== 0 && (e.flags & 128) === 0)
                m2(), el(), e.flags |= 98560, o = false;
              else if (o = Xf(e), r !== null && r.dehydrated !== null) {
                if (t === null) {
                  if (!o)
                    throw Error(ee(318));
                  if (o = e.memoizedState, o = o !== null ? o.dehydrated : null, !o)
                    throw Error(ee(317));
                  o[fi] = e;
                } else
                  el(), (e.flags & 128) === 0 && (e.memoizedState = null), e.flags |= 4;
                an(e), o = false;
              } else
                Br !== null && (Yv(Br), Br = null), o = true;
              if (!o)
                return e.flags & 65536 ? e : null;
            }
            return (e.flags & 128) !== 0 ? (e.lanes = n, e) : (r = r !== null, r !== (t !== null && t.memoizedState !== null) && r && (e.child.flags |= 8192, (e.mode & 1) !== 0 && (t === null || (mt.current & 1) !== 0 ? It === 0 && (It = 3) : yb())), e.updateQueue !== null && (e.flags |= 4), an(e), null);
          case 4:
            return nl(), Vv(t, e), t === null && cu(e.stateNode.containerInfo), an(e), null;
          case 10:
            return tb(e.type._context), an(e), null;
          case 17:
            return zn(e.type) && zd(), an(e), null;
          case 19:
            if (lt(mt), o = e.memoizedState, o === null)
              return an(e), null;
            if (r = (e.flags & 128) !== 0, s = o.rendering, s === null)
              if (r)
                Yl(o, false);
              else {
                if (It !== 0 || t !== null && (t.flags & 128) !== 0)
                  for (t = e.child; t !== null; ) {
                    if (s = Kd(t), s !== null) {
                      for (e.flags |= 128, Yl(o, false), r = s.updateQueue, r !== null && (e.updateQueue = r, e.flags |= 4), e.subtreeFlags = 0, r = n, n = e.child; n !== null; )
                        o = n, t = r, o.flags &= 14680066, s = o.alternate, s === null ? (o.childLanes = 0, o.lanes = t, o.child = null, o.subtreeFlags = 0, o.memoizedProps = null, o.memoizedState = null, o.updateQueue = null, o.dependencies = null, o.stateNode = null) : (o.childLanes = s.childLanes, o.lanes = s.lanes, o.child = s.child, o.subtreeFlags = 0, o.deletions = null, o.memoizedProps = s.memoizedProps, o.memoizedState = s.memoizedState, o.updateQueue = s.updateQueue, o.type = s.type, t = s.dependencies, o.dependencies = t === null ? null : {
                          lanes: t.lanes,
                          firstContext: t.firstContext
                        }), n = n.sibling;
                      return nt(mt, mt.current & 1 | 2), e.child;
                    }
                    t = t.sibling;
                  }
                o.tail !== null && Mt() > il && (e.flags |= 128, r = true, Yl(o, false), e.lanes = 4194304);
              }
            else {
              if (!r)
                if (t = Kd(s), t !== null) {
                  if (e.flags |= 128, r = true, n = t.updateQueue, n !== null && (e.updateQueue = n, e.flags |= 4), Yl(o, true), o.tail === null && o.tailMode === "hidden" && !s.alternate && !ft)
                    return an(e), null;
                } else
                  2 * Mt() - o.renderingStartTime > il && n !== 1073741824 && (e.flags |= 128, r = true, Yl(o, false), e.lanes = 4194304);
              o.isBackwards ? (s.sibling = e.child, e.child = s) : (n = o.last, n !== null ? n.sibling = s : e.child = s, o.last = s);
            }
            return o.tail !== null ? (e = o.tail, o.rendering = e, o.tail = e.sibling, o.renderingStartTime = Mt(), e.sibling = null, n = mt.current, nt(mt, r ? n & 1 | 2 : n & 1), e) : (an(e), null);
          case 22:
          case 23:
            return vb(), r = e.memoizedState !== null, t !== null && t.memoizedState !== null !== r && (e.flags |= 8192), r && (e.mode & 1) !== 0 ? (Wn & 1073741824) !== 0 && (an(e), e.subtreeFlags & 6 && (e.flags |= 8192)) : an(e), null;
          case 24:
            return null;
          case 25:
            return null;
        }
        throw Error(ee(156, e.tag));
      }
      function lI(t, e) {
        switch (Q1(e), e.tag) {
          case 1:
            return zn(e.type) && zd(), t = e.flags, t & 65536 ? (e.flags = t & -65537 | 128, e) : null;
          case 3:
            return nl(), lt($n), lt(pn), sb(), t = e.flags, (t & 65536) !== 0 && (t & 128) === 0 ? (e.flags = t & -65537 | 128, e) : null;
          case 5:
            return ob(e), null;
          case 13:
            if (lt(mt), t = e.memoizedState, t !== null && t.dehydrated !== null) {
              if (e.alternate === null)
                throw Error(ee(340));
              el();
            }
            return t = e.flags, t & 65536 ? (e.flags = t & -65537 | 128, e) : null;
          case 19:
            return lt(mt), null;
          case 4:
            return nl(), null;
          case 10:
            return tb(e.type._context), null;
          case 22:
          case 23:
            return vb(), null;
          case 24:
            return null;
          default:
            return null;
        }
      }
      var Zf = false, fn = false, cI = typeof WeakSet == "function" ? WeakSet : Set, me = null;
      function wa(t, e) {
        var n = t.ref;
        if (n !== null)
          if (typeof n == "function")
            try {
              n(null);
            } catch (r) {
              St(t, e, r);
            }
          else
            n.current = null;
      }
      function Hv(t, e, n) {
        try {
          n();
        } catch (r) {
          St(t, e, r);
        }
      }
      var aw = false;
      function uI(t, e) {
        if (Tv = Id, t = n2(), Y1(t)) {
          if ("selectionStart" in t)
            var n = {
              start: t.selectionStart,
              end: t.selectionEnd
            };
          else
            e: {
              n = (n = t.ownerDocument) && n.defaultView || window;
              var r = n.getSelection && n.getSelection();
              if (r && r.rangeCount !== 0) {
                n = r.anchorNode;
                var i = r.anchorOffset, o = r.focusNode;
                r = r.focusOffset;
                try {
                  n.nodeType, o.nodeType;
                } catch {
                  n = null;
                  break e;
                }
                var s = 0, a = -1, l = -1, c = 0, u = 0, h = t, p = null;
                t:
                  for (; ; ) {
                    for (var v; h !== n || i !== 0 && h.nodeType !== 3 || (a = s + i), h !== o || r !== 0 && h.nodeType !== 3 || (l = s + r), h.nodeType === 3 && (s += h.nodeValue.length), (v = h.firstChild) !== null; )
                      p = h, h = v;
                    for (; ; ) {
                      if (h === t)
                        break t;
                      if (p === n && ++c === i && (a = s), p === o && ++u === r && (l = s), (v = h.nextSibling) !== null)
                        break;
                      h = p, p = h.parentNode;
                    }
                    h = v;
                  }
                n = a === -1 || l === -1 ? null : {
                  start: a,
                  end: l
                };
              } else
                n = null;
            }
          n = n || {
            start: 0,
            end: 0
          };
        } else
          n = null;
        for (Mv = {
          focusedElem: t,
          selectionRange: n
        }, Id = false, me = e; me !== null; )
          if (e = me, t = e.child, (e.subtreeFlags & 1028) !== 0 && t !== null)
            t.return = e, me = t;
          else
            for (; me !== null; ) {
              e = me;
              try {
                var y = e.alternate;
                if ((e.flags & 1024) !== 0)
                  switch (e.tag) {
                    case 0:
                    case 11:
                    case 15:
                      break;
                    case 1:
                      if (y !== null) {
                        var S = y.memoizedProps, C = y.memoizedState, w = e.stateNode, k = w.getSnapshotBeforeUpdate(e.elementType === e.type ? S : Dr(e.type, S), C);
                        w.__reactInternalSnapshotBeforeUpdate = k;
                      }
                      break;
                    case 3:
                      var T = e.stateNode.containerInfo;
                      T.nodeType === 1 ? T.textContent = "" : T.nodeType === 9 && T.documentElement && T.removeChild(T.documentElement);
                      break;
                    case 5:
                    case 6:
                    case 4:
                    case 17:
                      break;
                    default:
                      throw Error(ee(163));
                  }
              } catch (P) {
                St(e, e.return, P);
              }
              if (t = e.sibling, t !== null) {
                t.return = e.return, me = t;
                break;
              }
              me = e.return;
            }
        return y = aw, aw = false, y;
      }
      function Rc(t, e, n) {
        var r = e.updateQueue;
        if (r = r !== null ? r.lastEffect : null, r !== null) {
          var i = r = r.next;
          do {
            if ((i.tag & t) === t) {
              var o = i.destroy;
              i.destroy = void 0, o !== void 0 && Hv(e, n, o);
            }
            i = i.next;
          } while (i !== r);
        }
      }
      function em(t, e) {
        if (e = e.updateQueue, e = e !== null ? e.lastEffect : null, e !== null) {
          var n = e = e.next;
          do {
            if ((n.tag & t) === t) {
              var r = n.create;
              n.destroy = r();
            }
            n = n.next;
          } while (n !== e);
        }
      }
      function jv(t) {
        var e = t.ref;
        if (e !== null) {
          var n = t.stateNode;
          switch (t.tag) {
            case 5:
              t = n;
              break;
            default:
              t = n;
          }
          typeof e == "function" ? e(t) : e.current = t;
        }
      }
      function Z2(t) {
        var e = t.alternate;
        e !== null && (t.alternate = null, Z2(e)), t.child = null, t.deletions = null, t.sibling = null, t.tag === 5 && (e = t.stateNode, e !== null && (delete e[fi], delete e[fu], delete e[Pv], delete e[K_], delete e[q_])), t.stateNode = null, t.return = null, t.dependencies = null, t.memoizedProps = null, t.memoizedState = null, t.pendingProps = null, t.stateNode = null, t.updateQueue = null;
      }
      function eA(t) {
        return t.tag === 5 || t.tag === 3 || t.tag === 4;
      }
      function lw(t) {
        e:
          for (; ; ) {
            for (; t.sibling === null; ) {
              if (t.return === null || eA(t.return))
                return null;
              t = t.return;
            }
            for (t.sibling.return = t.return, t = t.sibling; t.tag !== 5 && t.tag !== 6 && t.tag !== 18; ) {
              if (t.flags & 2 || t.child === null || t.tag === 4)
                continue e;
              t.child.return = t, t = t.child;
            }
            if (!(t.flags & 2))
              return t.stateNode;
          }
      }
      function Wv(t, e, n) {
        var r = t.tag;
        if (r === 5 || r === 6)
          t = t.stateNode, e ? n.nodeType === 8 ? n.parentNode.insertBefore(t, e) : n.insertBefore(t, e) : (n.nodeType === 8 ? (e = n.parentNode, e.insertBefore(t, n)) : (e = n, e.appendChild(t)), n = n._reactRootContainer, n != null || e.onclick !== null || (e.onclick = $d));
        else if (r !== 4 && (t = t.child, t !== null))
          for (Wv(t, e, n), t = t.sibling; t !== null; )
            Wv(t, e, n), t = t.sibling;
      }
      function Uv(t, e, n) {
        var r = t.tag;
        if (r === 5 || r === 6)
          t = t.stateNode, e ? n.insertBefore(t, e) : n.appendChild(t);
        else if (r !== 4 && (t = t.child, t !== null))
          for (Uv(t, e, n), t = t.sibling; t !== null; )
            Uv(t, e, n), t = t.sibling;
      }
      var Gt = null, _r = false;
      function ho(t, e, n) {
        for (n = n.child; n !== null; )
          tA(t, e, n), n = n.sibling;
      }
      function tA(t, e, n) {
        if (yi && typeof yi.onCommitFiberUnmount == "function")
          try {
            yi.onCommitFiberUnmount(Kp, n);
          } catch {
          }
        switch (n.tag) {
          case 5:
            fn || wa(n, e);
          case 6:
            var r = Gt, i = _r;
            Gt = null, ho(t, e, n), Gt = r, _r = i, Gt !== null && (_r ? (t = Gt, n = n.stateNode, t.nodeType === 8 ? t.parentNode.removeChild(n) : t.removeChild(n)) : Gt.removeChild(n.stateNode));
            break;
          case 18:
            Gt !== null && (_r ? (t = Gt, n = n.stateNode, t.nodeType === 8 ? Hg(t.parentNode, n) : t.nodeType === 1 && Hg(t, n), su(t)) : Hg(Gt, n.stateNode));
            break;
          case 4:
            r = Gt, i = _r, Gt = n.stateNode.containerInfo, _r = true, ho(t, e, n), Gt = r, _r = i;
            break;
          case 0:
          case 11:
          case 14:
          case 15:
            if (!fn && (r = n.updateQueue, r !== null && (r = r.lastEffect, r !== null))) {
              i = r = r.next;
              do {
                var o = i, s = o.destroy;
                o = o.tag, s !== void 0 && ((o & 2) !== 0 || (o & 4) !== 0) && Hv(n, e, s), i = i.next;
              } while (i !== r);
            }
            ho(t, e, n);
            break;
          case 1:
            if (!fn && (wa(n, e), r = n.stateNode, typeof r.componentWillUnmount == "function"))
              try {
                r.props = n.memoizedProps, r.state = n.memoizedState, r.componentWillUnmount();
              } catch (a) {
                St(n, e, a);
              }
            ho(t, e, n);
            break;
          case 21:
            ho(t, e, n);
            break;
          case 22:
            n.mode & 1 ? (fn = (r = fn) || n.memoizedState !== null, ho(t, e, n), fn = r) : ho(t, e, n);
            break;
          default:
            ho(t, e, n);
        }
      }
      function cw(t) {
        var e = t.updateQueue;
        if (e !== null) {
          t.updateQueue = null;
          var n = t.stateNode;
          n === null && (n = t.stateNode = new cI()), e.forEach(function(r) {
            var i = bI.bind(null, t, r);
            n.has(r) || (n.add(r), r.then(i, i));
          });
        }
      }
      function Or(t, e) {
        var n = e.deletions;
        if (n !== null)
          for (var r = 0; r < n.length; r++) {
            var i = n[r];
            try {
              var o = t, s = e, a = s;
              e:
                for (; a !== null; ) {
                  switch (a.tag) {
                    case 5:
                      Gt = a.stateNode, _r = false;
                      break e;
                    case 3:
                      Gt = a.stateNode.containerInfo, _r = true;
                      break e;
                    case 4:
                      Gt = a.stateNode.containerInfo, _r = true;
                      break e;
                  }
                  a = a.return;
                }
              if (Gt === null)
                throw Error(ee(160));
              tA(o, s, i), Gt = null, _r = false;
              var l = i.alternate;
              l !== null && (l.return = null), i.return = null;
            } catch (c) {
              St(i, e, c);
            }
          }
        if (e.subtreeFlags & 12854)
          for (e = e.child; e !== null; )
            nA(e, t), e = e.sibling;
      }
      function nA(t, e) {
        var n = t.alternate, r = t.flags;
        switch (t.tag) {
          case 0:
          case 11:
          case 14:
          case 15:
            if (Or(e, t), Jr(t), r & 4) {
              try {
                Rc(3, t, t.return), em(3, t);
              } catch (S) {
                St(t, t.return, S);
              }
              try {
                Rc(5, t, t.return);
              } catch (S) {
                St(t, t.return, S);
              }
            }
            break;
          case 1:
            Or(e, t), Jr(t), r & 512 && n !== null && wa(n, n.return);
            break;
          case 5:
            if (Or(e, t), Jr(t), r & 512 && n !== null && wa(n, n.return), t.flags & 32) {
              var i = t.stateNode;
              try {
                nu(i, "");
              } catch (S) {
                St(t, t.return, S);
              }
            }
            if (r & 4 && (i = t.stateNode, i != null)) {
              var o = t.memoizedProps, s = n !== null ? n.memoizedProps : o, a = t.type, l = t.updateQueue;
              if (t.updateQueue = null, l !== null)
                try {
                  a === "input" && o.type === "radio" && o.name != null && kM(i, o), mv(a, s);
                  var c = mv(a, o);
                  for (s = 0; s < l.length; s += 2) {
                    var u = l[s], h = l[s + 1];
                    u === "style" ? EM(i, h) : u === "dangerouslySetInnerHTML" ? MM(i, h) : u === "children" ? nu(i, h) : B1(i, u, h, c);
                  }
                  switch (a) {
                    case "input":
                      uv(i, o);
                      break;
                    case "textarea":
                      CM(i, o);
                      break;
                    case "select":
                      var p = i._wrapperState.wasMultiple;
                      i._wrapperState.wasMultiple = !!o.multiple;
                      var v = o.value;
                      v != null ? _a(i, !!o.multiple, v, false) : p !== !!o.multiple && (o.defaultValue != null ? _a(i, !!o.multiple, o.defaultValue, true) : _a(i, !!o.multiple, o.multiple ? [] : "", false));
                  }
                  i[fu] = o;
                } catch (S) {
                  St(t, t.return, S);
                }
            }
            break;
          case 6:
            if (Or(e, t), Jr(t), r & 4) {
              if (t.stateNode === null)
                throw Error(ee(162));
              i = t.stateNode, o = t.memoizedProps;
              try {
                i.nodeValue = o;
              } catch (S) {
                St(t, t.return, S);
              }
            }
            break;
          case 3:
            if (Or(e, t), Jr(t), r & 4 && n !== null && n.memoizedState.isDehydrated)
              try {
                su(e.containerInfo);
              } catch (S) {
                St(t, t.return, S);
              }
            break;
          case 4:
            Or(e, t), Jr(t);
            break;
          case 13:
            Or(e, t), Jr(t), i = t.child, i.flags & 8192 && (o = i.memoizedState !== null, i.stateNode.isHidden = o, !o || i.alternate !== null && i.alternate.memoizedState !== null || (mb = Mt())), r & 4 && cw(t);
            break;
          case 22:
            if (u = n !== null && n.memoizedState !== null, t.mode & 1 ? (fn = (c = fn) || u, Or(e, t), fn = c) : Or(e, t), Jr(t), r & 8192) {
              if (c = t.memoizedState !== null, (t.stateNode.isHidden = c) && !u && (t.mode & 1) !== 0)
                for (me = t, u = t.child; u !== null; ) {
                  for (h = me = u; me !== null; ) {
                    switch (p = me, v = p.child, p.tag) {
                      case 0:
                      case 11:
                      case 14:
                      case 15:
                        Rc(4, p, p.return);
                        break;
                      case 1:
                        wa(p, p.return);
                        var y = p.stateNode;
                        if (typeof y.componentWillUnmount == "function") {
                          r = p, n = p.return;
                          try {
                            e = r, y.props = e.memoizedProps, y.state = e.memoizedState, y.componentWillUnmount();
                          } catch (S) {
                            St(r, n, S);
                          }
                        }
                        break;
                      case 5:
                        wa(p, p.return);
                        break;
                      case 22:
                        if (p.memoizedState !== null) {
                          fw(h);
                          continue;
                        }
                    }
                    v !== null ? (v.return = p, me = v) : fw(h);
                  }
                  u = u.sibling;
                }
              e:
                for (u = null, h = t; ; ) {
                  if (h.tag === 5) {
                    if (u === null) {
                      u = h;
                      try {
                        i = h.stateNode, c ? (o = i.style, typeof o.setProperty == "function" ? o.setProperty("display", "none", "important") : o.display = "none") : (a = h.stateNode, l = h.memoizedProps.style, s = l != null && l.hasOwnProperty("display") ? l.display : null, a.style.display = AM("display", s));
                      } catch (S) {
                        St(t, t.return, S);
                      }
                    }
                  } else if (h.tag === 6) {
                    if (u === null)
                      try {
                        h.stateNode.nodeValue = c ? "" : h.memoizedProps;
                      } catch (S) {
                        St(t, t.return, S);
                      }
                  } else if ((h.tag !== 22 && h.tag !== 23 || h.memoizedState === null || h === t) && h.child !== null) {
                    h.child.return = h, h = h.child;
                    continue;
                  }
                  if (h === t)
                    break e;
                  for (; h.sibling === null; ) {
                    if (h.return === null || h.return === t)
                      break e;
                    u === h && (u = null), h = h.return;
                  }
                  u === h && (u = null), h.sibling.return = h.return, h = h.sibling;
                }
            }
            break;
          case 19:
            Or(e, t), Jr(t), r & 4 && cw(t);
            break;
          case 21:
            break;
          default:
            Or(e, t), Jr(t);
        }
      }
      function Jr(t) {
        var e = t.flags;
        if (e & 2) {
          try {
            e: {
              for (var n = t.return; n !== null; ) {
                if (eA(n)) {
                  var r = n;
                  break e;
                }
                n = n.return;
              }
              throw Error(ee(160));
            }
            switch (r.tag) {
              case 5:
                var i = r.stateNode;
                r.flags & 32 && (nu(i, ""), r.flags &= -33);
                var o = lw(t);
                Uv(t, o, i);
                break;
              case 3:
              case 4:
                var s = r.stateNode.containerInfo, a = lw(t);
                Wv(t, a, s);
                break;
              default:
                throw Error(ee(161));
            }
          } catch (l) {
            St(t, t.return, l);
          }
          t.flags &= -3;
        }
        e & 4096 && (t.flags &= -4097);
      }
      function fI(t, e, n) {
        me = t, rA(t);
      }
      function rA(t, e, n) {
        for (var r = (t.mode & 1) !== 0; me !== null; ) {
          var i = me, o = i.child;
          if (i.tag === 22 && r) {
            var s = i.memoizedState !== null || Zf;
            if (!s) {
              var a = i.alternate, l = a !== null && a.memoizedState !== null || fn;
              a = Zf;
              var c = fn;
              if (Zf = s, (fn = l) && !c)
                for (me = i; me !== null; )
                  s = me, l = s.child, s.tag === 22 && s.memoizedState !== null ? hw(i) : l !== null ? (l.return = s, me = l) : hw(i);
              for (; o !== null; )
                me = o, rA(o), o = o.sibling;
              me = i, Zf = a, fn = c;
            }
            uw(t);
          } else
            (i.subtreeFlags & 8772) !== 0 && o !== null ? (o.return = i, me = o) : uw(t);
        }
      }
      function uw(t) {
        for (; me !== null; ) {
          var e = me;
          if ((e.flags & 8772) !== 0) {
            var n = e.alternate;
            try {
              if ((e.flags & 8772) !== 0)
                switch (e.tag) {
                  case 0:
                  case 11:
                  case 15:
                    fn || em(5, e);
                    break;
                  case 1:
                    var r = e.stateNode;
                    if (e.flags & 4 && !fn)
                      if (n === null)
                        r.componentDidMount();
                      else {
                        var i = e.elementType === e.type ? n.memoizedProps : Dr(e.type, n.memoizedProps);
                        r.componentDidUpdate(i, n.memoizedState, r.__reactInternalSnapshotBeforeUpdate);
                      }
                    var o = e.updateQueue;
                    o !== null && qS(e, o, r);
                    break;
                  case 3:
                    var s = e.updateQueue;
                    if (s !== null) {
                      if (n = null, e.child !== null)
                        switch (e.child.tag) {
                          case 5:
                            n = e.child.stateNode;
                            break;
                          case 1:
                            n = e.child.stateNode;
                        }
                      qS(e, s, n);
                    }
                    break;
                  case 5:
                    var a = e.stateNode;
                    if (n === null && e.flags & 4) {
                      n = a;
                      var l = e.memoizedProps;
                      switch (e.type) {
                        case "button":
                        case "input":
                        case "select":
                        case "textarea":
                          l.autoFocus && n.focus();
                          break;
                        case "img":
                          l.src && (n.src = l.src);
                      }
                    }
                    break;
                  case 6:
                    break;
                  case 4:
                    break;
                  case 12:
                    break;
                  case 13:
                    if (e.memoizedState === null) {
                      var c = e.alternate;
                      if (c !== null) {
                        var u = c.memoizedState;
                        if (u !== null) {
                          var h = u.dehydrated;
                          h !== null && su(h);
                        }
                      }
                    }
                    break;
                  case 19:
                  case 17:
                  case 21:
                  case 22:
                  case 23:
                  case 25:
                    break;
                  default:
                    throw Error(ee(163));
                }
              fn || e.flags & 512 && jv(e);
            } catch (p) {
              St(e, e.return, p);
            }
          }
          if (e === t) {
            me = null;
            break;
          }
          if (n = e.sibling, n !== null) {
            n.return = e.return, me = n;
            break;
          }
          me = e.return;
        }
      }
      function fw(t) {
        for (; me !== null; ) {
          var e = me;
          if (e === t) {
            me = null;
            break;
          }
          var n = e.sibling;
          if (n !== null) {
            n.return = e.return, me = n;
            break;
          }
          me = e.return;
        }
      }
      function hw(t) {
        for (; me !== null; ) {
          var e = me;
          try {
            switch (e.tag) {
              case 0:
              case 11:
              case 15:
                var n = e.return;
                try {
                  em(4, e);
                } catch (l) {
                  St(e, n, l);
                }
                break;
              case 1:
                var r = e.stateNode;
                if (typeof r.componentDidMount == "function") {
                  var i = e.return;
                  try {
                    r.componentDidMount();
                  } catch (l) {
                    St(e, i, l);
                  }
                }
                var o = e.return;
                try {
                  jv(e);
                } catch (l) {
                  St(e, o, l);
                }
                break;
              case 5:
                var s = e.return;
                try {
                  jv(e);
                } catch (l) {
                  St(e, s, l);
                }
            }
          } catch (l) {
            St(e, e.return, l);
          }
          if (e === t) {
            me = null;
            break;
          }
          var a = e.sibling;
          if (a !== null) {
            a.return = e.return, me = a;
            break;
          }
          me = e.return;
        }
      }
      var hI = Math.ceil, Yd = io.ReactCurrentDispatcher, db = io.ReactCurrentOwner, yr = io.ReactCurrentBatchConfig, je = 0, jt = null, Rt = null, tn = 0, Wn = 0, ka = es(0), It = 0, vu = null, zs = 0, tm = 0, pb = 0, Lc = null, On = null, mb = 0, il = 1 / 0, Ii = null, Xd = false, Kv = null, Vo = null, eh = false, Po = null, Qd = 0, Dc = 0, qv = null, Qh = -1, Jh = 0;
      function Sn() {
        return (je & 6) !== 0 ? Mt() : Qh !== -1 ? Qh : Qh = Mt();
      }
      function Ho(t) {
        return (t.mode & 1) === 0 ? 1 : (je & 2) !== 0 && tn !== 0 ? tn & -tn : Y_.transition !== null ? (Jh === 0 && (Jh = FM()), Jh) : (t = Ye, t !== 0 || (t = window.event, t = t === void 0 ? 16 : qM(t.type)), t);
      }
      function Fr(t, e, n, r) {
        if (50 < Dc)
          throw Dc = 0, qv = null, Error(ee(185));
        Uu(t, n, r), ((je & 2) === 0 || t !== jt) && (t === jt && ((je & 2) === 0 && (tm |= n), It === 4 && Co(t, tn)), Fn(t, r), n === 1 && je === 0 && (e.mode & 1) === 0 && (il = Mt() + 500, Qp && ts()));
      }
      function Fn(t, e) {
        var n = t.callbackNode;
        YD(t, e);
        var r = _d(t, t === jt ? tn : 0);
        if (r === 0)
          n !== null && SS(n), t.callbackNode = null, t.callbackPriority = 0;
        else if (e = r & -r, t.callbackPriority !== e) {
          if (n != null && SS(n), e === 1)
            t.tag === 0 ? G_(dw.bind(null, t)) : h2(dw.bind(null, t)), W_(function() {
              (je & 6) === 0 && ts();
            }), n = null;
          else {
            switch (VM(r)) {
              case 1:
                n = V1;
                break;
              case 4:
                n = $M;
                break;
              case 16:
                n = Dd;
                break;
              case 536870912:
                n = zM;
                break;
              default:
                n = Dd;
            }
            n = fA(n, iA.bind(null, t));
          }
          t.callbackPriority = e, t.callbackNode = n;
        }
      }
      function iA(t, e) {
        if (Qh = -1, Jh = 0, (je & 6) !== 0)
          throw Error(ee(327));
        var n = t.callbackNode;
        if (za() && t.callbackNode !== n)
          return null;
        var r = _d(t, t === jt ? tn : 0);
        if (r === 0)
          return null;
        if ((r & 30) !== 0 || (r & t.expiredLanes) !== 0 || e)
          e = Jd(t, r);
        else {
          e = r;
          var i = je;
          je |= 2;
          var o = sA();
          (jt !== t || tn !== e) && (Ii = null, il = Mt() + 500, Ps(t, e));
          do
            try {
              mI();
              break;
            } catch (a) {
              oA(t, a);
            }
          while (1);
          eb(), Yd.current = o, je = i, Rt !== null ? e = 0 : (jt = null, tn = 0, e = It);
        }
        if (e !== 0) {
          if (e === 2 && (i = xv(t), i !== 0 && (r = i, e = Gv(t, i))), e === 1)
            throw n = vu, Ps(t, 0), Co(t, r), Fn(t, Mt()), n;
          if (e === 6)
            Co(t, r);
          else {
            if (i = t.current.alternate, (r & 30) === 0 && !dI(i) && (e = Jd(t, r), e === 2 && (o = xv(t), o !== 0 && (r = o, e = Gv(t, o))), e === 1))
              throw n = vu, Ps(t, 0), Co(t, r), Fn(t, Mt()), n;
            switch (t.finishedWork = i, t.finishedLanes = r, e) {
              case 0:
              case 1:
                throw Error(ee(345));
              case 2:
                vs(t, On, Ii);
                break;
              case 3:
                if (Co(t, r), (r & 130023424) === r && (e = mb + 500 - Mt(), 10 < e)) {
                  if (_d(t, 0) !== 0)
                    break;
                  if (i = t.suspendedLanes, (i & r) !== r) {
                    Sn(), t.pingedLanes |= t.suspendedLanes & i;
                    break;
                  }
                  t.timeoutHandle = Ev(vs.bind(null, t, On, Ii), e);
                  break;
                }
                vs(t, On, Ii);
                break;
              case 4:
                if (Co(t, r), (r & 4194240) === r)
                  break;
                for (e = t.eventTimes, i = -1; 0 < r; ) {
                  var s = 31 - zr(r);
                  o = 1 << s, s = e[s], s > i && (i = s), r &= ~o;
                }
                if (r = i, r = Mt() - r, r = (120 > r ? 120 : 480 > r ? 480 : 1080 > r ? 1080 : 1920 > r ? 1920 : 3e3 > r ? 3e3 : 4320 > r ? 4320 : 1960 * hI(r / 1960)) - r, 10 < r) {
                  t.timeoutHandle = Ev(vs.bind(null, t, On, Ii), r);
                  break;
                }
                vs(t, On, Ii);
                break;
              case 5:
                vs(t, On, Ii);
                break;
              default:
                throw Error(ee(329));
            }
          }
        }
        return Fn(t, Mt()), t.callbackNode === n ? iA.bind(null, t) : null;
      }
      function Gv(t, e) {
        var n = Lc;
        return t.current.memoizedState.isDehydrated && (Ps(t, e).flags |= 256), t = Jd(t, e), t !== 2 && (e = On, On = n, e !== null && Yv(e)), t;
      }
      function Yv(t) {
        On === null ? On = t : On.push.apply(On, t);
      }
      function dI(t) {
        for (var e = t; ; ) {
          if (e.flags & 16384) {
            var n = e.updateQueue;
            if (n !== null && (n = n.stores, n !== null))
              for (var r = 0; r < n.length; r++) {
                var i = n[r], o = i.getSnapshot;
                i = i.value;
                try {
                  if (!Wr(o(), i))
                    return false;
                } catch {
                  return false;
                }
              }
          }
          if (n = e.child, e.subtreeFlags & 16384 && n !== null)
            n.return = e, e = n;
          else {
            if (e === t)
              break;
            for (; e.sibling === null; ) {
              if (e.return === null || e.return === t)
                return true;
              e = e.return;
            }
            e.sibling.return = e.return, e = e.sibling;
          }
        }
        return true;
      }
      function Co(t, e) {
        for (e &= ~pb, e &= ~tm, t.suspendedLanes |= e, t.pingedLanes &= ~e, t = t.expirationTimes; 0 < e; ) {
          var n = 31 - zr(e), r = 1 << n;
          t[n] = -1, e &= ~r;
        }
      }
      function dw(t) {
        if ((je & 6) !== 0)
          throw Error(ee(327));
        za();
        var e = _d(t, 0);
        if ((e & 1) === 0)
          return Fn(t, Mt()), null;
        var n = Jd(t, e);
        if (t.tag !== 0 && n === 2) {
          var r = xv(t);
          r !== 0 && (e = r, n = Gv(t, r));
        }
        if (n === 1)
          throw n = vu, Ps(t, 0), Co(t, e), Fn(t, Mt()), n;
        if (n === 6)
          throw Error(ee(345));
        return t.finishedWork = t.current.alternate, t.finishedLanes = e, vs(t, On, Ii), Fn(t, Mt()), null;
      }
      function gb(t, e) {
        var n = je;
        je |= 1;
        try {
          return t(e);
        } finally {
          je = n, je === 0 && (il = Mt() + 500, Qp && ts());
        }
      }
      function Fs(t) {
        Po !== null && Po.tag === 0 && (je & 6) === 0 && za();
        var e = je;
        je |= 1;
        var n = yr.transition, r = Ye;
        try {
          if (yr.transition = null, Ye = 1, t)
            return t();
        } finally {
          Ye = r, yr.transition = n, je = e, (je & 6) === 0 && ts();
        }
      }
      function vb() {
        Wn = ka.current, lt(ka);
      }
      function Ps(t, e) {
        t.finishedWork = null, t.finishedLanes = 0;
        var n = t.timeoutHandle;
        if (n !== -1 && (t.timeoutHandle = -1, j_(n)), Rt !== null)
          for (n = Rt.return; n !== null; ) {
            var r = n;
            switch (Q1(r), r.tag) {
              case 1:
                r = r.type.childContextTypes, r != null && zd();
                break;
              case 3:
                nl(), lt($n), lt(pn), sb();
                break;
              case 5:
                ob(r);
                break;
              case 4:
                nl();
                break;
              case 13:
                lt(mt);
                break;
              case 19:
                lt(mt);
                break;
              case 10:
                tb(r.type._context);
                break;
              case 22:
              case 23:
                vb();
            }
            n = n.return;
          }
        if (jt = t, Rt = t = jo(t.current, null), tn = Wn = e, It = 0, vu = null, pb = tm = zs = 0, On = Lc = null, ks !== null) {
          for (e = 0; e < ks.length; e++)
            if (n = ks[e], r = n.interleaved, r !== null) {
              n.interleaved = null;
              var i = r.next, o = n.pending;
              if (o !== null) {
                var s = o.next;
                o.next = i, r.next = s;
              }
              n.pending = r;
            }
          ks = null;
        }
        return t;
      }
      function oA(t, e) {
        do {
          var n = Rt;
          try {
            if (eb(), Gh.current = Gd, qd) {
              for (var r = gt.memoizedState; r !== null; ) {
                var i = r.queue;
                i !== null && (i.pending = null), r = r.next;
              }
              qd = false;
            }
            if ($s = 0, Vt = Dt = gt = null, Oc = false, pu = 0, db.current = null, n === null || n.return === null) {
              It = 1, vu = e, Rt = null;
              break;
            }
            e: {
              var o = t, s = n.return, a = n, l = e;
              if (e = tn, a.flags |= 32768, l !== null && typeof l == "object" && typeof l.then == "function") {
                var c = l, u = a, h = u.tag;
                if ((u.mode & 1) === 0 && (h === 0 || h === 11 || h === 15)) {
                  var p = u.alternate;
                  p ? (u.updateQueue = p.updateQueue, u.memoizedState = p.memoizedState, u.lanes = p.lanes) : (u.updateQueue = null, u.memoizedState = null);
                }
                var v = ew(s);
                if (v !== null) {
                  v.flags &= -257, tw(v, s, a, o, e), v.mode & 1 && ZS(o, c, e), e = v, l = c;
                  var y = e.updateQueue;
                  if (y === null) {
                    var S = /* @__PURE__ */ new Set();
                    S.add(l), e.updateQueue = S;
                  } else
                    y.add(l);
                  break e;
                } else {
                  if ((e & 1) === 0) {
                    ZS(o, c, e), yb();
                    break e;
                  }
                  l = Error(ee(426));
                }
              } else if (ft && a.mode & 1) {
                var C = ew(s);
                if (C !== null) {
                  (C.flags & 65536) === 0 && (C.flags |= 256), tw(C, s, a, o, e), J1(rl(l, a));
                  break e;
                }
              }
              o = l = rl(l, a), It !== 4 && (It = 2), Lc === null ? Lc = [
                o
              ] : Lc.push(o), o = s;
              do {
                switch (o.tag) {
                  case 3:
                    o.flags |= 65536, e &= -e, o.lanes |= e;
                    var w = H2(o, l, e);
                    KS(o, w);
                    break e;
                  case 1:
                    a = l;
                    var k = o.type, T = o.stateNode;
                    if ((o.flags & 128) === 0 && (typeof k.getDerivedStateFromError == "function" || T !== null && typeof T.componentDidCatch == "function" && (Vo === null || !Vo.has(T)))) {
                      o.flags |= 65536, e &= -e, o.lanes |= e;
                      var P = j2(o, a, e);
                      KS(o, P);
                      break e;
                    }
                }
                o = o.return;
              } while (o !== null);
            }
            lA(n);
          } catch (R) {
            e = R, Rt === n && n !== null && (Rt = n = n.return);
            continue;
          }
          break;
        } while (1);
      }
      function sA() {
        var t = Yd.current;
        return Yd.current = Gd, t === null ? Gd : t;
      }
      function yb() {
        (It === 0 || It === 3 || It === 2) && (It = 4), jt === null || (zs & 268435455) === 0 && (tm & 268435455) === 0 || Co(jt, tn);
      }
      function Jd(t, e) {
        var n = je;
        je |= 2;
        var r = sA();
        (jt !== t || tn !== e) && (Ii = null, Ps(t, e));
        do
          try {
            pI();
            break;
          } catch (i) {
            oA(t, i);
          }
        while (1);
        if (eb(), je = n, Yd.current = r, Rt !== null)
          throw Error(ee(261));
        return jt = null, tn = 0, It;
      }
      function pI() {
        for (; Rt !== null; )
          aA(Rt);
      }
      function mI() {
        for (; Rt !== null && !FD(); )
          aA(Rt);
      }
      function aA(t) {
        var e = uA(t.alternate, t, Wn);
        t.memoizedProps = t.pendingProps, e === null ? lA(t) : Rt = e, db.current = null;
      }
      function lA(t) {
        var e = t;
        do {
          var n = e.alternate;
          if (t = e.return, (e.flags & 32768) === 0) {
            if (n = aI(n, e, Wn), n !== null) {
              Rt = n;
              return;
            }
          } else {
            if (n = lI(n, e), n !== null) {
              n.flags &= 32767, Rt = n;
              return;
            }
            if (t !== null)
              t.flags |= 32768, t.subtreeFlags = 0, t.deletions = null;
            else {
              It = 6, Rt = null;
              return;
            }
          }
          if (e = e.sibling, e !== null) {
            Rt = e;
            return;
          }
          Rt = e = t;
        } while (e !== null);
        It === 0 && (It = 5);
      }
      function vs(t, e, n) {
        var r = Ye, i = yr.transition;
        try {
          yr.transition = null, Ye = 1, gI(t, e, n, r);
        } finally {
          yr.transition = i, Ye = r;
        }
        return null;
      }
      function gI(t, e, n, r) {
        do
          za();
        while (Po !== null);
        if ((je & 6) !== 0)
          throw Error(ee(327));
        n = t.finishedWork;
        var i = t.finishedLanes;
        if (n === null)
          return null;
        if (t.finishedWork = null, t.finishedLanes = 0, n === t.current)
          throw Error(ee(177));
        t.callbackNode = null, t.callbackPriority = 0;
        var o = n.lanes | n.childLanes;
        if (XD(t, o), t === jt && (Rt = jt = null, tn = 0), (n.subtreeFlags & 2064) === 0 && (n.flags & 2064) === 0 || eh || (eh = true, fA(Dd, function() {
          return za(), null;
        })), o = (n.flags & 15990) !== 0, (n.subtreeFlags & 15990) !== 0 || o) {
          o = yr.transition, yr.transition = null;
          var s = Ye;
          Ye = 1;
          var a = je;
          je |= 4, db.current = null, uI(t, n), nA(n, t), B_(Mv), Id = !!Tv, Mv = Tv = null, t.current = n, fI(n), VD(), je = a, Ye = s, yr.transition = o;
        } else
          t.current = n;
        if (eh && (eh = false, Po = t, Qd = i), o = t.pendingLanes, o === 0 && (Vo = null), WD(n.stateNode), Fn(t, Mt()), e !== null)
          for (r = t.onRecoverableError, n = 0; n < e.length; n++)
            i = e[n], r(i.value, {
              componentStack: i.stack,
              digest: i.digest
            });
        if (Xd)
          throw Xd = false, t = Kv, Kv = null, t;
        return (Qd & 1) !== 0 && t.tag !== 0 && za(), o = t.pendingLanes, (o & 1) !== 0 ? t === qv ? Dc++ : (Dc = 0, qv = t) : Dc = 0, ts(), null;
      }
      function za() {
        if (Po !== null) {
          var t = VM(Qd), e = yr.transition, n = Ye;
          try {
            if (yr.transition = null, Ye = 16 > t ? 16 : t, Po === null)
              var r = false;
            else {
              if (t = Po, Po = null, Qd = 0, (je & 6) !== 0)
                throw Error(ee(331));
              var i = je;
              for (je |= 4, me = t.current; me !== null; ) {
                var o = me, s = o.child;
                if ((me.flags & 16) !== 0) {
                  var a = o.deletions;
                  if (a !== null) {
                    for (var l = 0; l < a.length; l++) {
                      var c = a[l];
                      for (me = c; me !== null; ) {
                        var u = me;
                        switch (u.tag) {
                          case 0:
                          case 11:
                          case 15:
                            Rc(8, u, o);
                        }
                        var h = u.child;
                        if (h !== null)
                          h.return = u, me = h;
                        else
                          for (; me !== null; ) {
                            u = me;
                            var p = u.sibling, v = u.return;
                            if (Z2(u), u === c) {
                              me = null;
                              break;
                            }
                            if (p !== null) {
                              p.return = v, me = p;
                              break;
                            }
                            me = v;
                          }
                      }
                    }
                    var y = o.alternate;
                    if (y !== null) {
                      var S = y.child;
                      if (S !== null) {
                        y.child = null;
                        do {
                          var C = S.sibling;
                          S.sibling = null, S = C;
                        } while (S !== null);
                      }
                    }
                    me = o;
                  }
                }
                if ((o.subtreeFlags & 2064) !== 0 && s !== null)
                  s.return = o, me = s;
                else
                  e:
                    for (; me !== null; ) {
                      if (o = me, (o.flags & 2048) !== 0)
                        switch (o.tag) {
                          case 0:
                          case 11:
                          case 15:
                            Rc(9, o, o.return);
                        }
                      var w = o.sibling;
                      if (w !== null) {
                        w.return = o.return, me = w;
                        break e;
                      }
                      me = o.return;
                    }
              }
              var k = t.current;
              for (me = k; me !== null; ) {
                s = me;
                var T = s.child;
                if ((s.subtreeFlags & 2064) !== 0 && T !== null)
                  T.return = s, me = T;
                else
                  e:
                    for (s = k; me !== null; ) {
                      if (a = me, (a.flags & 2048) !== 0)
                        try {
                          switch (a.tag) {
                            case 0:
                            case 11:
                            case 15:
                              em(9, a);
                          }
                        } catch (R) {
                          St(a, a.return, R);
                        }
                      if (a === s) {
                        me = null;
                        break e;
                      }
                      var P = a.sibling;
                      if (P !== null) {
                        P.return = a.return, me = P;
                        break e;
                      }
                      me = a.return;
                    }
              }
              if (je = i, ts(), yi && typeof yi.onPostCommitFiberRoot == "function")
                try {
                  yi.onPostCommitFiberRoot(Kp, t);
                } catch {
                }
              r = true;
            }
            return r;
          } finally {
            Ye = n, yr.transition = e;
          }
        }
        return false;
      }
      function pw(t, e, n) {
        e = rl(n, e), e = H2(t, e, 1), t = Fo(t, e, 1), e = Sn(), t !== null && (Uu(t, 1, e), Fn(t, e));
      }
      function St(t, e, n) {
        if (t.tag === 3)
          pw(t, t, n);
        else
          for (; e !== null; ) {
            if (e.tag === 3) {
              pw(e, t, n);
              break;
            } else if (e.tag === 1) {
              var r = e.stateNode;
              if (typeof e.type.getDerivedStateFromError == "function" || typeof r.componentDidCatch == "function" && (Vo === null || !Vo.has(r))) {
                t = rl(n, t), t = j2(e, t, 1), e = Fo(e, t, 1), t = Sn(), e !== null && (Uu(e, 1, t), Fn(e, t));
                break;
              }
            }
            e = e.return;
          }
      }
      function vI(t, e, n) {
        var r = t.pingCache;
        r !== null && r.delete(e), e = Sn(), t.pingedLanes |= t.suspendedLanes & n, jt === t && (tn & n) === n && (It === 4 || It === 3 && (tn & 130023424) === tn && 500 > Mt() - mb ? Ps(t, 0) : pb |= n), Fn(t, e);
      }
      function cA(t, e) {
        e === 0 && ((t.mode & 1) === 0 ? e = 1 : (e = Wf, Wf <<= 1, (Wf & 130023424) === 0 && (Wf = 4194304)));
        var n = Sn();
        t = Xi(t, e), t !== null && (Uu(t, e, n), Fn(t, n));
      }
      function yI(t) {
        var e = t.memoizedState, n = 0;
        e !== null && (n = e.retryLane), cA(t, n);
      }
      function bI(t, e) {
        var n = 0;
        switch (t.tag) {
          case 13:
            var r = t.stateNode, i = t.memoizedState;
            i !== null && (n = i.retryLane);
            break;
          case 19:
            r = t.stateNode;
            break;
          default:
            throw Error(ee(314));
        }
        r !== null && r.delete(e), cA(t, n);
      }
      var uA;
      uA = function(t, e, n) {
        if (t !== null)
          if (t.memoizedProps !== e.pendingProps || $n.current)
            In = true;
          else {
            if ((t.lanes & n) === 0 && (e.flags & 128) === 0)
              return In = false, sI(t, e, n);
            In = (t.flags & 131072) !== 0;
          }
        else
          In = false, ft && (e.flags & 1048576) !== 0 && d2(e, Hd, e.index);
        switch (e.lanes = 0, e.tag) {
          case 2:
            var r = e.type;
            Xh(t, e), t = e.pendingProps;
            var i = Za(e, pn.current);
            $a(e, n), i = lb(null, e, r, t, i, n);
            var o = cb();
            return e.flags |= 1, typeof i == "object" && i !== null && typeof i.render == "function" && i.$$typeof === void 0 ? (e.tag = 1, e.memoizedState = null, e.updateQueue = null, zn(r) ? (o = true, Fd(e)) : o = false, e.memoizedState = i.state !== null && i.state !== void 0 ? i.state : null, rb(e), i.updater = Jp, e.stateNode = i, i._reactInternals = e, Iv(e, r, t, n), e = $v(null, e, r, true, o, n)) : (e.tag = 0, ft && o && X1(e), bn(null, e, i, n), e = e.child), e;
          case 16:
            r = e.elementType;
            e: {
              switch (Xh(t, e), t = e.pendingProps, i = r._init, r = i(r._payload), e.type = r, i = e.tag = SI(r), t = Dr(r, t), i) {
                case 0:
                  e = Nv(null, e, r, t, n);
                  break e;
                case 1:
                  e = iw(null, e, r, t, n);
                  break e;
                case 11:
                  e = nw(null, e, r, t, n);
                  break e;
                case 14:
                  e = rw(null, e, r, Dr(r.type, t), n);
                  break e;
              }
              throw Error(ee(306, r, ""));
            }
            return e;
          case 0:
            return r = e.type, i = e.pendingProps, i = e.elementType === r ? i : Dr(r, i), Nv(t, e, r, i, n);
          case 1:
            return r = e.type, i = e.pendingProps, i = e.elementType === r ? i : Dr(r, i), iw(t, e, r, i, n);
          case 3:
            e: {
              if (q2(e), t === null)
                throw Error(ee(387));
              r = e.pendingProps, o = e.memoizedState, i = o.element, v2(t, e), Ud(e, r, null, n);
              var s = e.memoizedState;
              if (r = s.element, o.isDehydrated)
                if (o = {
                  element: r,
                  isDehydrated: false,
                  cache: s.cache,
                  pendingSuspenseBoundaries: s.pendingSuspenseBoundaries,
                  transitions: s.transitions
                }, e.updateQueue.baseState = o, e.memoizedState = o, e.flags & 256) {
                  i = rl(Error(ee(423)), e), e = ow(t, e, r, n, i);
                  break e;
                } else if (r !== i) {
                  i = rl(Error(ee(424)), e), e = ow(t, e, r, n, i);
                  break e;
                } else
                  for (Kn = zo(e.stateNode.containerInfo.firstChild), Gn = e, ft = true, Br = null, n = S2(e, null, r, n), e.child = n; n; )
                    n.flags = n.flags & -3 | 4096, n = n.sibling;
              else {
                if (el(), r === i) {
                  e = Qi(t, e, n);
                  break e;
                }
                bn(t, e, r, n);
              }
              e = e.child;
            }
            return e;
          case 5:
            return w2(e), t === null && Lv(e), r = e.type, i = e.pendingProps, o = t !== null ? t.memoizedProps : null, s = i.children, Av(r, i) ? s = null : o !== null && Av(r, o) && (e.flags |= 32), K2(t, e), bn(t, e, s, n), e.child;
          case 6:
            return t === null && Lv(e), null;
          case 13:
            return G2(t, e, n);
          case 4:
            return ib(e, e.stateNode.containerInfo), r = e.pendingProps, t === null ? e.child = tl(e, null, r, n) : bn(t, e, r, n), e.child;
          case 11:
            return r = e.type, i = e.pendingProps, i = e.elementType === r ? i : Dr(r, i), nw(t, e, r, i, n);
          case 7:
            return bn(t, e, e.pendingProps, n), e.child;
          case 8:
            return bn(t, e, e.pendingProps.children, n), e.child;
          case 12:
            return bn(t, e, e.pendingProps.children, n), e.child;
          case 10:
            e: {
              if (r = e.type._context, i = e.pendingProps, o = e.memoizedProps, s = i.value, nt(jd, r._currentValue), r._currentValue = s, o !== null)
                if (Wr(o.value, s)) {
                  if (o.children === i.children && !$n.current) {
                    e = Qi(t, e, n);
                    break e;
                  }
                } else
                  for (o = e.child, o !== null && (o.return = e); o !== null; ) {
                    var a = o.dependencies;
                    if (a !== null) {
                      s = o.child;
                      for (var l = a.firstContext; l !== null; ) {
                        if (l.context === r) {
                          if (o.tag === 1) {
                            l = Ui(-1, n & -n), l.tag = 2;
                            var c = o.updateQueue;
                            if (c !== null) {
                              c = c.shared;
                              var u = c.pending;
                              u === null ? l.next = l : (l.next = u.next, u.next = l), c.pending = l;
                            }
                          }
                          o.lanes |= n, l = o.alternate, l !== null && (l.lanes |= n), Dv(o.return, n, e), a.lanes |= n;
                          break;
                        }
                        l = l.next;
                      }
                    } else if (o.tag === 10)
                      s = o.type === e.type ? null : o.child;
                    else if (o.tag === 18) {
                      if (s = o.return, s === null)
                        throw Error(ee(341));
                      s.lanes |= n, a = s.alternate, a !== null && (a.lanes |= n), Dv(s, n, e), s = o.sibling;
                    } else
                      s = o.child;
                    if (s !== null)
                      s.return = o;
                    else
                      for (s = o; s !== null; ) {
                        if (s === e) {
                          s = null;
                          break;
                        }
                        if (o = s.sibling, o !== null) {
                          o.return = s.return, s = o;
                          break;
                        }
                        s = s.return;
                      }
                    o = s;
                  }
              bn(t, e, i.children, n), e = e.child;
            }
            return e;
          case 9:
            return i = e.type, r = e.pendingProps.children, $a(e, n), i = Sr(i), r = r(i), e.flags |= 1, bn(t, e, r, n), e.child;
          case 14:
            return r = e.type, i = Dr(r, e.pendingProps), i = Dr(r.type, i), rw(t, e, r, i, n);
          case 15:
            return W2(t, e, e.type, e.pendingProps, n);
          case 17:
            return r = e.type, i = e.pendingProps, i = e.elementType === r ? i : Dr(r, i), Xh(t, e), e.tag = 1, zn(r) ? (t = true, Fd(e)) : t = false, $a(e, n), b2(e, r, i), Iv(e, r, i, n), $v(null, e, r, true, t, n);
          case 19:
            return Y2(t, e, n);
          case 22:
            return U2(t, e, n);
        }
        throw Error(ee(156, e.tag));
      };
      function fA(t, e) {
        return NM(t, e);
      }
      function xI(t, e, n, r) {
        this.tag = t, this.key = n, this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null, this.index = 0, this.ref = null, this.pendingProps = e, this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null, this.mode = r, this.subtreeFlags = this.flags = 0, this.deletions = null, this.childLanes = this.lanes = 0, this.alternate = null;
      }
      function pr(t, e, n, r) {
        return new xI(t, e, n, r);
      }
      function bb(t) {
        return t = t.prototype, !(!t || !t.isReactComponent);
      }
      function SI(t) {
        if (typeof t == "function")
          return bb(t) ? 1 : 0;
        if (t != null) {
          if (t = t.$$typeof, t === $1)
            return 11;
          if (t === z1)
            return 14;
        }
        return 2;
      }
      function jo(t, e) {
        var n = t.alternate;
        return n === null ? (n = pr(t.tag, e, t.key, t.mode), n.elementType = t.elementType, n.type = t.type, n.stateNode = t.stateNode, n.alternate = t, t.alternate = n) : (n.pendingProps = e, n.type = t.type, n.flags = 0, n.subtreeFlags = 0, n.deletions = null), n.flags = t.flags & 14680064, n.childLanes = t.childLanes, n.lanes = t.lanes, n.child = t.child, n.memoizedProps = t.memoizedProps, n.memoizedState = t.memoizedState, n.updateQueue = t.updateQueue, e = t.dependencies, n.dependencies = e === null ? null : {
          lanes: e.lanes,
          firstContext: e.firstContext
        }, n.sibling = t.sibling, n.index = t.index, n.ref = t.ref, n;
      }
      function Zh(t, e, n, r, i, o) {
        var s = 2;
        if (r = t, typeof t == "function")
          bb(t) && (s = 1);
        else if (typeof t == "string")
          s = 5;
        else
          e:
            switch (t) {
              case da:
                return Os(n.children, i, o, e);
              case N1:
                s = 8, i |= 8;
                break;
              case ov:
                return t = pr(12, n, e, i | 2), t.elementType = ov, t.lanes = o, t;
              case sv:
                return t = pr(13, n, e, i), t.elementType = sv, t.lanes = o, t;
              case av:
                return t = pr(19, n, e, i), t.elementType = av, t.lanes = o, t;
              case xM:
                return nm(n, i, o, e);
              default:
                if (typeof t == "object" && t !== null)
                  switch (t.$$typeof) {
                    case yM:
                      s = 10;
                      break e;
                    case bM:
                      s = 9;
                      break e;
                    case $1:
                      s = 11;
                      break e;
                    case z1:
                      s = 14;
                      break e;
                    case yo:
                      s = 16, r = null;
                      break e;
                  }
                throw Error(ee(130, t == null ? t : typeof t, ""));
            }
        return e = pr(s, n, e, i), e.elementType = t, e.type = r, e.lanes = o, e;
      }
      function Os(t, e, n, r) {
        return t = pr(7, t, r, e), t.lanes = n, t;
      }
      function nm(t, e, n, r) {
        return t = pr(22, t, r, e), t.elementType = xM, t.lanes = n, t.stateNode = {
          isHidden: false
        }, t;
      }
      function Xg(t, e, n) {
        return t = pr(6, t, null, e), t.lanes = n, t;
      }
      function Qg(t, e, n) {
        return e = pr(4, t.children !== null ? t.children : [], t.key, e), e.lanes = n, e.stateNode = {
          containerInfo: t.containerInfo,
          pendingChildren: null,
          implementation: t.implementation
        }, e;
      }
      function wI(t, e, n, r, i) {
        this.tag = e, this.containerInfo = t, this.finishedWork = this.pingCache = this.current = this.pendingChildren = null, this.timeoutHandle = -1, this.callbackNode = this.pendingContext = this.context = null, this.callbackPriority = 0, this.eventTimes = Rg(0), this.expirationTimes = Rg(-1), this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0, this.entanglements = Rg(0), this.identifierPrefix = r, this.onRecoverableError = i, this.mutableSourceEagerHydrationData = null;
      }
      function xb(t, e, n, r, i, o, s, a, l) {
        return t = new wI(t, e, n, a, l), e === 1 ? (e = 1, o === true && (e |= 8)) : e = 0, o = pr(3, null, null, e), t.current = o, o.stateNode = t, o.memoizedState = {
          element: r,
          isDehydrated: n,
          cache: null,
          transitions: null,
          pendingSuspenseBoundaries: null
        }, rb(o), t;
      }
      function kI(t, e, n) {
        var r = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null;
        return {
          $$typeof: ha,
          key: r == null ? null : "" + r,
          children: t,
          containerInfo: e,
          implementation: n
        };
      }
      function hA(t) {
        if (!t)
          return Ko;
        t = t._reactInternals;
        e: {
          if (Ys(t) !== t || t.tag !== 1)
            throw Error(ee(170));
          var e = t;
          do {
            switch (e.tag) {
              case 3:
                e = e.stateNode.context;
                break e;
              case 1:
                if (zn(e.type)) {
                  e = e.stateNode.__reactInternalMemoizedMergedChildContext;
                  break e;
                }
            }
            e = e.return;
          } while (e !== null);
          throw Error(ee(171));
        }
        if (t.tag === 1) {
          var n = t.type;
          if (zn(n))
            return f2(t, n, e);
        }
        return e;
      }
      function dA(t, e, n, r, i, o, s, a, l) {
        return t = xb(n, r, true, t, i, o, s, a, l), t.context = hA(null), n = t.current, r = Sn(), i = Ho(n), o = Ui(r, i), o.callback = e ?? null, Fo(n, o, i), t.current.lanes = i, Uu(t, i, r), Fn(t, r), t;
      }
      function rm(t, e, n, r) {
        var i = e.current, o = Sn(), s = Ho(i);
        return n = hA(n), e.context === null ? e.context = n : e.pendingContext = n, e = Ui(o, s), e.payload = {
          element: t
        }, r = r === void 0 ? null : r, r !== null && (e.callback = r), t = Fo(i, e, s), t !== null && (Fr(t, i, s, o), qh(t, i, s)), s;
      }
      function Zd(t) {
        if (t = t.current, !t.child)
          return null;
        switch (t.child.tag) {
          case 5:
            return t.child.stateNode;
          default:
            return t.child.stateNode;
        }
      }
      function mw(t, e) {
        if (t = t.memoizedState, t !== null && t.dehydrated !== null) {
          var n = t.retryLane;
          t.retryLane = n !== 0 && n < e ? n : e;
        }
      }
      function Sb(t, e) {
        mw(t, e), (t = t.alternate) && mw(t, e);
      }
      function CI() {
        return null;
      }
      var pA = typeof reportError == "function" ? reportError : function(t) {
        console.error(t);
      };
      function wb(t) {
        this._internalRoot = t;
      }
      im.prototype.render = wb.prototype.render = function(t) {
        var e = this._internalRoot;
        if (e === null)
          throw Error(ee(409));
        rm(t, e, null, null);
      };
      im.prototype.unmount = wb.prototype.unmount = function() {
        var t = this._internalRoot;
        if (t !== null) {
          this._internalRoot = null;
          var e = t.containerInfo;
          Fs(function() {
            rm(null, t, null, null);
          }), e[Yi] = null;
        }
      };
      function im(t) {
        this._internalRoot = t;
      }
      im.prototype.unstable_scheduleHydration = function(t) {
        if (t) {
          var e = WM();
          t = {
            blockedOn: null,
            target: t,
            priority: e
          };
          for (var n = 0; n < ko.length && e !== 0 && e < ko[n].priority; n++)
            ;
          ko.splice(n, 0, t), n === 0 && KM(t);
        }
      };
      function kb(t) {
        return !(!t || t.nodeType !== 1 && t.nodeType !== 9 && t.nodeType !== 11);
      }
      function om(t) {
        return !(!t || t.nodeType !== 1 && t.nodeType !== 9 && t.nodeType !== 11 && (t.nodeType !== 8 || t.nodeValue !== " react-mount-point-unstable "));
      }
      function gw() {
      }
      function TI(t, e, n, r, i) {
        if (i) {
          if (typeof r == "function") {
            var o = r;
            r = function() {
              var c = Zd(s);
              o.call(c);
            };
          }
          var s = dA(e, r, t, 0, null, false, false, "", gw);
          return t._reactRootContainer = s, t[Yi] = s.current, cu(t.nodeType === 8 ? t.parentNode : t), Fs(), s;
        }
        for (; i = t.lastChild; )
          t.removeChild(i);
        if (typeof r == "function") {
          var a = r;
          r = function() {
            var c = Zd(l);
            a.call(c);
          };
        }
        var l = xb(t, 0, false, null, null, false, false, "", gw);
        return t._reactRootContainer = l, t[Yi] = l.current, cu(t.nodeType === 8 ? t.parentNode : t), Fs(function() {
          rm(e, l, n, r);
        }), l;
      }
      function sm(t, e, n, r, i) {
        var o = n._reactRootContainer;
        if (o) {
          var s = o;
          if (typeof i == "function") {
            var a = i;
            i = function() {
              var l = Zd(s);
              a.call(l);
            };
          }
          rm(e, s, t, i);
        } else
          s = TI(n, e, t, i, r);
        return Zd(s);
      }
      HM = function(t) {
        switch (t.tag) {
          case 3:
            var e = t.stateNode;
            if (e.current.memoizedState.isDehydrated) {
              var n = fc(e.pendingLanes);
              n !== 0 && (H1(e, n | 1), Fn(e, Mt()), (je & 6) === 0 && (il = Mt() + 500, ts()));
            }
            break;
          case 13:
            Fs(function() {
              var r = Xi(t, 1);
              if (r !== null) {
                var i = Sn();
                Fr(r, t, 1, i);
              }
            }), Sb(t, 1);
        }
      };
      j1 = function(t) {
        if (t.tag === 13) {
          var e = Xi(t, 134217728);
          if (e !== null) {
            var n = Sn();
            Fr(e, t, 134217728, n);
          }
          Sb(t, 134217728);
        }
      };
      jM = function(t) {
        if (t.tag === 13) {
          var e = Ho(t), n = Xi(t, e);
          if (n !== null) {
            var r = Sn();
            Fr(n, t, e, r);
          }
          Sb(t, e);
        }
      };
      WM = function() {
        return Ye;
      };
      UM = function(t, e) {
        var n = Ye;
        try {
          return Ye = t, e();
        } finally {
          Ye = n;
        }
      };
      vv = function(t, e, n) {
        switch (e) {
          case "input":
            if (uv(t, n), e = n.name, n.type === "radio" && e != null) {
              for (n = t; n.parentNode; )
                n = n.parentNode;
              for (n = n.querySelectorAll("input[name=" + JSON.stringify("" + e) + '][type="radio"]'), e = 0; e < n.length; e++) {
                var r = n[e];
                if (r !== t && r.form === t.form) {
                  var i = Xp(r);
                  if (!i)
                    throw Error(ee(90));
                  wM(r), uv(r, i);
                }
              }
            }
            break;
          case "textarea":
            CM(t, n);
            break;
          case "select":
            e = n.value, e != null && _a(t, !!n.multiple, e, false);
        }
      };
      RM = gb;
      LM = Fs;
      var MI = {
        usingClientEntryPoint: false,
        Events: [
          qu,
          va,
          Xp,
          PM,
          OM,
          gb
        ]
      }, Xl = {
        findFiberByHostInstance: ws,
        bundleType: 0,
        version: "18.2.0",
        rendererPackageName: "react-dom"
      }, AI = {
        bundleType: Xl.bundleType,
        version: Xl.version,
        rendererPackageName: Xl.rendererPackageName,
        rendererConfig: Xl.rendererConfig,
        overrideHookState: null,
        overrideHookStateDeletePath: null,
        overrideHookStateRenamePath: null,
        overrideProps: null,
        overridePropsDeletePath: null,
        overridePropsRenamePath: null,
        setErrorHandler: null,
        setSuspenseHandler: null,
        scheduleUpdate: null,
        currentDispatcherRef: io.ReactCurrentDispatcher,
        findHostInstanceByFiber: function(t) {
          return t = IM(t), t === null ? null : t.stateNode;
        },
        findFiberByHostInstance: Xl.findFiberByHostInstance || CI,
        findHostInstancesForRefresh: null,
        scheduleRefresh: null,
        scheduleRoot: null,
        setRefreshHandler: null,
        getCurrentFiber: null,
        reconcilerVersion: "18.2.0-next-9e3b772b8-20220608"
      };
      if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u") {
        var th = __REACT_DEVTOOLS_GLOBAL_HOOK__;
        if (!th.isDisabled && th.supportsFiber)
          try {
            Kp = th.inject(AI), yi = th;
          } catch {
          }
      }
      Zn.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = MI;
      Zn.createPortal = function(t, e) {
        var n = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null;
        if (!kb(e))
          throw Error(ee(200));
        return kI(t, e, null, n);
      };
      Zn.createRoot = function(t, e) {
        if (!kb(t))
          throw Error(ee(299));
        var n = false, r = "", i = pA;
        return e != null && (e.unstable_strictMode === true && (n = true), e.identifierPrefix !== void 0 && (r = e.identifierPrefix), e.onRecoverableError !== void 0 && (i = e.onRecoverableError)), e = xb(t, 1, false, null, null, n, false, r, i), t[Yi] = e.current, cu(t.nodeType === 8 ? t.parentNode : t), new wb(e);
      };
      Zn.findDOMNode = function(t) {
        if (t == null)
          return null;
        if (t.nodeType === 1)
          return t;
        var e = t._reactInternals;
        if (e === void 0)
          throw typeof t.render == "function" ? Error(ee(188)) : (t = Object.keys(t).join(","), Error(ee(268, t)));
        return t = IM(e), t = t === null ? null : t.stateNode, t;
      };
      Zn.flushSync = function(t) {
        return Fs(t);
      };
      Zn.hydrate = function(t, e, n) {
        if (!om(e))
          throw Error(ee(200));
        return sm(null, t, e, true, n);
      };
      Zn.hydrateRoot = function(t, e, n) {
        if (!kb(t))
          throw Error(ee(405));
        var r = n != null && n.hydratedSources || null, i = false, o = "", s = pA;
        if (n != null && (n.unstable_strictMode === true && (i = true), n.identifierPrefix !== void 0 && (o = n.identifierPrefix), n.onRecoverableError !== void 0 && (s = n.onRecoverableError)), e = dA(e, null, t, 1, n ?? null, i, false, o, s), t[Yi] = e.current, cu(t), r)
          for (t = 0; t < r.length; t++)
            n = r[t], i = n._getVersion, i = i(n._source), e.mutableSourceEagerHydrationData == null ? e.mutableSourceEagerHydrationData = [
              n,
              i
            ] : e.mutableSourceEagerHydrationData.push(n, i);
        return new im(e);
      };
      Zn.render = function(t, e, n) {
        if (!om(e))
          throw Error(ee(200));
        return sm(null, t, e, false, n);
      };
      Zn.unmountComponentAtNode = function(t) {
        if (!om(t))
          throw Error(ee(40));
        return t._reactRootContainer ? (Fs(function() {
          sm(null, null, t, false, function() {
            t._reactRootContainer = null, t[Yi] = null;
          });
        }), true) : false;
      };
      Zn.unstable_batchedUpdates = gb;
      Zn.unstable_renderSubtreeIntoContainer = function(t, e, n, r) {
        if (!om(n))
          throw Error(ee(200));
        if (t == null || t._reactInternals === void 0)
          throw Error(ee(38));
        return sm(t, e, n, false, r);
      };
      Zn.version = "18.2.0-next-9e3b772b8-20220608";
      (function(t) {
        function e() {
          if (!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function"))
            try {
              __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(e);
            } catch (n) {
              console.error(n);
            }
        }
        e(), t.exports = Zn;
      })(Up);
      var vw = Up.exports;
      rv.createRoot = vw.createRoot, rv.hydrateRoot = vw.hydrateRoot;
      function EI() {
        return Boolean(globalThis == null ? void 0 : globalThis.document);
      }
      function PI(t, ...e) {
        if (t == null)
          throw new TypeError("Cannot convert undefined or null to object");
        const n = {
          ...t
        };
        for (const r of e)
          if (r != null)
            for (const i in r)
              !Object.prototype.hasOwnProperty.call(r, i) || (i in n && delete n[i], n[i] = r[i]);
        return n;
      }
      const OI = (t) => t ? "" : void 0;
      function RI(t) {
        return Array.isArray(t);
      }
      function Vr(t) {
        const e = typeof t;
        return t != null && (e === "object" || e === "function") && !RI(t);
      }
      function LI(t) {
        const e = t == null ? 0 : t.length;
        return e ? t[e - 1] : void 0;
      }
      function DI(t) {
        const e = parseFloat(t.toString()), n = t.toString().replace(String(e), "");
        return {
          unitless: !n,
          value: e,
          unit: n
        };
      }
      function Xv(t) {
        if (t == null)
          return t;
        const { unitless: e } = DI(t);
        return e || typeof t == "number" ? `${t}px` : t;
      }
      const mA = (t, e) => parseInt(t[1], 10) > parseInt(e[1], 10) ? 1 : -1, Cb = (t) => Object.fromEntries(Object.entries(t).sort(mA));
      function yw(t) {
        const e = Cb(t);
        return Object.assign(Object.values(e), e);
      }
      function _I(t) {
        const e = Object.keys(Cb(t));
        return new Set(e);
      }
      function bw(t) {
        if (!t)
          return t;
        t = Xv(t) ?? t;
        const e = -0.02;
        return typeof t == "number" ? `${t + e}` : t.replace(/(\d+\.?\d*)/u, (n) => `${parseFloat(n) + e}`);
      }
      function dc(t, e) {
        const n = [
          "@media screen"
        ];
        return t && n.push("and", `(min-width: ${Xv(t)})`), e && n.push("and", `(max-width: ${Xv(e)})`), n.join(" ");
      }
      function II(t) {
        if (!t)
          return null;
        t.base = t.base ?? "0px";
        const e = yw(t), n = Object.entries(t).sort(mA).map(([o, s], a, l) => {
          let [, c] = l[a + 1] ?? [];
          return c = parseFloat(c) > 0 ? bw(c) : void 0, {
            _minW: bw(s),
            breakpoint: o,
            minW: s,
            maxW: c,
            maxWQuery: dc(null, c),
            minWQuery: dc(s),
            minMaxQuery: dc(s, c)
          };
        }), r = _I(t), i = Array.from(r.values());
        return {
          keys: r,
          normalized: e,
          isResponsive(o) {
            const s = Object.keys(o);
            return s.length > 0 && s.every((a) => r.has(a));
          },
          asObject: Cb(t),
          asArray: yw(t),
          details: n,
          get(o) {
            return n.find((s) => s.breakpoint === o);
          },
          media: [
            null,
            ...e.map((o) => dc(o)).slice(1)
          ],
          toArrayValue(o) {
            if (!Vr(o))
              throw new Error("toArrayValue: value must be an object");
            const s = i.map((a) => o[a] ?? null);
            for (; LI(s) === null; )
              s.pop();
            return s;
          },
          toObjectValue(o) {
            if (!Array.isArray(o))
              throw new Error("toObjectValue: value must be an array");
            return o.reduce((s, a, l) => {
              const c = i[l];
              return c != null && a != null && (s[c] = a), s;
            }, {});
          }
        };
      }
      function Qv(...t) {
        return function(n) {
          t.some((r) => (r == null ? void 0 : r(n), n == null ? void 0 : n.defaultPrevented));
        };
      }
      function BI(t) {
        return z.exports.Children.toArray(t).filter((e) => z.exports.isValidElement(e));
      }
      function gA(t) {
        const e = Object.assign({}, t);
        for (let n in e)
          e[n] === void 0 && delete e[n];
        return e;
      }
      function NI(t, e) {
        return `${t} returned \`undefined\`. Seems you forgot to wrap component within ${e}`;
      }
      function Mi(t = {}) {
        const { name: e, strict: n = true, hookName: r = "useContext", providerName: i = "Provider", errorMessage: o, defaultValue: s } = t, a = z.exports.createContext(s);
        a.displayName = e;
        function l() {
          var _a3;
          const c = z.exports.useContext(a);
          if (!c && n) {
            const u = new Error(o ?? NI(r, i));
            throw u.name = "ContextError", (_a3 = Error.captureStackTrace) == null ? void 0 : _a3.call(Error, u, l), u;
          }
          return c;
        }
        return [
          a.Provider,
          l,
          a
        ];
      }
      const qr = (...t) => t.filter(Boolean).join(" ");
      function $I(t, e, n, r) {
        const i = typeof e == "string" ? e.split(".") : [
          e
        ];
        for (r = 0; r < i.length && t; r += 1)
          t = t[i[r]];
        return t === void 0 ? n : t;
      }
      const zI = (t) => {
        const e = /* @__PURE__ */ new WeakMap();
        return (r, i, o, s) => {
          if (typeof r > "u")
            return t(r, i, o);
          e.has(r) || e.set(r, /* @__PURE__ */ new Map());
          const a = e.get(r);
          if (a.has(i))
            return a.get(i);
          const l = t(r, i, o, s);
          return a.set(i, l), l;
        };
      }, vA = zI($I), FI = (t) => t.default || t;
      function VI(t) {
        const { wasSelected: e, enabled: n, isSelected: r, mode: i = "unmount" } = t;
        return !!(!n || r || i === "keepMounted" && e);
      }
      function yA(t, e = []) {
        const n = Object.assign({}, t);
        for (const r of e)
          r in n && delete n[r];
        return n;
      }
      function HI(t, e) {
        const n = {};
        for (const r of e)
          r in t && (n[r] = t[r]);
        return n;
      }
      const jI = (t) => typeof t == "function";
      function mi(t, ...e) {
        return jI(t) ? t(...e) : t;
      }
      function WI(t, ...e) {
        const n = Object.getOwnPropertyDescriptors(t), r = Object.keys(n), i = (s) => {
          const a = {};
          for (let l = 0; l < s.length; l++) {
            const c = s[l];
            n[c] && (Object.defineProperty(a, c, n[c]), delete n[c]);
          }
          return a;
        }, o = (s) => i(Array.isArray(s) ? s : r.filter(s));
        return e.map(o).concat(i(r));
      }
      function xw(t, e, n = {}) {
        const { stop: r, getKey: i } = n;
        function o(s, a = []) {
          if (Vr(s) || Array.isArray(s)) {
            const l = {};
            for (const [c, u] of Object.entries(s)) {
              const h = (i == null ? void 0 : i(c)) ?? c, p = [
                ...a,
                h
              ];
              if (r == null ? void 0 : r(s, p))
                return e(s, a);
              l[h] = o(u, p);
            }
            return l;
          }
          return e(s, a);
        }
        return o(t);
      }
      var Jv = {
        exports: {}
      };
      (function(t, e) {
        var n = 200, r = "__lodash_hash_undefined__", i = 800, o = 16, s = 9007199254740991, a = "[object Arguments]", l = "[object Array]", c = "[object AsyncFunction]", u = "[object Boolean]", h = "[object Date]", p = "[object Error]", v = "[object Function]", y = "[object GeneratorFunction]", S = "[object Map]", C = "[object Number]", w = "[object Null]", k = "[object Object]", T = "[object Proxy]", P = "[object RegExp]", R = "[object Set]", L = "[object String]", D = "[object Undefined]", F = "[object WeakMap]", K = "[object ArrayBuffer]", Y = "[object DataView]", te = "[object Float32Array]", ne = "[object Float64Array]", ue = "[object Int8Array]", ye = "[object Int16Array]", ke = "[object Int32Array]", Ee = "[object Uint8Array]", Q = "[object Uint8ClampedArray]", V = "[object Uint16Array]", ae = "[object Uint32Array]", ge = /[\\^$.*+?()[\]{}|]/g, Te = /^\[object .+?Constructor\]$/, ve = /^(?:0|[1-9]\d*)$/, se = {};
        se[te] = se[ne] = se[ue] = se[ye] = se[ke] = se[Ee] = se[Q] = se[V] = se[ae] = true, se[a] = se[l] = se[K] = se[u] = se[Y] = se[h] = se[p] = se[v] = se[S] = se[C] = se[k] = se[P] = se[R] = se[L] = se[F] = false;
        var re = typeof Ao == "object" && Ao && Ao.Object === Object && Ao, oe = typeof self == "object" && self && self.Object === Object && self, De = re || oe || Function("return this")(), yt = e && !e.nodeType && e, An = yt && true && t && !t.nodeType && t, so = An && An.exports === yt, Yr = so && re.process, ao = function() {
          try {
            var O = An && An.require && An.require("util").types;
            return O || Yr && Yr.binding && Yr.binding("util");
          } catch {
          }
        }(), Ol = ao && ao.isTypedArray;
        function hf(O, B, U) {
          switch (U.length) {
            case 0:
              return O.call(B);
            case 1:
              return O.call(B, U[0]);
            case 2:
              return O.call(B, U[0], U[1]);
            case 3:
              return O.call(B, U[0], U[1], U[2]);
          }
          return O.apply(B, U);
        }
        function df(O, B) {
          for (var U = -1, he = Array(O); ++U < O; )
            he[U] = B(U);
          return he;
        }
        function Et(O) {
          return function(B) {
            return O(B);
          };
        }
        function Qm(O, B) {
          return O == null ? void 0 : O[B];
        }
        function nr(O, B) {
          return function(U) {
            return O(B(U));
          };
        }
        var Jm = Array.prototype, Zm = Function.prototype, is = Object.prototype, Er = De["__core-js_shared__"], vn = Zm.toString, Pr = is.hasOwnProperty, Rl = function() {
          var O = /[^.]+$/.exec(Er && Er.keys && Er.keys.IE_PROTO || "");
          return O ? "Symbol(src)_1." + O : "";
        }(), Js = is.toString, eg = vn.call(Object), lo = RegExp("^" + vn.call(Pr).replace(ge, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"), Zs = so ? De.Buffer : void 0, $t = De.Symbol, os = De.Uint8Array, dt = Zs ? Zs.allocUnsafe : void 0, pf = nr(Object.getPrototypeOf, Object), mf = Object.create, tg = is.propertyIsEnumerable, gf = Jm.splice, ze = $t ? $t.toStringTag : void 0, Kt = function() {
          try {
            var O = _e2(Object, "defineProperty");
            return O({}, "", {}), O;
          } catch {
          }
        }(), ct = Zs ? Zs.isBuffer : void 0, zt = Math.max, Xr = Date.now, Ll = _e2(De, "Map"), bt = _e2(Object, "create"), Dl = function() {
          function O() {
          }
          return function(B) {
            if (!Li(B))
              return {};
            if (mf)
              return mf(B);
            O.prototype = B;
            var U = new O();
            return O.prototype = void 0, U;
          };
        }();
        function Oi(O) {
          var B = -1, U = O == null ? 0 : O.length;
          for (this.clear(); ++B < U; ) {
            var he = O[B];
            this.set(he[0], he[1]);
          }
        }
        function ng() {
          this.__data__ = bt ? bt(null) : {}, this.size = 0;
        }
        function vf(O) {
          var B = this.has(O) && delete this.__data__[O];
          return this.size -= B ? 1 : 0, B;
        }
        function yf(O) {
          var B = this.__data__;
          if (bt) {
            var U = B[O];
            return U === r ? void 0 : U;
          }
          return Pr.call(B, O) ? B[O] : void 0;
        }
        function rg(O) {
          var B = this.__data__;
          return bt ? B[O] !== void 0 : Pr.call(B, O);
        }
        function ig(O, B) {
          var U = this.__data__;
          return this.size += this.has(O) ? 0 : 1, U[O] = bt && B === void 0 ? r : B, this;
        }
        Oi.prototype.clear = ng, Oi.prototype.delete = vf, Oi.prototype.get = yf, Oi.prototype.has = rg, Oi.prototype.set = ig;
        function rr(O) {
          var B = -1, U = O == null ? 0 : O.length;
          for (this.clear(); ++B < U; ) {
            var he = O[B];
            this.set(he[0], he[1]);
          }
        }
        function og() {
          this.__data__ = [], this.size = 0;
        }
        function co(O) {
          var B = this.__data__, U = En(B, O);
          if (U < 0)
            return false;
          var he = B.length - 1;
          return U == he ? B.pop() : gf.call(B, U, 1), --this.size, true;
        }
        function _l2(O) {
          var B = this.__data__, U = En(B, O);
          return U < 0 ? void 0 : B[U][1];
        }
        function sg(O) {
          return En(this.__data__, O) > -1;
        }
        function ir(O, B) {
          var U = this.__data__, he = En(U, O);
          return he < 0 ? (++this.size, U.push([
            O,
            B
          ])) : U[he][1] = B, this;
        }
        rr.prototype.clear = og, rr.prototype.delete = co, rr.prototype.get = _l2, rr.prototype.has = sg, rr.prototype.set = ir;
        function uo(O) {
          var B = -1, U = O == null ? 0 : O.length;
          for (this.clear(); ++B < U; ) {
            var he = O[B];
            this.set(he[0], he[1]);
          }
        }
        function ag() {
          this.size = 0, this.__data__ = {
            hash: new Oi(),
            map: new (Ll || rr)(),
            string: new Oi()
          };
        }
        function or(O) {
          var B = on(this, O).delete(O);
          return this.size -= B ? 1 : 0, B;
        }
        function Il(O) {
          return on(this, O).get(O);
        }
        function lg(O) {
          return on(this, O).has(O);
        }
        function bf(O, B) {
          var U = on(this, O), he = U.size;
          return U.set(O, B), this.size += U.size == he ? 0 : 1, this;
        }
        uo.prototype.clear = ag, uo.prototype.delete = or, uo.prototype.get = Il, uo.prototype.has = lg, uo.prototype.set = bf;
        function Ri(O) {
          var B = this.__data__ = new rr(O);
          this.size = B.size;
        }
        function cg() {
          this.__data__ = new rr(), this.size = 0;
        }
        function xf(O) {
          var B = this.__data__, U = B.delete(O);
          return this.size = B.size, U;
        }
        function ug(O) {
          return this.__data__.get(O);
        }
        function Sf(O) {
          return this.__data__.has(O);
        }
        function fg(O, B) {
          var U = this.__data__;
          if (U instanceof rr) {
            var he = U.__data__;
            if (!Ll || he.length < n - 1)
              return he.push([
                O,
                B
              ]), this.size = ++U.size, this;
            U = this.__data__ = new uo(he);
          }
          return U.set(O, B), this.size = U.size, this;
        }
        Ri.prototype.clear = cg, Ri.prototype.delete = xf, Ri.prototype.get = ug, Ri.prototype.has = Sf, Ri.prototype.set = fg;
        function wf(O, B) {
          var U = Ft(O), he = !U && ia(O), f = !U && !he && oa(O), d = !U && !he && !f && If(O), m = U || he || f || d, g = m ? df(O.length, String) : [], b = g.length;
          for (var x in O)
            (B || Pr.call(O, x)) && !(m && (x == "length" || f && (x == "offset" || x == "parent") || d && (x == "buffer" || x == "byteLength" || x == "byteOffset") || Rf(x, b))) && g.push(x);
          return g;
        }
        function ss(O, B, U) {
          (U !== void 0 && !ra(O[B], U) || U === void 0 && !(B in O)) && Bl(O, B, U);
        }
        function hg(O, B, U) {
          var he = O[B];
          (!(Pr.call(O, B) && ra(he, U)) || U === void 0 && !(B in O)) && Bl(O, B, U);
        }
        function En(O, B) {
          for (var U = O.length; U--; )
            if (ra(O[U][0], B))
              return U;
          return -1;
        }
        function Bl(O, B, U) {
          B == "__proto__" && Kt ? Kt(O, B, {
            configurable: true,
            enumerable: true,
            value: U,
            writable: true
          }) : O[B] = U;
        }
        var kf = Of();
        function as(O) {
          return O == null ? O === void 0 ? D : w : ze && ze in Object(O) ? xg(O) : wg(O);
        }
        function Cf(O) {
          return us(O) && as(O) == a;
        }
        function Tf(O) {
          if (!Li(O) || cs(O))
            return false;
          var B = Fl(O) ? lo : Te;
          return B.test(Df(O));
        }
        function dg(O) {
          return us(O) && _f2(O.length) && !!se[as(O)];
        }
        function pg(O) {
          if (!Li(O))
            return Lf(O);
          var B = ta(O), U = [];
          for (var he in O)
            he == "constructor" && (B || !Pr.call(O, he)) || U.push(he);
          return U;
        }
        function Pn(O, B, U, he, f) {
          O !== B && kf(B, function(d, m) {
            if (f || (f = new Ri()), Li(d))
              mg(O, B, m, U, Pn, he, f);
            else {
              var g = he ? he(Nl(O, m), d, m + "", O, B, f) : void 0;
              g === void 0 && (g = d), ss(O, m, g);
            }
          }, Vl);
        }
        function mg(O, B, U, he, f, d, m) {
          var g = Nl(O, U), b = Nl(B, U), x = m.get(b);
          if (x) {
            ss(O, U, x);
            return;
          }
          var M = d ? d(g, b, U + "", O, B, m) : void 0, A = M === void 0;
          if (A) {
            var E = Ft(b), I = !E && oa(b), _ = !E && !I && If(b);
            M = b, E || I || _ ? Ft(g) ? M = g : Qr(g) ? M = yg(g) : I ? (A = false, M = Af(b, true)) : _ ? (A = false, M = Ef(b, true)) : M = [] : kg(b) || ia(b) ? (M = g, ia(g) ? M = Cg(g) : (!Li(g) || Fl(g)) && (M = ea(b))) : A = false;
          }
          A && (m.set(b, M), f(M, b, he, d, m), m.delete(b)), ss(O, U, M);
        }
        function gg(O, B) {
          return $l(fo(O, B, Hl), O + "");
        }
        var Mf = Kt ? function(O, B) {
          return Kt(O, "toString", {
            configurable: true,
            enumerable: false,
            value: Nf(B),
            writable: true
          });
        } : Hl;
        function Af(O, B) {
          if (B)
            return O.slice();
          var U = O.length, he = dt ? dt(U) : new O.constructor(U);
          return O.copy(he), he;
        }
        function vg(O) {
          var B = new O.constructor(O.byteLength);
          return new os(B).set(new os(O)), B;
        }
        function Ef(O, B) {
          var U = B ? vg(O.buffer) : O.buffer;
          return new O.constructor(U, O.byteOffset, O.length);
        }
        function yg(O, B) {
          var U = -1, he = O.length;
          for (B || (B = Array(he)); ++U < he; )
            B[U] = O[U];
          return B;
        }
        function Pf(O, B, U, he) {
          var f = !U;
          U || (U = {});
          for (var d = -1, m = B.length; ++d < m; ) {
            var g = B[d], b = he ? he(U[g], O[g], g, U, O) : void 0;
            b === void 0 && (b = O[g]), f ? Bl(U, g, b) : hg(U, g, b);
          }
          return U;
        }
        function bg(O) {
          return gg(function(B, U) {
            var he = -1, f = U.length, d = f > 1 ? U[f - 1] : void 0, m = f > 2 ? U[2] : void 0;
            for (d = O.length > 3 && typeof d == "function" ? (f--, d) : void 0, m && ls(U[0], U[1], m) && (d = f < 3 ? void 0 : d, f = 1), B = Object(B); ++he < f; ) {
              var g = U[he];
              g && O(B, g, he, d);
            }
            return B;
          });
        }
        function Of(O) {
          return function(B, U, he) {
            for (var f = -1, d = Object(B), m = he(B), g = m.length; g--; ) {
              var b = m[O ? g : ++f];
              if (U(d[b], b, d) === false)
                break;
            }
            return B;
          };
        }
        function on(O, B) {
          var U = O.__data__;
          return Sg(B) ? U[typeof B == "string" ? "string" : "hash"] : U.map;
        }
        function _e2(O, B) {
          var U = Qm(O, B);
          return Tf(U) ? U : void 0;
        }
        function xg(O) {
          var B = Pr.call(O, ze), U = O[ze];
          try {
            O[ze] = void 0;
            var he = true;
          } catch {
          }
          var f = Js.call(O);
          return he && (B ? O[ze] = U : delete O[ze]), f;
        }
        function ea(O) {
          return typeof O.constructor == "function" && !ta(O) ? Dl(pf(O)) : {};
        }
        function Rf(O, B) {
          var U = typeof O;
          return B = B ?? s, !!B && (U == "number" || U != "symbol" && ve.test(O)) && O > -1 && O % 1 == 0 && O < B;
        }
        function ls(O, B, U) {
          if (!Li(U))
            return false;
          var he = typeof B;
          return (he == "number" ? zl(U) && Rf(B, U.length) : he == "string" && B in U) ? ra(U[B], O) : false;
        }
        function Sg(O) {
          var B = typeof O;
          return B == "string" || B == "number" || B == "symbol" || B == "boolean" ? O !== "__proto__" : O === null;
        }
        function cs(O) {
          return !!Rl && Rl in O;
        }
        function ta(O) {
          var B = O && O.constructor, U = typeof B == "function" && B.prototype || is;
          return O === U;
        }
        function Lf(O) {
          var B = [];
          if (O != null)
            for (var U in Object(O))
              B.push(U);
          return B;
        }
        function wg(O) {
          return Js.call(O);
        }
        function fo(O, B, U) {
          return B = zt(B === void 0 ? O.length - 1 : B, 0), function() {
            for (var he = arguments, f = -1, d = zt(he.length - B, 0), m = Array(d); ++f < d; )
              m[f] = he[B + f];
            f = -1;
            for (var g = Array(B + 1); ++f < B; )
              g[f] = he[f];
            return g[B] = U(m), hf(O, this, g);
          };
        }
        function Nl(O, B) {
          if (!(B === "constructor" && typeof O[B] == "function") && B != "__proto__")
            return O[B];
        }
        var $l = na(Mf);
        function na(O) {
          var B = 0, U = 0;
          return function() {
            var he = Xr(), f = o - (he - U);
            if (U = he, f > 0) {
              if (++B >= i)
                return arguments[0];
            } else
              B = 0;
            return O.apply(void 0, arguments);
          };
        }
        function Df(O) {
          if (O != null) {
            try {
              return vn.call(O);
            } catch {
            }
            try {
              return O + "";
            } catch {
            }
          }
          return "";
        }
        function ra(O, B) {
          return O === B || O !== O && B !== B;
        }
        var ia = Cf(function() {
          return arguments;
        }()) ? Cf : function(O) {
          return us(O) && Pr.call(O, "callee") && !tg.call(O, "callee");
        }, Ft = Array.isArray;
        function zl(O) {
          return O != null && _f2(O.length) && !Fl(O);
        }
        function Qr(O) {
          return us(O) && zl(O);
        }
        var oa = ct || $f;
        function Fl(O) {
          if (!Li(O))
            return false;
          var B = as(O);
          return B == v || B == y || B == c || B == T;
        }
        function _f2(O) {
          return typeof O == "number" && O > -1 && O % 1 == 0 && O <= s;
        }
        function Li(O) {
          var B = typeof O;
          return O != null && (B == "object" || B == "function");
        }
        function us(O) {
          return O != null && typeof O == "object";
        }
        function kg(O) {
          if (!us(O) || as(O) != k)
            return false;
          var B = pf(O);
          if (B === null)
            return true;
          var U = Pr.call(B, "constructor") && B.constructor;
          return typeof U == "function" && U instanceof U && vn.call(U) == eg;
        }
        var If = Ol ? Et(Ol) : dg;
        function Cg(O) {
          return Pf(O, Vl(O));
        }
        function Vl(O) {
          return zl(O) ? wf(O, true) : pg(O);
        }
        var Bf = bg(function(O, B, U, he) {
          Pn(O, B, U, he);
        });
        function Nf(O) {
          return function() {
            return O;
          };
        }
        function Hl(O) {
          return O;
        }
        function $f() {
          return false;
        }
        t.exports = Bf;
      })(Jv, Jv.exports);
      const gi = Jv.exports;
      function ed(t, e = []) {
        const n = z.exports.useRef(t);
        return z.exports.useEffect(() => {
          n.current = t;
        }), z.exports.useCallback((...r) => {
          var _a3;
          return (_a3 = n.current) == null ? void 0 : _a3.call(n, ...r);
        }, e);
      }
      function UI(t) {
        const { value: e, defaultValue: n, onChange: r, shouldUpdate: i = (p, v) => p !== v } = t, o = ed(r), s = ed(i), [a, l] = z.exports.useState(n), c = e !== void 0, u = c ? e : a, h = ed((p) => {
          const y = typeof p == "function" ? p(u) : p;
          !s(u, y) || (c || l(y), o(y));
        }, [
          c,
          o,
          u,
          s
        ]);
        return [
          u,
          h
        ];
      }
      const Zv = Boolean(globalThis == null ? void 0 : globalThis.document) ? z.exports.useLayoutEffect : z.exports.useEffect, Sw = (t, e) => {
        const n = z.exports.useRef(false), r = z.exports.useRef(false);
        z.exports.useEffect(() => {
          if (n.current && r.current)
            return t();
          r.current = true;
        }, e), z.exports.useEffect(() => (n.current = true, () => {
          n.current = false;
        }), []);
      };
      function KI(t, e) {
        if (t != null) {
          if (typeof t == "function") {
            t(e);
            return;
          }
          try {
            t.current = e;
          } catch {
            throw new Error(`Cannot assign value '${e}' to ref '${t}'`);
          }
        }
      }
      function Tb(...t) {
        return (e) => {
          t.forEach((n) => {
            KI(n, e);
          });
        };
      }
      function qI(t, e) {
        const n = ed(t);
        z.exports.useEffect(() => {
          if (e == null)
            return;
          let r = null;
          return r = window.setTimeout(() => {
            n();
          }, e), () => {
            r && window.clearTimeout(r);
          };
        }, [
          e,
          n
        ]);
      }
      const Lt = {
        open: (t, e) => `${t}[data-open], ${t}[open], ${t}[data-state=open] ${e}`,
        closed: (t, e) => `${t}[data-closed], ${t}[data-state=closed] ${e}`,
        hover: (t, e) => `${t}:hover ${e}, ${t}[data-hover] ${e}`,
        focus: (t, e) => `${t}:focus ${e}, ${t}[data-focus] ${e}`,
        focusVisible: (t, e) => `${t}:focus-visible ${e}`,
        focusWithin: (t, e) => `${t}:focus-within ${e}`,
        active: (t, e) => `${t}:active ${e}, ${t}[data-active] ${e}`,
        disabled: (t, e) => `${t}:disabled ${e}, ${t}[data-disabled] ${e}`,
        invalid: (t, e) => `${t}:invalid ${e}, ${t}[data-invalid] ${e}`,
        checked: (t, e) => `${t}:checked ${e}, ${t}[data-checked] ${e}`,
        indeterminate: (t, e) => `${t}:indeterminate ${e}, ${t}[aria-checked=mixed] ${e}, ${t}[data-indeterminate] ${e}`,
        readOnly: (t, e) => `${t}:read-only ${e}, ${t}[readonly] ${e}, ${t}[data-read-only] ${e}`,
        expanded: (t, e) => `${t}:read-only ${e}, ${t}[aria-expanded=true] ${e}, ${t}[data-expanded] ${e}`,
        placeholderShown: (t, e) => `${t}:placeholder-shown ${e}`
      }, Zr = (t) => bA((e) => t(e, "&"), "[role=group]", "[data-group]", ".group"), Di = (t) => bA((e) => t(e, "~ &"), "[data-peer]", ".peer"), bA = (t, ...e) => e.map(t).join(", "), am = {
        _hover: "&:hover, &[data-hover]",
        _active: "&:active, &[data-active]",
        _focus: "&:focus, &[data-focus]",
        _highlighted: "&[data-highlighted]",
        _focusWithin: "&:focus-within, &[data-focus-within]",
        _focusVisible: "&:focus-visible, &[data-focus-visible]",
        _disabled: "&:disabled, &[disabled], &[aria-disabled=true], &[data-disabled]",
        _readOnly: "&[aria-readonly=true], &[readonly], &[data-readonly]",
        _before: "&::before",
        _after: "&::after",
        _empty: "&:empty, &[data-empty]",
        _expanded: "&[aria-expanded=true], &[data-expanded], &[data-state=expanded]",
        _checked: "&[aria-checked=true], &[data-checked], &[data-state=checked]",
        _grabbed: "&[aria-grabbed=true], &[data-grabbed]",
        _pressed: "&[aria-pressed=true], &[data-pressed]",
        _invalid: "&[aria-invalid=true], &[data-invalid]",
        _valid: "&[data-valid], &[data-state=valid]",
        _loading: "&[data-loading], &[aria-busy=true]",
        _selected: "&[aria-selected=true], &[data-selected]",
        _hidden: "&[hidden], &[data-hidden]",
        _autofill: "&:-webkit-autofill",
        _even: "&:nth-of-type(even)",
        _odd: "&:nth-of-type(odd)",
        _first: "&:first-of-type",
        _firstLetter: "&::first-letter",
        _last: "&:last-of-type",
        _notFirst: "&:not(:first-of-type)",
        _notLast: "&:not(:last-of-type)",
        _visited: "&:visited",
        _activeLink: "&[aria-current=page]",
        _activeStep: "&[aria-current=step]",
        _indeterminate: "&:indeterminate, &[aria-checked=mixed], &[data-indeterminate], &[data-state=indeterminate]",
        _groupOpen: Zr(Lt.open),
        _groupClosed: Zr(Lt.closed),
        _groupHover: Zr(Lt.hover),
        _peerHover: Di(Lt.hover),
        _groupFocus: Zr(Lt.focus),
        _peerFocus: Di(Lt.focus),
        _groupFocusVisible: Zr(Lt.focusVisible),
        _peerFocusVisible: Di(Lt.focusVisible),
        _groupActive: Zr(Lt.active),
        _peerActive: Di(Lt.active),
        _groupDisabled: Zr(Lt.disabled),
        _peerDisabled: Di(Lt.disabled),
        _groupInvalid: Zr(Lt.invalid),
        _peerInvalid: Di(Lt.invalid),
        _groupChecked: Zr(Lt.checked),
        _peerChecked: Di(Lt.checked),
        _groupFocusWithin: Zr(Lt.focusWithin),
        _peerFocusWithin: Di(Lt.focusWithin),
        _peerPlaceholderShown: Di(Lt.placeholderShown),
        _placeholder: "&::placeholder, &[data-placeholder]",
        _placeholderShown: "&:placeholder-shown, &[data-placeholder-shown]",
        _fullScreen: "&:fullscreen, &[data-fullscreen]",
        _selection: "&::selection",
        _rtl: "[dir=rtl] &, &[dir=rtl]",
        _ltr: "[dir=ltr] &, &[dir=ltr]",
        _mediaDark: "@media (prefers-color-scheme: dark)",
        _mediaReduceMotion: "@media (prefers-reduced-motion: reduce)",
        _dark: ".chakra-ui-dark &:not([data-theme]),[data-theme=dark] &:not([data-theme]),&[data-theme=dark]",
        _light: ".chakra-ui-light &:not([data-theme]),[data-theme=light] &:not([data-theme]),&[data-theme=light]",
        _horizontal: "&[data-orientation=horizontal]",
        _vertical: "&[data-orientation=vertical]",
        _open: "&[data-open], &[open], &[data-state=open]",
        _closed: "&[data-closed], &[data-state=closed]",
        _complete: "&[data-complete]",
        _incomplete: "&[data-incomplete]",
        _current: "&[data-current]"
      }, xA = Object.keys(am), GI = (t) => /!(important)?$/.test(t), ww = (t) => typeof t == "string" ? t.replace(/!(important)?$/, "").trim() : t, YI = (t, e) => (n) => {
        const r = String(e), i = GI(r), o = ww(r), s = t ? `${t}.${o}` : o;
        let a = Vr(n.__cssMap) && s in n.__cssMap ? n.__cssMap[s].varRef : e;
        return a = ww(a), i ? `${a} !important` : a;
      };
      function Mb(t) {
        const { scale: e, transform: n, compose: r } = t;
        return (o, s) => {
          const a = YI(e, o)(s);
          let l = (n == null ? void 0 : n(a, s)) ?? a;
          return r && (l = r(l, s)), l;
        };
      }
      const nh = (...t) => (e) => t.reduce((n, r) => r(n), e);
      function lr(t, e) {
        return (n) => {
          const r = {
            property: n,
            scale: t
          };
          return r.transform = Mb({
            scale: t,
            transform: e
          }), r;
        };
      }
      const XI = ({ rtl: t, ltr: e }) => (n) => n.direction === "rtl" ? t : e;
      function QI(t) {
        const { property: e, scale: n, transform: r } = t;
        return {
          scale: n,
          property: XI(e),
          transform: n ? Mb({
            scale: n,
            compose: r
          }) : r
        };
      }
      const SA = [
        "rotate(var(--chakra-rotate, 0))",
        "scaleX(var(--chakra-scale-x, 1))",
        "scaleY(var(--chakra-scale-y, 1))",
        "skewX(var(--chakra-skew-x, 0))",
        "skewY(var(--chakra-skew-y, 0))"
      ];
      function JI() {
        return [
          "translateX(var(--chakra-translate-x, 0))",
          "translateY(var(--chakra-translate-y, 0))",
          ...SA
        ].join(" ");
      }
      function ZI() {
        return [
          "translate3d(var(--chakra-translate-x, 0), var(--chakra-translate-y, 0), 0)",
          ...SA
        ].join(" ");
      }
      const eB = {
        "--chakra-blur": "var(--chakra-empty,/*!*/ /*!*/)",
        "--chakra-brightness": "var(--chakra-empty,/*!*/ /*!*/)",
        "--chakra-contrast": "var(--chakra-empty,/*!*/ /*!*/)",
        "--chakra-grayscale": "var(--chakra-empty,/*!*/ /*!*/)",
        "--chakra-hue-rotate": "var(--chakra-empty,/*!*/ /*!*/)",
        "--chakra-invert": "var(--chakra-empty,/*!*/ /*!*/)",
        "--chakra-saturate": "var(--chakra-empty,/*!*/ /*!*/)",
        "--chakra-sepia": "var(--chakra-empty,/*!*/ /*!*/)",
        "--chakra-drop-shadow": "var(--chakra-empty,/*!*/ /*!*/)",
        filter: [
          "var(--chakra-blur)",
          "var(--chakra-brightness)",
          "var(--chakra-contrast)",
          "var(--chakra-grayscale)",
          "var(--chakra-hue-rotate)",
          "var(--chakra-invert)",
          "var(--chakra-saturate)",
          "var(--chakra-sepia)",
          "var(--chakra-drop-shadow)"
        ].join(" ")
      }, tB = {
        backdropFilter: [
          "var(--chakra-backdrop-blur)",
          "var(--chakra-backdrop-brightness)",
          "var(--chakra-backdrop-contrast)",
          "var(--chakra-backdrop-grayscale)",
          "var(--chakra-backdrop-hue-rotate)",
          "var(--chakra-backdrop-invert)",
          "var(--chakra-backdrop-opacity)",
          "var(--chakra-backdrop-saturate)",
          "var(--chakra-backdrop-sepia)"
        ].join(" "),
        "--chakra-backdrop-blur": "var(--chakra-empty,/*!*/ /*!*/)",
        "--chakra-backdrop-brightness": "var(--chakra-empty,/*!*/ /*!*/)",
        "--chakra-backdrop-contrast": "var(--chakra-empty,/*!*/ /*!*/)",
        "--chakra-backdrop-grayscale": "var(--chakra-empty,/*!*/ /*!*/)",
        "--chakra-backdrop-hue-rotate": "var(--chakra-empty,/*!*/ /*!*/)",
        "--chakra-backdrop-invert": "var(--chakra-empty,/*!*/ /*!*/)",
        "--chakra-backdrop-opacity": "var(--chakra-empty,/*!*/ /*!*/)",
        "--chakra-backdrop-saturate": "var(--chakra-empty,/*!*/ /*!*/)",
        "--chakra-backdrop-sepia": "var(--chakra-empty,/*!*/ /*!*/)"
      };
      function nB(t) {
        return {
          "--chakra-ring-offset-shadow": "var(--chakra-ring-inset) 0 0 0 var(--chakra-ring-offset-width) var(--chakra-ring-offset-color)",
          "--chakra-ring-shadow": "var(--chakra-ring-inset) 0 0 0 calc(var(--chakra-ring-width) + var(--chakra-ring-offset-width)) var(--chakra-ring-color)",
          "--chakra-ring-width": t,
          boxShadow: [
            "var(--chakra-ring-offset-shadow)",
            "var(--chakra-ring-shadow)",
            "var(--chakra-shadow, 0 0 #0000)"
          ].join(", ")
        };
      }
      const rB = {
        "row-reverse": {
          space: "--chakra-space-x-reverse",
          divide: "--chakra-divide-x-reverse"
        },
        "column-reverse": {
          space: "--chakra-space-y-reverse",
          divide: "--chakra-divide-y-reverse"
        }
      }, ey = {
        "to-t": "to top",
        "to-tr": "to top right",
        "to-r": "to right",
        "to-br": "to bottom right",
        "to-b": "to bottom",
        "to-bl": "to bottom left",
        "to-l": "to left",
        "to-tl": "to top left"
      }, iB = new Set(Object.values(ey)), ty = /* @__PURE__ */ new Set([
        "none",
        "-moz-initial",
        "inherit",
        "initial",
        "revert",
        "unset"
      ]), oB = (t) => t.trim();
      function sB(t, e) {
        if (t == null || ty.has(t))
          return t;
        if (!(ny(t) || ty.has(t)))
          return `url('${t}')`;
        const i = /(^[a-z-A-Z]+)\((.*)\)/g.exec(t), o = i == null ? void 0 : i[1], s = i == null ? void 0 : i[2];
        if (!o || !s)
          return t;
        const a = o.includes("-gradient") ? o : `${o}-gradient`, [l, ...c] = s.split(",").map(oB).filter(Boolean);
        if ((c == null ? void 0 : c.length) === 0)
          return t;
        const u = l in ey ? ey[l] : l;
        c.unshift(u);
        const h = c.map((p) => {
          if (iB.has(p))
            return p;
          const v = p.indexOf(" "), [y, S] = v !== -1 ? [
            p.substr(0, v),
            p.substr(v + 1)
          ] : [
            p
          ], C = ny(S) ? S : S && S.split(" "), w = `colors.${y}`, k = w in e.__cssMap ? e.__cssMap[w].varRef : y;
          return C ? [
            k,
            ...Array.isArray(C) ? C : [
              C
            ]
          ].join(" ") : k;
        });
        return `${a}(${h.join(", ")})`;
      }
      const ny = (t) => typeof t == "string" && t.includes("(") && t.includes(")"), aB = (t, e) => sB(t, e ?? {});
      function lB(t) {
        return /^var\(--.+\)$/.test(t);
      }
      const cB = (t) => {
        const e = parseFloat(t.toString()), n = t.toString().replace(String(e), "");
        return {
          unitless: !n,
          value: e,
          unit: n
        };
      }, ei = (t) => (e) => `${t}(${e})`, Be = {
        filter(t) {
          return t !== "auto" ? t : eB;
        },
        backdropFilter(t) {
          return t !== "auto" ? t : tB;
        },
        ring(t) {
          return nB(Be.px(t));
        },
        bgClip(t) {
          return t === "text" ? {
            color: "transparent",
            backgroundClip: "text"
          } : {
            backgroundClip: t
          };
        },
        transform(t) {
          return t === "auto" ? JI() : t === "auto-gpu" ? ZI() : t;
        },
        vh(t) {
          return t === "$100vh" ? "var(--chakra-vh)" : t;
        },
        px(t) {
          if (t == null)
            return t;
          const { unitless: e } = cB(t);
          return e || typeof t == "number" ? `${t}px` : t;
        },
        fraction(t) {
          return typeof t != "number" || t > 1 ? t : `${t * 100}%`;
        },
        float(t, e) {
          const n = {
            left: "right",
            right: "left"
          };
          return e.direction === "rtl" ? n[t] : t;
        },
        degree(t) {
          if (lB(t) || t == null)
            return t;
          const e = typeof t == "string" && !t.endsWith("deg");
          return typeof t == "number" || e ? `${t}deg` : t;
        },
        gradient: aB,
        blur: ei("blur"),
        opacity: ei("opacity"),
        brightness: ei("brightness"),
        contrast: ei("contrast"),
        dropShadow: ei("drop-shadow"),
        grayscale: ei("grayscale"),
        hueRotate: (t) => ei("hue-rotate")(Be.degree(t)),
        invert: ei("invert"),
        saturate: ei("saturate"),
        sepia: ei("sepia"),
        bgImage(t) {
          return t == null || ny(t) || ty.has(t) ? t : `url(${t})`;
        },
        outline(t) {
          const e = String(t) === "0" || String(t) === "none";
          return t !== null && e ? {
            outline: "2px solid transparent",
            outlineOffset: "2px"
          } : {
            outline: t
          };
        },
        flexDirection(t) {
          const { space: e, divide: n } = rB[t] ?? {}, r = {
            flexDirection: t
          };
          return e && (r[e] = 1), n && (r[n] = 1), r;
        }
      }, N = {
        borderWidths: lr("borderWidths"),
        borderStyles: lr("borderStyles"),
        colors: lr("colors"),
        borders: lr("borders"),
        gradients: lr("gradients", Be.gradient),
        radii: lr("radii", Be.px),
        space: lr("space", nh(Be.vh, Be.px)),
        spaceT: lr("space", nh(Be.vh, Be.px)),
        degreeT(t) {
          return {
            property: t,
            transform: Be.degree
          };
        },
        prop(t, e, n) {
          return {
            property: t,
            scale: e,
            ...e && {
              transform: Mb({
                scale: e,
                transform: n
              })
            }
          };
        },
        propT(t, e) {
          return {
            property: t,
            transform: e
          };
        },
        sizes: lr("sizes", nh(Be.vh, Be.px)),
        sizesT: lr("sizes", nh(Be.vh, Be.fraction)),
        shadows: lr("shadows"),
        logical: QI,
        blur: lr("blur", Be.blur)
      }, td = {
        background: N.colors("background"),
        backgroundColor: N.colors("backgroundColor"),
        backgroundImage: N.gradients("backgroundImage"),
        backgroundSize: true,
        backgroundPosition: true,
        backgroundRepeat: true,
        backgroundAttachment: true,
        backgroundClip: {
          transform: Be.bgClip
        },
        bgSize: N.prop("backgroundSize"),
        bgPosition: N.prop("backgroundPosition"),
        bg: N.colors("background"),
        bgColor: N.colors("backgroundColor"),
        bgPos: N.prop("backgroundPosition"),
        bgRepeat: N.prop("backgroundRepeat"),
        bgAttachment: N.prop("backgroundAttachment"),
        bgGradient: N.gradients("backgroundImage"),
        bgClip: {
          transform: Be.bgClip
        }
      };
      Object.assign(td, {
        bgImage: td.backgroundImage,
        bgImg: td.backgroundImage
      });
      const We = {
        border: N.borders("border"),
        borderWidth: N.borderWidths("borderWidth"),
        borderStyle: N.borderStyles("borderStyle"),
        borderColor: N.colors("borderColor"),
        borderRadius: N.radii("borderRadius"),
        borderTop: N.borders("borderTop"),
        borderBlockStart: N.borders("borderBlockStart"),
        borderTopLeftRadius: N.radii("borderTopLeftRadius"),
        borderStartStartRadius: N.logical({
          scale: "radii",
          property: {
            ltr: "borderTopLeftRadius",
            rtl: "borderTopRightRadius"
          }
        }),
        borderEndStartRadius: N.logical({
          scale: "radii",
          property: {
            ltr: "borderBottomLeftRadius",
            rtl: "borderBottomRightRadius"
          }
        }),
        borderTopRightRadius: N.radii("borderTopRightRadius"),
        borderStartEndRadius: N.logical({
          scale: "radii",
          property: {
            ltr: "borderTopRightRadius",
            rtl: "borderTopLeftRadius"
          }
        }),
        borderEndEndRadius: N.logical({
          scale: "radii",
          property: {
            ltr: "borderBottomRightRadius",
            rtl: "borderBottomLeftRadius"
          }
        }),
        borderRight: N.borders("borderRight"),
        borderInlineEnd: N.borders("borderInlineEnd"),
        borderBottom: N.borders("borderBottom"),
        borderBlockEnd: N.borders("borderBlockEnd"),
        borderBottomLeftRadius: N.radii("borderBottomLeftRadius"),
        borderBottomRightRadius: N.radii("borderBottomRightRadius"),
        borderLeft: N.borders("borderLeft"),
        borderInlineStart: {
          property: "borderInlineStart",
          scale: "borders"
        },
        borderInlineStartRadius: N.logical({
          scale: "radii",
          property: {
            ltr: [
              "borderTopLeftRadius",
              "borderBottomLeftRadius"
            ],
            rtl: [
              "borderTopRightRadius",
              "borderBottomRightRadius"
            ]
          }
        }),
        borderInlineEndRadius: N.logical({
          scale: "radii",
          property: {
            ltr: [
              "borderTopRightRadius",
              "borderBottomRightRadius"
            ],
            rtl: [
              "borderTopLeftRadius",
              "borderBottomLeftRadius"
            ]
          }
        }),
        borderX: N.borders([
          "borderLeft",
          "borderRight"
        ]),
        borderInline: N.borders("borderInline"),
        borderY: N.borders([
          "borderTop",
          "borderBottom"
        ]),
        borderBlock: N.borders("borderBlock"),
        borderTopWidth: N.borderWidths("borderTopWidth"),
        borderBlockStartWidth: N.borderWidths("borderBlockStartWidth"),
        borderTopColor: N.colors("borderTopColor"),
        borderBlockStartColor: N.colors("borderBlockStartColor"),
        borderTopStyle: N.borderStyles("borderTopStyle"),
        borderBlockStartStyle: N.borderStyles("borderBlockStartStyle"),
        borderBottomWidth: N.borderWidths("borderBottomWidth"),
        borderBlockEndWidth: N.borderWidths("borderBlockEndWidth"),
        borderBottomColor: N.colors("borderBottomColor"),
        borderBlockEndColor: N.colors("borderBlockEndColor"),
        borderBottomStyle: N.borderStyles("borderBottomStyle"),
        borderBlockEndStyle: N.borderStyles("borderBlockEndStyle"),
        borderLeftWidth: N.borderWidths("borderLeftWidth"),
        borderInlineStartWidth: N.borderWidths("borderInlineStartWidth"),
        borderLeftColor: N.colors("borderLeftColor"),
        borderInlineStartColor: N.colors("borderInlineStartColor"),
        borderLeftStyle: N.borderStyles("borderLeftStyle"),
        borderInlineStartStyle: N.borderStyles("borderInlineStartStyle"),
        borderRightWidth: N.borderWidths("borderRightWidth"),
        borderInlineEndWidth: N.borderWidths("borderInlineEndWidth"),
        borderRightColor: N.colors("borderRightColor"),
        borderInlineEndColor: N.colors("borderInlineEndColor"),
        borderRightStyle: N.borderStyles("borderRightStyle"),
        borderInlineEndStyle: N.borderStyles("borderInlineEndStyle"),
        borderTopRadius: N.radii([
          "borderTopLeftRadius",
          "borderTopRightRadius"
        ]),
        borderBottomRadius: N.radii([
          "borderBottomLeftRadius",
          "borderBottomRightRadius"
        ]),
        borderLeftRadius: N.radii([
          "borderTopLeftRadius",
          "borderBottomLeftRadius"
        ]),
        borderRightRadius: N.radii([
          "borderTopRightRadius",
          "borderBottomRightRadius"
        ])
      };
      Object.assign(We, {
        rounded: We.borderRadius,
        roundedTop: We.borderTopRadius,
        roundedTopLeft: We.borderTopLeftRadius,
        roundedTopRight: We.borderTopRightRadius,
        roundedTopStart: We.borderStartStartRadius,
        roundedTopEnd: We.borderStartEndRadius,
        roundedBottom: We.borderBottomRadius,
        roundedBottomLeft: We.borderBottomLeftRadius,
        roundedBottomRight: We.borderBottomRightRadius,
        roundedBottomStart: We.borderEndStartRadius,
        roundedBottomEnd: We.borderEndEndRadius,
        roundedLeft: We.borderLeftRadius,
        roundedRight: We.borderRightRadius,
        roundedStart: We.borderInlineStartRadius,
        roundedEnd: We.borderInlineEndRadius,
        borderStart: We.borderInlineStart,
        borderEnd: We.borderInlineEnd,
        borderTopStartRadius: We.borderStartStartRadius,
        borderTopEndRadius: We.borderStartEndRadius,
        borderBottomStartRadius: We.borderEndStartRadius,
        borderBottomEndRadius: We.borderEndEndRadius,
        borderStartRadius: We.borderInlineStartRadius,
        borderEndRadius: We.borderInlineEndRadius,
        borderStartWidth: We.borderInlineStartWidth,
        borderEndWidth: We.borderInlineEndWidth,
        borderStartColor: We.borderInlineStartColor,
        borderEndColor: We.borderInlineEndColor,
        borderStartStyle: We.borderInlineStartStyle,
        borderEndStyle: We.borderInlineEndStyle
      });
      const uB = {
        color: N.colors("color"),
        textColor: N.colors("color"),
        fill: N.colors("fill"),
        stroke: N.colors("stroke"),
        accentColor: N.colors("accentColor"),
        textFillColor: N.colors("textFillColor")
      }, ep = {
        alignItems: true,
        alignContent: true,
        justifyItems: true,
        justifyContent: true,
        flexWrap: true,
        flexDirection: {
          transform: Be.flexDirection
        },
        flex: true,
        flexFlow: true,
        flexGrow: true,
        flexShrink: true,
        flexBasis: N.sizes("flexBasis"),
        justifySelf: true,
        alignSelf: true,
        order: true,
        placeItems: true,
        placeContent: true,
        placeSelf: true,
        gap: N.space("gap"),
        rowGap: N.space("rowGap"),
        columnGap: N.space("columnGap")
      };
      Object.assign(ep, {
        flexDir: ep.flexDirection
      });
      const cr = {
        width: N.sizesT("width"),
        inlineSize: N.sizesT("inlineSize"),
        height: N.sizes("height"),
        blockSize: N.sizes("blockSize"),
        boxSize: N.sizes([
          "width",
          "height"
        ]),
        minWidth: N.sizes("minWidth"),
        minInlineSize: N.sizes("minInlineSize"),
        minHeight: N.sizes("minHeight"),
        minBlockSize: N.sizes("minBlockSize"),
        maxWidth: N.sizes("maxWidth"),
        maxInlineSize: N.sizes("maxInlineSize"),
        maxHeight: N.sizes("maxHeight"),
        maxBlockSize: N.sizes("maxBlockSize"),
        overflow: true,
        overflowX: true,
        overflowY: true,
        overscrollBehavior: true,
        overscrollBehaviorX: true,
        overscrollBehaviorY: true,
        display: true,
        aspectRatio: true,
        hideFrom: {
          scale: "breakpoints",
          transform: (t, e) => {
            var _a3, _b3;
            return {
              [`@media screen and (min-width: ${((_b3 = (_a3 = e.__breakpoints) == null ? void 0 : _a3.get(t)) == null ? void 0 : _b3.minW) ?? t})`]: {
                display: "none"
              }
            };
          }
        },
        hideBelow: {
          scale: "breakpoints",
          transform: (t, e) => {
            var _a3, _b3;
            return {
              [`@media screen and (max-width: ${((_b3 = (_a3 = e.__breakpoints) == null ? void 0 : _a3.get(t)) == null ? void 0 : _b3._minW) ?? t})`]: {
                display: "none"
              }
            };
          }
        },
        verticalAlign: true,
        boxSizing: true,
        boxDecorationBreak: true,
        float: N.propT("float", Be.float),
        objectFit: true,
        objectPosition: true,
        visibility: true,
        isolation: true
      };
      Object.assign(cr, {
        w: cr.width,
        h: cr.height,
        minW: cr.minWidth,
        maxW: cr.maxWidth,
        minH: cr.minHeight,
        maxH: cr.maxHeight,
        overscroll: cr.overscrollBehavior,
        overscrollX: cr.overscrollBehaviorX,
        overscrollY: cr.overscrollBehaviorY
      });
      const fB = {
        filter: {
          transform: Be.filter
        },
        blur: N.blur("--chakra-blur"),
        brightness: N.propT("--chakra-brightness", Be.brightness),
        contrast: N.propT("--chakra-contrast", Be.contrast),
        hueRotate: N.propT("--chakra-hue-rotate", Be.hueRotate),
        invert: N.propT("--chakra-invert", Be.invert),
        saturate: N.propT("--chakra-saturate", Be.saturate),
        dropShadow: N.propT("--chakra-drop-shadow", Be.dropShadow),
        backdropFilter: {
          transform: Be.backdropFilter
        },
        backdropBlur: N.blur("--chakra-backdrop-blur"),
        backdropBrightness: N.propT("--chakra-backdrop-brightness", Be.brightness),
        backdropContrast: N.propT("--chakra-backdrop-contrast", Be.contrast),
        backdropHueRotate: N.propT("--chakra-backdrop-hue-rotate", Be.hueRotate),
        backdropInvert: N.propT("--chakra-backdrop-invert", Be.invert),
        backdropSaturate: N.propT("--chakra-backdrop-saturate", Be.saturate)
      }, hB = {
        ring: {
          transform: Be.ring
        },
        ringColor: N.colors("--chakra-ring-color"),
        ringOffset: N.prop("--chakra-ring-offset-width"),
        ringOffsetColor: N.colors("--chakra-ring-offset-color"),
        ringInset: N.prop("--chakra-ring-inset")
      }, dB = {
        appearance: true,
        cursor: true,
        resize: true,
        userSelect: true,
        pointerEvents: true,
        outline: {
          transform: Be.outline
        },
        outlineOffset: true,
        outlineColor: N.colors("outlineColor")
      }, wA = {
        gridGap: N.space("gridGap"),
        gridColumnGap: N.space("gridColumnGap"),
        gridRowGap: N.space("gridRowGap"),
        gridColumn: true,
        gridRow: true,
        gridAutoFlow: true,
        gridAutoColumns: true,
        gridColumnStart: true,
        gridColumnEnd: true,
        gridRowStart: true,
        gridRowEnd: true,
        gridAutoRows: true,
        gridTemplate: true,
        gridTemplateColumns: true,
        gridTemplateRows: true,
        gridTemplateAreas: true,
        gridArea: true
      };
      function pB(t, e, n, r) {
        const i = typeof e == "string" ? e.split(".") : [
          e
        ];
        for (r = 0; r < i.length && t; r += 1)
          t = t[i[r]];
        return t === void 0 ? n : t;
      }
      const mB = (t) => {
        const e = /* @__PURE__ */ new WeakMap();
        return (r, i, o, s) => {
          if (typeof r > "u")
            return t(r, i, o);
          e.has(r) || e.set(r, /* @__PURE__ */ new Map());
          const a = e.get(r);
          if (a.has(i))
            return a.get(i);
          const l = t(r, i, o, s);
          return a.set(i, l), l;
        };
      }, gB = mB(pB), vB = {
        border: "0px",
        clip: "rect(0, 0, 0, 0)",
        width: "1px",
        height: "1px",
        margin: "-1px",
        padding: "0px",
        overflow: "hidden",
        whiteSpace: "nowrap",
        position: "absolute"
      }, yB = {
        position: "static",
        width: "auto",
        height: "auto",
        clip: "auto",
        padding: "0",
        margin: "0",
        overflow: "visible",
        whiteSpace: "normal"
      }, Jg = (t, e, n) => {
        const r = {}, i = gB(t, e, {});
        for (const o in i)
          o in n && n[o] != null || (r[o] = i[o]);
        return r;
      }, bB = {
        srOnly: {
          transform(t) {
            return t === true ? vB : t === "focusable" ? yB : {};
          }
        },
        layerStyle: {
          processResult: true,
          transform: (t, e, n) => Jg(e, `layerStyles.${t}`, n)
        },
        textStyle: {
          processResult: true,
          transform: (t, e, n) => Jg(e, `textStyles.${t}`, n)
        },
        apply: {
          processResult: true,
          transform: (t, e, n) => Jg(e, t, n)
        }
      }, _c = {
        position: true,
        pos: N.prop("position"),
        zIndex: N.prop("zIndex", "zIndices"),
        inset: N.spaceT("inset"),
        insetX: N.spaceT([
          "left",
          "right"
        ]),
        insetInline: N.spaceT("insetInline"),
        insetY: N.spaceT([
          "top",
          "bottom"
        ]),
        insetBlock: N.spaceT("insetBlock"),
        top: N.spaceT("top"),
        insetBlockStart: N.spaceT("insetBlockStart"),
        bottom: N.spaceT("bottom"),
        insetBlockEnd: N.spaceT("insetBlockEnd"),
        left: N.spaceT("left"),
        insetInlineStart: N.logical({
          scale: "space",
          property: {
            ltr: "left",
            rtl: "right"
          }
        }),
        right: N.spaceT("right"),
        insetInlineEnd: N.logical({
          scale: "space",
          property: {
            ltr: "right",
            rtl: "left"
          }
        })
      };
      Object.assign(_c, {
        insetStart: _c.insetInlineStart,
        insetEnd: _c.insetInlineEnd
      });
      const ry = {
        boxShadow: N.shadows("boxShadow"),
        mixBlendMode: true,
        blendMode: N.prop("mixBlendMode"),
        backgroundBlendMode: true,
        bgBlendMode: N.prop("backgroundBlendMode"),
        opacity: true
      };
      Object.assign(ry, {
        shadow: ry.boxShadow
      });
      const st = {
        margin: N.spaceT("margin"),
        marginTop: N.spaceT("marginTop"),
        marginBlockStart: N.spaceT("marginBlockStart"),
        marginRight: N.spaceT("marginRight"),
        marginInlineEnd: N.spaceT("marginInlineEnd"),
        marginBottom: N.spaceT("marginBottom"),
        marginBlockEnd: N.spaceT("marginBlockEnd"),
        marginLeft: N.spaceT("marginLeft"),
        marginInlineStart: N.spaceT("marginInlineStart"),
        marginX: N.spaceT([
          "marginInlineStart",
          "marginInlineEnd"
        ]),
        marginInline: N.spaceT("marginInline"),
        marginY: N.spaceT([
          "marginTop",
          "marginBottom"
        ]),
        marginBlock: N.spaceT("marginBlock"),
        padding: N.space("padding"),
        paddingTop: N.space("paddingTop"),
        paddingBlockStart: N.space("paddingBlockStart"),
        paddingRight: N.space("paddingRight"),
        paddingBottom: N.space("paddingBottom"),
        paddingBlockEnd: N.space("paddingBlockEnd"),
        paddingLeft: N.space("paddingLeft"),
        paddingInlineStart: N.space("paddingInlineStart"),
        paddingInlineEnd: N.space("paddingInlineEnd"),
        paddingX: N.space([
          "paddingInlineStart",
          "paddingInlineEnd"
        ]),
        paddingInline: N.space("paddingInline"),
        paddingY: N.space([
          "paddingTop",
          "paddingBottom"
        ]),
        paddingBlock: N.space("paddingBlock")
      };
      Object.assign(st, {
        m: st.margin,
        mt: st.marginTop,
        mr: st.marginRight,
        me: st.marginInlineEnd,
        marginEnd: st.marginInlineEnd,
        mb: st.marginBottom,
        ml: st.marginLeft,
        ms: st.marginInlineStart,
        marginStart: st.marginInlineStart,
        mx: st.marginX,
        my: st.marginY,
        p: st.padding,
        pt: st.paddingTop,
        py: st.paddingY,
        px: st.paddingX,
        pb: st.paddingBottom,
        pl: st.paddingLeft,
        ps: st.paddingInlineStart,
        paddingStart: st.paddingInlineStart,
        pr: st.paddingRight,
        pe: st.paddingInlineEnd,
        paddingEnd: st.paddingInlineEnd
      });
      const xB = {
        scrollBehavior: true,
        scrollSnapAlign: true,
        scrollSnapStop: true,
        scrollSnapType: true,
        scrollMargin: N.spaceT("scrollMargin"),
        scrollMarginTop: N.spaceT("scrollMarginTop"),
        scrollMarginBottom: N.spaceT("scrollMarginBottom"),
        scrollMarginLeft: N.spaceT("scrollMarginLeft"),
        scrollMarginRight: N.spaceT("scrollMarginRight"),
        scrollMarginX: N.spaceT([
          "scrollMarginLeft",
          "scrollMarginRight"
        ]),
        scrollMarginY: N.spaceT([
          "scrollMarginTop",
          "scrollMarginBottom"
        ]),
        scrollPadding: N.spaceT("scrollPadding"),
        scrollPaddingTop: N.spaceT("scrollPaddingTop"),
        scrollPaddingBottom: N.spaceT("scrollPaddingBottom"),
        scrollPaddingLeft: N.spaceT("scrollPaddingLeft"),
        scrollPaddingRight: N.spaceT("scrollPaddingRight"),
        scrollPaddingX: N.spaceT([
          "scrollPaddingLeft",
          "scrollPaddingRight"
        ]),
        scrollPaddingY: N.spaceT([
          "scrollPaddingTop",
          "scrollPaddingBottom"
        ])
      }, SB = {
        fontFamily: N.prop("fontFamily", "fonts"),
        fontSize: N.prop("fontSize", "fontSizes", Be.px),
        fontWeight: N.prop("fontWeight", "fontWeights"),
        lineHeight: N.prop("lineHeight", "lineHeights"),
        letterSpacing: N.prop("letterSpacing", "letterSpacings"),
        textAlign: true,
        fontStyle: true,
        textIndent: true,
        wordBreak: true,
        overflowWrap: true,
        textOverflow: true,
        textTransform: true,
        whiteSpace: true,
        isTruncated: {
          transform(t) {
            if (t === true)
              return {
                overflow: "hidden",
                textOverflow: "ellipsis",
                whiteSpace: "nowrap"
              };
          }
        },
        noOfLines: {
          static: {
            overflow: "hidden",
            textOverflow: "ellipsis",
            display: "-webkit-box",
            WebkitBoxOrient: "vertical",
            WebkitLineClamp: "var(--chakra-line-clamp)"
          },
          property: "--chakra-line-clamp"
        }
      }, wB = {
        textDecorationColor: N.colors("textDecorationColor"),
        textDecoration: true,
        textDecor: {
          property: "textDecoration"
        },
        textDecorationLine: true,
        textDecorationStyle: true,
        textDecorationThickness: true,
        textUnderlineOffset: true,
        textShadow: N.shadows("textShadow")
      }, kB = {
        clipPath: true,
        transform: N.propT("transform", Be.transform),
        transformOrigin: true,
        translateX: N.spaceT("--chakra-translate-x"),
        translateY: N.spaceT("--chakra-translate-y"),
        skewX: N.degreeT("--chakra-skew-x"),
        skewY: N.degreeT("--chakra-skew-y"),
        scaleX: N.prop("--chakra-scale-x"),
        scaleY: N.prop("--chakra-scale-y"),
        scale: N.prop([
          "--chakra-scale-x",
          "--chakra-scale-y"
        ]),
        rotate: N.degreeT("--chakra-rotate")
      }, CB = {
        listStyleType: true,
        listStylePosition: true,
        listStylePos: N.prop("listStylePosition"),
        listStyleImage: true,
        listStyleImg: N.prop("listStyleImage")
      }, TB = {
        transition: true,
        transitionDelay: true,
        animation: true,
        willChange: true,
        transitionDuration: N.prop("transitionDuration", "transition.duration"),
        transitionProperty: N.prop("transitionProperty", "transition.property"),
        transitionTimingFunction: N.prop("transitionTimingFunction", "transition.easing")
      }, Ab = gi({}, td, We, uB, ep, cr, fB, hB, dB, wA, bB, _c, ry, st, xB, SB, wB, kB, CB, TB);
      Object.assign({}, st, cr, ep, wA, _c);
      const MB = [
        ...Object.keys(Ab),
        ...xA
      ], AB = {
        ...Ab,
        ...am
      }, EB = (t) => t in AB, PB = (t) => (e) => {
        if (!e.__breakpoints)
          return t;
        const { isResponsive: n, toArrayValue: r, media: i } = e.__breakpoints, o = {};
        for (const s in t) {
          let a = mi(t[s], e);
          if (a == null)
            continue;
          if (a = Vr(a) && n(a) ? r(a) : a, !Array.isArray(a)) {
            o[s] = a;
            continue;
          }
          const l = a.slice(0, i.length).length;
          for (let c = 0; c < l; c += 1) {
            const u = i == null ? void 0 : i[c];
            if (!u) {
              o[s] = a[c];
              continue;
            }
            o[u] = o[u] || {}, a[c] != null && (o[u][s] = a[c]);
          }
        }
        return o;
      };
      function OB(t) {
        const e = [];
        let n = "", r = false;
        for (let i = 0; i < t.length; i++) {
          const o = t[i];
          o === "(" ? (r = true, n += o) : o === ")" ? (r = false, n += o) : o === "," && !r ? (e.push(n), n = "") : n += o;
        }
        return n = n.trim(), n && e.push(n), e;
      }
      function RB(t) {
        return /^var\(--.+\)$/.test(t);
      }
      const LB = (t, e) => t.startsWith("--") && typeof e == "string" && !RB(e), DB = (t, e) => {
        if (e == null)
          return e;
        const n = (s) => {
          var _a3, _b3;
          return (_b3 = (_a3 = t.__cssMap) == null ? void 0 : _a3[s]) == null ? void 0 : _b3.varRef;
        }, r = (s) => n(s) ?? s, [i, o] = OB(e);
        return e = n(i) ?? r(o) ?? r(e), e;
      };
      function _B(t) {
        const { configs: e = {}, pseudos: n = {}, theme: r } = t, i = (o, s = false) => {
          var _a3;
          const a = mi(o, r), l = PB(a)(r);
          let c = {};
          for (let u in l) {
            const h = l[u];
            let p = mi(h, r);
            u in n && (u = n[u]), LB(u, p) && (p = DB(r, p));
            let v = e[u];
            if (v === true && (v = {
              property: u
            }), Vr(p)) {
              c[u] = c[u] ?? {}, c[u] = gi({}, c[u], i(p, true));
              continue;
            }
            let y = ((_a3 = v == null ? void 0 : v.transform) == null ? void 0 : _a3.call(v, p, r, a)) ?? p;
            y = (v == null ? void 0 : v.processResult) ? i(y, true) : y;
            const S = mi(v == null ? void 0 : v.property, r);
            if (!s && (v == null ? void 0 : v.static)) {
              const C = mi(v.static, r);
              c = gi({}, c, C);
            }
            if (S && Array.isArray(S)) {
              for (const C of S)
                c[C] = y;
              continue;
            }
            if (S) {
              S === "&" && Vr(y) ? c = gi({}, c, y) : c[S] = y;
              continue;
            }
            if (Vr(y)) {
              c = gi({}, c, y);
              continue;
            }
            c[u] = y;
          }
          return c;
        };
        return i;
      }
      const kA = (t) => (e) => _B({
        theme: e,
        pseudos: am,
        configs: Ab
      })(t);
      function it(t) {
        return {
          definePartsStyle(e) {
            return e;
          },
          defineMultiStyleConfig(e) {
            return {
              parts: t,
              ...e
            };
          }
        };
      }
      function IB(t, e) {
        if (Array.isArray(t))
          return t;
        if (Vr(t))
          return e(t);
        if (t != null)
          return [
            t
          ];
      }
      function BB(t, e) {
        for (let n = e + 1; n < t.length; n++)
          if (t[n] != null)
            return n;
        return -1;
      }
      function NB(t) {
        const e = t.__breakpoints;
        return function(r, i, o, s) {
          var _a3, _b3;
          if (!e)
            return;
          const a = {}, l = IB(o, e.toArrayValue);
          if (!l)
            return a;
          const c = l.length, u = c === 1, h = !!r.parts;
          for (let p = 0; p < c; p++) {
            const v = e.details[p], y = e.details[BB(l, p)], S = dc(v.minW, y == null ? void 0 : y._minW), C = mi((_a3 = r[i]) == null ? void 0 : _a3[l[p]], s);
            if (!!C) {
              if (h) {
                (_b3 = r.parts) == null ? void 0 : _b3.forEach((w) => {
                  gi(a, {
                    [w]: u ? C[w] : {
                      [S]: C[w]
                    }
                  });
                });
                continue;
              }
              if (!h) {
                u ? gi(a, C) : a[S] = C;
                continue;
              }
              a[S] = C;
            }
          }
          return a;
        };
      }
      function $B(t) {
        return (e) => {
          const { variant: n, size: r, theme: i } = e, o = NB(i);
          return gi({}, mi(t.baseStyle ?? {}, e), o(t, "sizes", r, e), o(t, "variants", n, e));
        };
      }
      function lm(t) {
        return yA(t, [
          "styleConfig",
          "size",
          "variant",
          "colorScheme"
        ]);
      }
      function CA(t) {
        return Vr(t) && t.reference ? t.reference : String(t);
      }
      const cm = (t, ...e) => e.map(CA).join(` ${t} `).replace(/calc/g, ""), kw = (...t) => `calc(${cm("+", ...t)})`, Cw = (...t) => `calc(${cm("-", ...t)})`, iy = (...t) => `calc(${cm("*", ...t)})`, Tw = (...t) => `calc(${cm("/", ...t)})`, Mw = (t) => {
        const e = CA(t);
        return e != null && !Number.isNaN(parseFloat(e)) ? String(e).startsWith("-") ? String(e).slice(1) : `-${e}` : iy(e, -1);
      }, Ni = Object.assign((t) => ({
        add: (...e) => Ni(kw(t, ...e)),
        subtract: (...e) => Ni(Cw(t, ...e)),
        multiply: (...e) => Ni(iy(t, ...e)),
        divide: (...e) => Ni(Tw(t, ...e)),
        negate: () => Ni(Mw(t)),
        toString: () => t.toString()
      }), {
        add: kw,
        subtract: Cw,
        multiply: iy,
        divide: Tw,
        negate: Mw
      });
      function zB(t, e = "-") {
        return t.replace(/\s+/g, e);
      }
      function FB(t) {
        const e = zB(t.toString());
        return HB(VB(e));
      }
      function VB(t) {
        return t.includes("\\.") ? t : !Number.isInteger(parseFloat(t.toString())) ? t.replace(".", "\\.") : t;
      }
      function HB(t) {
        return t.replace(/[!-,/:-@[-^`{-~]/g, "\\$&");
      }
      function jB(t, e = "") {
        return [
          e,
          t
        ].filter(Boolean).join("-");
      }
      function WB(t, e) {
        return `var(${t}${e ? `, ${e}` : ""})`;
      }
      function UB(t, e = "") {
        return FB(`--${jB(t, e)}`);
      }
      function we(t, e, n) {
        const r = UB(t, n);
        return {
          variable: r,
          reference: WB(r, e)
        };
      }
      function KB(t, e) {
        const n = {};
        for (const r of e) {
          if (Array.isArray(r)) {
            const [i, o] = r;
            n[i] = we(`${t}-${i}`, o);
            continue;
          }
          n[r] = we(`${t}-${r}`);
        }
        return n;
      }
      const qB = [
        "colors",
        "borders",
        "borderWidths",
        "borderStyles",
        "fonts",
        "fontSizes",
        "fontWeights",
        "gradients",
        "letterSpacings",
        "lineHeights",
        "radii",
        "space",
        "shadows",
        "sizes",
        "zIndices",
        "transition",
        "blur",
        "breakpoints"
      ];
      function GB(t) {
        return HI(t, qB);
      }
      function YB(t) {
        return t.semanticTokens;
      }
      function XB(t) {
        const { __cssMap: e, __cssVars: n, __breakpoints: r, ...i } = t;
        return i;
      }
      function QB(t) {
        const e = GB(t), n = YB(t), r = (o) => xA.includes(o) || o === "default", i = {};
        return xw(e, (o, s) => {
          o != null && (i[s.join(".")] = {
            isSemantic: false,
            value: o
          });
        }), xw(n, (o, s) => {
          o != null && (i[s.join(".")] = {
            isSemantic: true,
            value: o
          });
        }, {
          stop: (o) => Object.keys(o).every(r)
        }), i;
      }
      function Aw(t, e) {
        return we(String(t).replace(/\./g, "-"), void 0, e);
      }
      function JB(t) {
        var _a3;
        const e = QB(t), n = (_a3 = t.config) == null ? void 0 : _a3.cssVarPrefix;
        let r = {};
        const i = {};
        function o(s, a) {
          const c = [
            String(s).split(".")[0],
            a
          ].join(".");
          if (!e[c])
            return a;
          const { reference: h } = Aw(c, n);
          return h;
        }
        for (const [s, a] of Object.entries(e)) {
          const { isSemantic: l, value: c } = a, { variable: u, reference: h } = Aw(s, n);
          if (!l) {
            if (s.startsWith("space")) {
              const v = s.split("."), [y, ...S] = v, C = `${y}.-${S.join(".")}`, w = Ni.negate(c), k = Ni.negate(h);
              i[C] = {
                value: w,
                var: u,
                varRef: k
              };
            }
            r[u] = c, i[s] = {
              value: c,
              var: u,
              varRef: h
            };
            continue;
          }
          const p = Vr(c) ? c : {
            default: c
          };
          r = gi(r, Object.entries(p).reduce((v, [y, S]) => {
            if (!S)
              return v;
            const C = o(s, `${S}`);
            if (y === "default")
              return v[u] = C, v;
            const w = (am == null ? void 0 : am[y]) ?? y;
            return v[w] = {
              [u]: C
            }, v;
          }, {})), i[s] = {
            value: h,
            var: u,
            varRef: h
          };
        }
        return {
          cssVars: r,
          cssMap: i
        };
      }
      function ZB(t) {
        const e = XB(t), { cssMap: n, cssVars: r } = JB(e);
        return Object.assign(e, {
          __cssVars: {
            ...{
              "--chakra-ring-inset": "var(--chakra-empty,/*!*/ /*!*/)",
              "--chakra-ring-offset-width": "0px",
              "--chakra-ring-offset-color": "#fff",
              "--chakra-ring-color": "rgba(66, 153, 225, 0.6)",
              "--chakra-ring-offset-shadow": "0 0 #0000",
              "--chakra-ring-shadow": "0 0 #0000",
              "--chakra-space-x-reverse": "0",
              "--chakra-space-y-reverse": "0"
            },
            ...r
          },
          __cssMap: n,
          __breakpoints: II(e.breakpoints)
        }), e;
      }
      function Ge(t, e = {}) {
        let n = false;
        function r() {
          if (!n) {
            n = true;
            return;
          }
          throw new Error("[anatomy] .part(...) should only be called once. Did you mean to use .extend(...) ?");
        }
        function i(...u) {
          r();
          for (const h of u)
            e[h] = l(h);
          return Ge(t, e);
        }
        function o(...u) {
          for (const h of u)
            h in e || (e[h] = l(h));
          return Ge(t, e);
        }
        function s() {
          return Object.fromEntries(Object.entries(e).map(([h, p]) => [
            h,
            p.selector
          ]));
        }
        function a() {
          return Object.fromEntries(Object.entries(e).map(([h, p]) => [
            h,
            p.className
          ]));
        }
        function l(u) {
          const v = `chakra-${([
            "container",
            "root"
          ].includes(u ?? "") ? [
            t
          ] : [
            t,
            u
          ]).filter(Boolean).join("__")}`;
          return {
            className: v,
            selector: `.${v}`,
            toString: () => u
          };
        }
        return {
          parts: i,
          toPart: l,
          extend: o,
          selectors: s,
          classnames: a,
          get keys() {
            return Object.keys(e);
          },
          __type: {}
        };
      }
      const eN = Ge("accordion").parts("root", "container", "button", "panel", "icon"), tN = Ge("alert").parts("title", "description", "container", "icon", "spinner"), nN = Ge("avatar").parts("label", "badge", "container", "excessLabel", "group"), rN = Ge("breadcrumb").parts("link", "item", "container", "separator");
      Ge("button").parts();
      const iN = Ge("checkbox").parts("control", "icon", "container", "label");
      Ge("progress").parts("track", "filledTrack", "label");
      const oN = Ge("drawer").parts("overlay", "dialogContainer", "dialog", "header", "closeButton", "body", "footer"), sN = Ge("editable").parts("preview", "input", "textarea"), aN = Ge("form").parts("container", "requiredIndicator", "helperText"), lN = Ge("formError").parts("text", "icon"), cN = Ge("input").parts("addon", "field", "element", "group"), uN = Ge("list").parts("container", "item", "icon"), fN = Ge("menu").parts("button", "list", "item", "groupTitle", "icon", "command", "divider"), hN = Ge("modal").parts("overlay", "dialogContainer", "dialog", "header", "closeButton", "body", "footer"), dN = Ge("numberinput").parts("root", "field", "stepperGroup", "stepper");
      Ge("pininput").parts("field");
      const pN = Ge("popover").parts("content", "header", "body", "footer", "popper", "arrow", "closeButton"), mN = Ge("progress").parts("label", "filledTrack", "track"), gN = Ge("radio").parts("container", "control", "label"), vN = Ge("select").parts("field", "icon"), yN = Ge("slider").parts("container", "track", "thumb", "filledTrack", "mark"), bN = Ge("stat").parts("container", "label", "helpText", "number", "icon"), xN = Ge("switch").parts("container", "track", "thumb", "label"), SN = Ge("table").parts("table", "thead", "tbody", "tr", "th", "td", "tfoot", "caption"), wN = Ge("tabs").parts("root", "tab", "tablist", "tabpanel", "tabpanels", "indicator"), kN = Ge("tag").parts("container", "label", "closeButton"), CN = Ge("card").parts("container", "header", "body", "footer");
      Ge("stepper").parts("stepper", "step", "title", "description", "indicator", "separator", "icon", "number");
      const { definePartsStyle: TN, defineMultiStyleConfig: MN } = it(eN.keys), AN = {
        borderTopWidth: "1px",
        borderColor: "inherit",
        _last: {
          borderBottomWidth: "1px"
        }
      }, EN = {
        transitionProperty: "common",
        transitionDuration: "normal",
        fontSize: "md",
        _focusVisible: {
          boxShadow: "outline"
        },
        _hover: {
          bg: "blackAlpha.50"
        },
        _disabled: {
          opacity: 0.4,
          cursor: "not-allowed"
        },
        px: "4",
        py: "2"
      }, PN = {
        pt: "2",
        px: "4",
        pb: "5"
      }, ON = {
        fontSize: "1.25em"
      }, RN = TN({
        container: AN,
        button: EN,
        panel: PN,
        icon: ON
      }), LN = MN({
        baseStyle: RN
      });
      function Ts(t, e, n) {
        return Math.min(Math.max(t, n), e);
      }
      class DN extends Error {
        constructor(e) {
          super(`Failed to parse color: "${e}"`);
        }
      }
      var pc = DN;
      function Eb(t) {
        if (typeof t != "string")
          throw new pc(t);
        if (t.trim().toLowerCase() === "transparent")
          return [
            0,
            0,
            0,
            0
          ];
        let e = t.trim();
        e = VN.test(t) ? BN(t) : t;
        const n = NN.exec(e);
        if (n) {
          const s = Array.from(n).slice(1);
          return [
            ...s.slice(0, 3).map((a) => parseInt(yu(a, 2), 16)),
            parseInt(yu(s[3] || "f", 2), 16) / 255
          ];
        }
        const r = $N.exec(e);
        if (r) {
          const s = Array.from(r).slice(1);
          return [
            ...s.slice(0, 3).map((a) => parseInt(a, 16)),
            parseInt(s[3] || "ff", 16) / 255
          ];
        }
        const i = zN.exec(e);
        if (i) {
          const s = Array.from(i).slice(1);
          return [
            ...s.slice(0, 3).map((a) => parseInt(a, 10)),
            parseFloat(s[3] || "1")
          ];
        }
        const o = FN.exec(e);
        if (o) {
          const [s, a, l, c] = Array.from(o).slice(1).map(parseFloat);
          if (Ts(0, 100, a) !== a)
            throw new pc(t);
          if (Ts(0, 100, l) !== l)
            throw new pc(t);
          return [
            ...HN(s, a, l),
            Number.isNaN(c) ? 1 : c
          ];
        }
        throw new pc(t);
      }
      function _N(t) {
        let e = 5381, n = t.length;
        for (; n; )
          e = e * 33 ^ t.charCodeAt(--n);
        return (e >>> 0) % 2341;
      }
      const Ew = (t) => parseInt(t.replace(/_/g, ""), 36), IN = "1q29ehhb 1n09sgk7 1kl1ekf_ _yl4zsno 16z9eiv3 1p29lhp8 _bd9zg04 17u0____ _iw9zhe5 _to73___ _r45e31e _7l6g016 _jh8ouiv _zn3qba8 1jy4zshs 11u87k0u 1ro9yvyo 1aj3xael 1gz9zjz0 _3w8l4xo 1bf1ekf_ _ke3v___ _4rrkb__ 13j776yz _646mbhl _nrjr4__ _le6mbhl 1n37ehkb _m75f91n _qj3bzfz 1939yygw 11i5z6x8 _1k5f8xs 1509441m 15t5lwgf _ae2th1n _tg1ugcv 1lp1ugcv 16e14up_ _h55rw7n _ny9yavn _7a11xb_ 1ih442g9 _pv442g9 1mv16xof 14e6y7tu 1oo9zkds 17d1cisi _4v9y70f _y98m8kc 1019pq0v 12o9zda8 _348j4f4 1et50i2o _8epa8__ _ts6senj 1o350i2o 1mi9eiuo 1259yrp0 1ln80gnw _632xcoy 1cn9zldc _f29edu4 1n490c8q _9f9ziet 1b94vk74 _m49zkct 1kz6s73a 1eu9dtog _q58s1rz 1dy9sjiq __u89jo3 _aj5nkwg _ld89jo3 13h9z6wx _qa9z2ii _l119xgq _bs5arju 1hj4nwk9 1qt4nwk9 1ge6wau6 14j9zlcw 11p1edc_ _ms1zcxe _439shk6 _jt9y70f _754zsow 1la40eju _oq5p___ _x279qkz 1fa5r3rv _yd2d9ip _424tcku _8y1di2_ _zi2uabw _yy7rn9h 12yz980_ __39ljp6 1b59zg0x _n39zfzp 1fy9zest _b33k___ _hp9wq92 1il50hz4 _io472ub _lj9z3eo 19z9ykg0 _8t8iu3a 12b9bl4a 1ak5yw0o _896v4ku _tb8k8lv _s59zi6t _c09ze0p 1lg80oqn 1id9z8wb _238nba5 1kq6wgdi _154zssg _tn3zk49 _da9y6tc 1sg7cv4f _r12jvtt 1gq5fmkz 1cs9rvci _lp9jn1c _xw1tdnb 13f9zje6 16f6973h _vo7ir40 _bt5arjf _rc45e4t _hr4e100 10v4e100 _hc9zke2 _w91egv_ _sj2r1kk 13c87yx8 _vqpds__ _ni8ggk8 _tj9yqfb 1ia2j4r4 _7x9b10u 1fc9ld4j 1eq9zldr _5j9lhpx _ez9zl6o _md61fzm".split(" ").reduce((t, e) => {
        const n = Ew(e.substring(0, 3)), r = Ew(e.substring(3)).toString(16);
        let i = "";
        for (let o = 0; o < 6 - r.length; o++)
          i += "0";
        return t[n] = `${i}${r}`, t;
      }, {});
      function BN(t) {
        const e = t.toLowerCase().trim(), n = IN[_N(e)];
        if (!n)
          throw new pc(t);
        return `#${n}`;
      }
      const yu = (t, e) => Array.from(Array(e)).map(() => t).join(""), NN = new RegExp(`^#${yu("([a-f0-9])", 3)}([a-f0-9])?$`, "i"), $N = new RegExp(`^#${yu("([a-f0-9]{2})", 3)}([a-f0-9]{2})?$`, "i"), zN = new RegExp(`^rgba?\\(\\s*(\\d+)\\s*${yu(",\\s*(\\d+)\\s*", 2)}(?:,\\s*([\\d.]+))?\\s*\\)$`, "i"), FN = /^hsla?\(\s*([\d.]+)\s*,\s*([\d.]+)%\s*,\s*([\d.]+)%(?:\s*,\s*([\d.]+))?\s*\)$/i, VN = /^[a-z]+$/i, Pw = (t) => Math.round(t * 255), HN = (t, e, n) => {
        let r = n / 100;
        if (e === 0)
          return [
            r,
            r,
            r
          ].map(Pw);
        const i = (t % 360 + 360) % 360 / 60, o = (1 - Math.abs(2 * r - 1)) * (e / 100), s = o * (1 - Math.abs(i % 2 - 1));
        let a = 0, l = 0, c = 0;
        i >= 0 && i < 1 ? (a = o, l = s) : i >= 1 && i < 2 ? (a = s, l = o) : i >= 2 && i < 3 ? (l = o, c = s) : i >= 3 && i < 4 ? (l = s, c = o) : i >= 4 && i < 5 ? (a = s, c = o) : i >= 5 && i < 6 && (a = o, c = s);
        const u = r - o / 2, h = a + u, p = l + u, v = c + u;
        return [
          h,
          p,
          v
        ].map(Pw);
      };
      function jN(t, e, n, r) {
        return `rgba(${Ts(0, 255, t).toFixed()}, ${Ts(0, 255, e).toFixed()}, ${Ts(0, 255, n).toFixed()}, ${parseFloat(Ts(0, 1, r).toFixed(3))})`;
      }
      function WN(t, e) {
        const [n, r, i, o] = Eb(t);
        return jN(n, r, i, o - e);
      }
      function UN(t) {
        const [e, n, r, i] = Eb(t);
        let o = (s) => {
          const a = Ts(0, 255, s).toString(16);
          return a.length === 1 ? `0${a}` : a;
        };
        return `#${o(e)}${o(n)}${o(r)}${i < 1 ? o(Math.round(i * 255)) : ""}`;
      }
      const KN = (t) => Object.keys(t).length === 0;
      function qN(t, e, n, r, i) {
        for (e = e.split ? e.split(".") : e, r = 0; r < e.length; r++)
          t = t ? t[e[r]] : i;
        return t === i ? n : t;
      }
      const xn = (t, e, n) => {
        const r = qN(t, `colors.${e}`, e);
        try {
          return UN(r), r;
        } catch {
          return n ?? "#000000";
        }
      }, GN = (t) => {
        const [e, n, r] = Eb(t);
        return (e * 299 + n * 587 + r * 114) / 1e3;
      }, YN = (t) => (e) => {
        const n = xn(e, t);
        return GN(n) < 128 ? "dark" : "light";
      }, XN = (t) => (e) => YN(t)(e) === "dark", ol = (t, e) => (n) => {
        const r = xn(n, t);
        return WN(r, 1 - e);
      };
      function Ow(t = "1rem", e = "rgba(255, 255, 255, 0.15)") {
        return {
          backgroundImage: `linear-gradient(
    45deg,
    ${e} 25%,
    transparent 25%,
    transparent 50%,
    ${e} 50%,
    ${e} 75%,
    transparent 75%,
    transparent
  )`,
          backgroundSize: `${t} ${t}`
        };
      }
      const QN = () => `#${Math.floor(Math.random() * 16777215).toString(16).padEnd(6, "0")}`;
      function JN(t) {
        const e = QN();
        return !t || KN(t) ? e : t.string && t.colors ? e5(t.string, t.colors) : t.string && !t.colors ? ZN(t.string) : t.colors && !t.string ? t5(t.colors) : e;
      }
      function ZN(t) {
        let e = 0;
        if (t.length === 0)
          return e.toString();
        for (let r = 0; r < t.length; r += 1)
          e = t.charCodeAt(r) + ((e << 5) - e), e = e & e;
        let n = "#";
        for (let r = 0; r < 3; r += 1) {
          const i = e >> r * 8 & 255;
          n += `00${i.toString(16)}`.substr(-2);
        }
        return n;
      }
      function e5(t, e) {
        let n = 0;
        if (t.length === 0)
          return e[0];
        for (let r = 0; r < t.length; r += 1)
          n = t.charCodeAt(r) + ((n << 5) - n), n = n & n;
        return n = (n % e.length + e.length) % e.length, e[n];
      }
      function t5(t) {
        return t[Math.floor(Math.random() * t.length)];
      }
      function Se(t, e) {
        return (n) => n.colorMode === "dark" ? e : t;
      }
      function Pb(t) {
        const { orientation: e, vertical: n, horizontal: r } = t;
        return e ? e === "vertical" ? n : r : {};
      }
      function TA(t) {
        return Vr(t) && t.reference ? t.reference : String(t);
      }
      const um = (t, ...e) => e.map(TA).join(` ${t} `).replace(/calc/g, ""), Rw = (...t) => `calc(${um("+", ...t)})`, Lw = (...t) => `calc(${um("-", ...t)})`, oy = (...t) => `calc(${um("*", ...t)})`, Dw = (...t) => `calc(${um("/", ...t)})`, _w = (t) => {
        const e = TA(t);
        return e != null && !Number.isNaN(parseFloat(e)) ? String(e).startsWith("-") ? String(e).slice(1) : `-${e}` : oy(e, -1);
      }, $i = Object.assign((t) => ({
        add: (...e) => $i(Rw(t, ...e)),
        subtract: (...e) => $i(Lw(t, ...e)),
        multiply: (...e) => $i(oy(t, ...e)),
        divide: (...e) => $i(Dw(t, ...e)),
        negate: () => $i(_w(t)),
        toString: () => t.toString()
      }), {
        add: Rw,
        subtract: Lw,
        multiply: oy,
        divide: Dw,
        negate: _w
      });
      function n5(t) {
        return !Number.isInteger(parseFloat(t.toString()));
      }
      function r5(t, e = "-") {
        return t.replace(/\s+/g, e);
      }
      function MA(t) {
        const e = r5(t.toString());
        return e.includes("\\.") ? t : n5(t) ? e.replace(".", "\\.") : t;
      }
      function i5(t, e = "") {
        return [
          e,
          MA(t)
        ].filter(Boolean).join("-");
      }
      function o5(t, e) {
        return `var(${MA(t)}${e ? `, ${e}` : ""})`;
      }
      function s5(t, e = "") {
        return `--${i5(t, e)}`;
      }
      function Nt(t, e) {
        const n = s5(t, e == null ? void 0 : e.prefix);
        return {
          variable: n,
          reference: o5(n, a5(e == null ? void 0 : e.fallback))
        };
      }
      function a5(t) {
        return typeof t == "string" ? t : t == null ? void 0 : t.reference;
      }
      const { definePartsStyle: Yu, defineMultiStyleConfig: l5 } = it(tN.keys), Yn = we("alert-fg"), Ji = we("alert-bg"), c5 = Yu({
        container: {
          bg: Ji.reference,
          px: "4",
          py: "3"
        },
        title: {
          fontWeight: "bold",
          lineHeight: "6",
          marginEnd: "2"
        },
        description: {
          lineHeight: "6"
        },
        icon: {
          color: Yn.reference,
          flexShrink: 0,
          marginEnd: "3",
          w: "5",
          h: "6"
        },
        spinner: {
          color: Yn.reference,
          flexShrink: 0,
          marginEnd: "3",
          w: "5",
          h: "5"
        }
      });
      function Ob(t) {
        const { theme: e, colorScheme: n } = t, r = ol(`${n}.200`, 0.16)(e);
        return {
          light: `colors.${n}.100`,
          dark: r
        };
      }
      const u5 = Yu((t) => {
        const { colorScheme: e } = t, n = Ob(t);
        return {
          container: {
            [Yn.variable]: `colors.${e}.600`,
            [Ji.variable]: n.light,
            _dark: {
              [Yn.variable]: `colors.${e}.200`,
              [Ji.variable]: n.dark
            }
          }
        };
      }), f5 = Yu((t) => {
        const { colorScheme: e } = t, n = Ob(t);
        return {
          container: {
            [Yn.variable]: `colors.${e}.600`,
            [Ji.variable]: n.light,
            _dark: {
              [Yn.variable]: `colors.${e}.200`,
              [Ji.variable]: n.dark
            },
            paddingStart: "3",
            borderStartWidth: "4px",
            borderStartColor: Yn.reference
          }
        };
      }), h5 = Yu((t) => {
        const { colorScheme: e } = t, n = Ob(t);
        return {
          container: {
            [Yn.variable]: `colors.${e}.600`,
            [Ji.variable]: n.light,
            _dark: {
              [Yn.variable]: `colors.${e}.200`,
              [Ji.variable]: n.dark
            },
            pt: "2",
            borderTopWidth: "4px",
            borderTopColor: Yn.reference
          }
        };
      }), d5 = Yu((t) => {
        const { colorScheme: e } = t;
        return {
          container: {
            [Yn.variable]: "colors.white",
            [Ji.variable]: `colors.${e}.600`,
            _dark: {
              [Yn.variable]: "colors.gray.900",
              [Ji.variable]: `colors.${e}.200`
            },
            color: Yn.reference
          }
        };
      }), p5 = {
        subtle: u5,
        "left-accent": f5,
        "top-accent": h5,
        solid: d5
      }, m5 = l5({
        baseStyle: c5,
        variants: p5,
        defaultProps: {
          variant: "subtle",
          colorScheme: "blue"
        }
      }), AA = {
        px: "1px",
        0.5: "0.125rem",
        1: "0.25rem",
        1.5: "0.375rem",
        2: "0.5rem",
        2.5: "0.625rem",
        3: "0.75rem",
        3.5: "0.875rem",
        4: "1rem",
        5: "1.25rem",
        6: "1.5rem",
        7: "1.75rem",
        8: "2rem",
        9: "2.25rem",
        10: "2.5rem",
        12: "3rem",
        14: "3.5rem",
        16: "4rem",
        20: "5rem",
        24: "6rem",
        28: "7rem",
        32: "8rem",
        36: "9rem",
        40: "10rem",
        44: "11rem",
        48: "12rem",
        52: "13rem",
        56: "14rem",
        60: "15rem",
        64: "16rem",
        72: "18rem",
        80: "20rem",
        96: "24rem"
      }, g5 = {
        max: "max-content",
        min: "min-content",
        full: "100%",
        "3xs": "14rem",
        "2xs": "16rem",
        xs: "20rem",
        sm: "24rem",
        md: "28rem",
        lg: "32rem",
        xl: "36rem",
        "2xl": "42rem",
        "3xl": "48rem",
        "4xl": "56rem",
        "5xl": "64rem",
        "6xl": "72rem",
        "7xl": "80rem",
        "8xl": "90rem",
        prose: "60ch"
      }, v5 = {
        sm: "640px",
        md: "768px",
        lg: "1024px",
        xl: "1280px"
      }, EA = {
        ...AA,
        ...g5,
        container: v5
      }, y5 = (t) => typeof t == "function";
      function wn(t, ...e) {
        return y5(t) ? t(...e) : t;
      }
      const { definePartsStyle: PA, defineMultiStyleConfig: b5 } = it(nN.keys), Fa = we("avatar-border-color"), Ic = we("avatar-bg"), bu = we("avatar-font-size"), sl = we("avatar-size"), x5 = {
        borderRadius: "full",
        border: "0.2em solid",
        borderColor: Fa.reference,
        [Fa.variable]: "white",
        _dark: {
          [Fa.variable]: "colors.gray.800"
        }
      }, S5 = {
        bg: Ic.reference,
        fontSize: bu.reference,
        width: sl.reference,
        height: sl.reference,
        lineHeight: "1",
        [Ic.variable]: "colors.gray.200",
        _dark: {
          [Ic.variable]: "colors.whiteAlpha.400"
        }
      }, w5 = (t) => {
        const { name: e, theme: n } = t, r = e ? JN({
          string: e
        }) : "colors.gray.400", i = XN(r)(n);
        let o = "white";
        return i || (o = "gray.800"), {
          bg: Ic.reference,
          fontSize: bu.reference,
          color: o,
          borderColor: Fa.reference,
          verticalAlign: "top",
          width: sl.reference,
          height: sl.reference,
          "&:not([data-loaded])": {
            [Ic.variable]: r
          },
          [Fa.variable]: "colors.white",
          _dark: {
            [Fa.variable]: "colors.gray.800"
          }
        };
      }, k5 = {
        fontSize: bu.reference,
        lineHeight: "1"
      }, C5 = PA((t) => ({
        badge: wn(x5, t),
        excessLabel: wn(S5, t),
        container: wn(w5, t),
        label: k5
      }));
      function po(t) {
        const e = t !== "100%" ? EA[t] : void 0;
        return PA({
          container: {
            [sl.variable]: e ?? t,
            [bu.variable]: `calc(${e ?? t} / 2.5)`
          },
          excessLabel: {
            [sl.variable]: e ?? t,
            [bu.variable]: `calc(${e ?? t} / 2.5)`
          }
        });
      }
      const T5 = {
        "2xs": po(4),
        xs: po(6),
        sm: po(8),
        md: po(12),
        lg: po(16),
        xl: po(24),
        "2xl": po(32),
        full: po("100%")
      }, M5 = b5({
        baseStyle: C5,
        sizes: T5,
        defaultProps: {
          size: "md"
        }
      }), At = KB("badge", [
        "bg",
        "color",
        "shadow"
      ]), A5 = {
        px: 1,
        textTransform: "uppercase",
        fontSize: "xs",
        borderRadius: "sm",
        fontWeight: "bold",
        bg: At.bg.reference,
        color: At.color.reference,
        boxShadow: At.shadow.reference
      }, E5 = (t) => {
        const { colorScheme: e, theme: n } = t, r = ol(`${e}.500`, 0.6)(n);
        return {
          [At.bg.variable]: `colors.${e}.500`,
          [At.color.variable]: "colors.white",
          _dark: {
            [At.bg.variable]: r,
            [At.color.variable]: "colors.whiteAlpha.800"
          }
        };
      }, P5 = (t) => {
        const { colorScheme: e, theme: n } = t, r = ol(`${e}.200`, 0.16)(n);
        return {
          [At.bg.variable]: `colors.${e}.100`,
          [At.color.variable]: `colors.${e}.800`,
          _dark: {
            [At.bg.variable]: r,
            [At.color.variable]: `colors.${e}.200`
          }
        };
      }, O5 = (t) => {
        const { colorScheme: e, theme: n } = t, r = ol(`${e}.200`, 0.8)(n);
        return {
          [At.color.variable]: `colors.${e}.500`,
          _dark: {
            [At.color.variable]: r
          },
          [At.shadow.variable]: `inset 0 0 0px 1px ${At.color.reference}`
        };
      }, R5 = {
        solid: E5,
        subtle: P5,
        outline: O5
      }, Bc = {
        baseStyle: A5,
        variants: R5,
        defaultProps: {
          variant: "subtle",
          colorScheme: "gray"
        }
      }, { defineMultiStyleConfig: L5, definePartsStyle: D5 } = it(rN.keys), Zg = we("breadcrumb-link-decor"), _5 = {
        transitionProperty: "common",
        transitionDuration: "fast",
        transitionTimingFunction: "ease-out",
        outline: "none",
        color: "inherit",
        textDecoration: Zg.reference,
        [Zg.variable]: "none",
        "&:not([aria-current=page])": {
          cursor: "pointer",
          _hover: {
            [Zg.variable]: "underline"
          },
          _focusVisible: {
            boxShadow: "outline"
          }
        }
      }, I5 = D5({
        link: _5
      }), B5 = L5({
        baseStyle: I5
      }), N5 = {
        lineHeight: "1.2",
        borderRadius: "md",
        fontWeight: "semibold",
        transitionProperty: "common",
        transitionDuration: "normal",
        _focusVisible: {
          boxShadow: "outline"
        },
        _disabled: {
          opacity: 0.4,
          cursor: "not-allowed",
          boxShadow: "none"
        },
        _hover: {
          _disabled: {
            bg: "initial"
          }
        }
      }, OA = (t) => {
        const { colorScheme: e, theme: n } = t;
        if (e === "gray")
          return {
            color: Se("gray.800", "whiteAlpha.900")(t),
            _hover: {
              bg: Se("gray.100", "whiteAlpha.200")(t)
            },
            _active: {
              bg: Se("gray.200", "whiteAlpha.300")(t)
            }
          };
        const r = ol(`${e}.200`, 0.12)(n), i = ol(`${e}.200`, 0.24)(n);
        return {
          color: Se(`${e}.600`, `${e}.200`)(t),
          bg: "transparent",
          _hover: {
            bg: Se(`${e}.50`, r)(t)
          },
          _active: {
            bg: Se(`${e}.100`, i)(t)
          }
        };
      }, $5 = (t) => {
        const { colorScheme: e } = t, n = Se("gray.200", "whiteAlpha.300")(t);
        return {
          border: "1px solid",
          borderColor: e === "gray" ? n : "currentColor",
          ".chakra-button__group[data-attached][data-orientation=horizontal] > &:not(:last-of-type)": {
            marginEnd: "-1px"
          },
          ".chakra-button__group[data-attached][data-orientation=vertical] > &:not(:last-of-type)": {
            marginBottom: "-1px"
          },
          ...wn(OA, t)
        };
      }, z5 = {
        yellow: {
          bg: "yellow.400",
          color: "black",
          hoverBg: "yellow.500",
          activeBg: "yellow.600"
        },
        cyan: {
          bg: "cyan.400",
          color: "black",
          hoverBg: "cyan.500",
          activeBg: "cyan.600"
        }
      }, F5 = (t) => {
        const { colorScheme: e } = t;
        if (e === "gray") {
          const a = Se("gray.100", "whiteAlpha.200")(t);
          return {
            bg: a,
            color: Se("gray.800", "whiteAlpha.900")(t),
            _hover: {
              bg: Se("gray.200", "whiteAlpha.300")(t),
              _disabled: {
                bg: a
              }
            },
            _active: {
              bg: Se("gray.300", "whiteAlpha.400")(t)
            }
          };
        }
        const { bg: n = `${e}.500`, color: r = "white", hoverBg: i = `${e}.600`, activeBg: o = `${e}.700` } = z5[e] ?? {}, s = Se(n, `${e}.200`)(t);
        return {
          bg: s,
          color: Se(r, "gray.800")(t),
          _hover: {
            bg: Se(i, `${e}.300`)(t),
            _disabled: {
              bg: s
            }
          },
          _active: {
            bg: Se(o, `${e}.400`)(t)
          }
        };
      }, V5 = (t) => {
        const { colorScheme: e } = t;
        return {
          padding: 0,
          height: "auto",
          lineHeight: "normal",
          verticalAlign: "baseline",
          color: Se(`${e}.500`, `${e}.200`)(t),
          _hover: {
            textDecoration: "underline",
            _disabled: {
              textDecoration: "none"
            }
          },
          _active: {
            color: Se(`${e}.700`, `${e}.500`)(t)
          }
        };
      }, H5 = {
        bg: "none",
        color: "inherit",
        display: "inline",
        lineHeight: "inherit",
        m: "0",
        p: "0"
      }, j5 = {
        ghost: OA,
        outline: $5,
        solid: F5,
        link: V5,
        unstyled: H5
      }, W5 = {
        lg: {
          h: "12",
          minW: "12",
          fontSize: "lg",
          px: "6"
        },
        md: {
          h: "10",
          minW: "10",
          fontSize: "md",
          px: "4"
        },
        sm: {
          h: "8",
          minW: "8",
          fontSize: "sm",
          px: "3"
        },
        xs: {
          h: "6",
          minW: "6",
          fontSize: "xs",
          px: "2"
        }
      }, U5 = {
        baseStyle: N5,
        variants: j5,
        sizes: W5,
        defaultProps: {
          variant: "solid",
          size: "md",
          colorScheme: "gray"
        }
      }, { definePartsStyle: Rs, defineMultiStyleConfig: K5 } = it(CN.keys), tp = we("card-bg"), Ki = we("card-padding"), RA = we("card-shadow"), nd = we("card-radius"), LA = we("card-border-width", "0"), DA = we("card-border-color"), q5 = Rs({
        container: {
          [tp.variable]: "colors.chakra-body-bg",
          backgroundColor: tp.reference,
          boxShadow: RA.reference,
          borderRadius: nd.reference,
          color: "chakra-body-text",
          borderWidth: LA.reference,
          borderColor: DA.reference
        },
        body: {
          padding: Ki.reference,
          flex: "1 1 0%"
        },
        header: {
          padding: Ki.reference
        },
        footer: {
          padding: Ki.reference
        }
      }), G5 = {
        sm: Rs({
          container: {
            [nd.variable]: "radii.base",
            [Ki.variable]: "space.3"
          }
        }),
        md: Rs({
          container: {
            [nd.variable]: "radii.md",
            [Ki.variable]: "space.5"
          }
        }),
        lg: Rs({
          container: {
            [nd.variable]: "radii.xl",
            [Ki.variable]: "space.7"
          }
        })
      }, Y5 = {
        elevated: Rs({
          container: {
            [RA.variable]: "shadows.base",
            _dark: {
              [tp.variable]: "colors.gray.700"
            }
          }
        }),
        outline: Rs({
          container: {
            [LA.variable]: "1px",
            [DA.variable]: "colors.chakra-border-color"
          }
        }),
        filled: Rs({
          container: {
            [tp.variable]: "colors.chakra-subtle-bg"
          }
        }),
        unstyled: {
          body: {
            [Ki.variable]: 0
          },
          header: {
            [Ki.variable]: 0
          },
          footer: {
            [Ki.variable]: 0
          }
        }
      }, X5 = K5({
        baseStyle: q5,
        variants: Y5,
        sizes: G5,
        defaultProps: {
          variant: "elevated",
          size: "md"
        }
      }), { definePartsStyle: rd, defineMultiStyleConfig: Q5 } = it(iN.keys), Nc = we("checkbox-size"), J5 = (t) => {
        const { colorScheme: e } = t;
        return {
          w: Nc.reference,
          h: Nc.reference,
          transitionProperty: "box-shadow",
          transitionDuration: "normal",
          border: "2px solid",
          borderRadius: "sm",
          borderColor: "inherit",
          color: "white",
          _checked: {
            bg: Se(`${e}.500`, `${e}.200`)(t),
            borderColor: Se(`${e}.500`, `${e}.200`)(t),
            color: Se("white", "gray.900")(t),
            _hover: {
              bg: Se(`${e}.600`, `${e}.300`)(t),
              borderColor: Se(`${e}.600`, `${e}.300`)(t)
            },
            _disabled: {
              borderColor: Se("gray.200", "transparent")(t),
              bg: Se("gray.200", "whiteAlpha.300")(t),
              color: Se("gray.500", "whiteAlpha.500")(t)
            }
          },
          _indeterminate: {
            bg: Se(`${e}.500`, `${e}.200`)(t),
            borderColor: Se(`${e}.500`, `${e}.200`)(t),
            color: Se("white", "gray.900")(t)
          },
          _disabled: {
            bg: Se("gray.100", "whiteAlpha.100")(t),
            borderColor: Se("gray.100", "transparent")(t)
          },
          _focusVisible: {
            boxShadow: "outline"
          },
          _invalid: {
            borderColor: Se("red.500", "red.300")(t)
          }
        };
      }, Z5 = {
        _disabled: {
          cursor: "not-allowed"
        }
      }, e$ = {
        userSelect: "none",
        _disabled: {
          opacity: 0.4
        }
      }, t$ = {
        transitionProperty: "transform",
        transitionDuration: "normal"
      }, n$ = rd((t) => ({
        icon: t$,
        container: Z5,
        control: wn(J5, t),
        label: e$
      })), r$ = {
        sm: rd({
          control: {
            [Nc.variable]: "sizes.3"
          },
          label: {
            fontSize: "sm"
          },
          icon: {
            fontSize: "3xs"
          }
        }),
        md: rd({
          control: {
            [Nc.variable]: "sizes.4"
          },
          label: {
            fontSize: "md"
          },
          icon: {
            fontSize: "2xs"
          }
        }),
        lg: rd({
          control: {
            [Nc.variable]: "sizes.5"
          },
          label: {
            fontSize: "lg"
          },
          icon: {
            fontSize: "2xs"
          }
        })
      }, np = Q5({
        baseStyle: n$,
        sizes: r$,
        defaultProps: {
          size: "md",
          colorScheme: "blue"
        }
      }), $c = Nt("close-button-size"), Ql = Nt("close-button-bg"), i$ = {
        w: [
          $c.reference
        ],
        h: [
          $c.reference
        ],
        borderRadius: "md",
        transitionProperty: "common",
        transitionDuration: "normal",
        _disabled: {
          opacity: 0.4,
          cursor: "not-allowed",
          boxShadow: "none"
        },
        _hover: {
          [Ql.variable]: "colors.blackAlpha.100",
          _dark: {
            [Ql.variable]: "colors.whiteAlpha.100"
          }
        },
        _active: {
          [Ql.variable]: "colors.blackAlpha.200",
          _dark: {
            [Ql.variable]: "colors.whiteAlpha.200"
          }
        },
        _focusVisible: {
          boxShadow: "outline"
        },
        bg: Ql.reference
      }, o$ = {
        lg: {
          [$c.variable]: "sizes.10",
          fontSize: "md"
        },
        md: {
          [$c.variable]: "sizes.8",
          fontSize: "xs"
        },
        sm: {
          [$c.variable]: "sizes.6",
          fontSize: "2xs"
        }
      }, s$ = {
        baseStyle: i$,
        sizes: o$,
        defaultProps: {
          size: "md"
        }
      }, { variants: a$, defaultProps: l$ } = Bc, c$ = {
        fontFamily: "mono",
        fontSize: "sm",
        px: "0.2em",
        borderRadius: "sm",
        bg: At.bg.reference,
        color: At.color.reference,
        boxShadow: At.shadow.reference
      }, u$ = {
        baseStyle: c$,
        variants: a$,
        defaultProps: l$
      }, f$ = {
        w: "100%",
        mx: "auto",
        maxW: "prose",
        px: "4"
      }, h$ = {
        baseStyle: f$
      }, d$ = {
        opacity: 0.6,
        borderColor: "inherit"
      }, p$ = {
        borderStyle: "solid"
      }, m$ = {
        borderStyle: "dashed"
      }, g$ = {
        solid: p$,
        dashed: m$
      }, v$ = {
        baseStyle: d$,
        variants: g$,
        defaultProps: {
          variant: "solid"
        }
      }, { definePartsStyle: sy, defineMultiStyleConfig: y$ } = it(oN.keys), e0 = we("drawer-bg"), t0 = we("drawer-box-shadow");
      function aa(t) {
        return sy(t === "full" ? {
          dialog: {
            maxW: "100vw",
            h: "100vh"
          }
        } : {
          dialog: {
            maxW: t
          }
        });
      }
      const b$ = {
        bg: "blackAlpha.600",
        zIndex: "modal"
      }, x$ = {
        display: "flex",
        zIndex: "modal",
        justifyContent: "center"
      }, S$ = (t) => {
        const { isFullHeight: e } = t;
        return {
          ...e && {
            height: "100vh"
          },
          zIndex: "modal",
          maxH: "100vh",
          color: "inherit",
          [e0.variable]: "colors.white",
          [t0.variable]: "shadows.lg",
          _dark: {
            [e0.variable]: "colors.gray.700",
            [t0.variable]: "shadows.dark-lg"
          },
          bg: e0.reference,
          boxShadow: t0.reference
        };
      }, w$ = {
        px: "6",
        py: "4",
        fontSize: "xl",
        fontWeight: "semibold"
      }, k$ = {
        position: "absolute",
        top: "2",
        insetEnd: "3"
      }, C$ = {
        px: "6",
        py: "2",
        flex: "1",
        overflow: "auto"
      }, T$ = {
        px: "6",
        py: "4"
      }, M$ = sy((t) => ({
        overlay: b$,
        dialogContainer: x$,
        dialog: wn(S$, t),
        header: w$,
        closeButton: k$,
        body: C$,
        footer: T$
      })), A$ = {
        xs: aa("xs"),
        sm: aa("md"),
        md: aa("lg"),
        lg: aa("2xl"),
        xl: aa("4xl"),
        full: aa("full")
      }, E$ = y$({
        baseStyle: M$,
        sizes: A$,
        defaultProps: {
          size: "xs"
        }
      }), { definePartsStyle: P$, defineMultiStyleConfig: O$ } = it(sN.keys), R$ = {
        borderRadius: "md",
        py: "1",
        transitionProperty: "common",
        transitionDuration: "normal"
      }, L$ = {
        borderRadius: "md",
        py: "1",
        transitionProperty: "common",
        transitionDuration: "normal",
        width: "full",
        _focusVisible: {
          boxShadow: "outline"
        },
        _placeholder: {
          opacity: 0.6
        }
      }, D$ = {
        borderRadius: "md",
        py: "1",
        transitionProperty: "common",
        transitionDuration: "normal",
        width: "full",
        _focusVisible: {
          boxShadow: "outline"
        },
        _placeholder: {
          opacity: 0.6
        }
      }, _$ = P$({
        preview: R$,
        input: L$,
        textarea: D$
      }), I$ = O$({
        baseStyle: _$
      }), { definePartsStyle: B$, defineMultiStyleConfig: N$ } = it(aN.keys), Va = we("form-control-color"), $$ = {
        marginStart: "1",
        [Va.variable]: "colors.red.500",
        _dark: {
          [Va.variable]: "colors.red.300"
        },
        color: Va.reference
      }, z$ = {
        mt: "2",
        [Va.variable]: "colors.gray.600",
        _dark: {
          [Va.variable]: "colors.whiteAlpha.600"
        },
        color: Va.reference,
        lineHeight: "normal",
        fontSize: "sm"
      }, F$ = B$({
        container: {
          width: "100%",
          position: "relative"
        },
        requiredIndicator: $$,
        helperText: z$
      }), V$ = N$({
        baseStyle: F$
      }), { definePartsStyle: H$, defineMultiStyleConfig: j$ } = it(lN.keys), Ha = we("form-error-color"), W$ = {
        [Ha.variable]: "colors.red.500",
        _dark: {
          [Ha.variable]: "colors.red.300"
        },
        color: Ha.reference,
        mt: "2",
        fontSize: "sm",
        lineHeight: "normal"
      }, U$ = {
        marginEnd: "0.5em",
        [Ha.variable]: "colors.red.500",
        _dark: {
          [Ha.variable]: "colors.red.300"
        },
        color: Ha.reference
      }, K$ = H$({
        text: W$,
        icon: U$
      }), q$ = j$({
        baseStyle: K$
      }), G$ = {
        fontSize: "md",
        marginEnd: "3",
        mb: "2",
        fontWeight: "medium",
        transitionProperty: "common",
        transitionDuration: "normal",
        opacity: 1,
        _disabled: {
          opacity: 0.4
        }
      }, Y$ = {
        baseStyle: G$
      }, X$ = {
        fontFamily: "heading",
        fontWeight: "bold"
      }, Q$ = {
        "4xl": {
          fontSize: [
            "6xl",
            null,
            "7xl"
          ],
          lineHeight: 1
        },
        "3xl": {
          fontSize: [
            "5xl",
            null,
            "6xl"
          ],
          lineHeight: 1
        },
        "2xl": {
          fontSize: [
            "4xl",
            null,
            "5xl"
          ],
          lineHeight: [
            1.2,
            null,
            1
          ]
        },
        xl: {
          fontSize: [
            "3xl",
            null,
            "4xl"
          ],
          lineHeight: [
            1.33,
            null,
            1.2
          ]
        },
        lg: {
          fontSize: [
            "2xl",
            null,
            "3xl"
          ],
          lineHeight: [
            1.33,
            null,
            1.2
          ]
        },
        md: {
          fontSize: "xl",
          lineHeight: 1.2
        },
        sm: {
          fontSize: "md",
          lineHeight: 1.2
        },
        xs: {
          fontSize: "sm",
          lineHeight: 1.2
        }
      }, J$ = {
        baseStyle: X$,
        sizes: Q$,
        defaultProps: {
          size: "xl"
        }
      }, { definePartsStyle: Wi, defineMultiStyleConfig: Z$ } = it(cN.keys), Ca = we("input-height"), Ta = we("input-font-size"), Ma = we("input-padding"), Aa = we("input-border-radius"), e3 = Wi({
        addon: {
          height: Ca.reference,
          fontSize: Ta.reference,
          px: Ma.reference,
          borderRadius: Aa.reference
        },
        field: {
          width: "100%",
          height: Ca.reference,
          fontSize: Ta.reference,
          px: Ma.reference,
          borderRadius: Aa.reference,
          minWidth: 0,
          outline: 0,
          position: "relative",
          appearance: "none",
          transitionProperty: "common",
          transitionDuration: "normal",
          _disabled: {
            opacity: 0.4,
            cursor: "not-allowed"
          }
        }
      }), mo = {
        lg: {
          [Ta.variable]: "fontSizes.lg",
          [Ma.variable]: "space.4",
          [Aa.variable]: "radii.md",
          [Ca.variable]: "sizes.12"
        },
        md: {
          [Ta.variable]: "fontSizes.md",
          [Ma.variable]: "space.4",
          [Aa.variable]: "radii.md",
          [Ca.variable]: "sizes.10"
        },
        sm: {
          [Ta.variable]: "fontSizes.sm",
          [Ma.variable]: "space.3",
          [Aa.variable]: "radii.sm",
          [Ca.variable]: "sizes.8"
        },
        xs: {
          [Ta.variable]: "fontSizes.xs",
          [Ma.variable]: "space.2",
          [Aa.variable]: "radii.sm",
          [Ca.variable]: "sizes.6"
        }
      }, t3 = {
        lg: Wi({
          field: mo.lg,
          group: mo.lg
        }),
        md: Wi({
          field: mo.md,
          group: mo.md
        }),
        sm: Wi({
          field: mo.sm,
          group: mo.sm
        }),
        xs: Wi({
          field: mo.xs,
          group: mo.xs
        })
      };
      function Rb(t) {
        const { focusBorderColor: e, errorBorderColor: n } = t;
        return {
          focusBorderColor: e || Se("blue.500", "blue.300")(t),
          errorBorderColor: n || Se("red.500", "red.300")(t)
        };
      }
      const n3 = Wi((t) => {
        const { theme: e } = t, { focusBorderColor: n, errorBorderColor: r } = Rb(t);
        return {
          field: {
            border: "1px solid",
            borderColor: "inherit",
            bg: "inherit",
            _hover: {
              borderColor: Se("gray.300", "whiteAlpha.400")(t)
            },
            _readOnly: {
              boxShadow: "none !important",
              userSelect: "all"
            },
            _invalid: {
              borderColor: xn(e, r),
              boxShadow: `0 0 0 1px ${xn(e, r)}`
            },
            _focusVisible: {
              zIndex: 1,
              borderColor: xn(e, n),
              boxShadow: `0 0 0 1px ${xn(e, n)}`
            }
          },
          addon: {
            border: "1px solid",
            borderColor: Se("inherit", "whiteAlpha.50")(t),
            bg: Se("gray.100", "whiteAlpha.300")(t)
          }
        };
      }), r3 = Wi((t) => {
        const { theme: e } = t, { focusBorderColor: n, errorBorderColor: r } = Rb(t);
        return {
          field: {
            border: "2px solid",
            borderColor: "transparent",
            bg: Se("gray.100", "whiteAlpha.50")(t),
            _hover: {
              bg: Se("gray.200", "whiteAlpha.100")(t)
            },
            _readOnly: {
              boxShadow: "none !important",
              userSelect: "all"
            },
            _invalid: {
              borderColor: xn(e, r)
            },
            _focusVisible: {
              bg: "transparent",
              borderColor: xn(e, n)
            }
          },
          addon: {
            border: "2px solid",
            borderColor: "transparent",
            bg: Se("gray.100", "whiteAlpha.50")(t)
          }
        };
      }), i3 = Wi((t) => {
        const { theme: e } = t, { focusBorderColor: n, errorBorderColor: r } = Rb(t);
        return {
          field: {
            borderBottom: "1px solid",
            borderColor: "inherit",
            borderRadius: "0",
            px: "0",
            bg: "transparent",
            _readOnly: {
              boxShadow: "none !important",
              userSelect: "all"
            },
            _invalid: {
              borderColor: xn(e, r),
              boxShadow: `0px 1px 0px 0px ${xn(e, r)}`
            },
            _focusVisible: {
              borderColor: xn(e, n),
              boxShadow: `0px 1px 0px 0px ${xn(e, n)}`
            }
          },
          addon: {
            borderBottom: "2px solid",
            borderColor: "inherit",
            borderRadius: "0",
            px: "0",
            bg: "transparent"
          }
        };
      }), o3 = Wi({
        field: {
          bg: "transparent",
          px: "0",
          height: "auto"
        },
        addon: {
          bg: "transparent",
          px: "0",
          height: "auto"
        }
      }), s3 = {
        outline: n3,
        filled: r3,
        flushed: i3,
        unstyled: o3
      }, qe = Z$({
        baseStyle: e3,
        sizes: t3,
        variants: s3,
        defaultProps: {
          size: "md",
          variant: "outline"
        }
      }), n0 = we("kbd-bg"), a3 = {
        [n0.variable]: "colors.gray.100",
        _dark: {
          [n0.variable]: "colors.whiteAlpha.100"
        },
        bg: n0.reference,
        borderRadius: "md",
        borderWidth: "1px",
        borderBottomWidth: "3px",
        fontSize: "0.8em",
        fontWeight: "bold",
        lineHeight: "normal",
        px: "0.4em",
        whiteSpace: "nowrap"
      }, l3 = {
        baseStyle: a3
      }, c3 = {
        transitionProperty: "common",
        transitionDuration: "fast",
        transitionTimingFunction: "ease-out",
        cursor: "pointer",
        textDecoration: "none",
        outline: "none",
        color: "inherit",
        _hover: {
          textDecoration: "underline"
        },
        _focusVisible: {
          boxShadow: "outline"
        }
      }, u3 = {
        baseStyle: c3
      }, { defineMultiStyleConfig: f3, definePartsStyle: h3 } = it(uN.keys), d3 = {
        marginEnd: "2",
        display: "inline",
        verticalAlign: "text-bottom"
      }, p3 = h3({
        icon: d3
      }), m3 = f3({
        baseStyle: p3
      }), { defineMultiStyleConfig: g3, definePartsStyle: v3 } = it(fN.keys), ai = we("menu-bg"), r0 = we("menu-shadow"), y3 = {
        [ai.variable]: "#fff",
        [r0.variable]: "shadows.sm",
        _dark: {
          [ai.variable]: "colors.gray.700",
          [r0.variable]: "shadows.dark-lg"
        },
        color: "inherit",
        minW: "3xs",
        py: "2",
        zIndex: "dropdown",
        borderRadius: "md",
        borderWidth: "1px",
        bg: ai.reference,
        boxShadow: r0.reference
      }, b3 = {
        py: "1.5",
        px: "3",
        transitionProperty: "background",
        transitionDuration: "ultra-fast",
        transitionTimingFunction: "ease-in",
        _focus: {
          [ai.variable]: "colors.gray.100",
          _dark: {
            [ai.variable]: "colors.whiteAlpha.100"
          }
        },
        _active: {
          [ai.variable]: "colors.gray.200",
          _dark: {
            [ai.variable]: "colors.whiteAlpha.200"
          }
        },
        _expanded: {
          [ai.variable]: "colors.gray.100",
          _dark: {
            [ai.variable]: "colors.whiteAlpha.100"
          }
        },
        _disabled: {
          opacity: 0.4,
          cursor: "not-allowed"
        },
        bg: ai.reference
      }, x3 = {
        mx: 4,
        my: 2,
        fontWeight: "semibold",
        fontSize: "sm"
      }, S3 = {
        display: "inline-flex",
        alignItems: "center",
        justifyContent: "center",
        flexShrink: 0
      }, w3 = {
        opacity: 0.6
      }, k3 = {
        border: 0,
        borderBottom: "1px solid",
        borderColor: "inherit",
        my: "2",
        opacity: 0.6
      }, C3 = {
        transitionProperty: "common",
        transitionDuration: "normal"
      }, T3 = v3({
        button: C3,
        list: y3,
        item: b3,
        groupTitle: x3,
        icon: S3,
        command: w3,
        divider: k3
      }), M3 = g3({
        baseStyle: T3
      }), { defineMultiStyleConfig: A3, definePartsStyle: ay } = it(hN.keys), i0 = we("modal-bg"), o0 = we("modal-shadow"), E3 = {
        bg: "blackAlpha.600",
        zIndex: "modal"
      }, P3 = (t) => {
        const { isCentered: e, scrollBehavior: n } = t;
        return {
          display: "flex",
          zIndex: "modal",
          justifyContent: "center",
          alignItems: e ? "center" : "flex-start",
          overflow: n === "inside" ? "hidden" : "auto",
          overscrollBehaviorY: "none"
        };
      }, O3 = (t) => {
        const { isCentered: e, scrollBehavior: n } = t;
        return {
          borderRadius: "md",
          color: "inherit",
          my: e ? "auto" : "16",
          mx: e ? "auto" : void 0,
          zIndex: "modal",
          maxH: n === "inside" ? "calc(100% - 7.5rem)" : void 0,
          [i0.variable]: "colors.white",
          [o0.variable]: "shadows.lg",
          _dark: {
            [i0.variable]: "colors.gray.700",
            [o0.variable]: "shadows.dark-lg"
          },
          bg: i0.reference,
          boxShadow: o0.reference
        };
      }, R3 = {
        px: "6",
        py: "4",
        fontSize: "xl",
        fontWeight: "semibold"
      }, L3 = {
        position: "absolute",
        top: "2",
        insetEnd: "3"
      }, D3 = (t) => {
        const { scrollBehavior: e } = t;
        return {
          px: "6",
          py: "2",
          flex: "1",
          overflow: e === "inside" ? "auto" : void 0
        };
      }, _3 = {
        px: "6",
        py: "4"
      }, I3 = ay((t) => ({
        overlay: E3,
        dialogContainer: wn(P3, t),
        dialog: wn(O3, t),
        header: R3,
        closeButton: L3,
        body: wn(D3, t),
        footer: _3
      }));
      function Rr(t) {
        return ay(t === "full" ? {
          dialog: {
            maxW: "100vw",
            minH: "$100vh",
            my: "0",
            borderRadius: "0"
          }
        } : {
          dialog: {
            maxW: t
          }
        });
      }
      const B3 = {
        xs: Rr("xs"),
        sm: Rr("sm"),
        md: Rr("md"),
        lg: Rr("lg"),
        xl: Rr("xl"),
        "2xl": Rr("2xl"),
        "3xl": Rr("3xl"),
        "4xl": Rr("4xl"),
        "5xl": Rr("5xl"),
        "6xl": Rr("6xl"),
        full: Rr("full")
      }, N3 = A3({
        baseStyle: I3,
        sizes: B3,
        defaultProps: {
          size: "md"
        }
      }), _A = {
        letterSpacings: {
          tighter: "-0.05em",
          tight: "-0.025em",
          normal: "0",
          wide: "0.025em",
          wider: "0.05em",
          widest: "0.1em"
        },
        lineHeights: {
          normal: "normal",
          none: 1,
          shorter: 1.25,
          short: 1.375,
          base: 1.5,
          tall: 1.625,
          taller: "2",
          3: ".75rem",
          4: "1rem",
          5: "1.25rem",
          6: "1.5rem",
          7: "1.75rem",
          8: "2rem",
          9: "2.25rem",
          10: "2.5rem"
        },
        fontWeights: {
          hairline: 100,
          thin: 200,
          light: 300,
          normal: 400,
          medium: 500,
          semibold: 600,
          bold: 700,
          extrabold: 800,
          black: 900
        },
        fonts: {
          heading: '-apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol"',
          body: '-apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol"',
          mono: 'SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace'
        },
        fontSizes: {
          "3xs": "0.45rem",
          "2xs": "0.625rem",
          xs: "0.75rem",
          sm: "0.875rem",
          md: "1rem",
          lg: "1.125rem",
          xl: "1.25rem",
          "2xl": "1.5rem",
          "3xl": "1.875rem",
          "4xl": "2.25rem",
          "5xl": "3rem",
          "6xl": "3.75rem",
          "7xl": "4.5rem",
          "8xl": "6rem",
          "9xl": "8rem"
        }
      }, { defineMultiStyleConfig: $3, definePartsStyle: IA } = it(dN.keys), Lb = Nt("number-input-stepper-width"), BA = Nt("number-input-input-padding"), z3 = $i(Lb).add("0.5rem").toString(), s0 = Nt("number-input-bg"), a0 = Nt("number-input-color"), l0 = Nt("number-input-border-color"), F3 = {
        [Lb.variable]: "sizes.6",
        [BA.variable]: z3
      }, V3 = (t) => {
        var _a3;
        return ((_a3 = wn(qe.baseStyle, t)) == null ? void 0 : _a3.field) ?? {};
      }, H3 = {
        width: Lb.reference
      }, j3 = {
        borderStart: "1px solid",
        borderStartColor: l0.reference,
        color: a0.reference,
        bg: s0.reference,
        [a0.variable]: "colors.chakra-body-text",
        [l0.variable]: "colors.chakra-border-color",
        _dark: {
          [a0.variable]: "colors.whiteAlpha.800",
          [l0.variable]: "colors.whiteAlpha.300"
        },
        _active: {
          [s0.variable]: "colors.gray.200",
          _dark: {
            [s0.variable]: "colors.whiteAlpha.300"
          }
        },
        _disabled: {
          opacity: 0.4,
          cursor: "not-allowed"
        }
      }, W3 = IA((t) => ({
        root: F3,
        field: wn(V3, t) ?? {},
        stepperGroup: H3,
        stepper: j3
      }));
      function rh(t) {
        var _a3, _b3;
        const e = (_a3 = qe.sizes) == null ? void 0 : _a3[t], n = {
          lg: "md",
          md: "md",
          sm: "sm",
          xs: "sm"
        }, r = ((_b3 = e.field) == null ? void 0 : _b3.fontSize) ?? "md", i = _A.fontSizes[r];
        return IA({
          field: {
            ...e.field,
            paddingInlineEnd: BA.reference,
            verticalAlign: "top"
          },
          stepper: {
            fontSize: $i(i).multiply(0.75).toString(),
            _first: {
              borderTopEndRadius: n[t]
            },
            _last: {
              borderBottomEndRadius: n[t],
              mt: "-1px",
              borderTopWidth: 1
            }
          }
        });
      }
      const U3 = {
        xs: rh("xs"),
        sm: rh("sm"),
        md: rh("md"),
        lg: rh("lg")
      }, K3 = $3({
        baseStyle: W3,
        sizes: U3,
        variants: qe.variants,
        defaultProps: qe.defaultProps
      }), q3 = {
        ...(_a2 = qe.baseStyle) == null ? void 0 : _a2.field,
        textAlign: "center"
      }, G3 = {
        lg: {
          fontSize: "lg",
          w: 12,
          h: 12,
          borderRadius: "md"
        },
        md: {
          fontSize: "md",
          w: 10,
          h: 10,
          borderRadius: "md"
        },
        sm: {
          fontSize: "sm",
          w: 8,
          h: 8,
          borderRadius: "sm"
        },
        xs: {
          fontSize: "xs",
          w: 6,
          h: 6,
          borderRadius: "sm"
        }
      }, Y3 = {
        outline: (t) => {
          var _a3, _b3;
          return ((_b3 = wn((_a3 = qe.variants) == null ? void 0 : _a3.outline, t)) == null ? void 0 : _b3.field) ?? {};
        },
        flushed: (t) => {
          var _a3, _b3;
          return ((_b3 = wn((_a3 = qe.variants) == null ? void 0 : _a3.flushed, t)) == null ? void 0 : _b3.field) ?? {};
        },
        filled: (t) => {
          var _a3, _b3;
          return ((_b3 = wn((_a3 = qe.variants) == null ? void 0 : _a3.filled, t)) == null ? void 0 : _b3.field) ?? {};
        },
        unstyled: ((_b2 = qe.variants) == null ? void 0 : _b2.unstyled.field) ?? {}
      }, X3 = {
        baseStyle: q3,
        sizes: G3,
        variants: Y3,
        defaultProps: qe.defaultProps
      }, { defineMultiStyleConfig: Q3, definePartsStyle: J3 } = it(pN.keys), ih = Nt("popper-bg"), Z3 = Nt("popper-arrow-bg"), Iw = Nt("popper-arrow-shadow-color"), ez = {
        zIndex: "popover"
      }, tz = {
        [ih.variable]: "colors.white",
        bg: ih.reference,
        [Z3.variable]: ih.reference,
        [Iw.variable]: "colors.gray.200",
        _dark: {
          [ih.variable]: "colors.gray.700",
          [Iw.variable]: "colors.whiteAlpha.300"
        },
        width: "xs",
        border: "1px solid",
        borderColor: "inherit",
        borderRadius: "md",
        boxShadow: "sm",
        zIndex: "inherit",
        _focusVisible: {
          outline: 0,
          boxShadow: "outline"
        }
      }, nz = {
        px: 3,
        py: 2,
        borderBottomWidth: "1px"
      }, rz = {
        px: 3,
        py: 2
      }, iz = {
        px: 3,
        py: 2,
        borderTopWidth: "1px"
      }, oz = {
        position: "absolute",
        borderRadius: "md",
        top: 1,
        insetEnd: 2,
        padding: 2
      }, sz = J3({
        popper: ez,
        content: tz,
        header: nz,
        body: rz,
        footer: iz,
        closeButton: oz
      }), az = Q3({
        baseStyle: sz
      }), { defineMultiStyleConfig: lz, definePartsStyle: mc } = it(mN.keys), cz = (t) => {
        const { colorScheme: e, theme: n, isIndeterminate: r, hasStripe: i } = t, o = Se(Ow(), Ow("1rem", "rgba(0,0,0,0.1)"))(t), s = Se(`${e}.500`, `${e}.200`)(t), a = `linear-gradient(
    to right,
    transparent 0%,
    ${xn(n, s)} 50%,
    transparent 100%
  )`;
        return {
          ...!r && i && o,
          ...r ? {
            bgImage: a
          } : {
            bgColor: s
          }
        };
      }, uz = {
        lineHeight: "1",
        fontSize: "0.25em",
        fontWeight: "bold",
        color: "white"
      }, fz = (t) => ({
        bg: Se("gray.100", "whiteAlpha.300")(t)
      }), hz = (t) => ({
        transitionProperty: "common",
        transitionDuration: "slow",
        ...cz(t)
      }), dz = mc((t) => ({
        label: uz,
        filledTrack: hz(t),
        track: fz(t)
      })), pz = {
        xs: mc({
          track: {
            h: "1"
          }
        }),
        sm: mc({
          track: {
            h: "2"
          }
        }),
        md: mc({
          track: {
            h: "3"
          }
        }),
        lg: mc({
          track: {
            h: "4"
          }
        })
      }, mz = lz({
        sizes: pz,
        baseStyle: dz,
        defaultProps: {
          size: "md",
          colorScheme: "blue"
        }
      }), { defineMultiStyleConfig: gz, definePartsStyle: id } = it(gN.keys), vz = (t) => {
        var _a3;
        const e = (_a3 = wn(np.baseStyle, t)) == null ? void 0 : _a3.control;
        return {
          ...e,
          borderRadius: "full",
          _checked: {
            ...e == null ? void 0 : e._checked,
            _before: {
              content: '""',
              display: "inline-block",
              pos: "relative",
              w: "50%",
              h: "50%",
              borderRadius: "50%",
              bg: "currentColor"
            }
          }
        };
      }, yz = id((t) => {
        var _a3, _b3;
        return {
          label: (_a3 = np.baseStyle) == null ? void 0 : _a3.call(np, t).label,
          container: (_b3 = np.baseStyle) == null ? void 0 : _b3.call(np, t).container,
          control: vz(t)
        };
      }), bz = {
        md: id({
          control: {
            w: "4",
            h: "4"
          },
          label: {
            fontSize: "md"
          }
        }),
        lg: id({
          control: {
            w: "5",
            h: "5"
          },
          label: {
            fontSize: "lg"
          }
        }),
        sm: id({
          control: {
            width: "3",
            height: "3"
          },
          label: {
            fontSize: "sm"
          }
        })
      }, xz = gz({
        baseStyle: yz,
        sizes: bz,
        defaultProps: {
          size: "md",
          colorScheme: "blue"
        }
      }), { defineMultiStyleConfig: Sz, definePartsStyle: wz } = it(vN.keys), oh = we("select-bg"), kz = {
        ...(_c2 = qe.baseStyle) == null ? void 0 : _c2.field,
        appearance: "none",
        paddingBottom: "1px",
        lineHeight: "normal",
        bg: oh.reference,
        [oh.variable]: "colors.white",
        _dark: {
          [oh.variable]: "colors.gray.700"
        },
        "> option, > optgroup": {
          bg: oh.reference
        }
      }, Cz = {
        width: "6",
        height: "100%",
        insetEnd: "2",
        position: "relative",
        color: "currentColor",
        fontSize: "xl",
        _disabled: {
          opacity: 0.5
        }
      }, Tz = wz({
        field: kz,
        icon: Cz
      }), sh = {
        paddingInlineEnd: "8"
      }, Mz = {
        lg: {
          ...(_d2 = qe.sizes) == null ? void 0 : _d2.lg,
          field: {
            ...(_e = qe.sizes) == null ? void 0 : _e.lg.field,
            ...sh
          }
        },
        md: {
          ...(_f = qe.sizes) == null ? void 0 : _f.md,
          field: {
            ...(_g2 = qe.sizes) == null ? void 0 : _g2.md.field,
            ...sh
          }
        },
        sm: {
          ...(_h2 = qe.sizes) == null ? void 0 : _h2.sm,
          field: {
            ...(_i2 = qe.sizes) == null ? void 0 : _i2.sm.field,
            ...sh
          }
        },
        xs: {
          ...(_j2 = qe.sizes) == null ? void 0 : _j2.xs,
          field: {
            ...(_k2 = qe.sizes) == null ? void 0 : _k2.xs.field,
            ...sh
          },
          icon: {
            insetEnd: "1"
          }
        }
      }, Az = Sz({
        baseStyle: Tz,
        sizes: Mz,
        variants: qe.variants,
        defaultProps: qe.defaultProps
      }), c0 = we("skeleton-start-color"), u0 = we("skeleton-end-color"), Ez = {
        [c0.variable]: "colors.gray.100",
        [u0.variable]: "colors.gray.400",
        _dark: {
          [c0.variable]: "colors.gray.800",
          [u0.variable]: "colors.gray.600"
        },
        background: c0.reference,
        borderColor: u0.reference,
        opacity: 0.7,
        borderRadius: "sm"
      }, Pz = {
        baseStyle: Ez
      }, f0 = we("skip-link-bg"), Oz = {
        borderRadius: "md",
        fontWeight: "semibold",
        _focusVisible: {
          boxShadow: "outline",
          padding: "4",
          position: "fixed",
          top: "6",
          insetStart: "6",
          [f0.variable]: "colors.white",
          _dark: {
            [f0.variable]: "colors.gray.700"
          },
          bg: f0.reference
        }
      }, Rz = {
        baseStyle: Oz
      }, { defineMultiStyleConfig: Lz, definePartsStyle: fm } = it(yN.keys), Vs = we("slider-thumb-size"), xu = we("slider-track-size"), To = we("slider-bg"), Dz = (t) => {
        const { orientation: e } = t;
        return {
          display: "inline-block",
          position: "relative",
          cursor: "pointer",
          _disabled: {
            opacity: 0.6,
            cursor: "default",
            pointerEvents: "none"
          },
          ...Pb({
            orientation: e,
            vertical: {
              h: "100%",
              px: Ni(Vs.reference).divide(2).toString()
            },
            horizontal: {
              w: "100%",
              py: Ni(Vs.reference).divide(2).toString()
            }
          })
        };
      }, _z = (t) => ({
        ...Pb({
          orientation: t.orientation,
          horizontal: {
            h: xu.reference
          },
          vertical: {
            w: xu.reference
          }
        }),
        overflow: "hidden",
        borderRadius: "sm",
        [To.variable]: "colors.gray.200",
        _dark: {
          [To.variable]: "colors.whiteAlpha.200"
        },
        _disabled: {
          [To.variable]: "colors.gray.300",
          _dark: {
            [To.variable]: "colors.whiteAlpha.300"
          }
        },
        bg: To.reference
      }), Iz = (t) => {
        const { orientation: e } = t;
        return {
          ...Pb({
            orientation: e,
            vertical: {
              left: "50%",
              transform: "translateX(-50%)",
              _active: {
                transform: "translateX(-50%) scale(1.15)"
              }
            },
            horizontal: {
              top: "50%",
              transform: "translateY(-50%)",
              _active: {
                transform: "translateY(-50%) scale(1.15)"
              }
            }
          }),
          w: Vs.reference,
          h: Vs.reference,
          display: "flex",
          alignItems: "center",
          justifyContent: "center",
          position: "absolute",
          outline: 0,
          zIndex: 1,
          borderRadius: "full",
          bg: "white",
          boxShadow: "base",
          border: "1px solid",
          borderColor: "transparent",
          transitionProperty: "transform",
          transitionDuration: "normal",
          _focusVisible: {
            boxShadow: "outline"
          },
          _disabled: {
            bg: "gray.300"
          }
        };
      }, Bz = (t) => {
        const { colorScheme: e } = t;
        return {
          width: "inherit",
          height: "inherit",
          [To.variable]: `colors.${e}.500`,
          _dark: {
            [To.variable]: `colors.${e}.200`
          },
          bg: To.reference
        };
      }, Nz = fm((t) => ({
        container: Dz(t),
        track: _z(t),
        thumb: Iz(t),
        filledTrack: Bz(t)
      })), $z = fm({
        container: {
          [Vs.variable]: "sizes.4",
          [xu.variable]: "sizes.1"
        }
      }), zz = fm({
        container: {
          [Vs.variable]: "sizes.3.5",
          [xu.variable]: "sizes.1"
        }
      }), Fz = fm({
        container: {
          [Vs.variable]: "sizes.2.5",
          [xu.variable]: "sizes.0.5"
        }
      }), Vz = {
        lg: $z,
        md: zz,
        sm: Fz
      }, Hz = Lz({
        baseStyle: Nz,
        sizes: Vz,
        defaultProps: {
          size: "md",
          colorScheme: "blue"
        }
      }), bs = Nt("spinner-size"), jz = {
        width: [
          bs.reference
        ],
        height: [
          bs.reference
        ]
      }, Wz = {
        xs: {
          [bs.variable]: "sizes.3"
        },
        sm: {
          [bs.variable]: "sizes.4"
        },
        md: {
          [bs.variable]: "sizes.6"
        },
        lg: {
          [bs.variable]: "sizes.8"
        },
        xl: {
          [bs.variable]: "sizes.12"
        }
      }, Uz = {
        baseStyle: jz,
        sizes: Wz,
        defaultProps: {
          size: "md"
        }
      }, { defineMultiStyleConfig: Kz, definePartsStyle: NA } = it(bN.keys), qz = {
        fontWeight: "medium"
      }, Gz = {
        opacity: 0.8,
        marginBottom: "2"
      }, Yz = {
        verticalAlign: "baseline",
        fontWeight: "semibold"
      }, Xz = {
        marginEnd: 1,
        w: "3.5",
        h: "3.5",
        verticalAlign: "middle"
      }, Qz = NA({
        container: {},
        label: qz,
        helpText: Gz,
        number: Yz,
        icon: Xz
      }), Jz = {
        md: NA({
          label: {
            fontSize: "sm"
          },
          helpText: {
            fontSize: "sm"
          },
          number: {
            fontSize: "2xl"
          }
        })
      }, Zz = Kz({
        baseStyle: Qz,
        sizes: Jz,
        defaultProps: {
          size: "md"
        }
      }), { defineMultiStyleConfig: e4, definePartsStyle: gc } = it([
        "stepper",
        "step",
        "title",
        "description",
        "indicator",
        "separator",
        "icon",
        "number"
      ]), zi = we("stepper-indicator-size"), Ea = we("stepper-icon-size"), Pa = we("stepper-title-font-size"), vc = we("stepper-description-font-size"), Jl = we("stepper-accent-color"), t4 = gc(({ colorScheme: t }) => ({
        stepper: {
          display: "flex",
          justifyContent: "space-between",
          gap: "4",
          "&[data-orientation=vertical]": {
            flexDirection: "column",
            alignItems: "flex-start"
          },
          "&[data-orientation=horizontal]": {
            flexDirection: "row",
            alignItems: "center"
          },
          [Jl.variable]: `colors.${t}.500`,
          _dark: {
            [Jl.variable]: `colors.${t}.200`
          }
        },
        title: {
          fontSize: Pa.reference,
          fontWeight: "medium"
        },
        description: {
          fontSize: vc.reference,
          color: "chakra-subtle-text"
        },
        number: {
          fontSize: Pa.reference
        },
        step: {
          flexShrink: 0,
          position: "relative",
          display: "flex",
          gap: "2",
          "&[data-orientation=horizontal]": {
            alignItems: "center"
          },
          flex: "1",
          "&:last-of-type:not([data-stretch])": {
            flex: "initial"
          }
        },
        icon: {
          flexShrink: 0,
          width: Ea.reference,
          height: Ea.reference
        },
        indicator: {
          flexShrink: 0,
          borderRadius: "full",
          width: zi.reference,
          height: zi.reference,
          display: "flex",
          justifyContent: "center",
          alignItems: "center",
          "&[data-status=active]": {
            borderWidth: "2px",
            borderColor: Jl.reference
          },
          "&[data-status=complete]": {
            bg: Jl.reference,
            color: "chakra-inverse-text"
          },
          "&[data-status=incomplete]": {
            borderWidth: "2px"
          }
        },
        separator: {
          bg: "chakra-border-color",
          flex: "1",
          "&[data-status=complete]": {
            bg: Jl.reference
          },
          "&[data-orientation=horizontal]": {
            width: "100%",
            height: "2px",
            marginStart: "2"
          },
          "&[data-orientation=vertical]": {
            width: "2px",
            position: "absolute",
            height: "100%",
            maxHeight: `calc(100% - ${zi.reference} - 8px)`,
            top: `calc(${zi.reference} + 4px)`,
            insetStart: `calc(${zi.reference} / 2 - 1px)`
          }
        }
      })), n4 = e4({
        baseStyle: t4,
        sizes: {
          xs: gc({
            stepper: {
              [zi.variable]: "sizes.4",
              [Ea.variable]: "sizes.3",
              [Pa.variable]: "fontSizes.xs",
              [vc.variable]: "fontSizes.xs"
            }
          }),
          sm: gc({
            stepper: {
              [zi.variable]: "sizes.6",
              [Ea.variable]: "sizes.4",
              [Pa.variable]: "fontSizes.sm",
              [vc.variable]: "fontSizes.xs"
            }
          }),
          md: gc({
            stepper: {
              [zi.variable]: "sizes.8",
              [Ea.variable]: "sizes.5",
              [Pa.variable]: "fontSizes.md",
              [vc.variable]: "fontSizes.sm"
            }
          }),
          lg: gc({
            stepper: {
              [zi.variable]: "sizes.10",
              [Ea.variable]: "sizes.6",
              [Pa.variable]: "fontSizes.lg",
              [vc.variable]: "fontSizes.md"
            }
          })
        },
        defaultProps: {
          size: "md",
          colorScheme: "blue"
        }
      }), { defineMultiStyleConfig: r4, definePartsStyle: od } = it(xN.keys), zc = Nt("switch-track-width"), Ls = Nt("switch-track-height"), h0 = Nt("switch-track-diff"), i4 = $i.subtract(zc, Ls), ly = Nt("switch-thumb-x"), Zl = Nt("switch-bg"), o4 = (t) => {
        const { colorScheme: e } = t;
        return {
          borderRadius: "full",
          p: "0.5",
          width: [
            zc.reference
          ],
          height: [
            Ls.reference
          ],
          transitionProperty: "common",
          transitionDuration: "fast",
          [Zl.variable]: "colors.gray.300",
          _dark: {
            [Zl.variable]: "colors.whiteAlpha.400"
          },
          _focusVisible: {
            boxShadow: "outline"
          },
          _disabled: {
            opacity: 0.4,
            cursor: "not-allowed"
          },
          _checked: {
            [Zl.variable]: `colors.${e}.500`,
            _dark: {
              [Zl.variable]: `colors.${e}.200`
            }
          },
          bg: Zl.reference
        };
      }, s4 = {
        bg: "white",
        transitionProperty: "transform",
        transitionDuration: "normal",
        borderRadius: "inherit",
        width: [
          Ls.reference
        ],
        height: [
          Ls.reference
        ],
        _checked: {
          transform: `translateX(${ly.reference})`
        }
      }, a4 = od((t) => ({
        container: {
          [h0.variable]: i4,
          [ly.variable]: h0.reference,
          _rtl: {
            [ly.variable]: $i(h0).negate().toString()
          }
        },
        track: o4(t),
        thumb: s4
      })), l4 = {
        sm: od({
          container: {
            [zc.variable]: "1.375rem",
            [Ls.variable]: "sizes.3"
          }
        }),
        md: od({
          container: {
            [zc.variable]: "1.875rem",
            [Ls.variable]: "sizes.4"
          }
        }),
        lg: od({
          container: {
            [zc.variable]: "2.875rem",
            [Ls.variable]: "sizes.6"
          }
        })
      }, c4 = r4({
        baseStyle: a4,
        sizes: l4,
        defaultProps: {
          size: "md",
          colorScheme: "blue"
        }
      }), { defineMultiStyleConfig: u4, definePartsStyle: ja } = it(SN.keys), f4 = ja({
        table: {
          fontVariantNumeric: "lining-nums tabular-nums",
          borderCollapse: "collapse",
          width: "full"
        },
        th: {
          fontFamily: "heading",
          fontWeight: "bold",
          textTransform: "uppercase",
          letterSpacing: "wider",
          textAlign: "start"
        },
        td: {
          textAlign: "start"
        },
        caption: {
          mt: 4,
          fontFamily: "heading",
          textAlign: "center",
          fontWeight: "medium"
        }
      }), rp = {
        "&[data-is-numeric=true]": {
          textAlign: "end"
        }
      }, h4 = ja((t) => {
        const { colorScheme: e } = t;
        return {
          th: {
            color: Se("gray.600", "gray.400")(t),
            borderBottom: "1px",
            borderColor: Se(`${e}.100`, `${e}.700`)(t),
            ...rp
          },
          td: {
            borderBottom: "1px",
            borderColor: Se(`${e}.100`, `${e}.700`)(t),
            ...rp
          },
          caption: {
            color: Se("gray.600", "gray.100")(t)
          },
          tfoot: {
            tr: {
              "&:last-of-type": {
                th: {
                  borderBottomWidth: 0
                }
              }
            }
          }
        };
      }), d4 = ja((t) => {
        const { colorScheme: e } = t;
        return {
          th: {
            color: Se("gray.600", "gray.400")(t),
            borderBottom: "1px",
            borderColor: Se(`${e}.100`, `${e}.700`)(t),
            ...rp
          },
          td: {
            borderBottom: "1px",
            borderColor: Se(`${e}.100`, `${e}.700`)(t),
            ...rp
          },
          caption: {
            color: Se("gray.600", "gray.100")(t)
          },
          tbody: {
            tr: {
              "&:nth-of-type(odd)": {
                "th, td": {
                  borderBottomWidth: "1px",
                  borderColor: Se(`${e}.100`, `${e}.700`)(t)
                },
                td: {
                  background: Se(`${e}.100`, `${e}.700`)(t)
                }
              }
            }
          },
          tfoot: {
            tr: {
              "&:last-of-type": {
                th: {
                  borderBottomWidth: 0
                }
              }
            }
          }
        };
      }), p4 = {
        simple: h4,
        striped: d4,
        unstyled: {}
      }, m4 = {
        sm: ja({
          th: {
            px: "4",
            py: "1",
            lineHeight: "4",
            fontSize: "xs"
          },
          td: {
            px: "4",
            py: "2",
            fontSize: "sm",
            lineHeight: "4"
          },
          caption: {
            px: "4",
            py: "2",
            fontSize: "xs"
          }
        }),
        md: ja({
          th: {
            px: "6",
            py: "3",
            lineHeight: "4",
            fontSize: "xs"
          },
          td: {
            px: "6",
            py: "4",
            lineHeight: "5"
          },
          caption: {
            px: "6",
            py: "2",
            fontSize: "sm"
          }
        }),
        lg: ja({
          th: {
            px: "8",
            py: "4",
            lineHeight: "5",
            fontSize: "sm"
          },
          td: {
            px: "8",
            py: "5",
            lineHeight: "6"
          },
          caption: {
            px: "6",
            py: "2",
            fontSize: "md"
          }
        })
      }, g4 = u4({
        baseStyle: f4,
        variants: p4,
        sizes: m4,
        defaultProps: {
          variant: "simple",
          size: "md",
          colorScheme: "gray"
        }
      }), _n = we("tabs-color"), Nr = we("tabs-bg"), ah = we("tabs-border-color"), { defineMultiStyleConfig: v4, definePartsStyle: xi } = it(wN.keys), y4 = (t) => {
        const { orientation: e } = t;
        return {
          display: e === "vertical" ? "flex" : "block"
        };
      }, b4 = (t) => {
        const { isFitted: e } = t;
        return {
          flex: e ? 1 : void 0,
          transitionProperty: "common",
          transitionDuration: "normal",
          _focusVisible: {
            zIndex: 1,
            boxShadow: "outline"
          },
          _disabled: {
            cursor: "not-allowed",
            opacity: 0.4
          }
        };
      }, x4 = (t) => {
        const { align: e = "start", orientation: n } = t;
        return {
          justifyContent: {
            end: "flex-end",
            center: "center",
            start: "flex-start"
          }[e],
          flexDirection: n === "vertical" ? "column" : "row"
        };
      }, S4 = {
        p: 4
      }, w4 = xi((t) => ({
        root: y4(t),
        tab: b4(t),
        tablist: x4(t),
        tabpanel: S4
      })), k4 = {
        sm: xi({
          tab: {
            py: 1,
            px: 4,
            fontSize: "sm"
          }
        }),
        md: xi({
          tab: {
            fontSize: "md",
            py: 2,
            px: 4
          }
        }),
        lg: xi({
          tab: {
            fontSize: "lg",
            py: 3,
            px: 4
          }
        })
      }, C4 = xi((t) => {
        const { colorScheme: e, orientation: n } = t, r = n === "vertical", i = r ? "borderStart" : "borderBottom", o = r ? "marginStart" : "marginBottom";
        return {
          tablist: {
            [i]: "2px solid",
            borderColor: "inherit"
          },
          tab: {
            [i]: "2px solid",
            borderColor: "transparent",
            [o]: "-2px",
            _selected: {
              [_n.variable]: `colors.${e}.600`,
              _dark: {
                [_n.variable]: `colors.${e}.300`
              },
              borderColor: "currentColor"
            },
            _active: {
              [Nr.variable]: "colors.gray.200",
              _dark: {
                [Nr.variable]: "colors.whiteAlpha.300"
              }
            },
            _disabled: {
              _active: {
                bg: "none"
              }
            },
            color: _n.reference,
            bg: Nr.reference
          }
        };
      }), T4 = xi((t) => {
        const { colorScheme: e } = t;
        return {
          tab: {
            borderTopRadius: "md",
            border: "1px solid",
            borderColor: "transparent",
            mb: "-1px",
            [ah.variable]: "transparent",
            _selected: {
              [_n.variable]: `colors.${e}.600`,
              [ah.variable]: "colors.white",
              _dark: {
                [_n.variable]: `colors.${e}.300`,
                [ah.variable]: "colors.gray.800"
              },
              borderColor: "inherit",
              borderBottomColor: ah.reference
            },
            color: _n.reference
          },
          tablist: {
            mb: "-1px",
            borderBottom: "1px solid",
            borderColor: "inherit"
          }
        };
      }), M4 = xi((t) => {
        const { colorScheme: e } = t;
        return {
          tab: {
            border: "1px solid",
            borderColor: "inherit",
            [Nr.variable]: "colors.gray.50",
            _dark: {
              [Nr.variable]: "colors.whiteAlpha.50"
            },
            mb: "-1px",
            _notLast: {
              marginEnd: "-1px"
            },
            _selected: {
              [Nr.variable]: "colors.white",
              [_n.variable]: `colors.${e}.600`,
              _dark: {
                [Nr.variable]: "colors.gray.800",
                [_n.variable]: `colors.${e}.300`
              },
              borderColor: "inherit",
              borderTopColor: "currentColor",
              borderBottomColor: "transparent"
            },
            color: _n.reference,
            bg: Nr.reference
          },
          tablist: {
            mb: "-1px",
            borderBottom: "1px solid",
            borderColor: "inherit"
          }
        };
      }), A4 = xi((t) => {
        const { colorScheme: e, theme: n } = t;
        return {
          tab: {
            borderRadius: "full",
            fontWeight: "semibold",
            color: "gray.600",
            _selected: {
              color: xn(n, `${e}.700`),
              bg: xn(n, `${e}.100`)
            }
          }
        };
      }), E4 = xi((t) => {
        const { colorScheme: e } = t;
        return {
          tab: {
            borderRadius: "full",
            fontWeight: "semibold",
            [_n.variable]: "colors.gray.600",
            _dark: {
              [_n.variable]: "inherit"
            },
            _selected: {
              [_n.variable]: "colors.white",
              [Nr.variable]: `colors.${e}.600`,
              _dark: {
                [_n.variable]: "colors.gray.800",
                [Nr.variable]: `colors.${e}.300`
              }
            },
            color: _n.reference,
            bg: Nr.reference
          }
        };
      }), P4 = xi({}), O4 = {
        line: C4,
        enclosed: T4,
        "enclosed-colored": M4,
        "soft-rounded": A4,
        "solid-rounded": E4,
        unstyled: P4
      }, R4 = v4({
        baseStyle: w4,
        sizes: k4,
        variants: O4,
        defaultProps: {
          size: "md",
          variant: "line",
          colorScheme: "blue"
        }
      }), { defineMultiStyleConfig: L4, definePartsStyle: Ds } = it(kN.keys), Bw = we("tag-bg"), Nw = we("tag-color"), d0 = we("tag-shadow"), sd = we("tag-min-height"), ad = we("tag-min-width"), ld = we("tag-font-size"), cd = we("tag-padding-inline"), D4 = {
        fontWeight: "medium",
        lineHeight: 1.2,
        outline: 0,
        [Nw.variable]: At.color.reference,
        [Bw.variable]: At.bg.reference,
        [d0.variable]: At.shadow.reference,
        color: Nw.reference,
        bg: Bw.reference,
        boxShadow: d0.reference,
        borderRadius: "md",
        minH: sd.reference,
        minW: ad.reference,
        fontSize: ld.reference,
        px: cd.reference,
        _focusVisible: {
          [d0.variable]: "shadows.outline"
        }
      }, _4 = {
        lineHeight: 1.2,
        overflow: "visible"
      }, I4 = {
        fontSize: "lg",
        w: "5",
        h: "5",
        transitionProperty: "common",
        transitionDuration: "normal",
        borderRadius: "full",
        marginStart: "1.5",
        marginEnd: "-1",
        opacity: 0.5,
        _disabled: {
          opacity: 0.4
        },
        _focusVisible: {
          boxShadow: "outline",
          bg: "rgba(0, 0, 0, 0.14)"
        },
        _hover: {
          opacity: 0.8
        },
        _active: {
          opacity: 1
        }
      }, B4 = Ds({
        container: D4,
        label: _4,
        closeButton: I4
      }), N4 = {
        sm: Ds({
          container: {
            [sd.variable]: "sizes.5",
            [ad.variable]: "sizes.5",
            [ld.variable]: "fontSizes.xs",
            [cd.variable]: "space.2"
          },
          closeButton: {
            marginEnd: "-2px",
            marginStart: "0.35rem"
          }
        }),
        md: Ds({
          container: {
            [sd.variable]: "sizes.6",
            [ad.variable]: "sizes.6",
            [ld.variable]: "fontSizes.sm",
            [cd.variable]: "space.2"
          }
        }),
        lg: Ds({
          container: {
            [sd.variable]: "sizes.8",
            [ad.variable]: "sizes.8",
            [ld.variable]: "fontSizes.md",
            [cd.variable]: "space.3"
          }
        })
      }, $4 = {
        subtle: Ds((t) => {
          var _a3;
          return {
            container: (_a3 = Bc.variants) == null ? void 0 : _a3.subtle(t)
          };
        }),
        solid: Ds((t) => {
          var _a3;
          return {
            container: (_a3 = Bc.variants) == null ? void 0 : _a3.solid(t)
          };
        }),
        outline: Ds((t) => {
          var _a3;
          return {
            container: (_a3 = Bc.variants) == null ? void 0 : _a3.outline(t)
          };
        })
      }, z4 = L4({
        variants: $4,
        baseStyle: B4,
        sizes: N4,
        defaultProps: {
          size: "md",
          variant: "subtle",
          colorScheme: "gray"
        }
      }), F4 = {
        ...(_l = qe.baseStyle) == null ? void 0 : _l.field,
        paddingY: "2",
        minHeight: "20",
        lineHeight: "short",
        verticalAlign: "top"
      }, V4 = {
        outline: (t) => {
          var _a3;
          return ((_a3 = qe.variants) == null ? void 0 : _a3.outline(t).field) ?? {};
        },
        flushed: (t) => {
          var _a3;
          return ((_a3 = qe.variants) == null ? void 0 : _a3.flushed(t).field) ?? {};
        },
        filled: (t) => {
          var _a3;
          return ((_a3 = qe.variants) == null ? void 0 : _a3.filled(t).field) ?? {};
        },
        unstyled: ((_m2 = qe.variants) == null ? void 0 : _m2.unstyled.field) ?? {}
      }, H4 = {
        xs: ((_n2 = qe.sizes) == null ? void 0 : _n2.xs.field) ?? {},
        sm: ((_o2 = qe.sizes) == null ? void 0 : _o2.sm.field) ?? {},
        md: ((_p2 = qe.sizes) == null ? void 0 : _p2.md.field) ?? {},
        lg: ((_q2 = qe.sizes) == null ? void 0 : _q2.lg.field) ?? {}
      }, j4 = {
        baseStyle: F4,
        sizes: H4,
        variants: V4,
        defaultProps: {
          size: "md",
          variant: "outline"
        }
      }, lh = Nt("tooltip-bg"), p0 = Nt("tooltip-fg"), W4 = Nt("popper-arrow-bg"), U4 = {
        bg: lh.reference,
        color: p0.reference,
        [lh.variable]: "colors.gray.700",
        [p0.variable]: "colors.whiteAlpha.900",
        _dark: {
          [lh.variable]: "colors.gray.300",
          [p0.variable]: "colors.gray.900"
        },
        [W4.variable]: lh.reference,
        px: "2",
        py: "0.5",
        borderRadius: "sm",
        fontWeight: "medium",
        fontSize: "sm",
        boxShadow: "md",
        maxW: "xs",
        zIndex: "tooltip"
      }, K4 = {
        baseStyle: U4
      }, q4 = {
        Accordion: LN,
        Alert: m5,
        Avatar: M5,
        Badge: Bc,
        Breadcrumb: B5,
        Button: U5,
        Checkbox: np,
        CloseButton: s$,
        Code: u$,
        Container: h$,
        Divider: v$,
        Drawer: E$,
        Editable: I$,
        Form: V$,
        FormError: q$,
        FormLabel: Y$,
        Heading: J$,
        Input: qe,
        Kbd: l3,
        Link: u3,
        List: m3,
        Menu: M3,
        Modal: N3,
        NumberInput: K3,
        PinInput: X3,
        Popover: az,
        Progress: mz,
        Radio: xz,
        Select: Az,
        Skeleton: Pz,
        SkipLink: Rz,
        Slider: Hz,
        Spinner: Uz,
        Stat: Zz,
        Switch: c4,
        Table: g4,
        Tabs: R4,
        Tag: z4,
        Textarea: j4,
        Tooltip: K4,
        Card: X5,
        Stepper: n4
      }, G4 = {
        none: 0,
        "1px": "1px solid",
        "2px": "2px solid",
        "4px": "4px solid",
        "8px": "8px solid"
      }, Y4 = {
        base: "0em",
        sm: "30em",
        md: "48em",
        lg: "62em",
        xl: "80em",
        "2xl": "96em"
      }, X4 = {
        transparent: "transparent",
        current: "currentColor",
        black: "#000000",
        white: "#FFFFFF",
        whiteAlpha: {
          50: "rgba(255, 255, 255, 0.04)",
          100: "rgba(255, 255, 255, 0.06)",
          200: "rgba(255, 255, 255, 0.08)",
          300: "rgba(255, 255, 255, 0.16)",
          400: "rgba(255, 255, 255, 0.24)",
          500: "rgba(255, 255, 255, 0.36)",
          600: "rgba(255, 255, 255, 0.48)",
          700: "rgba(255, 255, 255, 0.64)",
          800: "rgba(255, 255, 255, 0.80)",
          900: "rgba(255, 255, 255, 0.92)"
        },
        blackAlpha: {
          50: "rgba(0, 0, 0, 0.04)",
          100: "rgba(0, 0, 0, 0.06)",
          200: "rgba(0, 0, 0, 0.08)",
          300: "rgba(0, 0, 0, 0.16)",
          400: "rgba(0, 0, 0, 0.24)",
          500: "rgba(0, 0, 0, 0.36)",
          600: "rgba(0, 0, 0, 0.48)",
          700: "rgba(0, 0, 0, 0.64)",
          800: "rgba(0, 0, 0, 0.80)",
          900: "rgba(0, 0, 0, 0.92)"
        },
        gray: {
          50: "#F7FAFC",
          100: "#EDF2F7",
          200: "#E2E8F0",
          300: "#CBD5E0",
          400: "#A0AEC0",
          500: "#718096",
          600: "#4A5568",
          700: "#2D3748",
          800: "#1A202C",
          900: "#171923"
        },
        red: {
          50: "#FFF5F5",
          100: "#FED7D7",
          200: "#FEB2B2",
          300: "#FC8181",
          400: "#F56565",
          500: "#E53E3E",
          600: "#C53030",
          700: "#9B2C2C",
          800: "#822727",
          900: "#63171B"
        },
        orange: {
          50: "#FFFAF0",
          100: "#FEEBC8",
          200: "#FBD38D",
          300: "#F6AD55",
          400: "#ED8936",
          500: "#DD6B20",
          600: "#C05621",
          700: "#9C4221",
          800: "#7B341E",
          900: "#652B19"
        },
        yellow: {
          50: "#FFFFF0",
          100: "#FEFCBF",
          200: "#FAF089",
          300: "#F6E05E",
          400: "#ECC94B",
          500: "#D69E2E",
          600: "#B7791F",
          700: "#975A16",
          800: "#744210",
          900: "#5F370E"
        },
        green: {
          50: "#F0FFF4",
          100: "#C6F6D5",
          200: "#9AE6B4",
          300: "#68D391",
          400: "#48BB78",
          500: "#38A169",
          600: "#2F855A",
          700: "#276749",
          800: "#22543D",
          900: "#1C4532"
        },
        teal: {
          50: "#E6FFFA",
          100: "#B2F5EA",
          200: "#81E6D9",
          300: "#4FD1C5",
          400: "#38B2AC",
          500: "#319795",
          600: "#2C7A7B",
          700: "#285E61",
          800: "#234E52",
          900: "#1D4044"
        },
        blue: {
          50: "#ebf8ff",
          100: "#bee3f8",
          200: "#90cdf4",
          300: "#63b3ed",
          400: "#4299e1",
          500: "#3182ce",
          600: "#2b6cb0",
          700: "#2c5282",
          800: "#2a4365",
          900: "#1A365D"
        },
        cyan: {
          50: "#EDFDFD",
          100: "#C4F1F9",
          200: "#9DECF9",
          300: "#76E4F7",
          400: "#0BC5EA",
          500: "#00B5D8",
          600: "#00A3C4",
          700: "#0987A0",
          800: "#086F83",
          900: "#065666"
        },
        purple: {
          50: "#FAF5FF",
          100: "#E9D8FD",
          200: "#D6BCFA",
          300: "#B794F4",
          400: "#9F7AEA",
          500: "#805AD5",
          600: "#6B46C1",
          700: "#553C9A",
          800: "#44337A",
          900: "#322659"
        },
        pink: {
          50: "#FFF5F7",
          100: "#FED7E2",
          200: "#FBB6CE",
          300: "#F687B3",
          400: "#ED64A6",
          500: "#D53F8C",
          600: "#B83280",
          700: "#97266D",
          800: "#702459",
          900: "#521B41"
        }
      }, Q4 = {
        none: "0",
        sm: "0.125rem",
        base: "0.25rem",
        md: "0.375rem",
        lg: "0.5rem",
        xl: "0.75rem",
        "2xl": "1rem",
        "3xl": "1.5rem",
        full: "9999px"
      }, J4 = {
        xs: "0 0 0 1px rgba(0, 0, 0, 0.05)",
        sm: "0 1px 2px 0 rgba(0, 0, 0, 0.05)",
        base: "0 1px 3px 0 rgba(0, 0, 0, 0.1), 0 1px 2px 0 rgba(0, 0, 0, 0.06)",
        md: "0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06)",
        lg: "0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05)",
        xl: "0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04)",
        "2xl": "0 25px 50px -12px rgba(0, 0, 0, 0.25)",
        outline: "0 0 0 3px rgba(66, 153, 225, 0.6)",
        inner: "inset 0 2px 4px 0 rgba(0,0,0,0.06)",
        none: "none",
        "dark-lg": "rgba(0, 0, 0, 0.1) 0px 0px 0px 1px, rgba(0, 0, 0, 0.2) 0px 5px 10px, rgba(0, 0, 0, 0.4) 0px 15px 40px"
      }, Z4 = {
        common: "background-color, border-color, color, fill, stroke, opacity, box-shadow, transform",
        colors: "background-color, border-color, color, fill, stroke",
        dimensions: "width, height",
        position: "left, right, top, bottom",
        background: "background-color, background-image, background-position"
      }, eF = {
        "ease-in": "cubic-bezier(0.4, 0, 1, 1)",
        "ease-out": "cubic-bezier(0, 0, 0.2, 1)",
        "ease-in-out": "cubic-bezier(0.4, 0, 0.2, 1)"
      }, tF = {
        "ultra-fast": "50ms",
        faster: "100ms",
        fast: "150ms",
        normal: "200ms",
        slow: "300ms",
        slower: "400ms",
        "ultra-slow": "500ms"
      }, nF = {
        property: Z4,
        easing: eF,
        duration: tF
      }, rF = {
        hide: -1,
        auto: "auto",
        base: 0,
        docked: 10,
        dropdown: 1e3,
        sticky: 1100,
        banner: 1200,
        overlay: 1300,
        modal: 1400,
        popover: 1500,
        skipLink: 1600,
        toast: 1700,
        tooltip: 1800
      }, iF = {
        none: 0,
        sm: "4px",
        base: "8px",
        md: "12px",
        lg: "16px",
        xl: "24px",
        "2xl": "40px",
        "3xl": "64px"
      }, $A = {
        breakpoints: Y4,
        zIndices: rF,
        radii: Q4,
        blur: iF,
        colors: X4,
        ..._A,
        sizes: EA,
        shadows: J4,
        space: AA,
        borders: G4,
        transition: nF
      }, zA = {
        colors: {
          "chakra-body-text": {
            _light: "gray.800",
            _dark: "whiteAlpha.900"
          },
          "chakra-body-bg": {
            _light: "white",
            _dark: "gray.800"
          },
          "chakra-border-color": {
            _light: "gray.200",
            _dark: "whiteAlpha.300"
          },
          "chakra-inverse-text": {
            _light: "white",
            _dark: "gray.800"
          },
          "chakra-subtle-bg": {
            _light: "gray.100",
            _dark: "gray.700"
          },
          "chakra-subtle-text": {
            _light: "gray.600",
            _dark: "gray.400"
          },
          "chakra-placeholder-color": {
            _light: "gray.500",
            _dark: "whiteAlpha.400"
          }
        }
      }, FA = {
        global: {
          body: {
            fontFamily: "body",
            color: "chakra-body-text",
            bg: "chakra-body-bg",
            transitionProperty: "background-color",
            transitionDuration: "normal",
            lineHeight: "base"
          },
          "*::placeholder": {
            color: "chakra-placeholder-color"
          },
          "*, *::before, &::after": {
            borderColor: "chakra-border-color"
          }
        }
      }, VA = "ltr", HA = {
        useSystemColorMode: false,
        initialColorMode: "light",
        cssVarPrefix: "chakra"
      }, oF = {
        semanticTokens: zA,
        direction: VA,
        ...$A,
        components: q4,
        styles: FA,
        config: HA
      };
      ({
        ...$A
      });
      var hm = {
        exports: {}
      }, dm = {};
      var sF = z.exports, aF = Symbol.for("react.element"), lF = Symbol.for("react.fragment"), cF = Object.prototype.hasOwnProperty, uF = sF.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, fF = {
        key: true,
        ref: true,
        __self: true,
        __source: true
      };
      function jA(t, e, n) {
        var r, i = {}, o = null, s = null;
        n !== void 0 && (o = "" + n), e.key !== void 0 && (o = "" + e.key), e.ref !== void 0 && (s = e.ref);
        for (r in e)
          cF.call(e, r) && !fF.hasOwnProperty(r) && (i[r] = e[r]);
        if (t && t.defaultProps)
          for (r in e = t.defaultProps, e)
            i[r] === void 0 && (i[r] = e[r]);
        return {
          $$typeof: aF,
          type: t,
          key: o,
          ref: s,
          props: i,
          _owner: uF.current
        };
      }
      dm.Fragment = lF;
      dm.jsx = jA;
      dm.jsxs = jA;
      (function(t) {
        t.exports = dm;
      })(hm);
      const ip = hm.exports.Fragment, Z = hm.exports.jsx, Xn = hm.exports.jsxs;
      var hF = false;
      function dF(t) {
        if (t.sheet)
          return t.sheet;
        for (var e = 0; e < document.styleSheets.length; e++)
          if (document.styleSheets[e].ownerNode === t)
            return document.styleSheets[e];
      }
      function pF(t) {
        var e = document.createElement("style");
        return e.setAttribute("data-emotion", t.key), t.nonce !== void 0 && e.setAttribute("nonce", t.nonce), e.appendChild(document.createTextNode("")), e.setAttribute("data-s", ""), e;
      }
      var mF = function() {
        function t(n) {
          var r = this;
          this._insertTag = function(i) {
            var o;
            r.tags.length === 0 ? r.insertionPoint ? o = r.insertionPoint.nextSibling : r.prepend ? o = r.container.firstChild : o = r.before : o = r.tags[r.tags.length - 1].nextSibling, r.container.insertBefore(i, o), r.tags.push(i);
          }, this.isSpeedy = n.speedy === void 0 ? !hF : n.speedy, this.tags = [], this.ctr = 0, this.nonce = n.nonce, this.key = n.key, this.container = n.container, this.prepend = n.prepend, this.insertionPoint = n.insertionPoint, this.before = null;
        }
        var e = t.prototype;
        return e.hydrate = function(r) {
          r.forEach(this._insertTag);
        }, e.insert = function(r) {
          this.ctr % (this.isSpeedy ? 65e3 : 1) === 0 && this._insertTag(pF(this));
          var i = this.tags[this.tags.length - 1];
          if (this.isSpeedy) {
            var o = dF(i);
            try {
              o.insertRule(r, o.cssRules.length);
            } catch {
            }
          } else
            i.appendChild(document.createTextNode(r));
          this.ctr++;
        }, e.flush = function() {
          this.tags.forEach(function(r) {
            var i;
            return (i = r.parentNode) == null ? void 0 : i.removeChild(r);
          }), this.tags = [], this.ctr = 0;
        }, t;
      }(), ln = "-ms-", op = "-moz-", Ue = "-webkit-", WA = "comm", Db = "rule", _b = "decl", gF = "@import", UA = "@keyframes", vF = "@layer", yF = Math.abs, pm = String.fromCharCode, bF = Object.assign;
      function xF(t, e) {
        return Xt(t, 0) ^ 45 ? (((e << 2 ^ Xt(t, 0)) << 2 ^ Xt(t, 1)) << 2 ^ Xt(t, 2)) << 2 ^ Xt(t, 3) : 0;
      }
      function KA(t) {
        return t.trim();
      }
      function SF(t, e) {
        return (t = e.exec(t)) ? t[0] : t;
      }
      function Ke(t, e, n) {
        return t.replace(e, n);
      }
      function cy(t, e) {
        return t.indexOf(e);
      }
      function Xt(t, e) {
        return t.charCodeAt(e) | 0;
      }
      function Su(t, e, n) {
        return t.slice(e, n);
      }
      function li(t) {
        return t.length;
      }
      function Ib(t) {
        return t.length;
      }
      function ch(t, e) {
        return e.push(t), t;
      }
      function wF(t, e) {
        return t.map(e).join("");
      }
      var mm = 1, al = 1, qA = 0, Vn = 0, Ot = 0, Cl = "";
      function gm(t, e, n, r, i, o, s) {
        return {
          value: t,
          root: e,
          parent: n,
          type: r,
          props: i,
          children: o,
          line: mm,
          column: al,
          length: s,
          return: ""
        };
      }
      function ec(t, e) {
        return bF(gm("", null, null, "", null, null, 0), t, {
          length: -t.length
        }, e);
      }
      function kF() {
        return Ot;
      }
      function CF() {
        return Ot = Vn > 0 ? Xt(Cl, --Vn) : 0, al--, Ot === 10 && (al = 1, mm--), Ot;
      }
      function Qn() {
        return Ot = Vn < qA ? Xt(Cl, Vn++) : 0, al++, Ot === 10 && (al = 1, mm++), Ot;
      }
      function Si() {
        return Xt(Cl, Vn);
      }
      function ud() {
        return Vn;
      }
      function Xu(t, e) {
        return Su(Cl, t, e);
      }
      function wu(t) {
        switch (t) {
          case 0:
          case 9:
          case 10:
          case 13:
          case 32:
            return 5;
          case 33:
          case 43:
          case 44:
          case 47:
          case 62:
          case 64:
          case 126:
          case 59:
          case 123:
          case 125:
            return 4;
          case 58:
            return 3;
          case 34:
          case 39:
          case 40:
          case 91:
            return 2;
          case 41:
          case 93:
            return 1;
        }
        return 0;
      }
      function GA(t) {
        return mm = al = 1, qA = li(Cl = t), Vn = 0, [];
      }
      function YA(t) {
        return Cl = "", t;
      }
      function fd(t) {
        return KA(Xu(Vn - 1, uy(t === 91 ? t + 2 : t === 40 ? t + 1 : t)));
      }
      function TF(t) {
        for (; (Ot = Si()) && Ot < 33; )
          Qn();
        return wu(t) > 2 || wu(Ot) > 3 ? "" : " ";
      }
      function MF(t, e) {
        for (; --e && Qn() && !(Ot < 48 || Ot > 102 || Ot > 57 && Ot < 65 || Ot > 70 && Ot < 97); )
          ;
        return Xu(t, ud() + (e < 6 && Si() == 32 && Qn() == 32));
      }
      function uy(t) {
        for (; Qn(); )
          switch (Ot) {
            case t:
              return Vn;
            case 34:
            case 39:
              t !== 34 && t !== 39 && uy(Ot);
              break;
            case 40:
              t === 41 && uy(t);
              break;
            case 92:
              Qn();
              break;
          }
        return Vn;
      }
      function AF(t, e) {
        for (; Qn() && t + Ot !== 47 + 10; )
          if (t + Ot === 42 + 42 && Si() === 47)
            break;
        return "/*" + Xu(e, Vn - 1) + "*" + pm(t === 47 ? t : Qn());
      }
      function EF(t) {
        for (; !wu(Si()); )
          Qn();
        return Xu(t, Vn);
      }
      function PF(t) {
        return YA(hd("", null, null, null, [
          ""
        ], t = GA(t), 0, [
          0
        ], t));
      }
      function hd(t, e, n, r, i, o, s, a, l) {
        for (var c = 0, u = 0, h = s, p = 0, v = 0, y = 0, S = 1, C = 1, w = 1, k = 0, T = "", P = i, R = o, L = r, D = T; C; )
          switch (y = k, k = Qn()) {
            case 40:
              if (y != 108 && Xt(D, h - 1) == 58) {
                cy(D += Ke(fd(k), "&", "&\f"), "&\f") != -1 && (w = -1);
                break;
              }
            case 34:
            case 39:
            case 91:
              D += fd(k);
              break;
            case 9:
            case 10:
            case 13:
            case 32:
              D += TF(y);
              break;
            case 92:
              D += MF(ud() - 1, 7);
              continue;
            case 47:
              switch (Si()) {
                case 42:
                case 47:
                  ch(OF(AF(Qn(), ud()), e, n), l);
                  break;
                default:
                  D += "/";
              }
              break;
            case 123 * S:
              a[c++] = li(D) * w;
            case 125 * S:
            case 59:
            case 0:
              switch (k) {
                case 0:
                case 125:
                  C = 0;
                case 59 + u:
                  w == -1 && (D = Ke(D, /\f/g, "")), v > 0 && li(D) - h && ch(v > 32 ? zw(D + ";", r, n, h - 1) : zw(Ke(D, " ", "") + ";", r, n, h - 2), l);
                  break;
                case 59:
                  D += ";";
                default:
                  if (ch(L = $w(D, e, n, c, u, i, a, T, P = [], R = [], h), o), k === 123)
                    if (u === 0)
                      hd(D, e, L, L, P, o, h, a, R);
                    else
                      switch (p === 99 && Xt(D, 3) === 110 ? 100 : p) {
                        case 100:
                        case 108:
                        case 109:
                        case 115:
                          hd(t, L, L, r && ch($w(t, L, L, 0, 0, i, a, T, i, P = [], h), R), i, R, h, a, r ? P : R);
                          break;
                        default:
                          hd(D, L, L, L, [
                            ""
                          ], R, 0, a, R);
                      }
              }
              c = u = v = 0, S = w = 1, T = D = "", h = s;
              break;
            case 58:
              h = 1 + li(D), v = y;
            default:
              if (S < 1) {
                if (k == 123)
                  --S;
                else if (k == 125 && S++ == 0 && CF() == 125)
                  continue;
              }
              switch (D += pm(k), k * S) {
                case 38:
                  w = u > 0 ? 1 : (D += "\f", -1);
                  break;
                case 44:
                  a[c++] = (li(D) - 1) * w, w = 1;
                  break;
                case 64:
                  Si() === 45 && (D += fd(Qn())), p = Si(), u = h = li(T = D += EF(ud())), k++;
                  break;
                case 45:
                  y === 45 && li(D) == 2 && (S = 0);
              }
          }
        return o;
      }
      function $w(t, e, n, r, i, o, s, a, l, c, u) {
        for (var h = i - 1, p = i === 0 ? o : [
          ""
        ], v = Ib(p), y = 0, S = 0, C = 0; y < r; ++y)
          for (var w = 0, k = Su(t, h + 1, h = yF(S = s[y])), T = t; w < v; ++w)
            (T = KA(S > 0 ? p[w] + " " + k : Ke(k, /&\f/g, p[w]))) && (l[C++] = T);
        return gm(t, e, n, i === 0 ? Db : a, l, c, u);
      }
      function OF(t, e, n) {
        return gm(t, e, n, WA, pm(kF()), Su(t, 2, -2), 0);
      }
      function zw(t, e, n, r) {
        return gm(t, e, n, _b, Su(t, 0, r), Su(t, r + 1, -1), r);
      }
      function Wa(t, e) {
        for (var n = "", r = Ib(t), i = 0; i < r; i++)
          n += e(t[i], i, t, e) || "";
        return n;
      }
      function RF(t, e, n, r) {
        switch (t.type) {
          case vF:
            if (t.children.length)
              break;
          case gF:
          case _b:
            return t.return = t.return || t.value;
          case WA:
            return "";
          case UA:
            return t.return = t.value + "{" + Wa(t.children, r) + "}";
          case Db:
            t.value = t.props.join(",");
        }
        return li(n = Wa(t.children, r)) ? t.return = t.value + "{" + n + "}" : "";
      }
      function LF(t) {
        var e = Ib(t);
        return function(n, r, i, o) {
          for (var s = "", a = 0; a < e; a++)
            s += t[a](n, r, i, o) || "";
          return s;
        };
      }
      function DF(t) {
        return function(e) {
          e.root || (e = e.return) && t(e);
        };
      }
      var Fw = function(e) {
        var n = /* @__PURE__ */ new WeakMap();
        return function(r) {
          if (n.has(r))
            return n.get(r);
          var i = e(r);
          return n.set(r, i), i;
        };
      };
      function XA(t) {
        var e = /* @__PURE__ */ Object.create(null);
        return function(n) {
          return e[n] === void 0 && (e[n] = t(n)), e[n];
        };
      }
      var _F = function(e, n, r) {
        for (var i = 0, o = 0; i = o, o = Si(), i === 38 && o === 12 && (n[r] = 1), !wu(o); )
          Qn();
        return Xu(e, Vn);
      }, IF = function(e, n) {
        var r = -1, i = 44;
        do
          switch (wu(i)) {
            case 0:
              i === 38 && Si() === 12 && (n[r] = 1), e[r] += _F(Vn - 1, n, r);
              break;
            case 2:
              e[r] += fd(i);
              break;
            case 4:
              if (i === 44) {
                e[++r] = Si() === 58 ? "&\f" : "", n[r] = e[r].length;
                break;
              }
            default:
              e[r] += pm(i);
          }
        while (i = Qn());
        return e;
      }, BF = function(e, n) {
        return YA(IF(GA(e), n));
      }, Vw = /* @__PURE__ */ new WeakMap(), NF = function(e) {
        if (!(e.type !== "rule" || !e.parent || e.length < 1)) {
          for (var n = e.value, r = e.parent, i = e.column === r.column && e.line === r.line; r.type !== "rule"; )
            if (r = r.parent, !r)
              return;
          if (!(e.props.length === 1 && n.charCodeAt(0) !== 58 && !Vw.get(r)) && !i) {
            Vw.set(e, true);
            for (var o = [], s = BF(n, o), a = r.props, l = 0, c = 0; l < s.length; l++)
              for (var u = 0; u < a.length; u++, c++)
                e.props[c] = o[l] ? s[l].replace(/&\f/g, a[u]) : a[u] + " " + s[l];
          }
        }
      }, $F = function(e) {
        if (e.type === "decl") {
          var n = e.value;
          n.charCodeAt(0) === 108 && n.charCodeAt(2) === 98 && (e.return = "", e.value = "");
        }
      };
      function QA(t, e) {
        switch (xF(t, e)) {
          case 5103:
            return Ue + "print-" + t + t;
          case 5737:
          case 4201:
          case 3177:
          case 3433:
          case 1641:
          case 4457:
          case 2921:
          case 5572:
          case 6356:
          case 5844:
          case 3191:
          case 6645:
          case 3005:
          case 6391:
          case 5879:
          case 5623:
          case 6135:
          case 4599:
          case 4855:
          case 4215:
          case 6389:
          case 5109:
          case 5365:
          case 5621:
          case 3829:
            return Ue + t + t;
          case 5349:
          case 4246:
          case 4810:
          case 6968:
          case 2756:
            return Ue + t + op + t + ln + t + t;
          case 6828:
          case 4268:
            return Ue + t + ln + t + t;
          case 6165:
            return Ue + t + ln + "flex-" + t + t;
          case 5187:
            return Ue + t + Ke(t, /(\w+).+(:[^]+)/, Ue + "box-$1$2" + ln + "flex-$1$2") + t;
          case 5443:
            return Ue + t + ln + "flex-item-" + Ke(t, /flex-|-self/, "") + t;
          case 4675:
            return Ue + t + ln + "flex-line-pack" + Ke(t, /align-content|flex-|-self/, "") + t;
          case 5548:
            return Ue + t + ln + Ke(t, "shrink", "negative") + t;
          case 5292:
            return Ue + t + ln + Ke(t, "basis", "preferred-size") + t;
          case 6060:
            return Ue + "box-" + Ke(t, "-grow", "") + Ue + t + ln + Ke(t, "grow", "positive") + t;
          case 4554:
            return Ue + Ke(t, /([^-])(transform)/g, "$1" + Ue + "$2") + t;
          case 6187:
            return Ke(Ke(Ke(t, /(zoom-|grab)/, Ue + "$1"), /(image-set)/, Ue + "$1"), t, "") + t;
          case 5495:
          case 3959:
            return Ke(t, /(image-set\([^]*)/, Ue + "$1$`$1");
          case 4968:
            return Ke(Ke(t, /(.+:)(flex-)?(.*)/, Ue + "box-pack:$3" + ln + "flex-pack:$3"), /s.+-b[^;]+/, "justify") + Ue + t + t;
          case 4095:
          case 3583:
          case 4068:
          case 2532:
            return Ke(t, /(.+)-inline(.+)/, Ue + "$1$2") + t;
          case 8116:
          case 7059:
          case 5753:
          case 5535:
          case 5445:
          case 5701:
          case 4933:
          case 4677:
          case 5533:
          case 5789:
          case 5021:
          case 4765:
            if (li(t) - 1 - e > 6)
              switch (Xt(t, e + 1)) {
                case 109:
                  if (Xt(t, e + 4) !== 45)
                    break;
                case 102:
                  return Ke(t, /(.+:)(.+)-([^]+)/, "$1" + Ue + "$2-$3$1" + op + (Xt(t, e + 3) == 108 ? "$3" : "$2-$3")) + t;
                case 115:
                  return ~cy(t, "stretch") ? QA(Ke(t, "stretch", "fill-available"), e) + t : t;
              }
            break;
          case 4949:
            if (Xt(t, e + 1) !== 115)
              break;
          case 6444:
            switch (Xt(t, li(t) - 3 - (~cy(t, "!important") && 10))) {
              case 107:
                return Ke(t, ":", ":" + Ue) + t;
              case 101:
                return Ke(t, /(.+:)([^;!]+)(;|!.+)?/, "$1" + Ue + (Xt(t, 14) === 45 ? "inline-" : "") + "box$3$1" + Ue + "$2$3$1" + ln + "$2box$3") + t;
            }
            break;
          case 5936:
            switch (Xt(t, e + 11)) {
              case 114:
                return Ue + t + ln + Ke(t, /[svh]\w+-[tblr]{2}/, "tb") + t;
              case 108:
                return Ue + t + ln + Ke(t, /[svh]\w+-[tblr]{2}/, "tb-rl") + t;
              case 45:
                return Ue + t + ln + Ke(t, /[svh]\w+-[tblr]{2}/, "lr") + t;
            }
            return Ue + t + ln + t + t;
        }
        return t;
      }
      var zF = function(e, n, r, i) {
        if (e.length > -1 && !e.return)
          switch (e.type) {
            case _b:
              e.return = QA(e.value, e.length);
              break;
            case UA:
              return Wa([
                ec(e, {
                  value: Ke(e.value, "@", "@" + Ue)
                })
              ], i);
            case Db:
              if (e.length)
                return wF(e.props, function(o) {
                  switch (SF(o, /(::plac\w+|:read-\w+)/)) {
                    case ":read-only":
                    case ":read-write":
                      return Wa([
                        ec(e, {
                          props: [
                            Ke(o, /:(read-\w+)/, ":" + op + "$1")
                          ]
                        })
                      ], i);
                    case "::placeholder":
                      return Wa([
                        ec(e, {
                          props: [
                            Ke(o, /:(plac\w+)/, ":" + Ue + "input-$1")
                          ]
                        }),
                        ec(e, {
                          props: [
                            Ke(o, /:(plac\w+)/, ":" + op + "$1")
                          ]
                        }),
                        ec(e, {
                          props: [
                            Ke(o, /:(plac\w+)/, ln + "input-$1")
                          ]
                        })
                      ], i);
                  }
                  return "";
                });
          }
      }, FF = [
        zF
      ], VF = function(e) {
        var n = e.key;
        if (n === "css") {
          var r = document.querySelectorAll("style[data-emotion]:not([data-s])");
          Array.prototype.forEach.call(r, function(S) {
            var C = S.getAttribute("data-emotion");
            C.indexOf(" ") !== -1 && (document.head.appendChild(S), S.setAttribute("data-s", ""));
          });
        }
        var i = e.stylisPlugins || FF, o = {}, s, a = [];
        s = e.container || document.head, Array.prototype.forEach.call(document.querySelectorAll('style[data-emotion^="' + n + ' "]'), function(S) {
          for (var C = S.getAttribute("data-emotion").split(" "), w = 1; w < C.length; w++)
            o[C[w]] = true;
          a.push(S);
        });
        var l, c = [
          NF,
          $F
        ];
        {
          var u, h = [
            RF,
            DF(function(S) {
              u.insert(S);
            })
          ], p = LF(c.concat(i, h)), v = function(C) {
            return Wa(PF(C), p);
          };
          l = function(C, w, k, T) {
            u = k, v(C ? C + "{" + w.styles + "}" : w.styles), T && (y.inserted[w.name] = true);
          };
        }
        var y = {
          key: n,
          sheet: new mF({
            key: n,
            container: s,
            nonce: e.nonce,
            speedy: e.speedy,
            prepend: e.prepend,
            insertionPoint: e.insertionPoint
          }),
          nonce: e.nonce,
          inserted: o,
          registered: {},
          insert: l
        };
        return y.sheet.hydrate(a), y;
      };
      function ku() {
        return ku = Object.assign ? Object.assign.bind() : function(t) {
          for (var e = 1; e < arguments.length; e++) {
            var n = arguments[e];
            for (var r in n)
              ({}).hasOwnProperty.call(n, r) && (t[r] = n[r]);
          }
          return t;
        }, ku.apply(null, arguments);
      }
      var JA = {
        exports: {}
      }, Xe = {};
      var Wt = typeof Symbol == "function" && Symbol.for, Bb = Wt ? Symbol.for("react.element") : 60103, Nb = Wt ? Symbol.for("react.portal") : 60106, vm = Wt ? Symbol.for("react.fragment") : 60107, ym = Wt ? Symbol.for("react.strict_mode") : 60108, bm = Wt ? Symbol.for("react.profiler") : 60114, xm = Wt ? Symbol.for("react.provider") : 60109, Sm = Wt ? Symbol.for("react.context") : 60110, $b = Wt ? Symbol.for("react.async_mode") : 60111, wm = Wt ? Symbol.for("react.concurrent_mode") : 60111, km = Wt ? Symbol.for("react.forward_ref") : 60112, Cm = Wt ? Symbol.for("react.suspense") : 60113, HF = Wt ? Symbol.for("react.suspense_list") : 60120, Tm = Wt ? Symbol.for("react.memo") : 60115, Mm = Wt ? Symbol.for("react.lazy") : 60116, jF = Wt ? Symbol.for("react.block") : 60121, WF = Wt ? Symbol.for("react.fundamental") : 60117, UF = Wt ? Symbol.for("react.responder") : 60118, KF = Wt ? Symbol.for("react.scope") : 60119;
      function tr(t) {
        if (typeof t == "object" && t !== null) {
          var e = t.$$typeof;
          switch (e) {
            case Bb:
              switch (t = t.type, t) {
                case $b:
                case wm:
                case vm:
                case bm:
                case ym:
                case Cm:
                  return t;
                default:
                  switch (t = t && t.$$typeof, t) {
                    case Sm:
                    case km:
                    case Mm:
                    case Tm:
                    case xm:
                      return t;
                    default:
                      return e;
                  }
              }
            case Nb:
              return e;
          }
        }
      }
      function ZA(t) {
        return tr(t) === wm;
      }
      Xe.AsyncMode = $b;
      Xe.ConcurrentMode = wm;
      Xe.ContextConsumer = Sm;
      Xe.ContextProvider = xm;
      Xe.Element = Bb;
      Xe.ForwardRef = km;
      Xe.Fragment = vm;
      Xe.Lazy = Mm;
      Xe.Memo = Tm;
      Xe.Portal = Nb;
      Xe.Profiler = bm;
      Xe.StrictMode = ym;
      Xe.Suspense = Cm;
      Xe.isAsyncMode = function(t) {
        return ZA(t) || tr(t) === $b;
      };
      Xe.isConcurrentMode = ZA;
      Xe.isContextConsumer = function(t) {
        return tr(t) === Sm;
      };
      Xe.isContextProvider = function(t) {
        return tr(t) === xm;
      };
      Xe.isElement = function(t) {
        return typeof t == "object" && t !== null && t.$$typeof === Bb;
      };
      Xe.isForwardRef = function(t) {
        return tr(t) === km;
      };
      Xe.isFragment = function(t) {
        return tr(t) === vm;
      };
      Xe.isLazy = function(t) {
        return tr(t) === Mm;
      };
      Xe.isMemo = function(t) {
        return tr(t) === Tm;
      };
      Xe.isPortal = function(t) {
        return tr(t) === Nb;
      };
      Xe.isProfiler = function(t) {
        return tr(t) === bm;
      };
      Xe.isStrictMode = function(t) {
        return tr(t) === ym;
      };
      Xe.isSuspense = function(t) {
        return tr(t) === Cm;
      };
      Xe.isValidElementType = function(t) {
        return typeof t == "string" || typeof t == "function" || t === vm || t === wm || t === bm || t === ym || t === Cm || t === HF || typeof t == "object" && t !== null && (t.$$typeof === Mm || t.$$typeof === Tm || t.$$typeof === xm || t.$$typeof === Sm || t.$$typeof === km || t.$$typeof === WF || t.$$typeof === UF || t.$$typeof === KF || t.$$typeof === jF);
      };
      Xe.typeOf = tr;
      (function(t) {
        t.exports = Xe;
      })(JA);
      var eE = JA.exports, qF = {
        $$typeof: true,
        render: true,
        defaultProps: true,
        displayName: true,
        propTypes: true
      }, GF = {
        $$typeof: true,
        compare: true,
        defaultProps: true,
        displayName: true,
        propTypes: true,
        type: true
      }, tE = {};
      tE[eE.ForwardRef] = qF;
      tE[eE.Memo] = GF;
      var YF = true;
      function nE(t, e, n) {
        var r = "";
        return n.split(" ").forEach(function(i) {
          t[i] !== void 0 ? e.push(t[i] + ";") : i && (r += i + " ");
        }), r;
      }
      var zb = function(e, n, r) {
        var i = e.key + "-" + n.name;
        (r === false || YF === false) && e.registered[i] === void 0 && (e.registered[i] = n.styles);
      }, Fb = function(e, n, r) {
        zb(e, n, r);
        var i = e.key + "-" + n.name;
        if (e.inserted[n.name] === void 0) {
          var o = n;
          do
            e.insert(n === o ? "." + i : "", o, e.sheet, true), o = o.next;
          while (o !== void 0);
        }
      };
      function XF(t) {
        for (var e = 0, n, r = 0, i = t.length; i >= 4; ++r, i -= 4)
          n = t.charCodeAt(r) & 255 | (t.charCodeAt(++r) & 255) << 8 | (t.charCodeAt(++r) & 255) << 16 | (t.charCodeAt(++r) & 255) << 24, n = (n & 65535) * 1540483477 + ((n >>> 16) * 59797 << 16), n ^= n >>> 24, e = (n & 65535) * 1540483477 + ((n >>> 16) * 59797 << 16) ^ (e & 65535) * 1540483477 + ((e >>> 16) * 59797 << 16);
        switch (i) {
          case 3:
            e ^= (t.charCodeAt(r + 2) & 255) << 16;
          case 2:
            e ^= (t.charCodeAt(r + 1) & 255) << 8;
          case 1:
            e ^= t.charCodeAt(r) & 255, e = (e & 65535) * 1540483477 + ((e >>> 16) * 59797 << 16);
        }
        return e ^= e >>> 13, e = (e & 65535) * 1540483477 + ((e >>> 16) * 59797 << 16), ((e ^ e >>> 15) >>> 0).toString(36);
      }
      var QF = {
        animationIterationCount: 1,
        aspectRatio: 1,
        borderImageOutset: 1,
        borderImageSlice: 1,
        borderImageWidth: 1,
        boxFlex: 1,
        boxFlexGroup: 1,
        boxOrdinalGroup: 1,
        columnCount: 1,
        columns: 1,
        flex: 1,
        flexGrow: 1,
        flexPositive: 1,
        flexShrink: 1,
        flexNegative: 1,
        flexOrder: 1,
        gridRow: 1,
        gridRowEnd: 1,
        gridRowSpan: 1,
        gridRowStart: 1,
        gridColumn: 1,
        gridColumnEnd: 1,
        gridColumnSpan: 1,
        gridColumnStart: 1,
        msGridRow: 1,
        msGridRowSpan: 1,
        msGridColumn: 1,
        msGridColumnSpan: 1,
        fontWeight: 1,
        lineHeight: 1,
        opacity: 1,
        order: 1,
        orphans: 1,
        scale: 1,
        tabSize: 1,
        widows: 1,
        zIndex: 1,
        zoom: 1,
        WebkitLineClamp: 1,
        fillOpacity: 1,
        floodOpacity: 1,
        stopOpacity: 1,
        strokeDasharray: 1,
        strokeDashoffset: 1,
        strokeMiterlimit: 1,
        strokeOpacity: 1,
        strokeWidth: 1
      }, JF = false, ZF = /[A-Z]|^ms/g, eV = /_EMO_([^_]+?)_([^]*?)_EMO_/g, rE = function(e) {
        return e.charCodeAt(1) === 45;
      }, Hw = function(e) {
        return e != null && typeof e != "boolean";
      }, m0 = XA(function(t) {
        return rE(t) ? t : t.replace(ZF, "-$&").toLowerCase();
      }), jw = function(e, n) {
        switch (e) {
          case "animation":
          case "animationName":
            if (typeof n == "string")
              return n.replace(eV, function(r, i, o) {
                return ci = {
                  name: i,
                  styles: o,
                  next: ci
                }, i;
              });
        }
        return QF[e] !== 1 && !rE(e) && typeof n == "number" && n !== 0 ? n + "px" : n;
      }, tV = "Component selectors can only be used in conjunction with @emotion/babel-plugin, the swc Emotion plugin, or another Emotion-aware compiler transform.";
      function Cu(t, e, n) {
        if (n == null)
          return "";
        var r = n;
        if (r.__emotion_styles !== void 0)
          return r;
        switch (typeof n) {
          case "boolean":
            return "";
          case "object": {
            var i = n;
            if (i.anim === 1)
              return ci = {
                name: i.name,
                styles: i.styles,
                next: ci
              }, i.name;
            var o = n;
            if (o.styles !== void 0) {
              var s = o.next;
              if (s !== void 0)
                for (; s !== void 0; )
                  ci = {
                    name: s.name,
                    styles: s.styles,
                    next: ci
                  }, s = s.next;
              var a = o.styles + ";";
              return a;
            }
            return nV(t, e, n);
          }
          case "function": {
            if (t !== void 0) {
              var l = ci, c = n(t);
              return ci = l, Cu(t, e, c);
            }
            break;
          }
        }
        var u = n;
        if (e == null)
          return u;
        var h = e[u];
        return h !== void 0 ? h : u;
      }
      function nV(t, e, n) {
        var r = "";
        if (Array.isArray(n))
          for (var i = 0; i < n.length; i++)
            r += Cu(t, e, n[i]) + ";";
        else
          for (var o in n) {
            var s = n[o];
            if (typeof s != "object") {
              var a = s;
              e != null && e[a] !== void 0 ? r += o + "{" + e[a] + "}" : Hw(a) && (r += m0(o) + ":" + jw(o, a) + ";");
            } else {
              if (o === "NO_COMPONENT_SELECTOR" && JF)
                throw new Error(tV);
              if (Array.isArray(s) && typeof s[0] == "string" && (e == null || e[s[0]] === void 0))
                for (var l = 0; l < s.length; l++)
                  Hw(s[l]) && (r += m0(o) + ":" + jw(o, s[l]) + ";");
              else {
                var c = Cu(t, e, s);
                switch (o) {
                  case "animation":
                  case "animationName": {
                    r += m0(o) + ":" + c + ";";
                    break;
                  }
                  default:
                    r += o + "{" + c + "}";
                }
              }
            }
          }
        return r;
      }
      var Ww = /label:\s*([^\s;{]+)\s*(;|$)/g, ci;
      function Am(t, e, n) {
        if (t.length === 1 && typeof t[0] == "object" && t[0] !== null && t[0].styles !== void 0)
          return t[0];
        var r = true, i = "";
        ci = void 0;
        var o = t[0];
        if (o == null || o.raw === void 0)
          r = false, i += Cu(n, e, o);
        else {
          var s = o;
          i += s[0];
        }
        for (var a = 1; a < t.length; a++)
          if (i += Cu(n, e, t[a]), r) {
            var l = o;
            i += l[a];
          }
        Ww.lastIndex = 0;
        for (var c = "", u; (u = Ww.exec(i)) !== null; )
          c += "-" + u[1];
        var h = XF(i) + c;
        return {
          name: h,
          styles: i,
          next: ci
        };
      }
      var rV = function(e) {
        return e();
      }, iE = fS["useInsertionEffect"] ? fS["useInsertionEffect"] : false, oE = iE || rV, Uw = iE || z.exports.useLayoutEffect, iV = false, Vb = z.exports.createContext(typeof HTMLElement < "u" ? VF({
        key: "css"
      }) : null);
      Vb.Provider;
      var oV = function() {
        return z.exports.useContext(Vb);
      }, Hb = function(e) {
        return z.exports.forwardRef(function(n, r) {
          var i = z.exports.useContext(Vb);
          return e(n, i, r);
        });
      }, ll = z.exports.createContext({}), sV = function(e, n) {
        if (typeof n == "function") {
          var r = n(e);
          return r;
        }
        return ku({}, e, n);
      }, aV = Fw(function(t) {
        return Fw(function(e) {
          return sV(t, e);
        });
      }), lV = function(e) {
        var n = z.exports.useContext(ll);
        return e.theme !== n && (n = aV(n)(e.theme)), Z(ll.Provider, {
          value: n,
          children: e.children
        });
      }, jb = {}.hasOwnProperty, fy = "__EMOTION_TYPE_PLEASE_DO_NOT_USE__", cV = function(e, n) {
        var r = {};
        for (var i in n)
          jb.call(n, i) && (r[i] = n[i]);
        return r[fy] = e, r;
      }, uV = function(e) {
        var n = e.cache, r = e.serialized, i = e.isStringTag;
        return zb(n, r, i), oE(function() {
          return Fb(n, r, i);
        }), null;
      }, fV = Hb(function(t, e, n) {
        var r = t.css;
        typeof r == "string" && e.registered[r] !== void 0 && (r = e.registered[r]);
        var i = t[fy], o = [
          r
        ], s = "";
        typeof t.className == "string" ? s = nE(e.registered, o, t.className) : t.className != null && (s = t.className + " ");
        var a = Am(o, void 0, z.exports.useContext(ll));
        s += e.key + "-" + a.name;
        var l = {};
        for (var c in t)
          jb.call(t, c) && c !== "css" && c !== fy && !iV && (l[c] = t[c]);
        return l.className = s, n && (l.ref = n), Xn(ip, {
          children: [
            Z(uV, {
              cache: e,
              serialized: a,
              isStringTag: typeof i == "string"
            }),
            Z(i, {
              ...l
            })
          ]
        });
      }), hV = fV, Kw = function(e, n) {
        var r = arguments;
        if (n == null || !jb.call(n, "css"))
          return z.exports.createElement.apply(void 0, r);
        var i = r.length, o = new Array(i);
        o[0] = hV, o[1] = cV(e, n);
        for (var s = 2; s < i; s++)
          o[s] = r[s];
        return z.exports.createElement.apply(null, o);
      };
      (function(t) {
        var e;
        (function(n) {
        })(e || (e = t.JSX || (t.JSX = {})));
      })(Kw || (Kw = {}));
      var Em = Hb(function(t, e) {
        var n = t.styles, r = Am([
          n
        ], void 0, z.exports.useContext(ll)), i = z.exports.useRef();
        return Uw(function() {
          var o = e.key + "-global", s = new e.sheet.constructor({
            key: o,
            nonce: e.sheet.nonce,
            container: e.sheet.container,
            speedy: e.sheet.isSpeedy
          }), a = false, l = document.querySelector('style[data-emotion="' + o + " " + r.name + '"]');
          return e.sheet.tags.length && (s.before = e.sheet.tags[0]), l !== null && (a = true, l.setAttribute("data-emotion", o), s.hydrate([
            l
          ])), i.current = [
            s,
            a
          ], function() {
            s.flush();
          };
        }, [
          e
        ]), Uw(function() {
          var o = i.current, s = o[0], a = o[1];
          if (a) {
            o[1] = false;
            return;
          }
          if (r.next !== void 0 && Fb(e, r.next, true), s.tags.length) {
            var l = s.tags[s.tags.length - 1].nextElementSibling;
            s.before = l, s.flush();
          }
          e.insert("", r, s, false);
        }, [
          e,
          r.name
        ]), null;
      });
      function dV() {
        for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++)
          e[n] = arguments[n];
        return Am(e);
      }
      function pV() {
        var t = dV.apply(void 0, arguments), e = "animation-" + t.name;
        return {
          name: e,
          styles: "@keyframes " + e + "{" + t.styles + "}",
          anim: 1,
          toString: function() {
            return "_EMO_" + this.name + "_" + this.styles + "_EMO_";
          }
        };
      }
      const Wb = z.exports.createContext({});
      Wb.displayName = "ColorModeContext";
      function Ub() {
        const t = z.exports.useContext(Wb);
        if (t === void 0)
          throw new Error("useColorMode must be used within a ColorModeProvider");
        return t;
      }
      const uh = {
        light: "chakra-ui-light",
        dark: "chakra-ui-dark"
      };
      function mV(t = {}) {
        const { preventTransition: e = true, nonce: n } = t, r = {
          setDataset: (i) => {
            const o = e ? r.preventTransition() : void 0;
            document.documentElement.dataset.theme = i, document.documentElement.style.colorScheme = i, o == null ? void 0 : o();
          },
          setClassName(i) {
            document.body.classList.add(i ? uh.dark : uh.light), document.body.classList.remove(i ? uh.light : uh.dark);
          },
          query() {
            return window.matchMedia("(prefers-color-scheme: dark)");
          },
          getSystemTheme(i) {
            return r.query().matches ?? i === "dark" ? "dark" : "light";
          },
          addListener(i) {
            const o = r.query(), s = (a) => {
              i(a.matches ? "dark" : "light");
            };
            return typeof o.addListener == "function" ? o.addListener(s) : o.addEventListener("change", s), () => {
              typeof o.removeListener == "function" ? o.removeListener(s) : o.removeEventListener("change", s);
            };
          },
          preventTransition() {
            const i = document.createElement("style");
            return i.appendChild(document.createTextNode("*{-webkit-transition:none!important;-moz-transition:none!important;-o-transition:none!important;-ms-transition:none!important;transition:none!important}")), n !== void 0 && (i.nonce = n), document.head.appendChild(i), () => {
              window.getComputedStyle(document.body), requestAnimationFrame(() => {
                requestAnimationFrame(() => {
                  document.head.removeChild(i);
                });
              });
            };
          }
        };
        return r;
      }
      const gV = "chakra-ui-color-mode";
      function vV(t) {
        return {
          ssr: false,
          type: "localStorage",
          get(e) {
            if (!(globalThis == null ? void 0 : globalThis.document))
              return e;
            let n;
            try {
              n = localStorage.getItem(t) || e;
            } catch {
            }
            return n || e;
          },
          set(e) {
            try {
              localStorage.setItem(t, e);
            } catch {
            }
          }
        };
      }
      const yV = vV(gV), qw = () => {
      }, bV = EI() ? z.exports.useLayoutEffect : z.exports.useEffect;
      function Gw(t, e) {
        return t.type === "cookie" && t.ssr ? t.get(e) : e;
      }
      const sE = function(e) {
        const { value: n, children: r, options: { useSystemColorMode: i, initialColorMode: o, disableTransitionOnChange: s } = {}, colorModeManager: a = yV } = e, l = oV(), c = o === "dark" ? "dark" : "light", [u, h] = z.exports.useState(() => Gw(a, c)), [p, v] = z.exports.useState(() => Gw(a)), { getSystemTheme: y, setClassName: S, setDataset: C, addListener: w } = z.exports.useMemo(() => mV({
          preventTransition: s,
          nonce: l == null ? void 0 : l.nonce
        }), [
          s,
          l == null ? void 0 : l.nonce
        ]), k = o === "system" && !u ? p : u, T = z.exports.useCallback((L) => {
          const D = L === "system" ? y() : L;
          h(D), S(D === "dark"), C(D), a.set(D);
        }, [
          a,
          y,
          S,
          C
        ]);
        bV(() => {
          o === "system" && v(y());
        }, []), z.exports.useEffect(() => {
          const L = a.get();
          if (L) {
            T(L);
            return;
          }
          if (o === "system") {
            T("system");
            return;
          }
          T(c);
        }, [
          a,
          c,
          o,
          T
        ]);
        const P = z.exports.useCallback(() => {
          T(k === "dark" ? "light" : "dark");
        }, [
          k,
          T
        ]);
        z.exports.useEffect(() => {
          if (!!i)
            return w(T);
        }, [
          i,
          w,
          T
        ]);
        const R = z.exports.useMemo(() => ({
          colorMode: n ?? k,
          toggleColorMode: n ? qw : P,
          setColorMode: n ? qw : T,
          forced: n !== void 0
        }), [
          k,
          P,
          T,
          n
        ]);
        return Z(Wb.Provider, {
          value: R,
          children: r
        });
      };
      sE.displayName = "ColorModeProvider";
      const aE = String.raw, lE = aE`
  :root,
  :host {
    --chakra-vh: 100vh;
  }

  @supports (height: -webkit-fill-available) {
    :root,
    :host {
      --chakra-vh: -webkit-fill-available;
    }
  }

  @supports (height: -moz-fill-available) {
    :root,
    :host {
      --chakra-vh: -moz-fill-available;
    }
  }

  @supports (height: 100dvh) {
    :root,
    :host {
      --chakra-vh: 100dvh;
    }
  }
`, xV = () => Z(Em, {
        styles: lE
      }), SV = ({ scope: t = "" }) => Z(Em, {
        styles: aE`
      html {
        line-height: 1.5;
        -webkit-text-size-adjust: 100%;
        font-family: system-ui, sans-serif;
        -webkit-font-smoothing: antialiased;
        text-rendering: optimizeLegibility;
        -moz-osx-font-smoothing: grayscale;
        touch-action: manipulation;
      }

      body {
        position: relative;
        min-height: 100%;
        margin: 0;
        font-feature-settings: "kern";
      }

      ${t} :where(*, *::before, *::after) {
        border-width: 0;
        border-style: solid;
        box-sizing: border-box;
        word-wrap: break-word;
      }

      main {
        display: block;
      }

      ${t} hr {
        border-top-width: 1px;
        box-sizing: content-box;
        height: 0;
        overflow: visible;
      }

      ${t} :where(pre, code, kbd,samp) {
        font-family: SFMono-Regular, Menlo, Monaco, Consolas, monospace;
        font-size: 1em;
      }

      ${t} a {
        background-color: transparent;
        color: inherit;
        text-decoration: inherit;
      }

      ${t} abbr[title] {
        border-bottom: none;
        text-decoration: underline;
        -webkit-text-decoration: underline dotted;
        text-decoration: underline dotted;
      }

      ${t} :where(b, strong) {
        font-weight: bold;
      }

      ${t} small {
        font-size: 80%;
      }

      ${t} :where(sub,sup) {
        font-size: 75%;
        line-height: 0;
        position: relative;
        vertical-align: baseline;
      }

      ${t} sub {
        bottom: -0.25em;
      }

      ${t} sup {
        top: -0.5em;
      }

      ${t} img {
        border-style: none;
      }

      ${t} :where(button, input, optgroup, select, textarea) {
        font-family: inherit;
        font-size: 100%;
        line-height: 1.15;
        margin: 0;
      }

      ${t} :where(button, input) {
        overflow: visible;
      }

      ${t} :where(button, select) {
        text-transform: none;
      }

      ${t} :where(
          button::-moz-focus-inner,
          [type="button"]::-moz-focus-inner,
          [type="reset"]::-moz-focus-inner,
          [type="submit"]::-moz-focus-inner
        ) {
        border-style: none;
        padding: 0;
      }

      ${t} fieldset {
        padding: 0.35em 0.75em 0.625em;
      }

      ${t} legend {
        box-sizing: border-box;
        color: inherit;
        display: table;
        max-width: 100%;
        padding: 0;
        white-space: normal;
      }

      ${t} progress {
        vertical-align: baseline;
      }

      ${t} textarea {
        overflow: auto;
      }

      ${t} :where([type="checkbox"], [type="radio"]) {
        box-sizing: border-box;
        padding: 0;
      }

      ${t} input[type="number"]::-webkit-inner-spin-button,
      ${t} input[type="number"]::-webkit-outer-spin-button {
        -webkit-appearance: none !important;
      }

      ${t} input[type="number"] {
        -moz-appearance: textfield;
      }

      ${t} input[type="search"] {
        -webkit-appearance: textfield;
        outline-offset: -2px;
      }

      ${t} input[type="search"]::-webkit-search-decoration {
        -webkit-appearance: none !important;
      }

      ${t} ::-webkit-file-upload-button {
        -webkit-appearance: button;
        font: inherit;
      }

      ${t} details {
        display: block;
      }

      ${t} summary {
        display: list-item;
      }

      template {
        display: none;
      }

      [hidden] {
        display: none !important;
      }

      ${t} :where(
          blockquote,
          dl,
          dd,
          h1,
          h2,
          h3,
          h4,
          h5,
          h6,
          hr,
          figure,
          p,
          pre
        ) {
        margin: 0;
      }

      ${t} button {
        background: transparent;
        padding: 0;
      }

      ${t} fieldset {
        margin: 0;
        padding: 0;
      }

      ${t} :where(ol, ul) {
        margin: 0;
        padding: 0;
      }

      ${t} textarea {
        resize: vertical;
      }

      ${t} :where(button, [role="button"]) {
        cursor: pointer;
      }

      ${t} button::-moz-focus-inner {
        border: 0 !important;
      }

      ${t} table {
        border-collapse: collapse;
      }

      ${t} :where(h1, h2, h3, h4, h5, h6) {
        font-size: inherit;
        font-weight: inherit;
      }

      ${t} :where(button, input, optgroup, select, textarea) {
        padding: 0;
        line-height: inherit;
        color: inherit;
      }

      ${t} :where(img, svg, video, canvas, audio, iframe, embed, object) {
        display: block;
      }

      ${t} :where(img, video) {
        max-width: 100%;
        height: auto;
      }

      [data-js-focus-visible]
        :focus:not([data-focus-visible-added]):not(
          [data-focus-visible-disabled]
        ) {
        outline: none;
        box-shadow: none;
      }

      ${t} select::-ms-expand {
        display: none;
      }

      ${lE}
    `
      });
      function wV(t) {
        const { cssVarsRoot: e, theme: n, children: r } = t, i = z.exports.useMemo(() => ZB(n), [
          n
        ]);
        return Xn(lV, {
          theme: i,
          children: [
            Z(kV, {
              root: e
            }),
            r
          ]
        });
      }
      function kV({ root: t = ":host, :root" }) {
        const e = [
          t,
          "[data-theme]"
        ].join(",");
        return Z(Em, {
          styles: (n) => ({
            [e]: n.__cssVars
          })
        });
      }
      Mi({
        name: "StylesContext",
        errorMessage: "useStyles: `styles` is undefined. Seems you forgot to wrap the components in `<StylesProvider />` "
      });
      function CV() {
        const { colorMode: t } = Ub();
        return Z(Em, {
          styles: (e) => {
            const n = vA(e, "styles.global"), r = mi(n, {
              theme: e,
              colorMode: t
            });
            return r ? kA(r)(e) : void 0;
          }
        });
      }
      const [TV, MV] = Mi({
        strict: false,
        name: "PortalManagerContext"
      });
      function cE(t) {
        const { children: e, zIndex: n } = t;
        return Z(TV, {
          value: {
            zIndex: n
          },
          children: e
        });
      }
      cE.displayName = "PortalManager";
      const uE = z.exports.createContext({
        getDocument() {
          return document;
        },
        getWindow() {
          return window;
        }
      });
      uE.displayName = "EnvironmentContext";
      function fE(t) {
        const { children: e, environment: n, disabled: r } = t, i = z.exports.useRef(null), o = z.exports.useMemo(() => n || {
          getDocument: () => {
            var _a3;
            return ((_a3 = i.current) == null ? void 0 : _a3.ownerDocument) ?? document;
          },
          getWindow: () => {
            var _a3;
            return ((_a3 = i.current) == null ? void 0 : _a3.ownerDocument.defaultView) ?? window;
          }
        }, [
          n
        ]), s = !r || !n;
        return Xn(uE.Provider, {
          value: o,
          children: [
            e,
            s && Z("span", {
              id: "__chakra_env",
              hidden: true,
              ref: i
            })
          ]
        });
      }
      fE.displayName = "EnvironmentProvider";
      const AV = (t) => {
        const { children: e, colorModeManager: n, portalZIndex: r, resetScope: i, resetCSS: o = true, theme: s = {}, environment: a, cssVarsRoot: l, disableEnvironment: c, disableGlobalStyle: u } = t, h = Z(fE, {
          environment: a,
          disabled: c,
          children: e
        });
        return Z(wV, {
          theme: s,
          cssVarsRoot: l,
          children: Xn(sE, {
            colorModeManager: n,
            options: s.config,
            children: [
              o ? Z(SV, {
                scope: i
              }) : Z(xV, {}),
              !u && Z(CV, {}),
              r ? Z(cE, {
                zIndex: r,
                children: h
              }) : h
            ]
          })
        });
      };
      var hy = function(t, e) {
        return hy = Object.setPrototypeOf || {
          __proto__: []
        } instanceof Array && function(n, r) {
          n.__proto__ = r;
        } || function(n, r) {
          for (var i in r)
            Object.prototype.hasOwnProperty.call(r, i) && (n[i] = r[i]);
        }, hy(t, e);
      };
      function hE(t, e) {
        if (typeof e != "function" && e !== null)
          throw new TypeError("Class extends value " + String(e) + " is not a constructor or null");
        hy(t, e);
        function n() {
          this.constructor = t;
        }
        t.prototype = e === null ? Object.create(e) : (n.prototype = e.prototype, new n());
      }
      var ie = function() {
        return ie = Object.assign || function(e) {
          for (var n, r = 1, i = arguments.length; r < i; r++) {
            n = arguments[r];
            for (var o in n)
              Object.prototype.hasOwnProperty.call(n, o) && (e[o] = n[o]);
          }
          return e;
        }, ie.apply(this, arguments);
      };
      function Tr(t, e) {
        var n = {};
        for (var r in t)
          Object.prototype.hasOwnProperty.call(t, r) && e.indexOf(r) < 0 && (n[r] = t[r]);
        if (t != null && typeof Object.getOwnPropertySymbols == "function")
          for (var i = 0, r = Object.getOwnPropertySymbols(t); i < r.length; i++)
            e.indexOf(r[i]) < 0 && Object.prototype.propertyIsEnumerable.call(t, r[i]) && (n[r[i]] = t[r[i]]);
        return n;
      }
      function EV(t) {
        var e = typeof Symbol == "function" && Symbol.iterator, n = e && t[e], r = 0;
        if (n)
          return n.call(t);
        if (t && typeof t.length == "number")
          return {
            next: function() {
              return t && r >= t.length && (t = void 0), {
                value: t && t[r++],
                done: !t
              };
            }
          };
        throw new TypeError(e ? "Object is not iterable." : "Symbol.iterator is not defined.");
      }
      function kt(t, e) {
        var n = typeof Symbol == "function" && t[Symbol.iterator];
        if (!n)
          return t;
        var r = n.call(t), i, o = [], s;
        try {
          for (; (e === void 0 || e-- > 0) && !(i = r.next()).done; )
            o.push(i.value);
        } catch (a) {
          s = {
            error: a
          };
        } finally {
          try {
            i && !i.done && (n = r.return) && n.call(r);
          } finally {
            if (s)
              throw s.error;
          }
        }
        return o;
      }
      function Hr(t, e, n) {
        if (n || arguments.length === 2)
          for (var r = 0, i = e.length, o; r < i; r++)
            (o || !(r in e)) && (o || (o = Array.prototype.slice.call(e, 0, r)), o[r] = e[r]);
        return t.concat(o || Array.prototype.slice.call(e));
      }
      var PV = "production", Kb = typeof process > "u" || process.env === void 0 ? PV : "production", _i = function(t) {
        return {
          isEnabled: function(e) {
            return t.some(function(n) {
              return !!e[n];
            });
          }
        };
      }, Tu = {
        measureLayout: _i([
          "layout",
          "layoutId",
          "drag"
        ]),
        animation: _i([
          "animate",
          "exit",
          "variants",
          "whileHover",
          "whileTap",
          "whileFocus",
          "whileDrag",
          "whileInView"
        ]),
        exit: _i([
          "exit"
        ]),
        drag: _i([
          "drag",
          "dragControls"
        ]),
        focus: _i([
          "whileFocus"
        ]),
        hover: _i([
          "whileHover",
          "onHoverStart",
          "onHoverEnd"
        ]),
        tap: _i([
          "whileTap",
          "onTap",
          "onTapStart",
          "onTapCancel"
        ]),
        pan: _i([
          "onPan",
          "onPanStart",
          "onPanSessionStart",
          "onPanEnd"
        ]),
        inView: _i([
          "whileInView",
          "onViewportEnter",
          "onViewportLeave"
        ])
      };
      function OV(t) {
        for (var e in t)
          t[e] !== null && (e === "projectionNodeConstructor" ? Tu.projectionNodeConstructor = t[e] : Tu[e].Component = t[e]);
      }
      var RV = function() {
      }, sp = function() {
      }, dE = z.exports.createContext({
        strict: false
      }), pE = Object.keys(Tu), LV = pE.length;
      function DV(t, e, n) {
        var r = [], i = z.exports.useContext(dE);
        if (!e)
          return null;
        Kb !== "production" && n && i.strict;
        for (var o = 0; o < LV; o++) {
          var s = pE[o], a = Tu[s], l = a.isEnabled, c = a.Component;
          l(t) && c && r.push(Z(c, {
            ...ie({
              key: s
            }, t, {
              visualElement: e
            })
          }));
        }
        return r;
      }
      var qb = z.exports.createContext({
        transformPagePoint: function(t) {
          return t;
        },
        isStatic: false,
        reducedMotion: "never"
      }), Pm = z.exports.createContext({});
      function _V() {
        return z.exports.useContext(Pm).visualElement;
      }
      var Tl = z.exports.createContext(null), Ml = typeof document < "u", ap = Ml ? z.exports.useLayoutEffect : z.exports.useEffect, dy = {
        current: null
      }, mE = false;
      function IV() {
        if (mE = true, !!Ml)
          if (window.matchMedia) {
            var t = window.matchMedia("(prefers-reduced-motion)"), e = function() {
              return dy.current = t.matches;
            };
            t.addListener(e), e();
          } else
            dy.current = false;
      }
      function BV() {
        !mE && IV();
        var t = kt(z.exports.useState(dy.current), 1), e = t[0];
        return e;
      }
      function NV() {
        var t = BV(), e = z.exports.useContext(qb).reducedMotion;
        return e === "never" ? false : e === "always" ? true : t;
      }
      function $V(t, e, n, r) {
        var i = z.exports.useContext(dE), o = _V(), s = z.exports.useContext(Tl), a = NV(), l = z.exports.useRef(void 0);
        r || (r = i.renderer), !l.current && r && (l.current = r(t, {
          visualState: e,
          parent: o,
          props: n,
          presenceId: s == null ? void 0 : s.id,
          blockInitialAnimation: (s == null ? void 0 : s.initial) === false,
          shouldReduceMotion: a
        }));
        var c = l.current;
        return ap(function() {
          c == null ? void 0 : c.syncRender();
        }), z.exports.useEffect(function() {
          var u;
          (u = c == null ? void 0 : c.animationState) === null || u === void 0 || u.animateChanges();
        }), ap(function() {
          return function() {
            return c == null ? void 0 : c.notifyUnmount();
          };
        }, []), c;
      }
      function Oa(t) {
        return typeof t == "object" && Object.prototype.hasOwnProperty.call(t, "current");
      }
      function zV(t, e, n) {
        return z.exports.useCallback(function(r) {
          var i;
          r && ((i = t.mount) === null || i === void 0 || i.call(t, r)), e && (r ? e.mount(r) : e.unmount()), n && (typeof n == "function" ? n(r) : Oa(n) && (n.current = r));
        }, [
          e
        ]);
      }
      function gE(t) {
        return Array.isArray(t);
      }
      function Ir(t) {
        return typeof t == "string" || gE(t);
      }
      function FV(t) {
        var e = {};
        return t.forEachValue(function(n, r) {
          return e[r] = n.get();
        }), e;
      }
      function VV(t) {
        var e = {};
        return t.forEachValue(function(n, r) {
          return e[r] = n.getVelocity();
        }), e;
      }
      function vE(t, e, n, r, i) {
        var o;
        return r === void 0 && (r = {}), i === void 0 && (i = {}), typeof e == "function" && (e = e(n ?? t.custom, r, i)), typeof e == "string" && (e = (o = t.variants) === null || o === void 0 ? void 0 : o[e]), typeof e == "function" && (e = e(n ?? t.custom, r, i)), e;
      }
      function Om(t, e, n) {
        var r = t.getProps();
        return vE(r, e, n ?? r.custom, FV(t), VV(t));
      }
      function Rm(t) {
        var e;
        return typeof ((e = t.animate) === null || e === void 0 ? void 0 : e.start) == "function" || Ir(t.initial) || Ir(t.animate) || Ir(t.whileHover) || Ir(t.whileDrag) || Ir(t.whileTap) || Ir(t.whileFocus) || Ir(t.exit);
      }
      function yE(t) {
        return Boolean(Rm(t) || t.variants);
      }
      function HV(t, e) {
        if (Rm(t)) {
          var n = t.initial, r = t.animate;
          return {
            initial: n === false || Ir(n) ? n : void 0,
            animate: Ir(r) ? r : void 0
          };
        }
        return t.inherit !== false ? e : {};
      }
      function jV(t) {
        var e = HV(t, z.exports.useContext(Pm)), n = e.initial, r = e.animate;
        return z.exports.useMemo(function() {
          return {
            initial: n,
            animate: r
          };
        }, [
          Yw(n),
          Yw(r)
        ]);
      }
      function Yw(t) {
        return Array.isArray(t) ? t.join(" ") : t;
      }
      function Qu(t) {
        var e = z.exports.useRef(null);
        return e.current === null && (e.current = t()), e.current;
      }
      var Fc = {
        hasAnimatedSinceResize: true,
        hasEverUpdated: false
      }, WV = 1;
      function UV() {
        return Qu(function() {
          if (Fc.hasEverUpdated)
            return WV++;
        });
      }
      var Gb = z.exports.createContext({}), bE = z.exports.createContext({});
      function KV(t, e, n, r) {
        var i, o = e.layoutId, s = e.layout, a = e.drag, l = e.dragConstraints, c = e.layoutScroll, u = z.exports.useContext(bE);
        !r || !n || (n == null ? void 0 : n.projection) || (n.projection = new r(t, n.getLatestValues(), (i = n.parent) === null || i === void 0 ? void 0 : i.projection), n.projection.setOptions({
          layoutId: o,
          layout: s,
          alwaysMeasureLayout: Boolean(a) || l && Oa(l),
          visualElement: n,
          scheduleRender: function() {
            return n.scheduleRender();
          },
          animationType: typeof s == "string" ? s : "both",
          initialPromotionConfig: u,
          layoutScroll: c
        }));
      }
      var qV = function(t) {
        hE(e, t);
        function e() {
          return t !== null && t.apply(this, arguments) || this;
        }
        return e.prototype.getSnapshotBeforeUpdate = function() {
          return this.updateProps(), null;
        }, e.prototype.componentDidUpdate = function() {
        }, e.prototype.updateProps = function() {
          var n = this.props, r = n.visualElement, i = n.props;
          r && r.setProps(i);
        }, e.prototype.render = function() {
          return this.props.children;
        }, e;
      }(Wp.Component);
      function GV(t) {
        var e = t.preloadedFeatures, n = t.createVisualElement, r = t.projectionNodeConstructor, i = t.useRender, o = t.useVisualState, s = t.Component;
        e && OV(e);
        function a(l, c) {
          var u = YV(l);
          l = ie(ie({}, l), {
            layoutId: u
          });
          var h = z.exports.useContext(qb), p = null, v = jV(l), y = h.isStatic ? void 0 : UV(), S = o(l, h.isStatic);
          return !h.isStatic && Ml && (v.visualElement = $V(s, S, ie(ie({}, h), l), n), KV(y, l, v.visualElement, r || Tu.projectionNodeConstructor), p = DV(l, v.visualElement, e)), Xn(qV, {
            visualElement: v.visualElement,
            props: ie(ie({}, h), l),
            children: [
              p,
              Z(Pm.Provider, {
                value: v,
                children: i(s, l, y, zV(S, v.visualElement, c), S, h.isStatic, v.visualElement)
              })
            ]
          });
        }
        return z.exports.forwardRef(a);
      }
      function YV(t) {
        var e, n = t.layoutId, r = (e = z.exports.useContext(Gb)) === null || e === void 0 ? void 0 : e.id;
        return r && n !== void 0 ? r + "-" + n : n;
      }
      function XV(t) {
        function e(r, i) {
          return i === void 0 && (i = {}), GV(t(r, i));
        }
        if (typeof Proxy > "u")
          return e;
        var n = /* @__PURE__ */ new Map();
        return new Proxy(e, {
          get: function(r, i) {
            return n.has(i) || n.set(i, e(i)), n.get(i);
          }
        });
      }
      var QV = [
        "animate",
        "circle",
        "defs",
        "desc",
        "ellipse",
        "g",
        "image",
        "line",
        "filter",
        "marker",
        "mask",
        "metadata",
        "path",
        "pattern",
        "polygon",
        "polyline",
        "rect",
        "stop",
        "svg",
        "switch",
        "symbol",
        "text",
        "tspan",
        "use",
        "view"
      ];
      function Yb(t) {
        return typeof t != "string" || t.includes("-") ? false : !!(QV.indexOf(t) > -1 || /[A-Z]/.test(t));
      }
      var lp = {};
      function JV(t) {
        Object.assign(lp, t);
      }
      var py = [
        "",
        "X",
        "Y",
        "Z"
      ], ZV = [
        "translate",
        "scale",
        "rotate",
        "skew"
      ], Mu = [
        "transformPerspective",
        "x",
        "y",
        "z"
      ];
      ZV.forEach(function(t) {
        return py.forEach(function(e) {
          return Mu.push(t + e);
        });
      });
      function e6(t, e) {
        return Mu.indexOf(t) - Mu.indexOf(e);
      }
      var t6 = new Set(Mu);
      function Ju(t) {
        return t6.has(t);
      }
      var n6 = /* @__PURE__ */ new Set([
        "originX",
        "originY",
        "originZ"
      ]);
      function xE(t) {
        return n6.has(t);
      }
      function SE(t, e) {
        var n = e.layout, r = e.layoutId;
        return Ju(t) || xE(t) || (n || r !== void 0) && (!!lp[t] || t === "opacity");
      }
      var Zi = function(t) {
        return Boolean(t !== null && typeof t == "object" && t.getVelocity);
      }, r6 = {
        x: "translateX",
        y: "translateY",
        z: "translateZ",
        transformPerspective: "perspective"
      };
      function i6(t, e, n, r) {
        var i = t.transform, o = t.transformKeys, s = e.enableHardwareAcceleration, a = s === void 0 ? true : s, l = e.allowTransformNone, c = l === void 0 ? true : l, u = "";
        o.sort(e6);
        for (var h = false, p = o.length, v = 0; v < p; v++) {
          var y = o[v];
          u += "".concat(r6[y] || y, "(").concat(i[y], ") "), y === "z" && (h = true);
        }
        return !h && a ? u += "translateZ(0)" : u = u.trim(), r ? u = r(i, n ? "" : u) : c && n && (u = "none"), u;
      }
      function o6(t) {
        var e = t.originX, n = e === void 0 ? "50%" : e, r = t.originY, i = r === void 0 ? "50%" : r, o = t.originZ, s = o === void 0 ? 0 : o;
        return "".concat(n, " ").concat(i, " ").concat(s);
      }
      function wE(t) {
        return t.startsWith("--");
      }
      var s6 = function(t, e) {
        return e && typeof t == "number" ? e.transform(t) : t;
      };
      const kE = (t, e) => (n) => Math.max(Math.min(n, e), t), Vc = (t) => t % 1 ? Number(t.toFixed(5)) : t, Au = /(-)?([\d]*\.?[\d])+/g, my = /(#[0-9a-f]{6}|#[0-9a-f]{3}|#(?:[0-9a-f]{2}){2,4}|(rgb|hsl)a?\((-?[\d\.]+%?[,\s]+){2,3}\s*\/*\s*[\d\.]+%?\))/gi, a6 = /^(#[0-9a-f]{3}|#(?:[0-9a-f]{2}){2,4}|(rgb|hsl)a?\((-?[\d\.]+%?[,\s]+){2,3}\s*\/*\s*[\d\.]+%?\))$/i;
      function Zu(t) {
        return typeof t == "string";
      }
      const Xs = {
        test: (t) => typeof t == "number",
        parse: parseFloat,
        transform: (t) => t
      }, Hc = Object.assign(Object.assign({}, Xs), {
        transform: kE(0, 1)
      }), fh = Object.assign(Object.assign({}, Xs), {
        default: 1
      }), ef = (t) => ({
        test: (e) => Zu(e) && e.endsWith(t) && e.split(" ").length === 1,
        parse: parseFloat,
        transform: (e) => `${e}${t}`
      }), go = ef("deg"), wi = ef("%"), Ce = ef("px"), l6 = ef("vh"), c6 = ef("vw"), Xw = Object.assign(Object.assign({}, wi), {
        parse: (t) => wi.parse(t) / 100,
        transform: (t) => wi.transform(t * 100)
      }), Xb = (t, e) => (n) => Boolean(Zu(n) && a6.test(n) && n.startsWith(t) || e && Object.prototype.hasOwnProperty.call(n, e)), CE = (t, e, n) => (r) => {
        if (!Zu(r))
          return r;
        const [i, o, s, a] = r.match(Au);
        return {
          [t]: parseFloat(i),
          [e]: parseFloat(o),
          [n]: parseFloat(s),
          alpha: a !== void 0 ? parseFloat(a) : 1
        };
      }, Ms = {
        test: Xb("hsl", "hue"),
        parse: CE("hue", "saturation", "lightness"),
        transform: ({ hue: t, saturation: e, lightness: n, alpha: r = 1 }) => "hsla(" + Math.round(t) + ", " + wi.transform(Vc(e)) + ", " + wi.transform(Vc(n)) + ", " + Vc(Hc.transform(r)) + ")"
      }, u6 = kE(0, 255), g0 = Object.assign(Object.assign({}, Xs), {
        transform: (t) => Math.round(u6(t))
      }), Oo = {
        test: Xb("rgb", "red"),
        parse: CE("red", "green", "blue"),
        transform: ({ red: t, green: e, blue: n, alpha: r = 1 }) => "rgba(" + g0.transform(t) + ", " + g0.transform(e) + ", " + g0.transform(n) + ", " + Vc(Hc.transform(r)) + ")"
      };
      function f6(t) {
        let e = "", n = "", r = "", i = "";
        return t.length > 5 ? (e = t.substr(1, 2), n = t.substr(3, 2), r = t.substr(5, 2), i = t.substr(7, 2)) : (e = t.substr(1, 1), n = t.substr(2, 1), r = t.substr(3, 1), i = t.substr(4, 1), e += e, n += n, r += r, i += i), {
          red: parseInt(e, 16),
          green: parseInt(n, 16),
          blue: parseInt(r, 16),
          alpha: i ? parseInt(i, 16) / 255 : 1
        };
      }
      const gy = {
        test: Xb("#"),
        parse: f6,
        transform: Oo.transform
      }, yn = {
        test: (t) => Oo.test(t) || gy.test(t) || Ms.test(t),
        parse: (t) => Oo.test(t) ? Oo.parse(t) : Ms.test(t) ? Ms.parse(t) : gy.parse(t),
        transform: (t) => Zu(t) ? t : t.hasOwnProperty("red") ? Oo.transform(t) : Ms.transform(t)
      }, TE = "${c}", ME = "${n}";
      function h6(t) {
        var e, n, r, i;
        return isNaN(t) && Zu(t) && ((n = (e = t.match(Au)) === null || e === void 0 ? void 0 : e.length) !== null && n !== void 0 ? n : 0) + ((i = (r = t.match(my)) === null || r === void 0 ? void 0 : r.length) !== null && i !== void 0 ? i : 0) > 0;
      }
      function AE(t) {
        typeof t == "number" && (t = `${t}`);
        const e = [];
        let n = 0;
        const r = t.match(my);
        r && (n = r.length, t = t.replace(my, TE), e.push(...r.map(yn.parse)));
        const i = t.match(Au);
        return i && (t = t.replace(Au, ME), e.push(...i.map(Xs.parse))), {
          values: e,
          numColors: n,
          tokenised: t
        };
      }
      function EE(t) {
        return AE(t).values;
      }
      function PE(t) {
        const { values: e, numColors: n, tokenised: r } = AE(t), i = e.length;
        return (o) => {
          let s = r;
          for (let a = 0; a < i; a++)
            s = s.replace(a < n ? TE : ME, a < n ? yn.transform(o[a]) : Vc(o[a]));
          return s;
        };
      }
      const d6 = (t) => typeof t == "number" ? 0 : t;
      function p6(t) {
        const e = EE(t);
        return PE(t)(e.map(d6));
      }
      const eo = {
        test: h6,
        parse: EE,
        createTransformer: PE,
        getAnimatableNone: p6
      }, m6 = /* @__PURE__ */ new Set([
        "brightness",
        "contrast",
        "saturate",
        "opacity"
      ]);
      function g6(t) {
        let [e, n] = t.slice(0, -1).split("(");
        if (e === "drop-shadow")
          return t;
        const [r] = n.match(Au) || [];
        if (!r)
          return t;
        const i = n.replace(r, "");
        let o = m6.has(e) ? 1 : 0;
        return r !== n && (o *= 100), e + "(" + o + i + ")";
      }
      const v6 = /([a-z-]*)\(.*?\)/g, vy = Object.assign(Object.assign({}, eo), {
        getAnimatableNone: (t) => {
          const e = t.match(v6);
          return e ? e.map(g6).join(" ") : t;
        }
      });
      var Qw = ie(ie({}, Xs), {
        transform: Math.round
      }), OE = {
        borderWidth: Ce,
        borderTopWidth: Ce,
        borderRightWidth: Ce,
        borderBottomWidth: Ce,
        borderLeftWidth: Ce,
        borderRadius: Ce,
        radius: Ce,
        borderTopLeftRadius: Ce,
        borderTopRightRadius: Ce,
        borderBottomRightRadius: Ce,
        borderBottomLeftRadius: Ce,
        width: Ce,
        maxWidth: Ce,
        height: Ce,
        maxHeight: Ce,
        size: Ce,
        top: Ce,
        right: Ce,
        bottom: Ce,
        left: Ce,
        padding: Ce,
        paddingTop: Ce,
        paddingRight: Ce,
        paddingBottom: Ce,
        paddingLeft: Ce,
        margin: Ce,
        marginTop: Ce,
        marginRight: Ce,
        marginBottom: Ce,
        marginLeft: Ce,
        rotate: go,
        rotateX: go,
        rotateY: go,
        rotateZ: go,
        scale: fh,
        scaleX: fh,
        scaleY: fh,
        scaleZ: fh,
        skew: go,
        skewX: go,
        skewY: go,
        distance: Ce,
        translateX: Ce,
        translateY: Ce,
        translateZ: Ce,
        x: Ce,
        y: Ce,
        z: Ce,
        perspective: Ce,
        transformPerspective: Ce,
        opacity: Hc,
        originX: Xw,
        originY: Xw,
        originZ: Ce,
        zIndex: Qw,
        fillOpacity: Hc,
        strokeOpacity: Hc,
        numOctaves: Qw
      };
      function Qb(t, e, n, r) {
        var i, o = t.style, s = t.vars, a = t.transform, l = t.transformKeys, c = t.transformOrigin;
        l.length = 0;
        var u = false, h = false, p = true;
        for (var v in e) {
          var y = e[v];
          if (wE(v)) {
            s[v] = y;
            continue;
          }
          var S = OE[v], C = s6(y, S);
          if (Ju(v)) {
            if (u = true, a[v] = C, l.push(v), !p)
              continue;
            y !== ((i = S.default) !== null && i !== void 0 ? i : 0) && (p = false);
          } else
            xE(v) ? (c[v] = C, h = true) : o[v] = C;
        }
        u ? o.transform = i6(t, n, p, r) : r ? o.transform = r({}, "") : !e.transform && o.transform && (o.transform = "none"), h && (o.transformOrigin = o6(c));
      }
      var Jb = function() {
        return {
          style: {},
          transform: {},
          transformKeys: [],
          transformOrigin: {},
          vars: {}
        };
      };
      function RE(t, e, n) {
        for (var r in e)
          !Zi(e[r]) && !SE(r, n) && (t[r] = e[r]);
      }
      function y6(t, e, n) {
        var r = t.transformTemplate;
        return z.exports.useMemo(function() {
          var i = Jb();
          Qb(i, e, {
            enableHardwareAcceleration: !n
          }, r);
          var o = i.vars, s = i.style;
          return ie(ie({}, o), s);
        }, [
          e
        ]);
      }
      function b6(t, e, n) {
        var r = t.style || {}, i = {};
        return RE(i, r, t), Object.assign(i, y6(t, e, n)), t.transformValues && (i = t.transformValues(i)), i;
      }
      function x6(t, e, n) {
        var r = {}, i = b6(t, e, n);
        return Boolean(t.drag) && t.dragListener !== false && (r.draggable = false, i.userSelect = i.WebkitUserSelect = i.WebkitTouchCallout = "none", i.touchAction = t.drag === true ? "none" : "pan-".concat(t.drag === "x" ? "y" : "x")), r.style = i, r;
      }
      var S6 = /* @__PURE__ */ new Set([
        "initial",
        "animate",
        "exit",
        "style",
        "variants",
        "transition",
        "transformTemplate",
        "transformValues",
        "custom",
        "inherit",
        "layout",
        "layoutId",
        "layoutDependency",
        "onLayoutAnimationStart",
        "onLayoutAnimationComplete",
        "onLayoutMeasure",
        "onBeforeLayoutMeasure",
        "onAnimationStart",
        "onAnimationComplete",
        "onUpdate",
        "onDragStart",
        "onDrag",
        "onDragEnd",
        "onMeasureDragConstraints",
        "onDirectionLock",
        "onDragTransitionEnd",
        "drag",
        "dragControls",
        "dragListener",
        "dragConstraints",
        "dragDirectionLock",
        "dragSnapToOrigin",
        "_dragX",
        "_dragY",
        "dragElastic",
        "dragMomentum",
        "dragPropagation",
        "dragTransition",
        "whileDrag",
        "onPan",
        "onPanStart",
        "onPanEnd",
        "onPanSessionStart",
        "onTap",
        "onTapStart",
        "onTapCancel",
        "onHoverStart",
        "onHoverEnd",
        "whileFocus",
        "whileTap",
        "whileHover",
        "whileInView",
        "onViewportEnter",
        "onViewportLeave",
        "viewport",
        "layoutScroll"
      ]);
      function cp(t) {
        return S6.has(t);
      }
      var LE = function(t) {
        return !cp(t);
      };
      function w6(t) {
        !t || (LE = function(e) {
          return e.startsWith("on") ? !cp(e) : t(e);
        });
      }
      try {
        w6(require("@emotion/is-prop-valid").default);
      } catch {
      }
      function k6(t, e, n) {
        var r = {};
        for (var i in t)
          (LE(i) || n === true && cp(i) || !e && !cp(i) || t.draggable && i.startsWith("onDrag")) && (r[i] = t[i]);
        return r;
      }
      function Jw(t, e, n) {
        return typeof t == "string" ? t : Ce.transform(e + n * t);
      }
      function C6(t, e, n) {
        var r = Jw(e, t.x, t.width), i = Jw(n, t.y, t.height);
        return "".concat(r, " ").concat(i);
      }
      var T6 = {
        offset: "stroke-dashoffset",
        array: "stroke-dasharray"
      }, M6 = {
        offset: "strokeDashoffset",
        array: "strokeDasharray"
      };
      function A6(t, e, n, r, i) {
        n === void 0 && (n = 1), r === void 0 && (r = 0), i === void 0 && (i = true), t.pathLength = 1;
        var o = i ? T6 : M6;
        t[o.offset] = Ce.transform(-r);
        var s = Ce.transform(e), a = Ce.transform(n);
        t[o.array] = "".concat(s, " ").concat(a);
      }
      function Zb(t, e, n, r) {
        var i = e.attrX, o = e.attrY, s = e.originX, a = e.originY, l = e.pathLength, c = e.pathSpacing, u = c === void 0 ? 1 : c, h = e.pathOffset, p = h === void 0 ? 0 : h, v = Tr(e, [
          "attrX",
          "attrY",
          "originX",
          "originY",
          "pathLength",
          "pathSpacing",
          "pathOffset"
        ]);
        Qb(t, v, n, r), t.attrs = t.style, t.style = {};
        var y = t.attrs, S = t.style, C = t.dimensions;
        y.transform && (C && (S.transform = y.transform), delete y.transform), C && (s !== void 0 || a !== void 0 || S.transform) && (S.transformOrigin = C6(C, s !== void 0 ? s : 0.5, a !== void 0 ? a : 0.5)), i !== void 0 && (y.x = i), o !== void 0 && (y.y = o), l !== void 0 && A6(y, l, u, p, false);
      }
      var DE = function() {
        return ie(ie({}, Jb()), {
          attrs: {}
        });
      };
      function E6(t, e) {
        var n = z.exports.useMemo(function() {
          var i = DE();
          return Zb(i, e, {
            enableHardwareAcceleration: false
          }, t.transformTemplate), ie(ie({}, i.attrs), {
            style: ie({}, i.style)
          });
        }, [
          e
        ]);
        if (t.style) {
          var r = {};
          RE(r, t.style, t), n.style = ie(ie({}, r), n.style);
        }
        return n;
      }
      function P6(t) {
        t === void 0 && (t = false);
        var e = function(n, r, i, o, s, a) {
          var l = s.latestValues, c = Yb(n) ? E6 : x6, u = c(r, l, a), h = k6(r, typeof n == "string", t), p = ie(ie(ie({}, h), u), {
            ref: o
          });
          return i && (p["data-projection-id"] = i), z.exports.createElement(n, p);
        };
        return e;
      }
      var O6 = /([a-z])([A-Z])/g, R6 = "$1-$2", _E = function(t) {
        return t.replace(O6, R6).toLowerCase();
      };
      function IE(t, e, n, r) {
        var i = e.style, o = e.vars;
        Object.assign(t.style, i, r && r.getProjectionStyles(n));
        for (var s in o)
          t.style.setProperty(s, o[s]);
      }
      var BE = /* @__PURE__ */ new Set([
        "baseFrequency",
        "diffuseConstant",
        "kernelMatrix",
        "kernelUnitLength",
        "keySplines",
        "keyTimes",
        "limitingConeAngle",
        "markerHeight",
        "markerWidth",
        "numOctaves",
        "targetX",
        "targetY",
        "surfaceScale",
        "specularConstant",
        "specularExponent",
        "stdDeviation",
        "tableValues",
        "viewBox",
        "gradientTransform",
        "pathLength"
      ]);
      function NE(t, e, n, r) {
        IE(t, e, void 0, r);
        for (var i in e.attrs)
          t.setAttribute(BE.has(i) ? i : _E(i), e.attrs[i]);
      }
      function ex(t) {
        var e = t.style, n = {};
        for (var r in e)
          (Zi(e[r]) || SE(r, t)) && (n[r] = e[r]);
        return n;
      }
      function $E(t) {
        var e = ex(t);
        for (var n in t)
          if (Zi(t[n])) {
            var r = n === "x" || n === "y" ? "attr" + n.toUpperCase() : n;
            e[r] = t[n];
          }
        return e;
      }
      function tx(t) {
        return typeof t == "object" && typeof t.start == "function";
      }
      var Eu = function(t) {
        return Array.isArray(t);
      }, L6 = function(t) {
        return Boolean(t && typeof t == "object" && t.mix && t.toValue);
      }, zE = function(t) {
        return Eu(t) ? t[t.length - 1] || 0 : t;
      };
      function dd(t) {
        var e = Zi(t) ? t.get() : t;
        return L6(e) ? e.toValue() : e;
      }
      function Zw(t, e, n, r) {
        var i = t.scrapeMotionValuesFromProps, o = t.createRenderState, s = t.onMount, a = {
          latestValues: D6(e, n, r, i),
          renderState: o()
        };
        return s && (a.mount = function(l) {
          return s(e, l, a);
        }), a;
      }
      var FE = function(t) {
        return function(e, n) {
          var r = z.exports.useContext(Pm), i = z.exports.useContext(Tl);
          return n ? Zw(t, e, r, i) : Qu(function() {
            return Zw(t, e, r, i);
          });
        };
      };
      function D6(t, e, n, r) {
        var i = {}, o = (n == null ? void 0 : n.initial) === false, s = r(t);
        for (var a in s)
          i[a] = dd(s[a]);
        var l = t.initial, c = t.animate, u = Rm(t), h = yE(t);
        e && h && !u && t.inherit !== false && (l ?? (l = e.initial), c ?? (c = e.animate));
        var p = o || l === false, v = p ? c : l;
        if (v && typeof v != "boolean" && !tx(v)) {
          var y = Array.isArray(v) ? v : [
            v
          ];
          y.forEach(function(S) {
            var C = vE(t, S);
            if (!!C) {
              var w = C.transitionEnd;
              C.transition;
              var k = Tr(C, [
                "transitionEnd",
                "transition"
              ]);
              for (var T in k) {
                var P = k[T];
                if (Array.isArray(P)) {
                  var R = p ? P.length - 1 : 0;
                  P = P[R];
                }
                P !== null && (i[T] = P);
              }
              for (var T in w)
                i[T] = w[T];
            }
          });
        }
        return i;
      }
      var _6 = {
        useVisualState: FE({
          scrapeMotionValuesFromProps: $E,
          createRenderState: DE,
          onMount: function(t, e, n) {
            var r = n.renderState, i = n.latestValues;
            try {
              r.dimensions = typeof e.getBBox == "function" ? e.getBBox() : e.getBoundingClientRect();
            } catch {
              r.dimensions = {
                x: 0,
                y: 0,
                width: 0,
                height: 0
              };
            }
            Zb(r, i, {
              enableHardwareAcceleration: false
            }, t.transformTemplate), NE(e, r);
          }
        })
      }, I6 = {
        useVisualState: FE({
          scrapeMotionValuesFromProps: ex,
          createRenderState: Jb
        })
      };
      function B6(t, e, n, r, i) {
        var o = e.forwardMotionProps, s = o === void 0 ? false : o, a = Yb(t) ? _6 : I6;
        return ie(ie({}, a), {
          preloadedFeatures: n,
          useRender: P6(s),
          createVisualElement: r,
          projectionNodeConstructor: i,
          Component: t
        });
      }
      var tt;
      (function(t) {
        t.Animate = "animate", t.Hover = "whileHover", t.Tap = "whileTap", t.Drag = "whileDrag", t.Focus = "whileFocus", t.InView = "whileInView", t.Exit = "exit";
      })(tt || (tt = {}));
      function Lm(t, e, n, r) {
        return r === void 0 && (r = {
          passive: true
        }), t.addEventListener(e, n, r), function() {
          return t.removeEventListener(e, n);
        };
      }
      function yy(t, e, n, r) {
        z.exports.useEffect(function() {
          var i = t.current;
          if (n && i)
            return Lm(i, e, n, r);
        }, [
          t,
          e,
          n,
          r
        ]);
      }
      function N6(t) {
        var e = t.whileFocus, n = t.visualElement, r = function() {
          var o;
          (o = n.animationState) === null || o === void 0 || o.setActive(tt.Focus, true);
        }, i = function() {
          var o;
          (o = n.animationState) === null || o === void 0 || o.setActive(tt.Focus, false);
        };
        yy(n, "focus", e ? r : void 0), yy(n, "blur", e ? i : void 0);
      }
      function VE(t) {
        return typeof PointerEvent < "u" && t instanceof PointerEvent ? t.pointerType === "mouse" : t instanceof MouseEvent;
      }
      function HE(t) {
        var e = !!t.touches;
        return e;
      }
      function $6(t) {
        return function(e) {
          var n = e instanceof MouseEvent, r = !n || n && e.button === 0;
          r && t(e);
        };
      }
      var z6 = {
        pageX: 0,
        pageY: 0
      };
      function F6(t, e) {
        e === void 0 && (e = "page");
        var n = t.touches[0] || t.changedTouches[0], r = n || z6;
        return {
          x: r[e + "X"],
          y: r[e + "Y"]
        };
      }
      function V6(t, e) {
        return e === void 0 && (e = "page"), {
          x: t[e + "X"],
          y: t[e + "Y"]
        };
      }
      function nx(t, e) {
        return e === void 0 && (e = "page"), {
          point: HE(t) ? F6(t, e) : V6(t, e)
        };
      }
      var jE = function(t, e) {
        e === void 0 && (e = false);
        var n = function(r) {
          return t(r, nx(r));
        };
        return e ? $6(n) : n;
      }, H6 = function() {
        return Ml && window.onpointerdown === null;
      }, j6 = function() {
        return Ml && window.ontouchstart === null;
      }, W6 = function() {
        return Ml && window.onmousedown === null;
      }, U6 = {
        pointerdown: "mousedown",
        pointermove: "mousemove",
        pointerup: "mouseup",
        pointercancel: "mousecancel",
        pointerover: "mouseover",
        pointerout: "mouseout",
        pointerenter: "mouseenter",
        pointerleave: "mouseleave"
      }, K6 = {
        pointerdown: "touchstart",
        pointermove: "touchmove",
        pointerup: "touchend",
        pointercancel: "touchcancel"
      };
      function WE(t) {
        return H6() ? t : j6() ? K6[t] : W6() ? U6[t] : t;
      }
      function Ua(t, e, n, r) {
        return Lm(t, WE(e), jE(n, e === "pointerdown"), r);
      }
      function up(t, e, n, r) {
        return yy(t, WE(e), n && jE(n, e === "pointerdown"), r);
      }
      function UE(t) {
        var e = null;
        return function() {
          var n = function() {
            e = null;
          };
          return e === null ? (e = t, n) : false;
        };
      }
      var ek = UE("dragHorizontal"), tk = UE("dragVertical");
      function KE(t) {
        var e = false;
        if (t === "y")
          e = tk();
        else if (t === "x")
          e = ek();
        else {
          var n = ek(), r = tk();
          n && r ? e = function() {
            n(), r();
          } : (n && n(), r && r());
        }
        return e;
      }
      function qE() {
        var t = KE(true);
        return t ? (t(), false) : true;
      }
      function nk(t, e, n) {
        return function(r, i) {
          var o;
          !VE(r) || qE() || ((o = t.animationState) === null || o === void 0 || o.setActive(tt.Hover, e), n == null ? void 0 : n(r, i));
        };
      }
      function q6(t) {
        var e = t.onHoverStart, n = t.onHoverEnd, r = t.whileHover, i = t.visualElement;
        up(i, "pointerenter", e || r ? nk(i, true, e) : void 0, {
          passive: !e
        }), up(i, "pointerleave", n || r ? nk(i, false, n) : void 0, {
          passive: !n
        });
      }
      var GE = function(t, e) {
        return e ? t === e ? true : GE(t, e.parentElement) : false;
      };
      function rx(t) {
        return z.exports.useEffect(function() {
          return function() {
            return t();
          };
        }, []);
      }
      const fp = (t, e, n) => Math.min(Math.max(n, t), e), v0 = 1e-3, G6 = 0.01, rk = 10, Y6 = 0.05, X6 = 1;
      function Q6({ duration: t = 800, bounce: e = 0.25, velocity: n = 0, mass: r = 1 }) {
        let i, o;
        RV(t <= rk * 1e3);
        let s = 1 - e;
        s = fp(Y6, X6, s), t = fp(G6, rk, t / 1e3), s < 1 ? (i = (c) => {
          const u = c * s, h = u * t, p = u - n, v = by(c, s), y = Math.exp(-h);
          return v0 - p / v * y;
        }, o = (c) => {
          const h = c * s * t, p = h * n + n, v = Math.pow(s, 2) * Math.pow(c, 2) * t, y = Math.exp(-h), S = by(Math.pow(c, 2), s);
          return (-i(c) + v0 > 0 ? -1 : 1) * ((p - v) * y) / S;
        }) : (i = (c) => {
          const u = Math.exp(-c * t), h = (c - n) * t + 1;
          return -v0 + u * h;
        }, o = (c) => {
          const u = Math.exp(-c * t), h = (n - c) * (t * t);
          return u * h;
        });
        const a = 5 / t, l = Z6(i, o, a);
        if (t = t * 1e3, isNaN(l))
          return {
            stiffness: 100,
            damping: 10,
            duration: t
          };
        {
          const c = Math.pow(l, 2) * r;
          return {
            stiffness: c,
            damping: s * 2 * Math.sqrt(r * c),
            duration: t
          };
        }
      }
      const J6 = 12;
      function Z6(t, e, n) {
        let r = n;
        for (let i = 1; i < J6; i++)
          r = r - t(r) / e(r);
        return r;
      }
      function by(t, e) {
        return t * Math.sqrt(1 - e * e);
      }
      const e8 = [
        "duration",
        "bounce"
      ], t8 = [
        "stiffness",
        "damping",
        "mass"
      ];
      function ik(t, e) {
        return e.some((n) => t[n] !== void 0);
      }
      function n8(t) {
        let e = Object.assign({
          velocity: 0,
          stiffness: 100,
          damping: 10,
          mass: 1,
          isResolvedFromDuration: false
        }, t);
        if (!ik(t, t8) && ik(t, e8)) {
          const n = Q6(t);
          e = Object.assign(Object.assign(Object.assign({}, e), n), {
            velocity: 0,
            mass: 1
          }), e.isResolvedFromDuration = true;
        }
        return e;
      }
      function ix(t) {
        var { from: e = 0, to: n = 1, restSpeed: r = 2, restDelta: i } = t, o = Tr(t, [
          "from",
          "to",
          "restSpeed",
          "restDelta"
        ]);
        const s = {
          done: false,
          value: e
        };
        let { stiffness: a, damping: l, mass: c, velocity: u, duration: h, isResolvedFromDuration: p } = n8(o), v = ok, y = ok;
        function S() {
          const C = u ? -(u / 1e3) : 0, w = n - e, k = l / (2 * Math.sqrt(a * c)), T = Math.sqrt(a / c) / 1e3;
          if (i === void 0 && (i = Math.min(Math.abs(n - e) / 100, 0.4)), k < 1) {
            const P = by(T, k);
            v = (R) => {
              const L = Math.exp(-k * T * R);
              return n - L * ((C + k * T * w) / P * Math.sin(P * R) + w * Math.cos(P * R));
            }, y = (R) => {
              const L = Math.exp(-k * T * R);
              return k * T * L * (Math.sin(P * R) * (C + k * T * w) / P + w * Math.cos(P * R)) - L * (Math.cos(P * R) * (C + k * T * w) - P * w * Math.sin(P * R));
            };
          } else if (k === 1)
            v = (P) => n - Math.exp(-T * P) * (w + (C + T * w) * P);
          else {
            const P = T * Math.sqrt(k * k - 1);
            v = (R) => {
              const L = Math.exp(-k * T * R), D = Math.min(P * R, 300);
              return n - L * ((C + k * T * w) * Math.sinh(D) + P * w * Math.cosh(D)) / P;
            };
          }
        }
        return S(), {
          next: (C) => {
            const w = v(C);
            if (p)
              s.done = C >= h;
            else {
              const k = y(C) * 1e3, T = Math.abs(k) <= r, P = Math.abs(n - w) <= i;
              s.done = T && P;
            }
            return s.value = s.done ? n : w, s;
          },
          flipTarget: () => {
            u = -u, [e, n] = [
              n,
              e
            ], S();
          }
        };
      }
      ix.needsInterpolation = (t, e) => typeof t == "string" || typeof e == "string";
      const ok = (t) => 0, Pu = (t, e, n) => {
        const r = e - t;
        return r === 0 ? 1 : (n - t) / r;
      }, wt = (t, e, n) => -n * t + n * e + t;
      function y0(t, e, n) {
        return n < 0 && (n += 1), n > 1 && (n -= 1), n < 1 / 6 ? t + (e - t) * 6 * n : n < 1 / 2 ? e : n < 2 / 3 ? t + (e - t) * (2 / 3 - n) * 6 : t;
      }
      function sk({ hue: t, saturation: e, lightness: n, alpha: r }) {
        t /= 360, e /= 100, n /= 100;
        let i = 0, o = 0, s = 0;
        if (!e)
          i = o = s = n;
        else {
          const a = n < 0.5 ? n * (1 + e) : n + e - n * e, l = 2 * n - a;
          i = y0(l, a, t + 1 / 3), o = y0(l, a, t), s = y0(l, a, t - 1 / 3);
        }
        return {
          red: Math.round(i * 255),
          green: Math.round(o * 255),
          blue: Math.round(s * 255),
          alpha: r
        };
      }
      const r8 = (t, e, n) => {
        const r = t * t, i = e * e;
        return Math.sqrt(Math.max(0, n * (i - r) + r));
      }, i8 = [
        gy,
        Oo,
        Ms
      ], ak = (t) => i8.find((e) => e.test(t)), YE = (t, e) => {
        let n = ak(t), r = ak(e), i = n.parse(t), o = r.parse(e);
        n === Ms && (i = sk(i), n = Oo), r === Ms && (o = sk(o), r = Oo);
        const s = Object.assign({}, i);
        return (a) => {
          for (const l in s)
            l !== "alpha" && (s[l] = r8(i[l], o[l], a));
          return s.alpha = wt(i.alpha, o.alpha, a), n.transform(s);
        };
      }, xy = (t) => typeof t == "number", o8 = (t, e) => (n) => e(t(n)), Dm = (...t) => t.reduce(o8);
      function XE(t, e) {
        return xy(t) ? (n) => wt(t, e, n) : yn.test(t) ? YE(t, e) : JE(t, e);
      }
      const QE = (t, e) => {
        const n = [
          ...t
        ], r = n.length, i = t.map((o, s) => XE(o, e[s]));
        return (o) => {
          for (let s = 0; s < r; s++)
            n[s] = i[s](o);
          return n;
        };
      }, s8 = (t, e) => {
        const n = Object.assign(Object.assign({}, t), e), r = {};
        for (const i in n)
          t[i] !== void 0 && e[i] !== void 0 && (r[i] = XE(t[i], e[i]));
        return (i) => {
          for (const o in r)
            n[o] = r[o](i);
          return n;
        };
      };
      function lk(t) {
        const e = eo.parse(t), n = e.length;
        let r = 0, i = 0, o = 0;
        for (let s = 0; s < n; s++)
          r || typeof e[s] == "number" ? r++ : e[s].hue !== void 0 ? o++ : i++;
        return {
          parsed: e,
          numNumbers: r,
          numRGB: i,
          numHSL: o
        };
      }
      const JE = (t, e) => {
        const n = eo.createTransformer(e), r = lk(t), i = lk(e);
        return r.numHSL === i.numHSL && r.numRGB === i.numRGB && r.numNumbers >= i.numNumbers ? Dm(QE(r.parsed, i.parsed), n) : (s) => `${s > 0 ? e : t}`;
      }, a8 = (t, e) => (n) => wt(t, e, n);
      function l8(t) {
        if (typeof t == "number")
          return a8;
        if (typeof t == "string")
          return yn.test(t) ? YE : JE;
        if (Array.isArray(t))
          return QE;
        if (typeof t == "object")
          return s8;
      }
      function c8(t, e, n) {
        const r = [], i = n || l8(t[0]), o = t.length - 1;
        for (let s = 0; s < o; s++) {
          let a = i(t[s], t[s + 1]);
          if (e) {
            const l = Array.isArray(e) ? e[s] : e;
            a = Dm(l, a);
          }
          r.push(a);
        }
        return r;
      }
      function u8([t, e], [n]) {
        return (r) => n(Pu(t, e, r));
      }
      function f8(t, e) {
        const n = t.length, r = n - 1;
        return (i) => {
          let o = 0, s = false;
          if (i <= t[0] ? s = true : i >= t[r] && (o = r - 1, s = true), !s) {
            let l = 1;
            for (; l < n && !(t[l] > i || l === r); l++)
              ;
            o = l - 1;
          }
          const a = Pu(t[o], t[o + 1], i);
          return e[o](a);
        };
      }
      function ZE(t, e, { clamp: n = true, ease: r, mixer: i } = {}) {
        const o = t.length;
        sp(o === e.length), sp(!r || !Array.isArray(r) || r.length === o - 1), t[0] > t[o - 1] && (t = [].concat(t), e = [].concat(e), t.reverse(), e.reverse());
        const s = c8(e, r, i), a = o === 2 ? u8(t, s) : f8(t, s);
        return n ? (l) => a(fp(t[0], t[o - 1], l)) : a;
      }
      const _m = (t) => (e) => 1 - t(1 - e), ox = (t) => (e) => e <= 0.5 ? t(2 * e) / 2 : (2 - t(2 * (1 - e))) / 2, h8 = (t) => (e) => Math.pow(e, t), eP = (t) => (e) => e * e * ((t + 1) * e - t), d8 = (t) => {
        const e = eP(t);
        return (n) => (n *= 2) < 1 ? 0.5 * e(n) : 0.5 * (2 - Math.pow(2, -10 * (n - 1)));
      }, tP = 1.525, p8 = 4 / 11, m8 = 8 / 11, g8 = 9 / 10, sx = (t) => t, ax = h8(2), v8 = _m(ax), nP = ox(ax), rP = (t) => 1 - Math.sin(Math.acos(t)), lx = _m(rP), y8 = ox(lx), cx = eP(tP), b8 = _m(cx), x8 = ox(cx), S8 = d8(tP), w8 = 4356 / 361, k8 = 35442 / 1805, C8 = 16061 / 1805, hp = (t) => {
        if (t === 1 || t === 0)
          return t;
        const e = t * t;
        return t < p8 ? 7.5625 * e : t < m8 ? 9.075 * e - 9.9 * t + 3.4 : t < g8 ? w8 * e - k8 * t + C8 : 10.8 * t * t - 20.52 * t + 10.72;
      }, T8 = _m(hp), M8 = (t) => t < 0.5 ? 0.5 * (1 - hp(1 - t * 2)) : 0.5 * hp(t * 2 - 1) + 0.5;
      function A8(t, e) {
        return t.map(() => e || nP).splice(0, t.length - 1);
      }
      function E8(t) {
        const e = t.length;
        return t.map((n, r) => r !== 0 ? r / (e - 1) : 0);
      }
      function P8(t, e) {
        return t.map((n) => n * e);
      }
      function pd({ from: t = 0, to: e = 1, ease: n, offset: r, duration: i = 300 }) {
        const o = {
          done: false,
          value: t
        }, s = Array.isArray(e) ? e : [
          t,
          e
        ], a = P8(r && r.length === s.length ? r : E8(s), i);
        function l() {
          return ZE(a, s, {
            ease: Array.isArray(n) ? n : A8(s, n)
          });
        }
        let c = l();
        return {
          next: (u) => (o.value = c(u), o.done = u >= i, o),
          flipTarget: () => {
            s.reverse(), c = l();
          }
        };
      }
      function O8({ velocity: t = 0, from: e = 0, power: n = 0.8, timeConstant: r = 350, restDelta: i = 0.5, modifyTarget: o }) {
        const s = {
          done: false,
          value: e
        };
        let a = n * t;
        const l = e + a, c = o === void 0 ? l : o(l);
        return c !== l && (a = c - e), {
          next: (u) => {
            const h = -a * Math.exp(-u / r);
            return s.done = !(h > i || h < -i), s.value = s.done ? c : c + h, s;
          },
          flipTarget: () => {
          }
        };
      }
      const ck = {
        keyframes: pd,
        spring: ix,
        decay: O8
      };
      function R8(t) {
        if (Array.isArray(t.to))
          return pd;
        if (ck[t.type])
          return ck[t.type];
        const e = new Set(Object.keys(t));
        return e.has("ease") || e.has("duration") && !e.has("dampingRatio") ? pd : e.has("dampingRatio") || e.has("stiffness") || e.has("mass") || e.has("damping") || e.has("restSpeed") || e.has("restDelta") ? ix : pd;
      }
      const iP = 1 / 60 * 1e3, L8 = typeof performance < "u" ? () => performance.now() : () => Date.now(), oP = typeof window < "u" ? (t) => window.requestAnimationFrame(t) : (t) => setTimeout(() => t(L8()), iP);
      function D8(t) {
        let e = [], n = [], r = 0, i = false, o = false;
        const s = /* @__PURE__ */ new WeakSet(), a = {
          schedule: (l, c = false, u = false) => {
            const h = u && i, p = h ? e : n;
            return c && s.add(l), p.indexOf(l) === -1 && (p.push(l), h && i && (r = e.length)), l;
          },
          cancel: (l) => {
            const c = n.indexOf(l);
            c !== -1 && n.splice(c, 1), s.delete(l);
          },
          process: (l) => {
            if (i) {
              o = true;
              return;
            }
            if (i = true, [e, n] = [
              n,
              e
            ], n.length = 0, r = e.length, r)
              for (let c = 0; c < r; c++) {
                const u = e[c];
                u(l), s.has(u) && (a.schedule(u), t());
              }
            i = false, o && (o = false, a.process(l));
          }
        };
        return a;
      }
      const _8 = 40;
      let Sy = true, Ou = false, wy = false;
      const Ka = {
        delta: 0,
        timestamp: 0
      }, tf = [
        "read",
        "update",
        "preRender",
        "render",
        "postRender"
      ], Im = tf.reduce((t, e) => (t[e] = D8(() => Ou = true), t), {}), jr = tf.reduce((t, e) => {
        const n = Im[e];
        return t[e] = (r, i = false, o = false) => (Ou || B8(), n.schedule(r, i, o)), t;
      }, {}), cl = tf.reduce((t, e) => (t[e] = Im[e].cancel, t), {}), b0 = tf.reduce((t, e) => (t[e] = () => Im[e].process(Ka), t), {}), I8 = (t) => Im[t].process(Ka), sP = (t) => {
        Ou = false, Ka.delta = Sy ? iP : Math.max(Math.min(t - Ka.timestamp, _8), 1), Ka.timestamp = t, wy = true, tf.forEach(I8), wy = false, Ou && (Sy = false, oP(sP));
      }, B8 = () => {
        Ou = true, Sy = true, wy || oP(sP);
      }, dp = () => Ka;
      function aP(t, e, n = 0) {
        return t - e - n;
      }
      function N8(t, e, n = 0, r = true) {
        return r ? aP(e + -t, e, n) : e - (t - e) + n;
      }
      function $8(t, e, n, r) {
        return r ? t >= e + n : t <= -n;
      }
      const z8 = (t) => {
        const e = ({ delta: n }) => t(n);
        return {
          start: () => jr.update(e, true),
          stop: () => cl.update(e)
        };
      };
      function lP(t) {
        var e, n, { from: r, autoplay: i = true, driver: o = z8, elapsed: s = 0, repeat: a = 0, repeatType: l = "loop", repeatDelay: c = 0, onPlay: u, onStop: h, onComplete: p, onRepeat: v, onUpdate: y } = t, S = Tr(t, [
          "from",
          "autoplay",
          "driver",
          "elapsed",
          "repeat",
          "repeatType",
          "repeatDelay",
          "onPlay",
          "onStop",
          "onComplete",
          "onRepeat",
          "onUpdate"
        ]);
        let { to: C } = S, w, k = 0, T = S.duration, P, R = false, L = true, D;
        const F = R8(S);
        !((n = (e = F).needsInterpolation) === null || n === void 0) && n.call(e, r, C) && (D = ZE([
          0,
          100
        ], [
          r,
          C
        ], {
          clamp: false
        }), r = 0, C = 100);
        const K = F(Object.assign(Object.assign({}, S), {
          from: r,
          to: C
        }));
        function Y() {
          k++, l === "reverse" ? (L = k % 2 === 0, s = N8(s, T, c, L)) : (s = aP(s, T, c), l === "mirror" && K.flipTarget()), R = false, v && v();
        }
        function te() {
          w.stop(), p && p();
        }
        function ne(ye) {
          if (L || (ye = -ye), s += ye, !R) {
            const ke = K.next(Math.max(0, s));
            P = ke.value, D && (P = D(P)), R = L ? ke.done : s <= 0;
          }
          y == null ? void 0 : y(P), R && (k === 0 && (T ?? (T = s)), k < a ? $8(s, T, c, L) && Y() : te());
        }
        function ue() {
          u == null ? void 0 : u(), w = o(ne), w.start();
        }
        return i && ue(), {
          stop: () => {
            h == null ? void 0 : h(), w.stop();
          }
        };
      }
      function cP(t, e) {
        return e ? t * (1e3 / e) : 0;
      }
      function F8({ from: t = 0, velocity: e = 0, min: n, max: r, power: i = 0.8, timeConstant: o = 750, bounceStiffness: s = 500, bounceDamping: a = 10, restDelta: l = 1, modifyTarget: c, driver: u, onUpdate: h, onComplete: p, onStop: v }) {
        let y;
        function S(T) {
          return n !== void 0 && T < n || r !== void 0 && T > r;
        }
        function C(T) {
          return n === void 0 ? r : r === void 0 || Math.abs(n - T) < Math.abs(r - T) ? n : r;
        }
        function w(T) {
          y == null ? void 0 : y.stop(), y = lP(Object.assign(Object.assign({}, T), {
            driver: u,
            onUpdate: (P) => {
              var R;
              h == null ? void 0 : h(P), (R = T.onUpdate) === null || R === void 0 || R.call(T, P);
            },
            onComplete: p,
            onStop: v
          }));
        }
        function k(T) {
          w(Object.assign({
            type: "spring",
            stiffness: s,
            damping: a,
            restDelta: l
          }, T));
        }
        if (S(t))
          k({
            from: t,
            velocity: e,
            to: C(t)
          });
        else {
          let T = i * e + t;
          typeof c < "u" && (T = c(T));
          const P = C(T), R = P === n ? -1 : 1;
          let L, D;
          const F = (K) => {
            L = D, D = K, e = cP(K - L, dp().delta), (R === 1 && K > P || R === -1 && K < P) && k({
              from: K,
              to: P,
              velocity: e
            });
          };
          w({
            type: "decay",
            from: t,
            velocity: e,
            timeConstant: o,
            power: i,
            restDelta: l,
            modifyTarget: c,
            onUpdate: S(T) ? F : void 0
          });
        }
        return {
          stop: () => y == null ? void 0 : y.stop()
        };
      }
      const ky = (t) => t.hasOwnProperty("x") && t.hasOwnProperty("y"), uk = (t) => ky(t) && t.hasOwnProperty("z"), hh = (t, e) => Math.abs(t - e);
      function uP(t, e) {
        if (xy(t) && xy(e))
          return hh(t, e);
        if (ky(t) && ky(e)) {
          const n = hh(t.x, e.x), r = hh(t.y, e.y), i = uk(t) && uk(e) ? hh(t.z, e.z) : 0;
          return Math.sqrt(Math.pow(n, 2) + Math.pow(r, 2) + Math.pow(i, 2));
        }
      }
      const fP = (t, e) => 1 - 3 * e + 3 * t, hP = (t, e) => 3 * e - 6 * t, dP = (t) => 3 * t, pp = (t, e, n) => ((fP(e, n) * t + hP(e, n)) * t + dP(e)) * t, pP = (t, e, n) => 3 * fP(e, n) * t * t + 2 * hP(e, n) * t + dP(e), V8 = 1e-7, H8 = 10;
      function j8(t, e, n, r, i) {
        let o, s, a = 0;
        do
          s = e + (n - e) / 2, o = pp(s, r, i) - t, o > 0 ? n = s : e = s;
        while (Math.abs(o) > V8 && ++a < H8);
        return s;
      }
      const W8 = 8, U8 = 1e-3;
      function K8(t, e, n, r) {
        for (let i = 0; i < W8; ++i) {
          const o = pP(e, n, r);
          if (o === 0)
            return e;
          const s = pp(e, n, r) - t;
          e -= s / o;
        }
        return e;
      }
      const md = 11, dh = 1 / (md - 1);
      function q8(t, e, n, r) {
        if (t === e && n === r)
          return sx;
        const i = new Float32Array(md);
        for (let s = 0; s < md; ++s)
          i[s] = pp(s * dh, t, n);
        function o(s) {
          let a = 0, l = 1;
          const c = md - 1;
          for (; l !== c && i[l] <= s; ++l)
            a += dh;
          --l;
          const u = (s - i[l]) / (i[l + 1] - i[l]), h = a + u * dh, p = pP(h, t, n);
          return p >= U8 ? K8(s, h, t, n) : p === 0 ? h : j8(s, a, a + dh, t, n);
        }
        return (s) => s === 0 || s === 1 ? s : pp(o(s), e, r);
      }
      function G8(t) {
        var e = t.onTap, n = t.onTapStart, r = t.onTapCancel, i = t.whileTap, o = t.visualElement, s = e || n || r || i, a = z.exports.useRef(false), l = z.exports.useRef(null), c = {
          passive: !(n || e || r || y)
        };
        function u() {
          var S;
          (S = l.current) === null || S === void 0 || S.call(l), l.current = null;
        }
        function h() {
          var S;
          return u(), a.current = false, (S = o.animationState) === null || S === void 0 || S.setActive(tt.Tap, false), !qE();
        }
        function p(S, C) {
          !h() || (GE(o.getInstance(), S.target) ? e == null ? void 0 : e(S, C) : r == null ? void 0 : r(S, C));
        }
        function v(S, C) {
          !h() || (r == null ? void 0 : r(S, C));
        }
        function y(S, C) {
          var w;
          u(), !a.current && (a.current = true, l.current = Dm(Ua(window, "pointerup", p, c), Ua(window, "pointercancel", v, c)), (w = o.animationState) === null || w === void 0 || w.setActive(tt.Tap, true), n == null ? void 0 : n(S, C));
        }
        up(o, "pointerdown", s ? y : void 0, c), rx(u);
      }
      var fk = /* @__PURE__ */ new Set();
      function Y8(t, e, n) {
        t || fk.has(e) || (console.warn(e), n && console.warn(n), fk.add(e));
      }
      var Cy = /* @__PURE__ */ new WeakMap(), x0 = /* @__PURE__ */ new WeakMap(), X8 = function(t) {
        var e;
        (e = Cy.get(t.target)) === null || e === void 0 || e(t);
      }, Q8 = function(t) {
        t.forEach(X8);
      };
      function J8(t) {
        var e = t.root, n = Tr(t, [
          "root"
        ]), r = e || document;
        x0.has(r) || x0.set(r, {});
        var i = x0.get(r), o = JSON.stringify(n);
        return i[o] || (i[o] = new IntersectionObserver(Q8, ie({
          root: e
        }, n))), i[o];
      }
      function Z8(t, e, n) {
        var r = J8(e);
        return Cy.set(t, n), r.observe(t), function() {
          Cy.delete(t), r.unobserve(t);
        };
      }
      function e9(t) {
        var e = t.visualElement, n = t.whileInView, r = t.onViewportEnter, i = t.onViewportLeave, o = t.viewport, s = o === void 0 ? {} : o, a = z.exports.useRef({
          hasEnteredView: false,
          isInView: false
        }), l = Boolean(n || r || i);
        s.once && a.current.hasEnteredView && (l = false);
        var c = typeof IntersectionObserver > "u" ? r9 : n9;
        c(l, a.current, e, s);
      }
      var t9 = {
        some: 0,
        all: 1
      };
      function n9(t, e, n, r) {
        var i = r.root, o = r.margin, s = r.amount, a = s === void 0 ? "some" : s, l = r.once;
        z.exports.useEffect(function() {
          if (!!t) {
            var c = {
              root: i == null ? void 0 : i.current,
              rootMargin: o,
              threshold: typeof a == "number" ? a : t9[a]
            }, u = function(h) {
              var p, v = h.isIntersecting;
              if (e.isInView !== v && (e.isInView = v, !(l && !v && e.hasEnteredView))) {
                v && (e.hasEnteredView = true), (p = n.animationState) === null || p === void 0 || p.setActive(tt.InView, v);
                var y = n.getProps(), S = v ? y.onViewportEnter : y.onViewportLeave;
                S == null ? void 0 : S(h);
              }
            };
            return Z8(n.getInstance(), c, u);
          }
        }, [
          t,
          i,
          o,
          a
        ]);
      }
      function r9(t, e, n, r) {
        var i = r.fallback, o = i === void 0 ? true : i;
        z.exports.useEffect(function() {
          !t || !o || (Kb !== "production" && Y8(false, "IntersectionObserver not available on this device. whileInView animations will trigger on mount."), requestAnimationFrame(function() {
            var s;
            e.hasEnteredView = true;
            var a = n.getProps().onViewportEnter;
            a == null ? void 0 : a(null), (s = n.animationState) === null || s === void 0 || s.setActive(tt.InView, true);
          }));
        }, [
          t
        ]);
      }
      var Ro = function(t) {
        return function(e) {
          return t(e), null;
        };
      }, i9 = {
        inView: Ro(e9),
        tap: Ro(G8),
        focus: Ro(N6),
        hover: Ro(q6)
      }, o9 = 0, s9 = function() {
        return o9++;
      }, mP = function() {
        return Qu(s9);
      };
      function gP() {
        var t = z.exports.useContext(Tl);
        if (t === null)
          return [
            true,
            null
          ];
        var e = t.isPresent, n = t.onExitComplete, r = t.register, i = mP();
        z.exports.useEffect(function() {
          return r(i);
        }, []);
        var o = function() {
          return n == null ? void 0 : n(i);
        };
        return !e && n ? [
          false,
          o
        ] : [
          true
        ];
      }
      function a9() {
        return l9(z.exports.useContext(Tl));
      }
      function l9(t) {
        return t === null ? true : t.isPresent;
      }
      function vP(t, e) {
        if (!Array.isArray(e))
          return false;
        var n = e.length;
        if (n !== t.length)
          return false;
        for (var r = 0; r < n; r++)
          if (e[r] !== t[r])
            return false;
        return true;
      }
      var mp = function(t) {
        return t * 1e3;
      }, c9 = {
        linear: sx,
        easeIn: ax,
        easeInOut: nP,
        easeOut: v8,
        circIn: rP,
        circInOut: y8,
        circOut: lx,
        backIn: cx,
        backInOut: x8,
        backOut: b8,
        anticipate: S8,
        bounceIn: T8,
        bounceInOut: M8,
        bounceOut: hp
      }, hk = function(t) {
        if (Array.isArray(t)) {
          sp(t.length === 4);
          var e = kt(t, 4), n = e[0], r = e[1], i = e[2], o = e[3];
          return q8(n, r, i, o);
        } else if (typeof t == "string")
          return c9[t];
        return t;
      }, u9 = function(t) {
        return Array.isArray(t) && typeof t[0] != "number";
      }, dk = function(t, e) {
        return t === "zIndex" ? false : !!(typeof e == "number" || Array.isArray(e) || typeof e == "string" && eo.test(e) && !e.startsWith("url("));
      }, hs = function() {
        return {
          type: "spring",
          stiffness: 500,
          damping: 25,
          restSpeed: 10
        };
      }, ph = function(t) {
        return {
          type: "spring",
          stiffness: 550,
          damping: t === 0 ? 2 * Math.sqrt(550) : 30,
          restSpeed: 10
        };
      }, S0 = function() {
        return {
          type: "keyframes",
          ease: "linear",
          duration: 0.3
        };
      }, f9 = function(t) {
        return {
          type: "keyframes",
          duration: 0.8,
          values: t
        };
      }, pk = {
        x: hs,
        y: hs,
        z: hs,
        rotate: hs,
        rotateX: hs,
        rotateY: hs,
        rotateZ: hs,
        scaleX: ph,
        scaleY: ph,
        scale: ph,
        opacity: S0,
        backgroundColor: S0,
        color: S0,
        default: ph
      }, h9 = function(t, e) {
        var n;
        return Eu(e) ? n = f9 : n = pk[t] || pk.default, ie({
          to: e
        }, n(e));
      }, d9 = ie(ie({}, OE), {
        color: yn,
        backgroundColor: yn,
        outlineColor: yn,
        fill: yn,
        stroke: yn,
        borderColor: yn,
        borderTopColor: yn,
        borderRightColor: yn,
        borderBottomColor: yn,
        borderLeftColor: yn,
        filter: vy,
        WebkitFilter: vy
      }), ux = function(t) {
        return d9[t];
      };
      function fx(t, e) {
        var n, r = ux(t);
        return r !== vy && (r = eo), (n = r.getAnimatableNone) === null || n === void 0 ? void 0 : n.call(r, e);
      }
      var p9 = {
        current: false
      };
      function m9(t) {
        t.when, t.delay, t.delayChildren, t.staggerChildren, t.staggerDirection, t.repeat, t.repeatType, t.repeatDelay, t.from;
        var e = Tr(t, [
          "when",
          "delay",
          "delayChildren",
          "staggerChildren",
          "staggerDirection",
          "repeat",
          "repeatType",
          "repeatDelay",
          "from"
        ]);
        return !!Object.keys(e).length;
      }
      function g9(t) {
        var e = t.ease, n = t.times, r = t.yoyo, i = t.flip, o = t.loop, s = Tr(t, [
          "ease",
          "times",
          "yoyo",
          "flip",
          "loop"
        ]), a = ie({}, s);
        return n && (a.offset = n), s.duration && (a.duration = mp(s.duration)), s.repeatDelay && (a.repeatDelay = mp(s.repeatDelay)), e && (a.ease = u9(e) ? e.map(hk) : hk(e)), s.type === "tween" && (a.type = "keyframes"), (r || o || i) && (r ? a.repeatType = "reverse" : o ? a.repeatType = "loop" : i && (a.repeatType = "mirror"), a.repeat = o || r || i || s.repeat), s.type !== "spring" && (a.type = "keyframes"), a;
      }
      function v9(t, e) {
        var n, r, i = hx(t, e) || {};
        return (r = (n = i.delay) !== null && n !== void 0 ? n : t.delay) !== null && r !== void 0 ? r : 0;
      }
      function y9(t) {
        return Array.isArray(t.to) && t.to[0] === null && (t.to = Hr([], kt(t.to), false), t.to[0] = t.from), t;
      }
      function b9(t, e, n) {
        var r;
        return Array.isArray(e.to) && ((r = t.duration) !== null && r !== void 0 || (t.duration = 0.8)), y9(e), m9(t) || (t = ie(ie({}, t), h9(n, e.to))), ie(ie({}, e), g9(t));
      }
      function x9(t, e, n, r, i) {
        var o, s = hx(r, t), a = (o = s.from) !== null && o !== void 0 ? o : e.get(), l = dk(t, n);
        a === "none" && l && typeof n == "string" ? a = fx(t, n) : mk(a) && typeof n == "string" ? a = gk(n) : !Array.isArray(n) && mk(n) && typeof a == "string" && (n = gk(a));
        var c = dk(t, a);
        function u() {
          var p = {
            from: a,
            to: n,
            velocity: e.getVelocity(),
            onComplete: i,
            onUpdate: function(v) {
              return e.set(v);
            }
          };
          return s.type === "inertia" || s.type === "decay" ? F8(ie(ie({}, p), s)) : lP(ie(ie({}, b9(s, p, t)), {
            onUpdate: function(v) {
              var y;
              p.onUpdate(v), (y = s.onUpdate) === null || y === void 0 || y.call(s, v);
            },
            onComplete: function() {
              var v;
              p.onComplete(), (v = s.onComplete) === null || v === void 0 || v.call(s);
            }
          }));
        }
        function h() {
          var p, v, y = zE(n);
          return e.set(y), i(), (p = s == null ? void 0 : s.onUpdate) === null || p === void 0 || p.call(s, y), (v = s == null ? void 0 : s.onComplete) === null || v === void 0 || v.call(s), {
            stop: function() {
            }
          };
        }
        return !c || !l || s.type === false ? h : u;
      }
      function mk(t) {
        return t === 0 || typeof t == "string" && parseFloat(t) === 0 && t.indexOf(" ") === -1;
      }
      function gk(t) {
        return typeof t == "number" ? 0 : fx("", t);
      }
      function hx(t, e) {
        return t[e] || t.default || t;
      }
      function dx(t, e, n, r) {
        return r === void 0 && (r = {}), p9.current && (r = {
          type: false
        }), e.start(function(i) {
          var o, s, a = x9(t, e, n, r, i), l = v9(r, t), c = function() {
            return s = a();
          };
          return l ? o = window.setTimeout(c, mp(l)) : c(), function() {
            clearTimeout(o), s == null ? void 0 : s.stop();
          };
        });
      }
      var S9 = function(t) {
        return /^\-?\d*\.?\d+$/.test(t);
      }, w9 = function(t) {
        return /^0[^.\s]+$/.test(t);
      };
      function px(t, e) {
        t.indexOf(e) === -1 && t.push(e);
      }
      function mx(t, e) {
        var n = t.indexOf(e);
        n > -1 && t.splice(n, 1);
      }
      var jc = function() {
        function t() {
          this.subscriptions = [];
        }
        return t.prototype.add = function(e) {
          var n = this;
          return px(this.subscriptions, e), function() {
            return mx(n.subscriptions, e);
          };
        }, t.prototype.notify = function(e, n, r) {
          var i = this.subscriptions.length;
          if (!!i)
            if (i === 1)
              this.subscriptions[0](e, n, r);
            else
              for (var o = 0; o < i; o++) {
                var s = this.subscriptions[o];
                s && s(e, n, r);
              }
        }, t.prototype.getSize = function() {
          return this.subscriptions.length;
        }, t.prototype.clear = function() {
          this.subscriptions.length = 0;
        }, t;
      }(), k9 = function(t) {
        return !isNaN(parseFloat(t));
      }, C9 = function() {
        function t(e) {
          var n = this;
          this.version = "6.5.1", this.timeDelta = 0, this.lastUpdated = 0, this.updateSubscribers = new jc(), this.velocityUpdateSubscribers = new jc(), this.renderSubscribers = new jc(), this.canTrackVelocity = false, this.updateAndNotify = function(r, i) {
            i === void 0 && (i = true), n.prev = n.current, n.current = r;
            var o = dp(), s = o.delta, a = o.timestamp;
            n.lastUpdated !== a && (n.timeDelta = s, n.lastUpdated = a, jr.postRender(n.scheduleVelocityCheck)), n.prev !== n.current && n.updateSubscribers.notify(n.current), n.velocityUpdateSubscribers.getSize() && n.velocityUpdateSubscribers.notify(n.getVelocity()), i && n.renderSubscribers.notify(n.current);
          }, this.scheduleVelocityCheck = function() {
            return jr.postRender(n.velocityCheck);
          }, this.velocityCheck = function(r) {
            var i = r.timestamp;
            i !== n.lastUpdated && (n.prev = n.current, n.velocityUpdateSubscribers.notify(n.getVelocity()));
          }, this.hasAnimated = false, this.prev = this.current = e, this.canTrackVelocity = k9(this.current);
        }
        return t.prototype.onChange = function(e) {
          return this.updateSubscribers.add(e);
        }, t.prototype.clearListeners = function() {
          this.updateSubscribers.clear();
        }, t.prototype.onRenderRequest = function(e) {
          return e(this.get()), this.renderSubscribers.add(e);
        }, t.prototype.attach = function(e) {
          this.passiveEffect = e;
        }, t.prototype.set = function(e, n) {
          n === void 0 && (n = true), !n || !this.passiveEffect ? this.updateAndNotify(e, n) : this.passiveEffect(e, this.updateAndNotify);
        }, t.prototype.get = function() {
          return this.current;
        }, t.prototype.getPrevious = function() {
          return this.prev;
        }, t.prototype.getVelocity = function() {
          return this.canTrackVelocity ? cP(parseFloat(this.current) - parseFloat(this.prev), this.timeDelta) : 0;
        }, t.prototype.start = function(e) {
          var n = this;
          return this.stop(), new Promise(function(r) {
            n.hasAnimated = true, n.stopAnimation = e(r);
          }).then(function() {
            return n.clearAnimation();
          });
        }, t.prototype.stop = function() {
          this.stopAnimation && this.stopAnimation(), this.clearAnimation();
        }, t.prototype.isAnimating = function() {
          return !!this.stopAnimation;
        }, t.prototype.clearAnimation = function() {
          this.stopAnimation = null;
        }, t.prototype.destroy = function() {
          this.updateSubscribers.clear(), this.renderSubscribers.clear(), this.stop();
        }, t;
      }();
      function ul(t) {
        return new C9(t);
      }
      var yP = function(t) {
        return function(e) {
          return e.test(t);
        };
      }, T9 = {
        test: function(t) {
          return t === "auto";
        },
        parse: function(t) {
          return t;
        }
      }, bP = [
        Xs,
        Ce,
        wi,
        go,
        c6,
        l6,
        T9
      ], tc = function(t) {
        return bP.find(yP(t));
      }, M9 = Hr(Hr([], kt(bP), false), [
        yn,
        eo
      ], false), A9 = function(t) {
        return M9.find(yP(t));
      };
      function E9(t, e, n) {
        t.hasValue(e) ? t.getValue(e).set(n) : t.addValue(e, ul(n));
      }
      function P9(t, e) {
        var n = Om(t, e), r = n ? t.makeTargetAnimatable(n, false) : {}, i = r.transitionEnd, o = i === void 0 ? {} : i;
        r.transition;
        var s = Tr(r, [
          "transitionEnd",
          "transition"
        ]);
        s = ie(ie({}, s), o);
        for (var a in s) {
          var l = zE(s[a]);
          E9(t, a, l);
        }
      }
      function O9(t, e, n) {
        var r, i, o, s, a = Object.keys(e).filter(function(v) {
          return !t.hasValue(v);
        }), l = a.length;
        if (!!l)
          for (var c = 0; c < l; c++) {
            var u = a[c], h = e[u], p = null;
            Array.isArray(h) && (p = h[0]), p === null && (p = (i = (r = n[u]) !== null && r !== void 0 ? r : t.readValue(u)) !== null && i !== void 0 ? i : e[u]), p != null && (typeof p == "string" && (S9(p) || w9(p)) ? p = parseFloat(p) : !A9(p) && eo.test(h) && (p = fx(u, h)), t.addValue(u, ul(p)), (o = (s = n)[u]) !== null && o !== void 0 || (s[u] = p), t.setBaseTarget(u, p));
          }
      }
      function R9(t, e) {
        if (!!e) {
          var n = e[t] || e.default || e;
          return n.from;
        }
      }
      function L9(t, e, n) {
        var r, i, o = {};
        for (var s in t)
          o[s] = (r = R9(s, e)) !== null && r !== void 0 ? r : (i = n.getValue(s)) === null || i === void 0 ? void 0 : i.get();
        return o;
      }
      function D9(t, e, n) {
        n === void 0 && (n = {}), t.notifyAnimationStart(e);
        var r;
        if (Array.isArray(e)) {
          var i = e.map(function(s) {
            return Ty(t, s, n);
          });
          r = Promise.all(i);
        } else if (typeof e == "string")
          r = Ty(t, e, n);
        else {
          var o = typeof e == "function" ? Om(t, e, n.custom) : e;
          r = xP(t, o, n);
        }
        return r.then(function() {
          return t.notifyAnimationComplete(e);
        });
      }
      function Ty(t, e, n) {
        var r;
        n === void 0 && (n = {});
        var i = Om(t, e, n.custom), o = (i || {}).transition, s = o === void 0 ? t.getDefaultTransition() || {} : o;
        n.transitionOverride && (s = n.transitionOverride);
        var a = i ? function() {
          return xP(t, i, n);
        } : function() {
          return Promise.resolve();
        }, l = !((r = t.variantChildren) === null || r === void 0) && r.size ? function(v) {
          v === void 0 && (v = 0);
          var y = s.delayChildren, S = y === void 0 ? 0 : y, C = s.staggerChildren, w = s.staggerDirection;
          return _9(t, e, S + v, C, w, n);
        } : function() {
          return Promise.resolve();
        }, c = s.when;
        if (c) {
          var u = kt(c === "beforeChildren" ? [
            a,
            l
          ] : [
            l,
            a
          ], 2), h = u[0], p = u[1];
          return h().then(p);
        } else
          return Promise.all([
            a(),
            l(n.delay)
          ]);
      }
      function xP(t, e, n) {
        var r, i = n === void 0 ? {} : n, o = i.delay, s = o === void 0 ? 0 : o, a = i.transitionOverride, l = i.type, c = t.makeTargetAnimatable(e), u = c.transition, h = u === void 0 ? t.getDefaultTransition() : u, p = c.transitionEnd, v = Tr(c, [
          "transition",
          "transitionEnd"
        ]);
        a && (h = a);
        var y = [], S = l && ((r = t.animationState) === null || r === void 0 ? void 0 : r.getState()[l]);
        for (var C in v) {
          var w = t.getValue(C), k = v[C];
          if (!(!w || k === void 0 || S && B9(S, C))) {
            var T = ie({
              delay: s
            }, h);
            t.shouldReduceMotion && Ju(C) && (T = ie(ie({}, T), {
              type: false,
              delay: 0
            }));
            var P = dx(C, w, k, T);
            y.push(P);
          }
        }
        return Promise.all(y).then(function() {
          p && P9(t, p);
        });
      }
      function _9(t, e, n, r, i, o) {
        n === void 0 && (n = 0), r === void 0 && (r = 0), i === void 0 && (i = 1);
        var s = [], a = (t.variantChildren.size - 1) * r, l = i === 1 ? function(c) {
          return c === void 0 && (c = 0), c * r;
        } : function(c) {
          return c === void 0 && (c = 0), a - c * r;
        };
        return Array.from(t.variantChildren).sort(I9).forEach(function(c, u) {
          s.push(Ty(c, e, ie(ie({}, o), {
            delay: n + l(u)
          })).then(function() {
            return c.notifyAnimationComplete(e);
          }));
        }), Promise.all(s);
      }
      function I9(t, e) {
        return t.sortNodePosition(e);
      }
      function B9(t, e) {
        var n = t.protectedKeys, r = t.needsAnimating, i = n.hasOwnProperty(e) && r[e] !== true;
        return r[e] = false, i;
      }
      var gx = [
        tt.Animate,
        tt.InView,
        tt.Focus,
        tt.Hover,
        tt.Tap,
        tt.Drag,
        tt.Exit
      ], N9 = Hr([], kt(gx), false).reverse(), $9 = gx.length;
      function z9(t) {
        return function(e) {
          return Promise.all(e.map(function(n) {
            var r = n.animation, i = n.options;
            return D9(t, r, i);
          }));
        };
      }
      function F9(t) {
        var e = z9(t), n = H9(), r = {}, i = true, o = function(u, h) {
          var p = Om(t, h);
          if (p) {
            p.transition;
            var v = p.transitionEnd, y = Tr(p, [
              "transition",
              "transitionEnd"
            ]);
            u = ie(ie(ie({}, u), y), v);
          }
          return u;
        };
        function s(u) {
          return r[u] !== void 0;
        }
        function a(u) {
          e = u(t);
        }
        function l(u, h) {
          for (var p, v = t.getProps(), y = t.getVariantContext(true) || {}, S = [], C = /* @__PURE__ */ new Set(), w = {}, k = 1 / 0, T = function(D) {
            var F = N9[D], K = n[F], Y = (p = v[F]) !== null && p !== void 0 ? p : y[F], te = Ir(Y), ne = F === h ? K.isActive : null;
            ne === false && (k = D);
            var ue = Y === y[F] && Y !== v[F] && te;
            if (ue && i && t.manuallyAnimateOnMount && (ue = false), K.protectedKeys = ie({}, w), !K.isActive && ne === null || !Y && !K.prevProp || tx(Y) || typeof Y == "boolean")
              return "continue";
            var ye = V9(K.prevProp, Y), ke = ye || F === h && K.isActive && !ue && te || D > k && te, Ee = Array.isArray(Y) ? Y : [
              Y
            ], Q = Ee.reduce(o, {});
            ne === false && (Q = {});
            var V = K.prevResolvedValues, ae = V === void 0 ? {} : V, ge = ie(ie({}, ae), Q), Te = function(oe) {
              ke = true, C.delete(oe), K.needsAnimating[oe] = true;
            };
            for (var ve in ge) {
              var se = Q[ve], re = ae[ve];
              w.hasOwnProperty(ve) || (se !== re ? Eu(se) && Eu(re) ? !vP(se, re) || ye ? Te(ve) : K.protectedKeys[ve] = true : se !== void 0 ? Te(ve) : C.add(ve) : se !== void 0 && C.has(ve) ? Te(ve) : K.protectedKeys[ve] = true);
            }
            K.prevProp = Y, K.prevResolvedValues = Q, K.isActive && (w = ie(ie({}, w), Q)), i && t.blockInitialAnimation && (ke = false), ke && !ue && S.push.apply(S, Hr([], kt(Ee.map(function(oe) {
              return {
                animation: oe,
                options: ie({
                  type: F
                }, u)
              };
            })), false));
          }, P = 0; P < $9; P++)
            T(P);
          if (r = ie({}, w), C.size) {
            var R = {};
            C.forEach(function(D) {
              var F = t.getBaseTarget(D);
              F !== void 0 && (R[D] = F);
            }), S.push({
              animation: R
            });
          }
          var L = Boolean(S.length);
          return i && v.initial === false && !t.manuallyAnimateOnMount && (L = false), i = false, L ? e(S) : Promise.resolve();
        }
        function c(u, h, p) {
          var v;
          if (n[u].isActive === h)
            return Promise.resolve();
          (v = t.variantChildren) === null || v === void 0 || v.forEach(function(C) {
            var w;
            return (w = C.animationState) === null || w === void 0 ? void 0 : w.setActive(u, h);
          }), n[u].isActive = h;
          var y = l(p, u);
          for (var S in n)
            n[S].protectedKeys = {};
          return y;
        }
        return {
          isAnimated: s,
          animateChanges: l,
          setActive: c,
          setAnimateFunction: a,
          getState: function() {
            return n;
          }
        };
      }
      function V9(t, e) {
        return typeof e == "string" ? e !== t : gE(e) ? !vP(e, t) : false;
      }
      function ds(t) {
        return t === void 0 && (t = false), {
          isActive: t,
          protectedKeys: {},
          needsAnimating: {},
          prevResolvedValues: {}
        };
      }
      function H9() {
        var t;
        return t = {}, t[tt.Animate] = ds(true), t[tt.InView] = ds(), t[tt.Hover] = ds(), t[tt.Tap] = ds(), t[tt.Drag] = ds(), t[tt.Focus] = ds(), t[tt.Exit] = ds(), t;
      }
      var j9 = {
        animation: Ro(function(t) {
          var e = t.visualElement, n = t.animate;
          e.animationState || (e.animationState = F9(e)), tx(n) && z.exports.useEffect(function() {
            return n.subscribe(e);
          }, [
            n
          ]);
        }),
        exit: Ro(function(t) {
          var e = t.custom, n = t.visualElement, r = kt(gP(), 2), i = r[0], o = r[1], s = z.exports.useContext(Tl);
          z.exports.useEffect(function() {
            var a, l;
            n.isPresent = i;
            var c = (a = n.animationState) === null || a === void 0 ? void 0 : a.setActive(tt.Exit, !i, {
              custom: (l = s == null ? void 0 : s.custom) !== null && l !== void 0 ? l : e
            });
            !i && (c == null ? void 0 : c.then(o));
          }, [
            i
          ]);
        })
      }, SP = function() {
        function t(e, n, r) {
          var i = this, o = r === void 0 ? {} : r, s = o.transformPagePoint;
          if (this.startEvent = null, this.lastMoveEvent = null, this.lastMoveEventInfo = null, this.handlers = {}, this.updatePoint = function() {
            if (!!(i.lastMoveEvent && i.lastMoveEventInfo)) {
              var p = k0(i.lastMoveEventInfo, i.history), v = i.startEvent !== null, y = uP(p.offset, {
                x: 0,
                y: 0
              }) >= 3;
              if (!(!v && !y)) {
                var S = p.point, C = dp().timestamp;
                i.history.push(ie(ie({}, S), {
                  timestamp: C
                }));
                var w = i.handlers, k = w.onStart, T = w.onMove;
                v || (k && k(i.lastMoveEvent, p), i.startEvent = i.lastMoveEvent), T && T(i.lastMoveEvent, p);
              }
            }
          }, this.handlePointerMove = function(p, v) {
            if (i.lastMoveEvent = p, i.lastMoveEventInfo = w0(v, i.transformPagePoint), VE(p) && p.buttons === 0) {
              i.handlePointerUp(p, v);
              return;
            }
            jr.update(i.updatePoint, true);
          }, this.handlePointerUp = function(p, v) {
            i.end();
            var y = i.handlers, S = y.onEnd, C = y.onSessionEnd, w = k0(w0(v, i.transformPagePoint), i.history);
            i.startEvent && S && S(p, w), C && C(p, w);
          }, !(HE(e) && e.touches.length > 1)) {
            this.handlers = n, this.transformPagePoint = s;
            var a = nx(e), l = w0(a, this.transformPagePoint), c = l.point, u = dp().timestamp;
            this.history = [
              ie(ie({}, c), {
                timestamp: u
              })
            ];
            var h = n.onSessionStart;
            h && h(e, k0(l, this.history)), this.removeListeners = Dm(Ua(window, "pointermove", this.handlePointerMove), Ua(window, "pointerup", this.handlePointerUp), Ua(window, "pointercancel", this.handlePointerUp));
          }
        }
        return t.prototype.updateHandlers = function(e) {
          this.handlers = e;
        }, t.prototype.end = function() {
          this.removeListeners && this.removeListeners(), cl.update(this.updatePoint);
        }, t;
      }();
      function w0(t, e) {
        return e ? {
          point: e(t.point)
        } : t;
      }
      function vk(t, e) {
        return {
          x: t.x - e.x,
          y: t.y - e.y
        };
      }
      function k0(t, e) {
        var n = t.point;
        return {
          point: n,
          delta: vk(n, wP(e)),
          offset: vk(n, W9(e)),
          velocity: U9(e, 0.1)
        };
      }
      function W9(t) {
        return t[0];
      }
      function wP(t) {
        return t[t.length - 1];
      }
      function U9(t, e) {
        if (t.length < 2)
          return {
            x: 0,
            y: 0
          };
        for (var n = t.length - 1, r = null, i = wP(t); n >= 0 && (r = t[n], !(i.timestamp - r.timestamp > mp(e))); )
          n--;
        if (!r)
          return {
            x: 0,
            y: 0
          };
        var o = (i.timestamp - r.timestamp) / 1e3;
        if (o === 0)
          return {
            x: 0,
            y: 0
          };
        var s = {
          x: (i.x - r.x) / o,
          y: (i.y - r.y) / o
        };
        return s.x === 1 / 0 && (s.x = 0), s.y === 1 / 0 && (s.y = 0), s;
      }
      function to(t) {
        return t.max - t.min;
      }
      function yk(t, e, n) {
        return e === void 0 && (e = 0), n === void 0 && (n = 0.01), uP(t, e) < n;
      }
      function bk(t, e, n, r) {
        r === void 0 && (r = 0.5), t.origin = r, t.originPoint = wt(e.min, e.max, t.origin), t.scale = to(n) / to(e), (yk(t.scale, 1, 1e-4) || isNaN(t.scale)) && (t.scale = 1), t.translate = wt(n.min, n.max, t.origin) - t.originPoint, (yk(t.translate) || isNaN(t.translate)) && (t.translate = 0);
      }
      function Wc(t, e, n, r) {
        bk(t.x, e.x, n.x, r == null ? void 0 : r.originX), bk(t.y, e.y, n.y, r == null ? void 0 : r.originY);
      }
      function xk(t, e, n) {
        t.min = n.min + e.min, t.max = t.min + to(e);
      }
      function K9(t, e, n) {
        xk(t.x, e.x, n.x), xk(t.y, e.y, n.y);
      }
      function Sk(t, e, n) {
        t.min = e.min - n.min, t.max = t.min + to(e);
      }
      function Uc(t, e, n) {
        Sk(t.x, e.x, n.x), Sk(t.y, e.y, n.y);
      }
      function q9(t, e, n) {
        var r = e.min, i = e.max;
        return r !== void 0 && t < r ? t = n ? wt(r, t, n.min) : Math.max(t, r) : i !== void 0 && t > i && (t = n ? wt(i, t, n.max) : Math.min(t, i)), t;
      }
      function wk(t, e, n) {
        return {
          min: e !== void 0 ? t.min + e : void 0,
          max: n !== void 0 ? t.max + n - (t.max - t.min) : void 0
        };
      }
      function G9(t, e) {
        var n = e.top, r = e.left, i = e.bottom, o = e.right;
        return {
          x: wk(t.x, r, o),
          y: wk(t.y, n, i)
        };
      }
      function kk(t, e) {
        var n, r = e.min - t.min, i = e.max - t.max;
        return e.max - e.min < t.max - t.min && (n = kt([
          i,
          r
        ], 2), r = n[0], i = n[1]), {
          min: r,
          max: i
        };
      }
      function Y9(t, e) {
        return {
          x: kk(t.x, e.x),
          y: kk(t.y, e.y)
        };
      }
      function X9(t, e) {
        var n = 0.5, r = to(t), i = to(e);
        return i > r ? n = Pu(e.min, e.max - r, t.min) : r > i && (n = Pu(t.min, t.max - i, e.min)), fp(0, 1, n);
      }
      function Q9(t, e) {
        var n = {};
        return e.min !== void 0 && (n.min = e.min - t.min), e.max !== void 0 && (n.max = e.max - t.min), n;
      }
      var My = 0.35;
      function J9(t) {
        return t === void 0 && (t = My), t === false ? t = 0 : t === true && (t = My), {
          x: Ck(t, "left", "right"),
          y: Ck(t, "top", "bottom")
        };
      }
      function Ck(t, e, n) {
        return {
          min: Tk(t, e),
          max: Tk(t, n)
        };
      }
      function Tk(t, e) {
        var n;
        return typeof t == "number" ? t : (n = t[e]) !== null && n !== void 0 ? n : 0;
      }
      var Mk = function() {
        return {
          translate: 0,
          scale: 1,
          origin: 0,
          originPoint: 0
        };
      }, Kc = function() {
        return {
          x: Mk(),
          y: Mk()
        };
      }, Ak = function() {
        return {
          min: 0,
          max: 0
        };
      }, cn = function() {
        return {
          x: Ak(),
          y: Ak()
        };
      };
      function si(t) {
        return [
          t("x"),
          t("y")
        ];
      }
      function kP(t) {
        var e = t.top, n = t.left, r = t.right, i = t.bottom;
        return {
          x: {
            min: n,
            max: r
          },
          y: {
            min: e,
            max: i
          }
        };
      }
      function Z9(t) {
        var e = t.x, n = t.y;
        return {
          top: n.min,
          right: e.max,
          bottom: n.max,
          left: e.min
        };
      }
      function eH(t, e) {
        if (!e)
          return t;
        var n = e({
          x: t.left,
          y: t.top
        }), r = e({
          x: t.right,
          y: t.bottom
        });
        return {
          top: n.y,
          left: n.x,
          bottom: r.y,
          right: r.x
        };
      }
      function C0(t) {
        return t === void 0 || t === 1;
      }
      function CP(t) {
        var e = t.scale, n = t.scaleX, r = t.scaleY;
        return !C0(e) || !C0(n) || !C0(r);
      }
      function vo(t) {
        return CP(t) || Ek(t.x) || Ek(t.y) || t.z || t.rotate || t.rotateX || t.rotateY;
      }
      function Ek(t) {
        return t && t !== "0%";
      }
      function gp(t, e, n) {
        var r = t - n, i = e * r;
        return n + i;
      }
      function Pk(t, e, n, r, i) {
        return i !== void 0 && (t = gp(t, i, r)), gp(t, n, r) + e;
      }
      function Ay(t, e, n, r, i) {
        e === void 0 && (e = 0), n === void 0 && (n = 1), t.min = Pk(t.min, e, n, r, i), t.max = Pk(t.max, e, n, r, i);
      }
      function TP(t, e) {
        var n = e.x, r = e.y;
        Ay(t.x, n.translate, n.scale, n.originPoint), Ay(t.y, r.translate, r.scale, r.originPoint);
      }
      function tH(t, e, n, r) {
        var i, o;
        r === void 0 && (r = false);
        var s = n.length;
        if (!!s) {
          e.x = e.y = 1;
          for (var a, l, c = 0; c < s; c++)
            a = n[c], l = a.projectionDelta, ((o = (i = a.instance) === null || i === void 0 ? void 0 : i.style) === null || o === void 0 ? void 0 : o.display) !== "contents" && (r && a.options.layoutScroll && a.scroll && a !== a.root && Ra(t, {
              x: -a.scroll.x,
              y: -a.scroll.y
            }), l && (e.x *= l.x.scale, e.y *= l.y.scale, TP(t, l)), r && vo(a.latestValues) && Ra(t, a.latestValues));
        }
      }
      function xo(t, e) {
        t.min = t.min + e, t.max = t.max + e;
      }
      function Ok(t, e, n) {
        var r = kt(n, 3), i = r[0], o = r[1], s = r[2], a = e[s] !== void 0 ? e[s] : 0.5, l = wt(t.min, t.max, a);
        Ay(t, e[i], e[o], l, e.scale);
      }
      var nH = [
        "x",
        "scaleX",
        "originX"
      ], rH = [
        "y",
        "scaleY",
        "originY"
      ];
      function Ra(t, e) {
        Ok(t.x, e, nH), Ok(t.y, e, rH);
      }
      function MP(t, e) {
        return kP(eH(t.getBoundingClientRect(), e));
      }
      function iH(t, e, n) {
        var r = MP(t, n), i = e.scroll;
        return i && (xo(r.x, i.x), xo(r.y, i.y)), r;
      }
      var oH = /* @__PURE__ */ new WeakMap(), sH = function() {
        function t(e) {
          this.openGlobalLock = null, this.isDragging = false, this.currentDirection = null, this.originPoint = {
            x: 0,
            y: 0
          }, this.constraints = false, this.hasMutatedConstraints = false, this.elastic = cn(), this.visualElement = e;
        }
        return t.prototype.start = function(e, n) {
          var r = this, i = n === void 0 ? {} : n, o = i.snapToCursor, s = o === void 0 ? false : o;
          if (this.visualElement.isPresent !== false) {
            var a = function(h) {
              r.stopAnimation(), s && r.snapToCursor(nx(h, "page").point);
            }, l = function(h, p) {
              var v, y = r.getProps(), S = y.drag, C = y.dragPropagation, w = y.onDragStart;
              S && !C && (r.openGlobalLock && r.openGlobalLock(), r.openGlobalLock = KE(S), !r.openGlobalLock) || (r.isDragging = true, r.currentDirection = null, r.resolveConstraints(), r.visualElement.projection && (r.visualElement.projection.isAnimationBlocked = true, r.visualElement.projection.target = void 0), si(function(k) {
                var T, P, R = r.getAxisMotionValue(k).get() || 0;
                if (wi.test(R)) {
                  var L = (P = (T = r.visualElement.projection) === null || T === void 0 ? void 0 : T.layout) === null || P === void 0 ? void 0 : P.actual[k];
                  if (L) {
                    var D = to(L);
                    R = D * (parseFloat(R) / 100);
                  }
                }
                r.originPoint[k] = R;
              }), w == null ? void 0 : w(h, p), (v = r.visualElement.animationState) === null || v === void 0 || v.setActive(tt.Drag, true));
            }, c = function(h, p) {
              var v = r.getProps(), y = v.dragPropagation, S = v.dragDirectionLock, C = v.onDirectionLock, w = v.onDrag;
              if (!(!y && !r.openGlobalLock)) {
                var k = p.offset;
                if (S && r.currentDirection === null) {
                  r.currentDirection = aH(k), r.currentDirection !== null && (C == null ? void 0 : C(r.currentDirection));
                  return;
                }
                r.updateAxis("x", p.point, k), r.updateAxis("y", p.point, k), r.visualElement.syncRender(), w == null ? void 0 : w(h, p);
              }
            }, u = function(h, p) {
              return r.stop(h, p);
            };
            this.panSession = new SP(e, {
              onSessionStart: a,
              onStart: l,
              onMove: c,
              onSessionEnd: u
            }, {
              transformPagePoint: this.visualElement.getTransformPagePoint()
            });
          }
        }, t.prototype.stop = function(e, n) {
          var r = this.isDragging;
          if (this.cancel(), !!r) {
            var i = n.velocity;
            this.startAnimation(i);
            var o = this.getProps().onDragEnd;
            o == null ? void 0 : o(e, n);
          }
        }, t.prototype.cancel = function() {
          var e, n;
          this.isDragging = false, this.visualElement.projection && (this.visualElement.projection.isAnimationBlocked = false), (e = this.panSession) === null || e === void 0 || e.end(), this.panSession = void 0;
          var r = this.getProps().dragPropagation;
          !r && this.openGlobalLock && (this.openGlobalLock(), this.openGlobalLock = null), (n = this.visualElement.animationState) === null || n === void 0 || n.setActive(tt.Drag, false);
        }, t.prototype.updateAxis = function(e, n, r) {
          var i = this.getProps().drag;
          if (!(!r || !mh(e, i, this.currentDirection))) {
            var o = this.getAxisMotionValue(e), s = this.originPoint[e] + r[e];
            this.constraints && this.constraints[e] && (s = q9(s, this.constraints[e], this.elastic[e])), o.set(s);
          }
        }, t.prototype.resolveConstraints = function() {
          var e = this, n = this.getProps(), r = n.dragConstraints, i = n.dragElastic, o = (this.visualElement.projection || {}).layout, s = this.constraints;
          r && Oa(r) ? this.constraints || (this.constraints = this.resolveRefConstraints()) : r && o ? this.constraints = G9(o.actual, r) : this.constraints = false, this.elastic = J9(i), s !== this.constraints && o && this.constraints && !this.hasMutatedConstraints && si(function(a) {
            e.getAxisMotionValue(a) && (e.constraints[a] = Q9(o.actual[a], e.constraints[a]));
          });
        }, t.prototype.resolveRefConstraints = function() {
          var e = this.getProps(), n = e.dragConstraints, r = e.onMeasureDragConstraints;
          if (!n || !Oa(n))
            return false;
          var i = n.current, o = this.visualElement.projection;
          if (!o || !o.layout)
            return false;
          var s = iH(i, o.root, this.visualElement.getTransformPagePoint()), a = Y9(o.layout.actual, s);
          if (r) {
            var l = r(Z9(a));
            this.hasMutatedConstraints = !!l, l && (a = kP(l));
          }
          return a;
        }, t.prototype.startAnimation = function(e) {
          var n = this, r = this.getProps(), i = r.drag, o = r.dragMomentum, s = r.dragElastic, a = r.dragTransition, l = r.dragSnapToOrigin, c = r.onDragTransitionEnd, u = this.constraints || {}, h = si(function(p) {
            var v;
            if (!!mh(p, i, n.currentDirection)) {
              var y = (v = u == null ? void 0 : u[p]) !== null && v !== void 0 ? v : {};
              l && (y = {
                min: 0,
                max: 0
              });
              var S = s ? 200 : 1e6, C = s ? 40 : 1e7, w = ie(ie({
                type: "inertia",
                velocity: o ? e[p] : 0,
                bounceStiffness: S,
                bounceDamping: C,
                timeConstant: 750,
                restDelta: 1,
                restSpeed: 10
              }, a), y);
              return n.startAxisValueAnimation(p, w);
            }
          });
          return Promise.all(h).then(c);
        }, t.prototype.startAxisValueAnimation = function(e, n) {
          var r = this.getAxisMotionValue(e);
          return dx(e, r, 0, n);
        }, t.prototype.stopAnimation = function() {
          var e = this;
          si(function(n) {
            return e.getAxisMotionValue(n).stop();
          });
        }, t.prototype.getAxisMotionValue = function(e) {
          var n, r, i = "_drag" + e.toUpperCase(), o = this.visualElement.getProps()[i];
          return o || this.visualElement.getValue(e, (r = (n = this.visualElement.getProps().initial) === null || n === void 0 ? void 0 : n[e]) !== null && r !== void 0 ? r : 0);
        }, t.prototype.snapToCursor = function(e) {
          var n = this;
          si(function(r) {
            var i = n.getProps().drag;
            if (!!mh(r, i, n.currentDirection)) {
              var o = n.visualElement.projection, s = n.getAxisMotionValue(r);
              if (o && o.layout) {
                var a = o.layout.actual[r], l = a.min, c = a.max;
                s.set(e[r] - wt(l, c, 0.5));
              }
            }
          });
        }, t.prototype.scalePositionWithinConstraints = function() {
          var e = this, n, r = this.getProps(), i = r.drag, o = r.dragConstraints, s = this.visualElement.projection;
          if (!(!Oa(o) || !s || !this.constraints)) {
            this.stopAnimation();
            var a = {
              x: 0,
              y: 0
            };
            si(function(c) {
              var u = e.getAxisMotionValue(c);
              if (u) {
                var h = u.get();
                a[c] = X9({
                  min: h,
                  max: h
                }, e.constraints[c]);
              }
            });
            var l = this.visualElement.getProps().transformTemplate;
            this.visualElement.getInstance().style.transform = l ? l({}, "") : "none", (n = s.root) === null || n === void 0 || n.updateScroll(), s.updateLayout(), this.resolveConstraints(), si(function(c) {
              if (!!mh(c, i, null)) {
                var u = e.getAxisMotionValue(c), h = e.constraints[c], p = h.min, v = h.max;
                u.set(wt(p, v, a[c]));
              }
            });
          }
        }, t.prototype.addListeners = function() {
          var e = this, n;
          oH.set(this.visualElement, this);
          var r = this.visualElement.getInstance(), i = Ua(r, "pointerdown", function(c) {
            var u = e.getProps(), h = u.drag, p = u.dragListener, v = p === void 0 ? true : p;
            h && v && e.start(c);
          }), o = function() {
            var c = e.getProps().dragConstraints;
            Oa(c) && (e.constraints = e.resolveRefConstraints());
          }, s = this.visualElement.projection, a = s.addEventListener("measure", o);
          s && !s.layout && ((n = s.root) === null || n === void 0 || n.updateScroll(), s.updateLayout()), o();
          var l = Lm(window, "resize", function() {
            return e.scalePositionWithinConstraints();
          });
          return s.addEventListener("didUpdate", function(c) {
            var u = c.delta, h = c.hasLayoutChanged;
            e.isDragging && h && (si(function(p) {
              var v = e.getAxisMotionValue(p);
              !v || (e.originPoint[p] += u[p].translate, v.set(v.get() + u[p].translate));
            }), e.visualElement.syncRender());
          }), function() {
            l(), i(), a();
          };
        }, t.prototype.getProps = function() {
          var e = this.visualElement.getProps(), n = e.drag, r = n === void 0 ? false : n, i = e.dragDirectionLock, o = i === void 0 ? false : i, s = e.dragPropagation, a = s === void 0 ? false : s, l = e.dragConstraints, c = l === void 0 ? false : l, u = e.dragElastic, h = u === void 0 ? My : u, p = e.dragMomentum, v = p === void 0 ? true : p;
          return ie(ie({}, e), {
            drag: r,
            dragDirectionLock: o,
            dragPropagation: a,
            dragConstraints: c,
            dragElastic: h,
            dragMomentum: v
          });
        }, t;
      }();
      function mh(t, e, n) {
        return (e === true || e === t) && (n === null || n === t);
      }
      function aH(t, e) {
        e === void 0 && (e = 10);
        var n = null;
        return Math.abs(t.y) > e ? n = "y" : Math.abs(t.x) > e && (n = "x"), n;
      }
      function lH(t) {
        var e = t.dragControls, n = t.visualElement, r = Qu(function() {
          return new sH(n);
        });
        z.exports.useEffect(function() {
          return e && e.subscribe(r);
        }, [
          r,
          e
        ]), z.exports.useEffect(function() {
          return r.addListeners();
        }, [
          r
        ]);
      }
      function cH(t) {
        var e = t.onPan, n = t.onPanStart, r = t.onPanEnd, i = t.onPanSessionStart, o = t.visualElement, s = e || n || r || i, a = z.exports.useRef(null), l = z.exports.useContext(qb).transformPagePoint, c = {
          onSessionStart: i,
          onStart: n,
          onMove: e,
          onEnd: function(h, p) {
            a.current = null, r && r(h, p);
          }
        };
        z.exports.useEffect(function() {
          a.current !== null && a.current.updateHandlers(c);
        });
        function u(h) {
          a.current = new SP(h, c, {
            transformPagePoint: l
          });
        }
        up(o, "pointerdown", s && u), rx(function() {
          return a.current && a.current.end();
        });
      }
      var uH = {
        pan: Ro(cH),
        drag: Ro(lH)
      }, gh = [
        "LayoutMeasure",
        "BeforeLayoutMeasure",
        "LayoutUpdate",
        "ViewportBoxUpdate",
        "Update",
        "Render",
        "AnimationComplete",
        "LayoutAnimationComplete",
        "AnimationStart",
        "LayoutAnimationStart",
        "SetAxisTarget",
        "Unmount"
      ];
      function fH() {
        var t = gh.map(function() {
          return new jc();
        }), e = {}, n = {
          clearAllListeners: function() {
            return t.forEach(function(r) {
              return r.clear();
            });
          },
          updatePropListeners: function(r) {
            gh.forEach(function(i) {
              var o, s = "on" + i, a = r[s];
              (o = e[i]) === null || o === void 0 || o.call(e), a && (e[i] = n[s](a));
            });
          }
        };
        return t.forEach(function(r, i) {
          n["on" + gh[i]] = function(o) {
            return r.add(o);
          }, n["notify" + gh[i]] = function() {
            for (var o = [], s = 0; s < arguments.length; s++)
              o[s] = arguments[s];
            return r.notify.apply(r, Hr([], kt(o), false));
          };
        }), n;
      }
      function hH(t, e, n) {
        var r;
        for (var i in e) {
          var o = e[i], s = n[i];
          if (Zi(o))
            t.addValue(i, o);
          else if (Zi(s))
            t.addValue(i, ul(o));
          else if (s !== o)
            if (t.hasValue(i)) {
              var a = t.getValue(i);
              !a.hasAnimated && a.set(o);
            } else
              t.addValue(i, ul((r = t.getStaticValue(i)) !== null && r !== void 0 ? r : o));
        }
        for (var i in n)
          e[i] === void 0 && t.removeValue(i);
        return e;
      }
      var AP = function(t) {
        var e = t.treeType, n = e === void 0 ? "" : e, r = t.build, i = t.getBaseTarget, o = t.makeTargetAnimatable, s = t.measureViewportBox, a = t.render, l = t.readValueFromInstance, c = t.removeValueFromRenderState, u = t.sortNodePosition, h = t.scrapeMotionValuesFromProps;
        return function(p, v) {
          var y = p.parent, S = p.props, C = p.presenceId, w = p.blockInitialAnimation, k = p.visualState, T = p.shouldReduceMotion;
          v === void 0 && (v = {});
          var P = false, R = k.latestValues, L = k.renderState, D, F = fH(), K = /* @__PURE__ */ new Map(), Y = /* @__PURE__ */ new Map(), te = {}, ne = ie({}, R), ue;
          function ye() {
            !D || !P || (ke(), a(D, L, S.style, se.projection));
          }
          function ke() {
            r(se, L, R, v, S);
          }
          function Ee() {
            F.notifyUpdate(R);
          }
          function Q(re, oe) {
            var De = oe.onChange(function(An) {
              R[re] = An, S.onUpdate && jr.update(Ee, false, true);
            }), yt = oe.onRenderRequest(se.scheduleRender);
            Y.set(re, function() {
              De(), yt();
            });
          }
          var V = h(S);
          for (var ae in V) {
            var ge = V[ae];
            R[ae] !== void 0 && Zi(ge) && ge.set(R[ae], false);
          }
          var Te = Rm(S), ve = yE(S), se = ie(ie({
            treeType: n,
            current: null,
            depth: y ? y.depth + 1 : 0,
            parent: y,
            children: /* @__PURE__ */ new Set(),
            presenceId: C,
            shouldReduceMotion: T,
            variantChildren: ve ? /* @__PURE__ */ new Set() : void 0,
            isVisible: void 0,
            manuallyAnimateOnMount: Boolean(y == null ? void 0 : y.isMounted()),
            blockInitialAnimation: w,
            isMounted: function() {
              return Boolean(D);
            },
            mount: function(re) {
              P = true, D = se.current = re, se.projection && se.projection.mount(re), ve && y && !Te && (ue = y == null ? void 0 : y.addVariantChild(se)), K.forEach(function(oe, De) {
                return Q(De, oe);
              }), y == null ? void 0 : y.children.add(se), se.setProps(S);
            },
            unmount: function() {
              var re;
              (re = se.projection) === null || re === void 0 || re.unmount(), cl.update(Ee), cl.render(ye), Y.forEach(function(oe) {
                return oe();
              }), ue == null ? void 0 : ue(), y == null ? void 0 : y.children.delete(se), F.clearAllListeners(), D = void 0, P = false;
            },
            addVariantChild: function(re) {
              var oe, De = se.getClosestVariantNode();
              if (De)
                return (oe = De.variantChildren) === null || oe === void 0 || oe.add(re), function() {
                  return De.variantChildren.delete(re);
                };
            },
            sortNodePosition: function(re) {
              return !u || n !== re.treeType ? 0 : u(se.getInstance(), re.getInstance());
            },
            getClosestVariantNode: function() {
              return ve ? se : y == null ? void 0 : y.getClosestVariantNode();
            },
            getLayoutId: function() {
              return S.layoutId;
            },
            getInstance: function() {
              return D;
            },
            getStaticValue: function(re) {
              return R[re];
            },
            setStaticValue: function(re, oe) {
              return R[re] = oe;
            },
            getLatestValues: function() {
              return R;
            },
            setVisibility: function(re) {
              se.isVisible !== re && (se.isVisible = re, se.scheduleRender());
            },
            makeTargetAnimatable: function(re, oe) {
              return oe === void 0 && (oe = true), o(se, re, S, oe);
            },
            measureViewportBox: function() {
              return s(D, S);
            },
            addValue: function(re, oe) {
              se.hasValue(re) && se.removeValue(re), K.set(re, oe), R[re] = oe.get(), Q(re, oe);
            },
            removeValue: function(re) {
              var oe;
              K.delete(re), (oe = Y.get(re)) === null || oe === void 0 || oe(), Y.delete(re), delete R[re], c(re, L);
            },
            hasValue: function(re) {
              return K.has(re);
            },
            getValue: function(re, oe) {
              var De = K.get(re);
              return De === void 0 && oe !== void 0 && (De = ul(oe), se.addValue(re, De)), De;
            },
            forEachValue: function(re) {
              return K.forEach(re);
            },
            readValue: function(re) {
              var oe;
              return (oe = R[re]) !== null && oe !== void 0 ? oe : l(D, re, v);
            },
            setBaseTarget: function(re, oe) {
              ne[re] = oe;
            },
            getBaseTarget: function(re) {
              if (i) {
                var oe = i(S, re);
                if (oe !== void 0 && !Zi(oe))
                  return oe;
              }
              return ne[re];
            }
          }, F), {
            build: function() {
              return ke(), L;
            },
            scheduleRender: function() {
              jr.render(ye, false, true);
            },
            syncRender: ye,
            setProps: function(re) {
              (re.transformTemplate || S.transformTemplate) && se.scheduleRender(), S = re, F.updatePropListeners(re), te = hH(se, h(S), te);
            },
            getProps: function() {
              return S;
            },
            getVariant: function(re) {
              var oe;
              return (oe = S.variants) === null || oe === void 0 ? void 0 : oe[re];
            },
            getDefaultTransition: function() {
              return S.transition;
            },
            getTransformPagePoint: function() {
              return S.transformPagePoint;
            },
            getVariantContext: function(re) {
              if (re === void 0 && (re = false), re)
                return y == null ? void 0 : y.getVariantContext();
              if (!Te) {
                var oe = (y == null ? void 0 : y.getVariantContext()) || {};
                return S.initial !== void 0 && (oe.initial = S.initial), oe;
              }
              for (var De = {}, yt = 0; yt < dH; yt++) {
                var An = EP[yt], so = S[An];
                (Ir(so) || so === false) && (De[An] = so);
              }
              return De;
            }
          });
          return se;
        };
      }, EP = Hr([
        "initial"
      ], kt(gx), false), dH = EP.length;
      function Ey(t) {
        return typeof t == "string" && t.startsWith("var(--");
      }
      var PP = /var\((--[a-zA-Z0-9-_]+),? ?([a-zA-Z0-9 ()%#.,-]+)?\)/;
      function pH(t) {
        var e = PP.exec(t);
        if (!e)
          return [
            ,
          ];
        var n = kt(e, 3), r = n[1], i = n[2];
        return [
          r,
          i
        ];
      }
      function Py(t, e, n) {
        var r = kt(pH(t), 2), i = r[0], o = r[1];
        if (!!i) {
          var s = window.getComputedStyle(e).getPropertyValue(i);
          return s ? s.trim() : Ey(o) ? Py(o, e) : o;
        }
      }
      function mH(t, e, n) {
        var r, i = Tr(e, []), o = t.getInstance();
        if (!(o instanceof Element))
          return {
            target: i,
            transitionEnd: n
          };
        n && (n = ie({}, n)), t.forEachValue(function(c) {
          var u = c.get();
          if (!!Ey(u)) {
            var h = Py(u, o);
            h && c.set(h);
          }
        });
        for (var s in i) {
          var a = i[s];
          if (!!Ey(a)) {
            var l = Py(a, o);
            !l || (i[s] = l, n && ((r = n[s]) !== null && r !== void 0 || (n[s] = a)));
          }
        }
        return {
          target: i,
          transitionEnd: n
        };
      }
      var gH = /* @__PURE__ */ new Set([
        "width",
        "height",
        "top",
        "left",
        "right",
        "bottom",
        "x",
        "y"
      ]), OP = function(t) {
        return gH.has(t);
      }, vH = function(t) {
        return Object.keys(t).some(OP);
      }, RP = function(t, e) {
        t.set(e, false), t.set(e);
      }, Rk = function(t) {
        return t === Xs || t === Ce;
      }, Lk;
      (function(t) {
        t.width = "width", t.height = "height", t.left = "left", t.right = "right", t.top = "top", t.bottom = "bottom";
      })(Lk || (Lk = {}));
      var Dk = function(t, e) {
        return parseFloat(t.split(", ")[e]);
      }, _k = function(t, e) {
        return function(n, r) {
          var i = r.transform;
          if (i === "none" || !i)
            return 0;
          var o = i.match(/^matrix3d\((.+)\)$/);
          if (o)
            return Dk(o[1], e);
          var s = i.match(/^matrix\((.+)\)$/);
          return s ? Dk(s[1], t) : 0;
        };
      }, yH = /* @__PURE__ */ new Set([
        "x",
        "y",
        "z"
      ]), bH = Mu.filter(function(t) {
        return !yH.has(t);
      });
      function xH(t) {
        var e = [];
        return bH.forEach(function(n) {
          var r = t.getValue(n);
          r !== void 0 && (e.push([
            n,
            r.get()
          ]), r.set(n.startsWith("scale") ? 1 : 0));
        }), e.length && t.syncRender(), e;
      }
      var Ik = {
        width: function(t, e) {
          var n = t.x, r = e.paddingLeft, i = r === void 0 ? "0" : r, o = e.paddingRight, s = o === void 0 ? "0" : o;
          return n.max - n.min - parseFloat(i) - parseFloat(s);
        },
        height: function(t, e) {
          var n = t.y, r = e.paddingTop, i = r === void 0 ? "0" : r, o = e.paddingBottom, s = o === void 0 ? "0" : o;
          return n.max - n.min - parseFloat(i) - parseFloat(s);
        },
        top: function(t, e) {
          var n = e.top;
          return parseFloat(n);
        },
        left: function(t, e) {
          var n = e.left;
          return parseFloat(n);
        },
        bottom: function(t, e) {
          var n = t.y, r = e.top;
          return parseFloat(r) + (n.max - n.min);
        },
        right: function(t, e) {
          var n = t.x, r = e.left;
          return parseFloat(r) + (n.max - n.min);
        },
        x: _k(4, 13),
        y: _k(5, 14)
      }, SH = function(t, e, n) {
        var r = e.measureViewportBox(), i = e.getInstance(), o = getComputedStyle(i), s = o.display, a = {};
        s === "none" && e.setStaticValue("display", t.display || "block"), n.forEach(function(c) {
          a[c] = Ik[c](r, o);
        }), e.syncRender();
        var l = e.measureViewportBox();
        return n.forEach(function(c) {
          var u = e.getValue(c);
          RP(u, a[c]), t[c] = Ik[c](l, o);
        }), t;
      }, wH = function(t, e, n, r) {
        n === void 0 && (n = {}), r === void 0 && (r = {}), e = ie({}, e), r = ie({}, r);
        var i = Object.keys(e).filter(OP), o = [], s = false, a = [];
        if (i.forEach(function(u) {
          var h = t.getValue(u);
          if (!!t.hasValue(u)) {
            var p = n[u], v = tc(p), y = e[u], S;
            if (Eu(y)) {
              var C = y.length, w = y[0] === null ? 1 : 0;
              p = y[w], v = tc(p);
              for (var k = w; k < C; k++)
                S ? sp(tc(y[k]) === S) : S = tc(y[k]);
            } else
              S = tc(y);
            if (v !== S)
              if (Rk(v) && Rk(S)) {
                var T = h.get();
                typeof T == "string" && h.set(parseFloat(T)), typeof y == "string" ? e[u] = parseFloat(y) : Array.isArray(y) && S === Ce && (e[u] = y.map(parseFloat));
              } else
                (v == null ? void 0 : v.transform) && (S == null ? void 0 : S.transform) && (p === 0 || y === 0) ? p === 0 ? h.set(S.transform(p)) : e[u] = v.transform(y) : (s || (o = xH(t), s = true), a.push(u), r[u] = r[u] !== void 0 ? r[u] : e[u], RP(h, y));
          }
        }), a.length) {
          var l = a.indexOf("height") >= 0 ? window.pageYOffset : null, c = SH(e, t, a);
          return o.length && o.forEach(function(u) {
            var h = kt(u, 2), p = h[0], v = h[1];
            t.getValue(p).set(v);
          }), t.syncRender(), l !== null && window.scrollTo({
            top: l
          }), {
            target: c,
            transitionEnd: r
          };
        } else
          return {
            target: e,
            transitionEnd: r
          };
      };
      function kH(t, e, n, r) {
        return vH(e) ? wH(t, e, n, r) : {
          target: e,
          transitionEnd: r
        };
      }
      var CH = function(t, e, n, r) {
        var i = mH(t, e, r);
        return e = i.target, r = i.transitionEnd, kH(t, e, n, r);
      };
      function TH(t) {
        return window.getComputedStyle(t);
      }
      var LP = {
        treeType: "dom",
        readValueFromInstance: function(t, e) {
          if (Ju(e)) {
            var n = ux(e);
            return n && n.default || 0;
          } else {
            var r = TH(t);
            return (wE(e) ? r.getPropertyValue(e) : r[e]) || 0;
          }
        },
        sortNodePosition: function(t, e) {
          return t.compareDocumentPosition(e) & 2 ? 1 : -1;
        },
        getBaseTarget: function(t, e) {
          var n;
          return (n = t.style) === null || n === void 0 ? void 0 : n[e];
        },
        measureViewportBox: function(t, e) {
          var n = e.transformPagePoint;
          return MP(t, n);
        },
        resetTransform: function(t, e, n) {
          var r = n.transformTemplate;
          e.style.transform = r ? r({}, "") : "none", t.scheduleRender();
        },
        restoreTransform: function(t, e) {
          t.style.transform = e.style.transform;
        },
        removeValueFromRenderState: function(t, e) {
          var n = e.vars, r = e.style;
          delete n[t], delete r[t];
        },
        makeTargetAnimatable: function(t, e, n, r) {
          var i = n.transformValues;
          r === void 0 && (r = true);
          var o = e.transition, s = e.transitionEnd, a = Tr(e, [
            "transition",
            "transitionEnd"
          ]), l = L9(a, o || {}, t);
          if (i && (s && (s = i(s)), a && (a = i(a)), l && (l = i(l))), r) {
            O9(t, a, l);
            var c = CH(t, a, l, s);
            s = c.transitionEnd, a = c.target;
          }
          return ie({
            transition: o,
            transitionEnd: s
          }, a);
        },
        scrapeMotionValuesFromProps: ex,
        build: function(t, e, n, r, i) {
          t.isVisible !== void 0 && (e.style.visibility = t.isVisible ? "visible" : "hidden"), Qb(e, n, r, i.transformTemplate);
        },
        render: IE
      }, MH = AP(LP), AH = AP(ie(ie({}, LP), {
        getBaseTarget: function(t, e) {
          return t[e];
        },
        readValueFromInstance: function(t, e) {
          var n;
          return Ju(e) ? ((n = ux(e)) === null || n === void 0 ? void 0 : n.default) || 0 : (e = BE.has(e) ? e : _E(e), t.getAttribute(e));
        },
        scrapeMotionValuesFromProps: $E,
        build: function(t, e, n, r, i) {
          Zb(e, n, r, i.transformTemplate);
        },
        render: NE
      })), EH = function(t, e) {
        return Yb(t) ? AH(e, {
          enableHardwareAcceleration: false
        }) : MH(e, {
          enableHardwareAcceleration: true
        });
      };
      function Bk(t, e) {
        return e.max === e.min ? 0 : t / (e.max - e.min) * 100;
      }
      var nc = {
        correct: function(t, e) {
          if (!e.target)
            return t;
          if (typeof t == "string")
            if (Ce.test(t))
              t = parseFloat(t);
            else
              return t;
          var n = Bk(t, e.target.x), r = Bk(t, e.target.y);
          return "".concat(n, "% ").concat(r, "%");
        }
      }, Nk = "_$css", PH = {
        correct: function(t, e) {
          var n = e.treeScale, r = e.projectionDelta, i = t, o = t.includes("var("), s = [];
          o && (t = t.replace(PP, function(S) {
            return s.push(S), Nk;
          }));
          var a = eo.parse(t);
          if (a.length > 5)
            return i;
          var l = eo.createTransformer(t), c = typeof a[0] != "number" ? 1 : 0, u = r.x.scale * n.x, h = r.y.scale * n.y;
          a[0 + c] /= u, a[1 + c] /= h;
          var p = wt(u, h, 0.5);
          typeof a[2 + c] == "number" && (a[2 + c] /= p), typeof a[3 + c] == "number" && (a[3 + c] /= p);
          var v = l(a);
          if (o) {
            var y = 0;
            v = v.replace(Nk, function() {
              var S = s[y];
              return y++, S;
            });
          }
          return v;
        }
      }, OH = function(t) {
        hE(e, t);
        function e() {
          return t !== null && t.apply(this, arguments) || this;
        }
        return e.prototype.componentDidMount = function() {
          var n = this, r = this.props, i = r.visualElement, o = r.layoutGroup, s = r.switchLayoutGroup, a = r.layoutId, l = i.projection;
          JV(LH), l && ((o == null ? void 0 : o.group) && o.group.add(l), (s == null ? void 0 : s.register) && a && s.register(l), l.root.didUpdate(), l.addEventListener("animationComplete", function() {
            n.safeToRemove();
          }), l.setOptions(ie(ie({}, l.options), {
            onExitComplete: function() {
              return n.safeToRemove();
            }
          }))), Fc.hasEverUpdated = true;
        }, e.prototype.getSnapshotBeforeUpdate = function(n) {
          var r = this, i = this.props, o = i.layoutDependency, s = i.visualElement, a = i.drag, l = i.isPresent, c = s.projection;
          return c && (c.isPresent = l, a || n.layoutDependency !== o || o === void 0 ? c.willUpdate() : this.safeToRemove(), n.isPresent !== l && (l ? c.promote() : c.relegate() || jr.postRender(function() {
            var u;
            !((u = c.getStack()) === null || u === void 0) && u.members.length || r.safeToRemove();
          }))), null;
        }, e.prototype.componentDidUpdate = function() {
          var n = this.props.visualElement.projection;
          n && (n.root.didUpdate(), !n.currentAnimation && n.isLead() && this.safeToRemove());
        }, e.prototype.componentWillUnmount = function() {
          var n = this.props, r = n.visualElement, i = n.layoutGroup, o = n.switchLayoutGroup, s = r.projection;
          s && (s.scheduleCheckAfterUnmount(), (i == null ? void 0 : i.group) && i.group.remove(s), (o == null ? void 0 : o.deregister) && o.deregister(s));
        }, e.prototype.safeToRemove = function() {
          var n = this.props.safeToRemove;
          n == null ? void 0 : n();
        }, e.prototype.render = function() {
          return null;
        }, e;
      }(Wp.Component);
      function RH(t) {
        var e = kt(gP(), 2), n = e[0], r = e[1], i = z.exports.useContext(Gb);
        return Z(OH, {
          ...ie({}, t, {
            layoutGroup: i,
            switchLayoutGroup: z.exports.useContext(bE),
            isPresent: n,
            safeToRemove: r
          })
        });
      }
      var LH = {
        borderRadius: ie(ie({}, nc), {
          applyTo: [
            "borderTopLeftRadius",
            "borderTopRightRadius",
            "borderBottomLeftRadius",
            "borderBottomRightRadius"
          ]
        }),
        borderTopLeftRadius: nc,
        borderTopRightRadius: nc,
        borderBottomLeftRadius: nc,
        borderBottomRightRadius: nc,
        boxShadow: PH
      }, DH = {
        measureLayout: RH
      };
      function _H(t, e, n) {
        n === void 0 && (n = {});
        var r = Zi(t) ? t : ul(t);
        return dx("", r, e, n), {
          stop: function() {
            return r.stop();
          },
          isAnimating: function() {
            return r.isAnimating();
          }
        };
      }
      var DP = [
        "TopLeft",
        "TopRight",
        "BottomLeft",
        "BottomRight"
      ], IH = DP.length, $k = function(t) {
        return typeof t == "string" ? parseFloat(t) : t;
      }, zk = function(t) {
        return typeof t == "number" || Ce.test(t);
      };
      function BH(t, e, n, r, i, o) {
        var s, a, l, c;
        i ? (t.opacity = wt(0, (s = n.opacity) !== null && s !== void 0 ? s : 1, NH(r)), t.opacityExit = wt((a = e.opacity) !== null && a !== void 0 ? a : 1, 0, $H(r))) : o && (t.opacity = wt((l = e.opacity) !== null && l !== void 0 ? l : 1, (c = n.opacity) !== null && c !== void 0 ? c : 1, r));
        for (var u = 0; u < IH; u++) {
          var h = "border".concat(DP[u], "Radius"), p = Fk(e, h), v = Fk(n, h);
          if (!(p === void 0 && v === void 0)) {
            p || (p = 0), v || (v = 0);
            var y = p === 0 || v === 0 || zk(p) === zk(v);
            y ? (t[h] = Math.max(wt($k(p), $k(v), r), 0), (wi.test(v) || wi.test(p)) && (t[h] += "%")) : t[h] = v;
          }
        }
        (e.rotate || n.rotate) && (t.rotate = wt(e.rotate || 0, n.rotate || 0, r));
      }
      function Fk(t, e) {
        var n;
        return (n = t[e]) !== null && n !== void 0 ? n : t.borderRadius;
      }
      var NH = _P(0, 0.5, lx), $H = _P(0.5, 0.95, sx);
      function _P(t, e, n) {
        return function(r) {
          return r < t ? 0 : r > e ? 1 : n(Pu(t, e, r));
        };
      }
      function Vk(t, e) {
        t.min = e.min, t.max = e.max;
      }
      function Lr(t, e) {
        Vk(t.x, e.x), Vk(t.y, e.y);
      }
      function Hk(t, e, n, r, i) {
        return t -= e, t = gp(t, 1 / n, r), i !== void 0 && (t = gp(t, 1 / i, r)), t;
      }
      function zH(t, e, n, r, i, o, s) {
        if (e === void 0 && (e = 0), n === void 0 && (n = 1), r === void 0 && (r = 0.5), o === void 0 && (o = t), s === void 0 && (s = t), wi.test(e)) {
          e = parseFloat(e);
          var a = wt(s.min, s.max, e / 100);
          e = a - s.min;
        }
        if (typeof e == "number") {
          var l = wt(o.min, o.max, r);
          t === o && (l -= e), t.min = Hk(t.min, e, n, l, i), t.max = Hk(t.max, e, n, l, i);
        }
      }
      function jk(t, e, n, r, i) {
        var o = kt(n, 3), s = o[0], a = o[1], l = o[2];
        zH(t, e[s], e[a], e[l], e.scale, r, i);
      }
      var FH = [
        "x",
        "scaleX",
        "originX"
      ], VH = [
        "y",
        "scaleY",
        "originY"
      ];
      function Wk(t, e, n, r) {
        jk(t.x, e, FH, n == null ? void 0 : n.x, r == null ? void 0 : r.x), jk(t.y, e, VH, n == null ? void 0 : n.y, r == null ? void 0 : r.y);
      }
      function Uk(t) {
        return t.translate === 0 && t.scale === 1;
      }
      function IP(t) {
        return Uk(t.x) && Uk(t.y);
      }
      function BP(t, e) {
        return t.x.min === e.x.min && t.x.max === e.x.max && t.y.min === e.y.min && t.y.max === e.y.max;
      }
      var HH = function() {
        function t() {
          this.members = [];
        }
        return t.prototype.add = function(e) {
          px(this.members, e), e.scheduleRender();
        }, t.prototype.remove = function(e) {
          if (mx(this.members, e), e === this.prevLead && (this.prevLead = void 0), e === this.lead) {
            var n = this.members[this.members.length - 1];
            n && this.promote(n);
          }
        }, t.prototype.relegate = function(e) {
          var n = this.members.findIndex(function(s) {
            return e === s;
          });
          if (n === 0)
            return false;
          for (var r, i = n; i >= 0; i--) {
            var o = this.members[i];
            if (o.isPresent !== false) {
              r = o;
              break;
            }
          }
          return r ? (this.promote(r), true) : false;
        }, t.prototype.promote = function(e, n) {
          var r, i = this.lead;
          if (e !== i && (this.prevLead = i, this.lead = e, e.show(), i)) {
            i.instance && i.scheduleRender(), e.scheduleRender(), e.resumeFrom = i, n && (e.resumeFrom.preserveOpacity = true), i.snapshot && (e.snapshot = i.snapshot, e.snapshot.latestValues = i.animationValues || i.latestValues, e.snapshot.isShared = true), !((r = e.root) === null || r === void 0) && r.isUpdating && (e.isLayoutDirty = true);
            var o = e.options.crossfade;
            o === false && i.hide();
          }
        }, t.prototype.exitAnimationComplete = function() {
          this.members.forEach(function(e) {
            var n, r, i, o, s;
            (r = (n = e.options).onExitComplete) === null || r === void 0 || r.call(n), (s = (i = e.resumingFrom) === null || i === void 0 ? void 0 : (o = i.options).onExitComplete) === null || s === void 0 || s.call(o);
          });
        }, t.prototype.scheduleRender = function() {
          this.members.forEach(function(e) {
            e.instance && e.scheduleRender(false);
          });
        }, t.prototype.removeLeadSnapshot = function() {
          this.lead && this.lead.snapshot && (this.lead.snapshot = void 0);
        }, t;
      }(), jH = "translate3d(0px, 0px, 0) scale(1, 1) scale(1, 1)";
      function Kk(t, e, n) {
        var r = t.x.translate / e.x, i = t.y.translate / e.y, o = "translate3d(".concat(r, "px, ").concat(i, "px, 0) ");
        if (o += "scale(".concat(1 / e.x, ", ").concat(1 / e.y, ") "), n) {
          var s = n.rotate, a = n.rotateX, l = n.rotateY;
          s && (o += "rotate(".concat(s, "deg) ")), a && (o += "rotateX(".concat(a, "deg) ")), l && (o += "rotateY(".concat(l, "deg) "));
        }
        var c = t.x.scale * e.x, u = t.y.scale * e.y;
        return o += "scale(".concat(c, ", ").concat(u, ")"), o === jH ? "none" : o;
      }
      var WH = function(t, e) {
        return t.depth - e.depth;
      }, UH = function() {
        function t() {
          this.children = [], this.isDirty = false;
        }
        return t.prototype.add = function(e) {
          px(this.children, e), this.isDirty = true;
        }, t.prototype.remove = function(e) {
          mx(this.children, e), this.isDirty = true;
        }, t.prototype.forEach = function(e) {
          this.isDirty && this.children.sort(WH), this.isDirty = false, this.children.forEach(e);
        }, t;
      }(), qk = 1e3;
      function NP(t) {
        var e = t.attachResizeListener, n = t.defaultParent, r = t.measureScroll, i = t.checkIsScrollRoot, o = t.resetTransform;
        return function() {
          function s(a, l, c) {
            var u = this;
            l === void 0 && (l = {}), c === void 0 && (c = n == null ? void 0 : n()), this.children = /* @__PURE__ */ new Set(), this.options = {}, this.isTreeAnimating = false, this.isAnimationBlocked = false, this.isLayoutDirty = false, this.updateManuallyBlocked = false, this.updateBlockedByResize = false, this.isUpdating = false, this.isSVG = false, this.needsReset = false, this.shouldResetTransform = false, this.treeScale = {
              x: 1,
              y: 1
            }, this.eventHandlers = /* @__PURE__ */ new Map(), this.potentialNodes = /* @__PURE__ */ new Map(), this.checkUpdateFailed = function() {
              u.isUpdating && (u.isUpdating = false, u.clearAllSnapshots());
            }, this.updateProjection = function() {
              u.nodes.forEach(QH), u.nodes.forEach(JH);
            }, this.hasProjected = false, this.isVisible = true, this.animationProgress = 0, this.sharedNodes = /* @__PURE__ */ new Map(), this.id = a, this.latestValues = l, this.root = c ? c.root || c : this, this.path = c ? Hr(Hr([], kt(c.path), false), [
              c
            ], false) : [], this.parent = c, this.depth = c ? c.depth + 1 : 0, a && this.root.registerPotentialNode(a, this);
            for (var h = 0; h < this.path.length; h++)
              this.path[h].shouldResetTransform = true;
            this.root === this && (this.nodes = new UH());
          }
          return s.prototype.addEventListener = function(a, l) {
            return this.eventHandlers.has(a) || this.eventHandlers.set(a, new jc()), this.eventHandlers.get(a).add(l);
          }, s.prototype.notifyListeners = function(a) {
            for (var l = [], c = 1; c < arguments.length; c++)
              l[c - 1] = arguments[c];
            var u = this.eventHandlers.get(a);
            u == null ? void 0 : u.notify.apply(u, Hr([], kt(l), false));
          }, s.prototype.hasListeners = function(a) {
            return this.eventHandlers.has(a);
          }, s.prototype.registerPotentialNode = function(a, l) {
            this.potentialNodes.set(a, l);
          }, s.prototype.mount = function(a, l) {
            var c = this, u;
            if (l === void 0 && (l = false), !this.instance) {
              this.isSVG = a instanceof SVGElement && a.tagName !== "svg", this.instance = a;
              var h = this.options, p = h.layoutId, v = h.layout, y = h.visualElement;
              if (y && !y.getInstance() && y.mount(a), this.root.nodes.add(this), (u = this.parent) === null || u === void 0 || u.children.add(this), this.id && this.root.potentialNodes.delete(this.id), l && (v || p) && (this.isLayoutDirty = true), e) {
                var S, C = function() {
                  return c.root.updateBlockedByResize = false;
                };
                e(a, function() {
                  c.root.updateBlockedByResize = true, clearTimeout(S), S = window.setTimeout(C, 250), Fc.hasAnimatedSinceResize && (Fc.hasAnimatedSinceResize = false, c.nodes.forEach(XH));
                });
              }
              p && this.root.registerSharedNode(p, this), this.options.animate !== false && y && (p || v) && this.addEventListener("didUpdate", function(w) {
                var k, T, P, R, L, D = w.delta, F = w.hasLayoutChanged, K = w.hasRelativeTargetChanged, Y = w.layout;
                if (c.isTreeAnimationBlocked()) {
                  c.target = void 0, c.relativeTarget = void 0;
                  return;
                }
                var te = (T = (k = c.options.transition) !== null && k !== void 0 ? k : y.getDefaultTransition()) !== null && T !== void 0 ? T : rj, ne = y.getProps(), ue = ne.onLayoutAnimationStart, ye = ne.onLayoutAnimationComplete, ke = !c.targetLayout || !BP(c.targetLayout, Y) || K, Ee = !F && K;
                if (((P = c.resumeFrom) === null || P === void 0 ? void 0 : P.instance) || Ee || F && (ke || !c.currentAnimation)) {
                  c.resumeFrom && (c.resumingFrom = c.resumeFrom, c.resumingFrom.resumingFrom = void 0), c.setAnimationOrigin(D, Ee);
                  var Q = ie(ie({}, hx(te, "layout")), {
                    onPlay: ue,
                    onComplete: ye
                  });
                  y.shouldReduceMotion && (Q.delay = 0, Q.type = false), c.startAnimation(Q);
                } else
                  !F && c.animationProgress === 0 && c.finishAnimation(), c.isLead() && ((L = (R = c.options).onExitComplete) === null || L === void 0 || L.call(R));
                c.targetLayout = Y;
              });
            }
          }, s.prototype.unmount = function() {
            var a, l;
            this.options.layoutId && this.willUpdate(), this.root.nodes.remove(this), (a = this.getStack()) === null || a === void 0 || a.remove(this), (l = this.parent) === null || l === void 0 || l.children.delete(this), this.instance = void 0, cl.preRender(this.updateProjection);
          }, s.prototype.blockUpdate = function() {
            this.updateManuallyBlocked = true;
          }, s.prototype.unblockUpdate = function() {
            this.updateManuallyBlocked = false;
          }, s.prototype.isUpdateBlocked = function() {
            return this.updateManuallyBlocked || this.updateBlockedByResize;
          }, s.prototype.isTreeAnimationBlocked = function() {
            var a;
            return this.isAnimationBlocked || ((a = this.parent) === null || a === void 0 ? void 0 : a.isTreeAnimationBlocked()) || false;
          }, s.prototype.startUpdate = function() {
            var a;
            this.isUpdateBlocked() || (this.isUpdating = true, (a = this.nodes) === null || a === void 0 || a.forEach(ZH));
          }, s.prototype.willUpdate = function(a) {
            var l, c, u;
            if (a === void 0 && (a = true), this.root.isUpdateBlocked()) {
              (c = (l = this.options).onExitComplete) === null || c === void 0 || c.call(l);
              return;
            }
            if (!this.root.isUpdating && this.root.startUpdate(), !this.isLayoutDirty) {
              this.isLayoutDirty = true;
              for (var h = 0; h < this.path.length; h++) {
                var p = this.path[h];
                p.shouldResetTransform = true, p.updateScroll();
              }
              var v = this.options, y = v.layoutId, S = v.layout;
              if (!(y === void 0 && !S)) {
                var C = (u = this.options.visualElement) === null || u === void 0 ? void 0 : u.getProps().transformTemplate;
                this.prevTransformTemplateValue = C == null ? void 0 : C(this.latestValues, ""), this.updateSnapshot(), a && this.notifyListeners("willUpdate");
              }
            }
          }, s.prototype.didUpdate = function() {
            var a = this.isUpdateBlocked();
            if (a) {
              this.unblockUpdate(), this.clearAllSnapshots(), this.nodes.forEach(Gk);
              return;
            }
            !this.isUpdating || (this.isUpdating = false, this.potentialNodes.size && (this.potentialNodes.forEach(ij), this.potentialNodes.clear()), this.nodes.forEach(YH), this.nodes.forEach(KH), this.nodes.forEach(qH), this.clearAllSnapshots(), b0.update(), b0.preRender(), b0.render());
          }, s.prototype.clearAllSnapshots = function() {
            this.nodes.forEach(GH), this.sharedNodes.forEach(ej);
          }, s.prototype.scheduleUpdateProjection = function() {
            jr.preRender(this.updateProjection, false, true);
          }, s.prototype.scheduleCheckAfterUnmount = function() {
            var a = this;
            jr.postRender(function() {
              a.isLayoutDirty ? a.root.didUpdate() : a.root.checkUpdateFailed();
            });
          }, s.prototype.updateSnapshot = function() {
            if (!(this.snapshot || !this.instance)) {
              var a = this.measure(), l = this.removeTransform(this.removeElementScroll(a));
              Jk(l), this.snapshot = {
                measured: a,
                layout: l,
                latestValues: {}
              };
            }
          }, s.prototype.updateLayout = function() {
            var a;
            if (!!this.instance && (this.updateScroll(), !(!(this.options.alwaysMeasureLayout && this.isLead()) && !this.isLayoutDirty))) {
              if (this.resumeFrom && !this.resumeFrom.instance)
                for (var l = 0; l < this.path.length; l++) {
                  var c = this.path[l];
                  c.updateScroll();
                }
              var u = this.measure();
              Jk(u);
              var h = this.layout;
              this.layout = {
                measured: u,
                actual: this.removeElementScroll(u)
              }, this.layoutCorrected = cn(), this.isLayoutDirty = false, this.projectionDelta = void 0, this.notifyListeners("measure", this.layout.actual), (a = this.options.visualElement) === null || a === void 0 || a.notifyLayoutMeasure(this.layout.actual, h == null ? void 0 : h.actual);
            }
          }, s.prototype.updateScroll = function() {
            this.options.layoutScroll && this.instance && (this.isScrollRoot = i(this.instance), this.scroll = r(this.instance));
          }, s.prototype.resetTransform = function() {
            var a;
            if (!!o) {
              var l = this.isLayoutDirty || this.shouldResetTransform, c = this.projectionDelta && !IP(this.projectionDelta), u = (a = this.options.visualElement) === null || a === void 0 ? void 0 : a.getProps().transformTemplate, h = u == null ? void 0 : u(this.latestValues, ""), p = h !== this.prevTransformTemplateValue;
              l && (c || vo(this.latestValues) || p) && (o(this.instance, h), this.shouldResetTransform = false, this.scheduleRender());
            }
          }, s.prototype.measure = function() {
            var a = this.options.visualElement;
            if (!a)
              return cn();
            var l = a.measureViewportBox(), c = this.root.scroll;
            return c && (xo(l.x, c.x), xo(l.y, c.y)), l;
          }, s.prototype.removeElementScroll = function(a) {
            var l = cn();
            Lr(l, a);
            for (var c = 0; c < this.path.length; c++) {
              var u = this.path[c], h = u.scroll, p = u.options, v = u.isScrollRoot;
              if (u !== this.root && h && p.layoutScroll) {
                if (v) {
                  Lr(l, a);
                  var y = this.root.scroll;
                  y && (xo(l.x, -y.x), xo(l.y, -y.y));
                }
                xo(l.x, h.x), xo(l.y, h.y);
              }
            }
            return l;
          }, s.prototype.applyTransform = function(a, l) {
            l === void 0 && (l = false);
            var c = cn();
            Lr(c, a);
            for (var u = 0; u < this.path.length; u++) {
              var h = this.path[u];
              !l && h.options.layoutScroll && h.scroll && h !== h.root && Ra(c, {
                x: -h.scroll.x,
                y: -h.scroll.y
              }), vo(h.latestValues) && Ra(c, h.latestValues);
            }
            return vo(this.latestValues) && Ra(c, this.latestValues), c;
          }, s.prototype.removeTransform = function(a) {
            var l, c = cn();
            Lr(c, a);
            for (var u = 0; u < this.path.length; u++) {
              var h = this.path[u];
              if (!!h.instance && !!vo(h.latestValues)) {
                CP(h.latestValues) && h.updateSnapshot();
                var p = cn(), v = h.measure();
                Lr(p, v), Wk(c, h.latestValues, (l = h.snapshot) === null || l === void 0 ? void 0 : l.layout, p);
              }
            }
            return vo(this.latestValues) && Wk(c, this.latestValues), c;
          }, s.prototype.setTargetDelta = function(a) {
            this.targetDelta = a, this.root.scheduleUpdateProjection();
          }, s.prototype.setOptions = function(a) {
            var l;
            this.options = ie(ie(ie({}, this.options), a), {
              crossfade: (l = a.crossfade) !== null && l !== void 0 ? l : true
            });
          }, s.prototype.clearMeasurements = function() {
            this.scroll = void 0, this.layout = void 0, this.snapshot = void 0, this.prevTransformTemplateValue = void 0, this.targetDelta = void 0, this.target = void 0, this.isLayoutDirty = false;
          }, s.prototype.resolveTargetDelta = function() {
            var a, l = this.options, c = l.layout, u = l.layoutId;
            !this.layout || !(c || u) || (!this.targetDelta && !this.relativeTarget && (this.relativeParent = this.getClosestProjectingParent(), this.relativeParent && this.relativeParent.layout && (this.relativeTarget = cn(), this.relativeTargetOrigin = cn(), Uc(this.relativeTargetOrigin, this.layout.actual, this.relativeParent.layout.actual), Lr(this.relativeTarget, this.relativeTargetOrigin))), !(!this.relativeTarget && !this.targetDelta) && (this.target || (this.target = cn(), this.targetWithTransforms = cn()), this.relativeTarget && this.relativeTargetOrigin && ((a = this.relativeParent) === null || a === void 0 ? void 0 : a.target) ? K9(this.target, this.relativeTarget, this.relativeParent.target) : this.targetDelta ? (Boolean(this.resumingFrom) ? this.target = this.applyTransform(this.layout.actual) : Lr(this.target, this.layout.actual), TP(this.target, this.targetDelta)) : Lr(this.target, this.layout.actual), this.attemptToResolveRelativeTarget && (this.attemptToResolveRelativeTarget = false, this.relativeParent = this.getClosestProjectingParent(), this.relativeParent && Boolean(this.relativeParent.resumingFrom) === Boolean(this.resumingFrom) && !this.relativeParent.options.layoutScroll && this.relativeParent.target && (this.relativeTarget = cn(), this.relativeTargetOrigin = cn(), Uc(this.relativeTargetOrigin, this.target, this.relativeParent.target), Lr(this.relativeTarget, this.relativeTargetOrigin)))));
          }, s.prototype.getClosestProjectingParent = function() {
            if (!(!this.parent || vo(this.parent.latestValues)))
              return (this.parent.relativeTarget || this.parent.targetDelta) && this.parent.layout ? this.parent : this.parent.getClosestProjectingParent();
          }, s.prototype.calcProjection = function() {
            var a, l = this.options, c = l.layout, u = l.layoutId;
            if (this.isTreeAnimating = Boolean(((a = this.parent) === null || a === void 0 ? void 0 : a.isTreeAnimating) || this.currentAnimation || this.pendingAnimation), this.isTreeAnimating || (this.targetDelta = this.relativeTarget = void 0), !(!this.layout || !(c || u))) {
              var h = this.getLead();
              Lr(this.layoutCorrected, this.layout.actual), tH(this.layoutCorrected, this.treeScale, this.path, Boolean(this.resumingFrom) || this !== h);
              var p = h.target;
              if (!!p) {
                this.projectionDelta || (this.projectionDelta = Kc(), this.projectionDeltaWithTransform = Kc());
                var v = this.treeScale.x, y = this.treeScale.y, S = this.projectionTransform;
                Wc(this.projectionDelta, this.layoutCorrected, p, this.latestValues), this.projectionTransform = Kk(this.projectionDelta, this.treeScale), (this.projectionTransform !== S || this.treeScale.x !== v || this.treeScale.y !== y) && (this.hasProjected = true, this.scheduleRender(), this.notifyListeners("projectionUpdate", p));
              }
            }
          }, s.prototype.hide = function() {
            this.isVisible = false;
          }, s.prototype.show = function() {
            this.isVisible = true;
          }, s.prototype.scheduleRender = function(a) {
            var l, c, u;
            a === void 0 && (a = true), (c = (l = this.options).scheduleRender) === null || c === void 0 || c.call(l), a && ((u = this.getStack()) === null || u === void 0 || u.scheduleRender()), this.resumingFrom && !this.resumingFrom.instance && (this.resumingFrom = void 0);
          }, s.prototype.setAnimationOrigin = function(a, l) {
            var c = this, u;
            l === void 0 && (l = false);
            var h = this.snapshot, p = (h == null ? void 0 : h.latestValues) || {}, v = ie({}, this.latestValues), y = Kc();
            this.relativeTarget = this.relativeTargetOrigin = void 0, this.attemptToResolveRelativeTarget = !l;
            var S = cn(), C = h == null ? void 0 : h.isShared, w = (((u = this.getStack()) === null || u === void 0 ? void 0 : u.members.length) || 0) <= 1, k = Boolean(C && !w && this.options.crossfade === true && !this.path.some(nj));
            this.animationProgress = 0, this.mixTargetDelta = function(T) {
              var P, R = T / 1e3;
              Yk(y.x, a.x, R), Yk(y.y, a.y, R), c.setTargetDelta(y), c.relativeTarget && c.relativeTargetOrigin && c.layout && ((P = c.relativeParent) === null || P === void 0 ? void 0 : P.layout) && (Uc(S, c.layout.actual, c.relativeParent.layout.actual), tj(c.relativeTarget, c.relativeTargetOrigin, S, R)), C && (c.animationValues = v, BH(v, p, c.latestValues, R, k, w)), c.root.scheduleUpdateProjection(), c.scheduleRender(), c.animationProgress = R;
            }, this.mixTargetDelta(0);
          }, s.prototype.startAnimation = function(a) {
            var l = this, c, u;
            this.notifyListeners("animationStart"), (c = this.currentAnimation) === null || c === void 0 || c.stop(), this.resumingFrom && ((u = this.resumingFrom.currentAnimation) === null || u === void 0 || u.stop()), this.pendingAnimation && (cl.update(this.pendingAnimation), this.pendingAnimation = void 0), this.pendingAnimation = jr.update(function() {
              Fc.hasAnimatedSinceResize = true, l.currentAnimation = _H(0, qk, ie(ie({}, a), {
                onUpdate: function(h) {
                  var p;
                  l.mixTargetDelta(h), (p = a.onUpdate) === null || p === void 0 || p.call(a, h);
                },
                onComplete: function() {
                  var h;
                  (h = a.onComplete) === null || h === void 0 || h.call(a), l.completeAnimation();
                }
              })), l.resumingFrom && (l.resumingFrom.currentAnimation = l.currentAnimation), l.pendingAnimation = void 0;
            });
          }, s.prototype.completeAnimation = function() {
            var a;
            this.resumingFrom && (this.resumingFrom.currentAnimation = void 0, this.resumingFrom.preserveOpacity = void 0), (a = this.getStack()) === null || a === void 0 || a.exitAnimationComplete(), this.resumingFrom = this.currentAnimation = this.animationValues = void 0, this.notifyListeners("animationComplete");
          }, s.prototype.finishAnimation = function() {
            var a;
            this.currentAnimation && ((a = this.mixTargetDelta) === null || a === void 0 || a.call(this, qk), this.currentAnimation.stop()), this.completeAnimation();
          }, s.prototype.applyTransformsToTarget = function() {
            var a = this.getLead(), l = a.targetWithTransforms, c = a.target, u = a.layout, h = a.latestValues;
            !l || !c || !u || (Lr(l, c), Ra(l, h), Wc(this.projectionDeltaWithTransform, this.layoutCorrected, l, h));
          }, s.prototype.registerSharedNode = function(a, l) {
            var c, u, h;
            this.sharedNodes.has(a) || this.sharedNodes.set(a, new HH());
            var p = this.sharedNodes.get(a);
            p.add(l), l.promote({
              transition: (c = l.options.initialPromotionConfig) === null || c === void 0 ? void 0 : c.transition,
              preserveFollowOpacity: (h = (u = l.options.initialPromotionConfig) === null || u === void 0 ? void 0 : u.shouldPreserveFollowOpacity) === null || h === void 0 ? void 0 : h.call(u, l)
            });
          }, s.prototype.isLead = function() {
            var a = this.getStack();
            return a ? a.lead === this : true;
          }, s.prototype.getLead = function() {
            var a, l = this.options.layoutId;
            return l ? ((a = this.getStack()) === null || a === void 0 ? void 0 : a.lead) || this : this;
          }, s.prototype.getPrevLead = function() {
            var a, l = this.options.layoutId;
            return l ? (a = this.getStack()) === null || a === void 0 ? void 0 : a.prevLead : void 0;
          }, s.prototype.getStack = function() {
            var a = this.options.layoutId;
            if (a)
              return this.root.sharedNodes.get(a);
          }, s.prototype.promote = function(a) {
            var l = a === void 0 ? {} : a, c = l.needsReset, u = l.transition, h = l.preserveFollowOpacity, p = this.getStack();
            p && p.promote(this, h), c && (this.projectionDelta = void 0, this.needsReset = true), u && this.setOptions({
              transition: u
            });
          }, s.prototype.relegate = function() {
            var a = this.getStack();
            return a ? a.relegate(this) : false;
          }, s.prototype.resetRotation = function() {
            var a = this.options.visualElement;
            if (!!a) {
              for (var l = false, c = {}, u = 0; u < py.length; u++) {
                var h = py[u], p = "rotate" + h;
                !a.getStaticValue(p) || (l = true, c[p] = a.getStaticValue(p), a.setStaticValue(p, 0));
              }
              if (!!l) {
                a == null ? void 0 : a.syncRender();
                for (var p in c)
                  a.setStaticValue(p, c[p]);
                a.scheduleRender();
              }
            }
          }, s.prototype.getProjectionStyles = function(a) {
            var l, c, u, h, p, v;
            a === void 0 && (a = {});
            var y = {};
            if (!this.instance || this.isSVG)
              return y;
            if (this.isVisible)
              y.visibility = "";
            else
              return {
                visibility: "hidden"
              };
            var S = (l = this.options.visualElement) === null || l === void 0 ? void 0 : l.getProps().transformTemplate;
            if (this.needsReset)
              return this.needsReset = false, y.opacity = "", y.pointerEvents = dd(a.pointerEvents) || "", y.transform = S ? S(this.latestValues, "") : "none", y;
            var C = this.getLead();
            if (!this.projectionDelta || !this.layout || !C.target) {
              var w = {};
              return this.options.layoutId && (w.opacity = (c = this.latestValues.opacity) !== null && c !== void 0 ? c : 1, w.pointerEvents = dd(a.pointerEvents) || ""), this.hasProjected && !vo(this.latestValues) && (w.transform = S ? S({}, "") : "none", this.hasProjected = false), w;
            }
            var k = C.animationValues || C.latestValues;
            this.applyTransformsToTarget(), y.transform = Kk(this.projectionDeltaWithTransform, this.treeScale, k), S && (y.transform = S(k, y.transform));
            var T = this.projectionDelta, P = T.x, R = T.y;
            y.transformOrigin = "".concat(P.origin * 100, "% ").concat(R.origin * 100, "% 0"), C.animationValues ? y.opacity = C === this ? (h = (u = k.opacity) !== null && u !== void 0 ? u : this.latestValues.opacity) !== null && h !== void 0 ? h : 1 : this.preserveOpacity ? this.latestValues.opacity : k.opacityExit : y.opacity = C === this ? (p = k.opacity) !== null && p !== void 0 ? p : "" : (v = k.opacityExit) !== null && v !== void 0 ? v : 0;
            for (var L in lp)
              if (k[L] !== void 0) {
                var D = lp[L], F = D.correct, K = D.applyTo, Y = F(k[L], C);
                if (K)
                  for (var te = K.length, ne = 0; ne < te; ne++)
                    y[K[ne]] = Y;
                else
                  y[L] = Y;
              }
            return this.options.layoutId && (y.pointerEvents = C === this ? dd(a.pointerEvents) || "" : "none"), y;
          }, s.prototype.clearSnapshot = function() {
            this.resumeFrom = this.snapshot = void 0;
          }, s.prototype.resetTree = function() {
            this.root.nodes.forEach(function(a) {
              var l;
              return (l = a.currentAnimation) === null || l === void 0 ? void 0 : l.stop();
            }), this.root.nodes.forEach(Gk), this.root.sharedNodes.clear();
          }, s;
        }();
      }
      function KH(t) {
        t.updateLayout();
      }
      function qH(t) {
        var e, n, r, i, o = (n = (e = t.resumeFrom) === null || e === void 0 ? void 0 : e.snapshot) !== null && n !== void 0 ? n : t.snapshot;
        if (t.isLead() && t.layout && o && t.hasListeners("didUpdate")) {
          var s = t.layout, a = s.actual, l = s.measured;
          t.options.animationType === "size" ? si(function(k) {
            var T = o.isShared ? o.measured[k] : o.layout[k], P = to(T);
            T.min = a[k].min, T.max = T.min + P;
          }) : t.options.animationType === "position" && si(function(k) {
            var T = o.isShared ? o.measured[k] : o.layout[k], P = to(a[k]);
            T.max = T.min + P;
          });
          var c = Kc();
          Wc(c, a, o.layout);
          var u = Kc();
          o.isShared ? Wc(u, t.applyTransform(l, true), o.measured) : Wc(u, a, o.layout);
          var h = !IP(c), p = false;
          if (!t.resumeFrom && (t.relativeParent = t.getClosestProjectingParent(), t.relativeParent && !t.relativeParent.resumeFrom)) {
            var v = t.relativeParent, y = v.snapshot, S = v.layout;
            if (y && S) {
              var C = cn();
              Uc(C, o.layout, y.layout);
              var w = cn();
              Uc(w, a, S.actual), BP(C, w) || (p = true);
            }
          }
          t.notifyListeners("didUpdate", {
            layout: a,
            snapshot: o,
            delta: u,
            layoutDelta: c,
            hasLayoutChanged: h,
            hasRelativeTargetChanged: p
          });
        } else
          t.isLead() && ((i = (r = t.options).onExitComplete) === null || i === void 0 || i.call(r));
        t.options.transition = void 0;
      }
      function GH(t) {
        t.clearSnapshot();
      }
      function Gk(t) {
        t.clearMeasurements();
      }
      function YH(t) {
        var e = t.options.visualElement;
        (e == null ? void 0 : e.getProps().onBeforeLayoutMeasure) && e.notifyBeforeLayoutMeasure(), t.resetTransform();
      }
      function XH(t) {
        t.finishAnimation(), t.targetDelta = t.relativeTarget = t.target = void 0;
      }
      function QH(t) {
        t.resolveTargetDelta();
      }
      function JH(t) {
        t.calcProjection();
      }
      function ZH(t) {
        t.resetRotation();
      }
      function ej(t) {
        t.removeLeadSnapshot();
      }
      function Yk(t, e, n) {
        t.translate = wt(e.translate, 0, n), t.scale = wt(e.scale, 1, n), t.origin = e.origin, t.originPoint = e.originPoint;
      }
      function Xk(t, e, n, r) {
        t.min = wt(e.min, n.min, r), t.max = wt(e.max, n.max, r);
      }
      function tj(t, e, n, r) {
        Xk(t.x, e.x, n.x, r), Xk(t.y, e.y, n.y, r);
      }
      function nj(t) {
        return t.animationValues && t.animationValues.opacityExit !== void 0;
      }
      var rj = {
        duration: 0.45,
        ease: [
          0.4,
          0,
          0.1,
          1
        ]
      };
      function ij(t, e) {
        for (var n = t.root, r = t.path.length - 1; r >= 0; r--)
          if (Boolean(t.path[r].instance)) {
            n = t.path[r];
            break;
          }
        var i = n && n !== t.root ? n.instance : document, o = i.querySelector('[data-projection-id="'.concat(e, '"]'));
        o && t.mount(o, true);
      }
      function Qk(t) {
        t.min = Math.round(t.min), t.max = Math.round(t.max);
      }
      function Jk(t) {
        Qk(t.x), Qk(t.y);
      }
      var oj = NP({
        attachResizeListener: function(t, e) {
          return Lm(t, "resize", e);
        },
        measureScroll: function() {
          return {
            x: document.documentElement.scrollLeft || document.body.scrollLeft,
            y: document.documentElement.scrollTop || document.body.scrollTop
          };
        },
        checkIsScrollRoot: function() {
          return true;
        }
      }), T0 = {
        current: void 0
      }, sj = NP({
        measureScroll: function(t) {
          return {
            x: t.scrollLeft,
            y: t.scrollTop
          };
        },
        defaultParent: function() {
          if (!T0.current) {
            var t = new oj(0, {});
            t.mount(window), t.setOptions({
              layoutScroll: true
            }), T0.current = t;
          }
          return T0.current;
        },
        resetTransform: function(t, e) {
          t.style.transform = e ?? "none";
        },
        checkIsScrollRoot: function(t) {
          return Boolean(window.getComputedStyle(t).position === "fixed");
        }
      }), aj = ie(ie(ie(ie({}, j9), i9), uH), DH), lj = XV(function(t, e) {
        return B6(t, e, aj, EH, sj);
      });
      function $P() {
        var t = z.exports.useRef(false);
        return ap(function() {
          return t.current = true, function() {
            t.current = false;
          };
        }, []), t;
      }
      function cj() {
        var t = $P(), e = kt(z.exports.useState(0), 2), n = e[0], r = e[1], i = z.exports.useCallback(function() {
          t.current && r(n + 1);
        }, [
          n
        ]), o = z.exports.useCallback(function() {
          return jr.postRender(i);
        }, [
          i
        ]);
        return [
          o,
          n
        ];
      }
      var M0 = function(t) {
        var e = t.children, n = t.initial, r = t.isPresent, i = t.onExitComplete, o = t.custom, s = t.presenceAffectsLayout, a = Qu(uj), l = mP(), c = z.exports.useMemo(function() {
          return {
            id: l,
            initial: n,
            isPresent: r,
            custom: o,
            onExitComplete: function(u) {
              var h, p;
              a.set(u, true);
              try {
                for (var v = EV(a.values()), y = v.next(); !y.done; y = v.next()) {
                  var S = y.value;
                  if (!S)
                    return;
                }
              } catch (C) {
                h = {
                  error: C
                };
              } finally {
                try {
                  y && !y.done && (p = v.return) && p.call(v);
                } finally {
                  if (h)
                    throw h.error;
                }
              }
              i == null ? void 0 : i();
            },
            register: function(u) {
              return a.set(u, false), function() {
                return a.delete(u);
              };
            }
          };
        }, s ? void 0 : [
          r
        ]);
        return z.exports.useMemo(function() {
          a.forEach(function(u, h) {
            return a.set(h, false);
          });
        }, [
          r
        ]), z.exports.useEffect(function() {
          !r && !a.size && (i == null ? void 0 : i());
        }, [
          r
        ]), Z(Tl.Provider, {
          value: c,
          children: e
        });
      };
      function uj() {
        return /* @__PURE__ */ new Map();
      }
      var ca = function(t) {
        return t.key || "";
      };
      function fj(t, e) {
        t.forEach(function(n) {
          var r = ca(n);
          e.set(r, n);
        });
      }
      function hj(t) {
        var e = [];
        return z.exports.Children.forEach(t, function(n) {
          z.exports.isValidElement(n) && e.push(n);
        }), e;
      }
      var dj = function(t) {
        var e = t.children, n = t.custom, r = t.initial, i = r === void 0 ? true : r, o = t.onExitComplete, s = t.exitBeforeEnter, a = t.presenceAffectsLayout, l = a === void 0 ? true : a, c = kt(cj(), 1), u = c[0], h = z.exports.useContext(Gb).forceRender;
        h && (u = h);
        var p = $P(), v = hj(e), y = v, S = /* @__PURE__ */ new Set(), C = z.exports.useRef(y), w = z.exports.useRef(/* @__PURE__ */ new Map()).current, k = z.exports.useRef(true);
        if (ap(function() {
          k.current = false, fj(v, w), C.current = y;
        }), rx(function() {
          k.current = true, w.clear(), S.clear();
        }), k.current)
          return Z(ip, {
            children: y.map(function(F) {
              return Z(M0, {
                isPresent: true,
                initial: i ? void 0 : false,
                presenceAffectsLayout: l,
                children: F
              }, ca(F));
            })
          });
        y = Hr([], kt(y), false);
        for (var T = C.current.map(ca), P = v.map(ca), R = T.length, L = 0; L < R; L++) {
          var D = T[L];
          P.indexOf(D) === -1 && S.add(D);
        }
        return s && S.size && (y = []), S.forEach(function(F) {
          if (P.indexOf(F) === -1) {
            var K = w.get(F);
            if (!!K) {
              var Y = T.indexOf(F), te = function() {
                w.delete(F), S.delete(F);
                var ne = C.current.findIndex(function(ue) {
                  return ue.key === F;
                });
                if (C.current.splice(ne, 1), !S.size) {
                  if (C.current = v, p.current === false)
                    return;
                  u(), o && o();
                }
              };
              y.splice(Y, 0, Z(M0, {
                isPresent: false,
                onExitComplete: te,
                custom: n,
                presenceAffectsLayout: l,
                children: K
              }, ca(K)));
            }
          }
        }), y = y.map(function(F) {
          var K = F.key;
          return S.has(K) ? F : Z(M0, {
            isPresent: true,
            presenceAffectsLayout: l,
            children: F
          }, ca(F));
        }), Kb !== "production" && s && y.length > 1 && console.warn("You're attempting to animate multiple children within AnimatePresence, but its exitBeforeEnter prop is set to true. This will lead to odd visual behaviour."), Z(ip, {
          children: S.size ? y : y.map(function(F) {
            return z.exports.cloneElement(F);
          })
        });
      };
      const pj = (t, e) => t.find((n) => n.id === e);
      function Zk(t, e) {
        const n = zP(t, e), r = n ? t[n].findIndex((i) => i.id === e) : -1;
        return {
          position: n,
          index: r
        };
      }
      function zP(t, e) {
        for (const [n, r] of Object.entries(t))
          if (pj(r, e))
            return n;
      }
      function mj(t) {
        const e = t.includes("right"), n = t.includes("left");
        let r = "center";
        return e && (r = "flex-end"), n && (r = "flex-start"), {
          display: "flex",
          flexDirection: "column",
          alignItems: r
        };
      }
      function gj(t) {
        const n = t === "top" || t === "bottom" ? "0 auto" : void 0, r = t.includes("top") ? "env(safe-area-inset-top, 0px)" : void 0, i = t.includes("bottom") ? "env(safe-area-inset-bottom, 0px)" : void 0, o = t.includes("left") ? void 0 : "env(safe-area-inset-right, 0px)", s = t.includes("right") ? void 0 : "env(safe-area-inset-left, 0px)";
        return {
          position: "fixed",
          zIndex: "var(--toast-z-index, 5500)",
          pointerEvents: "none",
          display: "flex",
          flexDirection: "column",
          margin: n,
          top: r,
          bottom: i,
          right: o,
          left: s
        };
      }
      var vj = /^((children|dangerouslySetInnerHTML|key|ref|autoFocus|defaultValue|defaultChecked|innerHTML|suppressContentEditableWarning|suppressHydrationWarning|valueLink|abbr|accept|acceptCharset|accessKey|action|allow|allowUserMedia|allowPaymentRequest|allowFullScreen|allowTransparency|alt|async|autoComplete|autoPlay|capture|cellPadding|cellSpacing|challenge|charSet|checked|cite|classID|className|cols|colSpan|content|contentEditable|contextMenu|controls|controlsList|coords|crossOrigin|data|dateTime|decoding|default|defer|dir|disabled|disablePictureInPicture|disableRemotePlayback|download|draggable|encType|enterKeyHint|fetchpriority|fetchPriority|form|formAction|formEncType|formMethod|formNoValidate|formTarget|frameBorder|headers|height|hidden|high|href|hrefLang|htmlFor|httpEquiv|id|inputMode|integrity|is|keyParams|keyType|kind|label|lang|list|loading|loop|low|marginHeight|marginWidth|max|maxLength|media|mediaGroup|method|min|minLength|multiple|muted|name|nonce|noValidate|open|optimum|pattern|placeholder|playsInline|poster|preload|profile|radioGroup|readOnly|referrerPolicy|rel|required|reversed|role|rows|rowSpan|sandbox|scope|scoped|scrolling|seamless|selected|shape|size|sizes|slot|span|spellCheck|src|srcDoc|srcLang|srcSet|start|step|style|summary|tabIndex|target|title|translate|type|useMap|value|width|wmode|wrap|about|datatype|inlist|prefix|property|resource|typeof|vocab|autoCapitalize|autoCorrect|autoSave|color|incremental|fallback|inert|itemProp|itemScope|itemType|itemID|itemRef|on|option|results|security|unselectable|accentHeight|accumulate|additive|alignmentBaseline|allowReorder|alphabetic|amplitude|arabicForm|ascent|attributeName|attributeType|autoReverse|azimuth|baseFrequency|baselineShift|baseProfile|bbox|begin|bias|by|calcMode|capHeight|clip|clipPathUnits|clipPath|clipRule|colorInterpolation|colorInterpolationFilters|colorProfile|colorRendering|contentScriptType|contentStyleType|cursor|cx|cy|d|decelerate|descent|diffuseConstant|direction|display|divisor|dominantBaseline|dur|dx|dy|edgeMode|elevation|enableBackground|end|exponent|externalResourcesRequired|fill|fillOpacity|fillRule|filter|filterRes|filterUnits|floodColor|floodOpacity|focusable|fontFamily|fontSize|fontSizeAdjust|fontStretch|fontStyle|fontVariant|fontWeight|format|from|fr|fx|fy|g1|g2|glyphName|glyphOrientationHorizontal|glyphOrientationVertical|glyphRef|gradientTransform|gradientUnits|hanging|horizAdvX|horizOriginX|ideographic|imageRendering|in|in2|intercept|k|k1|k2|k3|k4|kernelMatrix|kernelUnitLength|kerning|keyPoints|keySplines|keyTimes|lengthAdjust|letterSpacing|lightingColor|limitingConeAngle|local|markerEnd|markerMid|markerStart|markerHeight|markerUnits|markerWidth|mask|maskContentUnits|maskUnits|mathematical|mode|numOctaves|offset|opacity|operator|order|orient|orientation|origin|overflow|overlinePosition|overlineThickness|panose1|paintOrder|pathLength|patternContentUnits|patternTransform|patternUnits|pointerEvents|points|pointsAtX|pointsAtY|pointsAtZ|preserveAlpha|preserveAspectRatio|primitiveUnits|r|radius|refX|refY|renderingIntent|repeatCount|repeatDur|requiredExtensions|requiredFeatures|restart|result|rotate|rx|ry|scale|seed|shapeRendering|slope|spacing|specularConstant|specularExponent|speed|spreadMethod|startOffset|stdDeviation|stemh|stemv|stitchTiles|stopColor|stopOpacity|strikethroughPosition|strikethroughThickness|string|stroke|strokeDasharray|strokeDashoffset|strokeLinecap|strokeLinejoin|strokeMiterlimit|strokeOpacity|strokeWidth|surfaceScale|systemLanguage|tableValues|targetX|targetY|textAnchor|textDecoration|textRendering|textLength|to|transform|u1|u2|underlinePosition|underlineThickness|unicode|unicodeBidi|unicodeRange|unitsPerEm|vAlphabetic|vHanging|vIdeographic|vMathematical|values|vectorEffect|version|vertAdvY|vertOriginX|vertOriginY|viewBox|viewTarget|visibility|widths|wordSpacing|writingMode|x|xHeight|x1|x2|xChannelSelector|xlinkActuate|xlinkArcrole|xlinkHref|xlinkRole|xlinkShow|xlinkTitle|xlinkType|xmlBase|xmlns|xmlnsXlink|xmlLang|xmlSpace|y|y1|y2|yChannelSelector|z|zoomAndPan|for|class|autofocus)|(([Dd][Aa][Tt][Aa]|[Aa][Rr][Ii][Aa]|x)-.*))$/, yj = XA(function(t) {
        return vj.test(t) || t.charCodeAt(0) === 111 && t.charCodeAt(1) === 110 && t.charCodeAt(2) < 91;
      }), bj = false, xj = yj, Sj = function(e) {
        return e !== "theme";
      }, eC = function(e) {
        return typeof e == "string" && e.charCodeAt(0) > 96 ? xj : Sj;
      }, tC = function(e, n, r) {
        var i;
        if (n) {
          var o = n.shouldForwardProp;
          i = e.__emotion_forwardProp && o ? function(s) {
            return e.__emotion_forwardProp(s) && o(s);
          } : o;
        }
        return typeof i != "function" && r && (i = e.__emotion_forwardProp), i;
      }, wj = function(e) {
        var n = e.cache, r = e.serialized, i = e.isStringTag;
        return zb(n, r, i), oE(function() {
          return Fb(n, r, i);
        }), null;
      }, kj = function t(e, n) {
        var r = e.__emotion_real === e, i = r && e.__emotion_base || e, o, s;
        n !== void 0 && (o = n.label, s = n.target);
        var a = tC(e, n, r), l = a || eC(i), c = !l("as");
        return function() {
          var u = arguments, h = r && e.__emotion_styles !== void 0 ? e.__emotion_styles.slice(0) : [];
          if (o !== void 0 && h.push("label:" + o + ";"), u[0] == null || u[0].raw === void 0)
            h.push.apply(h, u);
          else {
            var p = u[0];
            h.push(p[0]);
            for (var v = u.length, y = 1; y < v; y++)
              h.push(u[y], p[y]);
          }
          var S = Hb(function(C, w, k) {
            var T = c && C.as || i, P = "", R = [], L = C;
            if (C.theme == null) {
              L = {};
              for (var D in C)
                L[D] = C[D];
              L.theme = z.exports.useContext(ll);
            }
            typeof C.className == "string" ? P = nE(w.registered, R, C.className) : C.className != null && (P = C.className + " ");
            var F = Am(h.concat(R), w.registered, L);
            P += w.key + "-" + F.name, s !== void 0 && (P += " " + s);
            var K = c && a === void 0 ? eC(T) : l, Y = {};
            for (var te in C)
              c && te === "as" || K(te) && (Y[te] = C[te]);
            return Y.className = P, k && (Y.ref = k), Xn(ip, {
              children: [
                Z(wj, {
                  cache: w,
                  serialized: F,
                  isStringTag: typeof T == "string"
                }),
                Z(T, {
                  ...Y
                })
              ]
            });
          });
          return S.displayName = o !== void 0 ? o : "Styled(" + (typeof i == "string" ? i : i.displayName || i.name || "Component") + ")", S.defaultProps = e.defaultProps, S.__emotion_real = S, S.__emotion_base = i, S.__emotion_styles = h, S.__emotion_forwardProp = a, Object.defineProperty(S, "toString", {
            value: function() {
              return s === void 0 && bj ? "NO_COMPONENT_SELECTOR" : "." + s;
            }
          }), S.withComponent = function(C, w) {
            var k = t(C, ku({}, n, w, {
              shouldForwardProp: tC(S, w, true)
            }));
            return k.apply(void 0, h);
          }, S;
        };
      }, Cj = [
        "a",
        "abbr",
        "address",
        "area",
        "article",
        "aside",
        "audio",
        "b",
        "base",
        "bdi",
        "bdo",
        "big",
        "blockquote",
        "body",
        "br",
        "button",
        "canvas",
        "caption",
        "cite",
        "code",
        "col",
        "colgroup",
        "data",
        "datalist",
        "dd",
        "del",
        "details",
        "dfn",
        "dialog",
        "div",
        "dl",
        "dt",
        "em",
        "embed",
        "fieldset",
        "figcaption",
        "figure",
        "footer",
        "form",
        "h1",
        "h2",
        "h3",
        "h4",
        "h5",
        "h6",
        "head",
        "header",
        "hgroup",
        "hr",
        "html",
        "i",
        "iframe",
        "img",
        "input",
        "ins",
        "kbd",
        "keygen",
        "label",
        "legend",
        "li",
        "link",
        "main",
        "map",
        "mark",
        "marquee",
        "menu",
        "menuitem",
        "meta",
        "meter",
        "nav",
        "noscript",
        "object",
        "ol",
        "optgroup",
        "option",
        "output",
        "p",
        "param",
        "picture",
        "pre",
        "progress",
        "q",
        "rp",
        "rt",
        "ruby",
        "s",
        "samp",
        "script",
        "section",
        "select",
        "small",
        "source",
        "span",
        "strong",
        "style",
        "sub",
        "summary",
        "sup",
        "table",
        "tbody",
        "td",
        "textarea",
        "tfoot",
        "th",
        "thead",
        "time",
        "title",
        "tr",
        "track",
        "u",
        "ul",
        "var",
        "video",
        "wbr",
        "circle",
        "clipPath",
        "defs",
        "ellipse",
        "foreignObject",
        "g",
        "image",
        "line",
        "linearGradient",
        "mask",
        "path",
        "pattern",
        "polygon",
        "polyline",
        "radialGradient",
        "rect",
        "stop",
        "svg",
        "text",
        "tspan"
      ], Oy = kj.bind(null);
      Cj.forEach(function(t) {
        Oy[t] = Oy(t);
      });
      const Tj = /* @__PURE__ */ new Set([
        ...MB,
        "textStyle",
        "layerStyle",
        "apply",
        "noOfLines",
        "focusBorderColor",
        "errorBorderColor",
        "as",
        "__css",
        "css",
        "sx"
      ]), Mj = /* @__PURE__ */ new Set([
        "htmlWidth",
        "htmlHeight",
        "htmlSize",
        "htmlTranslate"
      ]);
      function Aj(t) {
        return (Mj.has(t) || !Tj.has(t)) && t[0] !== "_";
      }
      const Ej = FI(Oy), Pj = ({ baseStyle: t }) => (e) => {
        const { theme: n, css: r, __css: i, sx: o, ...s } = e, [a] = WI(s, EB), l = mi(t, e), c = PI({}, i, l, gA(a), o), u = kA(c)(e.theme);
        return r ? [
          u,
          r
        ] : u;
      };
      function A0(t, e) {
        const { baseStyle: n, ...r } = e ?? {};
        r.shouldForwardProp || (r.shouldForwardProp = Aj);
        const i = Pj({
          baseStyle: n
        }), o = Ej(t, r)(i);
        return z.exports.forwardRef(function(l, c) {
          const { children: u, ...h } = l, { colorMode: p, forced: v } = Ub(), y = v ? p : void 0;
          return z.exports.createElement(o, {
            ref: c,
            "data-theme": y,
            ...h
          }, u);
        });
      }
      function Oj() {
        const t = /* @__PURE__ */ new Map();
        return new Proxy(A0, {
          apply(e, n, r) {
            return A0(...r);
          },
          get(e, n) {
            return t.has(n) || t.set(n, A0(n)), t.get(n);
          }
        });
      }
      const rn = Oj(), Rj = {
        initial: (t) => {
          const { position: e } = t, n = [
            "top",
            "bottom"
          ].includes(e) ? "y" : "x";
          let r = [
            "top-right",
            "bottom-right"
          ].includes(e) ? 1 : -1;
          return e === "bottom" && (r = 1), {
            opacity: 0,
            [n]: r * 24
          };
        },
        animate: {
          opacity: 1,
          y: 0,
          x: 0,
          scale: 1,
          transition: {
            duration: 0.4,
            ease: [
              0.4,
              0,
              0.2,
              1
            ]
          }
        },
        exit: {
          opacity: 0,
          scale: 0.85,
          transition: {
            duration: 0.2,
            ease: [
              0.4,
              0,
              1,
              1
            ]
          }
        }
      }, FP = z.exports.memo((t) => {
        const { id: e, message: n, onCloseComplete: r, onRequestRemove: i, requestClose: o = false, position: s = "bottom", duration: a = 5e3, containerStyle: l, motionVariants: c = Rj, toastSpacing: u = "0.5rem" } = t, [h, p] = z.exports.useState(a), v = a9();
        Sw(() => {
          v || (r == null ? void 0 : r());
        }, [
          v
        ]), Sw(() => {
          p(a);
        }, [
          a
        ]);
        const y = () => p(null), S = () => p(a), C = () => {
          v && i();
        };
        z.exports.useEffect(() => {
          v && o && i();
        }, [
          v,
          o,
          i
        ]), qI(C, h);
        const w = z.exports.useMemo(() => ({
          pointerEvents: "auto",
          maxWidth: 560,
          minWidth: 300,
          margin: u,
          ...l
        }), [
          l,
          u
        ]), k = z.exports.useMemo(() => mj(s), [
          s
        ]);
        return Z(lj.div, {
          layout: true,
          className: "chakra-toast",
          variants: c,
          initial: "initial",
          animate: "animate",
          exit: "exit",
          onHoverStart: y,
          onHoverEnd: S,
          custom: {
            position: s
          },
          style: k,
          children: Z(rn.div, {
            role: "status",
            "aria-atomic": "true",
            className: "chakra-toast__inner",
            __css: w,
            children: mi(n, {
              id: e,
              onClose: C
            })
          })
        });
      });
      FP.displayName = "ToastComponent";
      function Mr(t) {
        return z.exports.forwardRef(t);
      }
      var Lj = typeof Element < "u", Dj = typeof Map == "function", _j = typeof Set == "function", Ij = typeof ArrayBuffer == "function" && !!ArrayBuffer.isView;
      function gd(t, e) {
        if (t === e)
          return true;
        if (t && e && typeof t == "object" && typeof e == "object") {
          if (t.constructor !== e.constructor)
            return false;
          var n, r, i;
          if (Array.isArray(t)) {
            if (n = t.length, n != e.length)
              return false;
            for (r = n; r-- !== 0; )
              if (!gd(t[r], e[r]))
                return false;
            return true;
          }
          var o;
          if (Dj && t instanceof Map && e instanceof Map) {
            if (t.size !== e.size)
              return false;
            for (o = t.entries(); !(r = o.next()).done; )
              if (!e.has(r.value[0]))
                return false;
            for (o = t.entries(); !(r = o.next()).done; )
              if (!gd(r.value[1], e.get(r.value[0])))
                return false;
            return true;
          }
          if (_j && t instanceof Set && e instanceof Set) {
            if (t.size !== e.size)
              return false;
            for (o = t.entries(); !(r = o.next()).done; )
              if (!e.has(r.value[0]))
                return false;
            return true;
          }
          if (Ij && ArrayBuffer.isView(t) && ArrayBuffer.isView(e)) {
            if (n = t.length, n != e.length)
              return false;
            for (r = n; r-- !== 0; )
              if (t[r] !== e[r])
                return false;
            return true;
          }
          if (t.constructor === RegExp)
            return t.source === e.source && t.flags === e.flags;
          if (t.valueOf !== Object.prototype.valueOf && typeof t.valueOf == "function" && typeof e.valueOf == "function")
            return t.valueOf() === e.valueOf();
          if (t.toString !== Object.prototype.toString && typeof t.toString == "function" && typeof e.toString == "function")
            return t.toString() === e.toString();
          if (i = Object.keys(t), n = i.length, n !== Object.keys(e).length)
            return false;
          for (r = n; r-- !== 0; )
            if (!Object.prototype.hasOwnProperty.call(e, i[r]))
              return false;
          if (Lj && t instanceof Element)
            return false;
          for (r = n; r-- !== 0; )
            if (!((i[r] === "_owner" || i[r] === "__v" || i[r] === "__o") && t.$$typeof) && !gd(t[i[r]], e[i[r]]))
              return false;
          return true;
        }
        return t !== t && e !== e;
      }
      var Bj = function(e, n) {
        try {
          return gd(e, n);
        } catch (r) {
          if ((r.message || "").match(/stack|recursion/i))
            return console.warn("react-fast-compare cannot handle circular refs"), false;
          throw r;
        }
      };
      function Nj() {
        const t = z.exports.useContext(ll);
        if (!t)
          throw Error("useTheme: `theme` is undefined. Seems you forgot to wrap your app in `<ChakraProvider />` or `<ThemeProvider />`");
        return t;
      }
      function $j() {
        const t = Ub(), e = Nj();
        return {
          ...t,
          theme: e
        };
      }
      function VP(t, e = {}) {
        const { styleConfig: n, ...r } = e, { theme: i, colorMode: o } = $j(), s = t ? vA(i, `components.${t}`) : void 0, a = n || s, l = gi({
          theme: i,
          colorMode: o
        }, (a == null ? void 0 : a.defaultProps) ?? {}, gA(yA(r, [
          "children"
        ])), (u, h) => u ? void 0 : h), c = z.exports.useRef({});
        if (a) {
          const h = $B(a)(l);
          Bj(c.current, h) || (c.current = h);
        }
        return c.current;
      }
      function vx(t, e = {}) {
        return VP(t, e);
      }
      function HP(t, e = {}) {
        return VP(t, e);
      }
      const nC = {
        path: Xn("g", {
          stroke: "currentColor",
          strokeWidth: "1.5",
          children: [
            Z("path", {
              strokeLinecap: "round",
              fill: "none",
              d: "M9,9a3,3,0,1,1,4,2.829,1.5,1.5,0,0,0-1,1.415V14.25"
            }),
            Z("path", {
              fill: "currentColor",
              strokeLinecap: "round",
              d: "M12,17.25a.375.375,0,1,0,.375.375A.375.375,0,0,0,12,17.25h0"
            }),
            Z("circle", {
              fill: "none",
              strokeMiterlimit: "10",
              cx: "12",
              cy: "12",
              r: "11.25"
            })
          ]
        }),
        viewBox: "0 0 24 24"
      }, nf = Mr((t, e) => {
        const { as: n, viewBox: r, color: i = "currentColor", focusable: o = false, children: s, className: a, __css: l, ...c } = t, u = qr("chakra-icon", a), h = vx("Icon", t), p = {
          w: "1em",
          h: "1em",
          display: "inline-block",
          lineHeight: "1em",
          flexShrink: 0,
          color: i,
          ...l,
          ...h
        }, v = {
          ref: e,
          focusable: o,
          className: u,
          __css: p
        }, y = r ?? nC.viewBox;
        if (n && typeof n != "string")
          return Z(rn.svg, {
            as: n,
            ...v,
            ...c
          });
        const S = s ?? nC.path;
        return Z(rn.svg, {
          verticalAlign: "middle",
          viewBox: y,
          ...v,
          ...c,
          children: S
        });
      });
      nf.displayName = "Icon";
      function zj(t) {
        return Z(nf, {
          viewBox: "0 0 24 24",
          ...t,
          children: Z("path", {
            fill: "currentColor",
            d: "M12,0A12,12,0,1,0,24,12,12.014,12.014,0,0,0,12,0Zm6.927,8.2-6.845,9.289a1.011,1.011,0,0,1-1.43.188L5.764,13.769a1,1,0,1,1,1.25-1.562l4.076,3.261,6.227-8.451A1,1,0,1,1,18.927,8.2Z"
          })
        });
      }
      function Fj(t) {
        return Z(nf, {
          viewBox: "0 0 24 24",
          ...t,
          children: Z("path", {
            fill: "currentColor",
            d: "M12,0A12,12,0,1,0,24,12,12.013,12.013,0,0,0,12,0Zm.25,5a1.5,1.5,0,1,1-1.5,1.5A1.5,1.5,0,0,1,12.25,5ZM14.5,18.5h-4a1,1,0,0,1,0-2h.75a.25.25,0,0,0,.25-.25v-4.5a.25.25,0,0,0-.25-.25H10.5a1,1,0,0,1,0-2h1a2,2,0,0,1,2,2v4.75a.25.25,0,0,0,.25.25h.75a1,1,0,1,1,0,2Z"
          })
        });
      }
      function rC(t) {
        return Z(nf, {
          viewBox: "0 0 24 24",
          ...t,
          children: Z("path", {
            fill: "currentColor",
            d: "M11.983,0a12.206,12.206,0,0,0-8.51,3.653A11.8,11.8,0,0,0,0,12.207,11.779,11.779,0,0,0,11.8,24h.214A12.111,12.111,0,0,0,24,11.791h0A11.766,11.766,0,0,0,11.983,0ZM10.5,16.542a1.476,1.476,0,0,1,1.449-1.53h.027a1.527,1.527,0,0,1,1.523,1.47,1.475,1.475,0,0,1-1.449,1.53h-.027A1.529,1.529,0,0,1,10.5,16.542ZM11,12.5v-6a1,1,0,0,1,2,0v6a1,1,0,1,1-2,0Z"
          })
        });
      }
      const Vj = pV({
        "0%": {
          transform: "rotate(0deg)"
        },
        "100%": {
          transform: "rotate(360deg)"
        }
      }), jP = Mr((t, e) => {
        const n = vx("Spinner", t), { label: r = "Loading...", thickness: i = "2px", speed: o = "0.45s", emptyColor: s = "transparent", className: a, ...l } = lm(t), c = qr("chakra-spinner", a), u = {
          display: "inline-block",
          borderColor: "currentColor",
          borderStyle: "solid",
          borderRadius: "99999px",
          borderWidth: i,
          borderBottomColor: s,
          borderLeftColor: s,
          animation: `${Vj} ${o} linear infinite`,
          ...n
        };
        return Z(rn.div, {
          ref: e,
          __css: u,
          className: c,
          ...l,
          children: r && Z(rn.span, {
            srOnly: true,
            children: r
          })
        });
      });
      jP.displayName = "Spinner";
      const [Hj, yx] = Mi({
        name: "AlertContext",
        hookName: "useAlertContext",
        providerName: "<Alert />"
      }), [jj, bx] = Mi({
        name: "AlertStylesContext",
        hookName: "useAlertStyles",
        providerName: "<Alert />"
      }), WP = {
        info: {
          icon: Fj,
          colorScheme: "blue"
        },
        warning: {
          icon: rC,
          colorScheme: "orange"
        },
        success: {
          icon: zj,
          colorScheme: "green"
        },
        error: {
          icon: rC,
          colorScheme: "red"
        },
        loading: {
          icon: jP,
          colorScheme: "blue"
        }
      };
      function Wj(t) {
        return WP[t].colorScheme;
      }
      function Uj(t) {
        return WP[t].icon;
      }
      const UP = Mr(function(e, n) {
        const { status: r = "info", addRole: i = true, ...o } = lm(e), s = e.colorScheme ?? Wj(r), a = HP("Alert", {
          ...e,
          colorScheme: s
        }), l = {
          width: "100%",
          display: "flex",
          alignItems: "center",
          position: "relative",
          overflow: "hidden",
          ...a.container
        };
        return Z(Hj, {
          value: {
            status: r
          },
          children: Z(jj, {
            value: a,
            children: Z(rn.div, {
              "data-status": r,
              role: i ? "alert" : void 0,
              ref: n,
              ...o,
              className: qr("chakra-alert", e.className),
              __css: l
            })
          })
        });
      });
      UP.displayName = "Alert";
      function KP(t) {
        const { status: e } = yx(), n = Uj(e), r = bx(), i = e === "loading" ? r.spinner : r.icon;
        return Z(rn.span, {
          display: "inherit",
          "data-status": e,
          ...t,
          className: qr("chakra-alert__icon", t.className),
          __css: i,
          children: t.children || Z(n, {
            h: "100%",
            w: "100%"
          })
        });
      }
      KP.displayName = "AlertIcon";
      const qP = Mr(function(e, n) {
        const r = bx(), { status: i } = yx();
        return Z(rn.div, {
          ref: n,
          "data-status": i,
          ...e,
          className: qr("chakra-alert__title", e.className),
          __css: r.title
        });
      });
      qP.displayName = "AlertTitle";
      const GP = Mr(function(e, n) {
        const { status: r } = yx(), i = bx(), o = {
          display: "inline",
          ...i.description
        };
        return Z(rn.div, {
          ref: n,
          "data-status": r,
          ...e,
          className: qr("chakra-alert__desc", e.className),
          __css: o
        });
      });
      GP.displayName = "AlertDescription";
      function Kj(t) {
        return Z(nf, {
          focusable: "false",
          "aria-hidden": true,
          ...t,
          children: Z("path", {
            fill: "currentColor",
            d: "M.439,21.44a1.5,1.5,0,0,0,2.122,2.121L11.823,14.3a.25.25,0,0,1,.354,0l9.262,9.263a1.5,1.5,0,1,0,2.122-2.121L14.3,12.177a.25.25,0,0,1,0-.354l9.263-9.262A1.5,1.5,0,0,0,21.439.44L12.177,9.7a.25.25,0,0,1-.354,0L2.561.44A1.5,1.5,0,0,0,.439,2.561L9.7,11.823a.25.25,0,0,1,0,.354Z"
          })
        });
      }
      const YP = Mr(function(e, n) {
        const r = vx("CloseButton", e), { children: i, isDisabled: o, __css: s, ...a } = lm(e), l = {
          outline: 0,
          display: "flex",
          alignItems: "center",
          justifyContent: "center",
          flexShrink: 0
        };
        return Z(rn.button, {
          type: "button",
          "aria-label": "Close",
          ref: n,
          disabled: o,
          __css: {
            ...l,
            ...r,
            ...s
          },
          ...a,
          children: i || Z(Kj, {
            width: "1em",
            height: "1em"
          })
        });
      });
      YP.displayName = "CloseButton";
      const qj = (t) => {
        const { status: e, variant: n = "solid", id: r, title: i, isClosable: o, onClose: s, description: a, colorScheme: l, icon: c } = t, u = r ? {
          root: `toast-${r}`,
          title: `toast-${r}-title`,
          description: `toast-${r}-description`
        } : void 0;
        return Xn(UP, {
          addRole: false,
          status: e,
          variant: n,
          id: u == null ? void 0 : u.root,
          alignItems: "start",
          borderRadius: "md",
          boxShadow: "lg",
          paddingEnd: 8,
          textAlign: "start",
          width: "auto",
          colorScheme: l,
          children: [
            Z(KP, {
              children: c
            }),
            Xn(rn.div, {
              flex: "1",
              maxWidth: "100%",
              children: [
                i && Z(qP, {
                  id: u == null ? void 0 : u.title,
                  children: i
                }),
                a && Z(GP, {
                  id: u == null ? void 0 : u.description,
                  display: "block",
                  children: a
                })
              ]
            }),
            o && Z(YP, {
              size: "sm",
              onClick: s,
              position: "absolute",
              insetEnd: 1,
              top: 1
            })
          ]
        });
      };
      function Gj(t = {}) {
        const { render: e, toastComponent: n = qj } = t;
        return (i) => typeof e == "function" ? e({
          ...i,
          ...t
        }) : Z(n, {
          ...i,
          ...t
        });
      }
      const Yj = {
        top: [],
        "top-left": [],
        "top-right": [],
        "bottom-left": [],
        bottom: [],
        "bottom-right": []
      }, qc = Xj(Yj);
      function Xj(t) {
        let e = t;
        const n = /* @__PURE__ */ new Set(), r = (i) => {
          e = i(e), n.forEach((o) => o());
        };
        return {
          getState: () => e,
          subscribe: (i) => (n.add(i), () => {
            r(() => t), n.delete(i);
          }),
          removeToast: (i, o) => {
            r((s) => ({
              ...s,
              [o]: s[o].filter((a) => a.id != i)
            }));
          },
          notify: (i, o) => {
            const s = Qj(i, o), { position: a, id: l } = s;
            return r((c) => {
              const h = a.includes("top") ? [
                s,
                ...c[a] ?? []
              ] : [
                ...c[a] ?? [],
                s
              ];
              return {
                ...c,
                [a]: h
              };
            }), l;
          },
          update: (i, o) => {
            !i || r((s) => {
              const a = {
                ...s
              }, { position: l, index: c } = Zk(a, i);
              return l && c !== -1 && (a[l][c] = {
                ...a[l][c],
                ...o,
                message: Gj(o)
              }), a;
            });
          },
          closeAll: ({ positions: i } = {}) => {
            r((o) => (i ?? [
              "bottom",
              "bottom-right",
              "bottom-left",
              "top",
              "top-left",
              "top-right"
            ]).reduce((l, c) => (l[c] = o[c].map((u) => ({
              ...u,
              requestClose: true
            })), l), {
              ...o
            }));
          },
          close: (i) => {
            r((o) => {
              const s = zP(o, i);
              return s ? {
                ...o,
                [s]: o[s].map((a) => a.id == i ? {
                  ...a,
                  requestClose: true
                } : a)
              } : o;
            });
          },
          isActive: (i) => Boolean(Zk(qc.getState(), i).position)
        };
      }
      let iC = 0;
      function Qj(t, e = {}) {
        iC += 1;
        const n = e.id ?? iC, r = e.position ?? "bottom";
        return {
          id: n,
          message: t,
          position: r,
          duration: e.duration,
          onCloseComplete: e.onCloseComplete,
          onRequestRemove: () => qc.removeToast(String(n), r),
          status: e.status,
          requestClose: false,
          containerStyle: e.containerStyle
        };
      }
      const [XP, Jj] = Mi({
        strict: false,
        name: "PortalContext"
      }), xx = "chakra-portal", Zj = ".chakra-portal", eW = (t) => Z("div", {
        className: "chakra-portal-zIndex",
        style: {
          position: "absolute",
          zIndex: t.zIndex,
          top: 0,
          left: 0,
          right: 0
        },
        children: t.children
      }), tW = (t) => {
        const { appendToParentPortal: e, children: n } = t, [r, i] = z.exports.useState(null), o = z.exports.useRef(null), [, s] = z.exports.useState({});
        z.exports.useEffect(() => s({}), []);
        const a = Jj(), l = MV();
        Zv(() => {
          if (!r)
            return;
          const u = r.ownerDocument, h = e ? a ?? u.body : u.body;
          if (!h)
            return;
          o.current = u.createElement("div"), o.current.className = xx, h.appendChild(o.current), s({});
          const p = o.current;
          return () => {
            h.contains(p) && h.removeChild(p);
          };
        }, [
          r
        ]);
        const c = (l == null ? void 0 : l.zIndex) ? Z(eW, {
          zIndex: l == null ? void 0 : l.zIndex,
          children: n
        }) : n;
        return o.current ? Up.exports.createPortal(Z(XP, {
          value: o.current,
          children: c
        }), o.current) : Z("span", {
          ref: (u) => {
            u && i(u);
          }
        });
      }, nW = (t) => {
        const { children: e, containerRef: n, appendToParentPortal: r } = t, i = n.current, o = i ?? (typeof window < "u" ? document.body : void 0), s = z.exports.useMemo(() => {
          const l = i == null ? void 0 : i.ownerDocument.createElement("div");
          return l && (l.className = xx), l;
        }, [
          i
        ]), [, a] = z.exports.useState({});
        return Zv(() => a({}), []), Zv(() => {
          if (!(!s || !o))
            return o.appendChild(s), () => {
              o.removeChild(s);
            };
        }, [
          s,
          o
        ]), o && s ? Up.exports.createPortal(Z(XP, {
          value: r ? s : null,
          children: e
        }), s) : null;
      };
      function Bm(t) {
        const e = {
          appendToParentPortal: true,
          ...t
        }, { containerRef: n, ...r } = e;
        return n ? Z(nW, {
          containerRef: n,
          ...r
        }) : Z(tW, {
          ...r
        });
      }
      Bm.className = xx;
      Bm.selector = Zj;
      Bm.displayName = "Portal";
      const [rW, UQ] = Mi({
        name: "ToastOptionsContext",
        strict: false
      }), iW = (t) => {
        const e = z.exports.useSyncExternalStore(qc.subscribe, qc.getState, qc.getState), { motionVariants: n, component: r = FP, portalProps: i, animatePresenceProps: o } = t, a = Object.keys(e).map((l) => {
          const c = e[l];
          return Z("div", {
            role: "region",
            "aria-live": "polite",
            "aria-label": `Notifications-${l}`,
            id: `chakra-toast-manager-${l}`,
            style: gj(l),
            children: Z(dj, {
              ...o,
              initial: false,
              children: c.map((u) => Z(r, {
                motionVariants: n,
                ...u
              }, u.id))
            })
          }, l);
        });
        return Z(Bm, {
          ...i,
          children: a
        });
      }, oW = (t) => function({ children: n, theme: r = t, toastOptions: i, ...o }) {
        return Xn(AV, {
          theme: r,
          ...o,
          children: [
            Z(rW, {
              value: i == null ? void 0 : i.defaultOptions,
              children: n
            }),
            Z(iW, {
              ...i
            })
          ]
        });
      }, sW = oW(oF);
      function oC(t) {
        return t.sort((e, n) => {
          const r = e.compareDocumentPosition(n);
          if (r & Node.DOCUMENT_POSITION_FOLLOWING || r & Node.DOCUMENT_POSITION_CONTAINED_BY)
            return -1;
          if (r & Node.DOCUMENT_POSITION_PRECEDING || r & Node.DOCUMENT_POSITION_CONTAINS)
            return 1;
          if (r & Node.DOCUMENT_POSITION_DISCONNECTED || r & Node.DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC)
            throw Error("Cannot sort the given nodes.");
          return 0;
        });
      }
      const aW = (t) => typeof t == "object" && "nodeType" in t && t.nodeType === Node.ELEMENT_NODE;
      function sC(t, e, n) {
        let r = t + 1;
        return n && r >= e && (r = 0), r;
      }
      function aC(t, e, n) {
        let r = t - 1;
        return n && r < 0 && (r = e), r;
      }
      const E0 = typeof window < "u" ? z.exports.useLayoutEffect : z.exports.useEffect, lC = (t) => t;
      var lW = Object.defineProperty, cW = (t, e, n) => e in t ? lW(t, e, {
        enumerable: true,
        configurable: true,
        writable: true,
        value: n
      }) : t[e] = n, xt = (t, e, n) => (cW(t, typeof e != "symbol" ? e + "" : e, n), n);
      class uW {
        constructor() {
          xt(this, "descendants", /* @__PURE__ */ new Map()), xt(this, "register", (e) => {
            if (e != null)
              return aW(e) ? this.registerNode(e) : (n) => {
                this.registerNode(n, e);
              };
          }), xt(this, "unregister", (e) => {
            this.descendants.delete(e);
            const n = oC(Array.from(this.descendants.keys()));
            this.assignIndex(n);
          }), xt(this, "destroy", () => {
            this.descendants.clear();
          }), xt(this, "assignIndex", (e) => {
            this.descendants.forEach((n) => {
              const r = e.indexOf(n.node);
              n.index = r, n.node.dataset.index = n.index.toString();
            });
          }), xt(this, "count", () => this.descendants.size), xt(this, "enabledCount", () => this.enabledValues().length), xt(this, "values", () => Array.from(this.descendants.values()).sort((n, r) => n.index - r.index)), xt(this, "enabledValues", () => this.values().filter((e) => !e.disabled)), xt(this, "item", (e) => {
            if (this.count() !== 0)
              return this.values()[e];
          }), xt(this, "enabledItem", (e) => {
            if (this.enabledCount() !== 0)
              return this.enabledValues()[e];
          }), xt(this, "first", () => this.item(0)), xt(this, "firstEnabled", () => this.enabledItem(0)), xt(this, "last", () => this.item(this.descendants.size - 1)), xt(this, "lastEnabled", () => {
            const e = this.enabledValues().length - 1;
            return this.enabledItem(e);
          }), xt(this, "indexOf", (e) => {
            var _a3;
            return e ? ((_a3 = this.descendants.get(e)) == null ? void 0 : _a3.index) ?? -1 : -1;
          }), xt(this, "enabledIndexOf", (e) => e == null ? -1 : this.enabledValues().findIndex((n) => n.node.isSameNode(e))), xt(this, "next", (e, n = true) => {
            const r = sC(e, this.count(), n);
            return this.item(r);
          }), xt(this, "nextEnabled", (e, n = true) => {
            const r = this.item(e);
            if (!r)
              return;
            const i = this.enabledIndexOf(r.node), o = sC(i, this.enabledCount(), n);
            return this.enabledItem(o);
          }), xt(this, "prev", (e, n = true) => {
            const r = aC(e, this.count() - 1, n);
            return this.item(r);
          }), xt(this, "prevEnabled", (e, n = true) => {
            const r = this.item(e);
            if (!r)
              return;
            const i = this.enabledIndexOf(r.node), o = aC(i, this.enabledCount() - 1, n);
            return this.enabledItem(o);
          }), xt(this, "registerNode", (e, n) => {
            if (!e || this.descendants.has(e))
              return;
            const r = Array.from(this.descendants.keys()).concat(e), i = oC(r);
            (n == null ? void 0 : n.disabled) && (n.disabled = !!n.disabled);
            const o = {
              node: e,
              index: -1,
              ...n
            };
            this.descendants.set(e, o), this.assignIndex(i);
          });
        }
      }
      function fW() {
        const [t, e] = Mi({
          name: "DescendantsProvider",
          errorMessage: "useDescendantsContext must be used within DescendantsProvider"
        });
        return [
          t,
          e,
          () => {
            const i = z.exports.useRef(new uW());
            return E0(() => () => i.current.destroy()), i.current;
          },
          (i) => {
            const o = e(), [s, a] = z.exports.useState(-1), l = z.exports.useRef(null);
            E0(() => () => {
              !l.current || o.unregister(l.current);
            }, []), E0(() => {
              if (!l.current)
                return;
              const u = Number(l.current.dataset.index);
              s != u && !Number.isNaN(u) && a(u);
            });
            const c = lC(i ? o.register(i) : o.register);
            return {
              descendants: o,
              index: s,
              enabledIndex: o.enabledIndexOf(l.current),
              register: Tb(c, l)
            };
          }
        ];
      }
      function hW(t, e) {
        if (t == null)
          return {};
        var n = {};
        for (var r in t)
          if ({}.hasOwnProperty.call(t, r)) {
            if (e.indexOf(r) !== -1)
              continue;
            n[r] = t[r];
          }
        return n;
      }
      const QP = Mr(function(e, n) {
        const { templateAreas: r, gap: i, rowGap: o, columnGap: s, column: a, row: l, autoFlow: c, autoRows: u, templateRows: h, autoColumns: p, templateColumns: v, ...y } = e, S = {
          display: "grid",
          gridTemplateAreas: r,
          gridGap: i,
          gridRowGap: o,
          gridColumnGap: s,
          gridAutoColumns: p,
          gridColumn: a,
          gridRow: l,
          gridAutoFlow: c,
          gridAutoRows: u,
          gridTemplateRows: h,
          gridTemplateColumns: v
        };
        return Z(rn.div, {
          ref: n,
          __css: S,
          ...y
        });
      });
      QP.displayName = "Grid";
      function dW() {
        const t = z.exports.useRef(/* @__PURE__ */ new Map()), e = t.current, n = z.exports.useCallback((i, o, s, a) => {
          t.current.set(s, {
            type: o,
            el: i,
            options: a
          }), i.addEventListener(o, s, a);
        }, []), r = z.exports.useCallback((i, o, s, a) => {
          i.removeEventListener(o, s, a), t.current.delete(s);
        }, []);
        return z.exports.useEffect(() => () => {
          e.forEach((i, o) => {
            r(i.el, i.type, o, i.options);
          });
        }, [
          r,
          e
        ]), {
          add: n,
          remove: r
        };
      }
      function P0(t) {
        var _a3, _b3;
        const e = ((_b3 = (_a3 = t.composedPath) == null ? void 0 : _a3.call(t)) == null ? void 0 : _b3[0]) ?? t.target, { tagName: n, isContentEditable: r } = e;
        return n !== "INPUT" && n !== "TEXTAREA" && r !== true;
      }
      function pW(t = {}) {
        const { ref: e, isDisabled: n, isFocusable: r, clickOnEnter: i = true, clickOnSpace: o = true, onMouseDown: s, onMouseUp: a, onClick: l, onKeyDown: c, onKeyUp: u, tabIndex: h, onMouseOver: p, onMouseLeave: v, ...y } = t, [S, C] = z.exports.useState(true), [w, k] = z.exports.useState(false), T = dW(), P = (Q) => {
          !Q || Q.tagName !== "BUTTON" && C(false);
        }, R = S ? h : h || 0, L = n && !r, D = z.exports.useCallback((Q) => {
          if (n) {
            Q.stopPropagation(), Q.preventDefault();
            return;
          }
          Q.currentTarget.focus(), l == null ? void 0 : l(Q);
        }, [
          n,
          l
        ]), F = z.exports.useCallback((Q) => {
          w && P0(Q) && (Q.preventDefault(), Q.stopPropagation(), k(false), T.remove(document, "keyup", F, false));
        }, [
          w,
          T
        ]), K = z.exports.useCallback((Q) => {
          if (c == null ? void 0 : c(Q), n || Q.defaultPrevented || Q.metaKey || !P0(Q.nativeEvent) || S)
            return;
          const V = i && Q.key === "Enter";
          o && Q.key === " " && (Q.preventDefault(), k(true)), V && (Q.preventDefault(), Q.currentTarget.click()), T.add(document, "keyup", F, false);
        }, [
          n,
          S,
          c,
          i,
          o,
          T,
          F
        ]), Y = z.exports.useCallback((Q) => {
          if (u == null ? void 0 : u(Q), n || Q.defaultPrevented || Q.metaKey || !P0(Q.nativeEvent) || S)
            return;
          o && Q.key === " " && (Q.preventDefault(), k(false), Q.currentTarget.click());
        }, [
          o,
          S,
          n,
          u
        ]), te = z.exports.useCallback((Q) => {
          Q.button === 0 && (k(false), T.remove(document, "mouseup", te, false));
        }, [
          T
        ]), ne = z.exports.useCallback((Q) => {
          if (Q.button !== 0)
            return;
          if (n) {
            Q.stopPropagation(), Q.preventDefault();
            return;
          }
          S || k(true), Q.currentTarget.focus({
            preventScroll: true
          }), T.add(document, "mouseup", te, false), s == null ? void 0 : s(Q);
        }, [
          n,
          S,
          s,
          T,
          te
        ]), ue = z.exports.useCallback((Q) => {
          Q.button === 0 && (S || k(false), a == null ? void 0 : a(Q));
        }, [
          a,
          S
        ]), ye = z.exports.useCallback((Q) => {
          if (n) {
            Q.preventDefault();
            return;
          }
          p == null ? void 0 : p(Q);
        }, [
          n,
          p
        ]), ke = z.exports.useCallback((Q) => {
          w && (Q.preventDefault(), k(false)), v == null ? void 0 : v(Q);
        }, [
          w,
          v
        ]), Ee = Tb(e, P);
        return S ? {
          ...y,
          ref: Ee,
          type: "button",
          "aria-disabled": L ? void 0 : n,
          disabled: L,
          onClick: D,
          onMouseDown: s,
          onMouseUp: a,
          onKeyUp: u,
          onKeyDown: c,
          onMouseOver: p,
          onMouseLeave: v
        } : {
          ...y,
          ref: Ee,
          role: "button",
          "data-active": OI(w),
          "aria-disabled": n ? "true" : void 0,
          tabIndex: L ? void 0 : R,
          onClick: D,
          onMouseDown: ne,
          onMouseUp: ue,
          onKeyUp: Y,
          onKeyDown: K,
          onMouseOver: ye,
          onMouseLeave: ke
        };
      }
      const [mW, gW, vW, yW] = fW();
      function bW(t) {
        const { defaultIndex: e, onChange: n, index: r, isManual: i, isLazy: o, lazyBehavior: s = "unmount", orientation: a = "horizontal", direction: l = "ltr", ...c } = t, [u, h] = z.exports.useState(e ?? 0), [p, v] = UI({
          defaultValue: e ?? 0,
          value: r,
          onChange: n
        });
        z.exports.useEffect(() => {
          r != null && h(r);
        }, [
          r
        ]);
        const y = vW(), S = z.exports.useId();
        return {
          id: `tabs-${t.id ?? S}`,
          selectedIndex: p,
          focusedIndex: u,
          setSelectedIndex: v,
          setFocusedIndex: h,
          isManual: i,
          isLazy: o,
          lazyBehavior: s,
          orientation: a,
          descendants: y,
          direction: l,
          htmlProps: c
        };
      }
      const [xW, Nm] = Mi({
        name: "TabsContext",
        errorMessage: "useTabsContext: `context` is undefined. Seems you forgot to wrap all tabs components within <Tabs />"
      });
      function SW(t) {
        const { focusedIndex: e, orientation: n, direction: r } = Nm(), i = gW(), o = z.exports.useCallback((s) => {
          const a = () => {
            var _a3;
            const k = i.nextEnabled(e);
            k && ((_a3 = k.node) == null ? void 0 : _a3.focus());
          }, l = () => {
            var _a3;
            const k = i.prevEnabled(e);
            k && ((_a3 = k.node) == null ? void 0 : _a3.focus());
          }, c = () => {
            var _a3;
            const k = i.firstEnabled();
            k && ((_a3 = k.node) == null ? void 0 : _a3.focus());
          }, u = () => {
            var _a3;
            const k = i.lastEnabled();
            k && ((_a3 = k.node) == null ? void 0 : _a3.focus());
          }, h = n === "horizontal", p = n === "vertical", v = s.key, y = r === "ltr" ? "ArrowLeft" : "ArrowRight", S = r === "ltr" ? "ArrowRight" : "ArrowLeft", w = {
            [y]: () => h && l(),
            [S]: () => h && a(),
            ArrowDown: () => p && a(),
            ArrowUp: () => p && l(),
            Home: c,
            End: u
          }[v];
          w && (s.preventDefault(), w(s));
        }, [
          i,
          e,
          n,
          r
        ]);
        return {
          ...t,
          role: "tablist",
          "aria-orientation": n,
          onKeyDown: Qv(t.onKeyDown, o)
        };
      }
      function wW(t) {
        const { isDisabled: e = false, isFocusable: n = false, ...r } = t, { setSelectedIndex: i, isManual: o, id: s, setFocusedIndex: a, selectedIndex: l } = Nm(), { index: c, register: u } = yW({
          disabled: e && !n
        }), h = c === l, p = () => {
          i(c);
        }, v = () => {
          a(c), !o && !(e && n) && i(c);
        }, y = pW({
          ...r,
          ref: Tb(u, t.ref),
          isDisabled: e,
          isFocusable: n,
          onClick: Qv(t.onClick, p)
        }), S = "button";
        return {
          ...y,
          id: JP(s, c),
          role: "tab",
          tabIndex: h ? 0 : -1,
          type: S,
          "aria-selected": h,
          "aria-controls": ZP(s, c),
          onFocus: e ? void 0 : Qv(t.onFocus, v)
        };
      }
      const [kW, CW] = Mi({});
      function TW(t) {
        const e = Nm(), { id: n, selectedIndex: r } = e, o = BI(t.children).map((s, a) => z.exports.createElement(kW, {
          key: s.key ?? a,
          value: {
            isSelected: a === r,
            id: ZP(n, a),
            tabId: JP(n, a),
            selectedIndex: r
          }
        }, s));
        return {
          ...t,
          children: o
        };
      }
      function MW(t) {
        const { children: e, ...n } = t, { isLazy: r, lazyBehavior: i } = Nm(), { isSelected: o, id: s, tabId: a } = CW(), l = z.exports.useRef(false);
        o && (l.current = true);
        const c = VI({
          wasSelected: l.current,
          isSelected: o,
          enabled: r,
          mode: i
        });
        return {
          tabIndex: 0,
          ...n,
          children: c ? e : null,
          role: "tabpanel",
          "aria-labelledby": a,
          hidden: !o,
          id: s
        };
      }
      function JP(t, e) {
        return `${t}--tab-${e}`;
      }
      function ZP(t, e) {
        return `${t}--tabpanel-${e}`;
      }
      const [AW, $m] = Mi({
        name: "TabsStylesContext",
        errorMessage: `useTabsStyles returned is 'undefined'. Seems you forgot to wrap the components in "<Tabs />" `
      }), eO = Mr(function(e, n) {
        const r = HP("Tabs", e), { children: i, className: o, ...s } = lm(e), { htmlProps: a, descendants: l, ...c } = bW(s), u = z.exports.useMemo(() => c, [
          c
        ]), { isFitted: h, ...p } = a, v = {
          position: "relative",
          ...r.root
        };
        return Z(mW, {
          value: l,
          children: Z(xW, {
            value: u,
            children: Z(AW, {
              value: r,
              children: Z(rn.div, {
                className: qr("chakra-tabs", o),
                ref: n,
                ...p,
                __css: v,
                children: i
              })
            })
          })
        });
      });
      eO.displayName = "Tabs";
      const tO = Mr(function(e, n) {
        const r = $m(), i = wW({
          ...e,
          ref: n
        }), o = {
          outline: "0",
          display: "flex",
          alignItems: "center",
          justifyContent: "center",
          ...r.tab
        };
        return Z(rn.button, {
          ...i,
          className: qr("chakra-tabs__tab", e.className),
          __css: o
        });
      });
      tO.displayName = "Tab";
      const nO = Mr(function(e, n) {
        const r = SW({
          ...e,
          ref: n
        }), i = $m(), o = {
          display: "flex",
          ...i.tablist
        };
        return Z(rn.div, {
          ...r,
          className: qr("chakra-tabs__tablist", e.className),
          __css: o
        });
      });
      nO.displayName = "TabList";
      const Ry = Mr(function(e, n) {
        const r = MW({
          ...e,
          ref: n
        }), i = $m();
        return Z(rn.div, {
          outline: "0",
          ...r,
          className: qr("chakra-tabs__tab-panel", e.className),
          __css: i.tabpanel
        });
      });
      Ry.displayName = "TabPanel";
      const rO = Mr(function(e, n) {
        const r = TW(e), i = $m();
        return Z(rn.div, {
          ...r,
          width: "100%",
          ref: n,
          className: qr("chakra-tabs__tab-panels", e.className),
          __css: i.tabpanels
        });
      });
      rO.displayName = "TabPanels";
      let Ly = [], iO = [];
      (() => {
        let t = "lc,34,7n,7,7b,19,,,,2,,2,,,20,b,1c,l,g,,2t,7,2,6,2,2,,4,z,,u,r,2j,b,1m,9,9,,o,4,,9,,3,,5,17,3,3b,f,,w,1j,,,,4,8,4,,3,7,a,2,t,,1m,,,,2,4,8,,9,,a,2,q,,2,2,1l,,4,2,4,2,2,3,3,,u,2,3,,b,2,1l,,4,5,,2,4,,k,2,m,6,,,1m,,,2,,4,8,,7,3,a,2,u,,1n,,,,c,,9,,14,,3,,1l,3,5,3,,4,7,2,b,2,t,,1m,,2,,2,,3,,5,2,7,2,b,2,s,2,1l,2,,,2,4,8,,9,,a,2,t,,20,,4,,2,3,,,8,,29,,2,7,c,8,2q,,2,9,b,6,22,2,r,,,,,,1j,e,,5,,2,5,b,,10,9,,2u,4,,6,,2,2,2,p,2,4,3,g,4,d,,2,2,6,,f,,jj,3,qa,3,t,3,t,2,u,2,1s,2,,7,8,,2,b,9,,19,3,3b,2,y,,3a,3,4,2,9,,6,3,63,2,2,,1m,,,7,,,,,2,8,6,a,2,,1c,h,1r,4,1c,7,,,5,,14,9,c,2,w,4,2,2,,3,1k,,,2,3,,,3,1m,8,2,2,48,3,,d,,7,4,,6,,3,2,5i,1m,,5,ek,,5f,x,2da,3,3x,,2o,w,fe,6,2x,2,n9w,4,,a,w,2,28,2,7k,,3,,4,,p,2,5,,47,2,q,i,d,,12,8,p,b,1a,3,1c,,2,4,2,2,13,,1v,6,2,2,2,2,c,,8,,1b,,1f,,,3,2,2,5,2,,,16,2,8,,6m,,2,,4,,fn4,,kh,g,g,g,a6,2,gt,,6a,,45,5,1ae,3,,2,5,4,14,3,4,,4l,2,fx,4,ar,2,49,b,4w,,1i,f,1k,3,1d,4,2,2,1x,3,10,5,,8,1q,,c,2,1g,9,a,4,2,,2n,3,2,,,2,6,,4g,,3,8,l,2,1l,2,,,,,m,,e,7,3,5,5f,8,2,3,,,n,,29,,2,6,,,2,,,2,,2,6j,,2,4,6,2,,2,r,2,2d,8,2,,,2,2y,,,,2,6,,,2t,3,2,4,,5,77,9,,2,6t,,a,2,,,4,,40,4,2,2,4,,w,a,14,6,2,4,8,,9,6,2,3,1a,d,,2,ba,7,,6,,,2a,m,2,7,,2,,2,3e,6,3,,,2,,7,,,20,2,3,,,,9n,2,f0b,5,1n,7,t4,,1r,4,29,,f5k,2,43q,,,3,4,5,8,8,2,7,u,4,44,3,1iz,1j,4,1e,8,,e,,m,5,,f,11s,7,,h,2,7,,2,,5,79,7,c5,4,15s,7,31,7,240,5,gx7k,2o,3k,6o".split(",").map((e) => e ? parseInt(e, 36) : 1);
        for (let e = 0, n = 0; e < t.length; e++)
          (e % 2 ? iO : Ly).push(n = n + t[e]);
      })();
      function EW(t) {
        if (t < 768)
          return false;
        for (let e = 0, n = Ly.length; ; ) {
          let r = e + n >> 1;
          if (t < Ly[r])
            n = r;
          else if (t >= iO[r])
            e = r + 1;
          else
            return true;
          if (e == n)
            return false;
        }
      }
      function cC(t) {
        return t >= 127462 && t <= 127487;
      }
      const uC = 8205;
      function PW(t, e, n = true, r = true) {
        return (n ? oO : OW)(t, e, r);
      }
      function oO(t, e, n) {
        if (e == t.length)
          return e;
        e && sO(t.charCodeAt(e)) && aO(t.charCodeAt(e - 1)) && e--;
        let r = O0(t, e);
        for (e += fC(r); e < t.length; ) {
          let i = O0(t, e);
          if (r == uC || i == uC || n && EW(i))
            e += fC(i), r = i;
          else if (cC(i)) {
            let o = 0, s = e - 2;
            for (; s >= 0 && cC(O0(t, s)); )
              o++, s -= 2;
            if (o % 2 == 0)
              break;
            e += 2;
          } else
            break;
        }
        return e;
      }
      function OW(t, e, n) {
        for (; e > 0; ) {
          let r = oO(t, e - 2, n);
          if (r < e)
            return r;
          e--;
        }
        return 0;
      }
      function O0(t, e) {
        let n = t.charCodeAt(e);
        if (!aO(n) || e + 1 == t.length)
          return n;
        let r = t.charCodeAt(e + 1);
        return sO(r) ? (n - 55296 << 10) + (r - 56320) + 65536 : n;
      }
      function sO(t) {
        return t >= 56320 && t < 57344;
      }
      function aO(t) {
        return t >= 55296 && t < 56320;
      }
      function fC(t) {
        return t < 65536 ? 1 : 2;
      }
      class He {
        lineAt(e) {
          if (e < 0 || e > this.length)
            throw new RangeError(`Invalid position ${e} in document of length ${this.length}`);
          return this.lineInner(e, false, 1, 0);
        }
        line(e) {
          if (e < 1 || e > this.lines)
            throw new RangeError(`Invalid line number ${e} in ${this.lines}-line document`);
          return this.lineInner(e, true, 1, 0);
        }
        replace(e, n, r) {
          [e, n] = fl(this, e, n);
          let i = [];
          return this.decompose(0, e, i, 2), r.length && r.decompose(0, r.length, i, 3), this.decompose(n, this.length, i, 1), hi.from(i, this.length - (n - e) + r.length);
        }
        append(e) {
          return this.replace(this.length, this.length, e);
        }
        slice(e, n = this.length) {
          [e, n] = fl(this, e, n);
          let r = [];
          return this.decompose(e, n, r, 0), hi.from(r, n - e);
        }
        eq(e) {
          if (e == this)
            return true;
          if (e.length != this.length || e.lines != this.lines)
            return false;
          let n = this.scanIdentical(e, 1), r = this.length - this.scanIdentical(e, -1), i = new Gc(this), o = new Gc(e);
          for (let s = n, a = n; ; ) {
            if (i.next(s), o.next(s), s = 0, i.lineBreak != o.lineBreak || i.done != o.done || i.value != o.value)
              return false;
            if (a += i.value.length, i.done || a >= r)
              return true;
          }
        }
        iter(e = 1) {
          return new Gc(this, e);
        }
        iterRange(e, n = this.length) {
          return new lO(this, e, n);
        }
        iterLines(e, n) {
          let r;
          if (e == null)
            r = this.iter();
          else {
            n == null && (n = this.lines + 1);
            let i = this.line(e).from;
            r = this.iterRange(i, Math.max(i, n == this.lines + 1 ? this.length : n <= 1 ? 0 : this.line(n - 1).to));
          }
          return new cO(r);
        }
        toString() {
          return this.sliceString(0);
        }
        toJSON() {
          let e = [];
          return this.flatten(e), e;
        }
        constructor() {
        }
        static of(e) {
          if (e.length == 0)
            throw new RangeError("A document must have at least one line");
          return e.length == 1 && !e[0] ? He.empty : e.length <= 32 ? new Tt(e) : hi.from(Tt.split(e, []));
        }
      }
      class Tt extends He {
        constructor(e, n = RW(e)) {
          super(), this.text = e, this.length = n;
        }
        get lines() {
          return this.text.length;
        }
        get children() {
          return null;
        }
        lineInner(e, n, r, i) {
          for (let o = 0; ; o++) {
            let s = this.text[o], a = i + s.length;
            if ((n ? r : a) >= e)
              return new LW(i, a, r, s);
            i = a + 1, r++;
          }
        }
        decompose(e, n, r, i) {
          let o = e <= 0 && n >= this.length ? this : new Tt(hC(this.text, e, n), Math.min(n, this.length) - Math.max(0, e));
          if (i & 1) {
            let s = r.pop(), a = vd(o.text, s.text.slice(), 0, o.length);
            if (a.length <= 32)
              r.push(new Tt(a, s.length + o.length));
            else {
              let l = a.length >> 1;
              r.push(new Tt(a.slice(0, l)), new Tt(a.slice(l)));
            }
          } else
            r.push(o);
        }
        replace(e, n, r) {
          if (!(r instanceof Tt))
            return super.replace(e, n, r);
          [e, n] = fl(this, e, n);
          let i = vd(this.text, vd(r.text, hC(this.text, 0, e)), n), o = this.length + r.length - (n - e);
          return i.length <= 32 ? new Tt(i, o) : hi.from(Tt.split(i, []), o);
        }
        sliceString(e, n = this.length, r = `
`) {
          [e, n] = fl(this, e, n);
          let i = "";
          for (let o = 0, s = 0; o <= n && s < this.text.length; s++) {
            let a = this.text[s], l = o + a.length;
            o > e && s && (i += r), e < l && n > o && (i += a.slice(Math.max(0, e - o), n - o)), o = l + 1;
          }
          return i;
        }
        flatten(e) {
          for (let n of this.text)
            e.push(n);
        }
        scanIdentical() {
          return 0;
        }
        static split(e, n) {
          let r = [], i = -1;
          for (let o of e)
            r.push(o), i += o.length + 1, r.length == 32 && (n.push(new Tt(r, i)), r = [], i = -1);
          return i > -1 && n.push(new Tt(r, i)), n;
        }
      }
      class hi extends He {
        constructor(e, n) {
          super(), this.children = e, this.length = n, this.lines = 0;
          for (let r of e)
            this.lines += r.lines;
        }
        lineInner(e, n, r, i) {
          for (let o = 0; ; o++) {
            let s = this.children[o], a = i + s.length, l = r + s.lines - 1;
            if ((n ? l : a) >= e)
              return s.lineInner(e, n, r, i);
            i = a + 1, r = l + 1;
          }
        }
        decompose(e, n, r, i) {
          for (let o = 0, s = 0; s <= n && o < this.children.length; o++) {
            let a = this.children[o], l = s + a.length;
            if (e <= l && n >= s) {
              let c = i & ((s <= e ? 1 : 0) | (l >= n ? 2 : 0));
              s >= e && l <= n && !c ? r.push(a) : a.decompose(e - s, n - s, r, c);
            }
            s = l + 1;
          }
        }
        replace(e, n, r) {
          if ([e, n] = fl(this, e, n), r.lines < this.lines)
            for (let i = 0, o = 0; i < this.children.length; i++) {
              let s = this.children[i], a = o + s.length;
              if (e >= o && n <= a) {
                let l = s.replace(e - o, n - o, r), c = this.lines - s.lines + l.lines;
                if (l.lines < c >> 5 - 1 && l.lines > c >> 5 + 1) {
                  let u = this.children.slice();
                  return u[i] = l, new hi(u, this.length - (n - e) + r.length);
                }
                return super.replace(o, a, l);
              }
              o = a + 1;
            }
          return super.replace(e, n, r);
        }
        sliceString(e, n = this.length, r = `
`) {
          [e, n] = fl(this, e, n);
          let i = "";
          for (let o = 0, s = 0; o < this.children.length && s <= n; o++) {
            let a = this.children[o], l = s + a.length;
            s > e && o && (i += r), e < l && n > s && (i += a.sliceString(e - s, n - s, r)), s = l + 1;
          }
          return i;
        }
        flatten(e) {
          for (let n of this.children)
            n.flatten(e);
        }
        scanIdentical(e, n) {
          if (!(e instanceof hi))
            return 0;
          let r = 0, [i, o, s, a] = n > 0 ? [
            0,
            0,
            this.children.length,
            e.children.length
          ] : [
            this.children.length - 1,
            e.children.length - 1,
            -1,
            -1
          ];
          for (; ; i += n, o += n) {
            if (i == s || o == a)
              return r;
            let l = this.children[i], c = e.children[o];
            if (l != c)
              return r + l.scanIdentical(c, n);
            r += l.length + 1;
          }
        }
        static from(e, n = e.reduce((r, i) => r + i.length + 1, -1)) {
          let r = 0;
          for (let v of e)
            r += v.lines;
          if (r < 32) {
            let v = [];
            for (let y of e)
              y.flatten(v);
            return new Tt(v, n);
          }
          let i = Math.max(32, r >> 5), o = i << 1, s = i >> 1, a = [], l = 0, c = -1, u = [];
          function h(v) {
            let y;
            if (v.lines > o && v instanceof hi)
              for (let S of v.children)
                h(S);
            else
              v.lines > s && (l > s || !l) ? (p(), a.push(v)) : v instanceof Tt && l && (y = u[u.length - 1]) instanceof Tt && v.lines + y.lines <= 32 ? (l += v.lines, c += v.length + 1, u[u.length - 1] = new Tt(y.text.concat(v.text), y.length + 1 + v.length)) : (l + v.lines > i && p(), l += v.lines, c += v.length + 1, u.push(v));
          }
          function p() {
            l != 0 && (a.push(u.length == 1 ? u[0] : hi.from(u, c)), c = -1, l = u.length = 0);
          }
          for (let v of e)
            h(v);
          return p(), a.length == 1 ? a[0] : new hi(a, n);
        }
      }
      He.empty = new Tt([
        ""
      ], 0);
      function RW(t) {
        let e = -1;
        for (let n of t)
          e += n.length + 1;
        return e;
      }
      function vd(t, e, n = 0, r = 1e9) {
        for (let i = 0, o = 0, s = true; o < t.length && i <= r; o++) {
          let a = t[o], l = i + a.length;
          l >= n && (l > r && (a = a.slice(0, r - i)), i < n && (a = a.slice(n - i)), s ? (e[e.length - 1] += a, s = false) : e.push(a)), i = l + 1;
        }
        return e;
      }
      function hC(t, e, n) {
        return vd(t, [
          ""
        ], e, n);
      }
      class Gc {
        constructor(e, n = 1) {
          this.dir = n, this.done = false, this.lineBreak = false, this.value = "", this.nodes = [
            e
          ], this.offsets = [
            n > 0 ? 1 : (e instanceof Tt ? e.text.length : e.children.length) << 1
          ];
        }
        nextInner(e, n) {
          for (this.done = this.lineBreak = false; ; ) {
            let r = this.nodes.length - 1, i = this.nodes[r], o = this.offsets[r], s = o >> 1, a = i instanceof Tt ? i.text.length : i.children.length;
            if (s == (n > 0 ? a : 0)) {
              if (r == 0)
                return this.done = true, this.value = "", this;
              n > 0 && this.offsets[r - 1]++, this.nodes.pop(), this.offsets.pop();
            } else if ((o & 1) == (n > 0 ? 0 : 1)) {
              if (this.offsets[r] += n, e == 0)
                return this.lineBreak = true, this.value = `
`, this;
              e--;
            } else if (i instanceof Tt) {
              let l = i.text[s + (n < 0 ? -1 : 0)];
              if (this.offsets[r] += n, l.length > Math.max(0, e))
                return this.value = e == 0 ? l : n > 0 ? l.slice(e) : l.slice(0, l.length - e), this;
              e -= l.length;
            } else {
              let l = i.children[s + (n < 0 ? -1 : 0)];
              e > l.length ? (e -= l.length, this.offsets[r] += n) : (n < 0 && this.offsets[r]--, this.nodes.push(l), this.offsets.push(n > 0 ? 1 : (l instanceof Tt ? l.text.length : l.children.length) << 1));
            }
          }
        }
        next(e = 0) {
          return e < 0 && (this.nextInner(-e, -this.dir), e = this.value.length), this.nextInner(e, this.dir);
        }
      }
      class lO {
        constructor(e, n, r) {
          this.value = "", this.done = false, this.cursor = new Gc(e, n > r ? -1 : 1), this.pos = n > r ? e.length : 0, this.from = Math.min(n, r), this.to = Math.max(n, r);
        }
        nextInner(e, n) {
          if (n < 0 ? this.pos <= this.from : this.pos >= this.to)
            return this.value = "", this.done = true, this;
          e += Math.max(0, n < 0 ? this.pos - this.to : this.from - this.pos);
          let r = n < 0 ? this.pos - this.from : this.to - this.pos;
          e > r && (e = r), r -= e;
          let { value: i } = this.cursor.next(e);
          return this.pos += (i.length + e) * n, this.value = i.length <= r ? i : n < 0 ? i.slice(i.length - r) : i.slice(0, r), this.done = !this.value, this;
        }
        next(e = 0) {
          return e < 0 ? e = Math.max(e, this.from - this.pos) : e > 0 && (e = Math.min(e, this.to - this.pos)), this.nextInner(e, this.cursor.dir);
        }
        get lineBreak() {
          return this.cursor.lineBreak && this.value != "";
        }
      }
      class cO {
        constructor(e) {
          this.inner = e, this.afterBreak = true, this.value = "", this.done = false;
        }
        next(e = 0) {
          let { done: n, lineBreak: r, value: i } = this.inner.next(e);
          return n && this.afterBreak ? (this.value = "", this.afterBreak = false) : n ? (this.done = true, this.value = "") : r ? this.afterBreak ? this.value = "" : (this.afterBreak = true, this.next()) : (this.value = i, this.afterBreak = false), this;
        }
        get lineBreak() {
          return false;
        }
      }
      typeof Symbol < "u" && (He.prototype[Symbol.iterator] = function() {
        return this.iter();
      }, Gc.prototype[Symbol.iterator] = lO.prototype[Symbol.iterator] = cO.prototype[Symbol.iterator] = function() {
        return this;
      });
      class LW {
        constructor(e, n, r, i) {
          this.from = e, this.to = n, this.number = r, this.text = i;
        }
        get length() {
          return this.to - this.from;
        }
      }
      function fl(t, e, n) {
        return e = Math.max(0, Math.min(t.length, e)), [
          e,
          Math.max(e, Math.min(t.length, n))
        ];
      }
      function en(t, e, n = true, r = true) {
        return PW(t, e, n, r);
      }
      function DW(t) {
        return t >= 56320 && t < 57344;
      }
      function _W(t) {
        return t >= 55296 && t < 56320;
      }
      function Rn(t, e) {
        let n = t.charCodeAt(e);
        if (!_W(n) || e + 1 == t.length)
          return n;
        let r = t.charCodeAt(e + 1);
        return DW(r) ? (n - 55296 << 10) + (r - 56320) + 65536 : n;
      }
      function Sx(t) {
        return t <= 65535 ? String.fromCharCode(t) : (t -= 65536, String.fromCharCode((t >> 10) + 55296, (t & 1023) + 56320));
      }
      function di(t) {
        return t < 65536 ? 1 : 2;
      }
      const Dy = /\r\n?|\n/;
      var Zt = function(t) {
        return t[t.Simple = 0] = "Simple", t[t.TrackDel = 1] = "TrackDel", t[t.TrackBefore = 2] = "TrackBefore", t[t.TrackAfter = 3] = "TrackAfter", t;
      }(Zt || (Zt = {}));
      class ki {
        constructor(e) {
          this.sections = e;
        }
        get length() {
          let e = 0;
          for (let n = 0; n < this.sections.length; n += 2)
            e += this.sections[n];
          return e;
        }
        get newLength() {
          let e = 0;
          for (let n = 0; n < this.sections.length; n += 2) {
            let r = this.sections[n + 1];
            e += r < 0 ? this.sections[n] : r;
          }
          return e;
        }
        get empty() {
          return this.sections.length == 0 || this.sections.length == 2 && this.sections[1] < 0;
        }
        iterGaps(e) {
          for (let n = 0, r = 0, i = 0; n < this.sections.length; ) {
            let o = this.sections[n++], s = this.sections[n++];
            s < 0 ? (e(r, i, o), i += o) : i += s, r += o;
          }
        }
        iterChangedRanges(e, n = false) {
          _y(this, e, n);
        }
        get invertedDesc() {
          let e = [];
          for (let n = 0; n < this.sections.length; ) {
            let r = this.sections[n++], i = this.sections[n++];
            i < 0 ? e.push(r, i) : e.push(i, r);
          }
          return new ki(e);
        }
        composeDesc(e) {
          return this.empty ? e : e.empty ? this : uO(this, e);
        }
        mapDesc(e, n = false) {
          return e.empty ? this : Iy(this, e, n);
        }
        mapPos(e, n = -1, r = Zt.Simple) {
          let i = 0, o = 0;
          for (let s = 0; s < this.sections.length; ) {
            let a = this.sections[s++], l = this.sections[s++], c = i + a;
            if (l < 0) {
              if (c > e)
                return o + (e - i);
              o += a;
            } else {
              if (r != Zt.Simple && c >= e && (r == Zt.TrackDel && i < e && c > e || r == Zt.TrackBefore && i < e || r == Zt.TrackAfter && c > e))
                return null;
              if (c > e || c == e && n < 0 && !a)
                return e == i || n < 0 ? o : o + l;
              o += l;
            }
            i = c;
          }
          if (e > i)
            throw new RangeError(`Position ${e} is out of range for changeset of length ${i}`);
          return o;
        }
        touchesRange(e, n = e) {
          for (let r = 0, i = 0; r < this.sections.length && i <= n; ) {
            let o = this.sections[r++], s = this.sections[r++], a = i + o;
            if (s >= 0 && i <= n && a >= e)
              return i < e && a > n ? "cover" : true;
            i = a;
          }
          return false;
        }
        toString() {
          let e = "";
          for (let n = 0; n < this.sections.length; ) {
            let r = this.sections[n++], i = this.sections[n++];
            e += (e ? " " : "") + r + (i >= 0 ? ":" + i : "");
          }
          return e;
        }
        toJSON() {
          return this.sections;
        }
        static fromJSON(e) {
          if (!Array.isArray(e) || e.length % 2 || e.some((n) => typeof n != "number"))
            throw new RangeError("Invalid JSON representation of ChangeDesc");
          return new ki(e);
        }
        static create(e) {
          return new ki(e);
        }
      }
      class _t extends ki {
        constructor(e, n) {
          super(e), this.inserted = n;
        }
        apply(e) {
          if (this.length != e.length)
            throw new RangeError("Applying change set to a document with the wrong length");
          return _y(this, (n, r, i, o, s) => e = e.replace(i, i + (r - n), s), false), e;
        }
        mapDesc(e, n = false) {
          return Iy(this, e, n, true);
        }
        invert(e) {
          let n = this.sections.slice(), r = [];
          for (let i = 0, o = 0; i < n.length; i += 2) {
            let s = n[i], a = n[i + 1];
            if (a >= 0) {
              n[i] = a, n[i + 1] = s;
              let l = i >> 1;
              for (; r.length < l; )
                r.push(He.empty);
              r.push(s ? e.slice(o, o + s) : He.empty);
            }
            o += s;
          }
          return new _t(n, r);
        }
        compose(e) {
          return this.empty ? e : e.empty ? this : uO(this, e, true);
        }
        map(e, n = false) {
          return e.empty ? this : Iy(this, e, n, true);
        }
        iterChanges(e, n = false) {
          _y(this, e, n);
        }
        get desc() {
          return ki.create(this.sections);
        }
        filter(e) {
          let n = [], r = [], i = [], o = new Ru(this);
          e:
            for (let s = 0, a = 0; ; ) {
              let l = s == e.length ? 1e9 : e[s++];
              for (; a < l || a == l && o.len == 0; ) {
                if (o.done)
                  break e;
                let u = Math.min(o.len, l - a);
                un(i, u, -1);
                let h = o.ins == -1 ? -1 : o.off == 0 ? o.ins : 0;
                un(n, u, h), h > 0 && Lo(r, n, o.text), o.forward(u), a += u;
              }
              let c = e[s++];
              for (; a < c; ) {
                if (o.done)
                  break e;
                let u = Math.min(o.len, c - a);
                un(n, u, -1), un(i, u, o.ins == -1 ? -1 : o.off == 0 ? o.ins : 0), o.forward(u), a += u;
              }
            }
          return {
            changes: new _t(n, r),
            filtered: ki.create(i)
          };
        }
        toJSON() {
          let e = [];
          for (let n = 0; n < this.sections.length; n += 2) {
            let r = this.sections[n], i = this.sections[n + 1];
            i < 0 ? e.push(r) : i == 0 ? e.push([
              r
            ]) : e.push([
              r
            ].concat(this.inserted[n >> 1].toJSON()));
          }
          return e;
        }
        static of(e, n, r) {
          let i = [], o = [], s = 0, a = null;
          function l(u = false) {
            if (!u && !i.length)
              return;
            s < n && un(i, n - s, -1);
            let h = new _t(i, o);
            a = a ? a.compose(h.map(a)) : h, i = [], o = [], s = 0;
          }
          function c(u) {
            if (Array.isArray(u))
              for (let h of u)
                c(h);
            else if (u instanceof _t) {
              if (u.length != n)
                throw new RangeError(`Mismatched change set length (got ${u.length}, expected ${n})`);
              l(), a = a ? a.compose(u.map(a)) : u;
            } else {
              let { from: h, to: p = h, insert: v } = u;
              if (h > p || h < 0 || p > n)
                throw new RangeError(`Invalid change range ${h} to ${p} (in doc of length ${n})`);
              let y = v ? typeof v == "string" ? He.of(v.split(r || Dy)) : v : He.empty, S = y.length;
              if (h == p && S == 0)
                return;
              h < s && l(), h > s && un(i, h - s, -1), un(i, p - h, S), Lo(o, i, y), s = p;
            }
          }
          return c(e), l(!a), a;
        }
        static empty(e) {
          return new _t(e ? [
            e,
            -1
          ] : [], []);
        }
        static fromJSON(e) {
          if (!Array.isArray(e))
            throw new RangeError("Invalid JSON representation of ChangeSet");
          let n = [], r = [];
          for (let i = 0; i < e.length; i++) {
            let o = e[i];
            if (typeof o == "number")
              n.push(o, -1);
            else {
              if (!Array.isArray(o) || typeof o[0] != "number" || o.some((s, a) => a && typeof s != "string"))
                throw new RangeError("Invalid JSON representation of ChangeSet");
              if (o.length == 1)
                n.push(o[0], 0);
              else {
                for (; r.length < i; )
                  r.push(He.empty);
                r[i] = He.of(o.slice(1)), n.push(o[0], r[i].length);
              }
            }
          }
          return new _t(n, r);
        }
        static createSet(e, n) {
          return new _t(e, n);
        }
      }
      function un(t, e, n, r = false) {
        if (e == 0 && n <= 0)
          return;
        let i = t.length - 2;
        i >= 0 && n <= 0 && n == t[i + 1] ? t[i] += e : i >= 0 && e == 0 && t[i] == 0 ? t[i + 1] += n : r ? (t[i] += e, t[i + 1] += n) : t.push(e, n);
      }
      function Lo(t, e, n) {
        if (n.length == 0)
          return;
        let r = e.length - 2 >> 1;
        if (r < t.length)
          t[t.length - 1] = t[t.length - 1].append(n);
        else {
          for (; t.length < r; )
            t.push(He.empty);
          t.push(n);
        }
      }
      function _y(t, e, n) {
        let r = t.inserted;
        for (let i = 0, o = 0, s = 0; s < t.sections.length; ) {
          let a = t.sections[s++], l = t.sections[s++];
          if (l < 0)
            i += a, o += a;
          else {
            let c = i, u = o, h = He.empty;
            for (; c += a, u += l, l && r && (h = h.append(r[s - 2 >> 1])), !(n || s == t.sections.length || t.sections[s + 1] < 0); )
              a = t.sections[s++], l = t.sections[s++];
            e(i, c, o, u, h), i = c, o = u;
          }
        }
      }
      function Iy(t, e, n, r = false) {
        let i = [], o = r ? [] : null, s = new Ru(t), a = new Ru(e);
        for (let l = -1; ; ) {
          if (s.done && a.len || a.done && s.len)
            throw new Error("Mismatched change set lengths");
          if (s.ins == -1 && a.ins == -1) {
            let c = Math.min(s.len, a.len);
            un(i, c, -1), s.forward(c), a.forward(c);
          } else if (a.ins >= 0 && (s.ins < 0 || l == s.i || s.off == 0 && (a.len < s.len || a.len == s.len && !n))) {
            let c = a.len;
            for (un(i, a.ins, -1); c; ) {
              let u = Math.min(s.len, c);
              s.ins >= 0 && l < s.i && s.len <= u && (un(i, 0, s.ins), o && Lo(o, i, s.text), l = s.i), s.forward(u), c -= u;
            }
            a.next();
          } else if (s.ins >= 0) {
            let c = 0, u = s.len;
            for (; u; )
              if (a.ins == -1) {
                let h = Math.min(u, a.len);
                c += h, u -= h, a.forward(h);
              } else if (a.ins == 0 && a.len < u)
                u -= a.len, a.next();
              else
                break;
            un(i, c, l < s.i ? s.ins : 0), o && l < s.i && Lo(o, i, s.text), l = s.i, s.forward(s.len - u);
          } else {
            if (s.done && a.done)
              return o ? _t.createSet(i, o) : ki.create(i);
            throw new Error("Mismatched change set lengths");
          }
        }
      }
      function uO(t, e, n = false) {
        let r = [], i = n ? [] : null, o = new Ru(t), s = new Ru(e);
        for (let a = false; ; ) {
          if (o.done && s.done)
            return i ? _t.createSet(r, i) : ki.create(r);
          if (o.ins == 0)
            un(r, o.len, 0, a), o.next();
          else if (s.len == 0 && !s.done)
            un(r, 0, s.ins, a), i && Lo(i, r, s.text), s.next();
          else {
            if (o.done || s.done)
              throw new Error("Mismatched change set lengths");
            {
              let l = Math.min(o.len2, s.len), c = r.length;
              if (o.ins == -1) {
                let u = s.ins == -1 ? -1 : s.off ? 0 : s.ins;
                un(r, l, u, a), i && u && Lo(i, r, s.text);
              } else
                s.ins == -1 ? (un(r, o.off ? 0 : o.len, l, a), i && Lo(i, r, o.textBit(l))) : (un(r, o.off ? 0 : o.len, s.off ? 0 : s.ins, a), i && !s.off && Lo(i, r, s.text));
              a = (o.ins > l || s.ins >= 0 && s.len > l) && (a || r.length > c), o.forward2(l), s.forward(l);
            }
          }
        }
      }
      class Ru {
        constructor(e) {
          this.set = e, this.i = 0, this.next();
        }
        next() {
          let { sections: e } = this.set;
          this.i < e.length ? (this.len = e[this.i++], this.ins = e[this.i++]) : (this.len = 0, this.ins = -2), this.off = 0;
        }
        get done() {
          return this.ins == -2;
        }
        get len2() {
          return this.ins < 0 ? this.len : this.ins;
        }
        get text() {
          let { inserted: e } = this.set, n = this.i - 2 >> 1;
          return n >= e.length ? He.empty : e[n];
        }
        textBit(e) {
          let { inserted: n } = this.set, r = this.i - 2 >> 1;
          return r >= n.length && !e ? He.empty : n[r].slice(this.off, e == null ? void 0 : this.off + e);
        }
        forward(e) {
          e == this.len ? this.next() : (this.len -= e, this.off += e);
        }
        forward2(e) {
          this.ins == -1 ? this.forward(e) : e == this.ins ? this.next() : (this.ins -= e, this.off += e);
        }
      }
      class As {
        constructor(e, n, r) {
          this.from = e, this.to = n, this.flags = r;
        }
        get anchor() {
          return this.flags & 32 ? this.to : this.from;
        }
        get head() {
          return this.flags & 32 ? this.from : this.to;
        }
        get empty() {
          return this.from == this.to;
        }
        get assoc() {
          return this.flags & 8 ? -1 : this.flags & 16 ? 1 : 0;
        }
        get bidiLevel() {
          let e = this.flags & 7;
          return e == 7 ? null : e;
        }
        get goalColumn() {
          let e = this.flags >> 6;
          return e == 16777215 ? void 0 : e;
        }
        map(e, n = -1) {
          let r, i;
          return this.empty ? r = i = e.mapPos(this.from, n) : (r = e.mapPos(this.from, 1), i = e.mapPos(this.to, -1)), r == this.from && i == this.to ? this : new As(r, i, this.flags);
        }
        extend(e, n = e) {
          if (e <= this.anchor && n >= this.anchor)
            return q.range(e, n);
          let r = Math.abs(e - this.anchor) > Math.abs(n - this.anchor) ? e : n;
          return q.range(this.anchor, r);
        }
        eq(e, n = false) {
          return this.anchor == e.anchor && this.head == e.head && (!n || !this.empty || this.assoc == e.assoc);
        }
        toJSON() {
          return {
            anchor: this.anchor,
            head: this.head
          };
        }
        static fromJSON(e) {
          if (!e || typeof e.anchor != "number" || typeof e.head != "number")
            throw new RangeError("Invalid JSON representation for SelectionRange");
          return q.range(e.anchor, e.head);
        }
        static create(e, n, r) {
          return new As(e, n, r);
        }
      }
      class q {
        constructor(e, n) {
          this.ranges = e, this.mainIndex = n;
        }
        map(e, n = -1) {
          return e.empty ? this : q.create(this.ranges.map((r) => r.map(e, n)), this.mainIndex);
        }
        eq(e, n = false) {
          if (this.ranges.length != e.ranges.length || this.mainIndex != e.mainIndex)
            return false;
          for (let r = 0; r < this.ranges.length; r++)
            if (!this.ranges[r].eq(e.ranges[r], n))
              return false;
          return true;
        }
        get main() {
          return this.ranges[this.mainIndex];
        }
        asSingle() {
          return this.ranges.length == 1 ? this : new q([
            this.main
          ], 0);
        }
        addRange(e, n = true) {
          return q.create([
            e
          ].concat(this.ranges), n ? 0 : this.mainIndex + 1);
        }
        replaceRange(e, n = this.mainIndex) {
          let r = this.ranges.slice();
          return r[n] = e, q.create(r, this.mainIndex);
        }
        toJSON() {
          return {
            ranges: this.ranges.map((e) => e.toJSON()),
            main: this.mainIndex
          };
        }
        static fromJSON(e) {
          if (!e || !Array.isArray(e.ranges) || typeof e.main != "number" || e.main >= e.ranges.length)
            throw new RangeError("Invalid JSON representation for EditorSelection");
          return new q(e.ranges.map((n) => As.fromJSON(n)), e.main);
        }
        static single(e, n = e) {
          return new q([
            q.range(e, n)
          ], 0);
        }
        static create(e, n = 0) {
          if (e.length == 0)
            throw new RangeError("A selection needs at least one range");
          for (let r = 0, i = 0; i < e.length; i++) {
            let o = e[i];
            if (o.empty ? o.from <= r : o.from < r)
              return q.normalized(e.slice(), n);
            r = o.to;
          }
          return new q(e, n);
        }
        static cursor(e, n = 0, r, i) {
          return As.create(e, e, (n == 0 ? 0 : n < 0 ? 8 : 16) | (r == null ? 7 : Math.min(6, r)) | (i ?? 16777215) << 6);
        }
        static range(e, n, r, i) {
          let o = (r ?? 16777215) << 6 | (i == null ? 7 : Math.min(6, i));
          return n < e ? As.create(n, e, 48 | o) : As.create(e, n, (n > e ? 8 : 0) | o);
        }
        static normalized(e, n = 0) {
          let r = e[n];
          e.sort((i, o) => i.from - o.from), n = e.indexOf(r);
          for (let i = 1; i < e.length; i++) {
            let o = e[i], s = e[i - 1];
            if (o.empty ? o.from <= s.to : o.from < s.to) {
              let a = s.from, l = Math.max(o.to, s.to);
              i <= n && n--, e.splice(--i, 2, o.anchor > o.head ? q.range(l, a) : q.range(a, l));
            }
          }
          return new q(e, n);
        }
      }
      function fO(t, e) {
        for (let n of t.ranges)
          if (n.to > e)
            throw new RangeError("Selection points outside of document");
      }
      let wx = 0;
      class pe {
        constructor(e, n, r, i, o) {
          this.combine = e, this.compareInput = n, this.compare = r, this.isStatic = i, this.id = wx++, this.default = e([]), this.extensions = typeof o == "function" ? o(this) : o;
        }
        get reader() {
          return this;
        }
        static define(e = {}) {
          return new pe(e.combine || ((n) => n), e.compareInput || ((n, r) => n === r), e.compare || (e.combine ? (n, r) => n === r : kx), !!e.static, e.enables);
        }
        of(e) {
          return new yd([], this, 0, e);
        }
        compute(e, n) {
          if (this.isStatic)
            throw new Error("Can't compute a static facet");
          return new yd(e, this, 1, n);
        }
        computeN(e, n) {
          if (this.isStatic)
            throw new Error("Can't compute a static facet");
          return new yd(e, this, 2, n);
        }
        from(e, n) {
          return n || (n = (r) => r), this.compute([
            e
          ], (r) => n(r.field(e)));
        }
      }
      function kx(t, e) {
        return t == e || t.length == e.length && t.every((n, r) => n === e[r]);
      }
      class yd {
        constructor(e, n, r, i) {
          this.dependencies = e, this.facet = n, this.type = r, this.value = i, this.id = wx++;
        }
        dynamicSlot(e) {
          var n;
          let r = this.value, i = this.facet.compareInput, o = this.id, s = e[o] >> 1, a = this.type == 2, l = false, c = false, u = [];
          for (let h of this.dependencies)
            h == "doc" ? l = true : h == "selection" ? c = true : (((n = e[h.id]) !== null && n !== void 0 ? n : 1) & 1) == 0 && u.push(e[h.id]);
          return {
            create(h) {
              return h.values[s] = r(h), 1;
            },
            update(h, p) {
              if (l && p.docChanged || c && (p.docChanged || p.selection) || By(h, u)) {
                let v = r(h);
                if (a ? !dC(v, h.values[s], i) : !i(v, h.values[s]))
                  return h.values[s] = v, 1;
              }
              return 0;
            },
            reconfigure: (h, p) => {
              let v, y = p.config.address[o];
              if (y != null) {
                let S = yp(p, y);
                if (this.dependencies.every((C) => C instanceof pe ? p.facet(C) === h.facet(C) : C instanceof Ut ? p.field(C, false) == h.field(C, false) : true) || (a ? dC(v = r(h), S, i) : i(v = r(h), S)))
                  return h.values[s] = S, 0;
              } else
                v = r(h);
              return h.values[s] = v, 1;
            }
          };
        }
      }
      function dC(t, e, n) {
        if (t.length != e.length)
          return false;
        for (let r = 0; r < t.length; r++)
          if (!n(t[r], e[r]))
            return false;
        return true;
      }
      function By(t, e) {
        let n = false;
        for (let r of e)
          Yc(t, r) & 1 && (n = true);
        return n;
      }
      function IW(t, e, n) {
        let r = n.map((l) => t[l.id]), i = n.map((l) => l.type), o = r.filter((l) => !(l & 1)), s = t[e.id] >> 1;
        function a(l) {
          let c = [];
          for (let u = 0; u < r.length; u++) {
            let h = yp(l, r[u]);
            if (i[u] == 2)
              for (let p of h)
                c.push(p);
            else
              c.push(h);
          }
          return e.combine(c);
        }
        return {
          create(l) {
            for (let c of r)
              Yc(l, c);
            return l.values[s] = a(l), 1;
          },
          update(l, c) {
            if (!By(l, o))
              return 0;
            let u = a(l);
            return e.compare(u, l.values[s]) ? 0 : (l.values[s] = u, 1);
          },
          reconfigure(l, c) {
            let u = By(l, r), h = c.config.facets[e.id], p = c.facet(e);
            if (h && !u && kx(n, h))
              return l.values[s] = p, 0;
            let v = a(l);
            return e.compare(v, p) ? (l.values[s] = p, 0) : (l.values[s] = v, 1);
          }
        };
      }
      const vh = pe.define({
        static: true
      });
      class Ut {
        constructor(e, n, r, i, o) {
          this.id = e, this.createF = n, this.updateF = r, this.compareF = i, this.spec = o, this.provides = void 0;
        }
        static define(e) {
          let n = new Ut(wx++, e.create, e.update, e.compare || ((r, i) => r === i), e);
          return e.provide && (n.provides = e.provide(n)), n;
        }
        create(e) {
          let n = e.facet(vh).find((r) => r.field == this);
          return ((n == null ? void 0 : n.create) || this.createF)(e);
        }
        slot(e) {
          let n = e[this.id] >> 1;
          return {
            create: (r) => (r.values[n] = this.create(r), 1),
            update: (r, i) => {
              let o = r.values[n], s = this.updateF(o, i);
              return this.compareF(o, s) ? 0 : (r.values[n] = s, 1);
            },
            reconfigure: (r, i) => {
              let o = r.facet(vh), s = i.facet(vh), a;
              return (a = o.find((l) => l.field == this)) && a != s.find((l) => l.field == this) ? (r.values[n] = a.create(r), 1) : i.config.address[this.id] != null ? (r.values[n] = i.field(this), 0) : (r.values[n] = this.create(r), 1);
            }
          };
        }
        init(e) {
          return [
            this,
            vh.of({
              field: this,
              create: e
            })
          ];
        }
        get extension() {
          return this;
        }
      }
      const xs = {
        lowest: 4,
        low: 3,
        default: 2,
        high: 1,
        highest: 0
      };
      function rc(t) {
        return (e) => new hO(e, t);
      }
      const ns = {
        highest: rc(xs.highest),
        high: rc(xs.high),
        default: rc(xs.default),
        low: rc(xs.low),
        lowest: rc(xs.lowest)
      };
      class hO {
        constructor(e, n) {
          this.inner = e, this.prec = n;
        }
      }
      class zm {
        of(e) {
          return new Ny(this, e);
        }
        reconfigure(e) {
          return zm.reconfigure.of({
            compartment: this,
            extension: e
          });
        }
        get(e) {
          return e.config.compartments.get(this);
        }
      }
      class Ny {
        constructor(e, n) {
          this.compartment = e, this.inner = n;
        }
      }
      class vp {
        constructor(e, n, r, i, o, s) {
          for (this.base = e, this.compartments = n, this.dynamicSlots = r, this.address = i, this.staticValues = o, this.facets = s, this.statusTemplate = []; this.statusTemplate.length < r.length; )
            this.statusTemplate.push(0);
        }
        staticFacet(e) {
          let n = this.address[e.id];
          return n == null ? e.default : this.staticValues[n >> 1];
        }
        static resolve(e, n, r) {
          let i = [], o = /* @__PURE__ */ Object.create(null), s = /* @__PURE__ */ new Map();
          for (let p of BW(e, n, s))
            p instanceof Ut ? i.push(p) : (o[p.facet.id] || (o[p.facet.id] = [])).push(p);
          let a = /* @__PURE__ */ Object.create(null), l = [], c = [];
          for (let p of i)
            a[p.id] = c.length << 1, c.push((v) => p.slot(v));
          let u = r == null ? void 0 : r.config.facets;
          for (let p in o) {
            let v = o[p], y = v[0].facet, S = u && u[p] || [];
            if (v.every((C) => C.type == 0))
              if (a[y.id] = l.length << 1 | 1, kx(S, v))
                l.push(r.facet(y));
              else {
                let C = y.combine(v.map((w) => w.value));
                l.push(r && y.compare(C, r.facet(y)) ? r.facet(y) : C);
              }
            else {
              for (let C of v)
                C.type == 0 ? (a[C.id] = l.length << 1 | 1, l.push(C.value)) : (a[C.id] = c.length << 1, c.push((w) => C.dynamicSlot(w)));
              a[y.id] = c.length << 1, c.push((C) => IW(C, y, v));
            }
          }
          let h = c.map((p) => p(a));
          return new vp(e, s, h, a, l, o);
        }
      }
      function BW(t, e, n) {
        let r = [
          [],
          [],
          [],
          [],
          []
        ], i = /* @__PURE__ */ new Map();
        function o(s, a) {
          let l = i.get(s);
          if (l != null) {
            if (l <= a)
              return;
            let c = r[l].indexOf(s);
            c > -1 && r[l].splice(c, 1), s instanceof Ny && n.delete(s.compartment);
          }
          if (i.set(s, a), Array.isArray(s))
            for (let c of s)
              o(c, a);
          else if (s instanceof Ny) {
            if (n.has(s.compartment))
              throw new RangeError("Duplicate use of compartment in extensions");
            let c = e.get(s.compartment) || s.inner;
            n.set(s.compartment, c), o(c, a);
          } else if (s instanceof hO)
            o(s.inner, s.prec);
          else if (s instanceof Ut)
            r[a].push(s), s.provides && o(s.provides, a);
          else if (s instanceof yd)
            r[a].push(s), s.facet.extensions && o(s.facet.extensions, xs.default);
          else {
            let c = s.extension;
            if (!c)
              throw new Error(`Unrecognized extension value in extension set (${s}). This sometimes happens because multiple instances of @codemirror/state are loaded, breaking instanceof checks.`);
            o(c, a);
          }
        }
        return o(t, xs.default), r.reduce((s, a) => s.concat(a));
      }
      function Yc(t, e) {
        if (e & 1)
          return 2;
        let n = e >> 1, r = t.status[n];
        if (r == 4)
          throw new Error("Cyclic dependency between fields and/or facets");
        if (r & 2)
          return r;
        t.status[n] = 4;
        let i = t.computeSlot(t, t.config.dynamicSlots[n]);
        return t.status[n] = 2 | i;
      }
      function yp(t, e) {
        return e & 1 ? t.config.staticValues[e >> 1] : t.values[e >> 1];
      }
      const dO = pe.define(), $y = pe.define({
        combine: (t) => t.some((e) => e),
        static: true
      }), pO = pe.define({
        combine: (t) => t.length ? t[0] : void 0,
        static: true
      }), mO = pe.define(), gO = pe.define(), vO = pe.define(), yO = pe.define({
        combine: (t) => t.length ? t[0] : false
      });
      class Ai {
        constructor(e, n) {
          this.type = e, this.value = n;
        }
        static define() {
          return new NW();
        }
      }
      class NW {
        of(e) {
          return new Ai(this, e);
        }
      }
      class $W {
        constructor(e) {
          this.map = e;
        }
        of(e) {
          return new Pe(this, e);
        }
      }
      class Pe {
        constructor(e, n) {
          this.type = e, this.value = n;
        }
        map(e) {
          let n = this.type.map(this.value, e);
          return n === void 0 ? void 0 : n == this.value ? this : new Pe(this.type, n);
        }
        is(e) {
          return this.type == e;
        }
        static define(e = {}) {
          return new $W(e.map || ((n) => n));
        }
        static mapEffects(e, n) {
          if (!e.length)
            return e;
          let r = [];
          for (let i of e) {
            let o = i.map(n);
            o && r.push(o);
          }
          return r;
        }
      }
      Pe.reconfigure = Pe.define();
      Pe.appendConfig = Pe.define();
      class Bt {
        constructor(e, n, r, i, o, s) {
          this.startState = e, this.changes = n, this.selection = r, this.effects = i, this.annotations = o, this.scrollIntoView = s, this._doc = null, this._state = null, r && fO(r, n.newLength), o.some((a) => a.type == Bt.time) || (this.annotations = o.concat(Bt.time.of(Date.now())));
        }
        static create(e, n, r, i, o, s) {
          return new Bt(e, n, r, i, o, s);
        }
        get newDoc() {
          return this._doc || (this._doc = this.changes.apply(this.startState.doc));
        }
        get newSelection() {
          return this.selection || this.startState.selection.map(this.changes);
        }
        get state() {
          return this._state || this.startState.applyTransaction(this), this._state;
        }
        annotation(e) {
          for (let n of this.annotations)
            if (n.type == e)
              return n.value;
        }
        get docChanged() {
          return !this.changes.empty;
        }
        get reconfigured() {
          return this.startState.config != this.state.config;
        }
        isUserEvent(e) {
          let n = this.annotation(Bt.userEvent);
          return !!(n && (n == e || n.length > e.length && n.slice(0, e.length) == e && n[e.length] == "."));
        }
      }
      Bt.time = Ai.define();
      Bt.userEvent = Ai.define();
      Bt.addToHistory = Ai.define();
      Bt.remote = Ai.define();
      function zW(t, e) {
        let n = [];
        for (let r = 0, i = 0; ; ) {
          let o, s;
          if (r < t.length && (i == e.length || e[i] >= t[r]))
            o = t[r++], s = t[r++];
          else if (i < e.length)
            o = e[i++], s = e[i++];
          else
            return n;
          !n.length || n[n.length - 1] < o ? n.push(o, s) : n[n.length - 1] < s && (n[n.length - 1] = s);
        }
      }
      function bO(t, e, n) {
        var r;
        let i, o, s;
        return n ? (i = e.changes, o = _t.empty(e.changes.length), s = t.changes.compose(e.changes)) : (i = e.changes.map(t.changes), o = t.changes.mapDesc(e.changes, true), s = t.changes.compose(i)), {
          changes: s,
          selection: e.selection ? e.selection.map(o) : (r = t.selection) === null || r === void 0 ? void 0 : r.map(i),
          effects: Pe.mapEffects(t.effects, i).concat(Pe.mapEffects(e.effects, o)),
          annotations: t.annotations.length ? t.annotations.concat(e.annotations) : e.annotations,
          scrollIntoView: t.scrollIntoView || e.scrollIntoView
        };
      }
      function zy(t, e, n) {
        let r = e.selection, i = qa(e.annotations);
        return e.userEvent && (i = i.concat(Bt.userEvent.of(e.userEvent))), {
          changes: e.changes instanceof _t ? e.changes : _t.of(e.changes || [], n, t.facet(pO)),
          selection: r && (r instanceof q ? r : q.single(r.anchor, r.head)),
          effects: qa(e.effects),
          annotations: i,
          scrollIntoView: !!e.scrollIntoView
        };
      }
      function xO(t, e, n) {
        let r = zy(t, e.length ? e[0] : {}, t.doc.length);
        e.length && e[0].filter === false && (n = false);
        for (let o = 1; o < e.length; o++) {
          e[o].filter === false && (n = false);
          let s = !!e[o].sequential;
          r = bO(r, zy(t, e[o], s ? r.changes.newLength : t.doc.length), s);
        }
        let i = Bt.create(t, r.changes, r.selection, r.effects, r.annotations, r.scrollIntoView);
        return VW(n ? FW(i) : i);
      }
      function FW(t) {
        let e = t.startState, n = true;
        for (let i of e.facet(mO)) {
          let o = i(t);
          if (o === false) {
            n = false;
            break;
          }
          Array.isArray(o) && (n = n === true ? o : zW(n, o));
        }
        if (n !== true) {
          let i, o;
          if (n === false)
            o = t.changes.invertedDesc, i = _t.empty(e.doc.length);
          else {
            let s = t.changes.filter(n);
            i = s.changes, o = s.filtered.mapDesc(s.changes).invertedDesc;
          }
          t = Bt.create(e, i, t.selection && t.selection.map(o), Pe.mapEffects(t.effects, o), t.annotations, t.scrollIntoView);
        }
        let r = e.facet(gO);
        for (let i = r.length - 1; i >= 0; i--) {
          let o = r[i](t);
          o instanceof Bt ? t = o : Array.isArray(o) && o.length == 1 && o[0] instanceof Bt ? t = o[0] : t = xO(e, qa(o), false);
        }
        return t;
      }
      function VW(t) {
        let e = t.startState, n = e.facet(vO), r = t;
        for (let i = n.length - 1; i >= 0; i--) {
          let o = n[i](t);
          o && Object.keys(o).length && (r = bO(r, zy(e, o, t.changes.newLength), true));
        }
        return r == t ? t : Bt.create(e, t.changes, t.selection, r.effects, r.annotations, r.scrollIntoView);
      }
      const HW = [];
      function qa(t) {
        return t == null ? HW : Array.isArray(t) ? t : [
          t
        ];
      }
      var ht = function(t) {
        return t[t.Word = 0] = "Word", t[t.Space = 1] = "Space", t[t.Other = 2] = "Other", t;
      }(ht || (ht = {}));
      const jW = /[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/;
      let Fy;
      try {
        Fy = new RegExp("[\\p{Alphabetic}\\p{Number}_]", "u");
      } catch {
      }
      function WW(t) {
        if (Fy)
          return Fy.test(t);
        for (let e = 0; e < t.length; e++) {
          let n = t[e];
          if (/\w/.test(n) || n > "\x80" && (n.toUpperCase() != n.toLowerCase() || jW.test(n)))
            return true;
        }
        return false;
      }
      function UW(t) {
        return (e) => {
          if (!/\S/.test(e))
            return ht.Space;
          if (WW(e))
            return ht.Word;
          for (let n = 0; n < t.length; n++)
            if (e.indexOf(t[n]) > -1)
              return ht.Word;
          return ht.Other;
        };
      }
      class Ne {
        constructor(e, n, r, i, o, s) {
          this.config = e, this.doc = n, this.selection = r, this.values = i, this.status = e.statusTemplate.slice(), this.computeSlot = o, s && (s._state = this);
          for (let a = 0; a < this.config.dynamicSlots.length; a++)
            Yc(this, a << 1);
          this.computeSlot = null;
        }
        field(e, n = true) {
          let r = this.config.address[e.id];
          if (r == null) {
            if (n)
              throw new RangeError("Field is not present in this state");
            return;
          }
          return Yc(this, r), yp(this, r);
        }
        update(...e) {
          return xO(this, e, true);
        }
        applyTransaction(e) {
          let n = this.config, { base: r, compartments: i } = n;
          for (let a of e.effects)
            a.is(zm.reconfigure) ? (n && (i = /* @__PURE__ */ new Map(), n.compartments.forEach((l, c) => i.set(c, l)), n = null), i.set(a.value.compartment, a.value.extension)) : a.is(Pe.reconfigure) ? (n = null, r = a.value) : a.is(Pe.appendConfig) && (n = null, r = qa(r).concat(a.value));
          let o;
          n ? o = e.startState.values.slice() : (n = vp.resolve(r, i, this), o = new Ne(n, this.doc, this.selection, n.dynamicSlots.map(() => null), (l, c) => c.reconfigure(l, this), null).values);
          let s = e.startState.facet($y) ? e.newSelection : e.newSelection.asSingle();
          new Ne(n, e.newDoc, s, o, (a, l) => l.update(a, e), e);
        }
        replaceSelection(e) {
          return typeof e == "string" && (e = this.toText(e)), this.changeByRange((n) => ({
            changes: {
              from: n.from,
              to: n.to,
              insert: e
            },
            range: q.cursor(n.from + e.length)
          }));
        }
        changeByRange(e) {
          let n = this.selection, r = e(n.ranges[0]), i = this.changes(r.changes), o = [
            r.range
          ], s = qa(r.effects);
          for (let a = 1; a < n.ranges.length; a++) {
            let l = e(n.ranges[a]), c = this.changes(l.changes), u = c.map(i);
            for (let p = 0; p < a; p++)
              o[p] = o[p].map(u);
            let h = i.mapDesc(c, true);
            o.push(l.range.map(h)), i = i.compose(u), s = Pe.mapEffects(s, u).concat(Pe.mapEffects(qa(l.effects), h));
          }
          return {
            changes: i,
            selection: q.create(o, n.mainIndex),
            effects: s
          };
        }
        changes(e = []) {
          return e instanceof _t ? e : _t.of(e, this.doc.length, this.facet(Ne.lineSeparator));
        }
        toText(e) {
          return He.of(e.split(this.facet(Ne.lineSeparator) || Dy));
        }
        sliceDoc(e = 0, n = this.doc.length) {
          return this.doc.sliceString(e, n, this.lineBreak);
        }
        facet(e) {
          let n = this.config.address[e.id];
          return n == null ? e.default : (Yc(this, n), yp(this, n));
        }
        toJSON(e) {
          let n = {
            doc: this.sliceDoc(),
            selection: this.selection.toJSON()
          };
          if (e)
            for (let r in e) {
              let i = e[r];
              i instanceof Ut && this.config.address[i.id] != null && (n[r] = i.spec.toJSON(this.field(e[r]), this));
            }
          return n;
        }
        static fromJSON(e, n = {}, r) {
          if (!e || typeof e.doc != "string")
            throw new RangeError("Invalid JSON representation for EditorState");
          let i = [];
          if (r) {
            for (let o in r)
              if (Object.prototype.hasOwnProperty.call(e, o)) {
                let s = r[o], a = e[o];
                i.push(s.init((l) => s.spec.fromJSON(a, l)));
              }
          }
          return Ne.create({
            doc: e.doc,
            selection: q.fromJSON(e.selection),
            extensions: n.extensions ? i.concat([
              n.extensions
            ]) : i
          });
        }
        static create(e = {}) {
          let n = vp.resolve(e.extensions || [], /* @__PURE__ */ new Map()), r = e.doc instanceof He ? e.doc : He.of((e.doc || "").split(n.staticFacet(Ne.lineSeparator) || Dy)), i = e.selection ? e.selection instanceof q ? e.selection : q.single(e.selection.anchor, e.selection.head) : q.single(0);
          return fO(i, r.length), n.staticFacet($y) || (i = i.asSingle()), new Ne(n, r, i, n.dynamicSlots.map(() => null), (o, s) => s.create(o), null);
        }
        get tabSize() {
          return this.facet(Ne.tabSize);
        }
        get lineBreak() {
          return this.facet(Ne.lineSeparator) || `
`;
        }
        get readOnly() {
          return this.facet(yO);
        }
        phrase(e, ...n) {
          for (let r of this.facet(Ne.phrases))
            if (Object.prototype.hasOwnProperty.call(r, e)) {
              e = r[e];
              break;
            }
          return n.length && (e = e.replace(/\$(\$|\d*)/g, (r, i) => {
            if (i == "$")
              return "$";
            let o = +(i || 1);
            return !o || o > n.length ? r : n[o - 1];
          })), e;
        }
        languageDataAt(e, n, r = -1) {
          let i = [];
          for (let o of this.facet(dO))
            for (let s of o(this, n, r))
              Object.prototype.hasOwnProperty.call(s, e) && i.push(s[e]);
          return i;
        }
        charCategorizer(e) {
          return UW(this.languageDataAt("wordChars", e).join(""));
        }
        wordAt(e) {
          let { text: n, from: r, length: i } = this.doc.lineAt(e), o = this.charCategorizer(e), s = e - r, a = e - r;
          for (; s > 0; ) {
            let l = en(n, s, false);
            if (o(n.slice(l, s)) != ht.Word)
              break;
            s = l;
          }
          for (; a < i; ) {
            let l = en(n, a);
            if (o(n.slice(a, l)) != ht.Word)
              break;
            a = l;
          }
          return s == a ? null : q.range(s + r, a + r);
        }
      }
      Ne.allowMultipleSelections = $y;
      Ne.tabSize = pe.define({
        combine: (t) => t.length ? t[0] : 4
      });
      Ne.lineSeparator = pO;
      Ne.readOnly = yO;
      Ne.phrases = pe.define({
        compare(t, e) {
          let n = Object.keys(t), r = Object.keys(e);
          return n.length == r.length && n.every((i) => t[i] == e[i]);
        }
      });
      Ne.languageData = dO;
      Ne.changeFilter = mO;
      Ne.transactionFilter = gO;
      Ne.transactionExtender = vO;
      zm.reconfigure = Pe.define();
      function Ei(t, e, n = {}) {
        let r = {};
        for (let i of t)
          for (let o of Object.keys(i)) {
            let s = i[o], a = r[o];
            if (a === void 0)
              r[o] = s;
            else if (!(a === s || s === void 0))
              if (Object.hasOwnProperty.call(n, o))
                r[o] = n[o](a, s);
              else
                throw new Error("Config merge conflict for field " + o);
          }
        for (let i in e)
          r[i] === void 0 && (r[i] = e[i]);
        return r;
      }
      class Hs {
        eq(e) {
          return this == e;
        }
        range(e, n = e) {
          return Lu.create(e, n, this);
        }
      }
      Hs.prototype.startSide = Hs.prototype.endSide = 0;
      Hs.prototype.point = false;
      Hs.prototype.mapMode = Zt.TrackDel;
      class Lu {
        constructor(e, n, r) {
          this.from = e, this.to = n, this.value = r;
        }
        static create(e, n, r) {
          return new Lu(e, n, r);
        }
      }
      function Vy(t, e) {
        return t.from - e.from || t.value.startSide - e.value.startSide;
      }
      class Cx {
        constructor(e, n, r, i) {
          this.from = e, this.to = n, this.value = r, this.maxPoint = i;
        }
        get length() {
          return this.to[this.to.length - 1];
        }
        findIndex(e, n, r, i = 0) {
          let o = r ? this.to : this.from;
          for (let s = i, a = o.length; ; ) {
            if (s == a)
              return s;
            let l = s + a >> 1, c = o[l] - e || (r ? this.value[l].endSide : this.value[l].startSide) - n;
            if (l == s)
              return c >= 0 ? s : a;
            c >= 0 ? a = l : s = l + 1;
          }
        }
        between(e, n, r, i) {
          for (let o = this.findIndex(n, -1e9, true), s = this.findIndex(r, 1e9, false, o); o < s; o++)
            if (i(this.from[o] + e, this.to[o] + e, this.value[o]) === false)
              return false;
        }
        map(e, n) {
          let r = [], i = [], o = [], s = -1, a = -1;
          for (let l = 0; l < this.value.length; l++) {
            let c = this.value[l], u = this.from[l] + e, h = this.to[l] + e, p, v;
            if (u == h) {
              let y = n.mapPos(u, c.startSide, c.mapMode);
              if (y == null || (p = v = y, c.startSide != c.endSide && (v = n.mapPos(u, c.endSide), v < p)))
                continue;
            } else if (p = n.mapPos(u, c.startSide), v = n.mapPos(h, c.endSide), p > v || p == v && c.startSide > 0 && c.endSide <= 0)
              continue;
            (v - p || c.endSide - c.startSide) < 0 || (s < 0 && (s = p), c.point && (a = Math.max(a, v - p)), r.push(c), i.push(p - s), o.push(v - s));
          }
          return {
            mapped: r.length ? new Cx(i, o, r, a) : null,
            pos: s
          };
        }
      }
      class Ve {
        constructor(e, n, r, i) {
          this.chunkPos = e, this.chunk = n, this.nextLayer = r, this.maxPoint = i;
        }
        static create(e, n, r, i) {
          return new Ve(e, n, r, i);
        }
        get length() {
          let e = this.chunk.length - 1;
          return e < 0 ? 0 : Math.max(this.chunkEnd(e), this.nextLayer.length);
        }
        get size() {
          if (this.isEmpty)
            return 0;
          let e = this.nextLayer.size;
          for (let n of this.chunk)
            e += n.value.length;
          return e;
        }
        chunkEnd(e) {
          return this.chunkPos[e] + this.chunk[e].length;
        }
        update(e) {
          let { add: n = [], sort: r = false, filterFrom: i = 0, filterTo: o = this.length } = e, s = e.filter;
          if (n.length == 0 && !s)
            return this;
          if (r && (n = n.slice().sort(Vy)), this.isEmpty)
            return n.length ? Ve.of(n) : this;
          let a = new SO(this, null, -1).goto(0), l = 0, c = [], u = new Ci();
          for (; a.value || l < n.length; )
            if (l < n.length && (a.from - n[l].from || a.startSide - n[l].value.startSide) >= 0) {
              let h = n[l++];
              u.addInner(h.from, h.to, h.value) || c.push(h);
            } else
              a.rangeIndex == 1 && a.chunkIndex < this.chunk.length && (l == n.length || this.chunkEnd(a.chunkIndex) < n[l].from) && (!s || i > this.chunkEnd(a.chunkIndex) || o < this.chunkPos[a.chunkIndex]) && u.addChunk(this.chunkPos[a.chunkIndex], this.chunk[a.chunkIndex]) ? a.nextChunk() : ((!s || i > a.to || o < a.from || s(a.from, a.to, a.value)) && (u.addInner(a.from, a.to, a.value) || c.push(Lu.create(a.from, a.to, a.value))), a.next());
          return u.finishInner(this.nextLayer.isEmpty && !c.length ? Ve.empty : this.nextLayer.update({
            add: c,
            filter: s,
            filterFrom: i,
            filterTo: o
          }));
        }
        map(e) {
          if (e.empty || this.isEmpty)
            return this;
          let n = [], r = [], i = -1;
          for (let s = 0; s < this.chunk.length; s++) {
            let a = this.chunkPos[s], l = this.chunk[s], c = e.touchesRange(a, a + l.length);
            if (c === false)
              i = Math.max(i, l.maxPoint), n.push(l), r.push(e.mapPos(a));
            else if (c === true) {
              let { mapped: u, pos: h } = l.map(a, e);
              u && (i = Math.max(i, u.maxPoint), n.push(u), r.push(h));
            }
          }
          let o = this.nextLayer.map(e);
          return n.length == 0 ? o : new Ve(r, n, o || Ve.empty, i);
        }
        between(e, n, r) {
          if (!this.isEmpty) {
            for (let i = 0; i < this.chunk.length; i++) {
              let o = this.chunkPos[i], s = this.chunk[i];
              if (n >= o && e <= o + s.length && s.between(o, e - o, n - o, r) === false)
                return;
            }
            this.nextLayer.between(e, n, r);
          }
        }
        iter(e = 0) {
          return Du.from([
            this
          ]).goto(e);
        }
        get isEmpty() {
          return this.nextLayer == this;
        }
        static iter(e, n = 0) {
          return Du.from(e).goto(n);
        }
        static compare(e, n, r, i, o = -1) {
          let s = e.filter((h) => h.maxPoint > 0 || !h.isEmpty && h.maxPoint >= o), a = n.filter((h) => h.maxPoint > 0 || !h.isEmpty && h.maxPoint >= o), l = pC(s, a, r), c = new ic(s, l, o), u = new ic(a, l, o);
          r.iterGaps((h, p, v) => mC(c, h, u, p, v, i)), r.empty && r.length == 0 && mC(c, 0, u, 0, 0, i);
        }
        static eq(e, n, r = 0, i) {
          i == null && (i = 1e9 - 1);
          let o = e.filter((u) => !u.isEmpty && n.indexOf(u) < 0), s = n.filter((u) => !u.isEmpty && e.indexOf(u) < 0);
          if (o.length != s.length)
            return false;
          if (!o.length)
            return true;
          let a = pC(o, s), l = new ic(o, a, 0).goto(r), c = new ic(s, a, 0).goto(r);
          for (; ; ) {
            if (l.to != c.to || !Hy(l.active, c.active) || l.point && (!c.point || !l.point.eq(c.point)))
              return false;
            if (l.to > i)
              return true;
            l.next(), c.next();
          }
        }
        static spans(e, n, r, i, o = -1) {
          let s = new ic(e, null, o).goto(n), a = n, l = s.openStart;
          for (; ; ) {
            let c = Math.min(s.to, r);
            if (s.point) {
              let u = s.activeForPoint(s.to), h = s.pointFrom < n ? u.length + 1 : s.point.startSide < 0 ? u.length : Math.min(u.length, l);
              i.point(a, c, s.point, u, h, s.pointRank), l = Math.min(s.openEnd(c), u.length);
            } else
              c > a && (i.span(a, c, s.active, l), l = s.openEnd(c));
            if (s.to > r)
              return l + (s.point && s.to > r ? 1 : 0);
            a = s.to, s.next();
          }
        }
        static of(e, n = false) {
          let r = new Ci();
          for (let i of e instanceof Lu ? [
            e
          ] : n ? KW(e) : e)
            r.add(i.from, i.to, i.value);
          return r.finish();
        }
        static join(e) {
          if (!e.length)
            return Ve.empty;
          let n = e[e.length - 1];
          for (let r = e.length - 2; r >= 0; r--)
            for (let i = e[r]; i != Ve.empty; i = i.nextLayer)
              n = new Ve(i.chunkPos, i.chunk, n, Math.max(i.maxPoint, n.maxPoint));
          return n;
        }
      }
      Ve.empty = new Ve([], [], null, -1);
      function KW(t) {
        if (t.length > 1)
          for (let e = t[0], n = 1; n < t.length; n++) {
            let r = t[n];
            if (Vy(e, r) > 0)
              return t.slice().sort(Vy);
            e = r;
          }
        return t;
      }
      Ve.empty.nextLayer = Ve.empty;
      class Ci {
        finishChunk(e) {
          this.chunks.push(new Cx(this.from, this.to, this.value, this.maxPoint)), this.chunkPos.push(this.chunkStart), this.chunkStart = -1, this.setMaxPoint = Math.max(this.setMaxPoint, this.maxPoint), this.maxPoint = -1, e && (this.from = [], this.to = [], this.value = []);
        }
        constructor() {
          this.chunks = [], this.chunkPos = [], this.chunkStart = -1, this.last = null, this.lastFrom = -1e9, this.lastTo = -1e9, this.from = [], this.to = [], this.value = [], this.maxPoint = -1, this.setMaxPoint = -1, this.nextLayer = null;
        }
        add(e, n, r) {
          this.addInner(e, n, r) || (this.nextLayer || (this.nextLayer = new Ci())).add(e, n, r);
        }
        addInner(e, n, r) {
          let i = e - this.lastTo || r.startSide - this.last.endSide;
          if (i <= 0 && (e - this.lastFrom || r.startSide - this.last.startSide) < 0)
            throw new Error("Ranges must be added sorted by `from` position and `startSide`");
          return i < 0 ? false : (this.from.length == 250 && this.finishChunk(true), this.chunkStart < 0 && (this.chunkStart = e), this.from.push(e - this.chunkStart), this.to.push(n - this.chunkStart), this.last = r, this.lastFrom = e, this.lastTo = n, this.value.push(r), r.point && (this.maxPoint = Math.max(this.maxPoint, n - e)), true);
        }
        addChunk(e, n) {
          if ((e - this.lastTo || n.value[0].startSide - this.last.endSide) < 0)
            return false;
          this.from.length && this.finishChunk(true), this.setMaxPoint = Math.max(this.setMaxPoint, n.maxPoint), this.chunks.push(n), this.chunkPos.push(e);
          let r = n.value.length - 1;
          return this.last = n.value[r], this.lastFrom = n.from[r] + e, this.lastTo = n.to[r] + e, true;
        }
        finish() {
          return this.finishInner(Ve.empty);
        }
        finishInner(e) {
          if (this.from.length && this.finishChunk(false), this.chunks.length == 0)
            return e;
          let n = Ve.create(this.chunkPos, this.chunks, this.nextLayer ? this.nextLayer.finishInner(e) : e, this.setMaxPoint);
          return this.from = null, n;
        }
      }
      function pC(t, e, n) {
        let r = /* @__PURE__ */ new Map();
        for (let o of t)
          for (let s = 0; s < o.chunk.length; s++)
            o.chunk[s].maxPoint <= 0 && r.set(o.chunk[s], o.chunkPos[s]);
        let i = /* @__PURE__ */ new Set();
        for (let o of e)
          for (let s = 0; s < o.chunk.length; s++) {
            let a = r.get(o.chunk[s]);
            a != null && (n ? n.mapPos(a) : a) == o.chunkPos[s] && !(n == null ? void 0 : n.touchesRange(a, a + o.chunk[s].length)) && i.add(o.chunk[s]);
          }
        return i;
      }
      class SO {
        constructor(e, n, r, i = 0) {
          this.layer = e, this.skip = n, this.minPoint = r, this.rank = i;
        }
        get startSide() {
          return this.value ? this.value.startSide : 0;
        }
        get endSide() {
          return this.value ? this.value.endSide : 0;
        }
        goto(e, n = -1e9) {
          return this.chunkIndex = this.rangeIndex = 0, this.gotoInner(e, n, false), this;
        }
        gotoInner(e, n, r) {
          for (; this.chunkIndex < this.layer.chunk.length; ) {
            let i = this.layer.chunk[this.chunkIndex];
            if (!(this.skip && this.skip.has(i) || this.layer.chunkEnd(this.chunkIndex) < e || i.maxPoint < this.minPoint))
              break;
            this.chunkIndex++, r = false;
          }
          if (this.chunkIndex < this.layer.chunk.length) {
            let i = this.layer.chunk[this.chunkIndex].findIndex(e - this.layer.chunkPos[this.chunkIndex], n, true);
            (!r || this.rangeIndex < i) && this.setRangeIndex(i);
          }
          this.next();
        }
        forward(e, n) {
          (this.to - e || this.endSide - n) < 0 && this.gotoInner(e, n, true);
        }
        next() {
          for (; ; )
            if (this.chunkIndex == this.layer.chunk.length) {
              this.from = this.to = 1e9, this.value = null;
              break;
            } else {
              let e = this.layer.chunkPos[this.chunkIndex], n = this.layer.chunk[this.chunkIndex], r = e + n.from[this.rangeIndex];
              if (this.from = r, this.to = e + n.to[this.rangeIndex], this.value = n.value[this.rangeIndex], this.setRangeIndex(this.rangeIndex + 1), this.minPoint < 0 || this.value.point && this.to - this.from >= this.minPoint)
                break;
            }
        }
        setRangeIndex(e) {
          if (e == this.layer.chunk[this.chunkIndex].value.length) {
            if (this.chunkIndex++, this.skip)
              for (; this.chunkIndex < this.layer.chunk.length && this.skip.has(this.layer.chunk[this.chunkIndex]); )
                this.chunkIndex++;
            this.rangeIndex = 0;
          } else
            this.rangeIndex = e;
        }
        nextChunk() {
          this.chunkIndex++, this.rangeIndex = 0, this.next();
        }
        compare(e) {
          return this.from - e.from || this.startSide - e.startSide || this.rank - e.rank || this.to - e.to || this.endSide - e.endSide;
        }
      }
      class Du {
        constructor(e) {
          this.heap = e;
        }
        static from(e, n = null, r = -1) {
          let i = [];
          for (let o = 0; o < e.length; o++)
            for (let s = e[o]; !s.isEmpty; s = s.nextLayer)
              s.maxPoint >= r && i.push(new SO(s, n, r, o));
          return i.length == 1 ? i[0] : new Du(i);
        }
        get startSide() {
          return this.value ? this.value.startSide : 0;
        }
        goto(e, n = -1e9) {
          for (let r of this.heap)
            r.goto(e, n);
          for (let r = this.heap.length >> 1; r >= 0; r--)
            R0(this.heap, r);
          return this.next(), this;
        }
        forward(e, n) {
          for (let r of this.heap)
            r.forward(e, n);
          for (let r = this.heap.length >> 1; r >= 0; r--)
            R0(this.heap, r);
          (this.to - e || this.value.endSide - n) < 0 && this.next();
        }
        next() {
          if (this.heap.length == 0)
            this.from = this.to = 1e9, this.value = null, this.rank = -1;
          else {
            let e = this.heap[0];
            this.from = e.from, this.to = e.to, this.value = e.value, this.rank = e.rank, e.value && e.next(), R0(this.heap, 0);
          }
        }
      }
      function R0(t, e) {
        for (let n = t[e]; ; ) {
          let r = (e << 1) + 1;
          if (r >= t.length)
            break;
          let i = t[r];
          if (r + 1 < t.length && i.compare(t[r + 1]) >= 0 && (i = t[r + 1], r++), n.compare(i) < 0)
            break;
          t[r] = n, t[e] = i, e = r;
        }
      }
      class ic {
        constructor(e, n, r) {
          this.minPoint = r, this.active = [], this.activeTo = [], this.activeRank = [], this.minActive = -1, this.point = null, this.pointFrom = 0, this.pointRank = 0, this.to = -1e9, this.endSide = 0, this.openStart = -1, this.cursor = Du.from(e, n, r);
        }
        goto(e, n = -1e9) {
          return this.cursor.goto(e, n), this.active.length = this.activeTo.length = this.activeRank.length = 0, this.minActive = -1, this.to = e, this.endSide = n, this.openStart = -1, this.next(), this;
        }
        forward(e, n) {
          for (; this.minActive > -1 && (this.activeTo[this.minActive] - e || this.active[this.minActive].endSide - n) < 0; )
            this.removeActive(this.minActive);
          this.cursor.forward(e, n);
        }
        removeActive(e) {
          yh(this.active, e), yh(this.activeTo, e), yh(this.activeRank, e), this.minActive = gC(this.active, this.activeTo);
        }
        addActive(e) {
          let n = 0, { value: r, to: i, rank: o } = this.cursor;
          for (; n < this.activeRank.length && (o - this.activeRank[n] || i - this.activeTo[n]) > 0; )
            n++;
          bh(this.active, n, r), bh(this.activeTo, n, i), bh(this.activeRank, n, o), e && bh(e, n, this.cursor.from), this.minActive = gC(this.active, this.activeTo);
        }
        next() {
          let e = this.to, n = this.point;
          this.point = null;
          let r = this.openStart < 0 ? [] : null;
          for (; ; ) {
            let i = this.minActive;
            if (i > -1 && (this.activeTo[i] - this.cursor.from || this.active[i].endSide - this.cursor.startSide) < 0) {
              if (this.activeTo[i] > e) {
                this.to = this.activeTo[i], this.endSide = this.active[i].endSide;
                break;
              }
              this.removeActive(i), r && yh(r, i);
            } else if (this.cursor.value)
              if (this.cursor.from > e) {
                this.to = this.cursor.from, this.endSide = this.cursor.startSide;
                break;
              } else {
                let o = this.cursor.value;
                if (!o.point)
                  this.addActive(r), this.cursor.next();
                else if (n && this.cursor.to == this.to && this.cursor.from < this.cursor.to)
                  this.cursor.next();
                else {
                  this.point = o, this.pointFrom = this.cursor.from, this.pointRank = this.cursor.rank, this.to = this.cursor.to, this.endSide = o.endSide, this.cursor.next(), this.forward(this.to, this.endSide);
                  break;
                }
              }
            else {
              this.to = this.endSide = 1e9;
              break;
            }
          }
          if (r) {
            this.openStart = 0;
            for (let i = r.length - 1; i >= 0 && r[i] < e; i--)
              this.openStart++;
          }
        }
        activeForPoint(e) {
          if (!this.active.length)
            return this.active;
          let n = [];
          for (let r = this.active.length - 1; r >= 0 && !(this.activeRank[r] < this.pointRank); r--)
            (this.activeTo[r] > e || this.activeTo[r] == e && this.active[r].endSide >= this.point.endSide) && n.push(this.active[r]);
          return n.reverse();
        }
        openEnd(e) {
          let n = 0;
          for (let r = this.activeTo.length - 1; r >= 0 && this.activeTo[r] > e; r--)
            n++;
          return n;
        }
      }
      function mC(t, e, n, r, i, o) {
        t.goto(e), n.goto(r);
        let s = r + i, a = r, l = r - e;
        for (; ; ) {
          let c = t.to + l - n.to, u = c || t.endSide - n.endSide, h = u < 0 ? t.to + l : n.to, p = Math.min(h, s);
          if (t.point || n.point ? t.point && n.point && (t.point == n.point || t.point.eq(n.point)) && Hy(t.activeForPoint(t.to), n.activeForPoint(n.to)) || o.comparePoint(a, p, t.point, n.point) : p > a && !Hy(t.active, n.active) && o.compareRange(a, p, t.active, n.active), h > s)
            break;
          (c || t.openEnd != n.openEnd) && o.boundChange && o.boundChange(h), a = h, u <= 0 && t.next(), u >= 0 && n.next();
        }
      }
      function Hy(t, e) {
        if (t.length != e.length)
          return false;
        for (let n = 0; n < t.length; n++)
          if (t[n] != e[n] && !t[n].eq(e[n]))
            return false;
        return true;
      }
      function yh(t, e) {
        for (let n = e, r = t.length - 1; n < r; n++)
          t[n] = t[n + 1];
        t.pop();
      }
      function bh(t, e, n) {
        for (let r = t.length - 1; r >= e; r--)
          t[r + 1] = t[r];
        t[e] = n;
      }
      function gC(t, e) {
        let n = -1, r = 1e9;
        for (let i = 0; i < e.length; i++)
          (e[i] - r || t[i].endSide - t[n].endSide) < 0 && (n = i, r = e[i]);
        return n;
      }
      function Al(t, e, n = t.length) {
        let r = 0;
        for (let i = 0; i < n && i < t.length; )
          t.charCodeAt(i) == 9 ? (r += e - r % e, i++) : (r++, i = en(t, i));
        return r;
      }
      function jy(t, e, n, r) {
        for (let i = 0, o = 0; ; ) {
          if (o >= e)
            return i;
          if (i == t.length)
            break;
          o += t.charCodeAt(i) == 9 ? n - o % n : 1, i = en(t, i);
        }
        return r === true ? -1 : t.length;
      }
      const Wy = "\u037C", vC = typeof Symbol > "u" ? "__" + Wy : Symbol.for(Wy), Uy = typeof Symbol > "u" ? "__styleSet" + Math.floor(Math.random() * 1e8) : Symbol("styleSet"), yC = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : {};
      class qo {
        constructor(e, n) {
          this.rules = [];
          let { finish: r } = n || {};
          function i(s) {
            return /^@/.test(s) ? [
              s
            ] : s.split(/,\s*/);
          }
          function o(s, a, l, c) {
            let u = [], h = /^@(\w+)\b/.exec(s[0]), p = h && h[1] == "keyframes";
            if (h && a == null)
              return l.push(s[0] + ";");
            for (let v in a) {
              let y = a[v];
              if (/&/.test(v))
                o(v.split(/,\s*/).map((S) => s.map((C) => S.replace(/&/, C))).reduce((S, C) => S.concat(C)), y, l);
              else if (y && typeof y == "object") {
                if (!h)
                  throw new RangeError("The value of a property (" + v + ") should be a primitive value.");
                o(i(v), y, u, p);
              } else
                y != null && u.push(v.replace(/_.*/, "").replace(/[A-Z]/g, (S) => "-" + S.toLowerCase()) + ": " + y + ";");
            }
            (u.length || p) && l.push((r && !h && !c ? s.map(r) : s).join(", ") + " {" + u.join(" ") + "}");
          }
          for (let s in e)
            o(i(s), e[s], this.rules);
        }
        getRules() {
          return this.rules.join(`
`);
        }
        static newName() {
          let e = yC[vC] || 1;
          return yC[vC] = e + 1, Wy + e.toString(36);
        }
        static mount(e, n, r) {
          let i = e[Uy], o = r && r.nonce;
          i ? o && i.setNonce(o) : i = new qW(e, o), i.mount(Array.isArray(n) ? n : [
            n
          ], e);
        }
      }
      let bC = /* @__PURE__ */ new Map();
      class qW {
        constructor(e, n) {
          let r = e.ownerDocument || e, i = r.defaultView;
          if (!e.head && e.adoptedStyleSheets && i.CSSStyleSheet) {
            let o = bC.get(r);
            if (o)
              return e[Uy] = o;
            this.sheet = new i.CSSStyleSheet(), bC.set(r, this);
          } else
            this.styleTag = r.createElement("style"), n && this.styleTag.setAttribute("nonce", n);
          this.modules = [], e[Uy] = this;
        }
        mount(e, n) {
          let r = this.sheet, i = 0, o = 0;
          for (let s = 0; s < e.length; s++) {
            let a = e[s], l = this.modules.indexOf(a);
            if (l < o && l > -1 && (this.modules.splice(l, 1), o--, l = -1), l == -1) {
              if (this.modules.splice(o++, 0, a), r)
                for (let c = 0; c < a.rules.length; c++)
                  r.insertRule(a.rules[c], i++);
            } else {
              for (; o < l; )
                i += this.modules[o++].rules.length;
              i += a.rules.length, o++;
            }
          }
          if (r)
            n.adoptedStyleSheets.indexOf(this.sheet) < 0 && (n.adoptedStyleSheets = [
              this.sheet,
              ...n.adoptedStyleSheets
            ]);
          else {
            let s = "";
            for (let l = 0; l < this.modules.length; l++)
              s += this.modules[l].getRules() + `
`;
            this.styleTag.textContent = s;
            let a = n.head || n;
            this.styleTag.parentNode != a && a.insertBefore(this.styleTag, a.firstChild);
          }
        }
        setNonce(e) {
          this.styleTag && this.styleTag.getAttribute("nonce") != e && this.styleTag.setAttribute("nonce", e);
        }
      }
      var Go = {
        8: "Backspace",
        9: "Tab",
        10: "Enter",
        12: "NumLock",
        13: "Enter",
        16: "Shift",
        17: "Control",
        18: "Alt",
        20: "CapsLock",
        27: "Escape",
        32: " ",
        33: "PageUp",
        34: "PageDown",
        35: "End",
        36: "Home",
        37: "ArrowLeft",
        38: "ArrowUp",
        39: "ArrowRight",
        40: "ArrowDown",
        44: "PrintScreen",
        45: "Insert",
        46: "Delete",
        59: ";",
        61: "=",
        91: "Meta",
        92: "Meta",
        106: "*",
        107: "+",
        108: ",",
        109: "-",
        110: ".",
        111: "/",
        144: "NumLock",
        145: "ScrollLock",
        160: "Shift",
        161: "Shift",
        162: "Control",
        163: "Control",
        164: "Alt",
        165: "Alt",
        173: "-",
        186: ";",
        187: "=",
        188: ",",
        189: "-",
        190: ".",
        191: "/",
        192: "`",
        219: "[",
        220: "\\",
        221: "]",
        222: "'"
      }, _u = {
        48: ")",
        49: "!",
        50: "@",
        51: "#",
        52: "$",
        53: "%",
        54: "^",
        55: "&",
        56: "*",
        57: "(",
        59: ":",
        61: "+",
        173: "_",
        186: ":",
        187: "+",
        188: "<",
        189: "_",
        190: ">",
        191: "?",
        192: "~",
        219: "{",
        220: "|",
        221: "}",
        222: '"'
      }, GW = typeof navigator < "u" && /Mac/.test(navigator.platform), YW = typeof navigator < "u" && /MSIE \d|Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(navigator.userAgent);
      for (var Qt = 0; Qt < 10; Qt++)
        Go[48 + Qt] = Go[96 + Qt] = String(Qt);
      for (var Qt = 1; Qt <= 24; Qt++)
        Go[Qt + 111] = "F" + Qt;
      for (var Qt = 65; Qt <= 90; Qt++)
        Go[Qt] = String.fromCharCode(Qt + 32), _u[Qt] = String.fromCharCode(Qt);
      for (var L0 in Go)
        _u.hasOwnProperty(L0) || (_u[L0] = Go[L0]);
      function XW(t) {
        var e = GW && t.metaKey && t.shiftKey && !t.ctrlKey && !t.altKey || YW && t.shiftKey && t.key && t.key.length == 1 || t.key == "Unidentified", n = !e && t.key || (t.shiftKey ? _u : Go)[t.keyCode] || t.key || "Unidentified";
        return n == "Esc" && (n = "Escape"), n == "Del" && (n = "Delete"), n == "Left" && (n = "ArrowLeft"), n == "Up" && (n = "ArrowUp"), n == "Right" && (n = "ArrowRight"), n == "Down" && (n = "ArrowDown"), n;
      }
      function Iu(t) {
        let e;
        return t.nodeType == 11 ? e = t.getSelection ? t : t.ownerDocument : e = t, e.getSelection();
      }
      function Ky(t, e) {
        return e ? t == e || t.contains(e.nodeType != 1 ? e.parentNode : e) : false;
      }
      function bd(t, e) {
        if (!e.anchorNode)
          return false;
        try {
          return Ky(t, e.anchorNode);
        } catch {
          return false;
        }
      }
      function hl(t) {
        return t.nodeType == 3 ? Ws(t, 0, t.nodeValue.length).getClientRects() : t.nodeType == 1 ? t.getClientRects() : [];
      }
      function Xc(t, e, n, r) {
        return n ? xC(t, e, n, r, -1) || xC(t, e, n, r, 1) : false;
      }
      function js(t) {
        for (var e = 0; ; e++)
          if (t = t.previousSibling, !t)
            return e;
      }
      function bp(t) {
        return t.nodeType == 1 && /^(DIV|P|LI|UL|OL|BLOCKQUOTE|DD|DT|H\d|SECTION|PRE)$/.test(t.nodeName);
      }
      function xC(t, e, n, r, i) {
        for (; ; ) {
          if (t == n && e == r)
            return true;
          if (e == (i < 0 ? 0 : Ti(t))) {
            if (t.nodeName == "DIV")
              return false;
            let o = t.parentNode;
            if (!o || o.nodeType != 1)
              return false;
            e = js(t) + (i < 0 ? 0 : 1), t = o;
          } else if (t.nodeType == 1) {
            if (t = t.childNodes[e + (i < 0 ? -1 : 0)], t.nodeType == 1 && t.contentEditable == "false")
              return false;
            e = i < 0 ? Ti(t) : 0;
          } else
            return false;
        }
      }
      function Ti(t) {
        return t.nodeType == 3 ? t.nodeValue.length : t.childNodes.length;
      }
      function rf(t, e) {
        let n = e ? t.left : t.right;
        return {
          left: n,
          right: n,
          top: t.top,
          bottom: t.bottom
        };
      }
      function QW(t) {
        let e = t.visualViewport;
        return e ? {
          left: 0,
          right: e.width,
          top: 0,
          bottom: e.height
        } : {
          left: 0,
          right: t.innerWidth,
          top: 0,
          bottom: t.innerHeight
        };
      }
      function wO(t, e) {
        let n = e.width / t.offsetWidth, r = e.height / t.offsetHeight;
        return (n > 0.995 && n < 1.005 || !isFinite(n) || Math.abs(e.width - t.offsetWidth) < 1) && (n = 1), (r > 0.995 && r < 1.005 || !isFinite(r) || Math.abs(e.height - t.offsetHeight) < 1) && (r = 1), {
          scaleX: n,
          scaleY: r
        };
      }
      function JW(t, e, n, r, i, o, s, a) {
        let l = t.ownerDocument, c = l.defaultView || window;
        for (let u = t, h = false; u && !h; )
          if (u.nodeType == 1) {
            let p, v = u == l.body, y = 1, S = 1;
            if (v)
              p = QW(c);
            else {
              if (/^(fixed|sticky)$/.test(getComputedStyle(u).position) && (h = true), u.scrollHeight <= u.clientHeight && u.scrollWidth <= u.clientWidth) {
                u = u.assignedSlot || u.parentNode;
                continue;
              }
              let k = u.getBoundingClientRect();
              ({ scaleX: y, scaleY: S } = wO(u, k)), p = {
                left: k.left,
                right: k.left + u.clientWidth * y,
                top: k.top,
                bottom: k.top + u.clientHeight * S
              };
            }
            let C = 0, w = 0;
            if (i == "nearest")
              e.top < p.top ? (w = e.top - (p.top + s), n > 0 && e.bottom > p.bottom + w && (w = e.bottom - p.bottom + s)) : e.bottom > p.bottom && (w = e.bottom - p.bottom + s, n < 0 && e.top - w < p.top && (w = e.top - (p.top + s)));
            else {
              let k = e.bottom - e.top, T = p.bottom - p.top;
              w = (i == "center" && k <= T ? e.top + k / 2 - T / 2 : i == "start" || i == "center" && n < 0 ? e.top - s : e.bottom - T + s) - p.top;
            }
            if (r == "nearest" ? e.left < p.left ? (C = e.left - (p.left + o), n > 0 && e.right > p.right + C && (C = e.right - p.right + o)) : e.right > p.right && (C = e.right - p.right + o, n < 0 && e.left < p.left + C && (C = e.left - (p.left + o))) : C = (r == "center" ? e.left + (e.right - e.left) / 2 - (p.right - p.left) / 2 : r == "start" == a ? e.left - o : e.right - (p.right - p.left) + o) - p.left, C || w)
              if (v)
                c.scrollBy(C, w);
              else {
                let k = 0, T = 0;
                if (w) {
                  let P = u.scrollTop;
                  u.scrollTop += w / S, T = (u.scrollTop - P) * S;
                }
                if (C) {
                  let P = u.scrollLeft;
                  u.scrollLeft += C / y, k = (u.scrollLeft - P) * y;
                }
                e = {
                  left: e.left - k,
                  top: e.top - T,
                  right: e.right - k,
                  bottom: e.bottom - T
                }, k && Math.abs(k - C) < 1 && (r = "nearest"), T && Math.abs(T - w) < 1 && (i = "nearest");
              }
            if (v)
              break;
            (e.top < p.top || e.bottom > p.bottom || e.left < p.left || e.right > p.right) && (e = {
              left: Math.max(e.left, p.left),
              right: Math.min(e.right, p.right),
              top: Math.max(e.top, p.top),
              bottom: Math.min(e.bottom, p.bottom)
            }), u = u.assignedSlot || u.parentNode;
          } else if (u.nodeType == 11)
            u = u.host;
          else
            break;
      }
      function ZW(t) {
        let e = t.ownerDocument, n, r;
        for (let i = t.parentNode; i && !(i == e.body || n && r); )
          if (i.nodeType == 1)
            !r && i.scrollHeight > i.clientHeight && (r = i), !n && i.scrollWidth > i.clientWidth && (n = i), i = i.assignedSlot || i.parentNode;
          else if (i.nodeType == 11)
            i = i.host;
          else
            break;
        return {
          x: n,
          y: r
        };
      }
      class e7 {
        constructor() {
          this.anchorNode = null, this.anchorOffset = 0, this.focusNode = null, this.focusOffset = 0;
        }
        eq(e) {
          return this.anchorNode == e.anchorNode && this.anchorOffset == e.anchorOffset && this.focusNode == e.focusNode && this.focusOffset == e.focusOffset;
        }
        setRange(e) {
          let { anchorNode: n, focusNode: r } = e;
          this.set(n, Math.min(e.anchorOffset, n ? Ti(n) : 0), r, Math.min(e.focusOffset, r ? Ti(r) : 0));
        }
        set(e, n, r, i) {
          this.anchorNode = e, this.anchorOffset = n, this.focusNode = r, this.focusOffset = i;
        }
      }
      let la = null;
      function kO(t) {
        if (t.setActive)
          return t.setActive();
        if (la)
          return t.focus(la);
        let e = [];
        for (let n = t; n && (e.push(n, n.scrollTop, n.scrollLeft), n != n.ownerDocument); n = n.parentNode)
          ;
        if (t.focus(la == null ? {
          get preventScroll() {
            return la = {
              preventScroll: true
            }, true;
          }
        } : void 0), !la) {
          la = false;
          for (let n = 0; n < e.length; ) {
            let r = e[n++], i = e[n++], o = e[n++];
            r.scrollTop != i && (r.scrollTop = i), r.scrollLeft != o && (r.scrollLeft = o);
          }
        }
      }
      let SC;
      function Ws(t, e, n = e) {
        let r = SC || (SC = document.createRange());
        return r.setEnd(t, n), r.setStart(t, e), r;
      }
      function Ga(t, e, n, r) {
        let i = {
          key: e,
          code: e,
          keyCode: n,
          which: n,
          cancelable: true
        };
        r && ({ altKey: i.altKey, ctrlKey: i.ctrlKey, shiftKey: i.shiftKey, metaKey: i.metaKey } = r);
        let o = new KeyboardEvent("keydown", i);
        o.synthetic = true, t.dispatchEvent(o);
        let s = new KeyboardEvent("keyup", i);
        return s.synthetic = true, t.dispatchEvent(s), o.defaultPrevented || s.defaultPrevented;
      }
      function t7(t) {
        for (; t; ) {
          if (t && (t.nodeType == 9 || t.nodeType == 11 && t.host))
            return t;
          t = t.assignedSlot || t.parentNode;
        }
        return null;
      }
      function CO(t) {
        for (; t.attributes.length; )
          t.removeAttributeNode(t.attributes[0]);
      }
      function n7(t, e) {
        let n = e.focusNode, r = e.focusOffset;
        if (!n || e.anchorNode != n || e.anchorOffset != r)
          return false;
        for (r = Math.min(r, Ti(n)); ; )
          if (r) {
            if (n.nodeType != 1)
              return false;
            let i = n.childNodes[r - 1];
            i.contentEditable == "false" ? r-- : (n = i, r = Ti(n));
          } else {
            if (n == t)
              return true;
            r = js(n), n = n.parentNode;
          }
      }
      function TO(t) {
        return t.scrollTop > Math.max(1, t.scrollHeight - t.clientHeight - 4);
      }
      function MO(t, e) {
        for (let n = t, r = e; ; ) {
          if (n.nodeType == 3 && r > 0)
            return {
              node: n,
              offset: r
            };
          if (n.nodeType == 1 && r > 0) {
            if (n.contentEditable == "false")
              return null;
            n = n.childNodes[r - 1], r = Ti(n);
          } else if (n.parentNode && !bp(n))
            r = js(n), n = n.parentNode;
          else
            return null;
        }
      }
      function AO(t, e) {
        for (let n = t, r = e; ; ) {
          if (n.nodeType == 3 && r < n.nodeValue.length)
            return {
              node: n,
              offset: r
            };
          if (n.nodeType == 1 && r < n.childNodes.length) {
            if (n.contentEditable == "false")
              return null;
            n = n.childNodes[r], r = 0;
          } else if (n.parentNode && !bp(n))
            r = js(n) + 1, n = n.parentNode;
          else
            return null;
        }
      }
      class hn {
        constructor(e, n, r = true) {
          this.node = e, this.offset = n, this.precise = r;
        }
        static before(e, n) {
          return new hn(e.parentNode, js(e), n);
        }
        static after(e, n) {
          return new hn(e.parentNode, js(e) + 1, n);
        }
      }
      const Tx = [];
      class Ze {
        constructor() {
          this.parent = null, this.dom = null, this.flags = 2;
        }
        get overrideDOMText() {
          return null;
        }
        get posAtStart() {
          return this.parent ? this.parent.posBefore(this) : 0;
        }
        get posAtEnd() {
          return this.posAtStart + this.length;
        }
        posBefore(e) {
          let n = this.posAtStart;
          for (let r of this.children) {
            if (r == e)
              return n;
            n += r.length + r.breakAfter;
          }
          throw new RangeError("Invalid child in posBefore");
        }
        posAfter(e) {
          return this.posBefore(e) + e.length;
        }
        sync(e, n) {
          if (this.flags & 2) {
            let r = this.dom, i = null, o;
            for (let s of this.children) {
              if (s.flags & 7) {
                if (!s.dom && (o = i ? i.nextSibling : r.firstChild)) {
                  let a = Ze.get(o);
                  (!a || !a.parent && a.canReuseDOM(s)) && s.reuseDOM(o);
                }
                s.sync(e, n), s.flags &= -8;
              }
              if (o = i ? i.nextSibling : r.firstChild, n && !n.written && n.node == r && o != s.dom && (n.written = true), s.dom.parentNode == r)
                for (; o && o != s.dom; )
                  o = wC(o);
              else
                r.insertBefore(s.dom, o);
              i = s.dom;
            }
            for (o = i ? i.nextSibling : r.firstChild, o && n && n.node == r && (n.written = true); o; )
              o = wC(o);
          } else if (this.flags & 1)
            for (let r of this.children)
              r.flags & 7 && (r.sync(e, n), r.flags &= -8);
        }
        reuseDOM(e) {
        }
        localPosFromDOM(e, n) {
          let r;
          if (e == this.dom)
            r = this.dom.childNodes[n];
          else {
            let i = Ti(e) == 0 ? 0 : n == 0 ? -1 : 1;
            for (; ; ) {
              let o = e.parentNode;
              if (o == this.dom)
                break;
              i == 0 && o.firstChild != o.lastChild && (e == o.firstChild ? i = -1 : i = 1), e = o;
            }
            i < 0 ? r = e : r = e.nextSibling;
          }
          if (r == this.dom.firstChild)
            return 0;
          for (; r && !Ze.get(r); )
            r = r.nextSibling;
          if (!r)
            return this.length;
          for (let i = 0, o = 0; ; i++) {
            let s = this.children[i];
            if (s.dom == r)
              return o;
            o += s.length + s.breakAfter;
          }
        }
        domBoundsAround(e, n, r = 0) {
          let i = -1, o = -1, s = -1, a = -1;
          for (let l = 0, c = r, u = r; l < this.children.length; l++) {
            let h = this.children[l], p = c + h.length;
            if (c < e && p > n)
              return h.domBoundsAround(e, n, c);
            if (p >= e && i == -1 && (i = l, o = c), c > n && h.dom.parentNode == this.dom) {
              s = l, a = u;
              break;
            }
            u = p, c = p + h.breakAfter;
          }
          return {
            from: o,
            to: a < 0 ? r + this.length : a,
            startDOM: (i ? this.children[i - 1].dom.nextSibling : null) || this.dom.firstChild,
            endDOM: s < this.children.length && s >= 0 ? this.children[s].dom : null
          };
        }
        markDirty(e = false) {
          this.flags |= 2, this.markParentsDirty(e);
        }
        markParentsDirty(e) {
          for (let n = this.parent; n; n = n.parent) {
            if (e && (n.flags |= 2), n.flags & 1)
              return;
            n.flags |= 1, e = false;
          }
        }
        setParent(e) {
          this.parent != e && (this.parent = e, this.flags & 7 && this.markParentsDirty(true));
        }
        setDOM(e) {
          this.dom != e && (this.dom && (this.dom.cmView = null), this.dom = e, e.cmView = this);
        }
        get rootView() {
          for (let e = this; ; ) {
            let n = e.parent;
            if (!n)
              return e;
            e = n;
          }
        }
        replaceChildren(e, n, r = Tx) {
          this.markDirty();
          for (let i = e; i < n; i++) {
            let o = this.children[i];
            o.parent == this && r.indexOf(o) < 0 && o.destroy();
          }
          r.length < 250 ? this.children.splice(e, n - e, ...r) : this.children = [].concat(this.children.slice(0, e), r, this.children.slice(n));
          for (let i = 0; i < r.length; i++)
            r[i].setParent(this);
        }
        ignoreMutation(e) {
          return false;
        }
        ignoreEvent(e) {
          return false;
        }
        childCursor(e = this.length) {
          return new EO(this.children, e, this.children.length);
        }
        childPos(e, n = 1) {
          return this.childCursor().findPos(e, n);
        }
        toString() {
          let e = this.constructor.name.replace("View", "");
          return e + (this.children.length ? "(" + this.children.join() + ")" : this.length ? "[" + (e == "Text" ? this.text : this.length) + "]" : "") + (this.breakAfter ? "#" : "");
        }
        static get(e) {
          return e.cmView;
        }
        get isEditable() {
          return true;
        }
        get isWidget() {
          return false;
        }
        get isHidden() {
          return false;
        }
        merge(e, n, r, i, o, s) {
          return false;
        }
        become(e) {
          return false;
        }
        canReuseDOM(e) {
          return e.constructor == this.constructor && !((this.flags | e.flags) & 8);
        }
        getSide() {
          return 0;
        }
        destroy() {
          for (let e of this.children)
            e.parent == this && e.destroy();
          this.parent = null;
        }
      }
      Ze.prototype.breakAfter = 0;
      function wC(t) {
        let e = t.nextSibling;
        return t.parentNode.removeChild(t), e;
      }
      class EO {
        constructor(e, n, r) {
          this.children = e, this.pos = n, this.i = r, this.off = 0;
        }
        findPos(e, n = 1) {
          for (; ; ) {
            if (e > this.pos || e == this.pos && (n > 0 || this.i == 0 || this.children[this.i - 1].breakAfter))
              return this.off = e - this.pos, this;
            let r = this.children[--this.i];
            this.pos -= r.length + r.breakAfter;
          }
        }
      }
      function PO(t, e, n, r, i, o, s, a, l) {
        let { children: c } = t, u = c.length ? c[e] : null, h = o.length ? o[o.length - 1] : null, p = h ? h.breakAfter : s;
        if (!(e == r && u && !s && !p && o.length < 2 && u.merge(n, i, o.length ? h : null, n == 0, a, l))) {
          if (r < c.length) {
            let v = c[r];
            v && (i < v.length || v.breakAfter && (h == null ? void 0 : h.breakAfter)) ? (e == r && (v = v.split(i), i = 0), !p && h && v.merge(0, i, h, true, 0, l) ? o[o.length - 1] = v : ((i || v.children.length && !v.children[0].length) && v.merge(0, i, null, false, 0, l), o.push(v))) : (v == null ? void 0 : v.breakAfter) && (h ? h.breakAfter = 1 : s = 1), r++;
          }
          for (u && (u.breakAfter = s, n > 0 && (!s && o.length && u.merge(n, u.length, o[0], false, a, 0) ? u.breakAfter = o.shift().breakAfter : (n < u.length || u.children.length && u.children[u.children.length - 1].length == 0) && u.merge(n, u.length, null, false, a, 0), e++)); e < r && o.length; )
            if (c[r - 1].become(o[o.length - 1]))
              r--, o.pop(), l = o.length ? 0 : a;
            else if (c[e].become(o[0]))
              e++, o.shift(), a = o.length ? 0 : l;
            else
              break;
          !o.length && e && r < c.length && !c[e - 1].breakAfter && c[r].merge(0, 0, c[e - 1], false, a, l) && e--, (e < r || o.length) && t.replaceChildren(e, r, o);
        }
      }
      function OO(t, e, n, r, i, o) {
        let s = t.childCursor(), { i: a, off: l } = s.findPos(n, 1), { i: c, off: u } = s.findPos(e, -1), h = e - n;
        for (let p of r)
          h += p.length;
        t.length += h, PO(t, c, u, a, l, r, 0, i, o);
      }
      let Ln = typeof navigator < "u" ? navigator : {
        userAgent: "",
        vendor: "",
        platform: ""
      }, qy = typeof document < "u" ? document : {
        documentElement: {
          style: {}
        }
      };
      const Gy = /Edge\/(\d+)/.exec(Ln.userAgent), RO = /MSIE \d/.test(Ln.userAgent), Yy = /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(Ln.userAgent), Fm = !!(RO || Yy || Gy), kC = !Fm && /gecko\/(\d+)/i.test(Ln.userAgent), D0 = !Fm && /Chrome\/(\d+)/.exec(Ln.userAgent), CC = "webkitFontSmoothing" in qy.documentElement.style, LO = !Fm && /Apple Computer/.test(Ln.vendor), TC = LO && (/Mobile\/\w+/.test(Ln.userAgent) || Ln.maxTouchPoints > 2);
      var de = {
        mac: TC || /Mac/.test(Ln.platform),
        windows: /Win/.test(Ln.platform),
        linux: /Linux|X11/.test(Ln.platform),
        ie: Fm,
        ie_version: RO ? qy.documentMode || 6 : Yy ? +Yy[1] : Gy ? +Gy[1] : 0,
        gecko: kC,
        gecko_version: kC ? +(/Firefox\/(\d+)/.exec(Ln.userAgent) || [
          0,
          0
        ])[1] : 0,
        chrome: !!D0,
        chrome_version: D0 ? +D0[1] : 0,
        ios: TC,
        android: /Android\b/.test(Ln.userAgent),
        webkit: CC,
        safari: LO,
        webkit_version: CC ? +(/\bAppleWebKit\/(\d+)/.exec(Ln.userAgent) || [
          0,
          0
        ])[1] : 0,
        tabSize: qy.documentElement.style.tabSize != null ? "tab-size" : "-moz-tab-size"
      };
      const r7 = 256;
      class Ur extends Ze {
        constructor(e) {
          super(), this.text = e;
        }
        get length() {
          return this.text.length;
        }
        createDOM(e) {
          this.setDOM(e || document.createTextNode(this.text));
        }
        sync(e, n) {
          this.dom || this.createDOM(), this.dom.nodeValue != this.text && (n && n.node == this.dom && (n.written = true), this.dom.nodeValue = this.text);
        }
        reuseDOM(e) {
          e.nodeType == 3 && this.createDOM(e);
        }
        merge(e, n, r) {
          return this.flags & 8 || r && (!(r instanceof Ur) || this.length - (n - e) + r.length > r7 || r.flags & 8) ? false : (this.text = this.text.slice(0, e) + (r ? r.text : "") + this.text.slice(n), this.markDirty(), true);
        }
        split(e) {
          let n = new Ur(this.text.slice(e));
          return this.text = this.text.slice(0, e), this.markDirty(), n.flags |= this.flags & 8, n;
        }
        localPosFromDOM(e, n) {
          return e == this.dom ? n : n ? this.text.length : 0;
        }
        domAtPos(e) {
          return new hn(this.dom, e);
        }
        domBoundsAround(e, n, r) {
          return {
            from: r,
            to: r + this.length,
            startDOM: this.dom,
            endDOM: this.dom.nextSibling
          };
        }
        coordsAt(e, n) {
          return i7(this.dom, e, n);
        }
      }
      class no extends Ze {
        constructor(e, n = [], r = 0) {
          super(), this.mark = e, this.children = n, this.length = r;
          for (let i of n)
            i.setParent(this);
        }
        setAttrs(e) {
          if (CO(e), this.mark.class && (e.className = this.mark.class), this.mark.attrs)
            for (let n in this.mark.attrs)
              e.setAttribute(n, this.mark.attrs[n]);
          return e;
        }
        canReuseDOM(e) {
          return super.canReuseDOM(e) && !((this.flags | e.flags) & 8);
        }
        reuseDOM(e) {
          e.nodeName == this.mark.tagName.toUpperCase() && (this.setDOM(e), this.flags |= 6);
        }
        sync(e, n) {
          this.dom ? this.flags & 4 && this.setAttrs(this.dom) : this.setDOM(this.setAttrs(document.createElement(this.mark.tagName))), super.sync(e, n);
        }
        merge(e, n, r, i, o, s) {
          return r && (!(r instanceof no && r.mark.eq(this.mark)) || e && o <= 0 || n < this.length && s <= 0) ? false : (OO(this, e, n, r ? r.children.slice() : [], o - 1, s - 1), this.markDirty(), true);
        }
        split(e) {
          let n = [], r = 0, i = -1, o = 0;
          for (let a of this.children) {
            let l = r + a.length;
            l > e && n.push(r < e ? a.split(e - r) : a), i < 0 && r >= e && (i = o), r = l, o++;
          }
          let s = this.length - e;
          return this.length = e, i > -1 && (this.children.length = i, this.markDirty()), new no(this.mark, n, s);
        }
        domAtPos(e) {
          return DO(this, e);
        }
        coordsAt(e, n) {
          return IO(this, e, n);
        }
      }
      function i7(t, e, n) {
        let r = t.nodeValue.length;
        e > r && (e = r);
        let i = e, o = e, s = 0;
        e == 0 && n < 0 || e == r && n >= 0 ? de.chrome || de.gecko || (e ? (i--, s = 1) : o < r && (o++, s = -1)) : n < 0 ? i-- : o < r && o++;
        let a = Ws(t, i, o).getClientRects();
        if (!a.length)
          return null;
        let l = a[(s ? s < 0 : n >= 0) ? 0 : a.length - 1];
        return de.safari && !s && l.width == 0 && (l = Array.prototype.find.call(a, (c) => c.width) || l), s ? rf(l, s < 0) : l || null;
      }
      class Do extends Ze {
        static create(e, n, r) {
          return new Do(e, n, r);
        }
        constructor(e, n, r) {
          super(), this.widget = e, this.length = n, this.side = r, this.prevWidget = null;
        }
        split(e) {
          let n = Do.create(this.widget, this.length - e, this.side);
          return this.length -= e, n;
        }
        sync(e) {
          (!this.dom || !this.widget.updateDOM(this.dom, e)) && (this.dom && this.prevWidget && this.prevWidget.destroy(this.dom), this.prevWidget = null, this.setDOM(this.widget.toDOM(e)), this.widget.editable || (this.dom.contentEditable = "false"));
        }
        getSide() {
          return this.side;
        }
        merge(e, n, r, i, o, s) {
          return r && (!(r instanceof Do) || !this.widget.compare(r.widget) || e > 0 && o <= 0 || n < this.length && s <= 0) ? false : (this.length = e + (r ? r.length : 0) + (this.length - n), true);
        }
        become(e) {
          return e instanceof Do && e.side == this.side && this.widget.constructor == e.widget.constructor ? (this.widget.compare(e.widget) || this.markDirty(true), this.dom && !this.prevWidget && (this.prevWidget = this.widget), this.widget = e.widget, this.length = e.length, true) : false;
        }
        ignoreMutation() {
          return true;
        }
        ignoreEvent(e) {
          return this.widget.ignoreEvent(e);
        }
        get overrideDOMText() {
          if (this.length == 0)
            return He.empty;
          let e = this;
          for (; e.parent; )
            e = e.parent;
          let { view: n } = e, r = n && n.state.doc, i = this.posAtStart;
          return r ? r.slice(i, i + this.length) : He.empty;
        }
        domAtPos(e) {
          return (this.length ? e == 0 : this.side > 0) ? hn.before(this.dom) : hn.after(this.dom, e == this.length);
        }
        domBoundsAround() {
          return null;
        }
        coordsAt(e, n) {
          let r = this.widget.coordsAt(this.dom, e, n);
          if (r)
            return r;
          let i = this.dom.getClientRects(), o = null;
          if (!i.length)
            return null;
          let s = this.side ? this.side < 0 : e > 0;
          for (let a = s ? i.length - 1 : 0; o = i[a], !(e > 0 ? a == 0 : a == i.length - 1 || o.top < o.bottom); a += s ? -1 : 1)
            ;
          return rf(o, !s);
        }
        get isEditable() {
          return false;
        }
        get isWidget() {
          return true;
        }
        get isHidden() {
          return this.widget.isHidden;
        }
        destroy() {
          super.destroy(), this.dom && this.widget.destroy(this.dom);
        }
      }
      class dl extends Ze {
        constructor(e) {
          super(), this.side = e;
        }
        get length() {
          return 0;
        }
        merge() {
          return false;
        }
        become(e) {
          return e instanceof dl && e.side == this.side;
        }
        split() {
          return new dl(this.side);
        }
        sync() {
          if (!this.dom) {
            let e = document.createElement("img");
            e.className = "cm-widgetBuffer", e.setAttribute("aria-hidden", "true"), this.setDOM(e);
          }
        }
        getSide() {
          return this.side;
        }
        domAtPos(e) {
          return this.side > 0 ? hn.before(this.dom) : hn.after(this.dom);
        }
        localPosFromDOM() {
          return 0;
        }
        domBoundsAround() {
          return null;
        }
        coordsAt(e) {
          return this.dom.getBoundingClientRect();
        }
        get overrideDOMText() {
          return He.empty;
        }
        get isHidden() {
          return true;
        }
      }
      Ur.prototype.children = Do.prototype.children = dl.prototype.children = Tx;
      function DO(t, e) {
        let n = t.dom, { children: r } = t, i = 0;
        for (let o = 0; i < r.length; i++) {
          let s = r[i], a = o + s.length;
          if (!(a == o && s.getSide() <= 0)) {
            if (e > o && e < a && s.dom.parentNode == n)
              return s.domAtPos(e - o);
            if (e <= o)
              break;
            o = a;
          }
        }
        for (let o = i; o > 0; o--) {
          let s = r[o - 1];
          if (s.dom.parentNode == n)
            return s.domAtPos(s.length);
        }
        for (let o = i; o < r.length; o++) {
          let s = r[o];
          if (s.dom.parentNode == n)
            return s.domAtPos(0);
        }
        return new hn(n, 0);
      }
      function _O(t, e, n) {
        let r, { children: i } = t;
        n > 0 && e instanceof no && i.length && (r = i[i.length - 1]) instanceof no && r.mark.eq(e.mark) ? _O(r, e.children[0], n - 1) : (i.push(e), e.setParent(t)), t.length += e.length;
      }
      function IO(t, e, n) {
        let r = null, i = -1, o = null, s = -1;
        function a(c, u) {
          for (let h = 0, p = 0; h < c.children.length && p <= u; h++) {
            let v = c.children[h], y = p + v.length;
            y >= u && (v.children.length ? a(v, u - p) : (!o || o.isHidden && (n > 0 || s7(o, v))) && (y > u || p == y && v.getSide() > 0) ? (o = v, s = u - p) : (p < u || p == y && v.getSide() < 0 && !v.isHidden) && (r = v, i = u - p)), p = y;
          }
        }
        a(t, e);
        let l = (n < 0 ? r : o) || r || o;
        return l ? l.coordsAt(Math.max(0, l == r ? i : s), n) : o7(t);
      }
      function o7(t) {
        let e = t.dom.lastChild;
        if (!e)
          return t.dom.getBoundingClientRect();
        let n = hl(e);
        return n[n.length - 1] || null;
      }
      function s7(t, e) {
        let n = t.coordsAt(0, 1), r = e.coordsAt(0, 1);
        return n && r && r.top < n.bottom;
      }
      function Xy(t, e) {
        for (let n in t)
          n == "class" && e.class ? e.class += " " + t.class : n == "style" && e.style ? e.style += ";" + t.style : e[n] = t[n];
        return e;
      }
      const MC = /* @__PURE__ */ Object.create(null);
      function xp(t, e, n) {
        if (t == e)
          return true;
        t || (t = MC), e || (e = MC);
        let r = Object.keys(t), i = Object.keys(e);
        if (r.length - (n && r.indexOf(n) > -1 ? 1 : 0) != i.length - (n && i.indexOf(n) > -1 ? 1 : 0))
          return false;
        for (let o of r)
          if (o != n && (i.indexOf(o) == -1 || t[o] !== e[o]))
            return false;
        return true;
      }
      function Qy(t, e, n) {
        let r = false;
        if (e)
          for (let i in e)
            n && i in n || (r = true, i == "style" ? t.style.cssText = "" : t.removeAttribute(i));
        if (n)
          for (let i in n)
            e && e[i] == n[i] || (r = true, i == "style" ? t.style.cssText = n[i] : t.setAttribute(i, n[i]));
        return r;
      }
      function a7(t) {
        let e = /* @__PURE__ */ Object.create(null);
        for (let n = 0; n < t.attributes.length; n++) {
          let r = t.attributes[n];
          e[r.name] = r.value;
        }
        return e;
      }
      class oo {
        eq(e) {
          return false;
        }
        updateDOM(e, n) {
          return false;
        }
        compare(e) {
          return this == e || this.constructor == e.constructor && this.eq(e);
        }
        get estimatedHeight() {
          return -1;
        }
        get lineBreaks() {
          return 0;
        }
        ignoreEvent(e) {
          return true;
        }
        coordsAt(e, n, r) {
          return null;
        }
        get isHidden() {
          return false;
        }
        get editable() {
          return false;
        }
        destroy(e) {
        }
      }
      var kn = function(t) {
        return t[t.Text = 0] = "Text", t[t.WidgetBefore = 1] = "WidgetBefore", t[t.WidgetAfter = 2] = "WidgetAfter", t[t.WidgetRange = 3] = "WidgetRange", t;
      }(kn || (kn = {}));
      class be extends Hs {
        constructor(e, n, r, i) {
          super(), this.startSide = e, this.endSide = n, this.widget = r, this.spec = i;
        }
        get heightRelevant() {
          return false;
        }
        static mark(e) {
          return new of(e);
        }
        static widget(e) {
          let n = Math.max(-1e4, Math.min(1e4, e.side || 0)), r = !!e.block;
          return n += r && !e.inlineOrder ? n > 0 ? 3e8 : -4e8 : n > 0 ? 1e8 : -1e8, new Yo(e, n, n, r, e.widget || null, false);
        }
        static replace(e) {
          let n = !!e.block, r, i;
          if (e.isBlockGap)
            r = -5e8, i = 4e8;
          else {
            let { start: o, end: s } = BO(e, n);
            r = (o ? n ? -3e8 : -1 : 5e8) - 1, i = (s ? n ? 2e8 : 1 : -6e8) + 1;
          }
          return new Yo(e, r, i, n, e.widget || null, true);
        }
        static line(e) {
          return new sf(e);
        }
        static set(e, n = false) {
          return Ve.of(e, n);
        }
        hasHeight() {
          return this.widget ? this.widget.estimatedHeight > -1 : false;
        }
      }
      be.none = Ve.empty;
      class of extends be {
        constructor(e) {
          let { start: n, end: r } = BO(e);
          super(n ? -1 : 5e8, r ? 1 : -6e8, null, e), this.tagName = e.tagName || "span", this.class = e.class || "", this.attrs = e.attributes || null;
        }
        eq(e) {
          var n, r;
          return this == e || e instanceof of && this.tagName == e.tagName && (this.class || ((n = this.attrs) === null || n === void 0 ? void 0 : n.class)) == (e.class || ((r = e.attrs) === null || r === void 0 ? void 0 : r.class)) && xp(this.attrs, e.attrs, "class");
        }
        range(e, n = e) {
          if (e >= n)
            throw new RangeError("Mark decorations may not be empty");
          return super.range(e, n);
        }
      }
      of.prototype.point = false;
      class sf extends be {
        constructor(e) {
          super(-2e8, -2e8, null, e);
        }
        eq(e) {
          return e instanceof sf && this.spec.class == e.spec.class && xp(this.spec.attributes, e.spec.attributes);
        }
        range(e, n = e) {
          if (n != e)
            throw new RangeError("Line decoration ranges must be zero-length");
          return super.range(e, n);
        }
      }
      sf.prototype.mapMode = Zt.TrackBefore;
      sf.prototype.point = true;
      class Yo extends be {
        constructor(e, n, r, i, o, s) {
          super(n, r, o, e), this.block = i, this.isReplace = s, this.mapMode = i ? n <= 0 ? Zt.TrackBefore : Zt.TrackAfter : Zt.TrackDel;
        }
        get type() {
          return this.startSide != this.endSide ? kn.WidgetRange : this.startSide <= 0 ? kn.WidgetBefore : kn.WidgetAfter;
        }
        get heightRelevant() {
          return this.block || !!this.widget && (this.widget.estimatedHeight >= 5 || this.widget.lineBreaks > 0);
        }
        eq(e) {
          return e instanceof Yo && l7(this.widget, e.widget) && this.block == e.block && this.startSide == e.startSide && this.endSide == e.endSide;
        }
        range(e, n = e) {
          if (this.isReplace && (e > n || e == n && this.startSide > 0 && this.endSide <= 0))
            throw new RangeError("Invalid range for replacement decoration");
          if (!this.isReplace && n != e)
            throw new RangeError("Widget decorations can only have zero-length ranges");
          return super.range(e, n);
        }
      }
      Yo.prototype.point = true;
      function BO(t, e = false) {
        let { inclusiveStart: n, inclusiveEnd: r } = t;
        return n == null && (n = t.inclusive), r == null && (r = t.inclusive), {
          start: n ?? e,
          end: r ?? e
        };
      }
      function l7(t, e) {
        return t == e || !!(t && e && t.compare(e));
      }
      function xd(t, e, n, r = 0) {
        let i = n.length - 1;
        i >= 0 && n[i] + r >= t ? n[i] = Math.max(n[i], e) : n.push(t, e);
      }
      class Pt extends Ze {
        constructor() {
          super(...arguments), this.children = [], this.length = 0, this.prevAttrs = void 0, this.attrs = null, this.breakAfter = 0;
        }
        merge(e, n, r, i, o, s) {
          if (r) {
            if (!(r instanceof Pt))
              return false;
            this.dom || r.transferDOM(this);
          }
          return i && this.setDeco(r ? r.attrs : null), OO(this, e, n, r ? r.children.slice() : [], o, s), true;
        }
        split(e) {
          let n = new Pt();
          if (n.breakAfter = this.breakAfter, this.length == 0)
            return n;
          let { i: r, off: i } = this.childPos(e);
          i && (n.append(this.children[r].split(i), 0), this.children[r].merge(i, this.children[r].length, null, false, 0, 0), r++);
          for (let o = r; o < this.children.length; o++)
            n.append(this.children[o], 0);
          for (; r > 0 && this.children[r - 1].length == 0; )
            this.children[--r].destroy();
          return this.children.length = r, this.markDirty(), this.length = e, n;
        }
        transferDOM(e) {
          !this.dom || (this.markDirty(), e.setDOM(this.dom), e.prevAttrs = this.prevAttrs === void 0 ? this.attrs : this.prevAttrs, this.prevAttrs = void 0, this.dom = null);
        }
        setDeco(e) {
          xp(this.attrs, e) || (this.dom && (this.prevAttrs = this.attrs, this.markDirty()), this.attrs = e);
        }
        append(e, n) {
          _O(this, e, n);
        }
        addLineDeco(e) {
          let n = e.spec.attributes, r = e.spec.class;
          n && (this.attrs = Xy(n, this.attrs || {})), r && (this.attrs = Xy({
            class: r
          }, this.attrs || {}));
        }
        domAtPos(e) {
          return DO(this, e);
        }
        reuseDOM(e) {
          e.nodeName == "DIV" && (this.setDOM(e), this.flags |= 6);
        }
        sync(e, n) {
          var r;
          this.dom ? this.flags & 4 && (CO(this.dom), this.dom.className = "cm-line", this.prevAttrs = this.attrs ? null : void 0) : (this.setDOM(document.createElement("div")), this.dom.className = "cm-line", this.prevAttrs = this.attrs ? null : void 0), this.prevAttrs !== void 0 && (Qy(this.dom, this.prevAttrs, this.attrs), this.dom.classList.add("cm-line"), this.prevAttrs = void 0), super.sync(e, n);
          let i = this.dom.lastChild;
          for (; i && Ze.get(i) instanceof no; )
            i = i.lastChild;
          if (!i || !this.length || i.nodeName != "BR" && ((r = Ze.get(i)) === null || r === void 0 ? void 0 : r.isEditable) == false && (!de.ios || !this.children.some((o) => o instanceof Ur))) {
            let o = document.createElement("BR");
            o.cmIgnore = true, this.dom.appendChild(o);
          }
        }
        measureTextSize() {
          if (this.children.length == 0 || this.length > 20)
            return null;
          let e = 0, n;
          for (let r of this.children) {
            if (!(r instanceof Ur) || /[^ -~]/.test(r.text))
              return null;
            let i = hl(r.dom);
            if (i.length != 1)
              return null;
            e += i[0].width, n = i[0].height;
          }
          return e ? {
            lineHeight: this.dom.getBoundingClientRect().height,
            charWidth: e / this.length,
            textHeight: n
          } : null;
        }
        coordsAt(e, n) {
          let r = IO(this, e, n);
          if (!this.children.length && r && this.parent) {
            let { heightOracle: i } = this.parent.view.viewState, o = r.bottom - r.top;
            if (Math.abs(o - i.lineHeight) < 2 && i.textHeight < o) {
              let s = (o - i.textHeight) / 2;
              return {
                top: r.top + s,
                bottom: r.bottom - s,
                left: r.left,
                right: r.left
              };
            }
          }
          return r;
        }
        become(e) {
          return e instanceof Pt && this.children.length == 0 && e.children.length == 0 && xp(this.attrs, e.attrs) && this.breakAfter == e.breakAfter;
        }
        covers() {
          return true;
        }
        static find(e, n) {
          for (let r = 0, i = 0; r < e.children.length; r++) {
            let o = e.children[r], s = i + o.length;
            if (s >= n) {
              if (o instanceof Pt)
                return o;
              if (s > n)
                break;
            }
            i = s + o.breakAfter;
          }
          return null;
        }
      }
      class qi extends Ze {
        constructor(e, n, r) {
          super(), this.widget = e, this.length = n, this.deco = r, this.breakAfter = 0, this.prevWidget = null;
        }
        merge(e, n, r, i, o, s) {
          return r && (!(r instanceof qi) || !this.widget.compare(r.widget) || e > 0 && o <= 0 || n < this.length && s <= 0) ? false : (this.length = e + (r ? r.length : 0) + (this.length - n), true);
        }
        domAtPos(e) {
          return e == 0 ? hn.before(this.dom) : hn.after(this.dom, e == this.length);
        }
        split(e) {
          let n = this.length - e;
          this.length = e;
          let r = new qi(this.widget, n, this.deco);
          return r.breakAfter = this.breakAfter, r;
        }
        get children() {
          return Tx;
        }
        sync(e) {
          (!this.dom || !this.widget.updateDOM(this.dom, e)) && (this.dom && this.prevWidget && this.prevWidget.destroy(this.dom), this.prevWidget = null, this.setDOM(this.widget.toDOM(e)), this.widget.editable || (this.dom.contentEditable = "false"));
        }
        get overrideDOMText() {
          return this.parent ? this.parent.view.state.doc.slice(this.posAtStart, this.posAtEnd) : He.empty;
        }
        domBoundsAround() {
          return null;
        }
        become(e) {
          return e instanceof qi && e.widget.constructor == this.widget.constructor ? (e.widget.compare(this.widget) || this.markDirty(true), this.dom && !this.prevWidget && (this.prevWidget = this.widget), this.widget = e.widget, this.length = e.length, this.deco = e.deco, this.breakAfter = e.breakAfter, true) : false;
        }
        ignoreMutation() {
          return true;
        }
        ignoreEvent(e) {
          return this.widget.ignoreEvent(e);
        }
        get isEditable() {
          return false;
        }
        get isWidget() {
          return true;
        }
        coordsAt(e, n) {
          let r = this.widget.coordsAt(this.dom, e, n);
          return r || (this.widget instanceof Jy ? null : rf(this.dom.getBoundingClientRect(), this.length ? e == 0 : n <= 0));
        }
        destroy() {
          super.destroy(), this.dom && this.widget.destroy(this.dom);
        }
        covers(e) {
          let { startSide: n, endSide: r } = this.deco;
          return n == r ? false : e < 0 ? n < 0 : r > 0;
        }
      }
      class Jy extends oo {
        constructor(e) {
          super(), this.height = e;
        }
        toDOM() {
          let e = document.createElement("div");
          return e.className = "cm-gap", this.updateDOM(e), e;
        }
        eq(e) {
          return e.height == this.height;
        }
        updateDOM(e) {
          return e.style.height = this.height + "px", true;
        }
        get editable() {
          return true;
        }
        get estimatedHeight() {
          return this.height;
        }
        ignoreEvent() {
          return false;
        }
      }
      class Qc {
        constructor(e, n, r, i) {
          this.doc = e, this.pos = n, this.end = r, this.disallowBlockEffectsFor = i, this.content = [], this.curLine = null, this.breakAtStart = 0, this.pendingBuffer = 0, this.bufferMarks = [], this.atCursorPos = true, this.openStart = -1, this.openEnd = -1, this.text = "", this.textOff = 0, this.cursor = e.iter(), this.skip = n;
        }
        posCovered() {
          if (this.content.length == 0)
            return !this.breakAtStart && this.doc.lineAt(this.pos).from != this.pos;
          let e = this.content[this.content.length - 1];
          return !(e.breakAfter || e instanceof qi && e.deco.endSide < 0);
        }
        getLine() {
          return this.curLine || (this.content.push(this.curLine = new Pt()), this.atCursorPos = true), this.curLine;
        }
        flushBuffer(e = this.bufferMarks) {
          this.pendingBuffer && (this.curLine.append(xh(new dl(-1), e), e.length), this.pendingBuffer = 0);
        }
        addBlockWidget(e) {
          this.flushBuffer(), this.curLine = null, this.content.push(e);
        }
        finish(e) {
          this.pendingBuffer && e <= this.bufferMarks.length ? this.flushBuffer() : this.pendingBuffer = 0, !this.posCovered() && !(e && this.content.length && this.content[this.content.length - 1] instanceof qi) && this.getLine();
        }
        buildText(e, n, r) {
          for (; e > 0; ) {
            if (this.textOff == this.text.length) {
              let { value: o, lineBreak: s, done: a } = this.cursor.next(this.skip);
              if (this.skip = 0, a)
                throw new Error("Ran out of text content when drawing inline views");
              if (s) {
                this.posCovered() || this.getLine(), this.content.length ? this.content[this.content.length - 1].breakAfter = 1 : this.breakAtStart = 1, this.flushBuffer(), this.curLine = null, this.atCursorPos = true, e--;
                continue;
              } else
                this.text = o, this.textOff = 0;
            }
            let i = Math.min(this.text.length - this.textOff, e, 512);
            this.flushBuffer(n.slice(n.length - r)), this.getLine().append(xh(new Ur(this.text.slice(this.textOff, this.textOff + i)), n), r), this.atCursorPos = true, this.textOff += i, e -= i, r = 0;
          }
        }
        span(e, n, r, i) {
          this.buildText(n - e, r, i), this.pos = n, this.openStart < 0 && (this.openStart = i);
        }
        point(e, n, r, i, o, s) {
          if (this.disallowBlockEffectsFor[s] && r instanceof Yo) {
            if (r.block)
              throw new RangeError("Block decorations may not be specified via plugins");
            if (n > this.doc.lineAt(this.pos).to)
              throw new RangeError("Decorations that replace line breaks may not be specified via plugins");
          }
          let a = n - e;
          if (r instanceof Yo)
            if (r.block)
              r.startSide > 0 && !this.posCovered() && this.getLine(), this.addBlockWidget(new qi(r.widget || pl.block, a, r));
            else {
              let l = Do.create(r.widget || pl.inline, a, a ? 0 : r.startSide), c = this.atCursorPos && !l.isEditable && o <= i.length && (e < n || r.startSide > 0), u = !l.isEditable && (e < n || o > i.length || r.startSide <= 0), h = this.getLine();
              this.pendingBuffer == 2 && !c && !l.isEditable && (this.pendingBuffer = 0), this.flushBuffer(i), c && (h.append(xh(new dl(1), i), o), o = i.length + Math.max(0, o - i.length)), h.append(xh(l, i), o), this.atCursorPos = u, this.pendingBuffer = u ? e < n || o > i.length ? 1 : 2 : 0, this.pendingBuffer && (this.bufferMarks = i.slice());
            }
          else
            this.doc.lineAt(this.pos).from == this.pos && this.getLine().addLineDeco(r);
          a && (this.textOff + a <= this.text.length ? this.textOff += a : (this.skip += a - (this.text.length - this.textOff), this.text = "", this.textOff = 0), this.pos = n), this.openStart < 0 && (this.openStart = o);
        }
        static build(e, n, r, i, o) {
          let s = new Qc(e, n, r, o);
          return s.openEnd = Ve.spans(i, n, r, s), s.openStart < 0 && (s.openStart = s.openEnd), s.finish(s.openEnd), s;
        }
      }
      function xh(t, e) {
        for (let n of e)
          t = new no(n, [
            t
          ], t.length);
        return t;
      }
      class pl extends oo {
        constructor(e) {
          super(), this.tag = e;
        }
        eq(e) {
          return e.tag == this.tag;
        }
        toDOM() {
          return document.createElement(this.tag);
        }
        updateDOM(e) {
          return e.nodeName.toLowerCase() == this.tag;
        }
        get isHidden() {
          return true;
        }
      }
      pl.inline = new pl("span");
      pl.block = new pl("div");
      var rt = function(t) {
        return t[t.LTR = 0] = "LTR", t[t.RTL = 1] = "RTL", t;
      }(rt || (rt = {}));
      const Us = rt.LTR, Mx = rt.RTL;
      function NO(t) {
        let e = [];
        for (let n = 0; n < t.length; n++)
          e.push(1 << +t[n]);
        return e;
      }
      const c7 = NO("88888888888888888888888888888888888666888888787833333333337888888000000000000000000000000008888880000000000000000000000000088888888888888888888888888888888888887866668888088888663380888308888800000000000000000000000800000000000000000000000000000008"), u7 = NO("4444448826627288999999999992222222222222222222222222222222222222222222222229999999999999999999994444444444644222822222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222999999949999999229989999223333333333"), Zy = /* @__PURE__ */ Object.create(null), ti = [];
      for (let t of [
        "()",
        "[]",
        "{}"
      ]) {
        let e = t.charCodeAt(0), n = t.charCodeAt(1);
        Zy[e] = n, Zy[n] = -e;
      }
      function $O(t) {
        return t <= 247 ? c7[t] : 1424 <= t && t <= 1524 ? 2 : 1536 <= t && t <= 1785 ? u7[t - 1536] : 1774 <= t && t <= 2220 ? 4 : 8192 <= t && t <= 8204 ? 256 : 64336 <= t && t <= 65023 ? 4 : 1;
      }
      const f7 = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac\ufb50-\ufdff]/;
      class _o {
        get dir() {
          return this.level % 2 ? Mx : Us;
        }
        constructor(e, n, r) {
          this.from = e, this.to = n, this.level = r;
        }
        side(e, n) {
          return this.dir == n == e ? this.to : this.from;
        }
        forward(e, n) {
          return e == (this.dir == n);
        }
        static find(e, n, r, i) {
          let o = -1;
          for (let s = 0; s < e.length; s++) {
            let a = e[s];
            if (a.from <= n && a.to >= n) {
              if (a.level == r)
                return s;
              (o < 0 || (i != 0 ? i < 0 ? a.from < n : a.to > n : e[o].level > a.level)) && (o = s);
            }
          }
          if (o < 0)
            throw new RangeError("Index out of range");
          return o;
        }
      }
      function zO(t, e) {
        if (t.length != e.length)
          return false;
        for (let n = 0; n < t.length; n++) {
          let r = t[n], i = e[n];
          if (r.from != i.from || r.to != i.to || r.direction != i.direction || !zO(r.inner, i.inner))
            return false;
        }
        return true;
      }
      const Je = [];
      function h7(t, e, n, r, i) {
        for (let o = 0; o <= r.length; o++) {
          let s = o ? r[o - 1].to : e, a = o < r.length ? r[o].from : n, l = o ? 256 : i;
          for (let c = s, u = l, h = l; c < a; c++) {
            let p = $O(t.charCodeAt(c));
            p == 512 ? p = u : p == 8 && h == 4 && (p = 16), Je[c] = p == 4 ? 2 : p, p & 7 && (h = p), u = p;
          }
          for (let c = s, u = l, h = l; c < a; c++) {
            let p = Je[c];
            if (p == 128)
              c < a - 1 && u == Je[c + 1] && u & 24 ? p = Je[c] = u : Je[c] = 256;
            else if (p == 64) {
              let v = c + 1;
              for (; v < a && Je[v] == 64; )
                v++;
              let y = c && u == 8 || v < n && Je[v] == 8 ? h == 1 ? 1 : 8 : 256;
              for (let S = c; S < v; S++)
                Je[S] = y;
              c = v - 1;
            } else
              p == 8 && h == 1 && (Je[c] = 1);
            u = p, p & 7 && (h = p);
          }
        }
      }
      function d7(t, e, n, r, i) {
        let o = i == 1 ? 2 : 1;
        for (let s = 0, a = 0, l = 0; s <= r.length; s++) {
          let c = s ? r[s - 1].to : e, u = s < r.length ? r[s].from : n;
          for (let h = c, p, v, y; h < u; h++)
            if (v = Zy[p = t.charCodeAt(h)])
              if (v < 0) {
                for (let S = a - 3; S >= 0; S -= 3)
                  if (ti[S + 1] == -v) {
                    let C = ti[S + 2], w = C & 2 ? i : C & 4 ? C & 1 ? o : i : 0;
                    w && (Je[h] = Je[ti[S]] = w), a = S;
                    break;
                  }
              } else {
                if (ti.length == 189)
                  break;
                ti[a++] = h, ti[a++] = p, ti[a++] = l;
              }
            else if ((y = Je[h]) == 2 || y == 1) {
              let S = y == i;
              l = S ? 0 : 1;
              for (let C = a - 3; C >= 0; C -= 3) {
                let w = ti[C + 2];
                if (w & 2)
                  break;
                if (S)
                  ti[C + 2] |= 2;
                else {
                  if (w & 4)
                    break;
                  ti[C + 2] |= 4;
                }
              }
            }
        }
      }
      function p7(t, e, n, r) {
        for (let i = 0, o = r; i <= n.length; i++) {
          let s = i ? n[i - 1].to : t, a = i < n.length ? n[i].from : e;
          for (let l = s; l < a; ) {
            let c = Je[l];
            if (c == 256) {
              let u = l + 1;
              for (; ; )
                if (u == a) {
                  if (i == n.length)
                    break;
                  u = n[i++].to, a = i < n.length ? n[i].from : e;
                } else if (Je[u] == 256)
                  u++;
                else
                  break;
              let h = o == 1, p = (u < e ? Je[u] : r) == 1, v = h == p ? h ? 1 : 2 : r;
              for (let y = u, S = i, C = S ? n[S - 1].to : t; y > l; )
                y == C && (y = n[--S].from, C = S ? n[S - 1].to : t), Je[--y] = v;
              l = u;
            } else
              o = c, l++;
          }
        }
      }
      function e1(t, e, n, r, i, o, s) {
        let a = r % 2 ? 2 : 1;
        if (r % 2 == i % 2)
          for (let l = e, c = 0; l < n; ) {
            let u = true, h = false;
            if (c == o.length || l < o[c].from) {
              let S = Je[l];
              S != a && (u = false, h = S == 16);
            }
            let p = !u && a == 1 ? [] : null, v = u ? r : r + 1, y = l;
            e:
              for (; ; )
                if (c < o.length && y == o[c].from) {
                  if (h)
                    break e;
                  let S = o[c];
                  if (!u)
                    for (let C = S.to, w = c + 1; ; ) {
                      if (C == n)
                        break e;
                      if (w < o.length && o[w].from == C)
                        C = o[w++].to;
                      else {
                        if (Je[C] == a)
                          break e;
                        break;
                      }
                    }
                  if (c++, p)
                    p.push(S);
                  else {
                    S.from > l && s.push(new _o(l, S.from, v));
                    let C = S.direction == Us != !(v % 2);
                    t1(t, C ? r + 1 : r, i, S.inner, S.from, S.to, s), l = S.to;
                  }
                  y = S.to;
                } else {
                  if (y == n || (u ? Je[y] != a : Je[y] == a))
                    break;
                  y++;
                }
            p ? e1(t, l, y, r + 1, i, p, s) : l < y && s.push(new _o(l, y, v)), l = y;
          }
        else
          for (let l = n, c = o.length; l > e; ) {
            let u = true, h = false;
            if (!c || l > o[c - 1].to) {
              let S = Je[l - 1];
              S != a && (u = false, h = S == 16);
            }
            let p = !u && a == 1 ? [] : null, v = u ? r : r + 1, y = l;
            e:
              for (; ; )
                if (c && y == o[c - 1].to) {
                  if (h)
                    break e;
                  let S = o[--c];
                  if (!u)
                    for (let C = S.from, w = c; ; ) {
                      if (C == e)
                        break e;
                      if (w && o[w - 1].to == C)
                        C = o[--w].from;
                      else {
                        if (Je[C - 1] == a)
                          break e;
                        break;
                      }
                    }
                  if (p)
                    p.push(S);
                  else {
                    S.to < l && s.push(new _o(S.to, l, v));
                    let C = S.direction == Us != !(v % 2);
                    t1(t, C ? r + 1 : r, i, S.inner, S.from, S.to, s), l = S.from;
                  }
                  y = S.from;
                } else {
                  if (y == e || (u ? Je[y - 1] != a : Je[y - 1] == a))
                    break;
                  y--;
                }
            p ? e1(t, y, l, r + 1, i, p, s) : y < l && s.push(new _o(y, l, v)), l = y;
          }
      }
      function t1(t, e, n, r, i, o, s) {
        let a = e % 2 ? 2 : 1;
        h7(t, i, o, r, a), d7(t, i, o, r, a), p7(i, o, r, a), e1(t, i, o, e, n, r, s);
      }
      function m7(t, e, n) {
        if (!t)
          return [
            new _o(0, 0, e == Mx ? 1 : 0)
          ];
        if (e == Us && !n.length && !f7.test(t))
          return FO(t.length);
        if (n.length)
          for (; t.length > Je.length; )
            Je[Je.length] = 256;
        let r = [], i = e == Us ? 0 : 1;
        return t1(t, i, i, n, 0, t.length, r), r;
      }
      function FO(t) {
        return [
          new _o(0, t, 0)
        ];
      }
      let VO = "";
      function g7(t, e, n, r, i) {
        var o;
        let s = r.head - t.from, a = _o.find(e, s, (o = r.bidiLevel) !== null && o !== void 0 ? o : -1, r.assoc), l = e[a], c = l.side(i, n);
        if (s == c) {
          let p = a += i ? 1 : -1;
          if (p < 0 || p >= e.length)
            return null;
          l = e[a = p], s = l.side(!i, n), c = l.side(i, n);
        }
        let u = en(t.text, s, l.forward(i, n));
        (u < l.from || u > l.to) && (u = c), VO = t.text.slice(Math.min(s, u), Math.max(s, u));
        let h = a == (i ? e.length - 1 : 0) ? null : e[a + (i ? 1 : -1)];
        return h && u == c && h.level + (i ? 0 : 1) < l.level ? q.cursor(h.side(!i, n) + t.from, h.forward(i, n) ? 1 : -1, h.level) : q.cursor(u + t.from, l.forward(i, n) ? -1 : 1, l.level);
      }
      function v7(t, e, n) {
        for (let r = e; r < n; r++) {
          let i = $O(t.charCodeAt(r));
          if (i == 1)
            return Us;
          if (i == 2 || i == 4)
            return Mx;
        }
        return Us;
      }
      const HO = pe.define(), jO = pe.define(), WO = pe.define(), UO = pe.define(), n1 = pe.define(), KO = pe.define(), qO = pe.define(), Ax = pe.define(), Ex = pe.define(), GO = pe.define({
        combine: (t) => t.some((e) => e)
      }), YO = pe.define({
        combine: (t) => t.some((e) => e)
      }), XO = pe.define();
      class Ya {
        constructor(e, n = "nearest", r = "nearest", i = 5, o = 5, s = false) {
          this.range = e, this.y = n, this.x = r, this.yMargin = i, this.xMargin = o, this.isSnapshot = s;
        }
        map(e) {
          return e.empty ? this : new Ya(this.range.map(e), this.y, this.x, this.yMargin, this.xMargin, this.isSnapshot);
        }
        clip(e) {
          return this.range.to <= e.doc.length ? this : new Ya(q.cursor(e.doc.length), this.y, this.x, this.yMargin, this.xMargin, this.isSnapshot);
        }
      }
      const Sh = Pe.define({
        map: (t, e) => t.map(e)
      }), QO = Pe.define();
      function Bn(t, e, n) {
        let r = t.facet(UO);
        r.length ? r[0](e) : window.onerror ? window.onerror(String(e), n, void 0, void 0, e) : n ? console.error(n + ":", e) : console.error(e);
      }
      const Fi = pe.define({
        combine: (t) => t.length ? t[0] : true
      });
      let y7 = 0;
      const yc = pe.define();
      class Ct {
        constructor(e, n, r, i, o) {
          this.id = e, this.create = n, this.domEventHandlers = r, this.domEventObservers = i, this.extension = o(this);
        }
        static define(e, n) {
          const { eventHandlers: r, eventObservers: i, provide: o, decorations: s } = n || {};
          return new Ct(y7++, e, r, i, (a) => {
            let l = [
              yc.of(a)
            ];
            return s && l.push(Bu.of((c) => {
              let u = c.plugin(a);
              return u ? s(u) : be.none;
            })), o && l.push(o(a)), l;
          });
        }
        static fromClass(e, n) {
          return Ct.define((r) => new e(r), n);
        }
      }
      class _0 {
        constructor(e) {
          this.spec = e, this.mustUpdate = null, this.value = null;
        }
        update(e) {
          if (this.value) {
            if (this.mustUpdate) {
              let n = this.mustUpdate;
              if (this.mustUpdate = null, this.value.update)
                try {
                  this.value.update(n);
                } catch (r) {
                  if (Bn(n.state, r, "CodeMirror plugin crashed"), this.value.destroy)
                    try {
                      this.value.destroy();
                    } catch {
                    }
                  this.deactivate();
                }
            }
          } else if (this.spec)
            try {
              this.value = this.spec.create(e);
            } catch (n) {
              Bn(e.state, n, "CodeMirror plugin crashed"), this.deactivate();
            }
          return this;
        }
        destroy(e) {
          var n;
          if (!((n = this.value) === null || n === void 0) && n.destroy)
            try {
              this.value.destroy();
            } catch (r) {
              Bn(e.state, r, "CodeMirror plugin crashed");
            }
        }
        deactivate() {
          this.spec = this.value = null;
        }
      }
      const JO = pe.define(), Px = pe.define(), Bu = pe.define(), ZO = pe.define(), Ox = pe.define(), eR = pe.define();
      function AC(t, e) {
        let n = t.state.facet(eR);
        if (!n.length)
          return n;
        let r = n.map((o) => o instanceof Function ? o(t) : o), i = [];
        return Ve.spans(r, e.from, e.to, {
          point() {
          },
          span(o, s, a, l) {
            let c = o - e.from, u = s - e.from, h = i;
            for (let p = a.length - 1; p >= 0; p--, l--) {
              let v = a[p].spec.bidiIsolate, y;
              if (v == null && (v = v7(e.text, c, u)), l > 0 && h.length && (y = h[h.length - 1]).to == c && y.direction == v)
                y.to = u, h = y.inner;
              else {
                let S = {
                  from: c,
                  to: u,
                  direction: v,
                  inner: []
                };
                h.push(S), h = S.inner;
              }
            }
          }
        }), i;
      }
      const tR = pe.define();
      function Rx(t) {
        let e = 0, n = 0, r = 0, i = 0;
        for (let o of t.state.facet(tR)) {
          let s = o(t);
          s && (s.left != null && (e = Math.max(e, s.left)), s.right != null && (n = Math.max(n, s.right)), s.top != null && (r = Math.max(r, s.top)), s.bottom != null && (i = Math.max(i, s.bottom)));
        }
        return {
          left: e,
          right: n,
          top: r,
          bottom: i
        };
      }
      const bc = pe.define();
      class br {
        constructor(e, n, r, i) {
          this.fromA = e, this.toA = n, this.fromB = r, this.toB = i;
        }
        join(e) {
          return new br(Math.min(this.fromA, e.fromA), Math.max(this.toA, e.toA), Math.min(this.fromB, e.fromB), Math.max(this.toB, e.toB));
        }
        addToSet(e) {
          let n = e.length, r = this;
          for (; n > 0; n--) {
            let i = e[n - 1];
            if (!(i.fromA > r.toA)) {
              if (i.toA < r.fromA)
                break;
              r = r.join(i), e.splice(n - 1, 1);
            }
          }
          return e.splice(n, 0, r), e;
        }
        static extendWithRanges(e, n) {
          if (n.length == 0)
            return e;
          let r = [];
          for (let i = 0, o = 0, s = 0, a = 0; ; i++) {
            let l = i == e.length ? null : e[i], c = s - a, u = l ? l.fromB : 1e9;
            for (; o < n.length && n[o] < u; ) {
              let h = n[o], p = n[o + 1], v = Math.max(a, h), y = Math.min(u, p);
              if (v <= y && new br(v + c, y + c, v, y).addToSet(r), p > u)
                break;
              o += 2;
            }
            if (!l)
              return r;
            new br(l.fromA, l.toA, l.fromB, l.toB).addToSet(r), s = l.toA, a = l.toB;
          }
        }
      }
      class Sp {
        constructor(e, n, r) {
          this.view = e, this.state = n, this.transactions = r, this.flags = 0, this.startState = e.state, this.changes = _t.empty(this.startState.doc.length);
          for (let o of r)
            this.changes = this.changes.compose(o.changes);
          let i = [];
          this.changes.iterChangedRanges((o, s, a, l) => i.push(new br(o, s, a, l))), this.changedRanges = i;
        }
        static create(e, n, r) {
          return new Sp(e, n, r);
        }
        get viewportChanged() {
          return (this.flags & 4) > 0;
        }
        get viewportMoved() {
          return (this.flags & 8) > 0;
        }
        get heightChanged() {
          return (this.flags & 2) > 0;
        }
        get geometryChanged() {
          return this.docChanged || (this.flags & 18) > 0;
        }
        get focusChanged() {
          return (this.flags & 1) > 0;
        }
        get docChanged() {
          return !this.changes.empty;
        }
        get selectionSet() {
          return this.transactions.some((e) => e.selection);
        }
        get empty() {
          return this.flags == 0 && this.transactions.length == 0;
        }
      }
      class EC extends Ze {
        get length() {
          return this.view.state.doc.length;
        }
        constructor(e) {
          super(), this.view = e, this.decorations = [], this.dynamicDecorationMap = [
            false
          ], this.domChanged = null, this.hasComposition = null, this.markedForComposition = /* @__PURE__ */ new Set(), this.editContextFormatting = be.none, this.lastCompositionAfterCursor = false, this.minWidth = 0, this.minWidthFrom = 0, this.minWidthTo = 0, this.impreciseAnchor = null, this.impreciseHead = null, this.forceSelection = false, this.lastUpdate = Date.now(), this.setDOM(e.contentDOM), this.children = [
            new Pt()
          ], this.children[0].setParent(this), this.updateDeco(), this.updateInner([
            new br(0, 0, 0, e.state.doc.length)
          ], 0, null);
        }
        update(e) {
          var n;
          let r = e.changedRanges;
          this.minWidth > 0 && r.length && (r.every(({ fromA: c, toA: u }) => u < this.minWidthFrom || c > this.minWidthTo) ? (this.minWidthFrom = e.changes.mapPos(this.minWidthFrom, 1), this.minWidthTo = e.changes.mapPos(this.minWidthTo, 1)) : this.minWidth = this.minWidthFrom = this.minWidthTo = 0), this.updateEditContextFormatting(e);
          let i = -1;
          this.view.inputState.composing >= 0 && !this.view.observer.editContext && (!((n = this.domChanged) === null || n === void 0) && n.newSel ? i = this.domChanged.newSel.head : !T7(e.changes, this.hasComposition) && !e.selectionSet && (i = e.state.selection.main.head));
          let o = i > -1 ? x7(this.view, e.changes, i) : null;
          if (this.domChanged = null, this.hasComposition) {
            this.markedForComposition.clear();
            let { from: c, to: u } = this.hasComposition;
            r = new br(c, u, e.changes.mapPos(c, -1), e.changes.mapPos(u, 1)).addToSet(r.slice());
          }
          this.hasComposition = o ? {
            from: o.range.fromB,
            to: o.range.toB
          } : null, (de.ie || de.chrome) && !o && e && e.state.doc.lines != e.startState.doc.lines && (this.forceSelection = true);
          let s = this.decorations, a = this.updateDeco(), l = k7(s, a, e.changes);
          return r = br.extendWithRanges(r, l), !(this.flags & 7) && r.length == 0 ? false : (this.updateInner(r, e.startState.doc.length, o), e.transactions.length && (this.lastUpdate = Date.now()), true);
        }
        updateInner(e, n, r) {
          this.view.viewState.mustMeasureContent = true, this.updateChildren(e, n, r);
          let { observer: i } = this.view;
          i.ignore(() => {
            this.dom.style.height = this.view.viewState.contentHeight / this.view.scaleY + "px", this.dom.style.flexBasis = this.minWidth ? this.minWidth + "px" : "";
            let s = de.chrome || de.ios ? {
              node: i.selectionRange.focusNode,
              written: false
            } : void 0;
            this.sync(this.view, s), this.flags &= -8, s && (s.written || i.selectionRange.focusNode != s.node) && (this.forceSelection = true), this.dom.style.height = "";
          }), this.markedForComposition.forEach((s) => s.flags &= -9);
          let o = [];
          if (this.view.viewport.from || this.view.viewport.to < this.view.state.doc.length)
            for (let s of this.children)
              s instanceof qi && s.widget instanceof Jy && o.push(s.dom);
          i.updateGaps(o);
        }
        updateChildren(e, n, r) {
          let i = r ? r.range.addToSet(e.slice()) : e, o = this.childCursor(n);
          for (let s = i.length - 1; ; s--) {
            let a = s >= 0 ? i[s] : null;
            if (!a)
              break;
            let { fromA: l, toA: c, fromB: u, toB: h } = a, p, v, y, S;
            if (r && r.range.fromB < h && r.range.toB > u) {
              let P = Qc.build(this.view.state.doc, u, r.range.fromB, this.decorations, this.dynamicDecorationMap), R = Qc.build(this.view.state.doc, r.range.toB, h, this.decorations, this.dynamicDecorationMap);
              v = P.breakAtStart, y = P.openStart, S = R.openEnd;
              let L = this.compositionView(r);
              R.breakAtStart ? L.breakAfter = 1 : R.content.length && L.merge(L.length, L.length, R.content[0], false, R.openStart, 0) && (L.breakAfter = R.content[0].breakAfter, R.content.shift()), P.content.length && L.merge(0, 0, P.content[P.content.length - 1], true, 0, P.openEnd) && P.content.pop(), p = P.content.concat(L).concat(R.content);
            } else
              ({ content: p, breakAtStart: v, openStart: y, openEnd: S } = Qc.build(this.view.state.doc, u, h, this.decorations, this.dynamicDecorationMap));
            let { i: C, off: w } = o.findPos(c, 1), { i: k, off: T } = o.findPos(l, -1);
            PO(this, k, T, C, w, p, v, y, S);
          }
          r && this.fixCompositionDOM(r);
        }
        updateEditContextFormatting(e) {
          this.editContextFormatting = this.editContextFormatting.map(e.changes);
          for (let n of e.transactions)
            for (let r of n.effects)
              r.is(QO) && (this.editContextFormatting = r.value);
        }
        compositionView(e) {
          let n = new Ur(e.text.nodeValue);
          n.flags |= 8;
          for (let { deco: i } of e.marks)
            n = new no(i, [
              n
            ], n.length);
          let r = new Pt();
          return r.append(n, 0), r;
        }
        fixCompositionDOM(e) {
          let n = (o, s) => {
            s.flags |= 8 | (s.children.some((l) => l.flags & 7) ? 1 : 0), this.markedForComposition.add(s);
            let a = Ze.get(o);
            a && a != s && (a.dom = null), s.setDOM(o);
          }, r = this.childPos(e.range.fromB, 1), i = this.children[r.i];
          n(e.line, i);
          for (let o = e.marks.length - 1; o >= -1; o--)
            r = i.childPos(r.off, 1), i = i.children[r.i], n(o >= 0 ? e.marks[o].node : e.text, i);
        }
        updateSelection(e = false, n = false) {
          (e || !this.view.observer.selectionRange.focusNode) && this.view.observer.readSelectionRange();
          let r = this.view.root.activeElement, i = r == this.dom, o = !i && !(this.view.state.facet(Fi) || this.dom.tabIndex > -1) && bd(this.dom, this.view.observer.selectionRange) && !(r && this.dom.contains(r));
          if (!(i || n || o))
            return;
          let s = this.forceSelection;
          this.forceSelection = false;
          let a = this.view.state.selection.main, l = this.moveToLine(this.domAtPos(a.anchor)), c = a.empty ? l : this.moveToLine(this.domAtPos(a.head));
          if (de.gecko && a.empty && !this.hasComposition && b7(l)) {
            let h = document.createTextNode("");
            this.view.observer.ignore(() => l.node.insertBefore(h, l.node.childNodes[l.offset] || null)), l = c = new hn(h, 0), s = true;
          }
          let u = this.view.observer.selectionRange;
          (s || !u.focusNode || (!Xc(l.node, l.offset, u.anchorNode, u.anchorOffset) || !Xc(c.node, c.offset, u.focusNode, u.focusOffset)) && !this.suppressWidgetCursorChange(u, a)) && (this.view.observer.ignore(() => {
            de.android && de.chrome && this.dom.contains(u.focusNode) && C7(u.focusNode, this.dom) && (this.dom.blur(), this.dom.focus({
              preventScroll: true
            }));
            let h = Iu(this.view.root);
            if (h)
              if (a.empty) {
                if (de.gecko) {
                  let p = S7(l.node, l.offset);
                  if (p && p != 3) {
                    let v = (p == 1 ? MO : AO)(l.node, l.offset);
                    v && (l = new hn(v.node, v.offset));
                  }
                }
                h.collapse(l.node, l.offset), a.bidiLevel != null && h.caretBidiLevel !== void 0 && (h.caretBidiLevel = a.bidiLevel);
              } else if (h.extend) {
                h.collapse(l.node, l.offset);
                try {
                  h.extend(c.node, c.offset);
                } catch {
                }
              } else {
                let p = document.createRange();
                a.anchor > a.head && ([l, c] = [
                  c,
                  l
                ]), p.setEnd(c.node, c.offset), p.setStart(l.node, l.offset), h.removeAllRanges(), h.addRange(p);
              }
            o && this.view.root.activeElement == this.dom && (this.dom.blur(), r && r.focus());
          }), this.view.observer.setSelectionRange(l, c)), this.impreciseAnchor = l.precise ? null : new hn(u.anchorNode, u.anchorOffset), this.impreciseHead = c.precise ? null : new hn(u.focusNode, u.focusOffset);
        }
        suppressWidgetCursorChange(e, n) {
          return this.hasComposition && n.empty && Xc(e.focusNode, e.focusOffset, e.anchorNode, e.anchorOffset) && this.posFromDOM(e.focusNode, e.focusOffset) == n.head;
        }
        enforceCursorAssoc() {
          if (this.hasComposition)
            return;
          let { view: e } = this, n = e.state.selection.main, r = Iu(e.root), { anchorNode: i, anchorOffset: o } = e.observer.selectionRange;
          if (!r || !n.empty || !n.assoc || !r.modify)
            return;
          let s = Pt.find(this, n.head);
          if (!s)
            return;
          let a = s.posAtStart;
          if (n.head == a || n.head == a + s.length)
            return;
          let l = this.coordsAt(n.head, -1), c = this.coordsAt(n.head, 1);
          if (!l || !c || l.bottom > c.top)
            return;
          let u = this.domAtPos(n.head + n.assoc);
          r.collapse(u.node, u.offset), r.modify("move", n.assoc < 0 ? "forward" : "backward", "lineboundary"), e.observer.readSelectionRange();
          let h = e.observer.selectionRange;
          e.docView.posFromDOM(h.anchorNode, h.anchorOffset) != n.from && r.collapse(i, o);
        }
        moveToLine(e) {
          let n = this.dom, r;
          if (e.node != n)
            return e;
          for (let i = e.offset; !r && i < n.childNodes.length; i++) {
            let o = Ze.get(n.childNodes[i]);
            o instanceof Pt && (r = o.domAtPos(0));
          }
          for (let i = e.offset - 1; !r && i >= 0; i--) {
            let o = Ze.get(n.childNodes[i]);
            o instanceof Pt && (r = o.domAtPos(o.length));
          }
          return r ? new hn(r.node, r.offset, true) : e;
        }
        nearest(e) {
          for (let n = e; n; ) {
            let r = Ze.get(n);
            if (r && r.rootView == this)
              return r;
            n = n.parentNode;
          }
          return null;
        }
        posFromDOM(e, n) {
          let r = this.nearest(e);
          if (!r)
            throw new RangeError("Trying to find position for a DOM position outside of the document");
          return r.localPosFromDOM(e, n) + r.posAtStart;
        }
        domAtPos(e) {
          let { i: n, off: r } = this.childCursor().findPos(e, -1);
          for (; n < this.children.length - 1; ) {
            let i = this.children[n];
            if (r < i.length || i instanceof Pt)
              break;
            n++, r = 0;
          }
          return this.children[n].domAtPos(r);
        }
        coordsAt(e, n) {
          let r = null, i = 0;
          for (let o = this.length, s = this.children.length - 1; s >= 0; s--) {
            let a = this.children[s], l = o - a.breakAfter, c = l - a.length;
            if (l < e)
              break;
            if (c <= e && (c < e || a.covers(-1)) && (l > e || a.covers(1)) && (!r || a instanceof Pt && !(r instanceof Pt && n >= 0)))
              r = a, i = c;
            else if (r && c == e && l == e && a instanceof qi && Math.abs(n) < 2) {
              if (a.deco.startSide < 0)
                break;
              s && (r = null);
            }
            o = c;
          }
          return r ? r.coordsAt(e - i, n) : null;
        }
        coordsForChar(e) {
          let { i: n, off: r } = this.childPos(e, 1), i = this.children[n];
          if (!(i instanceof Pt))
            return null;
          for (; i.children.length; ) {
            let { i: a, off: l } = i.childPos(r, 1);
            for (; ; a++) {
              if (a == i.children.length)
                return null;
              if ((i = i.children[a]).length)
                break;
            }
            r = l;
          }
          if (!(i instanceof Ur))
            return null;
          let o = en(i.text, r);
          if (o == r)
            return null;
          let s = Ws(i.dom, r, o).getClientRects();
          for (let a = 0; a < s.length; a++) {
            let l = s[a];
            if (a == s.length - 1 || l.top < l.bottom && l.left < l.right)
              return l;
          }
          return null;
        }
        measureVisibleLineHeights(e) {
          let n = [], { from: r, to: i } = e, o = this.view.contentDOM.clientWidth, s = o > Math.max(this.view.scrollDOM.clientWidth, this.minWidth) + 1, a = -1, l = this.view.textDirection == rt.LTR;
          for (let c = 0, u = 0; u < this.children.length; u++) {
            let h = this.children[u], p = c + h.length;
            if (p > i)
              break;
            if (c >= r) {
              let v = h.dom.getBoundingClientRect();
              if (n.push(v.height), s) {
                let y = h.dom.lastChild, S = y ? hl(y) : [];
                if (S.length) {
                  let C = S[S.length - 1], w = l ? C.right - v.left : v.right - C.left;
                  w > a && (a = w, this.minWidth = o, this.minWidthFrom = c, this.minWidthTo = p);
                }
              }
            }
            c = p + h.breakAfter;
          }
          return n;
        }
        textDirectionAt(e) {
          let { i: n } = this.childPos(e, 1);
          return getComputedStyle(this.children[n].dom).direction == "rtl" ? rt.RTL : rt.LTR;
        }
        measureTextSize() {
          for (let o of this.children)
            if (o instanceof Pt) {
              let s = o.measureTextSize();
              if (s)
                return s;
            }
          let e = document.createElement("div"), n, r, i;
          return e.className = "cm-line", e.style.width = "99999px", e.style.position = "absolute", e.textContent = "abc def ghi jkl mno pqr stu", this.view.observer.ignore(() => {
            this.dom.appendChild(e);
            let o = hl(e.firstChild)[0];
            n = e.getBoundingClientRect().height, r = o ? o.width / 27 : 7, i = o ? o.height : n, e.remove();
          }), {
            lineHeight: n,
            charWidth: r,
            textHeight: i
          };
        }
        childCursor(e = this.length) {
          let n = this.children.length;
          return n && (e -= this.children[--n].length), new EO(this.children, e, n);
        }
        computeBlockGapDeco() {
          let e = [], n = this.view.viewState;
          for (let r = 0, i = 0; ; i++) {
            let o = i == n.viewports.length ? null : n.viewports[i], s = o ? o.from - 1 : this.length;
            if (s > r) {
              let a = (n.lineBlockAt(s).bottom - n.lineBlockAt(r).top) / this.view.scaleY;
              e.push(be.replace({
                widget: new Jy(a),
                block: true,
                inclusive: true,
                isBlockGap: true
              }).range(r, s));
            }
            if (!o)
              break;
            r = o.to + 1;
          }
          return be.set(e);
        }
        updateDeco() {
          let e = 1, n = this.view.state.facet(Bu).map((o) => (this.dynamicDecorationMap[e++] = typeof o == "function") ? o(this.view) : o), r = false, i = this.view.state.facet(ZO).map((o, s) => {
            let a = typeof o == "function";
            return a && (r = true), a ? o(this.view) : o;
          });
          for (i.length && (this.dynamicDecorationMap[e++] = r, n.push(Ve.join(i))), this.decorations = [
            this.editContextFormatting,
            ...n,
            this.computeBlockGapDeco(),
            this.view.viewState.lineGapDeco
          ]; e < this.decorations.length; )
            this.dynamicDecorationMap[e++] = false;
          return this.decorations;
        }
        scrollIntoView(e) {
          if (e.isSnapshot) {
            let c = this.view.viewState.lineBlockAt(e.range.head);
            this.view.scrollDOM.scrollTop = c.top - e.yMargin, this.view.scrollDOM.scrollLeft = e.xMargin;
            return;
          }
          for (let c of this.view.state.facet(XO))
            try {
              if (c(this.view, e.range, e))
                return true;
            } catch (u) {
              Bn(this.view.state, u, "scroll handler");
            }
          let { range: n } = e, r = this.coordsAt(n.head, n.empty ? n.assoc : n.head > n.anchor ? -1 : 1), i;
          if (!r)
            return;
          !n.empty && (i = this.coordsAt(n.anchor, n.anchor > n.head ? -1 : 1)) && (r = {
            left: Math.min(r.left, i.left),
            top: Math.min(r.top, i.top),
            right: Math.max(r.right, i.right),
            bottom: Math.max(r.bottom, i.bottom)
          });
          let o = Rx(this.view), s = {
            left: r.left - o.left,
            top: r.top - o.top,
            right: r.right + o.right,
            bottom: r.bottom + o.bottom
          }, { offsetWidth: a, offsetHeight: l } = this.view.scrollDOM;
          JW(this.view.scrollDOM, s, n.head < n.anchor ? -1 : 1, e.x, e.y, Math.max(Math.min(e.xMargin, a), -a), Math.max(Math.min(e.yMargin, l), -l), this.view.textDirection == rt.LTR);
        }
      }
      function b7(t) {
        return t.node.nodeType == 1 && t.node.firstChild && (t.offset == 0 || t.node.childNodes[t.offset - 1].contentEditable == "false") && (t.offset == t.node.childNodes.length || t.node.childNodes[t.offset].contentEditable == "false");
      }
      function nR(t, e) {
        let n = t.observer.selectionRange;
        if (!n.focusNode)
          return null;
        let r = MO(n.focusNode, n.focusOffset), i = AO(n.focusNode, n.focusOffset), o = r || i;
        if (i && r && i.node != r.node) {
          let a = Ze.get(i.node);
          if (!a || a instanceof Ur && a.text != i.node.nodeValue)
            o = i;
          else if (t.docView.lastCompositionAfterCursor) {
            let l = Ze.get(r.node);
            !l || l instanceof Ur && l.text != r.node.nodeValue || (o = i);
          }
        }
        if (t.docView.lastCompositionAfterCursor = o != r, !o)
          return null;
        let s = e - o.offset;
        return {
          from: s,
          to: s + o.node.nodeValue.length,
          node: o.node
        };
      }
      function x7(t, e, n) {
        let r = nR(t, n);
        if (!r)
          return null;
        let { node: i, from: o, to: s } = r, a = i.nodeValue;
        if (/[\n\r]/.test(a) || t.state.doc.sliceString(r.from, r.to) != a)
          return null;
        let l = e.invertedDesc, c = new br(l.mapPos(o), l.mapPos(s), o, s), u = [];
        for (let h = i.parentNode; ; h = h.parentNode) {
          let p = Ze.get(h);
          if (p instanceof no)
            u.push({
              node: h,
              deco: p.mark
            });
          else {
            if (p instanceof Pt || h.nodeName == "DIV" && h.parentNode == t.contentDOM)
              return {
                range: c,
                text: i,
                marks: u,
                line: h
              };
            if (h != t.contentDOM)
              u.push({
                node: h,
                deco: new of({
                  inclusive: true,
                  attributes: a7(h),
                  tagName: h.tagName.toLowerCase()
                })
              });
            else
              return null;
          }
        }
      }
      function S7(t, e) {
        return t.nodeType != 1 ? 0 : (e && t.childNodes[e - 1].contentEditable == "false" ? 1 : 0) | (e < t.childNodes.length && t.childNodes[e].contentEditable == "false" ? 2 : 0);
      }
      let w7 = class {
        constructor() {
          this.changes = [];
        }
        compareRange(e, n) {
          xd(e, n, this.changes);
        }
        comparePoint(e, n) {
          xd(e, n, this.changes);
        }
        boundChange(e) {
          xd(e, e, this.changes);
        }
      };
      function k7(t, e, n) {
        let r = new w7();
        return Ve.compare(t, e, n, r), r.changes;
      }
      function C7(t, e) {
        for (let n = t; n && n != e; n = n.assignedSlot || n.parentNode)
          if (n.nodeType == 1 && n.contentEditable == "false")
            return true;
        return false;
      }
      function T7(t, e) {
        let n = false;
        return e && t.iterChangedRanges((r, i) => {
          r < e.to && i > e.from && (n = true);
        }), n;
      }
      function M7(t, e, n = 1) {
        let r = t.charCategorizer(e), i = t.doc.lineAt(e), o = e - i.from;
        if (i.length == 0)
          return q.cursor(e);
        o == 0 ? n = 1 : o == i.length && (n = -1);
        let s = o, a = o;
        n < 0 ? s = en(i.text, o, false) : a = en(i.text, o);
        let l = r(i.text.slice(s, a));
        for (; s > 0; ) {
          let c = en(i.text, s, false);
          if (r(i.text.slice(c, s)) != l)
            break;
          s = c;
        }
        for (; a < i.length; ) {
          let c = en(i.text, a);
          if (r(i.text.slice(a, c)) != l)
            break;
          a = c;
        }
        return q.range(s + i.from, a + i.from);
      }
      function A7(t, e) {
        return e.left > t ? e.left - t : Math.max(0, t - e.right);
      }
      function E7(t, e) {
        return e.top > t ? e.top - t : Math.max(0, t - e.bottom);
      }
      function I0(t, e) {
        return t.top < e.bottom - 1 && t.bottom > e.top + 1;
      }
      function PC(t, e) {
        return e < t.top ? {
          top: e,
          left: t.left,
          right: t.right,
          bottom: t.bottom
        } : t;
      }
      function OC(t, e) {
        return e > t.bottom ? {
          top: t.top,
          left: t.left,
          right: t.right,
          bottom: e
        } : t;
      }
      function r1(t, e, n) {
        let r, i, o, s, a = false, l, c, u, h;
        for (let y = t.firstChild; y; y = y.nextSibling) {
          let S = hl(y);
          for (let C = 0; C < S.length; C++) {
            let w = S[C];
            i && I0(i, w) && (w = PC(OC(w, i.bottom), i.top));
            let k = A7(e, w), T = E7(n, w);
            if (k == 0 && T == 0)
              return y.nodeType == 3 ? RC(y, e, n) : r1(y, e, n);
            if (!r || s > T || s == T && o > k) {
              r = y, i = w, o = k, s = T;
              let P = T ? n < w.top ? -1 : 1 : k ? e < w.left ? -1 : 1 : 0;
              a = !P || (P > 0 ? C < S.length - 1 : C > 0);
            }
            k == 0 ? n > w.bottom && (!u || u.bottom < w.bottom) ? (l = y, u = w) : n < w.top && (!h || h.top > w.top) && (c = y, h = w) : u && I0(u, w) ? u = OC(u, w.bottom) : h && I0(h, w) && (h = PC(h, w.top));
          }
        }
        if (u && u.bottom >= n ? (r = l, i = u) : h && h.top <= n && (r = c, i = h), !r)
          return {
            node: t,
            offset: 0
          };
        let p = Math.max(i.left, Math.min(i.right, e));
        if (r.nodeType == 3)
          return RC(r, p, n);
        if (a && r.contentEditable != "false")
          return r1(r, p, n);
        let v = Array.prototype.indexOf.call(t.childNodes, r) + (e >= (i.left + i.right) / 2 ? 1 : 0);
        return {
          node: t,
          offset: v
        };
      }
      function RC(t, e, n) {
        let r = t.nodeValue.length, i = -1, o = 1e9, s = 0;
        for (let a = 0; a < r; a++) {
          let l = Ws(t, a, a + 1).getClientRects();
          for (let c = 0; c < l.length; c++) {
            let u = l[c];
            if (u.top == u.bottom)
              continue;
            s || (s = e - u.left);
            let h = (u.top > n ? u.top - n : n - u.bottom) - 1;
            if (u.left - 1 <= e && u.right + 1 >= e && h < o) {
              let p = e >= (u.left + u.right) / 2, v = p;
              if ((de.chrome || de.gecko) && Ws(t, a).getBoundingClientRect().left == u.right && (v = !p), h <= 0)
                return {
                  node: t,
                  offset: a + (v ? 1 : 0)
                };
              i = a + (v ? 1 : 0), o = h;
            }
          }
        }
        return {
          node: t,
          offset: i > -1 ? i : s > 0 ? t.nodeValue.length : 0
        };
      }
      function rR(t, e, n, r = -1) {
        var i, o;
        let s = t.contentDOM.getBoundingClientRect(), a = s.top + t.viewState.paddingTop, l, { docHeight: c } = t.viewState, { x: u, y: h } = e, p = h - a;
        if (p < 0)
          return 0;
        if (p > c)
          return t.state.doc.length;
        for (let P = t.viewState.heightOracle.textHeight / 2, R = false; l = t.elementAtHeight(p), l.type != kn.Text; )
          for (; p = r > 0 ? l.bottom + P : l.top - P, !(p >= 0 && p <= c); ) {
            if (R)
              return n ? null : 0;
            R = true, r = -r;
          }
        h = a + p;
        let v = l.from;
        if (v < t.viewport.from)
          return t.viewport.from == 0 ? 0 : n ? null : LC(t, s, l, u, h);
        if (v > t.viewport.to)
          return t.viewport.to == t.state.doc.length ? t.state.doc.length : n ? null : LC(t, s, l, u, h);
        let y = t.dom.ownerDocument, S = t.root.elementFromPoint ? t.root : y, C = S.elementFromPoint(u, h);
        C && !t.contentDOM.contains(C) && (C = null), C || (u = Math.max(s.left + 1, Math.min(s.right - 1, u)), C = S.elementFromPoint(u, h), C && !t.contentDOM.contains(C) && (C = null));
        let w, k = -1;
        if (C && ((i = t.docView.nearest(C)) === null || i === void 0 ? void 0 : i.isEditable) != false) {
          if (y.caretPositionFromPoint) {
            let P = y.caretPositionFromPoint(u, h);
            P && ({ offsetNode: w, offset: k } = P);
          } else if (y.caretRangeFromPoint) {
            let P = y.caretRangeFromPoint(u, h);
            P && ({ startContainer: w, startOffset: k } = P, (!t.contentDOM.contains(w) || de.safari && P7(w, k, u) || de.chrome && O7(w, k, u)) && (w = void 0));
          }
          w && (k = Math.min(Ti(w), k));
        }
        if (!w || !t.docView.dom.contains(w)) {
          let P = Pt.find(t.docView, v);
          if (!P)
            return p > l.top + l.height / 2 ? l.to : l.from;
          ({ node: w, offset: k } = r1(P.dom, u, h));
        }
        let T = t.docView.nearest(w);
        if (!T)
          return null;
        if (T.isWidget && ((o = T.dom) === null || o === void 0 ? void 0 : o.nodeType) == 1) {
          let P = T.dom.getBoundingClientRect();
          return e.y < P.top || e.y <= P.bottom && e.x <= (P.left + P.right) / 2 ? T.posAtStart : T.posAtEnd;
        } else
          return T.localPosFromDOM(w, k) + T.posAtStart;
      }
      function LC(t, e, n, r, i) {
        let o = Math.round((r - e.left) * t.defaultCharacterWidth);
        if (t.lineWrapping && n.height > t.defaultLineHeight * 1.5) {
          let a = t.viewState.heightOracle.textHeight, l = Math.floor((i - n.top - (t.defaultLineHeight - a) * 0.5) / a);
          o += l * t.viewState.heightOracle.lineLength;
        }
        let s = t.state.sliceDoc(n.from, n.to);
        return n.from + jy(s, o, t.state.tabSize);
      }
      function P7(t, e, n) {
        let r;
        if (t.nodeType != 3 || e != (r = t.nodeValue.length))
          return false;
        for (let i = t.nextSibling; i; i = i.nextSibling)
          if (i.nodeType != 1 || i.nodeName != "BR")
            return false;
        return Ws(t, r - 1, r).getBoundingClientRect().left > n;
      }
      function O7(t, e, n) {
        if (e != 0)
          return false;
        for (let i = t; ; ) {
          let o = i.parentNode;
          if (!o || o.nodeType != 1 || o.firstChild != i)
            return false;
          if (o.classList.contains("cm-line"))
            break;
          i = o;
        }
        let r = t.nodeType == 1 ? t.getBoundingClientRect() : Ws(t, 0, Math.max(t.nodeValue.length, 1)).getBoundingClientRect();
        return n - r.left > 5;
      }
      function i1(t, e) {
        let n = t.lineBlockAt(e);
        if (Array.isArray(n.type)) {
          for (let r of n.type)
            if (r.to > e || r.to == e && (r.to == n.to || r.type == kn.Text))
              return r;
        }
        return n;
      }
      function R7(t, e, n, r) {
        let i = i1(t, e.head), o = !r || i.type != kn.Text || !(t.lineWrapping || i.widgetLineBreaks) ? null : t.coordsAtPos(e.assoc < 0 && e.head > i.from ? e.head - 1 : e.head);
        if (o) {
          let s = t.dom.getBoundingClientRect(), a = t.textDirectionAt(i.from), l = t.posAtCoords({
            x: n == (a == rt.LTR) ? s.right - 1 : s.left + 1,
            y: (o.top + o.bottom) / 2
          });
          if (l != null)
            return q.cursor(l, n ? -1 : 1);
        }
        return q.cursor(n ? i.to : i.from, n ? -1 : 1);
      }
      function DC(t, e, n, r) {
        let i = t.state.doc.lineAt(e.head), o = t.bidiSpans(i), s = t.textDirectionAt(i.from);
        for (let a = e, l = null; ; ) {
          let c = g7(i, o, s, a, n), u = VO;
          if (!c) {
            if (i.number == (n ? t.state.doc.lines : 1))
              return a;
            u = `
`, i = t.state.doc.line(i.number + (n ? 1 : -1)), o = t.bidiSpans(i), c = t.visualLineSide(i, !n);
          }
          if (l) {
            if (!l(u))
              return a;
          } else {
            if (!r)
              return c;
            l = r(u);
          }
          a = c;
        }
      }
      function L7(t, e, n) {
        let r = t.state.charCategorizer(e), i = r(n);
        return (o) => {
          let s = r(o);
          return i == ht.Space && (i = s), i == s;
        };
      }
      function D7(t, e, n, r) {
        let i = e.head, o = n ? 1 : -1;
        if (i == (n ? t.state.doc.length : 0))
          return q.cursor(i, e.assoc);
        let s = e.goalColumn, a, l = t.contentDOM.getBoundingClientRect(), c = t.coordsAtPos(i, e.assoc || -1), u = t.documentTop;
        if (c)
          s == null && (s = c.left - l.left), a = o < 0 ? c.top : c.bottom;
        else {
          let v = t.viewState.lineBlockAt(i);
          s == null && (s = Math.min(l.right - l.left, t.defaultCharacterWidth * (i - v.from))), a = (o < 0 ? v.top : v.bottom) + u;
        }
        let h = l.left + s, p = r ?? t.viewState.heightOracle.textHeight >> 1;
        for (let v = 0; ; v += 10) {
          let y = a + (p + v) * o, S = rR(t, {
            x: h,
            y
          }, false, o);
          if (y < l.top || y > l.bottom || (o < 0 ? S < i : S > i)) {
            let C = t.docView.coordsForChar(S), w = !C || y < C.top ? -1 : 1;
            return q.cursor(S, w, void 0, s);
          }
        }
      }
      function Sd(t, e, n) {
        for (; ; ) {
          let r = 0;
          for (let i of t)
            i.between(e - 1, e + 1, (o, s, a) => {
              if (e > o && e < s) {
                let l = r || n || (e - o < s - e ? -1 : 1);
                e = l < 0 ? o : s, r = l;
              }
            });
          if (!r)
            return e;
        }
      }
      function B0(t, e, n) {
        let r = Sd(t.state.facet(Ox).map((i) => i(t)), n.from, e.head > n.from ? -1 : 1);
        return r == n.from ? n : q.cursor(r, r < n.from ? 1 : -1);
      }
      const xc = "\uFFFF";
      class _7 {
        constructor(e, n) {
          this.points = e, this.text = "", this.lineSeparator = n.facet(Ne.lineSeparator);
        }
        append(e) {
          this.text += e;
        }
        lineBreak() {
          this.text += xc;
        }
        readRange(e, n) {
          if (!e)
            return this;
          let r = e.parentNode;
          for (let i = e; ; ) {
            this.findPointBefore(r, i);
            let o = this.text.length;
            this.readNode(i);
            let s = i.nextSibling;
            if (s == n)
              break;
            let a = Ze.get(i), l = Ze.get(s);
            (a && l ? a.breakAfter : (a ? a.breakAfter : bp(i)) || bp(s) && (i.nodeName != "BR" || i.cmIgnore) && this.text.length > o) && this.lineBreak(), i = s;
          }
          return this.findPointBefore(r, n), this;
        }
        readTextNode(e) {
          let n = e.nodeValue;
          for (let r of this.points)
            r.node == e && (r.pos = this.text.length + Math.min(r.offset, n.length));
          for (let r = 0, i = this.lineSeparator ? null : /\r\n?|\n/g; ; ) {
            let o = -1, s = 1, a;
            if (this.lineSeparator ? (o = n.indexOf(this.lineSeparator, r), s = this.lineSeparator.length) : (a = i.exec(n)) && (o = a.index, s = a[0].length), this.append(n.slice(r, o < 0 ? n.length : o)), o < 0)
              break;
            if (this.lineBreak(), s > 1)
              for (let l of this.points)
                l.node == e && l.pos > this.text.length && (l.pos -= s - 1);
            r = o + s;
          }
        }
        readNode(e) {
          if (e.cmIgnore)
            return;
          let n = Ze.get(e), r = n && n.overrideDOMText;
          if (r != null) {
            this.findPointInside(e, r.length);
            for (let i = r.iter(); !i.next().done; )
              i.lineBreak ? this.lineBreak() : this.append(i.value);
          } else
            e.nodeType == 3 ? this.readTextNode(e) : e.nodeName == "BR" ? e.nextSibling && this.lineBreak() : e.nodeType == 1 && this.readRange(e.firstChild, null);
        }
        findPointBefore(e, n) {
          for (let r of this.points)
            r.node == e && e.childNodes[r.offset] == n && (r.pos = this.text.length);
        }
        findPointInside(e, n) {
          for (let r of this.points)
            (e.nodeType == 3 ? r.node == e : e.contains(r.node)) && (r.pos = this.text.length + (I7(e, r.node, r.offset) ? n : 0));
        }
      }
      function I7(t, e, n) {
        for (; ; ) {
          if (!e || n < Ti(e))
            return false;
          if (e == t)
            return true;
          n = js(e) + 1, e = e.parentNode;
        }
      }
      class _C {
        constructor(e, n) {
          this.node = e, this.offset = n, this.pos = -1;
        }
      }
      class B7 {
        constructor(e, n, r, i) {
          this.typeOver = i, this.bounds = null, this.text = "", this.domChanged = n > -1;
          let { impreciseHead: o, impreciseAnchor: s } = e.docView;
          if (e.state.readOnly && n > -1)
            this.newSel = null;
          else if (n > -1 && (this.bounds = e.docView.domBoundsAround(n, r, 0))) {
            let a = o || s ? [] : z7(e), l = new _7(a, e.state);
            l.readRange(this.bounds.startDOM, this.bounds.endDOM), this.text = l.text, this.newSel = F7(a, this.bounds.from);
          } else {
            let a = e.observer.selectionRange, l = o && o.node == a.focusNode && o.offset == a.focusOffset || !Ky(e.contentDOM, a.focusNode) ? e.state.selection.main.head : e.docView.posFromDOM(a.focusNode, a.focusOffset), c = s && s.node == a.anchorNode && s.offset == a.anchorOffset || !Ky(e.contentDOM, a.anchorNode) ? e.state.selection.main.anchor : e.docView.posFromDOM(a.anchorNode, a.anchorOffset), u = e.viewport;
            if ((de.ios || de.chrome) && e.state.selection.main.empty && l != c && (u.from > 0 || u.to < e.state.doc.length)) {
              let h = Math.min(l, c), p = Math.max(l, c), v = u.from - h, y = u.to - p;
              (v == 0 || v == 1 || h == 0) && (y == 0 || y == -1 || p == e.state.doc.length) && (l = 0, c = e.state.doc.length);
            }
            this.newSel = q.single(c, l);
          }
        }
      }
      function iR(t, e) {
        let n, { newSel: r } = e, i = t.state.selection.main, o = t.inputState.lastKeyTime > Date.now() - 100 ? t.inputState.lastKeyCode : -1;
        if (e.bounds) {
          let { from: s, to: a } = e.bounds, l = i.from, c = null;
          (o === 8 || de.android && e.text.length < a - s) && (l = i.to, c = "end");
          let u = $7(t.state.doc.sliceString(s, a, xc), e.text, l - s, c);
          u && (de.chrome && o == 13 && u.toB == u.from + 2 && e.text.slice(u.from, u.toB) == xc + xc && u.toB--, n = {
            from: s + u.from,
            to: s + u.toA,
            insert: He.of(e.text.slice(u.from, u.toB).split(xc))
          });
        } else
          r && (!t.hasFocus && t.state.facet(Fi) || r.main.eq(i)) && (r = null);
        if (!n && !r)
          return false;
        if (!n && e.typeOver && !i.empty && r && r.main.empty ? n = {
          from: i.from,
          to: i.to,
          insert: t.state.doc.slice(i.from, i.to)
        } : (de.mac || de.android) && n && n.from == n.to && n.from == i.head - 1 && /^\. ?$/.test(n.insert.toString()) && t.contentDOM.getAttribute("autocorrect") == "off" ? (r && n.insert.length == 2 && (r = q.single(r.main.anchor - 1, r.main.head - 1)), n = {
          from: n.from,
          to: n.to,
          insert: He.of([
            n.insert.toString().replace(".", " ")
          ])
        }) : n && n.from >= i.from && n.to <= i.to && (n.from != i.from || n.to != i.to) && i.to - i.from - (n.to - n.from) <= 4 ? n = {
          from: i.from,
          to: i.to,
          insert: t.state.doc.slice(i.from, n.from).append(n.insert).append(t.state.doc.slice(n.to, i.to))
        } : de.chrome && n && n.from == n.to && n.from == i.head && n.insert.toString() == `
 ` && t.lineWrapping && (r && (r = q.single(r.main.anchor - 1, r.main.head - 1)), n = {
          from: i.from,
          to: i.to,
          insert: He.of([
            " "
          ])
        }), n)
          return Lx(t, n, r, o);
        if (r && !r.main.eq(i)) {
          let s = false, a = "select";
          return t.inputState.lastSelectionTime > Date.now() - 50 && (t.inputState.lastSelectionOrigin == "select" && (s = true), a = t.inputState.lastSelectionOrigin), t.dispatch({
            selection: r,
            scrollIntoView: s,
            userEvent: a
          }), true;
        } else
          return false;
      }
      function Lx(t, e, n, r = -1) {
        if (de.ios && t.inputState.flushIOSKey(e))
          return true;
        let i = t.state.selection.main;
        if (de.android && (e.to == i.to && (e.from == i.from || e.from == i.from - 1 && t.state.sliceDoc(e.from, i.from) == " ") && e.insert.length == 1 && e.insert.lines == 2 && Ga(t.contentDOM, "Enter", 13) || (e.from == i.from - 1 && e.to == i.to && e.insert.length == 0 || r == 8 && e.insert.length < e.to - e.from && e.to > i.head) && Ga(t.contentDOM, "Backspace", 8) || e.from == i.from && e.to == i.to + 1 && e.insert.length == 0 && Ga(t.contentDOM, "Delete", 46)))
          return true;
        let o = e.insert.toString();
        t.inputState.composing >= 0 && t.inputState.composing++;
        let s, a = () => s || (s = N7(t, e, n));
        return t.state.facet(KO).some((l) => l(t, e.from, e.to, o, a)) || t.dispatch(a()), true;
      }
      function N7(t, e, n) {
        let r, i = t.state, o = i.selection.main;
        if (e.from >= o.from && e.to <= o.to && e.to - e.from >= (o.to - o.from) / 3 && (!n || n.main.empty && n.main.from == e.from + e.insert.length) && t.inputState.composing < 0) {
          let a = o.from < e.from ? i.sliceDoc(o.from, e.from) : "", l = o.to > e.to ? i.sliceDoc(e.to, o.to) : "";
          r = i.replaceSelection(t.state.toText(a + e.insert.sliceString(0, void 0, t.state.lineBreak) + l));
        } else {
          let a = i.changes(e), l = n && n.main.to <= a.newLength ? n.main : void 0;
          if (i.selection.ranges.length > 1 && t.inputState.composing >= 0 && e.to <= o.to && e.to >= o.to - 10) {
            let c = t.state.sliceDoc(e.from, e.to), u, h = n && nR(t, n.main.head);
            if (h) {
              let y = e.insert.length - (e.to - e.from);
              u = {
                from: h.from,
                to: h.to - y
              };
            } else
              u = t.state.doc.lineAt(o.head);
            let p = o.to - e.to, v = o.to - o.from;
            r = i.changeByRange((y) => {
              if (y.from == o.from && y.to == o.to)
                return {
                  changes: a,
                  range: l || y.map(a)
                };
              let S = y.to - p, C = S - c.length;
              if (y.to - y.from != v || t.state.sliceDoc(C, S) != c || y.to >= u.from && y.from <= u.to)
                return {
                  range: y
                };
              let w = i.changes({
                from: C,
                to: S,
                insert: e.insert
              }), k = y.to - o.to;
              return {
                changes: w,
                range: l ? q.range(Math.max(0, l.anchor + k), Math.max(0, l.head + k)) : y.map(w)
              };
            });
          } else
            r = {
              changes: a,
              selection: l && i.selection.replaceRange(l)
            };
        }
        let s = "input.type";
        return (t.composing || t.inputState.compositionPendingChange && t.inputState.compositionEndedAt > Date.now() - 50) && (t.inputState.compositionPendingChange = false, s += ".compose", t.inputState.compositionFirstChange && (s += ".start", t.inputState.compositionFirstChange = false)), i.update(r, {
          userEvent: s,
          scrollIntoView: true
        });
      }
      function $7(t, e, n, r) {
        let i = Math.min(t.length, e.length), o = 0;
        for (; o < i && t.charCodeAt(o) == e.charCodeAt(o); )
          o++;
        if (o == i && t.length == e.length)
          return null;
        let s = t.length, a = e.length;
        for (; s > 0 && a > 0 && t.charCodeAt(s - 1) == e.charCodeAt(a - 1); )
          s--, a--;
        if (r == "end") {
          let l = Math.max(0, o - Math.min(s, a));
          n -= s + l - o;
        }
        if (s < o && t.length < e.length) {
          let l = n <= o && n >= s ? o - n : 0;
          o -= l, a = o + (a - s), s = o;
        } else if (a < o) {
          let l = n <= o && n >= a ? o - n : 0;
          o -= l, s = o + (s - a), a = o;
        }
        return {
          from: o,
          toA: s,
          toB: a
        };
      }
      function z7(t) {
        let e = [];
        if (t.root.activeElement != t.contentDOM)
          return e;
        let { anchorNode: n, anchorOffset: r, focusNode: i, focusOffset: o } = t.observer.selectionRange;
        return n && (e.push(new _C(n, r)), (i != n || o != r) && e.push(new _C(i, o))), e;
      }
      function F7(t, e) {
        if (t.length == 0)
          return null;
        let n = t[0].pos, r = t.length == 2 ? t[1].pos : n;
        return n > -1 && r > -1 ? q.single(n + e, r + e) : null;
      }
      class V7 {
        setSelectionOrigin(e) {
          this.lastSelectionOrigin = e, this.lastSelectionTime = Date.now();
        }
        constructor(e) {
          this.view = e, this.lastKeyCode = 0, this.lastKeyTime = 0, this.lastTouchTime = 0, this.lastFocusTime = 0, this.lastScrollTop = 0, this.lastScrollLeft = 0, this.pendingIOSKey = void 0, this.tabFocusMode = -1, this.lastSelectionOrigin = null, this.lastSelectionTime = 0, this.lastContextMenu = 0, this.scrollHandlers = [], this.handlers = /* @__PURE__ */ Object.create(null), this.composing = -1, this.compositionFirstChange = null, this.compositionEndedAt = 0, this.compositionPendingKey = false, this.compositionPendingChange = false, this.mouseSelection = null, this.draggedContent = null, this.handleEvent = this.handleEvent.bind(this), this.notifiedFocused = e.hasFocus, de.safari && e.contentDOM.addEventListener("input", () => null), de.gecko && rU(e.contentDOM.ownerDocument);
        }
        handleEvent(e) {
          !Y7(this.view, e) || this.ignoreDuringComposition(e) || e.type == "keydown" && this.keydown(e) || (this.view.updateState != 0 ? Promise.resolve().then(() => this.runHandlers(e.type, e)) : this.runHandlers(e.type, e));
        }
        runHandlers(e, n) {
          let r = this.handlers[e];
          if (r) {
            for (let i of r.observers)
              i(this.view, n);
            for (let i of r.handlers) {
              if (n.defaultPrevented)
                break;
              if (i(this.view, n)) {
                n.preventDefault();
                break;
              }
            }
          }
        }
        ensureHandlers(e) {
          let n = H7(e), r = this.handlers, i = this.view.contentDOM;
          for (let o in n)
            if (o != "scroll") {
              let s = !n[o].handlers.length, a = r[o];
              a && s != !a.handlers.length && (i.removeEventListener(o, this.handleEvent), a = null), a || i.addEventListener(o, this.handleEvent, {
                passive: s
              });
            }
          for (let o in r)
            o != "scroll" && !n[o] && i.removeEventListener(o, this.handleEvent);
          this.handlers = n;
        }
        keydown(e) {
          if (this.lastKeyCode = e.keyCode, this.lastKeyTime = Date.now(), e.keyCode == 9 && this.tabFocusMode > -1 && (!this.tabFocusMode || Date.now() <= this.tabFocusMode))
            return true;
          if (this.tabFocusMode > 0 && e.keyCode != 27 && sR.indexOf(e.keyCode) < 0 && (this.tabFocusMode = -1), de.android && de.chrome && !e.synthetic && (e.keyCode == 13 || e.keyCode == 8))
            return this.view.observer.delayAndroidKey(e.key, e.keyCode), true;
          let n;
          return de.ios && !e.synthetic && !e.altKey && !e.metaKey && ((n = oR.find((r) => r.keyCode == e.keyCode)) && !e.ctrlKey || j7.indexOf(e.key) > -1 && e.ctrlKey && !e.shiftKey) ? (this.pendingIOSKey = n || e, setTimeout(() => this.flushIOSKey(), 250), true) : (e.keyCode != 229 && this.view.observer.forceFlush(), false);
        }
        flushIOSKey(e) {
          let n = this.pendingIOSKey;
          return !n || n.key == "Enter" && e && e.from < e.to && /^\S+$/.test(e.insert.toString()) ? false : (this.pendingIOSKey = void 0, Ga(this.view.contentDOM, n.key, n.keyCode, n instanceof KeyboardEvent ? n : void 0));
        }
        ignoreDuringComposition(e) {
          return /^key/.test(e.type) ? this.composing > 0 ? true : de.safari && !de.ios && this.compositionPendingKey && Date.now() - this.compositionEndedAt < 100 ? (this.compositionPendingKey = false, true) : false : false;
        }
        startMouseSelection(e) {
          this.mouseSelection && this.mouseSelection.destroy(), this.mouseSelection = e;
        }
        update(e) {
          this.view.observer.update(e), this.mouseSelection && this.mouseSelection.update(e), this.draggedContent && e.docChanged && (this.draggedContent = this.draggedContent.map(e.changes)), e.transactions.length && (this.lastKeyCode = this.lastSelectionTime = 0);
        }
        destroy() {
          this.mouseSelection && this.mouseSelection.destroy();
        }
      }
      function IC(t, e) {
        return (n, r) => {
          try {
            return e.call(t, r, n);
          } catch (i) {
            Bn(n.state, i);
          }
        };
      }
      function H7(t) {
        let e = /* @__PURE__ */ Object.create(null);
        function n(r) {
          return e[r] || (e[r] = {
            observers: [],
            handlers: []
          });
        }
        for (let r of t) {
          let i = r.spec;
          if (i && i.domEventHandlers)
            for (let o in i.domEventHandlers) {
              let s = i.domEventHandlers[o];
              s && n(o).handlers.push(IC(r.value, s));
            }
          if (i && i.domEventObservers)
            for (let o in i.domEventObservers) {
              let s = i.domEventObservers[o];
              s && n(o).observers.push(IC(r.value, s));
            }
        }
        for (let r in Kr)
          n(r).handlers.push(Kr[r]);
        for (let r in kr)
          n(r).observers.push(kr[r]);
        return e;
      }
      const oR = [
        {
          key: "Backspace",
          keyCode: 8,
          inputType: "deleteContentBackward"
        },
        {
          key: "Enter",
          keyCode: 13,
          inputType: "insertParagraph"
        },
        {
          key: "Enter",
          keyCode: 13,
          inputType: "insertLineBreak"
        },
        {
          key: "Delete",
          keyCode: 46,
          inputType: "deleteContentForward"
        }
      ], j7 = "dthko", sR = [
        16,
        17,
        18,
        20,
        91,
        92,
        224,
        225
      ], wh = 6;
      function kh(t) {
        return Math.max(0, t) * 0.7 + 8;
      }
      function W7(t, e) {
        return Math.max(Math.abs(t.clientX - e.clientX), Math.abs(t.clientY - e.clientY));
      }
      class U7 {
        constructor(e, n, r, i) {
          this.view = e, this.startEvent = n, this.style = r, this.mustSelect = i, this.scrollSpeed = {
            x: 0,
            y: 0
          }, this.scrolling = -1, this.lastEvent = n, this.scrollParents = ZW(e.contentDOM), this.atoms = e.state.facet(Ox).map((s) => s(e));
          let o = e.contentDOM.ownerDocument;
          o.addEventListener("mousemove", this.move = this.move.bind(this)), o.addEventListener("mouseup", this.up = this.up.bind(this)), this.extend = n.shiftKey, this.multiple = e.state.facet(Ne.allowMultipleSelections) && K7(e, n), this.dragging = G7(e, n) && cR(n) == 1 ? null : false;
        }
        start(e) {
          this.dragging === false && this.select(e);
        }
        move(e) {
          if (e.buttons == 0)
            return this.destroy();
          if (this.dragging || this.dragging == null && W7(this.startEvent, e) < 10)
            return;
          this.select(this.lastEvent = e);
          let n = 0, r = 0, i = 0, o = 0, s = this.view.win.innerWidth, a = this.view.win.innerHeight;
          this.scrollParents.x && ({ left: i, right: s } = this.scrollParents.x.getBoundingClientRect()), this.scrollParents.y && ({ top: o, bottom: a } = this.scrollParents.y.getBoundingClientRect());
          let l = Rx(this.view);
          e.clientX - l.left <= i + wh ? n = -kh(i - e.clientX) : e.clientX + l.right >= s - wh && (n = kh(e.clientX - s)), e.clientY - l.top <= o + wh ? r = -kh(o - e.clientY) : e.clientY + l.bottom >= a - wh && (r = kh(e.clientY - a)), this.setScrollSpeed(n, r);
        }
        up(e) {
          this.dragging == null && this.select(this.lastEvent), this.dragging || e.preventDefault(), this.destroy();
        }
        destroy() {
          this.setScrollSpeed(0, 0);
          let e = this.view.contentDOM.ownerDocument;
          e.removeEventListener("mousemove", this.move), e.removeEventListener("mouseup", this.up), this.view.inputState.mouseSelection = this.view.inputState.draggedContent = null;
        }
        setScrollSpeed(e, n) {
          this.scrollSpeed = {
            x: e,
            y: n
          }, e || n ? this.scrolling < 0 && (this.scrolling = setInterval(() => this.scroll(), 50)) : this.scrolling > -1 && (clearInterval(this.scrolling), this.scrolling = -1);
        }
        scroll() {
          let { x: e, y: n } = this.scrollSpeed;
          e && this.scrollParents.x && (this.scrollParents.x.scrollLeft += e, e = 0), n && this.scrollParents.y && (this.scrollParents.y.scrollTop += n, n = 0), (e || n) && this.view.win.scrollBy(e, n), this.dragging === false && this.select(this.lastEvent);
        }
        skipAtoms(e) {
          let n = null;
          for (let r = 0; r < e.ranges.length; r++) {
            let i = e.ranges[r], o = null;
            if (i.empty) {
              let s = Sd(this.atoms, i.from, 0);
              s != i.from && (o = q.cursor(s, -1));
            } else {
              let s = Sd(this.atoms, i.from, -1), a = Sd(this.atoms, i.to, 1);
              (s != i.from || a != i.to) && (o = q.range(i.from == i.anchor ? s : a, i.from == i.head ? s : a));
            }
            o && (n || (n = e.ranges.slice()), n[r] = o);
          }
          return n ? q.create(n, e.mainIndex) : e;
        }
        select(e) {
          let { view: n } = this, r = this.skipAtoms(this.style.get(e, this.extend, this.multiple));
          (this.mustSelect || !r.eq(n.state.selection, this.dragging === false)) && this.view.dispatch({
            selection: r,
            userEvent: "select.pointer"
          }), this.mustSelect = false;
        }
        update(e) {
          e.transactions.some((n) => n.isUserEvent("input.type")) ? this.destroy() : this.style.update(e) && setTimeout(() => this.select(this.lastEvent), 20);
        }
      }
      function K7(t, e) {
        let n = t.state.facet(HO);
        return n.length ? n[0](e) : de.mac ? e.metaKey : e.ctrlKey;
      }
      function q7(t, e) {
        let n = t.state.facet(jO);
        return n.length ? n[0](e) : de.mac ? !e.altKey : !e.ctrlKey;
      }
      function G7(t, e) {
        let { main: n } = t.state.selection;
        if (n.empty)
          return false;
        let r = Iu(t.root);
        if (!r || r.rangeCount == 0)
          return true;
        let i = r.getRangeAt(0).getClientRects();
        for (let o = 0; o < i.length; o++) {
          let s = i[o];
          if (s.left <= e.clientX && s.right >= e.clientX && s.top <= e.clientY && s.bottom >= e.clientY)
            return true;
        }
        return false;
      }
      function Y7(t, e) {
        if (!e.bubbles)
          return true;
        if (e.defaultPrevented)
          return false;
        for (let n = e.target, r; n != t.contentDOM; n = n.parentNode)
          if (!n || n.nodeType == 11 || (r = Ze.get(n)) && r.ignoreEvent(e))
            return false;
        return true;
      }
      const Kr = /* @__PURE__ */ Object.create(null), kr = /* @__PURE__ */ Object.create(null), aR = de.ie && de.ie_version < 15 || de.ios && de.webkit_version < 604;
      function X7(t) {
        let e = t.dom.parentNode;
        if (!e)
          return;
        let n = e.appendChild(document.createElement("textarea"));
        n.style.cssText = "position: fixed; left: -10000px; top: 10px", n.focus(), setTimeout(() => {
          t.focus(), n.remove(), lR(t, n.value);
        }, 50);
      }
      function Vm(t, e, n) {
        for (let r of t.facet(e))
          n = r(n, t);
        return n;
      }
      function lR(t, e) {
        e = Vm(t.state, Ax, e);
        let { state: n } = t, r, i = 1, o = n.toText(e), s = o.lines == n.selection.ranges.length;
        if (o1 != null && n.selection.ranges.every((l) => l.empty) && o1 == o.toString()) {
          let l = -1;
          r = n.changeByRange((c) => {
            let u = n.doc.lineAt(c.from);
            if (u.from == l)
              return {
                range: c
              };
            l = u.from;
            let h = n.toText((s ? o.line(i++).text : e) + n.lineBreak);
            return {
              changes: {
                from: u.from,
                insert: h
              },
              range: q.cursor(c.from + h.length)
            };
          });
        } else
          s ? r = n.changeByRange((l) => {
            let c = o.line(i++);
            return {
              changes: {
                from: l.from,
                to: l.to,
                insert: c.text
              },
              range: q.cursor(l.from + c.length)
            };
          }) : r = n.replaceSelection(o);
        t.dispatch(r, {
          userEvent: "input.paste",
          scrollIntoView: true
        });
      }
      kr.scroll = (t) => {
        t.inputState.lastScrollTop = t.scrollDOM.scrollTop, t.inputState.lastScrollLeft = t.scrollDOM.scrollLeft;
      };
      Kr.keydown = (t, e) => (t.inputState.setSelectionOrigin("select"), e.keyCode == 27 && t.inputState.tabFocusMode != 0 && (t.inputState.tabFocusMode = Date.now() + 2e3), false);
      kr.touchstart = (t, e) => {
        t.inputState.lastTouchTime = Date.now(), t.inputState.setSelectionOrigin("select.pointer");
      };
      kr.touchmove = (t) => {
        t.inputState.setSelectionOrigin("select.pointer");
      };
      Kr.mousedown = (t, e) => {
        if (t.observer.flush(), t.inputState.lastTouchTime > Date.now() - 2e3)
          return false;
        let n = null;
        for (let r of t.state.facet(WO))
          if (n = r(t, e), n)
            break;
        if (!n && e.button == 0 && (n = Z7(t, e)), n) {
          let r = !t.hasFocus;
          t.inputState.startMouseSelection(new U7(t, e, n, r)), r && t.observer.ignore(() => {
            kO(t.contentDOM);
            let o = t.root.activeElement;
            o && !o.contains(t.contentDOM) && o.blur();
          });
          let i = t.inputState.mouseSelection;
          if (i)
            return i.start(e), i.dragging === false;
        }
        return false;
      };
      function BC(t, e, n, r) {
        if (r == 1)
          return q.cursor(e, n);
        if (r == 2)
          return M7(t.state, e, n);
        {
          let i = Pt.find(t.docView, e), o = t.state.doc.lineAt(i ? i.posAtEnd : e), s = i ? i.posAtStart : o.from, a = i ? i.posAtEnd : o.to;
          return a < t.state.doc.length && a == o.to && a++, q.range(s, a);
        }
      }
      let NC = (t, e, n) => e >= n.top && e <= n.bottom && t >= n.left && t <= n.right;
      function Q7(t, e, n, r) {
        let i = Pt.find(t.docView, e);
        if (!i)
          return 1;
        let o = e - i.posAtStart;
        if (o == 0)
          return 1;
        if (o == i.length)
          return -1;
        let s = i.coordsAt(o, -1);
        if (s && NC(n, r, s))
          return -1;
        let a = i.coordsAt(o, 1);
        return a && NC(n, r, a) ? 1 : s && s.bottom >= r ? -1 : 1;
      }
      function $C(t, e) {
        let n = t.posAtCoords({
          x: e.clientX,
          y: e.clientY
        }, false);
        return {
          pos: n,
          bias: Q7(t, n, e.clientX, e.clientY)
        };
      }
      const J7 = de.ie && de.ie_version <= 11;
      let zC = null, FC = 0, VC = 0;
      function cR(t) {
        if (!J7)
          return t.detail;
        let e = zC, n = VC;
        return zC = t, VC = Date.now(), FC = !e || n > Date.now() - 400 && Math.abs(e.clientX - t.clientX) < 2 && Math.abs(e.clientY - t.clientY) < 2 ? (FC + 1) % 3 : 1;
      }
      function Z7(t, e) {
        let n = $C(t, e), r = cR(e), i = t.state.selection;
        return {
          update(o) {
            o.docChanged && (n.pos = o.changes.mapPos(n.pos), i = i.map(o.changes));
          },
          get(o, s, a) {
            let l = $C(t, o), c, u = BC(t, l.pos, l.bias, r);
            if (n.pos != l.pos && !s) {
              let h = BC(t, n.pos, n.bias, r), p = Math.min(h.from, u.from), v = Math.max(h.to, u.to);
              u = p < u.from ? q.range(p, v) : q.range(v, p);
            }
            return s ? i.replaceRange(i.main.extend(u.from, u.to)) : a && r == 1 && i.ranges.length > 1 && (c = eU(i, l.pos)) ? c : a ? i.addRange(u) : q.create([
              u
            ]);
          }
        };
      }
      function eU(t, e) {
        for (let n = 0; n < t.ranges.length; n++) {
          let { from: r, to: i } = t.ranges[n];
          if (r <= e && i >= e)
            return q.create(t.ranges.slice(0, n).concat(t.ranges.slice(n + 1)), t.mainIndex == n ? 0 : t.mainIndex - (t.mainIndex > n ? 1 : 0));
        }
        return null;
      }
      Kr.dragstart = (t, e) => {
        let { selection: { main: n } } = t.state;
        if (e.target.draggable) {
          let i = t.docView.nearest(e.target);
          if (i && i.isWidget) {
            let o = i.posAtStart, s = o + i.length;
            (o >= n.to || s <= n.from) && (n = q.range(o, s));
          }
        }
        let { inputState: r } = t;
        return r.mouseSelection && (r.mouseSelection.dragging = true), r.draggedContent = n, e.dataTransfer && (e.dataTransfer.setData("Text", Vm(t.state, Ex, t.state.sliceDoc(n.from, n.to))), e.dataTransfer.effectAllowed = "copyMove"), false;
      };
      Kr.dragend = (t) => (t.inputState.draggedContent = null, false);
      function HC(t, e, n, r) {
        if (n = Vm(t.state, Ax, n), !n)
          return;
        let i = t.posAtCoords({
          x: e.clientX,
          y: e.clientY
        }, false), { draggedContent: o } = t.inputState, s = r && o && q7(t, e) ? {
          from: o.from,
          to: o.to
        } : null, a = {
          from: i,
          insert: n
        }, l = t.state.changes(s ? [
          s,
          a
        ] : a);
        t.focus(), t.dispatch({
          changes: l,
          selection: {
            anchor: l.mapPos(i, -1),
            head: l.mapPos(i, 1)
          },
          userEvent: s ? "move.drop" : "input.drop"
        }), t.inputState.draggedContent = null;
      }
      Kr.drop = (t, e) => {
        if (!e.dataTransfer)
          return false;
        if (t.state.readOnly)
          return true;
        let n = e.dataTransfer.files;
        if (n && n.length) {
          let r = Array(n.length), i = 0, o = () => {
            ++i == n.length && HC(t, e, r.filter((s) => s != null).join(t.state.lineBreak), false);
          };
          for (let s = 0; s < n.length; s++) {
            let a = new FileReader();
            a.onerror = o, a.onload = () => {
              /[\x00-\x08\x0e-\x1f]{2}/.test(a.result) || (r[s] = a.result), o();
            }, a.readAsText(n[s]);
          }
          return true;
        } else {
          let r = e.dataTransfer.getData("Text");
          if (r)
            return HC(t, e, r, true), true;
        }
        return false;
      };
      Kr.paste = (t, e) => {
        if (t.state.readOnly)
          return true;
        t.observer.flush();
        let n = aR ? null : e.clipboardData;
        return n ? (lR(t, n.getData("text/plain") || n.getData("text/uri-list")), true) : (X7(t), false);
      };
      function tU(t, e) {
        let n = t.dom.parentNode;
        if (!n)
          return;
        let r = n.appendChild(document.createElement("textarea"));
        r.style.cssText = "position: fixed; left: -10000px; top: 10px", r.value = e, r.focus(), r.selectionEnd = e.length, r.selectionStart = 0, setTimeout(() => {
          r.remove(), t.focus();
        }, 50);
      }
      function nU(t) {
        let e = [], n = [], r = false;
        for (let i of t.selection.ranges)
          i.empty || (e.push(t.sliceDoc(i.from, i.to)), n.push(i));
        if (!e.length) {
          let i = -1;
          for (let { from: o } of t.selection.ranges) {
            let s = t.doc.lineAt(o);
            s.number > i && (e.push(s.text), n.push({
              from: s.from,
              to: Math.min(t.doc.length, s.to + 1)
            })), i = s.number;
          }
          r = true;
        }
        return {
          text: Vm(t, Ex, e.join(t.lineBreak)),
          ranges: n,
          linewise: r
        };
      }
      let o1 = null;
      Kr.copy = Kr.cut = (t, e) => {
        let { text: n, ranges: r, linewise: i } = nU(t.state);
        if (!n && !i)
          return false;
        o1 = i ? n : null, e.type == "cut" && !t.state.readOnly && t.dispatch({
          changes: r,
          scrollIntoView: true,
          userEvent: "delete.cut"
        });
        let o = aR ? null : e.clipboardData;
        return o ? (o.clearData(), o.setData("text/plain", n), true) : (tU(t, n), false);
      };
      const uR = Ai.define();
      function fR(t, e) {
        let n = [];
        for (let r of t.facet(qO)) {
          let i = r(t, e);
          i && n.push(i);
        }
        return n ? t.update({
          effects: n,
          annotations: uR.of(true)
        }) : null;
      }
      function hR(t) {
        setTimeout(() => {
          let e = t.hasFocus;
          if (e != t.inputState.notifiedFocused) {
            let n = fR(t.state, e);
            n ? t.dispatch(n) : t.update([]);
          }
        }, 10);
      }
      kr.focus = (t) => {
        t.inputState.lastFocusTime = Date.now(), !t.scrollDOM.scrollTop && (t.inputState.lastScrollTop || t.inputState.lastScrollLeft) && (t.scrollDOM.scrollTop = t.inputState.lastScrollTop, t.scrollDOM.scrollLeft = t.inputState.lastScrollLeft), hR(t);
      };
      kr.blur = (t) => {
        t.observer.clearSelectionRange(), hR(t);
      };
      kr.compositionstart = kr.compositionupdate = (t) => {
        t.observer.editContext || (t.inputState.compositionFirstChange == null && (t.inputState.compositionFirstChange = true), t.inputState.composing < 0 && (t.inputState.composing = 0));
      };
      kr.compositionend = (t) => {
        t.observer.editContext || (t.inputState.composing = -1, t.inputState.compositionEndedAt = Date.now(), t.inputState.compositionPendingKey = true, t.inputState.compositionPendingChange = t.observer.pendingRecords().length > 0, t.inputState.compositionFirstChange = null, de.chrome && de.android ? t.observer.flushSoon() : t.inputState.compositionPendingChange ? Promise.resolve().then(() => t.observer.flush()) : setTimeout(() => {
          t.inputState.composing < 0 && t.docView.hasComposition && t.update([]);
        }, 50));
      };
      kr.contextmenu = (t) => {
        t.inputState.lastContextMenu = Date.now();
      };
      Kr.beforeinput = (t, e) => {
        var n, r;
        if (e.inputType == "insertReplacementText" && t.observer.editContext) {
          let o = (n = e.dataTransfer) === null || n === void 0 ? void 0 : n.getData("text/plain"), s = e.getTargetRanges();
          if (o && s.length) {
            let a = s[0], l = t.posAtDOM(a.startContainer, a.startOffset), c = t.posAtDOM(a.endContainer, a.endOffset);
            return Lx(t, {
              from: l,
              to: c,
              insert: t.state.toText(o)
            }, null), true;
          }
        }
        let i;
        if (de.chrome && de.android && (i = oR.find((o) => o.inputType == e.inputType)) && (t.observer.delayAndroidKey(i.key, i.keyCode), i.key == "Backspace" || i.key == "Delete")) {
          let o = ((r = window.visualViewport) === null || r === void 0 ? void 0 : r.height) || 0;
          setTimeout(() => {
            var s;
            (((s = window.visualViewport) === null || s === void 0 ? void 0 : s.height) || 0) > o + 10 && t.hasFocus && (t.contentDOM.blur(), t.focus());
          }, 100);
        }
        return de.ios && e.inputType == "deleteContentForward" && t.observer.flushSoon(), de.safari && e.inputType == "insertText" && t.inputState.composing >= 0 && setTimeout(() => kr.compositionend(t, e), 20), false;
      };
      const jC = /* @__PURE__ */ new Set();
      function rU(t) {
        jC.has(t) || (jC.add(t), t.addEventListener("copy", () => {
        }), t.addEventListener("cut", () => {
        }));
      }
      const WC = [
        "pre-wrap",
        "normal",
        "pre-line",
        "break-spaces"
      ];
      let ml = false;
      function UC() {
        ml = false;
      }
      class iU {
        constructor(e) {
          this.lineWrapping = e, this.doc = He.empty, this.heightSamples = {}, this.lineHeight = 14, this.charWidth = 7, this.textHeight = 14, this.lineLength = 30;
        }
        heightForGap(e, n) {
          let r = this.doc.lineAt(n).number - this.doc.lineAt(e).number + 1;
          return this.lineWrapping && (r += Math.max(0, Math.ceil((n - e - r * this.lineLength * 0.5) / this.lineLength))), this.lineHeight * r;
        }
        heightForLine(e) {
          return this.lineWrapping ? (1 + Math.max(0, Math.ceil((e - this.lineLength) / (this.lineLength - 5)))) * this.lineHeight : this.lineHeight;
        }
        setDoc(e) {
          return this.doc = e, this;
        }
        mustRefreshForWrapping(e) {
          return WC.indexOf(e) > -1 != this.lineWrapping;
        }
        mustRefreshForHeights(e) {
          let n = false;
          for (let r = 0; r < e.length; r++) {
            let i = e[r];
            i < 0 ? r++ : this.heightSamples[Math.floor(i * 10)] || (n = true, this.heightSamples[Math.floor(i * 10)] = true);
          }
          return n;
        }
        refresh(e, n, r, i, o, s) {
          let a = WC.indexOf(e) > -1, l = Math.round(n) != Math.round(this.lineHeight) || this.lineWrapping != a;
          if (this.lineWrapping = a, this.lineHeight = n, this.charWidth = r, this.textHeight = i, this.lineLength = o, l) {
            this.heightSamples = {};
            for (let c = 0; c < s.length; c++) {
              let u = s[c];
              u < 0 ? c++ : this.heightSamples[Math.floor(u * 10)] = true;
            }
          }
          return l;
        }
      }
      class oU {
        constructor(e, n) {
          this.from = e, this.heights = n, this.index = 0;
        }
        get more() {
          return this.index < this.heights.length;
        }
      }
      class pi {
        constructor(e, n, r, i, o) {
          this.from = e, this.length = n, this.top = r, this.height = i, this._content = o;
        }
        get type() {
          return typeof this._content == "number" ? kn.Text : Array.isArray(this._content) ? this._content : this._content.type;
        }
        get to() {
          return this.from + this.length;
        }
        get bottom() {
          return this.top + this.height;
        }
        get widget() {
          return this._content instanceof Yo ? this._content.widget : null;
        }
        get widgetLineBreaks() {
          return typeof this._content == "number" ? this._content : 0;
        }
        join(e) {
          let n = (Array.isArray(this._content) ? this._content : [
            this
          ]).concat(Array.isArray(e._content) ? e._content : [
            e
          ]);
          return new pi(this.from, this.length + e.length, this.top, this.height + e.height, n);
        }
      }
      var at = function(t) {
        return t[t.ByPos = 0] = "ByPos", t[t.ByHeight = 1] = "ByHeight", t[t.ByPosNoHeight = 2] = "ByPosNoHeight", t;
      }(at || (at = {}));
      const wd = 1e-3;
      class Cn {
        constructor(e, n, r = 2) {
          this.length = e, this.height = n, this.flags = r;
        }
        get outdated() {
          return (this.flags & 2) > 0;
        }
        set outdated(e) {
          this.flags = (e ? 2 : 0) | this.flags & -3;
        }
        setHeight(e) {
          this.height != e && (Math.abs(this.height - e) > wd && (ml = true), this.height = e);
        }
        replace(e, n, r) {
          return Cn.of(r);
        }
        decomposeLeft(e, n) {
          n.push(this);
        }
        decomposeRight(e, n) {
          n.push(this);
        }
        applyChanges(e, n, r, i) {
          let o = this, s = r.doc;
          for (let a = i.length - 1; a >= 0; a--) {
            let { fromA: l, toA: c, fromB: u, toB: h } = i[a], p = o.lineAt(l, at.ByPosNoHeight, r.setDoc(n), 0, 0), v = p.to >= c ? p : o.lineAt(c, at.ByPosNoHeight, r, 0, 0);
            for (h += v.to - c, c = v.to; a > 0 && p.from <= i[a - 1].toA; )
              l = i[a - 1].fromA, u = i[a - 1].fromB, a--, l < p.from && (p = o.lineAt(l, at.ByPosNoHeight, r, 0, 0));
            u += p.from - l, l = p.from;
            let y = Dx.build(r.setDoc(s), e, u, h);
            o = wp(o, o.replace(l, c, y));
          }
          return o.updateHeight(r, 0);
        }
        static empty() {
          return new Un(0, 0);
        }
        static of(e) {
          if (e.length == 1)
            return e[0];
          let n = 0, r = e.length, i = 0, o = 0;
          for (; ; )
            if (n == r)
              if (i > o * 2) {
                let a = e[n - 1];
                a.break ? e.splice(--n, 1, a.left, null, a.right) : e.splice(--n, 1, a.left, a.right), r += 1 + a.break, i -= a.size;
              } else if (o > i * 2) {
                let a = e[r];
                a.break ? e.splice(r, 1, a.left, null, a.right) : e.splice(r, 1, a.left, a.right), r += 2 + a.break, o -= a.size;
              } else
                break;
            else if (i < o) {
              let a = e[n++];
              a && (i += a.size);
            } else {
              let a = e[--r];
              a && (o += a.size);
            }
          let s = 0;
          return e[n - 1] == null ? (s = 1, n--) : e[n] == null && (s = 1, r++), new sU(Cn.of(e.slice(0, n)), s, Cn.of(e.slice(r)));
        }
      }
      function wp(t, e) {
        return t == e ? t : (t.constructor != e.constructor && (ml = true), e);
      }
      Cn.prototype.size = 1;
      class dR extends Cn {
        constructor(e, n, r) {
          super(e, n), this.deco = r;
        }
        blockAt(e, n, r, i) {
          return new pi(i, this.length, r, this.height, this.deco || 0);
        }
        lineAt(e, n, r, i, o) {
          return this.blockAt(0, r, i, o);
        }
        forEachLine(e, n, r, i, o, s) {
          e <= o + this.length && n >= o && s(this.blockAt(0, r, i, o));
        }
        updateHeight(e, n = 0, r = false, i) {
          return i && i.from <= n && i.more && this.setHeight(i.heights[i.index++]), this.outdated = false, this;
        }
        toString() {
          return `block(${this.length})`;
        }
      }
      class Un extends dR {
        constructor(e, n) {
          super(e, n, null), this.collapsed = 0, this.widgetHeight = 0, this.breaks = 0;
        }
        blockAt(e, n, r, i) {
          return new pi(i, this.length, r, this.height, this.breaks);
        }
        replace(e, n, r) {
          let i = r[0];
          return r.length == 1 && (i instanceof Un || i instanceof Yt && i.flags & 4) && Math.abs(this.length - i.length) < 10 ? (i instanceof Yt ? i = new Un(i.length, this.height) : i.height = this.height, this.outdated || (i.outdated = false), i) : Cn.of(r);
        }
        updateHeight(e, n = 0, r = false, i) {
          return i && i.from <= n && i.more ? this.setHeight(i.heights[i.index++]) : (r || this.outdated) && this.setHeight(Math.max(this.widgetHeight, e.heightForLine(this.length - this.collapsed)) + this.breaks * e.lineHeight), this.outdated = false, this;
        }
        toString() {
          return `line(${this.length}${this.collapsed ? -this.collapsed : ""}${this.widgetHeight ? ":" + this.widgetHeight : ""})`;
        }
      }
      class Yt extends Cn {
        constructor(e) {
          super(e, 0);
        }
        heightMetrics(e, n) {
          let r = e.doc.lineAt(n).number, i = e.doc.lineAt(n + this.length).number, o = i - r + 1, s, a = 0;
          if (e.lineWrapping) {
            let l = Math.min(this.height, e.lineHeight * o);
            s = l / o, this.length > o + 1 && (a = (this.height - l) / (this.length - o - 1));
          } else
            s = this.height / o;
          return {
            firstLine: r,
            lastLine: i,
            perLine: s,
            perChar: a
          };
        }
        blockAt(e, n, r, i) {
          let { firstLine: o, lastLine: s, perLine: a, perChar: l } = this.heightMetrics(n, i);
          if (n.lineWrapping) {
            let c = i + (e < n.lineHeight ? 0 : Math.round(Math.max(0, Math.min(1, (e - r) / this.height)) * this.length)), u = n.doc.lineAt(c), h = a + u.length * l, p = Math.max(r, e - h / 2);
            return new pi(u.from, u.length, p, h, 0);
          } else {
            let c = Math.max(0, Math.min(s - o, Math.floor((e - r) / a))), { from: u, length: h } = n.doc.line(o + c);
            return new pi(u, h, r + a * c, a, 0);
          }
        }
        lineAt(e, n, r, i, o) {
          if (n == at.ByHeight)
            return this.blockAt(e, r, i, o);
          if (n == at.ByPosNoHeight) {
            let { from: v, to: y } = r.doc.lineAt(e);
            return new pi(v, y - v, 0, 0, 0);
          }
          let { firstLine: s, perLine: a, perChar: l } = this.heightMetrics(r, o), c = r.doc.lineAt(e), u = a + c.length * l, h = c.number - s, p = i + a * h + l * (c.from - o - h);
          return new pi(c.from, c.length, Math.max(i, Math.min(p, i + this.height - u)), u, 0);
        }
        forEachLine(e, n, r, i, o, s) {
          e = Math.max(e, o), n = Math.min(n, o + this.length);
          let { firstLine: a, perLine: l, perChar: c } = this.heightMetrics(r, o);
          for (let u = e, h = i; u <= n; ) {
            let p = r.doc.lineAt(u);
            if (u == e) {
              let y = p.number - a;
              h += l * y + c * (e - o - y);
            }
            let v = l + c * p.length;
            s(new pi(p.from, p.length, h, v, 0)), h += v, u = p.to + 1;
          }
        }
        replace(e, n, r) {
          let i = this.length - n;
          if (i > 0) {
            let o = r[r.length - 1];
            o instanceof Yt ? r[r.length - 1] = new Yt(o.length + i) : r.push(null, new Yt(i - 1));
          }
          if (e > 0) {
            let o = r[0];
            o instanceof Yt ? r[0] = new Yt(e + o.length) : r.unshift(new Yt(e - 1), null);
          }
          return Cn.of(r);
        }
        decomposeLeft(e, n) {
          n.push(new Yt(e - 1), null);
        }
        decomposeRight(e, n) {
          n.push(null, new Yt(this.length - e - 1));
        }
        updateHeight(e, n = 0, r = false, i) {
          let o = n + this.length;
          if (i && i.from <= n + this.length && i.more) {
            let s = [], a = Math.max(n, i.from), l = -1;
            for (i.from > n && s.push(new Yt(i.from - n - 1).updateHeight(e, n)); a <= o && i.more; ) {
              let u = e.doc.lineAt(a).length;
              s.length && s.push(null);
              let h = i.heights[i.index++];
              l == -1 ? l = h : Math.abs(h - l) >= wd && (l = -2);
              let p = new Un(u, h);
              p.outdated = false, s.push(p), a += u + 1;
            }
            a <= o && s.push(null, new Yt(o - a).updateHeight(e, a));
            let c = Cn.of(s);
            return (l < 0 || Math.abs(c.height - this.height) >= wd || Math.abs(l - this.heightMetrics(e, n).perLine) >= wd) && (ml = true), wp(this, c);
          } else
            (r || this.outdated) && (this.setHeight(e.heightForGap(n, n + this.length)), this.outdated = false);
          return this;
        }
        toString() {
          return `gap(${this.length})`;
        }
      }
      class sU extends Cn {
        constructor(e, n, r) {
          super(e.length + n + r.length, e.height + r.height, n | (e.outdated || r.outdated ? 2 : 0)), this.left = e, this.right = r, this.size = e.size + r.size;
        }
        get break() {
          return this.flags & 1;
        }
        blockAt(e, n, r, i) {
          let o = r + this.left.height;
          return e < o ? this.left.blockAt(e, n, r, i) : this.right.blockAt(e, n, o, i + this.left.length + this.break);
        }
        lineAt(e, n, r, i, o) {
          let s = i + this.left.height, a = o + this.left.length + this.break, l = n == at.ByHeight ? e < s : e < a, c = l ? this.left.lineAt(e, n, r, i, o) : this.right.lineAt(e, n, r, s, a);
          if (this.break || (l ? c.to < a : c.from > a))
            return c;
          let u = n == at.ByPosNoHeight ? at.ByPosNoHeight : at.ByPos;
          return l ? c.join(this.right.lineAt(a, u, r, s, a)) : this.left.lineAt(a, u, r, i, o).join(c);
        }
        forEachLine(e, n, r, i, o, s) {
          let a = i + this.left.height, l = o + this.left.length + this.break;
          if (this.break)
            e < l && this.left.forEachLine(e, n, r, i, o, s), n >= l && this.right.forEachLine(e, n, r, a, l, s);
          else {
            let c = this.lineAt(l, at.ByPos, r, i, o);
            e < c.from && this.left.forEachLine(e, c.from - 1, r, i, o, s), c.to >= e && c.from <= n && s(c), n > c.to && this.right.forEachLine(c.to + 1, n, r, a, l, s);
          }
        }
        replace(e, n, r) {
          let i = this.left.length + this.break;
          if (n < i)
            return this.balanced(this.left.replace(e, n, r), this.right);
          if (e > this.left.length)
            return this.balanced(this.left, this.right.replace(e - i, n - i, r));
          let o = [];
          e > 0 && this.decomposeLeft(e, o);
          let s = o.length;
          for (let a of r)
            o.push(a);
          if (e > 0 && KC(o, s - 1), n < this.length) {
            let a = o.length;
            this.decomposeRight(n, o), KC(o, a);
          }
          return Cn.of(o);
        }
        decomposeLeft(e, n) {
          let r = this.left.length;
          if (e <= r)
            return this.left.decomposeLeft(e, n);
          n.push(this.left), this.break && (r++, e >= r && n.push(null)), e > r && this.right.decomposeLeft(e - r, n);
        }
        decomposeRight(e, n) {
          let r = this.left.length, i = r + this.break;
          if (e >= i)
            return this.right.decomposeRight(e - i, n);
          e < r && this.left.decomposeRight(e, n), this.break && e < i && n.push(null), n.push(this.right);
        }
        balanced(e, n) {
          return e.size > 2 * n.size || n.size > 2 * e.size ? Cn.of(this.break ? [
            e,
            null,
            n
          ] : [
            e,
            n
          ]) : (this.left = wp(this.left, e), this.right = wp(this.right, n), this.setHeight(e.height + n.height), this.outdated = e.outdated || n.outdated, this.size = e.size + n.size, this.length = e.length + this.break + n.length, this);
        }
        updateHeight(e, n = 0, r = false, i) {
          let { left: o, right: s } = this, a = n + o.length + this.break, l = null;
          return i && i.from <= n + o.length && i.more ? l = o = o.updateHeight(e, n, r, i) : o.updateHeight(e, n, r), i && i.from <= a + s.length && i.more ? l = s = s.updateHeight(e, a, r, i) : s.updateHeight(e, a, r), l ? this.balanced(o, s) : (this.height = this.left.height + this.right.height, this.outdated = false, this);
        }
        toString() {
          return this.left + (this.break ? " " : "-") + this.right;
        }
      }
      function KC(t, e) {
        let n, r;
        t[e] == null && (n = t[e - 1]) instanceof Yt && (r = t[e + 1]) instanceof Yt && t.splice(e - 1, 3, new Yt(n.length + 1 + r.length));
      }
      const aU = 5;
      class Dx {
        constructor(e, n) {
          this.pos = e, this.oracle = n, this.nodes = [], this.lineStart = -1, this.lineEnd = -1, this.covering = null, this.writtenTo = e;
        }
        get isCovered() {
          return this.covering && this.nodes[this.nodes.length - 1] == this.covering;
        }
        span(e, n) {
          if (this.lineStart > -1) {
            let r = Math.min(n, this.lineEnd), i = this.nodes[this.nodes.length - 1];
            i instanceof Un ? i.length += r - this.pos : (r > this.pos || !this.isCovered) && this.nodes.push(new Un(r - this.pos, -1)), this.writtenTo = r, n > r && (this.nodes.push(null), this.writtenTo++, this.lineStart = -1);
          }
          this.pos = n;
        }
        point(e, n, r) {
          if (e < n || r.heightRelevant) {
            let i = r.widget ? r.widget.estimatedHeight : 0, o = r.widget ? r.widget.lineBreaks : 0;
            i < 0 && (i = this.oracle.lineHeight);
            let s = n - e;
            r.block ? this.addBlock(new dR(s, i, r)) : (s || o || i >= aU) && this.addLineDeco(i, o, s);
          } else
            n > e && this.span(e, n);
          this.lineEnd > -1 && this.lineEnd < this.pos && (this.lineEnd = this.oracle.doc.lineAt(this.pos).to);
        }
        enterLine() {
          if (this.lineStart > -1)
            return;
          let { from: e, to: n } = this.oracle.doc.lineAt(this.pos);
          this.lineStart = e, this.lineEnd = n, this.writtenTo < e && ((this.writtenTo < e - 1 || this.nodes[this.nodes.length - 1] == null) && this.nodes.push(this.blankContent(this.writtenTo, e - 1)), this.nodes.push(null)), this.pos > e && this.nodes.push(new Un(this.pos - e, -1)), this.writtenTo = this.pos;
        }
        blankContent(e, n) {
          let r = new Yt(n - e);
          return this.oracle.doc.lineAt(e).to == n && (r.flags |= 4), r;
        }
        ensureLine() {
          this.enterLine();
          let e = this.nodes.length ? this.nodes[this.nodes.length - 1] : null;
          if (e instanceof Un)
            return e;
          let n = new Un(0, -1);
          return this.nodes.push(n), n;
        }
        addBlock(e) {
          this.enterLine();
          let n = e.deco;
          n && n.startSide > 0 && !this.isCovered && this.ensureLine(), this.nodes.push(e), this.writtenTo = this.pos = this.pos + e.length, n && n.endSide > 0 && (this.covering = e);
        }
        addLineDeco(e, n, r) {
          let i = this.ensureLine();
          i.length += r, i.collapsed += r, i.widgetHeight = Math.max(i.widgetHeight, e), i.breaks += n, this.writtenTo = this.pos = this.pos + r;
        }
        finish(e) {
          let n = this.nodes.length == 0 ? null : this.nodes[this.nodes.length - 1];
          this.lineStart > -1 && !(n instanceof Un) && !this.isCovered ? this.nodes.push(new Un(0, -1)) : (this.writtenTo < this.pos || n == null) && this.nodes.push(this.blankContent(this.writtenTo, this.pos));
          let r = e;
          for (let i of this.nodes)
            i instanceof Un && i.updateHeight(this.oracle, r), r += i ? i.length : 1;
          return this.nodes;
        }
        static build(e, n, r, i) {
          let o = new Dx(r, e);
          return Ve.spans(n, r, i, o, 0), o.finish(r);
        }
      }
      function lU(t, e, n) {
        let r = new cU();
        return Ve.compare(t, e, n, r, 0), r.changes;
      }
      class cU {
        constructor() {
          this.changes = [];
        }
        compareRange() {
        }
        comparePoint(e, n, r, i) {
          (e < n || r && r.heightRelevant || i && i.heightRelevant) && xd(e, n, this.changes, 5);
        }
      }
      function uU(t, e) {
        let n = t.getBoundingClientRect(), r = t.ownerDocument, i = r.defaultView || window, o = Math.max(0, n.left), s = Math.min(i.innerWidth, n.right), a = Math.max(0, n.top), l = Math.min(i.innerHeight, n.bottom);
        for (let c = t.parentNode; c && c != r.body; )
          if (c.nodeType == 1) {
            let u = c, h = window.getComputedStyle(u);
            if ((u.scrollHeight > u.clientHeight || u.scrollWidth > u.clientWidth) && h.overflow != "visible") {
              let p = u.getBoundingClientRect();
              o = Math.max(o, p.left), s = Math.min(s, p.right), a = Math.max(a, p.top), l = Math.min(c == t.parentNode ? i.innerHeight : l, p.bottom);
            }
            c = h.position == "absolute" || h.position == "fixed" ? u.offsetParent : u.parentNode;
          } else if (c.nodeType == 11)
            c = c.host;
          else
            break;
        return {
          left: o - n.left,
          right: Math.max(o, s) - n.left,
          top: a - (n.top + e),
          bottom: Math.max(a, l) - (n.top + e)
        };
      }
      function fU(t) {
        let e = t.getBoundingClientRect(), n = t.ownerDocument.defaultView || window;
        return e.left < n.innerWidth && e.right > 0 && e.top < n.innerHeight && e.bottom > 0;
      }
      function hU(t, e) {
        let n = t.getBoundingClientRect();
        return {
          left: 0,
          right: n.right - n.left,
          top: e,
          bottom: n.bottom - (n.top + e)
        };
      }
      class N0 {
        constructor(e, n, r, i) {
          this.from = e, this.to = n, this.size = r, this.displaySize = i;
        }
        static same(e, n) {
          if (e.length != n.length)
            return false;
          for (let r = 0; r < e.length; r++) {
            let i = e[r], o = n[r];
            if (i.from != o.from || i.to != o.to || i.size != o.size)
              return false;
          }
          return true;
        }
        draw(e, n) {
          return be.replace({
            widget: new dU(this.displaySize * (n ? e.scaleY : e.scaleX), n)
          }).range(this.from, this.to);
        }
      }
      class dU extends oo {
        constructor(e, n) {
          super(), this.size = e, this.vertical = n;
        }
        eq(e) {
          return e.size == this.size && e.vertical == this.vertical;
        }
        toDOM() {
          let e = document.createElement("div");
          return this.vertical ? e.style.height = this.size + "px" : (e.style.width = this.size + "px", e.style.height = "2px", e.style.display = "inline-block"), e;
        }
        get estimatedHeight() {
          return this.vertical ? this.size : -1;
        }
      }
      class qC {
        constructor(e) {
          this.state = e, this.pixelViewport = {
            left: 0,
            right: window.innerWidth,
            top: 0,
            bottom: 0
          }, this.inView = true, this.paddingTop = 0, this.paddingBottom = 0, this.contentDOMWidth = 0, this.contentDOMHeight = 0, this.editorHeight = 0, this.editorWidth = 0, this.scrollTop = 0, this.scrolledToBottom = false, this.scaleX = 1, this.scaleY = 1, this.scrollAnchorPos = 0, this.scrollAnchorHeight = -1, this.scaler = GC, this.scrollTarget = null, this.printing = false, this.mustMeasureContent = true, this.defaultTextDirection = rt.LTR, this.visibleRanges = [], this.mustEnforceCursorAssoc = false;
          let n = e.facet(Px).some((r) => typeof r != "function" && r.class == "cm-lineWrapping");
          this.heightOracle = new iU(n), this.stateDeco = e.facet(Bu).filter((r) => typeof r != "function"), this.heightMap = Cn.empty().applyChanges(this.stateDeco, He.empty, this.heightOracle.setDoc(e.doc), [
            new br(0, 0, 0, e.doc.length)
          ]);
          for (let r = 0; r < 2 && (this.viewport = this.getViewport(0, null), !!this.updateForViewport()); r++)
            ;
          this.updateViewportLines(), this.lineGaps = this.ensureLineGaps([]), this.lineGapDeco = be.set(this.lineGaps.map((r) => r.draw(this, false))), this.computeVisibleRanges();
        }
        updateForViewport() {
          let e = [
            this.viewport
          ], { main: n } = this.state.selection;
          for (let r = 0; r <= 1; r++) {
            let i = r ? n.head : n.anchor;
            if (!e.some(({ from: o, to: s }) => i >= o && i <= s)) {
              let { from: o, to: s } = this.lineBlockAt(i);
              e.push(new Ch(o, s));
            }
          }
          return this.viewports = e.sort((r, i) => r.from - i.from), this.updateScaler();
        }
        updateScaler() {
          let e = this.scaler;
          return this.scaler = this.heightMap.height <= 7e6 ? GC : new _x(this.heightOracle, this.heightMap, this.viewports), e.eq(this.scaler) ? 0 : 2;
        }
        updateViewportLines() {
          this.viewportLines = [], this.heightMap.forEachLine(this.viewport.from, this.viewport.to, this.heightOracle.setDoc(this.state.doc), 0, 0, (e) => {
            this.viewportLines.push(Sc(e, this.scaler));
          });
        }
        update(e, n = null) {
          this.state = e.state;
          let r = this.stateDeco;
          this.stateDeco = this.state.facet(Bu).filter((u) => typeof u != "function");
          let i = e.changedRanges, o = br.extendWithRanges(i, lU(r, this.stateDeco, e ? e.changes : _t.empty(this.state.doc.length))), s = this.heightMap.height, a = this.scrolledToBottom ? null : this.scrollAnchorAt(this.scrollTop);
          UC(), this.heightMap = this.heightMap.applyChanges(this.stateDeco, e.startState.doc, this.heightOracle.setDoc(this.state.doc), o), (this.heightMap.height != s || ml) && (e.flags |= 2), a ? (this.scrollAnchorPos = e.changes.mapPos(a.from, -1), this.scrollAnchorHeight = a.top) : (this.scrollAnchorPos = -1, this.scrollAnchorHeight = this.heightMap.height);
          let l = o.length ? this.mapViewport(this.viewport, e.changes) : this.viewport;
          (n && (n.range.head < l.from || n.range.head > l.to) || !this.viewportIsAppropriate(l)) && (l = this.getViewport(0, n));
          let c = l.from != this.viewport.from || l.to != this.viewport.to;
          this.viewport = l, e.flags |= this.updateForViewport(), (c || !e.changes.empty || e.flags & 2) && this.updateViewportLines(), (this.lineGaps.length || this.viewport.to - this.viewport.from > 2e3 << 1) && this.updateLineGaps(this.ensureLineGaps(this.mapLineGaps(this.lineGaps, e.changes))), e.flags |= this.computeVisibleRanges(e.changes), n && (this.scrollTarget = n), !this.mustEnforceCursorAssoc && e.selectionSet && e.view.lineWrapping && e.state.selection.main.empty && e.state.selection.main.assoc && !e.state.facet(YO) && (this.mustEnforceCursorAssoc = true);
        }
        measure(e) {
          let n = e.contentDOM, r = window.getComputedStyle(n), i = this.heightOracle, o = r.whiteSpace;
          this.defaultTextDirection = r.direction == "rtl" ? rt.RTL : rt.LTR;
          let s = this.heightOracle.mustRefreshForWrapping(o), a = n.getBoundingClientRect(), l = s || this.mustMeasureContent || this.contentDOMHeight != a.height;
          this.contentDOMHeight = a.height, this.mustMeasureContent = false;
          let c = 0, u = 0;
          if (a.width && a.height) {
            let { scaleX: P, scaleY: R } = wO(n, a);
            (P > 5e-3 && Math.abs(this.scaleX - P) > 5e-3 || R > 5e-3 && Math.abs(this.scaleY - R) > 5e-3) && (this.scaleX = P, this.scaleY = R, c |= 16, s = l = true);
          }
          let h = (parseInt(r.paddingTop) || 0) * this.scaleY, p = (parseInt(r.paddingBottom) || 0) * this.scaleY;
          (this.paddingTop != h || this.paddingBottom != p) && (this.paddingTop = h, this.paddingBottom = p, c |= 18), this.editorWidth != e.scrollDOM.clientWidth && (i.lineWrapping && (l = true), this.editorWidth = e.scrollDOM.clientWidth, c |= 16);
          let v = e.scrollDOM.scrollTop * this.scaleY;
          this.scrollTop != v && (this.scrollAnchorHeight = -1, this.scrollTop = v), this.scrolledToBottom = TO(e.scrollDOM);
          let y = (this.printing ? hU : uU)(n, this.paddingTop), S = y.top - this.pixelViewport.top, C = y.bottom - this.pixelViewport.bottom;
          this.pixelViewport = y;
          let w = this.pixelViewport.bottom > this.pixelViewport.top && this.pixelViewport.right > this.pixelViewport.left;
          if (w != this.inView && (this.inView = w, w && (l = true)), !this.inView && !this.scrollTarget && !fU(e.dom))
            return 0;
          let k = a.width;
          if ((this.contentDOMWidth != k || this.editorHeight != e.scrollDOM.clientHeight) && (this.contentDOMWidth = a.width, this.editorHeight = e.scrollDOM.clientHeight, c |= 16), l) {
            let P = e.docView.measureVisibleLineHeights(this.viewport);
            if (i.mustRefreshForHeights(P) && (s = true), s || i.lineWrapping && Math.abs(k - this.contentDOMWidth) > i.charWidth) {
              let { lineHeight: R, charWidth: L, textHeight: D } = e.docView.measureTextSize();
              s = R > 0 && i.refresh(o, R, L, D, k / L, P), s && (e.docView.minWidth = 0, c |= 16);
            }
            S > 0 && C > 0 ? u = Math.max(S, C) : S < 0 && C < 0 && (u = Math.min(S, C)), UC();
            for (let R of this.viewports) {
              let L = R.from == this.viewport.from ? P : e.docView.measureVisibleLineHeights(R);
              this.heightMap = (s ? Cn.empty().applyChanges(this.stateDeco, He.empty, this.heightOracle, [
                new br(0, 0, 0, e.state.doc.length)
              ]) : this.heightMap).updateHeight(i, 0, s, new oU(R.from, L));
            }
            ml && (c |= 2);
          }
          let T = !this.viewportIsAppropriate(this.viewport, u) || this.scrollTarget && (this.scrollTarget.range.head < this.viewport.from || this.scrollTarget.range.head > this.viewport.to);
          return T && (c & 2 && (c |= this.updateScaler()), this.viewport = this.getViewport(u, this.scrollTarget), c |= this.updateForViewport()), (c & 2 || T) && this.updateViewportLines(), (this.lineGaps.length || this.viewport.to - this.viewport.from > 2e3 << 1) && this.updateLineGaps(this.ensureLineGaps(s ? [] : this.lineGaps, e)), c |= this.computeVisibleRanges(), this.mustEnforceCursorAssoc && (this.mustEnforceCursorAssoc = false, e.docView.enforceCursorAssoc()), c;
        }
        get visibleTop() {
          return this.scaler.fromDOM(this.pixelViewport.top);
        }
        get visibleBottom() {
          return this.scaler.fromDOM(this.pixelViewport.bottom);
        }
        getViewport(e, n) {
          let r = 0.5 - Math.max(-0.5, Math.min(0.5, e / 1e3 / 2)), i = this.heightMap, o = this.heightOracle, { visibleTop: s, visibleBottom: a } = this, l = new Ch(i.lineAt(s - r * 1e3, at.ByHeight, o, 0, 0).from, i.lineAt(a + (1 - r) * 1e3, at.ByHeight, o, 0, 0).to);
          if (n) {
            let { head: c } = n.range;
            if (c < l.from || c > l.to) {
              let u = Math.min(this.editorHeight, this.pixelViewport.bottom - this.pixelViewport.top), h = i.lineAt(c, at.ByPos, o, 0, 0), p;
              n.y == "center" ? p = (h.top + h.bottom) / 2 - u / 2 : n.y == "start" || n.y == "nearest" && c < l.from ? p = h.top : p = h.bottom - u, l = new Ch(i.lineAt(p - 1e3 / 2, at.ByHeight, o, 0, 0).from, i.lineAt(p + u + 1e3 / 2, at.ByHeight, o, 0, 0).to);
            }
          }
          return l;
        }
        mapViewport(e, n) {
          let r = n.mapPos(e.from, -1), i = n.mapPos(e.to, 1);
          return new Ch(this.heightMap.lineAt(r, at.ByPos, this.heightOracle, 0, 0).from, this.heightMap.lineAt(i, at.ByPos, this.heightOracle, 0, 0).to);
        }
        viewportIsAppropriate({ from: e, to: n }, r = 0) {
          if (!this.inView)
            return true;
          let { top: i } = this.heightMap.lineAt(e, at.ByPos, this.heightOracle, 0, 0), { bottom: o } = this.heightMap.lineAt(n, at.ByPos, this.heightOracle, 0, 0), { visibleTop: s, visibleBottom: a } = this;
          return (e == 0 || i <= s - Math.max(10, Math.min(-r, 250))) && (n == this.state.doc.length || o >= a + Math.max(10, Math.min(r, 250))) && i > s - 2 * 1e3 && o < a + 2 * 1e3;
        }
        mapLineGaps(e, n) {
          if (!e.length || n.empty)
            return e;
          let r = [];
          for (let i of e)
            n.touchesRange(i.from, i.to) || r.push(new N0(n.mapPos(i.from), n.mapPos(i.to), i.size, i.displaySize));
          return r;
        }
        ensureLineGaps(e, n) {
          let r = this.heightOracle.lineWrapping, i = r ? 1e4 : 2e3, o = i >> 1, s = i << 1;
          if (this.defaultTextDirection != rt.LTR && !r)
            return [];
          let a = [], l = (u, h, p, v) => {
            if (h - u < o)
              return;
            let y = this.state.selection.main, S = [
              y.from
            ];
            y.empty || S.push(y.to);
            for (let w of S)
              if (w > u && w < h) {
                l(u, w - 10, p, v), l(w + 10, h, p, v);
                return;
              }
            let C = mU(e, (w) => w.from >= p.from && w.to <= p.to && Math.abs(w.from - u) < o && Math.abs(w.to - h) < o && !S.some((k) => w.from < k && w.to > k));
            if (!C) {
              if (h < p.to && n && r && n.visibleRanges.some((T) => T.from <= h && T.to >= h)) {
                let T = n.moveToLineBoundary(q.cursor(h), false, true).head;
                T > u && (h = T);
              }
              let w = this.gapSize(p, u, h, v), k = r || w < 2e6 ? w : 2e6;
              C = new N0(u, h, w, k);
            }
            a.push(C);
          }, c = (u) => {
            if (u.length < s || u.type != kn.Text)
              return;
            let h = pU(u.from, u.to, this.stateDeco);
            if (h.total < s)
              return;
            let p = this.scrollTarget ? this.scrollTarget.range.head : null, v, y;
            if (r) {
              let S = i / this.heightOracle.lineLength * this.heightOracle.lineHeight, C, w;
              if (p != null) {
                let k = Mh(h, p), T = ((this.visibleBottom - this.visibleTop) / 2 + S) / u.height;
                C = k - T, w = k + T;
              } else
                C = (this.visibleTop - u.top - S) / u.height, w = (this.visibleBottom - u.top + S) / u.height;
              v = Th(h, C), y = Th(h, w);
            } else {
              let S = h.total * this.heightOracle.charWidth, C = i * this.heightOracle.charWidth, w = 0;
              if (S > 2e6)
                for (let L of e)
                  L.from >= u.from && L.from < u.to && L.size != L.displaySize && L.from * this.heightOracle.charWidth + w < this.pixelViewport.left && (w = L.size - L.displaySize);
              let k = this.pixelViewport.left + w, T = this.pixelViewport.right + w, P, R;
              if (p != null) {
                let L = Mh(h, p), D = ((T - k) / 2 + C) / S;
                P = L - D, R = L + D;
              } else
                P = (k - C) / S, R = (T + C) / S;
              v = Th(h, P), y = Th(h, R);
            }
            v > u.from && l(u.from, v, u, h), y < u.to && l(y, u.to, u, h);
          };
          for (let u of this.viewportLines)
            Array.isArray(u.type) ? u.type.forEach(c) : c(u);
          return a;
        }
        gapSize(e, n, r, i) {
          let o = Mh(i, r) - Mh(i, n);
          return this.heightOracle.lineWrapping ? e.height * o : i.total * this.heightOracle.charWidth * o;
        }
        updateLineGaps(e) {
          N0.same(e, this.lineGaps) || (this.lineGaps = e, this.lineGapDeco = be.set(e.map((n) => n.draw(this, this.heightOracle.lineWrapping))));
        }
        computeVisibleRanges(e) {
          let n = this.stateDeco;
          this.lineGaps.length && (n = n.concat(this.lineGapDeco));
          let r = [];
          Ve.spans(n, this.viewport.from, this.viewport.to, {
            span(o, s) {
              r.push({
                from: o,
                to: s
              });
            },
            point() {
            }
          }, 20);
          let i = 0;
          if (r.length != this.visibleRanges.length)
            i = 12;
          else
            for (let o = 0; o < r.length && !(i & 8); o++) {
              let s = this.visibleRanges[o], a = r[o];
              (s.from != a.from || s.to != a.to) && (i |= 4, e && e.mapPos(s.from, -1) == a.from && e.mapPos(s.to, 1) == a.to || (i |= 8));
            }
          return this.visibleRanges = r, i;
        }
        lineBlockAt(e) {
          return e >= this.viewport.from && e <= this.viewport.to && this.viewportLines.find((n) => n.from <= e && n.to >= e) || Sc(this.heightMap.lineAt(e, at.ByPos, this.heightOracle, 0, 0), this.scaler);
        }
        lineBlockAtHeight(e) {
          return e >= this.viewportLines[0].top && e <= this.viewportLines[this.viewportLines.length - 1].bottom && this.viewportLines.find((n) => n.top <= e && n.bottom >= e) || Sc(this.heightMap.lineAt(this.scaler.fromDOM(e), at.ByHeight, this.heightOracle, 0, 0), this.scaler);
        }
        scrollAnchorAt(e) {
          let n = this.lineBlockAtHeight(e + 8);
          return n.from >= this.viewport.from || this.viewportLines[0].top - e > 200 ? n : this.viewportLines[0];
        }
        elementAtHeight(e) {
          return Sc(this.heightMap.blockAt(this.scaler.fromDOM(e), this.heightOracle, 0, 0), this.scaler);
        }
        get docHeight() {
          return this.scaler.toDOM(this.heightMap.height);
        }
        get contentHeight() {
          return this.docHeight + this.paddingTop + this.paddingBottom;
        }
      }
      class Ch {
        constructor(e, n) {
          this.from = e, this.to = n;
        }
      }
      function pU(t, e, n) {
        let r = [], i = t, o = 0;
        return Ve.spans(n, t, e, {
          span() {
          },
          point(s, a) {
            s > i && (r.push({
              from: i,
              to: s
            }), o += s - i), i = a;
          }
        }, 20), i < e && (r.push({
          from: i,
          to: e
        }), o += e - i), {
          total: o,
          ranges: r
        };
      }
      function Th({ total: t, ranges: e }, n) {
        if (n <= 0)
          return e[0].from;
        if (n >= 1)
          return e[e.length - 1].to;
        let r = Math.floor(t * n);
        for (let i = 0; ; i++) {
          let { from: o, to: s } = e[i], a = s - o;
          if (r <= a)
            return o + r;
          r -= a;
        }
      }
      function Mh(t, e) {
        let n = 0;
        for (let { from: r, to: i } of t.ranges) {
          if (e <= i) {
            n += e - r;
            break;
          }
          n += i - r;
        }
        return n / t.total;
      }
      function mU(t, e) {
        for (let n of t)
          if (e(n))
            return n;
      }
      const GC = {
        toDOM(t) {
          return t;
        },
        fromDOM(t) {
          return t;
        },
        scale: 1,
        eq(t) {
          return t == this;
        }
      };
      class _x {
        constructor(e, n, r) {
          let i = 0, o = 0, s = 0;
          this.viewports = r.map(({ from: a, to: l }) => {
            let c = n.lineAt(a, at.ByPos, e, 0, 0).top, u = n.lineAt(l, at.ByPos, e, 0, 0).bottom;
            return i += u - c, {
              from: a,
              to: l,
              top: c,
              bottom: u,
              domTop: 0,
              domBottom: 0
            };
          }), this.scale = (7e6 - i) / (n.height - i);
          for (let a of this.viewports)
            a.domTop = s + (a.top - o) * this.scale, s = a.domBottom = a.domTop + (a.bottom - a.top), o = a.bottom;
        }
        toDOM(e) {
          for (let n = 0, r = 0, i = 0; ; n++) {
            let o = n < this.viewports.length ? this.viewports[n] : null;
            if (!o || e < o.top)
              return i + (e - r) * this.scale;
            if (e <= o.bottom)
              return o.domTop + (e - o.top);
            r = o.bottom, i = o.domBottom;
          }
        }
        fromDOM(e) {
          for (let n = 0, r = 0, i = 0; ; n++) {
            let o = n < this.viewports.length ? this.viewports[n] : null;
            if (!o || e < o.domTop)
              return r + (e - i) / this.scale;
            if (e <= o.domBottom)
              return o.top + (e - o.domTop);
            r = o.bottom, i = o.domBottom;
          }
        }
        eq(e) {
          return e instanceof _x ? this.scale == e.scale && this.viewports.length == e.viewports.length && this.viewports.every((n, r) => n.from == e.viewports[r].from && n.to == e.viewports[r].to) : false;
        }
      }
      function Sc(t, e) {
        if (e.scale == 1)
          return t;
        let n = e.toDOM(t.top), r = e.toDOM(t.bottom);
        return new pi(t.from, t.length, n, r - n, Array.isArray(t._content) ? t._content.map((i) => Sc(i, e)) : t._content);
      }
      const Ah = pe.define({
        combine: (t) => t.join(" ")
      }), s1 = pe.define({
        combine: (t) => t.indexOf(true) > -1
      }), a1 = qo.newName(), pR = qo.newName(), mR = qo.newName(), gR = {
        "&light": "." + pR,
        "&dark": "." + mR
      };
      function l1(t, e, n) {
        return new qo(e, {
          finish(r) {
            return /&/.test(r) ? r.replace(/&\w*/, (i) => {
              if (i == "&")
                return t;
              if (!n || !n[i])
                throw new RangeError(`Unsupported selector: ${i}`);
              return n[i];
            }) : t + " " + r;
          }
        });
      }
      const gU = l1("." + a1, {
        "&": {
          position: "relative !important",
          boxSizing: "border-box",
          "&.cm-focused": {
            outline: "1px dotted #212121"
          },
          display: "flex !important",
          flexDirection: "column"
        },
        ".cm-scroller": {
          display: "flex !important",
          alignItems: "flex-start !important",
          fontFamily: "monospace",
          lineHeight: 1.4,
          height: "100%",
          overflowX: "auto",
          position: "relative",
          zIndex: 0,
          overflowAnchor: "none"
        },
        ".cm-content": {
          margin: 0,
          flexGrow: 2,
          flexShrink: 0,
          display: "block",
          whiteSpace: "pre",
          wordWrap: "normal",
          boxSizing: "border-box",
          minHeight: "100%",
          padding: "4px 0",
          outline: "none",
          "&[contenteditable=true]": {
            WebkitUserModify: "read-write-plaintext-only"
          }
        },
        ".cm-lineWrapping": {
          whiteSpace_fallback: "pre-wrap",
          whiteSpace: "break-spaces",
          wordBreak: "break-word",
          overflowWrap: "anywhere",
          flexShrink: 1
        },
        "&light .cm-content": {
          caretColor: "black"
        },
        "&dark .cm-content": {
          caretColor: "white"
        },
        ".cm-line": {
          display: "block",
          padding: "0 2px 0 6px"
        },
        ".cm-layer": {
          position: "absolute",
          left: 0,
          top: 0,
          contain: "size style",
          "& > *": {
            position: "absolute"
          }
        },
        "&light .cm-selectionBackground": {
          background: "#d9d9d9"
        },
        "&dark .cm-selectionBackground": {
          background: "#222"
        },
        "&light.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground": {
          background: "#d7d4f0"
        },
        "&dark.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground": {
          background: "#233"
        },
        ".cm-cursorLayer": {
          pointerEvents: "none"
        },
        "&.cm-focused > .cm-scroller > .cm-cursorLayer": {
          animation: "steps(1) cm-blink 1.2s infinite"
        },
        "@keyframes cm-blink": {
          "0%": {},
          "50%": {
            opacity: 0
          },
          "100%": {}
        },
        "@keyframes cm-blink2": {
          "0%": {},
          "50%": {
            opacity: 0
          },
          "100%": {}
        },
        ".cm-cursor, .cm-dropCursor": {
          borderLeft: "1.2px solid black",
          marginLeft: "-0.6px",
          pointerEvents: "none"
        },
        ".cm-cursor": {
          display: "none"
        },
        "&dark .cm-cursor": {
          borderLeftColor: "#ddd"
        },
        ".cm-dropCursor": {
          position: "absolute"
        },
        "&.cm-focused > .cm-scroller > .cm-cursorLayer .cm-cursor": {
          display: "block"
        },
        ".cm-iso": {
          unicodeBidi: "isolate"
        },
        ".cm-announced": {
          position: "fixed",
          top: "-10000px"
        },
        "@media print": {
          ".cm-announced": {
            display: "none"
          }
        },
        "&light .cm-activeLine": {
          backgroundColor: "#cceeff44"
        },
        "&dark .cm-activeLine": {
          backgroundColor: "#99eeff33"
        },
        "&light .cm-specialChar": {
          color: "red"
        },
        "&dark .cm-specialChar": {
          color: "#f78"
        },
        ".cm-gutters": {
          flexShrink: 0,
          display: "flex",
          height: "100%",
          boxSizing: "border-box",
          insetInlineStart: 0,
          zIndex: 200
        },
        "&light .cm-gutters": {
          backgroundColor: "#f5f5f5",
          color: "#6c6c6c",
          borderRight: "1px solid #ddd"
        },
        "&dark .cm-gutters": {
          backgroundColor: "#333338",
          color: "#ccc"
        },
        ".cm-gutter": {
          display: "flex !important",
          flexDirection: "column",
          flexShrink: 0,
          boxSizing: "border-box",
          minHeight: "100%",
          overflow: "hidden"
        },
        ".cm-gutterElement": {
          boxSizing: "border-box"
        },
        ".cm-lineNumbers .cm-gutterElement": {
          padding: "0 3px 0 5px",
          minWidth: "20px",
          textAlign: "right",
          whiteSpace: "nowrap"
        },
        "&light .cm-activeLineGutter": {
          backgroundColor: "#e2f2ff"
        },
        "&dark .cm-activeLineGutter": {
          backgroundColor: "#222227"
        },
        ".cm-panels": {
          boxSizing: "border-box",
          position: "sticky",
          left: 0,
          right: 0,
          zIndex: 300
        },
        "&light .cm-panels": {
          backgroundColor: "#f5f5f5",
          color: "black"
        },
        "&light .cm-panels-top": {
          borderBottom: "1px solid #ddd"
        },
        "&light .cm-panels-bottom": {
          borderTop: "1px solid #ddd"
        },
        "&dark .cm-panels": {
          backgroundColor: "#333338",
          color: "white"
        },
        ".cm-tab": {
          display: "inline-block",
          overflow: "hidden",
          verticalAlign: "bottom"
        },
        ".cm-widgetBuffer": {
          verticalAlign: "text-top",
          height: "1em",
          width: 0,
          display: "inline"
        },
        ".cm-placeholder": {
          color: "#888",
          display: "inline-block",
          verticalAlign: "top",
          userSelect: "none"
        },
        ".cm-highlightSpace": {
          backgroundImage: "radial-gradient(circle at 50% 55%, #aaa 20%, transparent 5%)",
          backgroundPosition: "center"
        },
        ".cm-highlightTab": {
          backgroundImage: `url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="200" height="20"><path stroke="%23888" stroke-width="1" fill="none" d="M1 10H196L190 5M190 15L196 10M197 4L197 16"/></svg>')`,
          backgroundSize: "auto 100%",
          backgroundPosition: "right 90%",
          backgroundRepeat: "no-repeat"
        },
        ".cm-trailingSpace": {
          backgroundColor: "#ff332255"
        },
        ".cm-button": {
          verticalAlign: "middle",
          color: "inherit",
          fontSize: "70%",
          padding: ".2em 1em",
          borderRadius: "1px"
        },
        "&light .cm-button": {
          backgroundImage: "linear-gradient(#eff1f5, #d9d9df)",
          border: "1px solid #888",
          "&:active": {
            backgroundImage: "linear-gradient(#b4b4b4, #d0d3d6)"
          }
        },
        "&dark .cm-button": {
          backgroundImage: "linear-gradient(#393939, #111)",
          border: "1px solid #888",
          "&:active": {
            backgroundImage: "linear-gradient(#111, #333)"
          }
        },
        ".cm-textfield": {
          verticalAlign: "middle",
          color: "inherit",
          fontSize: "70%",
          border: "1px solid silver",
          padding: ".2em .5em"
        },
        "&light .cm-textfield": {
          backgroundColor: "white"
        },
        "&dark .cm-textfield": {
          border: "1px solid #555",
          backgroundColor: "inherit"
        }
      }, gR), vU = {
        childList: true,
        characterData: true,
        subtree: true,
        attributes: true,
        characterDataOldValue: true
      }, $0 = de.ie && de.ie_version <= 11;
      class yU {
        constructor(e) {
          this.view = e, this.active = false, this.editContext = null, this.selectionRange = new e7(), this.selectionChanged = false, this.delayedFlush = -1, this.resizeTimeout = -1, this.queue = [], this.delayedAndroidKey = null, this.flushingAndroidKey = -1, this.lastChange = 0, this.scrollTargets = [], this.intersection = null, this.resizeScroll = null, this.intersecting = false, this.gapIntersection = null, this.gaps = [], this.printQuery = null, this.parentCheck = -1, this.dom = e.contentDOM, this.observer = new MutationObserver((n) => {
            for (let r of n)
              this.queue.push(r);
            (de.ie && de.ie_version <= 11 || de.ios && e.composing) && n.some((r) => r.type == "childList" && r.removedNodes.length || r.type == "characterData" && r.oldValue.length > r.target.nodeValue.length) ? this.flushSoon() : this.flush();
          }), window.EditContext && e.constructor.EDIT_CONTEXT !== false && !(de.chrome && de.chrome_version < 126) && (this.editContext = new xU(e), e.state.facet(Fi) && (e.contentDOM.editContext = this.editContext.editContext)), $0 && (this.onCharData = (n) => {
            this.queue.push({
              target: n.target,
              type: "characterData",
              oldValue: n.prevValue
            }), this.flushSoon();
          }), this.onSelectionChange = this.onSelectionChange.bind(this), this.onResize = this.onResize.bind(this), this.onPrint = this.onPrint.bind(this), this.onScroll = this.onScroll.bind(this), window.matchMedia && (this.printQuery = window.matchMedia("print")), typeof ResizeObserver == "function" && (this.resizeScroll = new ResizeObserver(() => {
            var n;
            ((n = this.view.docView) === null || n === void 0 ? void 0 : n.lastUpdate) < Date.now() - 75 && this.onResize();
          }), this.resizeScroll.observe(e.scrollDOM)), this.addWindowListeners(this.win = e.win), this.start(), typeof IntersectionObserver == "function" && (this.intersection = new IntersectionObserver((n) => {
            this.parentCheck < 0 && (this.parentCheck = setTimeout(this.listenForScroll.bind(this), 1e3)), n.length > 0 && n[n.length - 1].intersectionRatio > 0 != this.intersecting && (this.intersecting = !this.intersecting, this.intersecting != this.view.inView && this.onScrollChanged(document.createEvent("Event")));
          }, {
            threshold: [
              0,
              1e-3
            ]
          }), this.intersection.observe(this.dom), this.gapIntersection = new IntersectionObserver((n) => {
            n.length > 0 && n[n.length - 1].intersectionRatio > 0 && this.onScrollChanged(document.createEvent("Event"));
          }, {})), this.listenForScroll(), this.readSelectionRange();
        }
        onScrollChanged(e) {
          this.view.inputState.runHandlers("scroll", e), this.intersecting && this.view.measure();
        }
        onScroll(e) {
          this.intersecting && this.flush(false), this.editContext && this.view.requestMeasure(this.editContext.measureReq), this.onScrollChanged(e);
        }
        onResize() {
          this.resizeTimeout < 0 && (this.resizeTimeout = setTimeout(() => {
            this.resizeTimeout = -1, this.view.requestMeasure();
          }, 50));
        }
        onPrint(e) {
          (e.type == "change" || !e.type) && !e.matches || (this.view.viewState.printing = true, this.view.measure(), setTimeout(() => {
            this.view.viewState.printing = false, this.view.requestMeasure();
          }, 500));
        }
        updateGaps(e) {
          if (this.gapIntersection && (e.length != this.gaps.length || this.gaps.some((n, r) => n != e[r]))) {
            this.gapIntersection.disconnect();
            for (let n of e)
              this.gapIntersection.observe(n);
            this.gaps = e;
          }
        }
        onSelectionChange(e) {
          let n = this.selectionChanged;
          if (!this.readSelectionRange() || this.delayedAndroidKey)
            return;
          let { view: r } = this, i = this.selectionRange;
          if (r.state.facet(Fi) ? r.root.activeElement != this.dom : !bd(this.dom, i))
            return;
          let o = i.anchorNode && r.docView.nearest(i.anchorNode);
          if (o && o.ignoreEvent(e)) {
            n || (this.selectionChanged = false);
            return;
          }
          (de.ie && de.ie_version <= 11 || de.android && de.chrome) && !r.state.selection.main.empty && i.focusNode && Xc(i.focusNode, i.focusOffset, i.anchorNode, i.anchorOffset) ? this.flushSoon() : this.flush(false);
        }
        readSelectionRange() {
          let { view: e } = this, n = Iu(e.root);
          if (!n)
            return false;
          let r = de.safari && e.root.nodeType == 11 && e.root.activeElement == this.dom && bU(this.view, n) || n;
          if (!r || this.selectionRange.eq(r))
            return false;
          let i = bd(this.dom, r);
          return i && !this.selectionChanged && e.inputState.lastFocusTime > Date.now() - 200 && e.inputState.lastTouchTime < Date.now() - 300 && n7(this.dom, r) ? (this.view.inputState.lastFocusTime = 0, e.docView.updateSelection(), false) : (this.selectionRange.setRange(r), i && (this.selectionChanged = true), true);
        }
        setSelectionRange(e, n) {
          this.selectionRange.set(e.node, e.offset, n.node, n.offset), this.selectionChanged = false;
        }
        clearSelectionRange() {
          this.selectionRange.set(null, 0, null, 0);
        }
        listenForScroll() {
          this.parentCheck = -1;
          let e = 0, n = null;
          for (let r = this.dom; r; )
            if (r.nodeType == 1)
              !n && e < this.scrollTargets.length && this.scrollTargets[e] == r ? e++ : n || (n = this.scrollTargets.slice(0, e)), n && n.push(r), r = r.assignedSlot || r.parentNode;
            else if (r.nodeType == 11)
              r = r.host;
            else
              break;
          if (e < this.scrollTargets.length && !n && (n = this.scrollTargets.slice(0, e)), n) {
            for (let r of this.scrollTargets)
              r.removeEventListener("scroll", this.onScroll);
            for (let r of this.scrollTargets = n)
              r.addEventListener("scroll", this.onScroll);
          }
        }
        ignore(e) {
          if (!this.active)
            return e();
          try {
            return this.stop(), e();
          } finally {
            this.start(), this.clear();
          }
        }
        start() {
          this.active || (this.observer.observe(this.dom, vU), $0 && this.dom.addEventListener("DOMCharacterDataModified", this.onCharData), this.active = true);
        }
        stop() {
          !this.active || (this.active = false, this.observer.disconnect(), $0 && this.dom.removeEventListener("DOMCharacterDataModified", this.onCharData));
        }
        clear() {
          this.processRecords(), this.queue.length = 0, this.selectionChanged = false;
        }
        delayAndroidKey(e, n) {
          var r;
          if (!this.delayedAndroidKey) {
            let i = () => {
              let o = this.delayedAndroidKey;
              o && (this.clearDelayedAndroidKey(), this.view.inputState.lastKeyCode = o.keyCode, this.view.inputState.lastKeyTime = Date.now(), !this.flush() && o.force && Ga(this.dom, o.key, o.keyCode));
            };
            this.flushingAndroidKey = this.view.win.requestAnimationFrame(i);
          }
          (!this.delayedAndroidKey || e == "Enter") && (this.delayedAndroidKey = {
            key: e,
            keyCode: n,
            force: this.lastChange < Date.now() - 50 || !!(!((r = this.delayedAndroidKey) === null || r === void 0) && r.force)
          });
        }
        clearDelayedAndroidKey() {
          this.win.cancelAnimationFrame(this.flushingAndroidKey), this.delayedAndroidKey = null, this.flushingAndroidKey = -1;
        }
        flushSoon() {
          this.delayedFlush < 0 && (this.delayedFlush = this.view.win.requestAnimationFrame(() => {
            this.delayedFlush = -1, this.flush();
          }));
        }
        forceFlush() {
          this.delayedFlush >= 0 && (this.view.win.cancelAnimationFrame(this.delayedFlush), this.delayedFlush = -1), this.flush();
        }
        pendingRecords() {
          for (let e of this.observer.takeRecords())
            this.queue.push(e);
          return this.queue;
        }
        processRecords() {
          let e = this.pendingRecords();
          e.length && (this.queue = []);
          let n = -1, r = -1, i = false;
          for (let o of e) {
            let s = this.readMutation(o);
            !s || (s.typeOver && (i = true), n == -1 ? { from: n, to: r } = s : (n = Math.min(s.from, n), r = Math.max(s.to, r)));
          }
          return {
            from: n,
            to: r,
            typeOver: i
          };
        }
        readChange() {
          let { from: e, to: n, typeOver: r } = this.processRecords(), i = this.selectionChanged && bd(this.dom, this.selectionRange);
          if (e < 0 && !i)
            return null;
          e > -1 && (this.lastChange = Date.now()), this.view.inputState.lastFocusTime = 0, this.selectionChanged = false;
          let o = new B7(this.view, e, n, r);
          return this.view.docView.domChanged = {
            newSel: o.newSel ? o.newSel.main : null
          }, o;
        }
        flush(e = true) {
          if (this.delayedFlush >= 0 || this.delayedAndroidKey)
            return false;
          e && this.readSelectionRange();
          let n = this.readChange();
          if (!n)
            return this.view.requestMeasure(), false;
          let r = this.view.state, i = iR(this.view, n);
          return this.view.state == r && (n.domChanged || n.newSel && !n.newSel.main.eq(this.view.state.selection.main)) && this.view.update([]), i;
        }
        readMutation(e) {
          let n = this.view.docView.nearest(e.target);
          if (!n || n.ignoreMutation(e))
            return null;
          if (n.markDirty(e.type == "attributes"), e.type == "attributes" && (n.flags |= 4), e.type == "childList") {
            let r = YC(n, e.previousSibling || e.target.previousSibling, -1), i = YC(n, e.nextSibling || e.target.nextSibling, 1);
            return {
              from: r ? n.posAfter(r) : n.posAtStart,
              to: i ? n.posBefore(i) : n.posAtEnd,
              typeOver: false
            };
          } else
            return e.type == "characterData" ? {
              from: n.posAtStart,
              to: n.posAtEnd,
              typeOver: e.target.nodeValue == e.oldValue
            } : null;
        }
        setWindow(e) {
          e != this.win && (this.removeWindowListeners(this.win), this.win = e, this.addWindowListeners(this.win));
        }
        addWindowListeners(e) {
          e.addEventListener("resize", this.onResize), this.printQuery ? this.printQuery.addEventListener ? this.printQuery.addEventListener("change", this.onPrint) : this.printQuery.addListener(this.onPrint) : e.addEventListener("beforeprint", this.onPrint), e.addEventListener("scroll", this.onScroll), e.document.addEventListener("selectionchange", this.onSelectionChange);
        }
        removeWindowListeners(e) {
          e.removeEventListener("scroll", this.onScroll), e.removeEventListener("resize", this.onResize), this.printQuery ? this.printQuery.removeEventListener ? this.printQuery.removeEventListener("change", this.onPrint) : this.printQuery.removeListener(this.onPrint) : e.removeEventListener("beforeprint", this.onPrint), e.document.removeEventListener("selectionchange", this.onSelectionChange);
        }
        update(e) {
          this.editContext && (this.editContext.update(e), e.startState.facet(Fi) != e.state.facet(Fi) && (e.view.contentDOM.editContext = e.state.facet(Fi) ? this.editContext.editContext : null));
        }
        destroy() {
          var e, n, r;
          this.stop(), (e = this.intersection) === null || e === void 0 || e.disconnect(), (n = this.gapIntersection) === null || n === void 0 || n.disconnect(), (r = this.resizeScroll) === null || r === void 0 || r.disconnect();
          for (let i of this.scrollTargets)
            i.removeEventListener("scroll", this.onScroll);
          this.removeWindowListeners(this.win), clearTimeout(this.parentCheck), clearTimeout(this.resizeTimeout), this.win.cancelAnimationFrame(this.delayedFlush), this.win.cancelAnimationFrame(this.flushingAndroidKey), this.editContext && (this.view.contentDOM.editContext = null, this.editContext.destroy());
        }
      }
      function YC(t, e, n) {
        for (; e; ) {
          let r = Ze.get(e);
          if (r && r.parent == t)
            return r;
          let i = e.parentNode;
          e = i != t.dom ? i : n > 0 ? e.nextSibling : e.previousSibling;
        }
        return null;
      }
      function XC(t, e) {
        let n = e.startContainer, r = e.startOffset, i = e.endContainer, o = e.endOffset, s = t.docView.domAtPos(t.state.selection.main.anchor);
        return Xc(s.node, s.offset, i, o) && ([n, r, i, o] = [
          i,
          o,
          n,
          r
        ]), {
          anchorNode: n,
          anchorOffset: r,
          focusNode: i,
          focusOffset: o
        };
      }
      function bU(t, e) {
        if (e.getComposedRanges) {
          let i = e.getComposedRanges(t.root)[0];
          if (i)
            return XC(t, i);
        }
        let n = null;
        function r(i) {
          i.preventDefault(), i.stopImmediatePropagation(), n = i.getTargetRanges()[0];
        }
        return t.contentDOM.addEventListener("beforeinput", r, true), t.dom.ownerDocument.execCommand("indent"), t.contentDOM.removeEventListener("beforeinput", r, true), n ? XC(t, n) : null;
      }
      class xU {
        constructor(e) {
          this.from = 0, this.to = 0, this.pendingContextChange = null, this.handlers = /* @__PURE__ */ Object.create(null), this.composing = null, this.resetRange(e.state);
          let n = this.editContext = new window.EditContext({
            text: e.state.doc.sliceString(this.from, this.to),
            selectionStart: this.toContextPos(Math.max(this.from, Math.min(this.to, e.state.selection.main.anchor))),
            selectionEnd: this.toContextPos(e.state.selection.main.head)
          });
          this.handlers.textupdate = (r) => {
            let i = e.state.selection.main, { anchor: o, head: s } = i, a = this.toEditorPos(r.updateRangeStart), l = this.toEditorPos(r.updateRangeEnd);
            e.inputState.composing >= 0 && !this.composing && (this.composing = {
              contextBase: r.updateRangeStart,
              editorBase: a,
              drifted: false
            });
            let c = {
              from: a,
              to: l,
              insert: He.of(r.text.split(`
`))
            };
            if (c.from == this.from && o < this.from ? c.from = o : c.to == this.to && o > this.to && (c.to = o), c.from == c.to && !c.insert.length) {
              let u = q.single(this.toEditorPos(r.selectionStart), this.toEditorPos(r.selectionEnd));
              u.main.eq(i) || e.dispatch({
                selection: u,
                userEvent: "select"
              });
              return;
            }
            if ((de.mac || de.android) && c.from == s - 1 && /^\. ?$/.test(r.text) && e.contentDOM.getAttribute("autocorrect") == "off" && (c = {
              from: a,
              to: l,
              insert: He.of([
                r.text.replace(".", " ")
              ])
            }), this.pendingContextChange = c, !e.state.readOnly) {
              let u = this.to - this.from + (c.to - c.from + c.insert.length);
              Lx(e, c, q.single(this.toEditorPos(r.selectionStart, u), this.toEditorPos(r.selectionEnd, u)));
            }
            this.pendingContextChange && (this.revertPending(e.state), this.setSelection(e.state));
          }, this.handlers.characterboundsupdate = (r) => {
            let i = [], o = null;
            for (let s = this.toEditorPos(r.rangeStart), a = this.toEditorPos(r.rangeEnd); s < a; s++) {
              let l = e.coordsForChar(s);
              o = l && new DOMRect(l.left, l.top, l.right - l.left, l.bottom - l.top) || o || new DOMRect(), i.push(o);
            }
            n.updateCharacterBounds(r.rangeStart, i);
          }, this.handlers.textformatupdate = (r) => {
            let i = [];
            for (let o of r.getTextFormats()) {
              let s = o.underlineStyle, a = o.underlineThickness;
              if (s != "None" && a != "None") {
                let l = this.toEditorPos(o.rangeStart), c = this.toEditorPos(o.rangeEnd);
                if (l < c) {
                  let u = `text-decoration: underline ${s == "Dashed" ? "dashed " : s == "Squiggle" ? "wavy " : ""}${a == "Thin" ? 1 : 2}px`;
                  i.push(be.mark({
                    attributes: {
                      style: u
                    }
                  }).range(l, c));
                }
              }
            }
            e.dispatch({
              effects: QO.of(be.set(i))
            });
          }, this.handlers.compositionstart = () => {
            e.inputState.composing < 0 && (e.inputState.composing = 0, e.inputState.compositionFirstChange = true);
          }, this.handlers.compositionend = () => {
            if (e.inputState.composing = -1, e.inputState.compositionFirstChange = null, this.composing) {
              let { drifted: r } = this.composing;
              this.composing = null, r && this.reset(e.state);
            }
          };
          for (let r in this.handlers)
            n.addEventListener(r, this.handlers[r]);
          this.measureReq = {
            read: (r) => {
              this.editContext.updateControlBounds(r.contentDOM.getBoundingClientRect());
              let i = Iu(r.root);
              i && i.rangeCount && this.editContext.updateSelectionBounds(i.getRangeAt(0).getBoundingClientRect());
            }
          };
        }
        applyEdits(e) {
          let n = 0, r = false, i = this.pendingContextChange;
          return e.changes.iterChanges((o, s, a, l, c) => {
            if (r)
              return;
            let u = c.length - (s - o);
            if (i && s >= i.to)
              if (i.from == o && i.to == s && i.insert.eq(c)) {
                i = this.pendingContextChange = null, n += u, this.to += u;
                return;
              } else
                i = null, this.revertPending(e.state);
            if (o += n, s += n, s <= this.from)
              this.from += u, this.to += u;
            else if (o < this.to) {
              if (o < this.from || s > this.to || this.to - this.from + c.length > 3e4) {
                r = true;
                return;
              }
              this.editContext.updateText(this.toContextPos(o), this.toContextPos(s), c.toString()), this.to += u;
            }
            n += u;
          }), i && !r && this.revertPending(e.state), !r;
        }
        update(e) {
          let n = this.pendingContextChange, r = e.startState.selection.main;
          this.composing && (this.composing.drifted || !e.changes.touchesRange(r.from, r.to) && e.transactions.some((i) => !i.isUserEvent("input.type") && i.changes.touchesRange(this.from, this.to))) ? (this.composing.drifted = true, this.composing.editorBase = e.changes.mapPos(this.composing.editorBase)) : !this.applyEdits(e) || !this.rangeIsValid(e.state) ? (this.pendingContextChange = null, this.reset(e.state)) : (e.docChanged || e.selectionSet || n) && this.setSelection(e.state), (e.geometryChanged || e.docChanged || e.selectionSet) && e.view.requestMeasure(this.measureReq);
        }
        resetRange(e) {
          let { head: n } = e.selection.main;
          this.from = Math.max(0, n - 1e4), this.to = Math.min(e.doc.length, n + 1e4);
        }
        reset(e) {
          this.resetRange(e), this.editContext.updateText(0, this.editContext.text.length, e.doc.sliceString(this.from, this.to)), this.setSelection(e);
        }
        revertPending(e) {
          let n = this.pendingContextChange;
          this.pendingContextChange = null, this.editContext.updateText(this.toContextPos(n.from), this.toContextPos(n.from + n.insert.length), e.doc.sliceString(n.from, n.to));
        }
        setSelection(e) {
          let { main: n } = e.selection, r = this.toContextPos(Math.max(this.from, Math.min(this.to, n.anchor))), i = this.toContextPos(n.head);
          (this.editContext.selectionStart != r || this.editContext.selectionEnd != i) && this.editContext.updateSelection(r, i);
        }
        rangeIsValid(e) {
          let { head: n } = e.selection.main;
          return !(this.from > 0 && n - this.from < 500 || this.to < e.doc.length && this.to - n < 500 || this.to - this.from > 1e4 * 3);
        }
        toEditorPos(e, n = this.to - this.from) {
          e = Math.min(e, n);
          let r = this.composing;
          return r && r.drifted ? r.editorBase + (e - r.contextBase) : e + this.from;
        }
        toContextPos(e) {
          let n = this.composing;
          return n && n.drifted ? n.contextBase + (e - n.editorBase) : e - this.from;
        }
        destroy() {
          for (let e in this.handlers)
            this.editContext.removeEventListener(e, this.handlers[e]);
        }
      }
      class ce {
        get state() {
          return this.viewState.state;
        }
        get viewport() {
          return this.viewState.viewport;
        }
        get visibleRanges() {
          return this.viewState.visibleRanges;
        }
        get inView() {
          return this.viewState.inView;
        }
        get composing() {
          return this.inputState.composing > 0;
        }
        get compositionStarted() {
          return this.inputState.composing >= 0;
        }
        get root() {
          return this._root;
        }
        get win() {
          return this.dom.ownerDocument.defaultView || window;
        }
        constructor(e = {}) {
          var n;
          this.plugins = [], this.pluginMap = /* @__PURE__ */ new Map(), this.editorAttrs = {}, this.contentAttrs = {}, this.bidiCache = [], this.destroyed = false, this.updateState = 2, this.measureScheduled = -1, this.measureRequests = [], this.contentDOM = document.createElement("div"), this.scrollDOM = document.createElement("div"), this.scrollDOM.tabIndex = -1, this.scrollDOM.className = "cm-scroller", this.scrollDOM.appendChild(this.contentDOM), this.announceDOM = document.createElement("div"), this.announceDOM.className = "cm-announced", this.announceDOM.setAttribute("aria-live", "polite"), this.dom = document.createElement("div"), this.dom.appendChild(this.announceDOM), this.dom.appendChild(this.scrollDOM), e.parent && e.parent.appendChild(this.dom);
          let { dispatch: r } = e;
          this.dispatchTransactions = e.dispatchTransactions || r && ((i) => i.forEach((o) => r(o, this))) || ((i) => this.update(i)), this.dispatch = this.dispatch.bind(this), this._root = e.root || t7(e.parent) || document, this.viewState = new qC(e.state || Ne.create(e)), e.scrollTo && e.scrollTo.is(Sh) && (this.viewState.scrollTarget = e.scrollTo.value.clip(this.viewState.state)), this.plugins = this.state.facet(yc).map((i) => new _0(i));
          for (let i of this.plugins)
            i.update(this);
          this.observer = new yU(this), this.inputState = new V7(this), this.inputState.ensureHandlers(this.plugins), this.docView = new EC(this), this.mountStyles(), this.updateAttrs(), this.updateState = 0, this.requestMeasure(), !((n = document.fonts) === null || n === void 0) && n.ready && document.fonts.ready.then(() => this.requestMeasure());
        }
        dispatch(...e) {
          let n = e.length == 1 && e[0] instanceof Bt ? e : e.length == 1 && Array.isArray(e[0]) ? e[0] : [
            this.state.update(...e)
          ];
          this.dispatchTransactions(n, this);
        }
        update(e) {
          if (this.updateState != 0)
            throw new Error("Calls to EditorView.update are not allowed while an update is in progress");
          let n = false, r = false, i, o = this.state;
          for (let p of e) {
            if (p.startState != o)
              throw new RangeError("Trying to update state with a transaction that doesn't start from the previous state.");
            o = p.state;
          }
          if (this.destroyed) {
            this.viewState.state = o;
            return;
          }
          let s = this.hasFocus, a = 0, l = null;
          e.some((p) => p.annotation(uR)) ? (this.inputState.notifiedFocused = s, a = 1) : s != this.inputState.notifiedFocused && (this.inputState.notifiedFocused = s, l = fR(o, s), l || (a = 1));
          let c = this.observer.delayedAndroidKey, u = null;
          if (c ? (this.observer.clearDelayedAndroidKey(), u = this.observer.readChange(), (u && !this.state.doc.eq(o.doc) || !this.state.selection.eq(o.selection)) && (u = null)) : this.observer.clear(), o.facet(Ne.phrases) != this.state.facet(Ne.phrases))
            return this.setState(o);
          i = Sp.create(this, o, e), i.flags |= a;
          let h = this.viewState.scrollTarget;
          try {
            this.updateState = 2;
            for (let p of e) {
              if (h && (h = h.map(p.changes)), p.scrollIntoView) {
                let { main: v } = p.state.selection;
                h = new Ya(v.empty ? v : q.cursor(v.head, v.head > v.anchor ? -1 : 1));
              }
              for (let v of p.effects)
                v.is(Sh) && (h = v.value.clip(this.state));
            }
            this.viewState.update(i, h), this.bidiCache = kp.update(this.bidiCache, i.changes), i.empty || (this.updatePlugins(i), this.inputState.update(i)), n = this.docView.update(i), this.state.facet(bc) != this.styleModules && this.mountStyles(), r = this.updateAttrs(), this.showAnnouncements(e), this.docView.updateSelection(n, e.some((p) => p.isUserEvent("select.pointer")));
          } finally {
            this.updateState = 0;
          }
          if (i.startState.facet(Ah) != i.state.facet(Ah) && (this.viewState.mustMeasureContent = true), (n || r || h || this.viewState.mustEnforceCursorAssoc || this.viewState.mustMeasureContent) && this.requestMeasure(), n && this.docViewUpdate(), !i.empty)
            for (let p of this.state.facet(n1))
              try {
                p(i);
              } catch (v) {
                Bn(this.state, v, "update listener");
              }
          (l || u) && Promise.resolve().then(() => {
            l && this.state == l.startState && this.dispatch(l), u && !iR(this, u) && c.force && Ga(this.contentDOM, c.key, c.keyCode);
          });
        }
        setState(e) {
          if (this.updateState != 0)
            throw new Error("Calls to EditorView.setState are not allowed while an update is in progress");
          if (this.destroyed) {
            this.viewState.state = e;
            return;
          }
          this.updateState = 2;
          let n = this.hasFocus;
          try {
            for (let r of this.plugins)
              r.destroy(this);
            this.viewState = new qC(e), this.plugins = e.facet(yc).map((r) => new _0(r)), this.pluginMap.clear();
            for (let r of this.plugins)
              r.update(this);
            this.docView.destroy(), this.docView = new EC(this), this.inputState.ensureHandlers(this.plugins), this.mountStyles(), this.updateAttrs(), this.bidiCache = [];
          } finally {
            this.updateState = 0;
          }
          n && this.focus(), this.requestMeasure();
        }
        updatePlugins(e) {
          let n = e.startState.facet(yc), r = e.state.facet(yc);
          if (n != r) {
            let i = [];
            for (let o of r) {
              let s = n.indexOf(o);
              if (s < 0)
                i.push(new _0(o));
              else {
                let a = this.plugins[s];
                a.mustUpdate = e, i.push(a);
              }
            }
            for (let o of this.plugins)
              o.mustUpdate != e && o.destroy(this);
            this.plugins = i, this.pluginMap.clear();
          } else
            for (let i of this.plugins)
              i.mustUpdate = e;
          for (let i = 0; i < this.plugins.length; i++)
            this.plugins[i].update(this);
          n != r && this.inputState.ensureHandlers(this.plugins);
        }
        docViewUpdate() {
          for (let e of this.plugins) {
            let n = e.value;
            if (n && n.docViewUpdate)
              try {
                n.docViewUpdate(this);
              } catch (r) {
                Bn(this.state, r, "doc view update listener");
              }
          }
        }
        measure(e = true) {
          if (this.destroyed)
            return;
          if (this.measureScheduled > -1 && this.win.cancelAnimationFrame(this.measureScheduled), this.observer.delayedAndroidKey) {
            this.measureScheduled = -1, this.requestMeasure();
            return;
          }
          this.measureScheduled = 0, e && this.observer.forceFlush();
          let n = null, r = this.scrollDOM, i = r.scrollTop * this.scaleY, { scrollAnchorPos: o, scrollAnchorHeight: s } = this.viewState;
          Math.abs(i - this.viewState.scrollTop) > 1 && (s = -1), this.viewState.scrollAnchorHeight = -1;
          try {
            for (let a = 0; ; a++) {
              if (s < 0)
                if (TO(r))
                  o = -1, s = this.viewState.heightMap.height;
                else {
                  let v = this.viewState.scrollAnchorAt(i);
                  o = v.from, s = v.top;
                }
              this.updateState = 1;
              let l = this.viewState.measure(this);
              if (!l && !this.measureRequests.length && this.viewState.scrollTarget == null)
                break;
              if (a > 5) {
                console.warn(this.measureRequests.length ? "Measure loop restarted more than 5 times" : "Viewport failed to stabilize");
                break;
              }
              let c = [];
              l & 4 || ([this.measureRequests, c] = [
                c,
                this.measureRequests
              ]);
              let u = c.map((v) => {
                try {
                  return v.read(this);
                } catch (y) {
                  return Bn(this.state, y), QC;
                }
              }), h = Sp.create(this, this.state, []), p = false;
              h.flags |= l, n ? n.flags |= l : n = h, this.updateState = 2, h.empty || (this.updatePlugins(h), this.inputState.update(h), this.updateAttrs(), p = this.docView.update(h), p && this.docViewUpdate());
              for (let v = 0; v < c.length; v++)
                if (u[v] != QC)
                  try {
                    let y = c[v];
                    y.write && y.write(u[v], this);
                  } catch (y) {
                    Bn(this.state, y);
                  }
              if (p && this.docView.updateSelection(true), !h.viewportChanged && this.measureRequests.length == 0) {
                if (this.viewState.editorHeight)
                  if (this.viewState.scrollTarget) {
                    this.docView.scrollIntoView(this.viewState.scrollTarget), this.viewState.scrollTarget = null, s = -1;
                    continue;
                  } else {
                    let y = (o < 0 ? this.viewState.heightMap.height : this.viewState.lineBlockAt(o).top) - s;
                    if (y > 1 || y < -1) {
                      i = i + y, r.scrollTop = i / this.scaleY, s = -1;
                      continue;
                    }
                  }
                break;
              }
            }
          } finally {
            this.updateState = 0, this.measureScheduled = -1;
          }
          if (n && !n.empty)
            for (let a of this.state.facet(n1))
              a(n);
        }
        get themeClasses() {
          return a1 + " " + (this.state.facet(s1) ? mR : pR) + " " + this.state.facet(Ah);
        }
        updateAttrs() {
          let e = JC(this, JO, {
            class: "cm-editor" + (this.hasFocus ? " cm-focused " : " ") + this.themeClasses
          }), n = {
            spellcheck: "false",
            autocorrect: "off",
            autocapitalize: "off",
            writingsuggestions: "false",
            translate: "no",
            contenteditable: this.state.facet(Fi) ? "true" : "false",
            class: "cm-content",
            style: `${de.tabSize}: ${this.state.tabSize}`,
            role: "textbox",
            "aria-multiline": "true"
          };
          this.state.readOnly && (n["aria-readonly"] = "true"), JC(this, Px, n);
          let r = this.observer.ignore(() => {
            let i = Qy(this.contentDOM, this.contentAttrs, n), o = Qy(this.dom, this.editorAttrs, e);
            return i || o;
          });
          return this.editorAttrs = e, this.contentAttrs = n, r;
        }
        showAnnouncements(e) {
          let n = true;
          for (let r of e)
            for (let i of r.effects)
              if (i.is(ce.announce)) {
                n && (this.announceDOM.textContent = ""), n = false;
                let o = this.announceDOM.appendChild(document.createElement("div"));
                o.textContent = i.value;
              }
        }
        mountStyles() {
          this.styleModules = this.state.facet(bc);
          let e = this.state.facet(ce.cspNonce);
          qo.mount(this.root, this.styleModules.concat(gU).reverse(), e ? {
            nonce: e
          } : void 0);
        }
        readMeasured() {
          if (this.updateState == 2)
            throw new Error("Reading the editor layout isn't allowed during an update");
          this.updateState == 0 && this.measureScheduled > -1 && this.measure(false);
        }
        requestMeasure(e) {
          if (this.measureScheduled < 0 && (this.measureScheduled = this.win.requestAnimationFrame(() => this.measure())), e) {
            if (this.measureRequests.indexOf(e) > -1)
              return;
            if (e.key != null) {
              for (let n = 0; n < this.measureRequests.length; n++)
                if (this.measureRequests[n].key === e.key) {
                  this.measureRequests[n] = e;
                  return;
                }
            }
            this.measureRequests.push(e);
          }
        }
        plugin(e) {
          let n = this.pluginMap.get(e);
          return (n === void 0 || n && n.spec != e) && this.pluginMap.set(e, n = this.plugins.find((r) => r.spec == e) || null), n && n.update(this).value;
        }
        get documentTop() {
          return this.contentDOM.getBoundingClientRect().top + this.viewState.paddingTop;
        }
        get documentPadding() {
          return {
            top: this.viewState.paddingTop,
            bottom: this.viewState.paddingBottom
          };
        }
        get scaleX() {
          return this.viewState.scaleX;
        }
        get scaleY() {
          return this.viewState.scaleY;
        }
        elementAtHeight(e) {
          return this.readMeasured(), this.viewState.elementAtHeight(e);
        }
        lineBlockAtHeight(e) {
          return this.readMeasured(), this.viewState.lineBlockAtHeight(e);
        }
        get viewportLineBlocks() {
          return this.viewState.viewportLines;
        }
        lineBlockAt(e) {
          return this.viewState.lineBlockAt(e);
        }
        get contentHeight() {
          return this.viewState.contentHeight;
        }
        moveByChar(e, n, r) {
          return B0(this, e, DC(this, e, n, r));
        }
        moveByGroup(e, n) {
          return B0(this, e, DC(this, e, n, (r) => L7(this, e.head, r)));
        }
        visualLineSide(e, n) {
          let r = this.bidiSpans(e), i = this.textDirectionAt(e.from), o = r[n ? r.length - 1 : 0];
          return q.cursor(o.side(n, i) + e.from, o.forward(!n, i) ? 1 : -1);
        }
        moveToLineBoundary(e, n, r = true) {
          return R7(this, e, n, r);
        }
        moveVertically(e, n, r) {
          return B0(this, e, D7(this, e, n, r));
        }
        domAtPos(e) {
          return this.docView.domAtPos(e);
        }
        posAtDOM(e, n = 0) {
          return this.docView.posFromDOM(e, n);
        }
        posAtCoords(e, n = true) {
          return this.readMeasured(), rR(this, e, n);
        }
        coordsAtPos(e, n = 1) {
          this.readMeasured();
          let r = this.docView.coordsAt(e, n);
          if (!r || r.left == r.right)
            return r;
          let i = this.state.doc.lineAt(e), o = this.bidiSpans(i), s = o[_o.find(o, e - i.from, -1, n)];
          return rf(r, s.dir == rt.LTR == n > 0);
        }
        coordsForChar(e) {
          return this.readMeasured(), this.docView.coordsForChar(e);
        }
        get defaultCharacterWidth() {
          return this.viewState.heightOracle.charWidth;
        }
        get defaultLineHeight() {
          return this.viewState.heightOracle.lineHeight;
        }
        get textDirection() {
          return this.viewState.defaultTextDirection;
        }
        textDirectionAt(e) {
          return !this.state.facet(GO) || e < this.viewport.from || e > this.viewport.to ? this.textDirection : (this.readMeasured(), this.docView.textDirectionAt(e));
        }
        get lineWrapping() {
          return this.viewState.heightOracle.lineWrapping;
        }
        bidiSpans(e) {
          if (e.length > SU)
            return FO(e.length);
          let n = this.textDirectionAt(e.from), r;
          for (let o of this.bidiCache)
            if (o.from == e.from && o.dir == n && (o.fresh || zO(o.isolates, r = AC(this, e))))
              return o.order;
          r || (r = AC(this, e));
          let i = m7(e.text, n, r);
          return this.bidiCache.push(new kp(e.from, e.to, n, r, true, i)), i;
        }
        get hasFocus() {
          var e;
          return (this.dom.ownerDocument.hasFocus() || de.safari && ((e = this.inputState) === null || e === void 0 ? void 0 : e.lastContextMenu) > Date.now() - 3e4) && this.root.activeElement == this.contentDOM;
        }
        focus() {
          this.observer.ignore(() => {
            kO(this.contentDOM), this.docView.updateSelection();
          });
        }
        setRoot(e) {
          this._root != e && (this._root = e, this.observer.setWindow((e.nodeType == 9 ? e : e.ownerDocument).defaultView || window), this.mountStyles());
        }
        destroy() {
          this.root.activeElement == this.contentDOM && this.contentDOM.blur();
          for (let e of this.plugins)
            e.destroy(this);
          this.plugins = [], this.inputState.destroy(), this.docView.destroy(), this.dom.remove(), this.observer.destroy(), this.measureScheduled > -1 && this.win.cancelAnimationFrame(this.measureScheduled), this.destroyed = true;
        }
        static scrollIntoView(e, n = {}) {
          return Sh.of(new Ya(typeof e == "number" ? q.cursor(e) : e, n.y, n.x, n.yMargin, n.xMargin));
        }
        scrollSnapshot() {
          let { scrollTop: e, scrollLeft: n } = this.scrollDOM, r = this.viewState.scrollAnchorAt(e);
          return Sh.of(new Ya(q.cursor(r.from), "start", "start", r.top - e, n, true));
        }
        setTabFocusMode(e) {
          e == null ? this.inputState.tabFocusMode = this.inputState.tabFocusMode < 0 ? 0 : -1 : typeof e == "boolean" ? this.inputState.tabFocusMode = e ? 0 : -1 : this.inputState.tabFocusMode != 0 && (this.inputState.tabFocusMode = Date.now() + e);
        }
        static domEventHandlers(e) {
          return Ct.define(() => ({}), {
            eventHandlers: e
          });
        }
        static domEventObservers(e) {
          return Ct.define(() => ({}), {
            eventObservers: e
          });
        }
        static theme(e, n) {
          let r = qo.newName(), i = [
            Ah.of(r),
            bc.of(l1(`.${r}`, e))
          ];
          return n && n.dark && i.push(s1.of(true)), i;
        }
        static baseTheme(e) {
          return ns.lowest(bc.of(l1("." + a1, e, gR)));
        }
        static findFromDOM(e) {
          var n;
          let r = e.querySelector(".cm-content"), i = r && Ze.get(r) || Ze.get(e);
          return ((n = i == null ? void 0 : i.rootView) === null || n === void 0 ? void 0 : n.view) || null;
        }
      }
      ce.styleModule = bc;
      ce.inputHandler = KO;
      ce.clipboardInputFilter = Ax;
      ce.clipboardOutputFilter = Ex;
      ce.scrollHandler = XO;
      ce.focusChangeEffect = qO;
      ce.perLineTextDirection = GO;
      ce.exceptionSink = UO;
      ce.updateListener = n1;
      ce.editable = Fi;
      ce.mouseSelectionStyle = WO;
      ce.dragMovesSelection = jO;
      ce.clickAddsSelectionRange = HO;
      ce.decorations = Bu;
      ce.outerDecorations = ZO;
      ce.atomicRanges = Ox;
      ce.bidiIsolatedRanges = eR;
      ce.scrollMargins = tR;
      ce.darkTheme = s1;
      ce.cspNonce = pe.define({
        combine: (t) => t.length ? t[0] : ""
      });
      ce.contentAttributes = Px;
      ce.editorAttributes = JO;
      ce.lineWrapping = ce.contentAttributes.of({
        class: "cm-lineWrapping"
      });
      ce.announce = Pe.define();
      const SU = 4096, QC = {};
      class kp {
        constructor(e, n, r, i, o, s) {
          this.from = e, this.to = n, this.dir = r, this.isolates = i, this.fresh = o, this.order = s;
        }
        static update(e, n) {
          if (n.empty && !e.some((o) => o.fresh))
            return e;
          let r = [], i = e.length ? e[e.length - 1].dir : rt.LTR;
          for (let o = Math.max(0, e.length - 10); o < e.length; o++) {
            let s = e[o];
            s.dir == i && !n.touchesRange(s.from, s.to) && r.push(new kp(n.mapPos(s.from, 1), n.mapPos(s.to, -1), s.dir, s.isolates, false, s.order));
          }
          return r;
        }
      }
      function JC(t, e, n) {
        for (let r = t.state.facet(e), i = r.length - 1; i >= 0; i--) {
          let o = r[i], s = typeof o == "function" ? o(t) : o;
          s && Xy(s, n);
        }
        return n;
      }
      const wU = de.mac ? "mac" : de.windows ? "win" : de.linux ? "linux" : "key";
      function kU(t, e) {
        const n = t.split(/-(?!$)/);
        let r = n[n.length - 1];
        r == "Space" && (r = " ");
        let i, o, s, a;
        for (let l = 0; l < n.length - 1; ++l) {
          const c = n[l];
          if (/^(cmd|meta|m)$/i.test(c))
            a = true;
          else if (/^a(lt)?$/i.test(c))
            i = true;
          else if (/^(c|ctrl|control)$/i.test(c))
            o = true;
          else if (/^s(hift)?$/i.test(c))
            s = true;
          else if (/^mod$/i.test(c))
            e == "mac" ? a = true : o = true;
          else
            throw new Error("Unrecognized modifier name: " + c);
        }
        return i && (r = "Alt-" + r), o && (r = "Ctrl-" + r), a && (r = "Meta-" + r), s && (r = "Shift-" + r), r;
      }
      function Eh(t, e, n) {
        return e.altKey && (t = "Alt-" + t), e.ctrlKey && (t = "Ctrl-" + t), e.metaKey && (t = "Meta-" + t), n !== false && e.shiftKey && (t = "Shift-" + t), t;
      }
      const CU = ns.default(ce.domEventHandlers({
        keydown(t, e) {
          return yR(vR(e.state), t, e, "editor");
        }
      })), Hm = pe.define({
        enables: CU
      }), ZC = /* @__PURE__ */ new WeakMap();
      function vR(t) {
        let e = t.facet(Hm), n = ZC.get(e);
        return n || ZC.set(e, n = MU(e.reduce((r, i) => r.concat(i), []))), n;
      }
      function ys(t, e, n) {
        return yR(vR(t.state), e, t, n);
      }
      let Mo = null;
      const TU = 4e3;
      function MU(t, e = wU) {
        let n = /* @__PURE__ */ Object.create(null), r = /* @__PURE__ */ Object.create(null), i = (s, a) => {
          let l = r[s];
          if (l == null)
            r[s] = a;
          else if (l != a)
            throw new Error("Key binding " + s + " is used both as a regular binding and as a multi-stroke prefix");
        }, o = (s, a, l, c, u) => {
          var h, p;
          let v = n[s] || (n[s] = /* @__PURE__ */ Object.create(null)), y = a.split(/ (?!$)/).map((w) => kU(w, e));
          for (let w = 1; w < y.length; w++) {
            let k = y.slice(0, w).join(" ");
            i(k, true), v[k] || (v[k] = {
              preventDefault: true,
              stopPropagation: false,
              run: [
                (T) => {
                  let P = Mo = {
                    view: T,
                    prefix: k,
                    scope: s
                  };
                  return setTimeout(() => {
                    Mo == P && (Mo = null);
                  }, TU), true;
                }
              ]
            });
          }
          let S = y.join(" ");
          i(S, false);
          let C = v[S] || (v[S] = {
            preventDefault: false,
            stopPropagation: false,
            run: ((p = (h = v._any) === null || h === void 0 ? void 0 : h.run) === null || p === void 0 ? void 0 : p.slice()) || []
          });
          l && C.run.push(l), c && (C.preventDefault = true), u && (C.stopPropagation = true);
        };
        for (let s of t) {
          let a = s.scope ? s.scope.split(" ") : [
            "editor"
          ];
          if (s.any)
            for (let c of a) {
              let u = n[c] || (n[c] = /* @__PURE__ */ Object.create(null));
              u._any || (u._any = {
                preventDefault: false,
                stopPropagation: false,
                run: []
              });
              let { any: h } = s;
              for (let p in u)
                u[p].run.push((v) => h(v, c1));
            }
          let l = s[e] || s.key;
          if (!!l)
            for (let c of a)
              o(c, l, s.run, s.preventDefault, s.stopPropagation), s.shift && o(c, "Shift-" + l, s.shift, s.preventDefault, s.stopPropagation);
        }
        return n;
      }
      let c1 = null;
      function yR(t, e, n, r) {
        c1 = e;
        let i = XW(e), o = Rn(i, 0), s = di(o) == i.length && i != " ", a = "", l = false, c = false, u = false;
        Mo && Mo.view == n && Mo.scope == r && (a = Mo.prefix + " ", sR.indexOf(e.keyCode) < 0 && (c = true, Mo = null));
        let h = /* @__PURE__ */ new Set(), p = (C) => {
          if (C) {
            for (let w of C.run)
              if (!h.has(w) && (h.add(w), w(n)))
                return C.stopPropagation && (u = true), true;
            C.preventDefault && (C.stopPropagation && (u = true), c = true);
          }
          return false;
        }, v = t[r], y, S;
        return v && (p(v[a + Eh(i, e, !s)]) ? l = true : s && (e.altKey || e.metaKey || e.ctrlKey) && !(de.windows && e.ctrlKey && e.altKey) && (y = Go[e.keyCode]) && y != i ? (p(v[a + Eh(y, e, true)]) || e.shiftKey && (S = _u[e.keyCode]) != i && S != y && p(v[a + Eh(S, e, false)])) && (l = true) : s && e.shiftKey && p(v[a + Eh(i, e, true)]) && (l = true), !l && p(v._any) && (l = true)), c && (l = true), l && u && e.stopPropagation(), c1 = null, l;
      }
      class af {
        constructor(e, n, r, i, o) {
          this.className = e, this.left = n, this.top = r, this.width = i, this.height = o;
        }
        draw() {
          let e = document.createElement("div");
          return e.className = this.className, this.adjust(e), e;
        }
        update(e, n) {
          return n.className != this.className ? false : (this.adjust(e), true);
        }
        adjust(e) {
          e.style.left = this.left + "px", e.style.top = this.top + "px", this.width != null && (e.style.width = this.width + "px"), e.style.height = this.height + "px";
        }
        eq(e) {
          return this.left == e.left && this.top == e.top && this.width == e.width && this.height == e.height && this.className == e.className;
        }
        static forRange(e, n, r) {
          if (r.empty) {
            let i = e.coordsAtPos(r.head, r.assoc || 1);
            if (!i)
              return [];
            let o = bR(e);
            return [
              new af(n, i.left - o.left, i.top - o.top, null, i.bottom - i.top)
            ];
          } else
            return AU(e, n, r);
        }
      }
      function bR(t) {
        let e = t.scrollDOM.getBoundingClientRect();
        return {
          left: (t.textDirection == rt.LTR ? e.left : e.right - t.scrollDOM.clientWidth * t.scaleX) - t.scrollDOM.scrollLeft * t.scaleX,
          top: e.top - t.scrollDOM.scrollTop * t.scaleY
        };
      }
      function eT(t, e, n, r) {
        let i = t.coordsAtPos(e, n * 2);
        if (!i)
          return r;
        let o = t.dom.getBoundingClientRect(), s = (i.top + i.bottom) / 2, a = t.posAtCoords({
          x: o.left + 1,
          y: s
        }), l = t.posAtCoords({
          x: o.right - 1,
          y: s
        });
        return a == null || l == null ? r : {
          from: Math.max(r.from, Math.min(a, l)),
          to: Math.min(r.to, Math.max(a, l))
        };
      }
      function AU(t, e, n) {
        if (n.to <= t.viewport.from || n.from >= t.viewport.to)
          return [];
        let r = Math.max(n.from, t.viewport.from), i = Math.min(n.to, t.viewport.to), o = t.textDirection == rt.LTR, s = t.contentDOM, a = s.getBoundingClientRect(), l = bR(t), c = s.querySelector(".cm-line"), u = c && window.getComputedStyle(c), h = a.left + (u ? parseInt(u.paddingLeft) + Math.min(0, parseInt(u.textIndent)) : 0), p = a.right - (u ? parseInt(u.paddingRight) : 0), v = i1(t, r), y = i1(t, i), S = v.type == kn.Text ? v : null, C = y.type == kn.Text ? y : null;
        if (S && (t.lineWrapping || v.widgetLineBreaks) && (S = eT(t, r, 1, S)), C && (t.lineWrapping || y.widgetLineBreaks) && (C = eT(t, i, -1, C)), S && C && S.from == C.from && S.to == C.to)
          return k(T(n.from, n.to, S));
        {
          let R = S ? T(n.from, null, S) : P(v, false), L = C ? T(null, n.to, C) : P(y, true), D = [];
          return (S || v).to < (C || y).from - (S && C ? 1 : 0) || v.widgetLineBreaks > 1 && R.bottom + t.defaultLineHeight / 2 < L.top ? D.push(w(h, R.bottom, p, L.top)) : R.bottom < L.top && t.elementAtHeight((R.bottom + L.top) / 2).type == kn.Text && (R.bottom = L.top = (R.bottom + L.top) / 2), k(R).concat(D).concat(k(L));
        }
        function w(R, L, D, F) {
          return new af(e, R - l.left, L - l.top, D - R, F - L);
        }
        function k({ top: R, bottom: L, horizontal: D }) {
          let F = [];
          for (let K = 0; K < D.length; K += 2)
            F.push(w(D[K], R, D[K + 1], L));
          return F;
        }
        function T(R, L, D) {
          let F = 1e9, K = -1e9, Y = [];
          function te(ye, ke, Ee, Q, V) {
            let ae = t.coordsAtPos(ye, ye == D.to ? -2 : 2), ge = t.coordsAtPos(Ee, Ee == D.from ? 2 : -2);
            !ae || !ge || (F = Math.min(ae.top, ge.top, F), K = Math.max(ae.bottom, ge.bottom, K), V == rt.LTR ? Y.push(o && ke ? h : ae.left, o && Q ? p : ge.right) : Y.push(!o && Q ? h : ge.left, !o && ke ? p : ae.right));
          }
          let ne = R ?? D.from, ue = L ?? D.to;
          for (let ye of t.visibleRanges)
            if (ye.to > ne && ye.from < ue)
              for (let ke = Math.max(ye.from, ne), Ee = Math.min(ye.to, ue); ; ) {
                let Q = t.state.doc.lineAt(ke);
                for (let V of t.bidiSpans(Q)) {
                  let ae = V.from + Q.from, ge = V.to + Q.from;
                  if (ae >= Ee)
                    break;
                  ge > ke && te(Math.max(ae, ke), R == null && ae <= ne, Math.min(ge, Ee), L == null && ge >= ue, V.dir);
                }
                if (ke = Q.to + 1, ke >= Ee)
                  break;
              }
          return Y.length == 0 && te(ne, R == null, ue, L == null, t.textDirection), {
            top: F,
            bottom: K,
            horizontal: Y
          };
        }
        function P(R, L) {
          let D = a.top + (L ? R.top : R.bottom);
          return {
            top: D,
            bottom: D,
            horizontal: []
          };
        }
      }
      function EU(t, e) {
        return t.constructor == e.constructor && t.eq(e);
      }
      class PU {
        constructor(e, n) {
          this.view = e, this.layer = n, this.drawn = [], this.scaleX = 1, this.scaleY = 1, this.measureReq = {
            read: this.measure.bind(this),
            write: this.draw.bind(this)
          }, this.dom = e.scrollDOM.appendChild(document.createElement("div")), this.dom.classList.add("cm-layer"), n.above && this.dom.classList.add("cm-layer-above"), n.class && this.dom.classList.add(n.class), this.scale(), this.dom.setAttribute("aria-hidden", "true"), this.setOrder(e.state), e.requestMeasure(this.measureReq), n.mount && n.mount(this.dom, e);
        }
        update(e) {
          e.startState.facet(kd) != e.state.facet(kd) && this.setOrder(e.state), (this.layer.update(e, this.dom) || e.geometryChanged) && (this.scale(), e.view.requestMeasure(this.measureReq));
        }
        docViewUpdate(e) {
          this.layer.updateOnDocViewUpdate !== false && e.requestMeasure(this.measureReq);
        }
        setOrder(e) {
          let n = 0, r = e.facet(kd);
          for (; n < r.length && r[n] != this.layer; )
            n++;
          this.dom.style.zIndex = String((this.layer.above ? 150 : -1) - n);
        }
        measure() {
          return this.layer.markers(this.view);
        }
        scale() {
          let { scaleX: e, scaleY: n } = this.view;
          (e != this.scaleX || n != this.scaleY) && (this.scaleX = e, this.scaleY = n, this.dom.style.transform = `scale(${1 / e}, ${1 / n})`);
        }
        draw(e) {
          if (e.length != this.drawn.length || e.some((n, r) => !EU(n, this.drawn[r]))) {
            let n = this.dom.firstChild, r = 0;
            for (let i of e)
              i.update && n && i.constructor && this.drawn[r].constructor && i.update(n, this.drawn[r]) ? (n = n.nextSibling, r++) : this.dom.insertBefore(i.draw(), n);
            for (; n; ) {
              let i = n.nextSibling;
              n.remove(), n = i;
            }
            this.drawn = e;
          }
        }
        destroy() {
          this.layer.destroy && this.layer.destroy(this.dom, this.view), this.dom.remove();
        }
      }
      const kd = pe.define();
      function xR(t) {
        return [
          Ct.define((e) => new PU(e, t)),
          kd.of(t)
        ];
      }
      const gl = pe.define({
        combine(t) {
          return Ei(t, {
            cursorBlinkRate: 1200,
            drawRangeCursor: true
          }, {
            cursorBlinkRate: (e, n) => Math.min(e, n),
            drawRangeCursor: (e, n) => e || n
          });
        }
      });
      function OU(t = {}) {
        return [
          gl.of(t),
          LU,
          DU,
          _U,
          YO.of(true)
        ];
      }
      function RU(t) {
        return t.facet(gl);
      }
      function SR(t) {
        return t.startState.facet(gl) != t.state.facet(gl);
      }
      const LU = xR({
        above: true,
        markers(t) {
          let { state: e } = t, n = e.facet(gl), r = [];
          for (let i of e.selection.ranges) {
            let o = i == e.selection.main;
            if (i.empty || n.drawRangeCursor) {
              let s = o ? "cm-cursor cm-cursor-primary" : "cm-cursor cm-cursor-secondary", a = i.empty ? i : q.cursor(i.head, i.head > i.anchor ? -1 : 1);
              for (let l of af.forRange(t, s, a))
                r.push(l);
            }
          }
          return r;
        },
        update(t, e) {
          t.transactions.some((r) => r.selection) && (e.style.animationName = e.style.animationName == "cm-blink" ? "cm-blink2" : "cm-blink");
          let n = SR(t);
          return n && tT(t.state, e), t.docChanged || t.selectionSet || n;
        },
        mount(t, e) {
          tT(e.state, t);
        },
        class: "cm-cursorLayer"
      });
      function tT(t, e) {
        e.style.animationDuration = t.facet(gl).cursorBlinkRate + "ms";
      }
      const DU = xR({
        above: false,
        markers(t) {
          return t.state.selection.ranges.map((e) => e.empty ? [] : af.forRange(t, "cm-selectionBackground", e)).reduce((e, n) => e.concat(n));
        },
        update(t, e) {
          return t.docChanged || t.selectionSet || t.viewportChanged || SR(t);
        },
        class: "cm-selectionLayer"
      }), _U = ns.highest(ce.theme({
        ".cm-line": {
          "& ::selection, &::selection": {
            backgroundColor: "transparent !important"
          },
          caretColor: "transparent !important"
        },
        ".cm-content": {
          caretColor: "transparent !important",
          "& :focus": {
            caretColor: "initial !important",
            "&::selection, & ::selection": {
              backgroundColor: "Highlight !important"
            }
          }
        }
      })), wR = Pe.define({
        map(t, e) {
          return t == null ? null : e.mapPos(t);
        }
      }), wc = Ut.define({
        create() {
          return null;
        },
        update(t, e) {
          return t != null && (t = e.changes.mapPos(t)), e.effects.reduce((n, r) => r.is(wR) ? r.value : n, t);
        }
      }), IU = Ct.fromClass(class {
        constructor(t) {
          this.view = t, this.cursor = null, this.measureReq = {
            read: this.readPos.bind(this),
            write: this.drawCursor.bind(this)
          };
        }
        update(t) {
          var e;
          let n = t.state.field(wc);
          n == null ? this.cursor != null && ((e = this.cursor) === null || e === void 0 || e.remove(), this.cursor = null) : (this.cursor || (this.cursor = this.view.scrollDOM.appendChild(document.createElement("div")), this.cursor.className = "cm-dropCursor"), (t.startState.field(wc) != n || t.docChanged || t.geometryChanged) && this.view.requestMeasure(this.measureReq));
        }
        readPos() {
          let { view: t } = this, e = t.state.field(wc), n = e != null && t.coordsAtPos(e);
          if (!n)
            return null;
          let r = t.scrollDOM.getBoundingClientRect();
          return {
            left: n.left - r.left + t.scrollDOM.scrollLeft * t.scaleX,
            top: n.top - r.top + t.scrollDOM.scrollTop * t.scaleY,
            height: n.bottom - n.top
          };
        }
        drawCursor(t) {
          if (this.cursor) {
            let { scaleX: e, scaleY: n } = this.view;
            t ? (this.cursor.style.left = t.left / e + "px", this.cursor.style.top = t.top / n + "px", this.cursor.style.height = t.height / n + "px") : this.cursor.style.left = "-100000px";
          }
        }
        destroy() {
          this.cursor && this.cursor.remove();
        }
        setDropPos(t) {
          this.view.state.field(wc) != t && this.view.dispatch({
            effects: wR.of(t)
          });
        }
      }, {
        eventObservers: {
          dragover(t) {
            this.setDropPos(this.view.posAtCoords({
              x: t.clientX,
              y: t.clientY
            }));
          },
          dragleave(t) {
            (t.target == this.view.contentDOM || !this.view.contentDOM.contains(t.relatedTarget)) && this.setDropPos(null);
          },
          dragend() {
            this.setDropPos(null);
          },
          drop() {
            this.setDropPos(null);
          }
        }
      });
      function BU() {
        return [
          wc,
          IU
        ];
      }
      function nT(t, e, n, r, i) {
        e.lastIndex = 0;
        for (let o = t.iterRange(n, r), s = n, a; !o.next().done; s += o.value.length)
          if (!o.lineBreak)
            for (; a = e.exec(o.value); )
              i(s + a.index, a);
      }
      function NU(t, e) {
        let n = t.visibleRanges;
        if (n.length == 1 && n[0].from == t.viewport.from && n[0].to == t.viewport.to)
          return n;
        let r = [];
        for (let { from: i, to: o } of n)
          i = Math.max(t.state.doc.lineAt(i).from, i - e), o = Math.min(t.state.doc.lineAt(o).to, o + e), r.length && r[r.length - 1].to >= i ? r[r.length - 1].to = o : r.push({
            from: i,
            to: o
          });
        return r;
      }
      class $U {
        constructor(e) {
          const { regexp: n, decoration: r, decorate: i, boundary: o, maxLength: s = 1e3 } = e;
          if (!n.global)
            throw new RangeError("The regular expression given to MatchDecorator should have its 'g' flag set");
          if (this.regexp = n, i)
            this.addMatch = (a, l, c, u) => i(u, c, c + a[0].length, a, l);
          else if (typeof r == "function")
            this.addMatch = (a, l, c, u) => {
              let h = r(a, l, c);
              h && u(c, c + a[0].length, h);
            };
          else if (r)
            this.addMatch = (a, l, c, u) => u(c, c + a[0].length, r);
          else
            throw new RangeError("Either 'decorate' or 'decoration' should be provided to MatchDecorator");
          this.boundary = o, this.maxLength = s;
        }
        createDeco(e) {
          let n = new Ci(), r = n.add.bind(n);
          for (let { from: i, to: o } of NU(e, this.maxLength))
            nT(e.state.doc, this.regexp, i, o, (s, a) => this.addMatch(a, e, s, r));
          return n.finish();
        }
        updateDeco(e, n) {
          let r = 1e9, i = -1;
          return e.docChanged && e.changes.iterChanges((o, s, a, l) => {
            l >= e.view.viewport.from && a <= e.view.viewport.to && (r = Math.min(a, r), i = Math.max(l, i));
          }), e.viewportMoved || i - r > 1e3 ? this.createDeco(e.view) : i > -1 ? this.updateRange(e.view, n.map(e.changes), r, i) : n;
        }
        updateRange(e, n, r, i) {
          for (let o of e.visibleRanges) {
            let s = Math.max(o.from, r), a = Math.min(o.to, i);
            if (a > s) {
              let l = e.state.doc.lineAt(s), c = l.to < a ? e.state.doc.lineAt(a) : l, u = Math.max(o.from, l.from), h = Math.min(o.to, c.to);
              if (this.boundary) {
                for (; s > l.from; s--)
                  if (this.boundary.test(l.text[s - 1 - l.from])) {
                    u = s;
                    break;
                  }
                for (; a < c.to; a++)
                  if (this.boundary.test(c.text[a - c.from])) {
                    h = a;
                    break;
                  }
              }
              let p = [], v, y = (S, C, w) => p.push(w.range(S, C));
              if (l == c)
                for (this.regexp.lastIndex = u - l.from; (v = this.regexp.exec(l.text)) && v.index < h - l.from; )
                  this.addMatch(v, e, v.index + l.from, y);
              else
                nT(e.state.doc, this.regexp, u, h, (S, C) => this.addMatch(C, e, S, y));
              n = n.update({
                filterFrom: u,
                filterTo: h,
                filter: (S, C) => S < u || C > h,
                add: p
              });
            }
          }
          return n;
        }
      }
      const u1 = /x/.unicode != null ? "gu" : "g", zU = new RegExp(`[\0-\b
-\x7F-\x9F\xAD\u061C\u200B\u200E\u200F\u2028\u2029\u202D\u202E\u2066\u2067\u2069\uFEFF\uFFF9-\uFFFC]`, u1), FU = {
        0: "null",
        7: "bell",
        8: "backspace",
        10: "newline",
        11: "vertical tab",
        13: "carriage return",
        27: "escape",
        8203: "zero width space",
        8204: "zero width non-joiner",
        8205: "zero width joiner",
        8206: "left-to-right mark",
        8207: "right-to-left mark",
        8232: "line separator",
        8237: "left-to-right override",
        8238: "right-to-left override",
        8294: "left-to-right isolate",
        8295: "right-to-left isolate",
        8297: "pop directional isolate",
        8233: "paragraph separator",
        65279: "zero width no-break space",
        65532: "object replacement"
      };
      let z0 = null;
      function VU() {
        var t;
        if (z0 == null && typeof document < "u" && document.body) {
          let e = document.body.style;
          z0 = ((t = e.tabSize) !== null && t !== void 0 ? t : e.MozTabSize) != null;
        }
        return z0 || false;
      }
      const Cd = pe.define({
        combine(t) {
          let e = Ei(t, {
            render: null,
            specialChars: zU,
            addSpecialChars: null
          });
          return (e.replaceTabs = !VU()) && (e.specialChars = new RegExp("	|" + e.specialChars.source, u1)), e.addSpecialChars && (e.specialChars = new RegExp(e.specialChars.source + "|" + e.addSpecialChars.source, u1)), e;
        }
      });
      function HU(t = {}) {
        return [
          Cd.of(t),
          jU()
        ];
      }
      let rT = null;
      function jU() {
        return rT || (rT = Ct.fromClass(class {
          constructor(t) {
            this.view = t, this.decorations = be.none, this.decorationCache = /* @__PURE__ */ Object.create(null), this.decorator = this.makeDecorator(t.state.facet(Cd)), this.decorations = this.decorator.createDeco(t);
          }
          makeDecorator(t) {
            return new $U({
              regexp: t.specialChars,
              decoration: (e, n, r) => {
                let { doc: i } = n.state, o = Rn(e[0], 0);
                if (o == 9) {
                  let s = i.lineAt(r), a = n.state.tabSize, l = Al(s.text, a, r - s.from);
                  return be.replace({
                    widget: new qU((a - l % a) * this.view.defaultCharacterWidth / this.view.scaleX)
                  });
                }
                return this.decorationCache[o] || (this.decorationCache[o] = be.replace({
                  widget: new KU(t, o)
                }));
              },
              boundary: t.replaceTabs ? void 0 : /[^]/
            });
          }
          update(t) {
            let e = t.state.facet(Cd);
            t.startState.facet(Cd) != e ? (this.decorator = this.makeDecorator(e), this.decorations = this.decorator.createDeco(t.view)) : this.decorations = this.decorator.updateDeco(t, this.decorations);
          }
        }, {
          decorations: (t) => t.decorations
        }));
      }
      const WU = "\u2022";
      function UU(t) {
        return t >= 32 ? WU : t == 10 ? "\u2424" : String.fromCharCode(9216 + t);
      }
      class KU extends oo {
        constructor(e, n) {
          super(), this.options = e, this.code = n;
        }
        eq(e) {
          return e.code == this.code;
        }
        toDOM(e) {
          let n = UU(this.code), r = e.state.phrase("Control character") + " " + (FU[this.code] || "0x" + this.code.toString(16)), i = this.options.render && this.options.render(this.code, r, n);
          if (i)
            return i;
          let o = document.createElement("span");
          return o.textContent = n, o.title = r, o.setAttribute("aria-label", r), o.className = "cm-specialChar", o;
        }
        ignoreEvent() {
          return false;
        }
      }
      class qU extends oo {
        constructor(e) {
          super(), this.width = e;
        }
        eq(e) {
          return e.width == this.width;
        }
        toDOM() {
          let e = document.createElement("span");
          return e.textContent = "	", e.className = "cm-tab", e.style.width = this.width + "px", e;
        }
        ignoreEvent() {
          return false;
        }
      }
      function GU() {
        return XU;
      }
      const YU = be.line({
        class: "cm-activeLine"
      }), XU = Ct.fromClass(class {
        constructor(t) {
          this.decorations = this.getDeco(t);
        }
        update(t) {
          (t.docChanged || t.selectionSet) && (this.decorations = this.getDeco(t.view));
        }
        getDeco(t) {
          let e = -1, n = [];
          for (let r of t.state.selection.ranges) {
            let i = t.lineBlockAt(r.head);
            i.from > e && (n.push(YU.range(i.from)), e = i.from);
          }
          return be.set(n);
        }
      }, {
        decorations: (t) => t.decorations
      });
      class QU extends oo {
        constructor(e) {
          super(), this.content = e;
        }
        toDOM(e) {
          let n = document.createElement("span");
          return n.className = "cm-placeholder", n.style.pointerEvents = "none", n.appendChild(typeof this.content == "string" ? document.createTextNode(this.content) : typeof this.content == "function" ? this.content(e) : this.content.cloneNode(true)), typeof this.content == "string" ? n.setAttribute("aria-label", "placeholder " + this.content) : n.setAttribute("aria-hidden", "true"), n;
        }
        coordsAt(e) {
          let n = e.firstChild ? hl(e.firstChild) : [];
          if (!n.length)
            return null;
          let r = window.getComputedStyle(e.parentNode), i = rf(n[0], r.direction != "rtl"), o = parseInt(r.lineHeight);
          return i.bottom - i.top > o * 1.5 ? {
            left: i.left,
            right: i.right,
            top: i.top,
            bottom: i.top + o
          } : i;
        }
        ignoreEvent() {
          return false;
        }
      }
      function JU(t) {
        return Ct.fromClass(class {
          constructor(e) {
            this.view = e, this.placeholder = t ? be.set([
              be.widget({
                widget: new QU(t),
                side: 1
              }).range(0)
            ]) : be.none;
          }
          get decorations() {
            return this.view.state.doc.length ? be.none : this.placeholder;
          }
        }, {
          decorations: (e) => e.decorations
        });
      }
      const f1 = 2e3;
      function ZU(t, e, n) {
        let r = Math.min(e.line, n.line), i = Math.max(e.line, n.line), o = [];
        if (e.off > f1 || n.off > f1 || e.col < 0 || n.col < 0) {
          let s = Math.min(e.off, n.off), a = Math.max(e.off, n.off);
          for (let l = r; l <= i; l++) {
            let c = t.doc.line(l);
            c.length <= a && o.push(q.range(c.from + s, c.to + a));
          }
        } else {
          let s = Math.min(e.col, n.col), a = Math.max(e.col, n.col);
          for (let l = r; l <= i; l++) {
            let c = t.doc.line(l), u = jy(c.text, s, t.tabSize, true);
            if (u < 0)
              o.push(q.cursor(c.to));
            else {
              let h = jy(c.text, a, t.tabSize);
              o.push(q.range(c.from + u, c.from + h));
            }
          }
        }
        return o;
      }
      function eK(t, e) {
        let n = t.coordsAtPos(t.viewport.from);
        return n ? Math.round(Math.abs((n.left - e) / t.defaultCharacterWidth)) : -1;
      }
      function iT(t, e) {
        let n = t.posAtCoords({
          x: e.clientX,
          y: e.clientY
        }, false), r = t.state.doc.lineAt(n), i = n - r.from, o = i > f1 ? -1 : i == r.length ? eK(t, e.clientX) : Al(r.text, t.state.tabSize, n - r.from);
        return {
          line: r.number,
          col: o,
          off: i
        };
      }
      function tK(t, e) {
        let n = iT(t, e), r = t.state.selection;
        return n ? {
          update(i) {
            if (i.docChanged) {
              let o = i.changes.mapPos(i.startState.doc.line(n.line).from), s = i.state.doc.lineAt(o);
              n = {
                line: s.number,
                col: n.col,
                off: Math.min(n.off, s.length)
              }, r = r.map(i.changes);
            }
          },
          get(i, o, s) {
            let a = iT(t, i);
            if (!a)
              return r;
            let l = ZU(t.state, n, a);
            return l.length ? s ? q.create(l.concat(r.ranges)) : q.create(l) : r;
          }
        } : null;
      }
      function nK(t) {
        let e = (t == null ? void 0 : t.eventFilter) || ((n) => n.altKey && n.button == 0);
        return ce.mouseSelectionStyle.of((n, r) => e(r) ? tK(n, r) : null);
      }
      const rK = {
        Alt: [
          18,
          (t) => !!t.altKey
        ],
        Control: [
          17,
          (t) => !!t.ctrlKey
        ],
        Shift: [
          16,
          (t) => !!t.shiftKey
        ],
        Meta: [
          91,
          (t) => !!t.metaKey
        ]
      }, iK = {
        style: "cursor: crosshair"
      };
      function oK(t = {}) {
        let [e, n] = rK[t.key || "Alt"], r = Ct.fromClass(class {
          constructor(i) {
            this.view = i, this.isDown = false;
          }
          set(i) {
            this.isDown != i && (this.isDown = i, this.view.update([]));
          }
        }, {
          eventObservers: {
            keydown(i) {
              this.set(i.keyCode == e || n(i));
            },
            keyup(i) {
              (i.keyCode == e || !n(i)) && this.set(false);
            },
            mousemove(i) {
              this.set(n(i));
            }
          }
        });
        return [
          r,
          ce.contentAttributes.of((i) => {
            var o;
            return !((o = i.plugin(r)) === null || o === void 0) && o.isDown ? iK : null;
          })
        ];
      }
      const oc = "-10000px";
      class kR {
        constructor(e, n, r, i) {
          this.facet = n, this.createTooltipView = r, this.removeTooltipView = i, this.input = e.state.facet(n), this.tooltips = this.input.filter((s) => s);
          let o = null;
          this.tooltipViews = this.tooltips.map((s) => o = r(s, o));
        }
        update(e, n) {
          var r;
          let i = e.state.facet(this.facet), o = i.filter((l) => l);
          if (i === this.input) {
            for (let l of this.tooltipViews)
              l.update && l.update(e);
            return false;
          }
          let s = [], a = n ? [] : null;
          for (let l = 0; l < o.length; l++) {
            let c = o[l], u = -1;
            if (!!c) {
              for (let h = 0; h < this.tooltips.length; h++) {
                let p = this.tooltips[h];
                p && p.create == c.create && (u = h);
              }
              if (u < 0)
                s[l] = this.createTooltipView(c, l ? s[l - 1] : null), a && (a[l] = !!c.above);
              else {
                let h = s[l] = this.tooltipViews[u];
                a && (a[l] = n[u]), h.update && h.update(e);
              }
            }
          }
          for (let l of this.tooltipViews)
            s.indexOf(l) < 0 && (this.removeTooltipView(l), (r = l.destroy) === null || r === void 0 || r.call(l));
          return n && (a.forEach((l, c) => n[c] = l), n.length = a.length), this.input = i, this.tooltips = o, this.tooltipViews = s, true;
        }
      }
      function sK(t) {
        let e = t.dom.ownerDocument.documentElement;
        return {
          top: 0,
          left: 0,
          bottom: e.clientHeight,
          right: e.clientWidth
        };
      }
      const F0 = pe.define({
        combine: (t) => {
          var e, n, r;
          return {
            position: de.ios ? "absolute" : ((e = t.find((i) => i.position)) === null || e === void 0 ? void 0 : e.position) || "fixed",
            parent: ((n = t.find((i) => i.parent)) === null || n === void 0 ? void 0 : n.parent) || null,
            tooltipSpace: ((r = t.find((i) => i.tooltipSpace)) === null || r === void 0 ? void 0 : r.tooltipSpace) || sK
          };
        }
      }), oT = /* @__PURE__ */ new WeakMap(), Ix = Ct.fromClass(class {
        constructor(t) {
          this.view = t, this.above = [], this.inView = true, this.madeAbsolute = false, this.lastTransaction = 0, this.measureTimeout = -1;
          let e = t.state.facet(F0);
          this.position = e.position, this.parent = e.parent, this.classes = t.themeClasses, this.createContainer(), this.measureReq = {
            read: this.readMeasure.bind(this),
            write: this.writeMeasure.bind(this),
            key: this
          }, this.resizeObserver = typeof ResizeObserver == "function" ? new ResizeObserver(() => this.measureSoon()) : null, this.manager = new kR(t, Bx, (n, r) => this.createTooltip(n, r), (n) => {
            this.resizeObserver && this.resizeObserver.unobserve(n.dom), n.dom.remove();
          }), this.above = this.manager.tooltips.map((n) => !!n.above), this.intersectionObserver = typeof IntersectionObserver == "function" ? new IntersectionObserver((n) => {
            Date.now() > this.lastTransaction - 50 && n.length > 0 && n[n.length - 1].intersectionRatio < 1 && this.measureSoon();
          }, {
            threshold: [
              1
            ]
          }) : null, this.observeIntersection(), t.win.addEventListener("resize", this.measureSoon = this.measureSoon.bind(this)), this.maybeMeasure();
        }
        createContainer() {
          this.parent ? (this.container = document.createElement("div"), this.container.style.position = "relative", this.container.className = this.view.themeClasses, this.parent.appendChild(this.container)) : this.container = this.view.dom;
        }
        observeIntersection() {
          if (this.intersectionObserver) {
            this.intersectionObserver.disconnect();
            for (let t of this.manager.tooltipViews)
              this.intersectionObserver.observe(t.dom);
          }
        }
        measureSoon() {
          this.measureTimeout < 0 && (this.measureTimeout = setTimeout(() => {
            this.measureTimeout = -1, this.maybeMeasure();
          }, 50));
        }
        update(t) {
          t.transactions.length && (this.lastTransaction = Date.now());
          let e = this.manager.update(t, this.above);
          e && this.observeIntersection();
          let n = e || t.geometryChanged, r = t.state.facet(F0);
          if (r.position != this.position && !this.madeAbsolute) {
            this.position = r.position;
            for (let i of this.manager.tooltipViews)
              i.dom.style.position = this.position;
            n = true;
          }
          if (r.parent != this.parent) {
            this.parent && this.container.remove(), this.parent = r.parent, this.createContainer();
            for (let i of this.manager.tooltipViews)
              this.container.appendChild(i.dom);
            n = true;
          } else
            this.parent && this.view.themeClasses != this.classes && (this.classes = this.container.className = this.view.themeClasses);
          n && this.maybeMeasure();
        }
        createTooltip(t, e) {
          let n = t.create(this.view), r = e ? e.dom : null;
          if (n.dom.classList.add("cm-tooltip"), t.arrow && !n.dom.querySelector(".cm-tooltip > .cm-tooltip-arrow")) {
            let i = document.createElement("div");
            i.className = "cm-tooltip-arrow", n.dom.appendChild(i);
          }
          return n.dom.style.position = this.position, n.dom.style.top = oc, n.dom.style.left = "0px", this.container.insertBefore(n.dom, r), n.mount && n.mount(this.view), this.resizeObserver && this.resizeObserver.observe(n.dom), n;
        }
        destroy() {
          var t, e, n;
          this.view.win.removeEventListener("resize", this.measureSoon);
          for (let r of this.manager.tooltipViews)
            r.dom.remove(), (t = r.destroy) === null || t === void 0 || t.call(r);
          this.parent && this.container.remove(), (e = this.resizeObserver) === null || e === void 0 || e.disconnect(), (n = this.intersectionObserver) === null || n === void 0 || n.disconnect(), clearTimeout(this.measureTimeout);
        }
        readMeasure() {
          let t = 1, e = 1, n = false;
          if (this.position == "fixed" && this.manager.tooltipViews.length) {
            let { dom: o } = this.manager.tooltipViews[0];
            if (de.gecko)
              n = o.offsetParent != this.container.ownerDocument.body;
            else if (o.style.top == oc && o.style.left == "0px") {
              let s = o.getBoundingClientRect();
              n = Math.abs(s.top + 1e4) > 1 || Math.abs(s.left) > 1;
            }
          }
          if (n || this.position == "absolute")
            if (this.parent) {
              let o = this.parent.getBoundingClientRect();
              o.width && o.height && (t = o.width / this.parent.offsetWidth, e = o.height / this.parent.offsetHeight);
            } else
              ({ scaleX: t, scaleY: e } = this.view.viewState);
          let r = this.view.scrollDOM.getBoundingClientRect(), i = Rx(this.view);
          return {
            visible: {
              left: r.left + i.left,
              top: r.top + i.top,
              right: r.right - i.right,
              bottom: r.bottom - i.bottom
            },
            parent: this.parent ? this.container.getBoundingClientRect() : this.view.dom.getBoundingClientRect(),
            pos: this.manager.tooltips.map((o, s) => {
              let a = this.manager.tooltipViews[s];
              return a.getCoords ? a.getCoords(o.pos) : this.view.coordsAtPos(o.pos);
            }),
            size: this.manager.tooltipViews.map(({ dom: o }) => o.getBoundingClientRect()),
            space: this.view.state.facet(F0).tooltipSpace(this.view),
            scaleX: t,
            scaleY: e,
            makeAbsolute: n
          };
        }
        writeMeasure(t) {
          var e;
          if (t.makeAbsolute) {
            this.madeAbsolute = true, this.position = "absolute";
            for (let a of this.manager.tooltipViews)
              a.dom.style.position = "absolute";
          }
          let { visible: n, space: r, scaleX: i, scaleY: o } = t, s = [];
          for (let a = 0; a < this.manager.tooltips.length; a++) {
            let l = this.manager.tooltips[a], c = this.manager.tooltipViews[a], { dom: u } = c, h = t.pos[a], p = t.size[a];
            if (!h || l.clip !== false && (h.bottom <= Math.max(n.top, r.top) || h.top >= Math.min(n.bottom, r.bottom) || h.right < Math.max(n.left, r.left) - 0.1 || h.left > Math.min(n.right, r.right) + 0.1)) {
              u.style.top = oc;
              continue;
            }
            let v = l.arrow ? c.dom.querySelector(".cm-tooltip-arrow") : null, y = v ? 7 : 0, S = p.right - p.left, C = (e = oT.get(c)) !== null && e !== void 0 ? e : p.bottom - p.top, w = c.offset || lK, k = this.view.textDirection == rt.LTR, T = p.width > r.right - r.left ? k ? r.left : r.right - p.width : k ? Math.max(r.left, Math.min(h.left - (v ? 14 : 0) + w.x, r.right - S)) : Math.min(Math.max(r.left, h.left - S + (v ? 14 : 0) - w.x), r.right - S), P = this.above[a];
            !l.strictSide && (P ? h.top - C - y - w.y < r.top : h.bottom + C + y + w.y > r.bottom) && P == r.bottom - h.bottom > h.top - r.top && (P = this.above[a] = !P);
            let R = (P ? h.top - r.top : r.bottom - h.bottom) - y;
            if (R < C && c.resize !== false) {
              if (R < this.view.defaultLineHeight) {
                u.style.top = oc;
                continue;
              }
              oT.set(c, C), u.style.height = (C = R) / o + "px";
            } else
              u.style.height && (u.style.height = "");
            let L = P ? h.top - C - y - w.y : h.bottom + y + w.y, D = T + S;
            if (c.overlap !== true)
              for (let F of s)
                F.left < D && F.right > T && F.top < L + C && F.bottom > L && (L = P ? F.top - C - 2 - y : F.bottom + y + 2);
            if (this.position == "absolute" ? (u.style.top = (L - t.parent.top) / o + "px", sT(u, (T - t.parent.left) / i)) : (u.style.top = L / o + "px", sT(u, T / i)), v) {
              let F = h.left + (k ? w.x : -w.x) - (T + 14 - 7);
              v.style.left = F / i + "px";
            }
            c.overlap !== true && s.push({
              left: T,
              top: L,
              right: D,
              bottom: L + C
            }), u.classList.toggle("cm-tooltip-above", P), u.classList.toggle("cm-tooltip-below", !P), c.positioned && c.positioned(t.space);
          }
        }
        maybeMeasure() {
          if (this.manager.tooltips.length && (this.view.inView && this.view.requestMeasure(this.measureReq), this.inView != this.view.inView && (this.inView = this.view.inView, !this.inView)))
            for (let t of this.manager.tooltipViews)
              t.dom.style.top = oc;
        }
      }, {
        eventObservers: {
          scroll() {
            this.maybeMeasure();
          }
        }
      });
      function sT(t, e) {
        let n = parseInt(t.style.left, 10);
        (isNaN(n) || Math.abs(e - n) > 1) && (t.style.left = e + "px");
      }
      const aK = ce.baseTheme({
        ".cm-tooltip": {
          zIndex: 500,
          boxSizing: "border-box"
        },
        "&light .cm-tooltip": {
          border: "1px solid #bbb",
          backgroundColor: "#f5f5f5"
        },
        "&light .cm-tooltip-section:not(:first-child)": {
          borderTop: "1px solid #bbb"
        },
        "&dark .cm-tooltip": {
          backgroundColor: "#333338",
          color: "white"
        },
        ".cm-tooltip-arrow": {
          height: `${7}px`,
          width: `${7 * 2}px`,
          position: "absolute",
          zIndex: -1,
          overflow: "hidden",
          "&:before, &:after": {
            content: "''",
            position: "absolute",
            width: 0,
            height: 0,
            borderLeft: `${7}px solid transparent`,
            borderRight: `${7}px solid transparent`
          },
          ".cm-tooltip-above &": {
            bottom: `-${7}px`,
            "&:before": {
              borderTop: `${7}px solid #bbb`
            },
            "&:after": {
              borderTop: `${7}px solid #f5f5f5`,
              bottom: "1px"
            }
          },
          ".cm-tooltip-below &": {
            top: `-${7}px`,
            "&:before": {
              borderBottom: `${7}px solid #bbb`
            },
            "&:after": {
              borderBottom: `${7}px solid #f5f5f5`,
              top: "1px"
            }
          }
        },
        "&dark .cm-tooltip .cm-tooltip-arrow": {
          "&:before": {
            borderTopColor: "#333338",
            borderBottomColor: "#333338"
          },
          "&:after": {
            borderTopColor: "transparent",
            borderBottomColor: "transparent"
          }
        }
      }), lK = {
        x: 0,
        y: 0
      }, Bx = pe.define({
        enables: [
          Ix,
          aK
        ]
      }), Cp = pe.define({
        combine: (t) => t.reduce((e, n) => e.concat(n), [])
      });
      class jm {
        static create(e) {
          return new jm(e);
        }
        constructor(e) {
          this.view = e, this.mounted = false, this.dom = document.createElement("div"), this.dom.classList.add("cm-tooltip-hover"), this.manager = new kR(e, Cp, (n, r) => this.createHostedView(n, r), (n) => n.dom.remove());
        }
        createHostedView(e, n) {
          let r = e.create(this.view);
          return r.dom.classList.add("cm-tooltip-section"), this.dom.insertBefore(r.dom, n ? n.dom.nextSibling : this.dom.firstChild), this.mounted && r.mount && r.mount(this.view), r;
        }
        mount(e) {
          for (let n of this.manager.tooltipViews)
            n.mount && n.mount(e);
          this.mounted = true;
        }
        positioned(e) {
          for (let n of this.manager.tooltipViews)
            n.positioned && n.positioned(e);
        }
        update(e) {
          this.manager.update(e);
        }
        destroy() {
          var e;
          for (let n of this.manager.tooltipViews)
            (e = n.destroy) === null || e === void 0 || e.call(n);
        }
        passProp(e) {
          let n;
          for (let r of this.manager.tooltipViews) {
            let i = r[e];
            if (i !== void 0) {
              if (n === void 0)
                n = i;
              else if (n !== i)
                return;
            }
          }
          return n;
        }
        get offset() {
          return this.passProp("offset");
        }
        get getCoords() {
          return this.passProp("getCoords");
        }
        get overlap() {
          return this.passProp("overlap");
        }
        get resize() {
          return this.passProp("resize");
        }
      }
      const cK = Bx.compute([
        Cp
      ], (t) => {
        let e = t.facet(Cp);
        return e.length === 0 ? null : {
          pos: Math.min(...e.map((n) => n.pos)),
          end: Math.max(...e.map((n) => {
            var r;
            return (r = n.end) !== null && r !== void 0 ? r : n.pos;
          })),
          create: jm.create,
          above: e[0].above,
          arrow: e.some((n) => n.arrow)
        };
      });
      class uK {
        constructor(e, n, r, i, o) {
          this.view = e, this.source = n, this.field = r, this.setHover = i, this.hoverTime = o, this.hoverTimeout = -1, this.restartTimeout = -1, this.pending = null, this.lastMove = {
            x: 0,
            y: 0,
            target: e.dom,
            time: 0
          }, this.checkHover = this.checkHover.bind(this), e.dom.addEventListener("mouseleave", this.mouseleave = this.mouseleave.bind(this)), e.dom.addEventListener("mousemove", this.mousemove = this.mousemove.bind(this));
        }
        update() {
          this.pending && (this.pending = null, clearTimeout(this.restartTimeout), this.restartTimeout = setTimeout(() => this.startHover(), 20));
        }
        get active() {
          return this.view.state.field(this.field);
        }
        checkHover() {
          if (this.hoverTimeout = -1, this.active.length)
            return;
          let e = Date.now() - this.lastMove.time;
          e < this.hoverTime ? this.hoverTimeout = setTimeout(this.checkHover, this.hoverTime - e) : this.startHover();
        }
        startHover() {
          clearTimeout(this.restartTimeout);
          let { view: e, lastMove: n } = this, r = e.docView.nearest(n.target);
          if (!r)
            return;
          let i, o = 1;
          if (r instanceof Do)
            i = r.posAtStart;
          else {
            if (i = e.posAtCoords(n), i == null)
              return;
            let a = e.coordsAtPos(i);
            if (!a || n.y < a.top || n.y > a.bottom || n.x < a.left - e.defaultCharacterWidth || n.x > a.right + e.defaultCharacterWidth)
              return;
            let l = e.bidiSpans(e.state.doc.lineAt(i)).find((u) => u.from <= i && u.to >= i), c = l && l.dir == rt.RTL ? -1 : 1;
            o = n.x < a.left ? -c : c;
          }
          let s = this.source(e, i, o);
          if (s == null ? void 0 : s.then) {
            let a = this.pending = {
              pos: i
            };
            s.then((l) => {
              this.pending == a && (this.pending = null, l && !(Array.isArray(l) && !l.length) && e.dispatch({
                effects: this.setHover.of(Array.isArray(l) ? l : [
                  l
                ])
              }));
            }, (l) => Bn(e.state, l, "hover tooltip"));
          } else
            s && !(Array.isArray(s) && !s.length) && e.dispatch({
              effects: this.setHover.of(Array.isArray(s) ? s : [
                s
              ])
            });
        }
        get tooltip() {
          let e = this.view.plugin(Ix), n = e ? e.manager.tooltips.findIndex((r) => r.create == jm.create) : -1;
          return n > -1 ? e.manager.tooltipViews[n] : null;
        }
        mousemove(e) {
          var n, r;
          this.lastMove = {
            x: e.clientX,
            y: e.clientY,
            target: e.target,
            time: Date.now()
          }, this.hoverTimeout < 0 && (this.hoverTimeout = setTimeout(this.checkHover, this.hoverTime));
          let { active: i, tooltip: o } = this;
          if (i.length && o && !fK(o.dom, e) || this.pending) {
            let { pos: s } = i[0] || this.pending, a = (r = (n = i[0]) === null || n === void 0 ? void 0 : n.end) !== null && r !== void 0 ? r : s;
            (s == a ? this.view.posAtCoords(this.lastMove) != s : !hK(this.view, s, a, e.clientX, e.clientY)) && (this.view.dispatch({
              effects: this.setHover.of([])
            }), this.pending = null);
          }
        }
        mouseleave(e) {
          clearTimeout(this.hoverTimeout), this.hoverTimeout = -1;
          let { active: n } = this;
          if (n.length) {
            let { tooltip: r } = this;
            r && r.dom.contains(e.relatedTarget) ? this.watchTooltipLeave(r.dom) : this.view.dispatch({
              effects: this.setHover.of([])
            });
          }
        }
        watchTooltipLeave(e) {
          let n = (r) => {
            e.removeEventListener("mouseleave", n), this.active.length && !this.view.dom.contains(r.relatedTarget) && this.view.dispatch({
              effects: this.setHover.of([])
            });
          };
          e.addEventListener("mouseleave", n);
        }
        destroy() {
          clearTimeout(this.hoverTimeout), this.view.dom.removeEventListener("mouseleave", this.mouseleave), this.view.dom.removeEventListener("mousemove", this.mousemove);
        }
      }
      const Ph = 4;
      function fK(t, e) {
        let { left: n, right: r, top: i, bottom: o } = t.getBoundingClientRect(), s;
        if (s = t.querySelector(".cm-tooltip-arrow")) {
          let a = s.getBoundingClientRect();
          i = Math.min(a.top, i), o = Math.max(a.bottom, o);
        }
        return e.clientX >= n - Ph && e.clientX <= r + Ph && e.clientY >= i - Ph && e.clientY <= o + Ph;
      }
      function hK(t, e, n, r, i, o) {
        let s = t.scrollDOM.getBoundingClientRect(), a = t.documentTop + t.documentPadding.top + t.contentHeight;
        if (s.left > r || s.right < r || s.top > i || Math.min(s.bottom, a) < i)
          return false;
        let l = t.posAtCoords({
          x: r,
          y: i
        }, false);
        return l >= e && l <= n;
      }
      function dK(t, e = {}) {
        let n = Pe.define(), r = Ut.define({
          create() {
            return [];
          },
          update(i, o) {
            if (i.length && (e.hideOnChange && (o.docChanged || o.selection) ? i = [] : e.hideOn && (i = i.filter((s) => !e.hideOn(o, s))), o.docChanged)) {
              let s = [];
              for (let a of i) {
                let l = o.changes.mapPos(a.pos, -1, Zt.TrackDel);
                if (l != null) {
                  let c = Object.assign(/* @__PURE__ */ Object.create(null), a);
                  c.pos = l, c.end != null && (c.end = o.changes.mapPos(c.end)), s.push(c);
                }
              }
              i = s;
            }
            for (let s of o.effects)
              s.is(n) && (i = s.value), s.is(pK) && (i = []);
            return i;
          },
          provide: (i) => Cp.from(i)
        });
        return {
          active: r,
          extension: [
            r,
            Ct.define((i) => new uK(i, t, r, n, e.hoverTime || 300)),
            cK
          ]
        };
      }
      function CR(t, e) {
        let n = t.plugin(Ix);
        if (!n)
          return null;
        let r = n.manager.tooltips.indexOf(e);
        return r < 0 ? null : n.manager.tooltipViews[r];
      }
      const pK = Pe.define(), aT = pe.define({
        combine(t) {
          let e, n;
          for (let r of t)
            e = e || r.topContainer, n = n || r.bottomContainer;
          return {
            topContainer: e,
            bottomContainer: n
          };
        }
      });
      function Nu(t, e) {
        let n = t.plugin(TR), r = n ? n.specs.indexOf(e) : -1;
        return r > -1 ? n.panels[r] : null;
      }
      const TR = Ct.fromClass(class {
        constructor(t) {
          this.input = t.state.facet(Ks), this.specs = this.input.filter((n) => n), this.panels = this.specs.map((n) => n(t));
          let e = t.state.facet(aT);
          this.top = new Oh(t, true, e.topContainer), this.bottom = new Oh(t, false, e.bottomContainer), this.top.sync(this.panels.filter((n) => n.top)), this.bottom.sync(this.panels.filter((n) => !n.top));
          for (let n of this.panels)
            n.dom.classList.add("cm-panel"), n.mount && n.mount();
        }
        update(t) {
          let e = t.state.facet(aT);
          this.top.container != e.topContainer && (this.top.sync([]), this.top = new Oh(t.view, true, e.topContainer)), this.bottom.container != e.bottomContainer && (this.bottom.sync([]), this.bottom = new Oh(t.view, false, e.bottomContainer)), this.top.syncClasses(), this.bottom.syncClasses();
          let n = t.state.facet(Ks);
          if (n != this.input) {
            let r = n.filter((l) => l), i = [], o = [], s = [], a = [];
            for (let l of r) {
              let c = this.specs.indexOf(l), u;
              c < 0 ? (u = l(t.view), a.push(u)) : (u = this.panels[c], u.update && u.update(t)), i.push(u), (u.top ? o : s).push(u);
            }
            this.specs = r, this.panels = i, this.top.sync(o), this.bottom.sync(s);
            for (let l of a)
              l.dom.classList.add("cm-panel"), l.mount && l.mount();
          } else
            for (let r of this.panels)
              r.update && r.update(t);
        }
        destroy() {
          this.top.sync([]), this.bottom.sync([]);
        }
      }, {
        provide: (t) => ce.scrollMargins.of((e) => {
          let n = e.plugin(t);
          return n && {
            top: n.top.scrollMargin(),
            bottom: n.bottom.scrollMargin()
          };
        })
      });
      class Oh {
        constructor(e, n, r) {
          this.view = e, this.top = n, this.container = r, this.dom = void 0, this.classes = "", this.panels = [], this.syncClasses();
        }
        sync(e) {
          for (let n of this.panels)
            n.destroy && e.indexOf(n) < 0 && n.destroy();
          this.panels = e, this.syncDOM();
        }
        syncDOM() {
          if (this.panels.length == 0) {
            this.dom && (this.dom.remove(), this.dom = void 0);
            return;
          }
          if (!this.dom) {
            this.dom = document.createElement("div"), this.dom.className = this.top ? "cm-panels cm-panels-top" : "cm-panels cm-panels-bottom", this.dom.style[this.top ? "top" : "bottom"] = "0";
            let n = this.container || this.view.dom;
            n.insertBefore(this.dom, this.top ? n.firstChild : null);
          }
          let e = this.dom.firstChild;
          for (let n of this.panels)
            if (n.dom.parentNode == this.dom) {
              for (; e != n.dom; )
                e = lT(e);
              e = e.nextSibling;
            } else
              this.dom.insertBefore(n.dom, e);
          for (; e; )
            e = lT(e);
        }
        scrollMargin() {
          return !this.dom || this.container ? 0 : Math.max(0, this.top ? this.dom.getBoundingClientRect().bottom - Math.max(0, this.view.scrollDOM.getBoundingClientRect().top) : Math.min(innerHeight, this.view.scrollDOM.getBoundingClientRect().bottom) - this.dom.getBoundingClientRect().top);
        }
        syncClasses() {
          if (!(!this.container || this.classes == this.view.themeClasses)) {
            for (let e of this.classes.split(" "))
              e && this.container.classList.remove(e);
            for (let e of (this.classes = this.view.themeClasses).split(" "))
              e && this.container.classList.add(e);
          }
        }
      }
      function lT(t) {
        let e = t.nextSibling;
        return t.remove(), e;
      }
      const Ks = pe.define({
        enables: TR
      });
      class ro extends Hs {
        compare(e) {
          return this == e || this.constructor == e.constructor && this.eq(e);
        }
        eq(e) {
          return false;
        }
        destroy(e) {
        }
      }
      ro.prototype.elementClass = "";
      ro.prototype.toDOM = void 0;
      ro.prototype.mapMode = Zt.TrackBefore;
      ro.prototype.startSide = ro.prototype.endSide = -1;
      ro.prototype.point = true;
      const Td = pe.define(), mK = pe.define(), gK = {
        class: "",
        renderEmptyElements: false,
        elementStyle: "",
        markers: () => Ve.empty,
        lineMarker: () => null,
        widgetMarker: () => null,
        lineMarkerChange: null,
        initialSpacer: null,
        updateSpacer: null,
        domEventHandlers: {}
      }, Jc = pe.define();
      function vK(t) {
        return [
          MR(),
          Jc.of(Object.assign(Object.assign({}, gK), t))
        ];
      }
      const h1 = pe.define({
        combine: (t) => t.some((e) => e)
      });
      function MR(t) {
        let e = [
          yK
        ];
        return t && t.fixed === false && e.push(h1.of(true)), e;
      }
      const yK = Ct.fromClass(class {
        constructor(t) {
          this.view = t, this.prevViewport = t.viewport, this.dom = document.createElement("div"), this.dom.className = "cm-gutters", this.dom.setAttribute("aria-hidden", "true"), this.dom.style.minHeight = this.view.contentHeight / this.view.scaleY + "px", this.gutters = t.state.facet(Jc).map((e) => new uT(t, e));
          for (let e of this.gutters)
            this.dom.appendChild(e.dom);
          this.fixed = !t.state.facet(h1), this.fixed && (this.dom.style.position = "sticky"), this.syncGutters(false), t.scrollDOM.insertBefore(this.dom, t.contentDOM);
        }
        update(t) {
          if (this.updateGutters(t)) {
            let e = this.prevViewport, n = t.view.viewport, r = Math.min(e.to, n.to) - Math.max(e.from, n.from);
            this.syncGutters(r < (n.to - n.from) * 0.8);
          }
          t.geometryChanged && (this.dom.style.minHeight = this.view.contentHeight / this.view.scaleY + "px"), this.view.state.facet(h1) != !this.fixed && (this.fixed = !this.fixed, this.dom.style.position = this.fixed ? "sticky" : ""), this.prevViewport = t.view.viewport;
        }
        syncGutters(t) {
          let e = this.dom.nextSibling;
          t && this.dom.remove();
          let n = Ve.iter(this.view.state.facet(Td), this.view.viewport.from), r = [], i = this.gutters.map((o) => new bK(o, this.view.viewport, -this.view.documentPadding.top));
          for (let o of this.view.viewportLineBlocks)
            if (r.length && (r = []), Array.isArray(o.type)) {
              let s = true;
              for (let a of o.type)
                if (a.type == kn.Text && s) {
                  d1(n, r, a.from);
                  for (let l of i)
                    l.line(this.view, a, r);
                  s = false;
                } else if (a.widget)
                  for (let l of i)
                    l.widget(this.view, a);
            } else if (o.type == kn.Text) {
              d1(n, r, o.from);
              for (let s of i)
                s.line(this.view, o, r);
            } else if (o.widget)
              for (let s of i)
                s.widget(this.view, o);
          for (let o of i)
            o.finish();
          t && this.view.scrollDOM.insertBefore(this.dom, e);
        }
        updateGutters(t) {
          let e = t.startState.facet(Jc), n = t.state.facet(Jc), r = t.docChanged || t.heightChanged || t.viewportChanged || !Ve.eq(t.startState.facet(Td), t.state.facet(Td), t.view.viewport.from, t.view.viewport.to);
          if (e == n)
            for (let i of this.gutters)
              i.update(t) && (r = true);
          else {
            r = true;
            let i = [];
            for (let o of n) {
              let s = e.indexOf(o);
              s < 0 ? i.push(new uT(this.view, o)) : (this.gutters[s].update(t), i.push(this.gutters[s]));
            }
            for (let o of this.gutters)
              o.dom.remove(), i.indexOf(o) < 0 && o.destroy();
            for (let o of i)
              this.dom.appendChild(o.dom);
            this.gutters = i;
          }
          return r;
        }
        destroy() {
          for (let t of this.gutters)
            t.destroy();
          this.dom.remove();
        }
      }, {
        provide: (t) => ce.scrollMargins.of((e) => {
          let n = e.plugin(t);
          return !n || n.gutters.length == 0 || !n.fixed ? null : e.textDirection == rt.LTR ? {
            left: n.dom.offsetWidth * e.scaleX
          } : {
            right: n.dom.offsetWidth * e.scaleX
          };
        })
      });
      function cT(t) {
        return Array.isArray(t) ? t : [
          t
        ];
      }
      function d1(t, e, n) {
        for (; t.value && t.from <= n; )
          t.from == n && e.push(t.value), t.next();
      }
      class bK {
        constructor(e, n, r) {
          this.gutter = e, this.height = r, this.i = 0, this.cursor = Ve.iter(e.markers, n.from);
        }
        addElement(e, n, r) {
          let { gutter: i } = this, o = (n.top - this.height) / e.scaleY, s = n.height / e.scaleY;
          if (this.i == i.elements.length) {
            let a = new AR(e, s, o, r);
            i.elements.push(a), i.dom.appendChild(a.dom);
          } else
            i.elements[this.i].update(e, s, o, r);
          this.height = n.bottom, this.i++;
        }
        line(e, n, r) {
          let i = [];
          d1(this.cursor, i, n.from), r.length && (i = i.concat(r));
          let o = this.gutter.config.lineMarker(e, n, i);
          o && i.unshift(o);
          let s = this.gutter;
          i.length == 0 && !s.config.renderEmptyElements || this.addElement(e, n, i);
        }
        widget(e, n) {
          let r = this.gutter.config.widgetMarker(e, n.widget, n), i = r ? [
            r
          ] : null;
          for (let o of e.state.facet(mK)) {
            let s = o(e, n.widget, n);
            s && (i || (i = [])).push(s);
          }
          i && this.addElement(e, n, i);
        }
        finish() {
          let e = this.gutter;
          for (; e.elements.length > this.i; ) {
            let n = e.elements.pop();
            e.dom.removeChild(n.dom), n.destroy();
          }
        }
      }
      class uT {
        constructor(e, n) {
          this.view = e, this.config = n, this.elements = [], this.spacer = null, this.dom = document.createElement("div"), this.dom.className = "cm-gutter" + (this.config.class ? " " + this.config.class : "");
          for (let r in n.domEventHandlers)
            this.dom.addEventListener(r, (i) => {
              let o = i.target, s;
              if (o != this.dom && this.dom.contains(o)) {
                for (; o.parentNode != this.dom; )
                  o = o.parentNode;
                let l = o.getBoundingClientRect();
                s = (l.top + l.bottom) / 2;
              } else
                s = i.clientY;
              let a = e.lineBlockAtHeight(s - e.documentTop);
              n.domEventHandlers[r](e, a, i) && i.preventDefault();
            });
          this.markers = cT(n.markers(e)), n.initialSpacer && (this.spacer = new AR(e, 0, 0, [
            n.initialSpacer(e)
          ]), this.dom.appendChild(this.spacer.dom), this.spacer.dom.style.cssText += "visibility: hidden; pointer-events: none");
        }
        update(e) {
          let n = this.markers;
          if (this.markers = cT(this.config.markers(e.view)), this.spacer && this.config.updateSpacer) {
            let i = this.config.updateSpacer(this.spacer.markers[0], e);
            i != this.spacer.markers[0] && this.spacer.update(e.view, 0, 0, [
              i
            ]);
          }
          let r = e.view.viewport;
          return !Ve.eq(this.markers, n, r.from, r.to) || (this.config.lineMarkerChange ? this.config.lineMarkerChange(e) : false);
        }
        destroy() {
          for (let e of this.elements)
            e.destroy();
        }
      }
      class AR {
        constructor(e, n, r, i) {
          this.height = -1, this.above = 0, this.markers = [], this.dom = document.createElement("div"), this.dom.className = "cm-gutterElement", this.update(e, n, r, i);
        }
        update(e, n, r, i) {
          this.height != n && (this.height = n, this.dom.style.height = n + "px"), this.above != r && (this.dom.style.marginTop = (this.above = r) ? r + "px" : ""), xK(this.markers, i) || this.setMarkers(e, i);
        }
        setMarkers(e, n) {
          let r = "cm-gutterElement", i = this.dom.firstChild;
          for (let o = 0, s = 0; ; ) {
            let a = s, l = o < n.length ? n[o++] : null, c = false;
            if (l) {
              let u = l.elementClass;
              u && (r += " " + u);
              for (let h = s; h < this.markers.length; h++)
                if (this.markers[h].compare(l)) {
                  a = h, c = true;
                  break;
                }
            } else
              a = this.markers.length;
            for (; s < a; ) {
              let u = this.markers[s++];
              if (u.toDOM) {
                u.destroy(i);
                let h = i.nextSibling;
                i.remove(), i = h;
              }
            }
            if (!l)
              break;
            l.toDOM && (c ? i = i.nextSibling : this.dom.insertBefore(l.toDOM(e), i)), c && s++;
          }
          this.dom.className = r, this.markers = n;
        }
        destroy() {
          this.setMarkers(null, []);
        }
      }
      function xK(t, e) {
        if (t.length != e.length)
          return false;
        for (let n = 0; n < t.length; n++)
          if (!t[n].compare(e[n]))
            return false;
        return true;
      }
      const SK = pe.define(), wK = pe.define(), La = pe.define({
        combine(t) {
          return Ei(t, {
            formatNumber: String,
            domEventHandlers: {}
          }, {
            domEventHandlers(e, n) {
              let r = Object.assign({}, e);
              for (let i in n) {
                let o = r[i], s = n[i];
                r[i] = o ? (a, l, c) => o(a, l, c) || s(a, l, c) : s;
              }
              return r;
            }
          });
        }
      });
      class V0 extends ro {
        constructor(e) {
          super(), this.number = e;
        }
        eq(e) {
          return this.number == e.number;
        }
        toDOM() {
          return document.createTextNode(this.number);
        }
      }
      function H0(t, e) {
        return t.state.facet(La).formatNumber(e, t.state);
      }
      const kK = Jc.compute([
        La
      ], (t) => ({
        class: "cm-lineNumbers",
        renderEmptyElements: false,
        markers(e) {
          return e.state.facet(SK);
        },
        lineMarker(e, n, r) {
          return r.some((i) => i.toDOM) ? null : new V0(H0(e, e.state.doc.lineAt(n.from).number));
        },
        widgetMarker: (e, n, r) => {
          for (let i of e.state.facet(wK)) {
            let o = i(e, n, r);
            if (o)
              return o;
          }
          return null;
        },
        lineMarkerChange: (e) => e.startState.facet(La) != e.state.facet(La),
        initialSpacer(e) {
          return new V0(H0(e, fT(e.state.doc.lines)));
        },
        updateSpacer(e, n) {
          let r = H0(n.view, fT(n.view.state.doc.lines));
          return r == e.number ? e : new V0(r);
        },
        domEventHandlers: t.facet(La).domEventHandlers
      }));
      function CK(t = {}) {
        return [
          La.of(t),
          MR(),
          kK
        ];
      }
      function fT(t) {
        let e = 9;
        for (; e < t; )
          e = e * 10 + 9;
        return e;
      }
      const TK = new class extends ro {
        constructor() {
          super(...arguments), this.elementClass = "cm-activeLineGutter";
        }
      }(), MK = Td.compute([
        "selection"
      ], (t) => {
        let e = [], n = -1;
        for (let r of t.selection.ranges) {
          let i = t.doc.lineAt(r.head).from;
          i > n && (n = i, e.push(TK.range(i)));
        }
        return Ve.of(e);
      });
      function AK() {
        return MK;
      }
      const EK = 1024;
      let PK = 0;
      class j0 {
        constructor(e, n) {
          this.from = e, this.to = n;
        }
      }
      class $e {
        constructor(e = {}) {
          this.id = PK++, this.perNode = !!e.perNode, this.deserialize = e.deserialize || (() => {
            throw new Error("This node type doesn't define a deserialize function");
          });
        }
        add(e) {
          if (this.perNode)
            throw new RangeError("Can't add per-node props to node types");
          return typeof e != "function" && (e = Cr.match(e)), (n) => {
            let r = e(n);
            return r === void 0 ? null : [
              this,
              r
            ];
          };
        }
      }
      $e.closedBy = new $e({
        deserialize: (t) => t.split(" ")
      });
      $e.openedBy = new $e({
        deserialize: (t) => t.split(" ")
      });
      $e.group = new $e({
        deserialize: (t) => t.split(" ")
      });
      $e.isolate = new $e({
        deserialize: (t) => {
          if (t && t != "rtl" && t != "ltr" && t != "auto")
            throw new RangeError("Invalid value for isolate: " + t);
          return t || "auto";
        }
      });
      $e.contextHash = new $e({
        perNode: true
      });
      $e.lookAhead = new $e({
        perNode: true
      });
      $e.mounted = new $e({
        perNode: true
      });
      class Tp {
        constructor(e, n, r) {
          this.tree = e, this.overlay = n, this.parser = r;
        }
        static get(e) {
          return e && e.props && e.props[$e.mounted.id];
        }
      }
      const OK = /* @__PURE__ */ Object.create(null);
      class Cr {
        constructor(e, n, r, i = 0) {
          this.name = e, this.props = n, this.id = r, this.flags = i;
        }
        static define(e) {
          let n = e.props && e.props.length ? /* @__PURE__ */ Object.create(null) : OK, r = (e.top ? 1 : 0) | (e.skipped ? 2 : 0) | (e.error ? 4 : 0) | (e.name == null ? 8 : 0), i = new Cr(e.name || "", n, e.id, r);
          if (e.props) {
            for (let o of e.props)
              if (Array.isArray(o) || (o = o(i)), o) {
                if (o[0].perNode)
                  throw new RangeError("Can't store a per-node prop on a node type");
                n[o[0].id] = o[1];
              }
          }
          return i;
        }
        prop(e) {
          return this.props[e.id];
        }
        get isTop() {
          return (this.flags & 1) > 0;
        }
        get isSkipped() {
          return (this.flags & 2) > 0;
        }
        get isError() {
          return (this.flags & 4) > 0;
        }
        get isAnonymous() {
          return (this.flags & 8) > 0;
        }
        is(e) {
          if (typeof e == "string") {
            if (this.name == e)
              return true;
            let n = this.prop($e.group);
            return n ? n.indexOf(e) > -1 : false;
          }
          return this.id == e;
        }
        static match(e) {
          let n = /* @__PURE__ */ Object.create(null);
          for (let r in e)
            for (let i of r.split(" "))
              n[i] = e[r];
          return (r) => {
            for (let i = r.prop($e.group), o = -1; o < (i ? i.length : 0); o++) {
              let s = n[o < 0 ? r.name : i[o]];
              if (s)
                return s;
            }
          };
        }
      }
      Cr.none = new Cr("", /* @__PURE__ */ Object.create(null), 0, 8);
      const Rh = /* @__PURE__ */ new WeakMap(), hT = /* @__PURE__ */ new WeakMap();
      var Jt;
      (function(t) {
        t[t.ExcludeBuffers = 1] = "ExcludeBuffers", t[t.IncludeAnonymous = 2] = "IncludeAnonymous", t[t.IgnoreMounts = 4] = "IgnoreMounts", t[t.IgnoreOverlays = 8] = "IgnoreOverlays";
      })(Jt || (Jt = {}));
      class dn {
        constructor(e, n, r, i, o) {
          if (this.type = e, this.children = n, this.positions = r, this.length = i, this.props = null, o && o.length) {
            this.props = /* @__PURE__ */ Object.create(null);
            for (let [s, a] of o)
              this.props[typeof s == "number" ? s : s.id] = a;
          }
        }
        toString() {
          let e = Tp.get(this);
          if (e && !e.overlay)
            return e.tree.toString();
          let n = "";
          for (let r of this.children) {
            let i = r.toString();
            i && (n && (n += ","), n += i);
          }
          return this.type.name ? (/\W/.test(this.type.name) && !this.type.isError ? JSON.stringify(this.type.name) : this.type.name) + (n.length ? "(" + n + ")" : "") : n;
        }
        cursor(e = 0) {
          return new m1(this.topNode, e);
        }
        cursorAt(e, n = 0, r = 0) {
          let i = Rh.get(this) || this.topNode, o = new m1(i);
          return o.moveTo(e, n), Rh.set(this, o._tree), o;
        }
        get topNode() {
          return new xr(this, 0, 0, null);
        }
        resolve(e, n = 0) {
          let r = $u(Rh.get(this) || this.topNode, e, n, false);
          return Rh.set(this, r), r;
        }
        resolveInner(e, n = 0) {
          let r = $u(hT.get(this) || this.topNode, e, n, true);
          return hT.set(this, r), r;
        }
        resolveStack(e, n = 0) {
          return DK(this, e, n);
        }
        iterate(e) {
          let { enter: n, leave: r, from: i = 0, to: o = this.length } = e, s = e.mode || 0, a = (s & Jt.IncludeAnonymous) > 0;
          for (let l = this.cursor(s | Jt.IncludeAnonymous); ; ) {
            let c = false;
            if (l.from <= o && l.to >= i && (!a && l.type.isAnonymous || n(l) !== false)) {
              if (l.firstChild())
                continue;
              c = true;
            }
            for (; c && r && (a || !l.type.isAnonymous) && r(l), !l.nextSibling(); ) {
              if (!l.parent())
                return;
              c = true;
            }
          }
        }
        prop(e) {
          return e.perNode ? this.props ? this.props[e.id] : void 0 : this.type.prop(e);
        }
        get propValues() {
          let e = [];
          if (this.props)
            for (let n in this.props)
              e.push([
                +n,
                this.props[n]
              ]);
          return e;
        }
        balance(e = {}) {
          return this.children.length <= 8 ? this : zx(Cr.none, this.children, this.positions, 0, this.children.length, 0, this.length, (n, r, i) => new dn(this.type, n, r, i, this.propValues), e.makeTree || ((n, r, i) => new dn(Cr.none, n, r, i)));
        }
        static build(e) {
          return _K(e);
        }
      }
      dn.empty = new dn(Cr.none, [], [], 0);
      class Nx {
        constructor(e, n) {
          this.buffer = e, this.index = n;
        }
        get id() {
          return this.buffer[this.index - 4];
        }
        get start() {
          return this.buffer[this.index - 3];
        }
        get end() {
          return this.buffer[this.index - 2];
        }
        get size() {
          return this.buffer[this.index - 1];
        }
        get pos() {
          return this.index;
        }
        next() {
          this.index -= 4;
        }
        fork() {
          return new Nx(this.buffer, this.index);
        }
      }
      class Xo {
        constructor(e, n, r) {
          this.buffer = e, this.length = n, this.set = r;
        }
        get type() {
          return Cr.none;
        }
        toString() {
          let e = [];
          for (let n = 0; n < this.buffer.length; )
            e.push(this.childString(n)), n = this.buffer[n + 3];
          return e.join(",");
        }
        childString(e) {
          let n = this.buffer[e], r = this.buffer[e + 3], i = this.set.types[n], o = i.name;
          if (/\W/.test(o) && !i.isError && (o = JSON.stringify(o)), e += 4, r == e)
            return o;
          let s = [];
          for (; e < r; )
            s.push(this.childString(e)), e = this.buffer[e + 3];
          return o + "(" + s.join(",") + ")";
        }
        findChild(e, n, r, i, o) {
          let { buffer: s } = this, a = -1;
          for (let l = e; l != n && !(ER(o, i, s[l + 1], s[l + 2]) && (a = l, r > 0)); l = s[l + 3])
            ;
          return a;
        }
        slice(e, n, r) {
          let i = this.buffer, o = new Uint16Array(n - e), s = 0;
          for (let a = e, l = 0; a < n; ) {
            o[l++] = i[a++], o[l++] = i[a++] - r;
            let c = o[l++] = i[a++] - r;
            o[l++] = i[a++] - e, s = Math.max(s, c);
          }
          return new Xo(o, s, this.set);
        }
      }
      function ER(t, e, n, r) {
        switch (t) {
          case -2:
            return n < e;
          case -1:
            return r >= e && n < e;
          case 0:
            return n < e && r > e;
          case 1:
            return n <= e && r > e;
          case 2:
            return r > e;
          case 4:
            return true;
        }
      }
      function $u(t, e, n, r) {
        for (var i; t.from == t.to || (n < 1 ? t.from >= e : t.from > e) || (n > -1 ? t.to <= e : t.to < e); ) {
          let s = !r && t instanceof xr && t.index < 0 ? null : t.parent;
          if (!s)
            return t;
          t = s;
        }
        let o = r ? 0 : Jt.IgnoreOverlays;
        if (r)
          for (let s = t, a = s.parent; a; s = a, a = s.parent)
            s instanceof xr && s.index < 0 && ((i = a.enter(e, n, o)) === null || i === void 0 ? void 0 : i.from) != s.from && (t = a);
        for (; ; ) {
          let s = t.enter(e, n, o);
          if (!s)
            return t;
          t = s;
        }
      }
      class PR {
        cursor(e = 0) {
          return new m1(this, e);
        }
        getChild(e, n = null, r = null) {
          let i = dT(this, e, n, r);
          return i.length ? i[0] : null;
        }
        getChildren(e, n = null, r = null) {
          return dT(this, e, n, r);
        }
        resolve(e, n = 0) {
          return $u(this, e, n, false);
        }
        resolveInner(e, n = 0) {
          return $u(this, e, n, true);
        }
        matchContext(e) {
          return p1(this.parent, e);
        }
        enterUnfinishedNodesBefore(e) {
          let n = this.childBefore(e), r = this;
          for (; n; ) {
            let i = n.lastChild;
            if (!i || i.to != n.to)
              break;
            i.type.isError && i.from == i.to ? (r = n, n = i.prevSibling) : n = i;
          }
          return r;
        }
        get node() {
          return this;
        }
        get next() {
          return this.parent;
        }
      }
      class xr extends PR {
        constructor(e, n, r, i) {
          super(), this._tree = e, this.from = n, this.index = r, this._parent = i;
        }
        get type() {
          return this._tree.type;
        }
        get name() {
          return this._tree.type.name;
        }
        get to() {
          return this.from + this._tree.length;
        }
        nextChild(e, n, r, i, o = 0) {
          for (let s = this; ; ) {
            for (let { children: a, positions: l } = s._tree, c = n > 0 ? a.length : -1; e != c; e += n) {
              let u = a[e], h = l[e] + s.from;
              if (!!ER(i, r, h, h + u.length)) {
                if (u instanceof Xo) {
                  if (o & Jt.ExcludeBuffers)
                    continue;
                  let p = u.findChild(0, u.buffer.length, n, r - h, i);
                  if (p > -1)
                    return new Io(new RK(s, u, e, h), null, p);
                } else if (o & Jt.IncludeAnonymous || !u.type.isAnonymous || $x(u)) {
                  let p;
                  if (!(o & Jt.IgnoreMounts) && (p = Tp.get(u)) && !p.overlay)
                    return new xr(p.tree, h, e, s);
                  let v = new xr(u, h, e, s);
                  return o & Jt.IncludeAnonymous || !v.type.isAnonymous ? v : v.nextChild(n < 0 ? u.children.length - 1 : 0, n, r, i);
                }
              }
            }
            if (o & Jt.IncludeAnonymous || !s.type.isAnonymous || (s.index >= 0 ? e = s.index + n : e = n < 0 ? -1 : s._parent._tree.children.length, s = s._parent, !s))
              return null;
          }
        }
        get firstChild() {
          return this.nextChild(0, 1, 0, 4);
        }
        get lastChild() {
          return this.nextChild(this._tree.children.length - 1, -1, 0, 4);
        }
        childAfter(e) {
          return this.nextChild(0, 1, e, 2);
        }
        childBefore(e) {
          return this.nextChild(this._tree.children.length - 1, -1, e, -2);
        }
        enter(e, n, r = 0) {
          let i;
          if (!(r & Jt.IgnoreOverlays) && (i = Tp.get(this._tree)) && i.overlay) {
            let o = e - this.from;
            for (let { from: s, to: a } of i.overlay)
              if ((n > 0 ? s <= o : s < o) && (n < 0 ? a >= o : a > o))
                return new xr(i.tree, i.overlay[0].from + this.from, -1, this);
          }
          return this.nextChild(0, 1, e, n, r);
        }
        nextSignificantParent() {
          let e = this;
          for (; e.type.isAnonymous && e._parent; )
            e = e._parent;
          return e;
        }
        get parent() {
          return this._parent ? this._parent.nextSignificantParent() : null;
        }
        get nextSibling() {
          return this._parent && this.index >= 0 ? this._parent.nextChild(this.index + 1, 1, 0, 4) : null;
        }
        get prevSibling() {
          return this._parent && this.index >= 0 ? this._parent.nextChild(this.index - 1, -1, 0, 4) : null;
        }
        get tree() {
          return this._tree;
        }
        toTree() {
          return this._tree;
        }
        toString() {
          return this._tree.toString();
        }
      }
      function dT(t, e, n, r) {
        let i = t.cursor(), o = [];
        if (!i.firstChild())
          return o;
        if (n != null) {
          for (let s = false; !s; )
            if (s = i.type.is(n), !i.nextSibling())
              return o;
        }
        for (; ; ) {
          if (r != null && i.type.is(r))
            return o;
          if (i.type.is(e) && o.push(i.node), !i.nextSibling())
            return r == null ? o : [];
        }
      }
      function p1(t, e, n = e.length - 1) {
        for (let r = t; n >= 0; r = r.parent) {
          if (!r)
            return false;
          if (!r.type.isAnonymous) {
            if (e[n] && e[n] != r.name)
              return false;
            n--;
          }
        }
        return true;
      }
      class RK {
        constructor(e, n, r, i) {
          this.parent = e, this.buffer = n, this.index = r, this.start = i;
        }
      }
      class Io extends PR {
        get name() {
          return this.type.name;
        }
        get from() {
          return this.context.start + this.context.buffer.buffer[this.index + 1];
        }
        get to() {
          return this.context.start + this.context.buffer.buffer[this.index + 2];
        }
        constructor(e, n, r) {
          super(), this.context = e, this._parent = n, this.index = r, this.type = e.buffer.set.types[e.buffer.buffer[r]];
        }
        child(e, n, r) {
          let { buffer: i } = this.context, o = i.findChild(this.index + 4, i.buffer[this.index + 3], e, n - this.context.start, r);
          return o < 0 ? null : new Io(this.context, this, o);
        }
        get firstChild() {
          return this.child(1, 0, 4);
        }
        get lastChild() {
          return this.child(-1, 0, 4);
        }
        childAfter(e) {
          return this.child(1, e, 2);
        }
        childBefore(e) {
          return this.child(-1, e, -2);
        }
        enter(e, n, r = 0) {
          if (r & Jt.ExcludeBuffers)
            return null;
          let { buffer: i } = this.context, o = i.findChild(this.index + 4, i.buffer[this.index + 3], n > 0 ? 1 : -1, e - this.context.start, n);
          return o < 0 ? null : new Io(this.context, this, o);
        }
        get parent() {
          return this._parent || this.context.parent.nextSignificantParent();
        }
        externalSibling(e) {
          return this._parent ? null : this.context.parent.nextChild(this.context.index + e, e, 0, 4);
        }
        get nextSibling() {
          let { buffer: e } = this.context, n = e.buffer[this.index + 3];
          return n < (this._parent ? e.buffer[this._parent.index + 3] : e.buffer.length) ? new Io(this.context, this._parent, n) : this.externalSibling(1);
        }
        get prevSibling() {
          let { buffer: e } = this.context, n = this._parent ? this._parent.index + 4 : 0;
          return this.index == n ? this.externalSibling(-1) : new Io(this.context, this._parent, e.findChild(n, this.index, -1, 0, 4));
        }
        get tree() {
          return null;
        }
        toTree() {
          let e = [], n = [], { buffer: r } = this.context, i = this.index + 4, o = r.buffer[this.index + 3];
          if (o > i) {
            let s = r.buffer[this.index + 1];
            e.push(r.slice(i, o, s)), n.push(0);
          }
          return new dn(this.type, e, n, this.to - this.from);
        }
        toString() {
          return this.context.buffer.childString(this.index);
        }
      }
      function OR(t) {
        if (!t.length)
          return null;
        let e = 0, n = t[0];
        for (let o = 1; o < t.length; o++) {
          let s = t[o];
          (s.from > n.from || s.to < n.to) && (n = s, e = o);
        }
        let r = n instanceof xr && n.index < 0 ? null : n.parent, i = t.slice();
        return r ? i[e] = r : i.splice(e, 1), new LK(i, n);
      }
      class LK {
        constructor(e, n) {
          this.heads = e, this.node = n;
        }
        get next() {
          return OR(this.heads);
        }
      }
      function DK(t, e, n) {
        let r = t.resolveInner(e, n), i = null;
        for (let o = r instanceof xr ? r : r.context.parent; o; o = o.parent)
          if (o.index < 0) {
            let s = o.parent;
            (i || (i = [
              r
            ])).push(s.resolve(e, n)), o = s;
          } else {
            let s = Tp.get(o.tree);
            if (s && s.overlay && s.overlay[0].from <= e && s.overlay[s.overlay.length - 1].to >= e) {
              let a = new xr(s.tree, s.overlay[0].from + o.from, -1, o);
              (i || (i = [
                r
              ])).push($u(a, e, n, false));
            }
          }
        return i ? OR(i) : r;
      }
      class m1 {
        get name() {
          return this.type.name;
        }
        constructor(e, n = 0) {
          if (this.mode = n, this.buffer = null, this.stack = [], this.index = 0, this.bufferNode = null, e instanceof xr)
            this.yieldNode(e);
          else {
            this._tree = e.context.parent, this.buffer = e.context;
            for (let r = e._parent; r; r = r._parent)
              this.stack.unshift(r.index);
            this.bufferNode = e, this.yieldBuf(e.index);
          }
        }
        yieldNode(e) {
          return e ? (this._tree = e, this.type = e.type, this.from = e.from, this.to = e.to, true) : false;
        }
        yieldBuf(e, n) {
          this.index = e;
          let { start: r, buffer: i } = this.buffer;
          return this.type = n || i.set.types[i.buffer[e]], this.from = r + i.buffer[e + 1], this.to = r + i.buffer[e + 2], true;
        }
        yield(e) {
          return e ? e instanceof xr ? (this.buffer = null, this.yieldNode(e)) : (this.buffer = e.context, this.yieldBuf(e.index, e.type)) : false;
        }
        toString() {
          return this.buffer ? this.buffer.buffer.childString(this.index) : this._tree.toString();
        }
        enterChild(e, n, r) {
          if (!this.buffer)
            return this.yield(this._tree.nextChild(e < 0 ? this._tree._tree.children.length - 1 : 0, e, n, r, this.mode));
          let { buffer: i } = this.buffer, o = i.findChild(this.index + 4, i.buffer[this.index + 3], e, n - this.buffer.start, r);
          return o < 0 ? false : (this.stack.push(this.index), this.yieldBuf(o));
        }
        firstChild() {
          return this.enterChild(1, 0, 4);
        }
        lastChild() {
          return this.enterChild(-1, 0, 4);
        }
        childAfter(e) {
          return this.enterChild(1, e, 2);
        }
        childBefore(e) {
          return this.enterChild(-1, e, -2);
        }
        enter(e, n, r = this.mode) {
          return this.buffer ? r & Jt.ExcludeBuffers ? false : this.enterChild(1, e, n) : this.yield(this._tree.enter(e, n, r));
        }
        parent() {
          if (!this.buffer)
            return this.yieldNode(this.mode & Jt.IncludeAnonymous ? this._tree._parent : this._tree.parent);
          if (this.stack.length)
            return this.yieldBuf(this.stack.pop());
          let e = this.mode & Jt.IncludeAnonymous ? this.buffer.parent : this.buffer.parent.nextSignificantParent();
          return this.buffer = null, this.yieldNode(e);
        }
        sibling(e) {
          if (!this.buffer)
            return this._tree._parent ? this.yield(this._tree.index < 0 ? null : this._tree._parent.nextChild(this._tree.index + e, e, 0, 4, this.mode)) : false;
          let { buffer: n } = this.buffer, r = this.stack.length - 1;
          if (e < 0) {
            let i = r < 0 ? 0 : this.stack[r] + 4;
            if (this.index != i)
              return this.yieldBuf(n.findChild(i, this.index, -1, 0, 4));
          } else {
            let i = n.buffer[this.index + 3];
            if (i < (r < 0 ? n.buffer.length : n.buffer[this.stack[r] + 3]))
              return this.yieldBuf(i);
          }
          return r < 0 ? this.yield(this.buffer.parent.nextChild(this.buffer.index + e, e, 0, 4, this.mode)) : false;
        }
        nextSibling() {
          return this.sibling(1);
        }
        prevSibling() {
          return this.sibling(-1);
        }
        atLastNode(e) {
          let n, r, { buffer: i } = this;
          if (i) {
            if (e > 0) {
              if (this.index < i.buffer.buffer.length)
                return false;
            } else
              for (let o = 0; o < this.index; o++)
                if (i.buffer.buffer[o + 3] < this.index)
                  return false;
            ({ index: n, parent: r } = i);
          } else
            ({ index: n, _parent: r } = this._tree);
          for (; r; { index: n, _parent: r } = r)
            if (n > -1)
              for (let o = n + e, s = e < 0 ? -1 : r._tree.children.length; o != s; o += e) {
                let a = r._tree.children[o];
                if (this.mode & Jt.IncludeAnonymous || a instanceof Xo || !a.type.isAnonymous || $x(a))
                  return false;
              }
          return true;
        }
        move(e, n) {
          if (n && this.enterChild(e, 0, 4))
            return true;
          for (; ; ) {
            if (this.sibling(e))
              return true;
            if (this.atLastNode(e) || !this.parent())
              return false;
          }
        }
        next(e = true) {
          return this.move(1, e);
        }
        prev(e = true) {
          return this.move(-1, e);
        }
        moveTo(e, n = 0) {
          for (; (this.from == this.to || (n < 1 ? this.from >= e : this.from > e) || (n > -1 ? this.to <= e : this.to < e)) && this.parent(); )
            ;
          for (; this.enterChild(1, e, n); )
            ;
          return this;
        }
        get node() {
          if (!this.buffer)
            return this._tree;
          let e = this.bufferNode, n = null, r = 0;
          if (e && e.context == this.buffer) {
            e:
              for (let i = this.index, o = this.stack.length; o >= 0; ) {
                for (let s = e; s; s = s._parent)
                  if (s.index == i) {
                    if (i == this.index)
                      return s;
                    n = s, r = o + 1;
                    break e;
                  }
                i = this.stack[--o];
              }
          }
          for (let i = r; i < this.stack.length; i++)
            n = new Io(this.buffer, n, this.stack[i]);
          return this.bufferNode = new Io(this.buffer, n, this.index);
        }
        get tree() {
          return this.buffer ? null : this._tree._tree;
        }
        iterate(e, n) {
          for (let r = 0; ; ) {
            let i = false;
            if (this.type.isAnonymous || e(this) !== false) {
              if (this.firstChild()) {
                r++;
                continue;
              }
              this.type.isAnonymous || (i = true);
            }
            for (; ; ) {
              if (i && n && n(this), i = this.type.isAnonymous, !r)
                return;
              if (this.nextSibling())
                break;
              this.parent(), r--, i = true;
            }
          }
        }
        matchContext(e) {
          if (!this.buffer)
            return p1(this.node.parent, e);
          let { buffer: n } = this.buffer, { types: r } = n.set;
          for (let i = e.length - 1, o = this.stack.length - 1; i >= 0; o--) {
            if (o < 0)
              return p1(this._tree, e, i);
            let s = r[n.buffer[this.stack[o]]];
            if (!s.isAnonymous) {
              if (e[i] && e[i] != s.name)
                return false;
              i--;
            }
          }
          return true;
        }
      }
      function $x(t) {
        return t.children.some((e) => e instanceof Xo || !e.type.isAnonymous || $x(e));
      }
      function _K(t) {
        var e;
        let { buffer: n, nodeSet: r, maxBufferLength: i = EK, reused: o = [], minRepeatType: s = r.types.length } = t, a = Array.isArray(n) ? new Nx(n, n.length) : n, l = r.types, c = 0, u = 0;
        function h(R, L, D, F, K, Y) {
          let { id: te, start: ne, end: ue, size: ye } = a, ke = u, Ee = c;
          for (; ye < 0; )
            if (a.next(), ye == -1) {
              let Te = o[te];
              D.push(Te), F.push(ne - R);
              return;
            } else if (ye == -3) {
              c = te;
              return;
            } else if (ye == -4) {
              u = te;
              return;
            } else
              throw new RangeError(`Unrecognized record size: ${ye}`);
          let Q = l[te], V, ae, ge = ne - R;
          if (ue - ne <= i && (ae = C(a.pos - L, K))) {
            let Te = new Uint16Array(ae.size - ae.skip), ve = a.pos - ae.size, se = Te.length;
            for (; a.pos > ve; )
              se = w(ae.start, Te, se);
            V = new Xo(Te, ue - ae.start, r), ge = ae.start - R;
          } else {
            let Te = a.pos - ye;
            a.next();
            let ve = [], se = [], re = te >= s ? te : -1, oe = 0, De = ue;
            for (; a.pos > Te; )
              re >= 0 && a.id == re && a.size >= 0 ? (a.end <= De - i && (y(ve, se, ne, oe, a.end, De, re, ke, Ee), oe = ve.length, De = a.end), a.next()) : Y > 2500 ? p(ne, Te, ve, se) : h(ne, Te, ve, se, re, Y + 1);
            if (re >= 0 && oe > 0 && oe < ve.length && y(ve, se, ne, oe, ne, De, re, ke, Ee), ve.reverse(), se.reverse(), re > -1 && oe > 0) {
              let yt = v(Q, Ee);
              V = zx(Q, ve, se, 0, ve.length, 0, ue - ne, yt, yt);
            } else
              V = S(Q, ve, se, ue - ne, ke - ue, Ee);
          }
          D.push(V), F.push(ge);
        }
        function p(R, L, D, F) {
          let K = [], Y = 0, te = -1;
          for (; a.pos > L; ) {
            let { id: ne, start: ue, end: ye, size: ke } = a;
            if (ke > 4)
              a.next();
            else {
              if (te > -1 && ue < te)
                break;
              te < 0 && (te = ye - i), K.push(ne, ue, ye), Y++, a.next();
            }
          }
          if (Y) {
            let ne = new Uint16Array(Y * 4), ue = K[K.length - 2];
            for (let ye = K.length - 3, ke = 0; ye >= 0; ye -= 3)
              ne[ke++] = K[ye], ne[ke++] = K[ye + 1] - ue, ne[ke++] = K[ye + 2] - ue, ne[ke++] = ke;
            D.push(new Xo(ne, K[2] - ue, r)), F.push(ue - R);
          }
        }
        function v(R, L) {
          return (D, F, K) => {
            let Y = 0, te = D.length - 1, ne, ue;
            if (te >= 0 && (ne = D[te]) instanceof dn) {
              if (!te && ne.type == R && ne.length == K)
                return ne;
              (ue = ne.prop($e.lookAhead)) && (Y = F[te] + ne.length + ue);
            }
            return S(R, D, F, K, Y, L);
          };
        }
        function y(R, L, D, F, K, Y, te, ne, ue) {
          let ye = [], ke = [];
          for (; R.length > F; )
            ye.push(R.pop()), ke.push(L.pop() + D - K);
          R.push(S(r.types[te], ye, ke, Y - K, ne - Y, ue)), L.push(K - D);
        }
        function S(R, L, D, F, K, Y, te) {
          if (Y) {
            let ne = [
              $e.contextHash,
              Y
            ];
            te = te ? [
              ne
            ].concat(te) : [
              ne
            ];
          }
          if (K > 25) {
            let ne = [
              $e.lookAhead,
              K
            ];
            te = te ? [
              ne
            ].concat(te) : [
              ne
            ];
          }
          return new dn(R, L, D, F, te);
        }
        function C(R, L) {
          let D = a.fork(), F = 0, K = 0, Y = 0, te = D.end - i, ne = {
            size: 0,
            start: 0,
            skip: 0
          };
          e:
            for (let ue = D.pos - R; D.pos > ue; ) {
              let ye = D.size;
              if (D.id == L && ye >= 0) {
                ne.size = F, ne.start = K, ne.skip = Y, Y += 4, F += 4, D.next();
                continue;
              }
              let ke = D.pos - ye;
              if (ye < 0 || ke < ue || D.start < te)
                break;
              let Ee = D.id >= s ? 4 : 0, Q = D.start;
              for (D.next(); D.pos > ke; ) {
                if (D.size < 0)
                  if (D.size == -3)
                    Ee += 4;
                  else
                    break e;
                else
                  D.id >= s && (Ee += 4);
                D.next();
              }
              K = Q, F += ye, Y += Ee;
            }
          return (L < 0 || F == R) && (ne.size = F, ne.start = K, ne.skip = Y), ne.size > 4 ? ne : void 0;
        }
        function w(R, L, D) {
          let { id: F, start: K, end: Y, size: te } = a;
          if (a.next(), te >= 0 && F < s) {
            let ne = D;
            if (te > 4) {
              let ue = a.pos - (te - 4);
              for (; a.pos > ue; )
                D = w(R, L, D);
            }
            L[--D] = ne, L[--D] = Y - R, L[--D] = K - R, L[--D] = F;
          } else
            te == -3 ? c = F : te == -4 && (u = F);
          return D;
        }
        let k = [], T = [];
        for (; a.pos > 0; )
          h(t.start || 0, t.bufferStart || 0, k, T, -1, 0);
        let P = (e = t.length) !== null && e !== void 0 ? e : k.length ? T[0] + k[0].length : 0;
        return new dn(l[t.topID], k.reverse(), T.reverse(), P);
      }
      const pT = /* @__PURE__ */ new WeakMap();
      function Md(t, e) {
        if (!t.isAnonymous || e instanceof Xo || e.type != t)
          return 1;
        let n = pT.get(e);
        if (n == null) {
          n = 1;
          for (let r of e.children) {
            if (r.type != t || !(r instanceof dn)) {
              n = 1;
              break;
            }
            n += Md(t, r);
          }
          pT.set(e, n);
        }
        return n;
      }
      function zx(t, e, n, r, i, o, s, a, l) {
        let c = 0;
        for (let y = r; y < i; y++)
          c += Md(t, e[y]);
        let u = Math.ceil(c * 1.5 / 8), h = [], p = [];
        function v(y, S, C, w, k) {
          for (let T = C; T < w; ) {
            let P = T, R = S[T], L = Md(t, y[T]);
            for (T++; T < w; T++) {
              let D = Md(t, y[T]);
              if (L + D >= u)
                break;
              L += D;
            }
            if (T == P + 1) {
              if (L > u) {
                let D = y[P];
                v(D.children, D.positions, 0, D.children.length, S[P] + k);
                continue;
              }
              h.push(y[P]);
            } else {
              let D = S[T - 1] + y[T - 1].length - R;
              h.push(zx(t, y, S, P, T, R, D, null, l));
            }
            p.push(R + k - o);
          }
        }
        return v(e, n, r, i, 0), (a || l)(h, p, s);
      }
      class _s {
        constructor(e, n, r, i, o = false, s = false) {
          this.from = e, this.to = n, this.tree = r, this.offset = i, this.open = (o ? 1 : 0) | (s ? 2 : 0);
        }
        get openStart() {
          return (this.open & 1) > 0;
        }
        get openEnd() {
          return (this.open & 2) > 0;
        }
        static addTree(e, n = [], r = false) {
          let i = [
            new _s(0, e.length, e, 0, false, r)
          ];
          for (let o of n)
            o.to > e.length && i.push(o);
          return i;
        }
        static applyChanges(e, n, r = 128) {
          if (!n.length)
            return e;
          let i = [], o = 1, s = e.length ? e[0] : null;
          for (let a = 0, l = 0, c = 0; ; a++) {
            let u = a < n.length ? n[a] : null, h = u ? u.fromA : 1e9;
            if (h - l >= r)
              for (; s && s.from < h; ) {
                let p = s;
                if (l >= p.from || h <= p.to || c) {
                  let v = Math.max(p.from, l) - c, y = Math.min(p.to, h) - c;
                  p = v >= y ? null : new _s(v, y, p.tree, p.offset + c, a > 0, !!u);
                }
                if (p && i.push(p), s.to > h)
                  break;
                s = o < e.length ? e[o++] : null;
              }
            if (!u)
              break;
            l = u.toA, c = u.toA - u.toB;
          }
          return i;
        }
      }
      class IK {
        startParse(e, n, r) {
          return typeof e == "string" && (e = new BK(e)), r = r ? r.length ? r.map((i) => new j0(i.from, i.to)) : [
            new j0(0, 0)
          ] : [
            new j0(0, e.length)
          ], this.createParse(e, n || [], r);
        }
        parse(e, n, r) {
          let i = this.startParse(e, n, r);
          for (; ; ) {
            let o = i.advance();
            if (o)
              return o;
          }
        }
      }
      class BK {
        constructor(e) {
          this.string = e;
        }
        get length() {
          return this.string.length;
        }
        chunk(e) {
          return this.string.slice(e);
        }
        get lineChunks() {
          return false;
        }
        read(e, n) {
          return this.string.slice(e, n);
        }
      }
      new $e({
        perNode: true
      });
      let NK = 0;
      class dr {
        constructor(e, n, r, i) {
          this.name = e, this.set = n, this.base = r, this.modified = i, this.id = NK++;
        }
        toString() {
          let { name: e } = this;
          for (let n of this.modified)
            n.name && (e = `${n.name}(${e})`);
          return e;
        }
        static define(e, n) {
          let r = typeof e == "string" ? e : "?";
          if (e instanceof dr && (n = e), n == null ? void 0 : n.base)
            throw new Error("Can not derive from a modified tag");
          let i = new dr(r, [], null, []);
          if (i.set.push(i), n)
            for (let o of n.set)
              i.set.push(o);
          return i;
        }
        static defineModifier(e) {
          let n = new Mp(e);
          return (r) => r.modified.indexOf(n) > -1 ? r : Mp.get(r.base || r, r.modified.concat(n).sort((i, o) => i.id - o.id));
        }
      }
      let $K = 0;
      class Mp {
        constructor(e) {
          this.name = e, this.instances = [], this.id = $K++;
        }
        static get(e, n) {
          if (!n.length)
            return e;
          let r = n[0].instances.find((a) => a.base == e && zK(n, a.modified));
          if (r)
            return r;
          let i = [], o = new dr(e.name, i, e, n);
          for (let a of n)
            a.instances.push(o);
          let s = FK(n);
          for (let a of e.set)
            if (!a.modified.length)
              for (let l of s)
                i.push(Mp.get(a, l));
          return o;
        }
      }
      function zK(t, e) {
        return t.length == e.length && t.every((n, r) => n == e[r]);
      }
      function FK(t) {
        let e = [
          []
        ];
        for (let n = 0; n < t.length; n++)
          for (let r = 0, i = e.length; r < i; r++)
            e.push(e[r].concat(t[n]));
        return e.sort((n, r) => r.length - n.length);
      }
      function VK(t) {
        let e = /* @__PURE__ */ Object.create(null);
        for (let n in t) {
          let r = t[n];
          Array.isArray(r) || (r = [
            r
          ]);
          for (let i of n.split(" "))
            if (i) {
              let o = [], s = 2, a = i;
              for (let h = 0; ; ) {
                if (a == "..." && h > 0 && h + 3 == i.length) {
                  s = 1;
                  break;
                }
                let p = /^"(?:[^"\\]|\\.)*?"|[^\/!]+/.exec(a);
                if (!p)
                  throw new RangeError("Invalid path: " + i);
                if (o.push(p[0] == "*" ? "" : p[0][0] == '"' ? JSON.parse(p[0]) : p[0]), h += p[0].length, h == i.length)
                  break;
                let v = i[h++];
                if (h == i.length && v == "!") {
                  s = 0;
                  break;
                }
                if (v != "/")
                  throw new RangeError("Invalid path: " + i);
                a = i.slice(h);
              }
              let l = o.length - 1, c = o[l];
              if (!c)
                throw new RangeError("Invalid path: " + i);
              let u = new Ap(r, s, l > 0 ? o.slice(0, l) : null);
              e[c] = u.sort(e[c]);
            }
        }
        return RR.add(e);
      }
      const RR = new $e();
      class Ap {
        constructor(e, n, r, i) {
          this.tags = e, this.mode = n, this.context = r, this.next = i;
        }
        get opaque() {
          return this.mode == 0;
        }
        get inherit() {
          return this.mode == 1;
        }
        sort(e) {
          return !e || e.depth < this.depth ? (this.next = e, this) : (e.next = this.sort(e.next), e);
        }
        get depth() {
          return this.context ? this.context.length : 0;
        }
      }
      Ap.empty = new Ap([], 2, null);
      function LR(t, e) {
        let n = /* @__PURE__ */ Object.create(null);
        for (let o of t)
          if (!Array.isArray(o.tag))
            n[o.tag.id] = o.class;
          else
            for (let s of o.tag)
              n[s.id] = o.class;
        let { scope: r, all: i = null } = e || {};
        return {
          style: (o) => {
            let s = i;
            for (let a of o)
              for (let l of a.set) {
                let c = n[l.id];
                if (c) {
                  s = s ? s + " " + c : c;
                  break;
                }
              }
            return s;
          },
          scope: r
        };
      }
      function HK(t, e) {
        let n = null;
        for (let r of t) {
          let i = r.style(e);
          i && (n = n ? n + " " + i : i);
        }
        return n;
      }
      function jK(t, e, n, r = 0, i = t.length) {
        let o = new WK(r, Array.isArray(e) ? e : [
          e
        ], n);
        o.highlightRange(t.cursor(), r, i, "", o.highlighters), o.flush(i);
      }
      class WK {
        constructor(e, n, r) {
          this.at = e, this.highlighters = n, this.span = r, this.class = "";
        }
        startSpan(e, n) {
          n != this.class && (this.flush(e), e > this.at && (this.at = e), this.class = n);
        }
        flush(e) {
          e > this.at && this.class && this.span(this.at, e, this.class);
        }
        highlightRange(e, n, r, i, o) {
          let { type: s, from: a, to: l } = e;
          if (a >= r || l <= n)
            return;
          s.isTop && (o = this.highlighters.filter((v) => !v.scope || v.scope(s)));
          let c = i, u = UK(e) || Ap.empty, h = HK(o, u.tags);
          if (h && (c && (c += " "), c += h, u.mode == 1 && (i += (i ? " " : "") + h)), this.startSpan(Math.max(n, a), c), u.opaque)
            return;
          let p = e.tree && e.tree.prop($e.mounted);
          if (p && p.overlay) {
            let v = e.node.enter(p.overlay[0].from + a, 1), y = this.highlighters.filter((C) => !C.scope || C.scope(p.tree.type)), S = e.firstChild();
            for (let C = 0, w = a; ; C++) {
              let k = C < p.overlay.length ? p.overlay[C] : null, T = k ? k.from + a : l, P = Math.max(n, w), R = Math.min(r, T);
              if (P < R && S)
                for (; e.from < R && (this.highlightRange(e, P, R, i, o), this.startSpan(Math.min(R, e.to), c), !(e.to >= T || !e.nextSibling())); )
                  ;
              if (!k || T > r)
                break;
              w = k.to + a, w > n && (this.highlightRange(v.cursor(), Math.max(n, k.from + a), Math.min(r, w), "", y), this.startSpan(Math.min(r, w), c));
            }
            S && e.parent();
          } else if (e.firstChild()) {
            p && (i = "");
            do
              if (!(e.to <= n)) {
                if (e.from >= r)
                  break;
                this.highlightRange(e, n, r, i, o), this.startSpan(Math.min(r, e.to), c);
              }
            while (e.nextSibling());
            e.parent();
          }
        }
      }
      function UK(t) {
        let e = t.type.prop(RR);
        for (; e && e.context && !t.matchContext(e.context); )
          e = e.next;
        return e || null;
      }
      const le = dr.define, Lh = le(), So = le(), mT = le(So), gT = le(So), wo = le(), Dh = le(wo), W0 = le(wo), ii = le(), ps = le(ii), ni = le(), ri = le(), g1 = le(), sc = le(g1), _h = le(), G = {
        comment: Lh,
        lineComment: le(Lh),
        blockComment: le(Lh),
        docComment: le(Lh),
        name: So,
        variableName: le(So),
        typeName: mT,
        tagName: le(mT),
        propertyName: gT,
        attributeName: le(gT),
        className: le(So),
        labelName: le(So),
        namespace: le(So),
        macroName: le(So),
        literal: wo,
        string: Dh,
        docString: le(Dh),
        character: le(Dh),
        attributeValue: le(Dh),
        number: W0,
        integer: le(W0),
        float: le(W0),
        bool: le(wo),
        regexp: le(wo),
        escape: le(wo),
        color: le(wo),
        url: le(wo),
        keyword: ni,
        self: le(ni),
        null: le(ni),
        atom: le(ni),
        unit: le(ni),
        modifier: le(ni),
        operatorKeyword: le(ni),
        controlKeyword: le(ni),
        definitionKeyword: le(ni),
        moduleKeyword: le(ni),
        operator: ri,
        derefOperator: le(ri),
        arithmeticOperator: le(ri),
        logicOperator: le(ri),
        bitwiseOperator: le(ri),
        compareOperator: le(ri),
        updateOperator: le(ri),
        definitionOperator: le(ri),
        typeOperator: le(ri),
        controlOperator: le(ri),
        punctuation: g1,
        separator: le(g1),
        bracket: sc,
        angleBracket: le(sc),
        squareBracket: le(sc),
        paren: le(sc),
        brace: le(sc),
        content: ii,
        heading: ps,
        heading1: le(ps),
        heading2: le(ps),
        heading3: le(ps),
        heading4: le(ps),
        heading5: le(ps),
        heading6: le(ps),
        contentSeparator: le(ii),
        list: le(ii),
        quote: le(ii),
        emphasis: le(ii),
        strong: le(ii),
        link: le(ii),
        monospace: le(ii),
        strikethrough: le(ii),
        inserted: le(),
        deleted: le(),
        changed: le(),
        invalid: le(),
        meta: _h,
        documentMeta: le(_h),
        annotation: le(_h),
        processingInstruction: le(_h),
        definition: dr.defineModifier("definition"),
        constant: dr.defineModifier("constant"),
        function: dr.defineModifier("function"),
        standard: dr.defineModifier("standard"),
        local: dr.defineModifier("local"),
        special: dr.defineModifier("special")
      };
      for (let t in G) {
        let e = G[t];
        e instanceof dr && (e.name = t);
      }
      LR([
        {
          tag: G.link,
          class: "tok-link"
        },
        {
          tag: G.heading,
          class: "tok-heading"
        },
        {
          tag: G.emphasis,
          class: "tok-emphasis"
        },
        {
          tag: G.strong,
          class: "tok-strong"
        },
        {
          tag: G.keyword,
          class: "tok-keyword"
        },
        {
          tag: G.atom,
          class: "tok-atom"
        },
        {
          tag: G.bool,
          class: "tok-bool"
        },
        {
          tag: G.url,
          class: "tok-url"
        },
        {
          tag: G.labelName,
          class: "tok-labelName"
        },
        {
          tag: G.inserted,
          class: "tok-inserted"
        },
        {
          tag: G.deleted,
          class: "tok-deleted"
        },
        {
          tag: G.literal,
          class: "tok-literal"
        },
        {
          tag: G.string,
          class: "tok-string"
        },
        {
          tag: G.number,
          class: "tok-number"
        },
        {
          tag: [
            G.regexp,
            G.escape,
            G.special(G.string)
          ],
          class: "tok-string2"
        },
        {
          tag: G.variableName,
          class: "tok-variableName"
        },
        {
          tag: G.local(G.variableName),
          class: "tok-variableName tok-local"
        },
        {
          tag: G.definition(G.variableName),
          class: "tok-variableName tok-definition"
        },
        {
          tag: G.special(G.variableName),
          class: "tok-variableName2"
        },
        {
          tag: G.definition(G.propertyName),
          class: "tok-propertyName tok-definition"
        },
        {
          tag: G.typeName,
          class: "tok-typeName"
        },
        {
          tag: G.namespace,
          class: "tok-namespace"
        },
        {
          tag: G.className,
          class: "tok-className"
        },
        {
          tag: G.macroName,
          class: "tok-macroName"
        },
        {
          tag: G.propertyName,
          class: "tok-propertyName"
        },
        {
          tag: G.operator,
          class: "tok-operator"
        },
        {
          tag: G.comment,
          class: "tok-comment"
        },
        {
          tag: G.meta,
          class: "tok-meta"
        },
        {
          tag: G.invalid,
          class: "tok-invalid"
        },
        {
          tag: G.punctuation,
          class: "tok-punctuation"
        }
      ]);
      var U0;
      const kc = new $e(), KK = new $e();
      class $r {
        constructor(e, n, r = [], i = "") {
          this.data = e, this.name = i, Ne.prototype.hasOwnProperty("tree") || Object.defineProperty(Ne.prototype, "tree", {
            get() {
              return mn(this);
            }
          }), this.parser = n, this.extension = [
            Qo.of(this),
            Ne.languageData.of((o, s, a) => {
              let l = vT(o, s, a), c = l.type.prop(kc);
              if (!c)
                return [];
              let u = o.facet(c), h = l.type.prop(KK);
              if (h) {
                let p = l.resolve(s - l.from, a);
                for (let v of h)
                  if (v.test(p, o)) {
                    let y = o.facet(v.facet);
                    return v.type == "replace" ? y : y.concat(u);
                  }
              }
              return u;
            })
          ].concat(r);
        }
        isActiveAt(e, n, r = -1) {
          return vT(e, n, r).type.prop(kc) == this.data;
        }
        findRegions(e) {
          let n = e.facet(Qo);
          if ((n == null ? void 0 : n.data) == this.data)
            return [
              {
                from: 0,
                to: e.doc.length
              }
            ];
          if (!n || !n.allowsNesting)
            return [];
          let r = [], i = (o, s) => {
            if (o.prop(kc) == this.data) {
              r.push({
                from: s,
                to: s + o.length
              });
              return;
            }
            let a = o.prop($e.mounted);
            if (a) {
              if (a.tree.prop(kc) == this.data) {
                if (a.overlay)
                  for (let l of a.overlay)
                    r.push({
                      from: l.from + s,
                      to: l.to + s
                    });
                else
                  r.push({
                    from: s,
                    to: s + o.length
                  });
                return;
              } else if (a.overlay) {
                let l = r.length;
                if (i(a.tree, a.overlay[0].from + s), r.length > l)
                  return;
              }
            }
            for (let l = 0; l < o.children.length; l++) {
              let c = o.children[l];
              c instanceof dn && i(c, o.positions[l] + s);
            }
          };
          return i(mn(e), 0), r;
        }
        get allowsNesting() {
          return true;
        }
      }
      $r.setState = Pe.define();
      function vT(t, e, n) {
        let r = t.facet(Qo), i = mn(t).topNode;
        if (!r || r.allowsNesting)
          for (let o = i; o; o = o.enter(e, n, Jt.ExcludeBuffers))
            o.type.isTop && (i = o);
        return i;
      }
      function mn(t) {
        let e = t.field($r.state, false);
        return e ? e.tree : dn.empty;
      }
      function DR(t, e, n = 50) {
        var r;
        let i = (r = t.field($r.state, false)) === null || r === void 0 ? void 0 : r.context;
        if (!i)
          return null;
        let o = i.viewport;
        i.updateViewport({
          from: 0,
          to: e
        });
        let s = i.isDone(e) || i.work(n, e) ? i.tree : null;
        return i.updateViewport(o), s;
      }
      class qK {
        constructor(e) {
          this.doc = e, this.cursorPos = 0, this.string = "", this.cursor = e.iter();
        }
        get length() {
          return this.doc.length;
        }
        syncTo(e) {
          return this.string = this.cursor.next(e - this.cursorPos).value, this.cursorPos = e + this.string.length, this.cursorPos - this.string.length;
        }
        chunk(e) {
          return this.syncTo(e), this.string;
        }
        get lineChunks() {
          return true;
        }
        read(e, n) {
          let r = this.cursorPos - this.string.length;
          return e < r || n >= this.cursorPos ? this.doc.sliceString(e, n) : this.string.slice(e - r, n - r);
        }
      }
      let ac = null;
      class Ep {
        constructor(e, n, r = [], i, o, s, a, l) {
          this.parser = e, this.state = n, this.fragments = r, this.tree = i, this.treeLen = o, this.viewport = s, this.skipped = a, this.scheduleOn = l, this.parse = null, this.tempSkipped = [];
        }
        static create(e, n, r) {
          return new Ep(e, n, [], dn.empty, 0, r, [], null);
        }
        startParse() {
          return this.parser.startParse(new qK(this.state.doc), this.fragments);
        }
        work(e, n) {
          return n != null && n >= this.state.doc.length && (n = void 0), this.tree != dn.empty && this.isDone(n ?? this.state.doc.length) ? (this.takeTree(), true) : this.withContext(() => {
            var r;
            if (typeof e == "number") {
              let i = Date.now() + e;
              e = () => Date.now() > i;
            }
            for (this.parse || (this.parse = this.startParse()), n != null && (this.parse.stoppedAt == null || this.parse.stoppedAt > n) && n < this.state.doc.length && this.parse.stopAt(n); ; ) {
              let i = this.parse.advance();
              if (i)
                if (this.fragments = this.withoutTempSkipped(_s.addTree(i, this.fragments, this.parse.stoppedAt != null)), this.treeLen = (r = this.parse.stoppedAt) !== null && r !== void 0 ? r : this.state.doc.length, this.tree = i, this.parse = null, this.treeLen < (n ?? this.state.doc.length))
                  this.parse = this.startParse();
                else
                  return true;
              if (e())
                return false;
            }
          });
        }
        takeTree() {
          let e, n;
          this.parse && (e = this.parse.parsedPos) >= this.treeLen && ((this.parse.stoppedAt == null || this.parse.stoppedAt > e) && this.parse.stopAt(e), this.withContext(() => {
            for (; !(n = this.parse.advance()); )
              ;
          }), this.treeLen = e, this.tree = n, this.fragments = this.withoutTempSkipped(_s.addTree(this.tree, this.fragments, true)), this.parse = null);
        }
        withContext(e) {
          let n = ac;
          ac = this;
          try {
            return e();
          } finally {
            ac = n;
          }
        }
        withoutTempSkipped(e) {
          for (let n; n = this.tempSkipped.pop(); )
            e = yT(e, n.from, n.to);
          return e;
        }
        changes(e, n) {
          let { fragments: r, tree: i, treeLen: o, viewport: s, skipped: a } = this;
          if (this.takeTree(), !e.empty) {
            let l = [];
            if (e.iterChangedRanges((c, u, h, p) => l.push({
              fromA: c,
              toA: u,
              fromB: h,
              toB: p
            })), r = _s.applyChanges(r, l), i = dn.empty, o = 0, s = {
              from: e.mapPos(s.from, -1),
              to: e.mapPos(s.to, 1)
            }, this.skipped.length) {
              a = [];
              for (let c of this.skipped) {
                let u = e.mapPos(c.from, 1), h = e.mapPos(c.to, -1);
                u < h && a.push({
                  from: u,
                  to: h
                });
              }
            }
          }
          return new Ep(this.parser, n, r, i, o, s, a, this.scheduleOn);
        }
        updateViewport(e) {
          if (this.viewport.from == e.from && this.viewport.to == e.to)
            return false;
          this.viewport = e;
          let n = this.skipped.length;
          for (let r = 0; r < this.skipped.length; r++) {
            let { from: i, to: o } = this.skipped[r];
            i < e.to && o > e.from && (this.fragments = yT(this.fragments, i, o), this.skipped.splice(r--, 1));
          }
          return this.skipped.length >= n ? false : (this.reset(), true);
        }
        reset() {
          this.parse && (this.takeTree(), this.parse = null);
        }
        skipUntilInView(e, n) {
          this.skipped.push({
            from: e,
            to: n
          });
        }
        static getSkippingParser(e) {
          return new class extends IK {
            createParse(n, r, i) {
              let o = i[0].from, s = i[i.length - 1].to;
              return {
                parsedPos: o,
                advance() {
                  let l = ac;
                  if (l) {
                    for (let c of i)
                      l.tempSkipped.push(c);
                    e && (l.scheduleOn = l.scheduleOn ? Promise.all([
                      l.scheduleOn,
                      e
                    ]) : e);
                  }
                  return this.parsedPos = s, new dn(Cr.none, [], [], s - o);
                },
                stoppedAt: null,
                stopAt() {
                }
              };
            }
          }();
        }
        isDone(e) {
          e = Math.min(e, this.state.doc.length);
          let n = this.fragments;
          return this.treeLen >= e && n.length && n[0].from == 0 && n[0].to >= e;
        }
        static get() {
          return ac;
        }
      }
      function yT(t, e, n) {
        return _s.applyChanges(t, [
          {
            fromA: e,
            toA: n,
            fromB: e,
            toB: n
          }
        ]);
      }
      class vl {
        constructor(e) {
          this.context = e, this.tree = e.tree;
        }
        apply(e) {
          if (!e.docChanged && this.tree == this.context.tree)
            return this;
          let n = this.context.changes(e.changes, e.state), r = this.context.treeLen == e.startState.doc.length ? void 0 : Math.max(e.changes.mapPos(this.context.treeLen), n.viewport.to);
          return n.work(20, r) || n.takeTree(), new vl(n);
        }
        static init(e) {
          let n = Math.min(3e3, e.doc.length), r = Ep.create(e.facet(Qo).parser, e, {
            from: 0,
            to: n
          });
          return r.work(20, n) || r.takeTree(), new vl(r);
        }
      }
      $r.state = Ut.define({
        create: vl.init,
        update(t, e) {
          for (let n of e.effects)
            if (n.is($r.setState))
              return n.value;
          return e.startState.facet(Qo) != e.state.facet(Qo) ? vl.init(e.state) : t.apply(e);
        }
      });
      let _R = (t) => {
        let e = setTimeout(() => t(), 500);
        return () => clearTimeout(e);
      };
      typeof requestIdleCallback < "u" && (_R = (t) => {
        let e = -1, n = setTimeout(() => {
          e = requestIdleCallback(t, {
            timeout: 500 - 100
          });
        }, 100);
        return () => e < 0 ? clearTimeout(n) : cancelIdleCallback(e);
      });
      const K0 = typeof navigator < "u" && ((U0 = navigator.scheduling) === null || U0 === void 0 ? void 0 : U0.isInputPending) ? () => navigator.scheduling.isInputPending() : null, GK = Ct.fromClass(class {
        constructor(e) {
          this.view = e, this.working = null, this.workScheduled = 0, this.chunkEnd = -1, this.chunkBudget = -1, this.work = this.work.bind(this), this.scheduleWork();
        }
        update(e) {
          let n = this.view.state.field($r.state).context;
          (n.updateViewport(e.view.viewport) || this.view.viewport.to > n.treeLen) && this.scheduleWork(), (e.docChanged || e.selectionSet) && (this.view.hasFocus && (this.chunkBudget += 50), this.scheduleWork()), this.checkAsyncSchedule(n);
        }
        scheduleWork() {
          if (this.working)
            return;
          let { state: e } = this.view, n = e.field($r.state);
          (n.tree != n.context.tree || !n.context.isDone(e.doc.length)) && (this.working = _R(this.work));
        }
        work(e) {
          this.working = null;
          let n = Date.now();
          if (this.chunkEnd < n && (this.chunkEnd < 0 || this.view.hasFocus) && (this.chunkEnd = n + 3e4, this.chunkBudget = 3e3), this.chunkBudget <= 0)
            return;
          let { state: r, viewport: { to: i } } = this.view, o = r.field($r.state);
          if (o.tree == o.context.tree && o.context.isDone(i + 1e5))
            return;
          let s = Date.now() + Math.min(this.chunkBudget, 100, e && !K0 ? Math.max(25, e.timeRemaining() - 5) : 1e9), a = o.context.treeLen < i && r.doc.length > i + 1e3, l = o.context.work(() => K0 && K0() || Date.now() > s, i + (a ? 0 : 1e5));
          this.chunkBudget -= Date.now() - n, (l || this.chunkBudget <= 0) && (o.context.takeTree(), this.view.dispatch({
            effects: $r.setState.of(new vl(o.context))
          })), this.chunkBudget > 0 && !(l && !a) && this.scheduleWork(), this.checkAsyncSchedule(o.context);
        }
        checkAsyncSchedule(e) {
          e.scheduleOn && (this.workScheduled++, e.scheduleOn.then(() => this.scheduleWork()).catch((n) => Bn(this.view.state, n)).then(() => this.workScheduled--), e.scheduleOn = null);
        }
        destroy() {
          this.working && this.working();
        }
        isWorking() {
          return !!(this.working || this.workScheduled > 0);
        }
      }, {
        eventHandlers: {
          focus() {
            this.scheduleWork();
          }
        }
      }), Qo = pe.define({
        combine(t) {
          return t.length ? t[0] : null;
        },
        enables: (t) => [
          $r.state,
          GK,
          ce.contentAttributes.compute([
            t
          ], (e) => {
            let n = e.facet(t);
            return n && n.name ? {
              "data-language": n.name
            } : {};
          })
        ]
      }), YK = pe.define(), yl = pe.define({
        combine: (t) => {
          if (!t.length)
            return "  ";
          let e = t[0];
          if (!e || /\S/.test(e) || Array.from(e).some((n) => n != e[0]))
            throw new Error("Invalid indent unit: " + JSON.stringify(t[0]));
          return e;
        }
      });
      function Pp(t) {
        let e = t.facet(yl);
        return e.charCodeAt(0) == 9 ? t.tabSize * e.length : e.length;
      }
      function zu(t, e) {
        let n = "", r = t.tabSize, i = t.facet(yl)[0];
        if (i == "	") {
          for (; e >= r; )
            n += "	", e -= r;
          i = " ";
        }
        for (let o = 0; o < e; o++)
          n += i;
        return n;
      }
      function Fx(t, e) {
        t instanceof Ne && (t = new Wm(t));
        for (let r of t.state.facet(YK)) {
          let i = r(t, e);
          if (i !== void 0)
            return i;
        }
        let n = mn(t.state);
        return n.length >= e ? QK(t, n, e) : null;
      }
      class Wm {
        constructor(e, n = {}) {
          this.state = e, this.options = n, this.unit = Pp(e);
        }
        lineAt(e, n = 1) {
          let r = this.state.doc.lineAt(e), { simulateBreak: i, simulateDoubleBreak: o } = this.options;
          return i != null && i >= r.from && i <= r.to ? o && i == e ? {
            text: "",
            from: e
          } : (n < 0 ? i < e : i <= e) ? {
            text: r.text.slice(i - r.from),
            from: i
          } : {
            text: r.text.slice(0, i - r.from),
            from: r.from
          } : r;
        }
        textAfterPos(e, n = 1) {
          if (this.options.simulateDoubleBreak && e == this.options.simulateBreak)
            return "";
          let { text: r, from: i } = this.lineAt(e, n);
          return r.slice(e - i, Math.min(r.length, e + 100 - i));
        }
        column(e, n = 1) {
          let { text: r, from: i } = this.lineAt(e, n), o = this.countColumn(r, e - i), s = this.options.overrideIndentation ? this.options.overrideIndentation(i) : -1;
          return s > -1 && (o += s - this.countColumn(r, r.search(/\S|$/))), o;
        }
        countColumn(e, n = e.length) {
          return Al(e, this.state.tabSize, n);
        }
        lineIndent(e, n = 1) {
          let { text: r, from: i } = this.lineAt(e, n), o = this.options.overrideIndentation;
          if (o) {
            let s = o(i);
            if (s > -1)
              return s;
          }
          return this.countColumn(r, r.search(/\S|$/));
        }
        get simulatedBreak() {
          return this.options.simulateBreak || null;
        }
      }
      const XK = new $e();
      function QK(t, e, n) {
        let r = e.resolveStack(n), i = e.resolveInner(n, -1).resolve(n, 0).enterUnfinishedNodesBefore(n);
        if (i != r.node) {
          let o = [];
          for (let s = i; s && !(s.from == r.node.from && s.type == r.node.type); s = s.parent)
            o.push(s);
          for (let s = o.length - 1; s >= 0; s--)
            r = {
              node: o[s],
              next: r
            };
        }
        return IR(r, t, n);
      }
      function IR(t, e, n) {
        for (let r = t; r; r = r.next) {
          let i = ZK(r.node);
          if (i)
            return i(Vx.create(e, n, r));
        }
        return 0;
      }
      function JK(t) {
        return t.pos == t.options.simulateBreak && t.options.simulateDoubleBreak;
      }
      function ZK(t) {
        let e = t.type.prop(XK);
        if (e)
          return e;
        let n = t.firstChild, r;
        if (n && (r = n.type.prop($e.closedBy))) {
          let i = t.lastChild, o = i && r.indexOf(i.name) > -1;
          return (s) => rq(s, true, 1, void 0, o && !JK(s) ? i.from : void 0);
        }
        return t.parent == null ? eq : null;
      }
      function eq() {
        return 0;
      }
      class Vx extends Wm {
        constructor(e, n, r) {
          super(e.state, e.options), this.base = e, this.pos = n, this.context = r;
        }
        get node() {
          return this.context.node;
        }
        static create(e, n, r) {
          return new Vx(e, n, r);
        }
        get textAfter() {
          return this.textAfterPos(this.pos);
        }
        get baseIndent() {
          return this.baseIndentFor(this.node);
        }
        baseIndentFor(e) {
          let n = this.state.doc.lineAt(e.from);
          for (; ; ) {
            let r = e.resolve(n.from);
            for (; r.parent && r.parent.from == r.from; )
              r = r.parent;
            if (tq(r, e))
              break;
            n = this.state.doc.lineAt(r.from);
          }
          return this.lineIndent(n.from);
        }
        continue() {
          return IR(this.context.next, this.base, this.pos);
        }
      }
      function tq(t, e) {
        for (let n = e; n; n = n.parent)
          if (t == n)
            return true;
        return false;
      }
      function nq(t) {
        let e = t.node, n = e.childAfter(e.from), r = e.lastChild;
        if (!n)
          return null;
        let i = t.options.simulateBreak, o = t.state.doc.lineAt(n.from), s = i == null || i <= o.from ? o.to : Math.min(o.to, i);
        for (let a = n.to; ; ) {
          let l = e.childAfter(a);
          if (!l || l == r)
            return null;
          if (!l.type.isSkipped) {
            if (l.from >= s)
              return null;
            let c = /^ */.exec(o.text.slice(n.to - o.from))[0].length;
            return {
              from: n.from,
              to: n.to + c
            };
          }
          a = l.to;
        }
      }
      function rq(t, e, n, r, i) {
        let o = t.textAfter, s = o.match(/^\s*/)[0].length, a = r && o.slice(s, s + r.length) == r || i == t.pos + s, l = e ? nq(t) : null;
        return l ? a ? t.column(l.from) : t.column(l.to) : t.baseIndent + (a ? 0 : t.unit * n);
      }
      const iq = 200;
      function oq() {
        return Ne.transactionFilter.of((t) => {
          if (!t.docChanged || !t.isUserEvent("input.type") && !t.isUserEvent("input.complete"))
            return t;
          let e = t.startState.languageDataAt("indentOnInput", t.startState.selection.main.head);
          if (!e.length)
            return t;
          let n = t.newDoc, { head: r } = t.newSelection.main, i = n.lineAt(r);
          if (r > i.from + iq)
            return t;
          let o = n.sliceString(i.from, r);
          if (!e.some((c) => c.test(o)))
            return t;
          let { state: s } = t, a = -1, l = [];
          for (let { head: c } of s.selection.ranges) {
            let u = s.doc.lineAt(c);
            if (u.from == a)
              continue;
            a = u.from;
            let h = Fx(s, u.from);
            if (h == null)
              continue;
            let p = /^\s*/.exec(u.text)[0], v = zu(s, h);
            p != v && l.push({
              from: u.from,
              to: u.from + p.length,
              insert: v
            });
          }
          return l.length ? [
            t,
            {
              changes: l,
              sequential: true
            }
          ] : t;
        });
      }
      const sq = pe.define(), aq = new $e();
      function lq(t, e, n) {
        let r = mn(t);
        if (r.length < n)
          return null;
        let i = r.resolveStack(n, 1), o = null;
        for (let s = i; s; s = s.next) {
          let a = s.node;
          if (a.to <= n || a.from > n)
            continue;
          if (o && a.from < e)
            break;
          let l = a.type.prop(aq);
          if (l && (a.to < r.length - 50 || r.length == t.doc.length || !cq(a))) {
            let c = l(a, t);
            c && c.from <= n && c.from >= e && c.to > n && (o = c);
          }
        }
        return o;
      }
      function cq(t) {
        let e = t.lastChild;
        return e && e.to == t.to && e.type.isError;
      }
      function Op(t, e, n) {
        for (let r of t.facet(sq)) {
          let i = r(t, e, n);
          if (i)
            return i;
        }
        return lq(t, e, n);
      }
      function BR(t, e) {
        let n = e.mapPos(t.from, 1), r = e.mapPos(t.to, -1);
        return n >= r ? void 0 : {
          from: n,
          to: r
        };
      }
      const Um = Pe.define({
        map: BR
      }), lf = Pe.define({
        map: BR
      });
      function NR(t) {
        let e = [];
        for (let { head: n } of t.state.selection.ranges)
          e.some((r) => r.from <= n && r.to >= n) || e.push(t.lineBlockAt(n));
        return e;
      }
      const qs = Ut.define({
        create() {
          return be.none;
        },
        update(t, e) {
          t = t.map(e.changes);
          for (let n of e.effects)
            if (n.is(Um) && !uq(t, n.value.from, n.value.to)) {
              let { preparePlaceholder: r } = e.state.facet(Hx), i = r ? be.replace({
                widget: new gq(r(e.state, n.value))
              }) : bT;
              t = t.update({
                add: [
                  i.range(n.value.from, n.value.to)
                ]
              });
            } else
              n.is(lf) && (t = t.update({
                filter: (r, i) => n.value.from != r || n.value.to != i,
                filterFrom: n.value.from,
                filterTo: n.value.to
              }));
          if (e.selection) {
            let n = false, { head: r } = e.selection.main;
            t.between(r, r, (i, o) => {
              i < r && o > r && (n = true);
            }), n && (t = t.update({
              filterFrom: r,
              filterTo: r,
              filter: (i, o) => o <= r || i >= r
            }));
          }
          return t;
        },
        provide: (t) => ce.decorations.from(t),
        toJSON(t, e) {
          let n = [];
          return t.between(0, e.doc.length, (r, i) => {
            n.push(r, i);
          }), n;
        },
        fromJSON(t) {
          if (!Array.isArray(t) || t.length % 2)
            throw new RangeError("Invalid JSON for fold state");
          let e = [];
          for (let n = 0; n < t.length; ) {
            let r = t[n++], i = t[n++];
            if (typeof r != "number" || typeof i != "number")
              throw new RangeError("Invalid JSON for fold state");
            e.push(bT.range(r, i));
          }
          return be.set(e, true);
        }
      });
      function Rp(t, e, n) {
        var r;
        let i = null;
        return (r = t.field(qs, false)) === null || r === void 0 || r.between(e, n, (o, s) => {
          (!i || i.from > o) && (i = {
            from: o,
            to: s
          });
        }), i;
      }
      function uq(t, e, n) {
        let r = false;
        return t.between(e, e, (i, o) => {
          i == e && o == n && (r = true);
        }), r;
      }
      function $R(t, e) {
        return t.field(qs, false) ? e : e.concat(Pe.appendConfig.of(VR()));
      }
      const zR = (t) => {
        for (let e of NR(t)) {
          let n = Op(t.state, e.from, e.to);
          if (n)
            return t.dispatch({
              effects: $R(t.state, [
                Um.of(n),
                FR(t, n)
              ])
            }), true;
        }
        return false;
      }, fq = (t) => {
        if (!t.state.field(qs, false))
          return false;
        let e = [];
        for (let n of NR(t)) {
          let r = Rp(t.state, n.from, n.to);
          r && e.push(lf.of(r), FR(t, r, false));
        }
        return e.length && t.dispatch({
          effects: e
        }), e.length > 0;
      };
      function FR(t, e, n = true) {
        let r = t.state.doc.lineAt(e.from).number, i = t.state.doc.lineAt(e.to).number;
        return ce.announce.of(`${t.state.phrase(n ? "Folded lines" : "Unfolded lines")} ${r} ${t.state.phrase("to")} ${i}.`);
      }
      const hq = (t) => {
        let { state: e } = t, n = [];
        for (let r = 0; r < e.doc.length; ) {
          let i = t.lineBlockAt(r), o = Op(e, i.from, i.to);
          o && n.push(Um.of(o)), r = (o ? t.lineBlockAt(o.to) : i).to + 1;
        }
        return n.length && t.dispatch({
          effects: $R(t.state, n)
        }), !!n.length;
      }, dq = (t) => {
        let e = t.state.field(qs, false);
        if (!e || !e.size)
          return false;
        let n = [];
        return e.between(0, t.state.doc.length, (r, i) => {
          n.push(lf.of({
            from: r,
            to: i
          }));
        }), t.dispatch({
          effects: n
        }), true;
      }, pq = [
        {
          key: "Ctrl-Shift-[",
          mac: "Cmd-Alt-[",
          run: zR
        },
        {
          key: "Ctrl-Shift-]",
          mac: "Cmd-Alt-]",
          run: fq
        },
        {
          key: "Ctrl-Alt-[",
          run: hq
        },
        {
          key: "Ctrl-Alt-]",
          run: dq
        }
      ], mq = {
        placeholderDOM: null,
        preparePlaceholder: null,
        placeholderText: "\u2026"
      }, Hx = pe.define({
        combine(t) {
          return Ei(t, mq);
        }
      });
      function VR(t) {
        let e = [
          qs,
          bq
        ];
        return t && e.push(Hx.of(t)), e;
      }
      function HR(t, e) {
        let { state: n } = t, r = n.facet(Hx), i = (s) => {
          let a = t.lineBlockAt(t.posAtDOM(s.target)), l = Rp(t.state, a.from, a.to);
          l && t.dispatch({
            effects: lf.of(l)
          }), s.preventDefault();
        };
        if (r.placeholderDOM)
          return r.placeholderDOM(t, i, e);
        let o = document.createElement("span");
        return o.textContent = r.placeholderText, o.setAttribute("aria-label", n.phrase("folded code")), o.title = n.phrase("unfold"), o.className = "cm-foldPlaceholder", o.onclick = i, o;
      }
      const bT = be.replace({
        widget: new class extends oo {
          toDOM(t) {
            return HR(t, null);
          }
        }()
      });
      class gq extends oo {
        constructor(e) {
          super(), this.value = e;
        }
        eq(e) {
          return this.value == e.value;
        }
        toDOM(e) {
          return HR(e, this.value);
        }
      }
      const vq = {
        openText: "\u2304",
        closedText: "\u203A",
        markerDOM: null,
        domEventHandlers: {},
        foldingChanged: () => false
      };
      class q0 extends ro {
        constructor(e, n) {
          super(), this.config = e, this.open = n;
        }
        eq(e) {
          return this.config == e.config && this.open == e.open;
        }
        toDOM(e) {
          if (this.config.markerDOM)
            return this.config.markerDOM(this.open);
          let n = document.createElement("span");
          return n.textContent = this.open ? this.config.openText : this.config.closedText, n.title = e.state.phrase(this.open ? "Fold line" : "Unfold line"), n;
        }
      }
      function yq(t = {}) {
        let e = Object.assign(Object.assign({}, vq), t), n = new q0(e, true), r = new q0(e, false), i = Ct.fromClass(class {
          constructor(s) {
            this.from = s.viewport.from, this.markers = this.buildMarkers(s);
          }
          update(s) {
            (s.docChanged || s.viewportChanged || s.startState.facet(Qo) != s.state.facet(Qo) || s.startState.field(qs, false) != s.state.field(qs, false) || mn(s.startState) != mn(s.state) || e.foldingChanged(s)) && (this.markers = this.buildMarkers(s.view));
          }
          buildMarkers(s) {
            let a = new Ci();
            for (let l of s.viewportLineBlocks) {
              let c = Rp(s.state, l.from, l.to) ? r : Op(s.state, l.from, l.to) ? n : null;
              c && a.add(l.from, l.from, c);
            }
            return a.finish();
          }
        }), { domEventHandlers: o } = e;
        return [
          i,
          vK({
            class: "cm-foldGutter",
            markers(s) {
              var a;
              return ((a = s.plugin(i)) === null || a === void 0 ? void 0 : a.markers) || Ve.empty;
            },
            initialSpacer() {
              return new q0(e, false);
            },
            domEventHandlers: Object.assign(Object.assign({}, o), {
              click: (s, a, l) => {
                if (o.click && o.click(s, a, l))
                  return true;
                let c = Rp(s.state, a.from, a.to);
                if (c)
                  return s.dispatch({
                    effects: lf.of(c)
                  }), true;
                let u = Op(s.state, a.from, a.to);
                return u ? (s.dispatch({
                  effects: Um.of(u)
                }), true) : false;
              }
            })
          }),
          VR()
        ];
      }
      const bq = ce.baseTheme({
        ".cm-foldPlaceholder": {
          backgroundColor: "#eee",
          border: "1px solid #ddd",
          color: "#888",
          borderRadius: ".2em",
          margin: "0 1px",
          padding: "0 1px",
          cursor: "pointer"
        },
        ".cm-foldGutter span": {
          padding: "0 1px",
          cursor: "pointer"
        }
      });
      class cf {
        constructor(e, n) {
          this.specs = e;
          let r;
          function i(a) {
            let l = qo.newName();
            return (r || (r = /* @__PURE__ */ Object.create(null)))["." + l] = a, l;
          }
          const o = typeof n.all == "string" ? n.all : n.all ? i(n.all) : void 0, s = n.scope;
          this.scope = s instanceof $r ? (a) => a.prop(kc) == s.data : s ? (a) => a == s : void 0, this.style = LR(e.map((a) => ({
            tag: a.tag,
            class: a.class || i(Object.assign({}, a, {
              tag: null
            }))
          })), {
            all: o
          }).style, this.module = r ? new qo(r) : null, this.themeType = n.themeType;
        }
        static define(e, n) {
          return new cf(e, n || {});
        }
      }
      const v1 = pe.define(), jR = pe.define({
        combine(t) {
          return t.length ? [
            t[0]
          ] : null;
        }
      });
      function G0(t) {
        let e = t.facet(v1);
        return e.length ? e : t.facet(jR);
      }
      function WR(t, e) {
        let n = [
          Sq
        ], r;
        return t instanceof cf && (t.module && n.push(ce.styleModule.of(t.module)), r = t.themeType), (e == null ? void 0 : e.fallback) ? n.push(jR.of(t)) : r ? n.push(v1.computeN([
          ce.darkTheme
        ], (i) => i.facet(ce.darkTheme) == (r == "dark") ? [
          t
        ] : [])) : n.push(v1.of(t)), n;
      }
      class xq {
        constructor(e) {
          this.markCache = /* @__PURE__ */ Object.create(null), this.tree = mn(e.state), this.decorations = this.buildDeco(e, G0(e.state)), this.decoratedTo = e.viewport.to;
        }
        update(e) {
          let n = mn(e.state), r = G0(e.state), i = r != G0(e.startState), { viewport: o } = e.view, s = e.changes.mapPos(this.decoratedTo, 1);
          n.length < o.to && !i && n.type == this.tree.type && s >= o.to ? (this.decorations = this.decorations.map(e.changes), this.decoratedTo = s) : (n != this.tree || e.viewportChanged || i) && (this.tree = n, this.decorations = this.buildDeco(e.view, r), this.decoratedTo = o.to);
        }
        buildDeco(e, n) {
          if (!n || !this.tree.length)
            return be.none;
          let r = new Ci();
          for (let { from: i, to: o } of e.visibleRanges)
            jK(this.tree, n, (s, a, l) => {
              r.add(s, a, this.markCache[l] || (this.markCache[l] = be.mark({
                class: l
              })));
            }, i, o);
          return r.finish();
        }
      }
      const Sq = ns.high(Ct.fromClass(xq, {
        decorations: (t) => t.decorations
      })), wq = cf.define([
        {
          tag: G.meta,
          color: "#404740"
        },
        {
          tag: G.link,
          textDecoration: "underline"
        },
        {
          tag: G.heading,
          textDecoration: "underline",
          fontWeight: "bold"
        },
        {
          tag: G.emphasis,
          fontStyle: "italic"
        },
        {
          tag: G.strong,
          fontWeight: "bold"
        },
        {
          tag: G.strikethrough,
          textDecoration: "line-through"
        },
        {
          tag: G.keyword,
          color: "#708"
        },
        {
          tag: [
            G.atom,
            G.bool,
            G.url,
            G.contentSeparator,
            G.labelName
          ],
          color: "#219"
        },
        {
          tag: [
            G.literal,
            G.inserted
          ],
          color: "#164"
        },
        {
          tag: [
            G.string,
            G.deleted
          ],
          color: "#a11"
        },
        {
          tag: [
            G.regexp,
            G.escape,
            G.special(G.string)
          ],
          color: "#e40"
        },
        {
          tag: G.definition(G.variableName),
          color: "#00f"
        },
        {
          tag: G.local(G.variableName),
          color: "#30a"
        },
        {
          tag: [
            G.typeName,
            G.namespace
          ],
          color: "#085"
        },
        {
          tag: G.className,
          color: "#167"
        },
        {
          tag: [
            G.special(G.variableName),
            G.macroName
          ],
          color: "#256"
        },
        {
          tag: G.definition(G.propertyName),
          color: "#00c"
        },
        {
          tag: G.comment,
          color: "#940"
        },
        {
          tag: G.invalid,
          color: "#f00"
        }
      ]), kq = ce.baseTheme({
        "&.cm-focused .cm-matchingBracket": {
          backgroundColor: "#328c8252"
        },
        "&.cm-focused .cm-nonmatchingBracket": {
          backgroundColor: "#bb555544"
        }
      }), UR = 1e4, KR = "()[]{}", qR = pe.define({
        combine(t) {
          return Ei(t, {
            afterCursor: true,
            brackets: KR,
            maxScanDistance: UR,
            renderMatch: Mq
          });
        }
      }), Cq = be.mark({
        class: "cm-matchingBracket"
      }), Tq = be.mark({
        class: "cm-nonmatchingBracket"
      });
      function Mq(t) {
        let e = [], n = t.matched ? Cq : Tq;
        return e.push(n.range(t.start.from, t.start.to)), t.end && e.push(n.range(t.end.from, t.end.to)), e;
      }
      const Aq = Ut.define({
        create() {
          return be.none;
        },
        update(t, e) {
          if (!e.docChanged && !e.selection)
            return t;
          let n = [], r = e.state.facet(qR);
          for (let i of e.state.selection.ranges) {
            if (!i.empty)
              continue;
            let o = mr(e.state, i.head, -1, r) || i.head > 0 && mr(e.state, i.head - 1, 1, r) || r.afterCursor && (mr(e.state, i.head, 1, r) || i.head < e.state.doc.length && mr(e.state, i.head + 1, -1, r));
            o && (n = n.concat(r.renderMatch(o, e.state)));
          }
          return be.set(n, true);
        },
        provide: (t) => ce.decorations.from(t)
      }), Eq = [
        Aq,
        kq
      ];
      function Pq(t = {}) {
        return [
          qR.of(t),
          Eq
        ];
      }
      const Oq = new $e();
      function y1(t, e, n) {
        let r = t.prop(e < 0 ? $e.openedBy : $e.closedBy);
        if (r)
          return r;
        if (t.name.length == 1) {
          let i = n.indexOf(t.name);
          if (i > -1 && i % 2 == (e < 0 ? 1 : 0))
            return [
              n[i + e]
            ];
        }
        return null;
      }
      function b1(t) {
        let e = t.type.prop(Oq);
        return e ? e(t.node) : t;
      }
      function mr(t, e, n, r = {}) {
        let i = r.maxScanDistance || UR, o = r.brackets || KR, s = mn(t), a = s.resolveInner(e, n);
        for (let l = a; l; l = l.parent) {
          let c = y1(l.type, n, o);
          if (c && l.from < l.to) {
            let u = b1(l);
            if (u && (n > 0 ? e >= u.from && e < u.to : e > u.from && e <= u.to))
              return Rq(t, e, n, l, u, c, o);
          }
        }
        return Lq(t, e, n, s, a.type, i, o);
      }
      function Rq(t, e, n, r, i, o, s) {
        let a = r.parent, l = {
          from: i.from,
          to: i.to
        }, c = 0, u = a == null ? void 0 : a.cursor();
        if (u && (n < 0 ? u.childBefore(r.from) : u.childAfter(r.to)))
          do
            if (n < 0 ? u.to <= r.from : u.from >= r.to) {
              if (c == 0 && o.indexOf(u.type.name) > -1 && u.from < u.to) {
                let h = b1(u);
                return {
                  start: l,
                  end: h ? {
                    from: h.from,
                    to: h.to
                  } : void 0,
                  matched: true
                };
              } else if (y1(u.type, n, s))
                c++;
              else if (y1(u.type, -n, s)) {
                if (c == 0) {
                  let h = b1(u);
                  return {
                    start: l,
                    end: h && h.from < h.to ? {
                      from: h.from,
                      to: h.to
                    } : void 0,
                    matched: false
                  };
                }
                c--;
              }
            }
          while (n < 0 ? u.prevSibling() : u.nextSibling());
        return {
          start: l,
          matched: false
        };
      }
      function Lq(t, e, n, r, i, o, s) {
        let a = n < 0 ? t.sliceDoc(e - 1, e) : t.sliceDoc(e, e + 1), l = s.indexOf(a);
        if (l < 0 || l % 2 == 0 != n > 0)
          return null;
        let c = {
          from: n < 0 ? e - 1 : e,
          to: n > 0 ? e + 1 : e
        }, u = t.doc.iterRange(e, n > 0 ? t.doc.length : 0), h = 0;
        for (let p = 0; !u.next().done && p <= o; ) {
          let v = u.value;
          n < 0 && (p += v.length);
          let y = e + p * n;
          for (let S = n > 0 ? 0 : v.length - 1, C = n > 0 ? v.length : -1; S != C; S += n) {
            let w = s.indexOf(v[S]);
            if (!(w < 0 || r.resolveInner(y + S, 1).type != i))
              if (w % 2 == 0 == n > 0)
                h++;
              else {
                if (h == 1)
                  return {
                    start: c,
                    end: {
                      from: y + S,
                      to: y + S + 1
                    },
                    matched: w >> 1 == l >> 1
                  };
                h--;
              }
          }
          n > 0 && (p += v.length);
        }
        return u.done ? {
          start: c,
          matched: false
        } : null;
      }
      function xT(t, e, n, r = 0, i = 0) {
        e == null && (e = t.search(/[^\s\u00a0]/), e == -1 && (e = t.length));
        let o = i;
        for (let s = r; s < e; s++)
          t.charCodeAt(s) == 9 ? o += n - o % n : o++;
        return o;
      }
      class Dq {
        constructor(e, n, r, i) {
          this.string = e, this.tabSize = n, this.indentUnit = r, this.overrideIndent = i, this.pos = 0, this.start = 0, this.lastColumnPos = 0, this.lastColumnValue = 0;
        }
        eol() {
          return this.pos >= this.string.length;
        }
        sol() {
          return this.pos == 0;
        }
        peek() {
          return this.string.charAt(this.pos) || void 0;
        }
        next() {
          if (this.pos < this.string.length)
            return this.string.charAt(this.pos++);
        }
        eat(e) {
          let n = this.string.charAt(this.pos), r;
          if (typeof e == "string" ? r = n == e : r = n && (e instanceof RegExp ? e.test(n) : e(n)), r)
            return ++this.pos, n;
        }
        eatWhile(e) {
          let n = this.pos;
          for (; this.eat(e); )
            ;
          return this.pos > n;
        }
        eatSpace() {
          let e = this.pos;
          for (; /[\s\u00a0]/.test(this.string.charAt(this.pos)); )
            ++this.pos;
          return this.pos > e;
        }
        skipToEnd() {
          this.pos = this.string.length;
        }
        skipTo(e) {
          let n = this.string.indexOf(e, this.pos);
          if (n > -1)
            return this.pos = n, true;
        }
        backUp(e) {
          this.pos -= e;
        }
        column() {
          return this.lastColumnPos < this.start && (this.lastColumnValue = xT(this.string, this.start, this.tabSize, this.lastColumnPos, this.lastColumnValue), this.lastColumnPos = this.start), this.lastColumnValue;
        }
        indentation() {
          var e;
          return (e = this.overrideIndent) !== null && e !== void 0 ? e : xT(this.string, null, this.tabSize);
        }
        match(e, n, r) {
          if (typeof e == "string") {
            let i = (s) => r ? s.toLowerCase() : s, o = this.string.substr(this.pos, e.length);
            return i(o) == i(e) ? (n !== false && (this.pos += e.length), true) : null;
          } else {
            let i = this.string.slice(this.pos).match(e);
            return i && i.index > 0 ? null : (i && n !== false && (this.pos += i[0].length), i);
          }
        }
        current() {
          return this.string.slice(this.start, this.pos);
        }
      }
      const _q = /* @__PURE__ */ Object.create(null), ST = [
        Cr.none
      ], wT = [], kT = /* @__PURE__ */ Object.create(null), Iq = /* @__PURE__ */ Object.create(null);
      for (let [t, e] of [
        [
          "variable",
          "variableName"
        ],
        [
          "variable-2",
          "variableName.special"
        ],
        [
          "string-2",
          "string.special"
        ],
        [
          "def",
          "variableName.definition"
        ],
        [
          "tag",
          "tagName"
        ],
        [
          "attribute",
          "attributeName"
        ],
        [
          "type",
          "typeName"
        ],
        [
          "builtin",
          "variableName.standard"
        ],
        [
          "qualifier",
          "modifier"
        ],
        [
          "error",
          "invalid"
        ],
        [
          "header",
          "heading"
        ],
        [
          "property",
          "propertyName"
        ]
      ])
        Iq[t] = Bq(_q, e);
      function Y0(t, e) {
        wT.indexOf(t) > -1 || (wT.push(t), console.warn(e));
      }
      function Bq(t, e) {
        let n = [];
        for (let a of e.split(" ")) {
          let l = [];
          for (let c of a.split(".")) {
            let u = t[c] || G[c];
            u ? typeof u == "function" ? l.length ? l = l.map(u) : Y0(c, `Modifier ${c} used at start of tag`) : l.length ? Y0(c, `Tag ${c} used as modifier`) : l = Array.isArray(u) ? u : [
              u
            ] : Y0(c, `Unknown highlighting tag ${c}`);
          }
          for (let c of l)
            n.push(c);
        }
        if (!n.length)
          return 0;
        let r = e.replace(/ /g, "_"), i = r + " " + n.map((a) => a.id), o = kT[i];
        if (o)
          return o.id;
        let s = kT[i] = Cr.define({
          id: ST.length,
          name: r,
          props: [
            VK({
              [r]: n
            })
          ]
        });
        return ST.push(s), s.id;
      }
      rt.RTL, rt.LTR;
      const Nq = (t) => {
        let { state: e } = t, n = e.doc.lineAt(e.selection.main.from), r = Wx(t.state, n.from);
        return r.line ? $q(t) : r.block ? Fq(t) : false;
      };
      function jx(t, e) {
        return ({ state: n, dispatch: r }) => {
          if (n.readOnly)
            return false;
          let i = t(e, n);
          return i ? (r(n.update(i)), true) : false;
        };
      }
      const $q = jx(jq, 0), zq = jx(GR, 0), Fq = jx((t, e) => GR(t, e, Hq(e)), 0);
      function Wx(t, e) {
        let n = t.languageDataAt("commentTokens", e, 1);
        return n.length ? n[0] : {};
      }
      const lc = 50;
      function Vq(t, { open: e, close: n }, r, i) {
        let o = t.sliceDoc(r - lc, r), s = t.sliceDoc(i, i + lc), a = /\s*$/.exec(o)[0].length, l = /^\s*/.exec(s)[0].length, c = o.length - a;
        if (o.slice(c - e.length, c) == e && s.slice(l, l + n.length) == n)
          return {
            open: {
              pos: r - a,
              margin: a && 1
            },
            close: {
              pos: i + l,
              margin: l && 1
            }
          };
        let u, h;
        i - r <= 2 * lc ? u = h = t.sliceDoc(r, i) : (u = t.sliceDoc(r, r + lc), h = t.sliceDoc(i - lc, i));
        let p = /^\s*/.exec(u)[0].length, v = /\s*$/.exec(h)[0].length, y = h.length - v - n.length;
        return u.slice(p, p + e.length) == e && h.slice(y, y + n.length) == n ? {
          open: {
            pos: r + p + e.length,
            margin: /\s/.test(u.charAt(p + e.length)) ? 1 : 0
          },
          close: {
            pos: i - v - n.length,
            margin: /\s/.test(h.charAt(y - 1)) ? 1 : 0
          }
        } : null;
      }
      function Hq(t) {
        let e = [];
        for (let n of t.selection.ranges) {
          let r = t.doc.lineAt(n.from), i = n.to <= r.to ? r : t.doc.lineAt(n.to);
          i.from > r.from && i.from == n.to && (i = n.to == r.to + 1 ? r : t.doc.lineAt(n.to - 1));
          let o = e.length - 1;
          o >= 0 && e[o].to > r.from ? e[o].to = i.to : e.push({
            from: r.from + /^\s*/.exec(r.text)[0].length,
            to: i.to
          });
        }
        return e;
      }
      function GR(t, e, n = e.selection.ranges) {
        let r = n.map((o) => Wx(e, o.from).block);
        if (!r.every((o) => o))
          return null;
        let i = n.map((o, s) => Vq(e, r[s], o.from, o.to));
        if (t != 2 && !i.every((o) => o))
          return {
            changes: e.changes(n.map((o, s) => i[s] ? [] : [
              {
                from: o.from,
                insert: r[s].open + " "
              },
              {
                from: o.to,
                insert: " " + r[s].close
              }
            ]))
          };
        if (t != 1 && i.some((o) => o)) {
          let o = [];
          for (let s = 0, a; s < i.length; s++)
            if (a = i[s]) {
              let l = r[s], { open: c, close: u } = a;
              o.push({
                from: c.pos - l.open.length,
                to: c.pos + c.margin
              }, {
                from: u.pos - u.margin,
                to: u.pos + l.close.length
              });
            }
          return {
            changes: o
          };
        }
        return null;
      }
      function jq(t, e, n = e.selection.ranges) {
        let r = [], i = -1;
        for (let { from: o, to: s } of n) {
          let a = r.length, l = 1e9, c = Wx(e, o).line;
          if (!!c) {
            for (let u = o; u <= s; ) {
              let h = e.doc.lineAt(u);
              if (h.from > i && (o == s || s > h.from)) {
                i = h.from;
                let p = /^\s*/.exec(h.text)[0].length, v = p == h.length, y = h.text.slice(p, p + c.length) == c ? p : -1;
                p < h.text.length && p < l && (l = p), r.push({
                  line: h,
                  comment: y,
                  token: c,
                  indent: p,
                  empty: v,
                  single: false
                });
              }
              u = h.to + 1;
            }
            if (l < 1e9)
              for (let u = a; u < r.length; u++)
                r[u].indent < r[u].line.text.length && (r[u].indent = l);
            r.length == a + 1 && (r[a].single = true);
          }
        }
        if (t != 2 && r.some((o) => o.comment < 0 && (!o.empty || o.single))) {
          let o = [];
          for (let { line: a, token: l, indent: c, empty: u, single: h } of r)
            (h || !u) && o.push({
              from: a.from + c,
              insert: l + " "
            });
          let s = e.changes(o);
          return {
            changes: s,
            selection: e.selection.map(s, 1)
          };
        } else if (t != 1 && r.some((o) => o.comment >= 0)) {
          let o = [];
          for (let { line: s, comment: a, token: l } of r)
            if (a >= 0) {
              let c = s.from + a, u = c + l.length;
              s.text[u - s.from] == " " && u++, o.push({
                from: c,
                to: u
              });
            }
          return {
            changes: o
          };
        }
        return null;
      }
      const x1 = Ai.define(), Wq = Ai.define(), Uq = pe.define(), YR = pe.define({
        combine(t) {
          return Ei(t, {
            minDepth: 100,
            newGroupDelay: 500,
            joinToEvent: (e, n) => n
          }, {
            minDepth: Math.max,
            newGroupDelay: Math.min,
            joinToEvent: (e, n) => (r, i) => e(r, i) || n(r, i)
          });
        }
      }), XR = Ut.define({
        create() {
          return vi.empty;
        },
        update(t, e) {
          let n = e.state.facet(YR), r = e.annotation(x1);
          if (r) {
            let l = Nn.fromTransaction(e, r.selection), c = r.side, u = c == 0 ? t.undone : t.done;
            return l ? u = Dp(u, u.length, n.minDepth, l) : u = JR(u, e.startState.selection), new vi(c == 0 ? r.rest : u, c == 0 ? u : r.rest);
          }
          let i = e.annotation(Wq);
          if ((i == "full" || i == "before") && (t = t.isolate()), e.annotation(Bt.addToHistory) === false)
            return e.changes.empty ? t : t.addMapping(e.changes.desc);
          let o = Nn.fromTransaction(e), s = e.annotation(Bt.time), a = e.annotation(Bt.userEvent);
          return o ? t = t.addChanges(o, s, a, n, e) : e.selection && (t = t.addSelection(e.startState.selection, s, a, n.newGroupDelay)), (i == "full" || i == "after") && (t = t.isolate()), t;
        },
        toJSON(t) {
          return {
            done: t.done.map((e) => e.toJSON()),
            undone: t.undone.map((e) => e.toJSON())
          };
        },
        fromJSON(t) {
          return new vi(t.done.map(Nn.fromJSON), t.undone.map(Nn.fromJSON));
        }
      });
      function Kq(t = {}) {
        return [
          XR,
          YR.of(t),
          ce.domEventHandlers({
            beforeinput(e, n) {
              let r = e.inputType == "historyUndo" ? Ux : e.inputType == "historyRedo" ? Lp : null;
              return r ? (e.preventDefault(), r(n)) : false;
            }
          })
        ];
      }
      function Km(t, e) {
        return function({ state: n, dispatch: r }) {
          if (!e && n.readOnly)
            return false;
          let i = n.field(XR, false);
          if (!i)
            return false;
          let o = i.pop(t, n, e);
          return o ? (r(o), true) : false;
        };
      }
      const Ux = Km(0, false), Lp = Km(1, false), qq = Km(0, true), Gq = Km(1, true);
      class Nn {
        constructor(e, n, r, i, o) {
          this.changes = e, this.effects = n, this.mapped = r, this.startSelection = i, this.selectionsAfter = o;
        }
        setSelAfter(e) {
          return new Nn(this.changes, this.effects, this.mapped, this.startSelection, e);
        }
        toJSON() {
          var e, n, r;
          return {
            changes: (e = this.changes) === null || e === void 0 ? void 0 : e.toJSON(),
            mapped: (n = this.mapped) === null || n === void 0 ? void 0 : n.toJSON(),
            startSelection: (r = this.startSelection) === null || r === void 0 ? void 0 : r.toJSON(),
            selectionsAfter: this.selectionsAfter.map((i) => i.toJSON())
          };
        }
        static fromJSON(e) {
          return new Nn(e.changes && _t.fromJSON(e.changes), [], e.mapped && ki.fromJSON(e.mapped), e.startSelection && q.fromJSON(e.startSelection), e.selectionsAfter.map(q.fromJSON));
        }
        static fromTransaction(e, n) {
          let r = gr;
          for (let i of e.startState.facet(Uq)) {
            let o = i(e);
            o.length && (r = r.concat(o));
          }
          return !r.length && e.changes.empty ? null : new Nn(e.changes.invert(e.startState.doc), r, void 0, n || e.startState.selection, gr);
        }
        static selection(e) {
          return new Nn(void 0, gr, void 0, void 0, e);
        }
      }
      function Dp(t, e, n, r) {
        let i = e + 1 > n + 20 ? e - n - 1 : 0, o = t.slice(i, e);
        return o.push(r), o;
      }
      function Yq(t, e) {
        let n = [], r = false;
        return t.iterChangedRanges((i, o) => n.push(i, o)), e.iterChangedRanges((i, o, s, a) => {
          for (let l = 0; l < n.length; ) {
            let c = n[l++], u = n[l++];
            a >= c && s <= u && (r = true);
          }
        }), r;
      }
      function Xq(t, e) {
        return t.ranges.length == e.ranges.length && t.ranges.filter((n, r) => n.empty != e.ranges[r].empty).length === 0;
      }
      function QR(t, e) {
        return t.length ? e.length ? t.concat(e) : t : e;
      }
      const gr = [], Qq = 200;
      function JR(t, e) {
        if (t.length) {
          let n = t[t.length - 1], r = n.selectionsAfter.slice(Math.max(0, n.selectionsAfter.length - Qq));
          return r.length && r[r.length - 1].eq(e) ? t : (r.push(e), Dp(t, t.length - 1, 1e9, n.setSelAfter(r)));
        } else
          return [
            Nn.selection([
              e
            ])
          ];
      }
      function Jq(t) {
        let e = t[t.length - 1], n = t.slice();
        return n[t.length - 1] = e.setSelAfter(e.selectionsAfter.slice(0, e.selectionsAfter.length - 1)), n;
      }
      function X0(t, e) {
        if (!t.length)
          return t;
        let n = t.length, r = gr;
        for (; n; ) {
          let i = Zq(t[n - 1], e, r);
          if (i.changes && !i.changes.empty || i.effects.length) {
            let o = t.slice(0, n);
            return o[n - 1] = i, o;
          } else
            e = i.mapped, n--, r = i.selectionsAfter;
        }
        return r.length ? [
          Nn.selection(r)
        ] : gr;
      }
      function Zq(t, e, n) {
        let r = QR(t.selectionsAfter.length ? t.selectionsAfter.map((a) => a.map(e)) : gr, n);
        if (!t.changes)
          return Nn.selection(r);
        let i = t.changes.map(e), o = e.mapDesc(t.changes, true), s = t.mapped ? t.mapped.composeDesc(o) : o;
        return new Nn(i, Pe.mapEffects(t.effects, e), s, t.startSelection.map(o), r);
      }
      const eG = /^(input\.type|delete)($|\.)/;
      class vi {
        constructor(e, n, r = 0, i = void 0) {
          this.done = e, this.undone = n, this.prevTime = r, this.prevUserEvent = i;
        }
        isolate() {
          return this.prevTime ? new vi(this.done, this.undone) : this;
        }
        addChanges(e, n, r, i, o) {
          let s = this.done, a = s[s.length - 1];
          return a && a.changes && !a.changes.empty && e.changes && (!r || eG.test(r)) && (!a.selectionsAfter.length && n - this.prevTime < i.newGroupDelay && i.joinToEvent(o, Yq(a.changes, e.changes)) || r == "input.type.compose") ? s = Dp(s, s.length - 1, i.minDepth, new Nn(e.changes.compose(a.changes), QR(Pe.mapEffects(e.effects, a.changes), a.effects), a.mapped, a.startSelection, gr)) : s = Dp(s, s.length, i.minDepth, e), new vi(s, gr, n, r);
        }
        addSelection(e, n, r, i) {
          let o = this.done.length ? this.done[this.done.length - 1].selectionsAfter : gr;
          return o.length > 0 && n - this.prevTime < i && r == this.prevUserEvent && r && /^select($|\.)/.test(r) && Xq(o[o.length - 1], e) ? this : new vi(JR(this.done, e), this.undone, n, r);
        }
        addMapping(e) {
          return new vi(X0(this.done, e), X0(this.undone, e), this.prevTime, this.prevUserEvent);
        }
        pop(e, n, r) {
          let i = e == 0 ? this.done : this.undone;
          if (i.length == 0)
            return null;
          let o = i[i.length - 1], s = o.selectionsAfter[0] || n.selection;
          if (r && o.selectionsAfter.length)
            return n.update({
              selection: o.selectionsAfter[o.selectionsAfter.length - 1],
              annotations: x1.of({
                side: e,
                rest: Jq(i),
                selection: s
              }),
              userEvent: e == 0 ? "select.undo" : "select.redo",
              scrollIntoView: true
            });
          if (o.changes) {
            let a = i.length == 1 ? gr : i.slice(0, i.length - 1);
            return o.mapped && (a = X0(a, o.mapped)), n.update({
              changes: o.changes,
              selection: o.startSelection,
              effects: o.effects,
              annotations: x1.of({
                side: e,
                rest: a,
                selection: s
              }),
              filter: false,
              userEvent: e == 0 ? "undo" : "redo",
              scrollIntoView: true
            });
          } else
            return null;
        }
      }
      vi.empty = new vi(gr, gr);
      const tG = [
        {
          key: "Mod-z",
          run: Ux,
          preventDefault: true
        },
        {
          key: "Mod-y",
          mac: "Mod-Shift-z",
          run: Lp,
          preventDefault: true
        },
        {
          linux: "Ctrl-Shift-z",
          run: Lp,
          preventDefault: true
        },
        {
          key: "Mod-u",
          run: qq,
          preventDefault: true
        },
        {
          key: "Alt-u",
          mac: "Mod-Shift-u",
          run: Gq,
          preventDefault: true
        }
      ];
      function El(t, e) {
        return q.create(t.ranges.map(e), t.mainIndex);
      }
      function Pi(t, e) {
        return t.update({
          selection: e,
          scrollIntoView: true,
          userEvent: "select"
        });
      }
      function Gr({ state: t, dispatch: e }, n) {
        let r = El(t.selection, n);
        return r.eq(t.selection, true) ? false : (e(Pi(t, r)), true);
      }
      function qm(t, e) {
        return q.cursor(e ? t.to : t.from);
      }
      function Kx(t, e) {
        return Gr(t, (n) => n.empty ? t.moveByChar(n, e) : qm(n, e));
      }
      function gn(t) {
        return t.textDirectionAt(t.state.selection.main.head) == rt.LTR;
      }
      const qx = (t) => Kx(t, !gn(t)), ZR = (t) => Kx(t, gn(t)), nG = (t) => Kx(t, false);
      function eL(t, e) {
        return Gr(t, (n) => n.empty ? t.moveByGroup(n, e) : qm(n, e));
      }
      const rG = (t) => eL(t, !gn(t)), iG = (t) => eL(t, gn(t));
      function oG(t, e, n) {
        if (e.type.prop(n))
          return true;
        let r = e.to - e.from;
        return r && (r > 2 || /[^\s,.;:]/.test(t.sliceDoc(e.from, e.to))) || e.firstChild;
      }
      function Gm(t, e, n) {
        let r = mn(t).resolveInner(e.head), i = n ? $e.closedBy : $e.openedBy;
        for (let l = e.head; ; ) {
          let c = n ? r.childAfter(l) : r.childBefore(l);
          if (!c)
            break;
          oG(t, c, i) ? r = c : l = n ? c.to : c.from;
        }
        let o = r.type.prop(i), s, a;
        return o && (s = n ? mr(t, r.from, 1) : mr(t, r.to, -1)) && s.matched ? a = n ? s.end.to : s.end.from : a = n ? r.to : r.from, q.cursor(a, n ? -1 : 1);
      }
      const sG = (t) => Gr(t, (e) => Gm(t.state, e, !gn(t))), aG = (t) => Gr(t, (e) => Gm(t.state, e, gn(t)));
      function tL(t, e) {
        return Gr(t, (n) => {
          if (!n.empty)
            return qm(n, e);
          let r = t.moveVertically(n, e);
          return r.head != n.head ? r : t.moveToLineBoundary(n, e);
        });
      }
      const nL = (t) => tL(t, false), rL = (t) => tL(t, true);
      function iL(t) {
        let e = t.scrollDOM.clientHeight < t.scrollDOM.scrollHeight - 2, n = 0, r = 0, i;
        if (e) {
          for (let o of t.state.facet(ce.scrollMargins)) {
            let s = o(t);
            (s == null ? void 0 : s.top) && (n = Math.max(s == null ? void 0 : s.top, n)), (s == null ? void 0 : s.bottom) && (r = Math.max(s == null ? void 0 : s.bottom, r));
          }
          i = t.scrollDOM.clientHeight - n - r;
        } else
          i = (t.dom.ownerDocument.defaultView || window).innerHeight;
        return {
          marginTop: n,
          marginBottom: r,
          selfScroll: e,
          height: Math.max(t.defaultLineHeight, i - 5)
        };
      }
      function oL(t, e) {
        let n = iL(t), { state: r } = t, i = El(r.selection, (s) => s.empty ? t.moveVertically(s, e, n.height) : qm(s, e));
        if (i.eq(r.selection))
          return false;
        let o;
        if (n.selfScroll) {
          let s = t.coordsAtPos(r.selection.main.head), a = t.scrollDOM.getBoundingClientRect(), l = a.top + n.marginTop, c = a.bottom - n.marginBottom;
          s && s.top > l && s.bottom < c && (o = ce.scrollIntoView(i.main.head, {
            y: "start",
            yMargin: s.top - l
          }));
        }
        return t.dispatch(Pi(r, i), {
          effects: o
        }), true;
      }
      const CT = (t) => oL(t, false), S1 = (t) => oL(t, true);
      function rs(t, e, n) {
        let r = t.lineBlockAt(e.head), i = t.moveToLineBoundary(e, n);
        if (i.head == e.head && i.head != (n ? r.to : r.from) && (i = t.moveToLineBoundary(e, n, false)), !n && i.head == r.from && r.length) {
          let o = /^\s*/.exec(t.state.sliceDoc(r.from, Math.min(r.from + 100, r.to)))[0].length;
          o && e.head != r.from + o && (i = q.cursor(r.from + o));
        }
        return i;
      }
      const sL = (t) => Gr(t, (e) => rs(t, e, true)), aL = (t) => Gr(t, (e) => rs(t, e, false)), lG = (t) => Gr(t, (e) => rs(t, e, !gn(t))), cG = (t) => Gr(t, (e) => rs(t, e, gn(t))), uG = (t) => Gr(t, (e) => q.cursor(t.lineBlockAt(e.head).from, 1)), fG = (t) => Gr(t, (e) => q.cursor(t.lineBlockAt(e.head).to, -1));
      function hG(t, e, n) {
        let r = false, i = El(t.selection, (o) => {
          let s = mr(t, o.head, -1) || mr(t, o.head, 1) || o.head > 0 && mr(t, o.head - 1, 1) || o.head < t.doc.length && mr(t, o.head + 1, -1);
          if (!s || !s.end)
            return o;
          r = true;
          let a = s.start.from == o.head ? s.end.to : s.end.from;
          return n ? q.range(o.anchor, a) : q.cursor(a);
        });
        return r ? (e(Pi(t, i)), true) : false;
      }
      const dG = ({ state: t, dispatch: e }) => hG(t, e, false);
      function Ar(t, e) {
        let n = El(t.state.selection, (r) => {
          let i = e(r);
          return q.range(r.anchor, i.head, i.goalColumn, i.bidiLevel || void 0);
        });
        return n.eq(t.state.selection) ? false : (t.dispatch(Pi(t.state, n)), true);
      }
      function lL(t, e) {
        return Ar(t, (n) => t.moveByChar(n, e));
      }
      const cL = (t) => lL(t, !gn(t)), uL = (t) => lL(t, gn(t));
      function fL(t, e) {
        return Ar(t, (n) => t.moveByGroup(n, e));
      }
      const pG = (t) => fL(t, !gn(t)), mG = (t) => fL(t, gn(t)), gG = (t) => Ar(t, (e) => Gm(t.state, e, !gn(t))), vG = (t) => Ar(t, (e) => Gm(t.state, e, gn(t)));
      function hL(t, e) {
        return Ar(t, (n) => t.moveVertically(n, e));
      }
      const dL = (t) => hL(t, false), pL = (t) => hL(t, true);
      function mL(t, e) {
        return Ar(t, (n) => t.moveVertically(n, e, iL(t).height));
      }
      const TT = (t) => mL(t, false), MT = (t) => mL(t, true), yG = (t) => Ar(t, (e) => rs(t, e, true)), bG = (t) => Ar(t, (e) => rs(t, e, false)), xG = (t) => Ar(t, (e) => rs(t, e, !gn(t))), SG = (t) => Ar(t, (e) => rs(t, e, gn(t))), wG = (t) => Ar(t, (e) => q.cursor(t.lineBlockAt(e.head).from)), kG = (t) => Ar(t, (e) => q.cursor(t.lineBlockAt(e.head).to)), AT = ({ state: t, dispatch: e }) => (e(Pi(t, {
        anchor: 0
      })), true), ET = ({ state: t, dispatch: e }) => (e(Pi(t, {
        anchor: t.doc.length
      })), true), PT = ({ state: t, dispatch: e }) => (e(Pi(t, {
        anchor: t.selection.main.anchor,
        head: 0
      })), true), OT = ({ state: t, dispatch: e }) => (e(Pi(t, {
        anchor: t.selection.main.anchor,
        head: t.doc.length
      })), true), CG = ({ state: t, dispatch: e }) => (e(t.update({
        selection: {
          anchor: 0,
          head: t.doc.length
        },
        userEvent: "select"
      })), true), TG = ({ state: t, dispatch: e }) => {
        let n = Ym(t).map(({ from: r, to: i }) => q.range(r, Math.min(i + 1, t.doc.length)));
        return e(t.update({
          selection: q.create(n),
          userEvent: "select"
        })), true;
      }, MG = ({ state: t, dispatch: e }) => {
        let n = El(t.selection, (r) => {
          let i = mn(t), o = i.resolveStack(r.from, 1);
          if (r.empty) {
            let s = i.resolveStack(r.from, -1);
            s.node.from >= o.node.from && s.node.to <= o.node.to && (o = s);
          }
          for (let s = o; s; s = s.next) {
            let { node: a } = s;
            if ((a.from < r.from && a.to >= r.to || a.to > r.to && a.from <= r.from) && s.next)
              return q.range(a.to, a.from);
          }
          return r;
        });
        return n.eq(t.selection) ? false : (e(Pi(t, n)), true);
      }, AG = ({ state: t, dispatch: e }) => {
        let n = t.selection, r = null;
        return n.ranges.length > 1 ? r = q.create([
          n.main
        ]) : n.main.empty || (r = q.create([
          q.cursor(n.main.head)
        ])), r ? (e(Pi(t, r)), true) : false;
      };
      function uf(t, e) {
        if (t.state.readOnly)
          return false;
        let n = "delete.selection", { state: r } = t, i = r.changeByRange((o) => {
          let { from: s, to: a } = o;
          if (s == a) {
            let l = e(o);
            l < s ? (n = "delete.backward", l = Ih(t, l, false)) : l > s && (n = "delete.forward", l = Ih(t, l, true)), s = Math.min(s, l), a = Math.max(a, l);
          } else
            s = Ih(t, s, false), a = Ih(t, a, true);
          return s == a ? {
            range: o
          } : {
            changes: {
              from: s,
              to: a
            },
            range: q.cursor(s, s < o.head ? -1 : 1)
          };
        });
        return i.changes.empty ? false : (t.dispatch(r.update(i, {
          scrollIntoView: true,
          userEvent: n,
          effects: n == "delete.selection" ? ce.announce.of(r.phrase("Selection deleted")) : void 0
        })), true);
      }
      function Ih(t, e, n) {
        if (t instanceof ce)
          for (let r of t.state.facet(ce.atomicRanges).map((i) => i(t)))
            r.between(e, e, (i, o) => {
              i < e && o > e && (e = n ? o : i);
            });
        return e;
      }
      const gL = (t, e, n) => uf(t, (r) => {
        let i = r.from, { state: o } = t, s = o.doc.lineAt(i), a, l;
        if (n && !e && i > s.from && i < s.from + 200 && !/[^ \t]/.test(a = s.text.slice(0, i - s.from))) {
          if (a[a.length - 1] == "	")
            return i - 1;
          let c = Al(a, o.tabSize), u = c % Pp(o) || Pp(o);
          for (let h = 0; h < u && a[a.length - 1 - h] == " "; h++)
            i--;
          l = i;
        } else
          l = en(s.text, i - s.from, e, e) + s.from, l == i && s.number != (e ? o.doc.lines : 1) ? l += e ? 1 : -1 : !e && /[\ufe00-\ufe0f]/.test(s.text.slice(l - s.from, i - s.from)) && (l = en(s.text, l - s.from, false, false) + s.from);
        return l;
      }), w1 = (t) => gL(t, false, true), vL = (t) => gL(t, true, false), yL = (t, e) => uf(t, (n) => {
        let r = n.head, { state: i } = t, o = i.doc.lineAt(r), s = i.charCategorizer(r);
        for (let a = null; ; ) {
          if (r == (e ? o.to : o.from)) {
            r == n.head && o.number != (e ? i.doc.lines : 1) && (r += e ? 1 : -1);
            break;
          }
          let l = en(o.text, r - o.from, e) + o.from, c = o.text.slice(Math.min(r, l) - o.from, Math.max(r, l) - o.from), u = s(c);
          if (a != null && u != a)
            break;
          (c != " " || r != n.head) && (a = u), r = l;
        }
        return r;
      }), bL = (t) => yL(t, false), EG = (t) => yL(t, true), PG = (t) => uf(t, (e) => {
        let n = t.lineBlockAt(e.head).to;
        return e.head < n ? n : Math.min(t.state.doc.length, e.head + 1);
      }), OG = (t) => uf(t, (e) => {
        let n = t.moveToLineBoundary(e, false).head;
        return e.head > n ? n : Math.max(0, e.head - 1);
      }), RG = (t) => uf(t, (e) => {
        let n = t.moveToLineBoundary(e, true).head;
        return e.head < n ? n : Math.min(t.state.doc.length, e.head + 1);
      }), LG = ({ state: t, dispatch: e }) => {
        if (t.readOnly)
          return false;
        let n = t.changeByRange((r) => ({
          changes: {
            from: r.from,
            to: r.to,
            insert: He.of([
              "",
              ""
            ])
          },
          range: q.cursor(r.from)
        }));
        return e(t.update(n, {
          scrollIntoView: true,
          userEvent: "input"
        })), true;
      }, DG = ({ state: t, dispatch: e }) => {
        if (t.readOnly)
          return false;
        let n = t.changeByRange((r) => {
          if (!r.empty || r.from == 0 || r.from == t.doc.length)
            return {
              range: r
            };
          let i = r.from, o = t.doc.lineAt(i), s = i == o.from ? i - 1 : en(o.text, i - o.from, false) + o.from, a = i == o.to ? i + 1 : en(o.text, i - o.from, true) + o.from;
          return {
            changes: {
              from: s,
              to: a,
              insert: t.doc.slice(i, a).append(t.doc.slice(s, i))
            },
            range: q.cursor(a)
          };
        });
        return n.changes.empty ? false : (e(t.update(n, {
          scrollIntoView: true,
          userEvent: "move.character"
        })), true);
      };
      function Ym(t) {
        let e = [], n = -1;
        for (let r of t.selection.ranges) {
          let i = t.doc.lineAt(r.from), o = t.doc.lineAt(r.to);
          if (!r.empty && r.to == o.from && (o = t.doc.lineAt(r.to - 1)), n >= i.number) {
            let s = e[e.length - 1];
            s.to = o.to, s.ranges.push(r);
          } else
            e.push({
              from: i.from,
              to: o.to,
              ranges: [
                r
              ]
            });
          n = o.number + 1;
        }
        return e;
      }
      function xL(t, e, n) {
        if (t.readOnly)
          return false;
        let r = [], i = [];
        for (let o of Ym(t)) {
          if (n ? o.to == t.doc.length : o.from == 0)
            continue;
          let s = t.doc.lineAt(n ? o.to + 1 : o.from - 1), a = s.length + 1;
          if (n) {
            r.push({
              from: o.to,
              to: s.to
            }, {
              from: o.from,
              insert: s.text + t.lineBreak
            });
            for (let l of o.ranges)
              i.push(q.range(Math.min(t.doc.length, l.anchor + a), Math.min(t.doc.length, l.head + a)));
          } else {
            r.push({
              from: s.from,
              to: o.from
            }, {
              from: o.to,
              insert: t.lineBreak + s.text
            });
            for (let l of o.ranges)
              i.push(q.range(l.anchor - a, l.head - a));
          }
        }
        return r.length ? (e(t.update({
          changes: r,
          scrollIntoView: true,
          selection: q.create(i, t.selection.mainIndex),
          userEvent: "move.line"
        })), true) : false;
      }
      const _G = ({ state: t, dispatch: e }) => xL(t, e, false), IG = ({ state: t, dispatch: e }) => xL(t, e, true);
      function SL(t, e, n) {
        if (t.readOnly)
          return false;
        let r = [];
        for (let i of Ym(t))
          n ? r.push({
            from: i.from,
            insert: t.doc.slice(i.from, i.to) + t.lineBreak
          }) : r.push({
            from: i.to,
            insert: t.lineBreak + t.doc.slice(i.from, i.to)
          });
        return e(t.update({
          changes: r,
          scrollIntoView: true,
          userEvent: "input.copyline"
        })), true;
      }
      const BG = ({ state: t, dispatch: e }) => SL(t, e, false), NG = ({ state: t, dispatch: e }) => SL(t, e, true), $G = (t) => {
        if (t.state.readOnly)
          return false;
        let { state: e } = t, n = e.changes(Ym(e).map(({ from: i, to: o }) => (i > 0 ? i-- : o < e.doc.length && o++, {
          from: i,
          to: o
        }))), r = El(e.selection, (i) => {
          let o;
          if (t.lineWrapping) {
            let s = t.lineBlockAt(i.head), a = t.coordsAtPos(i.head, i.assoc || 1);
            a && (o = s.bottom + t.documentTop - a.bottom + t.defaultLineHeight / 2);
          }
          return t.moveVertically(i, true, o);
        }).map(n);
        return t.dispatch({
          changes: n,
          selection: r,
          scrollIntoView: true,
          userEvent: "delete.line"
        }), true;
      };
      function zG(t, e) {
        if (/\(\)|\[\]|\{\}/.test(t.sliceDoc(e - 1, e + 1)))
          return {
            from: e,
            to: e
          };
        let n = mn(t).resolveInner(e), r = n.childBefore(e), i = n.childAfter(e), o;
        return r && i && r.to <= e && i.from >= e && (o = r.type.prop($e.closedBy)) && o.indexOf(i.name) > -1 && t.doc.lineAt(r.to).from == t.doc.lineAt(i.from).from && !/\S/.test(t.sliceDoc(r.to, i.from)) ? {
          from: r.to,
          to: i.from
        } : null;
      }
      const k1 = wL(false), FG = wL(true);
      function wL(t) {
        return ({ state: e, dispatch: n }) => {
          if (e.readOnly)
            return false;
          let r = e.changeByRange((i) => {
            let { from: o, to: s } = i, a = e.doc.lineAt(o), l = !t && o == s && zG(e, o);
            t && (o = s = (s <= a.to ? a : e.doc.lineAt(s)).to);
            let c = new Wm(e, {
              simulateBreak: o,
              simulateDoubleBreak: !!l
            }), u = Fx(c, o);
            for (u == null && (u = Al(/^\s*/.exec(e.doc.lineAt(o).text)[0], e.tabSize)); s < a.to && /\s/.test(a.text[s - a.from]); )
              s++;
            l ? { from: o, to: s } = l : o > a.from && o < a.from + 100 && !/\S/.test(a.text.slice(0, o)) && (o = a.from);
            let h = [
              "",
              zu(e, u)
            ];
            return l && h.push(zu(e, c.lineIndent(a.from, -1))), {
              changes: {
                from: o,
                to: s,
                insert: He.of(h)
              },
              range: q.cursor(o + 1 + h[1].length)
            };
          });
          return n(e.update(r, {
            scrollIntoView: true,
            userEvent: "input"
          })), true;
        };
      }
      function Gx(t, e) {
        let n = -1;
        return t.changeByRange((r) => {
          let i = [];
          for (let s = r.from; s <= r.to; ) {
            let a = t.doc.lineAt(s);
            a.number > n && (r.empty || r.to > a.from) && (e(a, i, r), n = a.number), s = a.to + 1;
          }
          let o = t.changes(i);
          return {
            changes: i,
            range: q.range(o.mapPos(r.anchor, 1), o.mapPos(r.head, 1))
          };
        });
      }
      const kL = ({ state: t, dispatch: e }) => {
        if (t.readOnly)
          return false;
        let n = /* @__PURE__ */ Object.create(null), r = new Wm(t, {
          overrideIndentation: (o) => {
            let s = n[o];
            return s ?? -1;
          }
        }), i = Gx(t, (o, s, a) => {
          let l = Fx(r, o.from);
          if (l == null)
            return;
          /\S/.test(o.text) || (l = 0);
          let c = /^\s*/.exec(o.text)[0], u = zu(t, l);
          (c != u || a.from < o.from + c.length) && (n[o.from] = l, s.push({
            from: o.from,
            to: o.from + c.length,
            insert: u
          }));
        });
        return i.changes.empty || e(t.update(i, {
          userEvent: "indent"
        })), true;
      }, Yx = ({ state: t, dispatch: e }) => t.readOnly ? false : (e(t.update(Gx(t, (n, r) => {
        r.push({
          from: n.from,
          insert: t.facet(yl)
        });
      }), {
        userEvent: "input.indent"
      })), true), Xx = ({ state: t, dispatch: e }) => t.readOnly ? false : (e(t.update(Gx(t, (n, r) => {
        let i = /^\s*/.exec(n.text)[0];
        if (!i)
          return;
        let o = Al(i, t.tabSize), s = 0, a = zu(t, Math.max(0, o - Pp(t)));
        for (; s < i.length && s < a.length && i.charCodeAt(s) == a.charCodeAt(s); )
          s++;
        r.push({
          from: n.from + s,
          to: n.from + i.length,
          insert: a.slice(s)
        });
      }), {
        userEvent: "delete.dedent"
      })), true), VG = (t) => (t.setTabFocusMode(), true), HG = [
        {
          key: "Ctrl-b",
          run: qx,
          shift: cL,
          preventDefault: true
        },
        {
          key: "Ctrl-f",
          run: ZR,
          shift: uL
        },
        {
          key: "Ctrl-p",
          run: nL,
          shift: dL
        },
        {
          key: "Ctrl-n",
          run: rL,
          shift: pL
        },
        {
          key: "Ctrl-a",
          run: uG,
          shift: wG
        },
        {
          key: "Ctrl-e",
          run: fG,
          shift: kG
        },
        {
          key: "Ctrl-d",
          run: vL
        },
        {
          key: "Ctrl-h",
          run: w1
        },
        {
          key: "Ctrl-k",
          run: PG
        },
        {
          key: "Ctrl-Alt-h",
          run: bL
        },
        {
          key: "Ctrl-o",
          run: LG
        },
        {
          key: "Ctrl-t",
          run: DG
        },
        {
          key: "Ctrl-v",
          run: S1
        }
      ], jG = [
        {
          key: "ArrowLeft",
          run: qx,
          shift: cL,
          preventDefault: true
        },
        {
          key: "Mod-ArrowLeft",
          mac: "Alt-ArrowLeft",
          run: rG,
          shift: pG,
          preventDefault: true
        },
        {
          mac: "Cmd-ArrowLeft",
          run: lG,
          shift: xG,
          preventDefault: true
        },
        {
          key: "ArrowRight",
          run: ZR,
          shift: uL,
          preventDefault: true
        },
        {
          key: "Mod-ArrowRight",
          mac: "Alt-ArrowRight",
          run: iG,
          shift: mG,
          preventDefault: true
        },
        {
          mac: "Cmd-ArrowRight",
          run: cG,
          shift: SG,
          preventDefault: true
        },
        {
          key: "ArrowUp",
          run: nL,
          shift: dL,
          preventDefault: true
        },
        {
          mac: "Cmd-ArrowUp",
          run: AT,
          shift: PT
        },
        {
          mac: "Ctrl-ArrowUp",
          run: CT,
          shift: TT
        },
        {
          key: "ArrowDown",
          run: rL,
          shift: pL,
          preventDefault: true
        },
        {
          mac: "Cmd-ArrowDown",
          run: ET,
          shift: OT
        },
        {
          mac: "Ctrl-ArrowDown",
          run: S1,
          shift: MT
        },
        {
          key: "PageUp",
          run: CT,
          shift: TT
        },
        {
          key: "PageDown",
          run: S1,
          shift: MT
        },
        {
          key: "Home",
          run: aL,
          shift: bG,
          preventDefault: true
        },
        {
          key: "Mod-Home",
          run: AT,
          shift: PT
        },
        {
          key: "End",
          run: sL,
          shift: yG,
          preventDefault: true
        },
        {
          key: "Mod-End",
          run: ET,
          shift: OT
        },
        {
          key: "Enter",
          run: k1,
          shift: k1
        },
        {
          key: "Mod-a",
          run: CG
        },
        {
          key: "Backspace",
          run: w1,
          shift: w1
        },
        {
          key: "Delete",
          run: vL
        },
        {
          key: "Mod-Backspace",
          mac: "Alt-Backspace",
          run: bL
        },
        {
          key: "Mod-Delete",
          mac: "Alt-Delete",
          run: EG
        },
        {
          mac: "Mod-Backspace",
          run: OG
        },
        {
          mac: "Mod-Delete",
          run: RG
        }
      ].concat(HG.map((t) => ({
        mac: t.key,
        run: t.run,
        shift: t.shift
      }))), WG = [
        {
          key: "Alt-ArrowLeft",
          mac: "Ctrl-ArrowLeft",
          run: sG,
          shift: gG
        },
        {
          key: "Alt-ArrowRight",
          mac: "Ctrl-ArrowRight",
          run: aG,
          shift: vG
        },
        {
          key: "Alt-ArrowUp",
          run: _G
        },
        {
          key: "Shift-Alt-ArrowUp",
          run: BG
        },
        {
          key: "Alt-ArrowDown",
          run: IG
        },
        {
          key: "Shift-Alt-ArrowDown",
          run: NG
        },
        {
          key: "Escape",
          run: AG
        },
        {
          key: "Mod-Enter",
          run: FG
        },
        {
          key: "Alt-l",
          mac: "Ctrl-l",
          run: TG
        },
        {
          key: "Mod-i",
          run: MG,
          preventDefault: true
        },
        {
          key: "Mod-[",
          run: Xx
        },
        {
          key: "Mod-]",
          run: Yx
        },
        {
          key: "Mod-Alt-\\",
          run: kL
        },
        {
          key: "Shift-Mod-k",
          run: $G
        },
        {
          key: "Shift-Mod-\\",
          run: dG
        },
        {
          key: "Mod-/",
          run: Nq
        },
        {
          key: "Alt-A",
          run: zq
        },
        {
          key: "Ctrl-m",
          mac: "Shift-Alt-m",
          run: VG
        }
      ].concat(jG), UG = {
        key: "Tab",
        run: Yx,
        shift: Xx
      };
      function Qe() {
        var t = arguments[0];
        typeof t == "string" && (t = document.createElement(t));
        var e = 1, n = arguments[1];
        if (n && typeof n == "object" && n.nodeType == null && !Array.isArray(n)) {
          for (var r in n)
            if (Object.prototype.hasOwnProperty.call(n, r)) {
              var i = n[r];
              typeof i == "string" ? t.setAttribute(r, i) : i != null && (t[r] = i);
            }
          e++;
        }
        for (; e < arguments.length; e++)
          CL(t, arguments[e]);
        return t;
      }
      function CL(t, e) {
        if (typeof e == "string")
          t.appendChild(document.createTextNode(e));
        else if (e != null)
          if (e.nodeType != null)
            t.appendChild(e);
          else if (Array.isArray(e))
            for (var n = 0; n < e.length; n++)
              CL(t, e[n]);
          else
            throw new RangeError("Unsupported child node: " + e);
      }
      const RT = typeof String.prototype.normalize == "function" ? (t) => t.normalize("NFKD") : (t) => t;
      class bl {
        constructor(e, n, r = 0, i = e.length, o, s) {
          this.test = s, this.value = {
            from: 0,
            to: 0
          }, this.done = false, this.matches = [], this.buffer = "", this.bufferPos = 0, this.iter = e.iterRange(r, i), this.bufferStart = r, this.normalize = o ? (a) => o(RT(a)) : RT, this.query = this.normalize(n);
        }
        peek() {
          if (this.bufferPos == this.buffer.length) {
            if (this.bufferStart += this.buffer.length, this.iter.next(), this.iter.done)
              return -1;
            this.bufferPos = 0, this.buffer = this.iter.value;
          }
          return Rn(this.buffer, this.bufferPos);
        }
        next() {
          for (; this.matches.length; )
            this.matches.pop();
          return this.nextOverlapping();
        }
        nextOverlapping() {
          for (; ; ) {
            let e = this.peek();
            if (e < 0)
              return this.done = true, this;
            let n = Sx(e), r = this.bufferStart + this.bufferPos;
            this.bufferPos += di(e);
            let i = this.normalize(n);
            if (i.length)
              for (let o = 0, s = r; ; o++) {
                let a = i.charCodeAt(o), l = this.match(a, s, this.bufferPos + this.bufferStart);
                if (o == i.length - 1) {
                  if (l)
                    return this.value = l, this;
                  break;
                }
                s == r && o < n.length && n.charCodeAt(o) == a && s++;
              }
          }
        }
        match(e, n, r) {
          let i = null;
          for (let o = 0; o < this.matches.length; o += 2) {
            let s = this.matches[o], a = false;
            this.query.charCodeAt(s) == e && (s == this.query.length - 1 ? i = {
              from: this.matches[o + 1],
              to: r
            } : (this.matches[o]++, a = true)), a || (this.matches.splice(o, 2), o -= 2);
          }
          return this.query.charCodeAt(0) == e && (this.query.length == 1 ? i = {
            from: n,
            to: r
          } : this.matches.push(1, n)), i && this.test && !this.test(i.from, i.to, this.buffer, this.bufferStart) && (i = null), i;
        }
      }
      typeof Symbol < "u" && (bl.prototype[Symbol.iterator] = function() {
        return this;
      });
      const TL = {
        from: -1,
        to: -1,
        match: /.*/.exec("")
      }, Qx = "gm" + (/x/.unicode == null ? "" : "u");
      class Jx {
        constructor(e, n, r, i = 0, o = e.length) {
          if (this.text = e, this.to = o, this.curLine = "", this.done = false, this.value = TL, /\\[sWDnr]|\n|\r|\[\^/.test(n))
            return new ML(e, n, r, i, o);
          this.re = new RegExp(n, Qx + ((r == null ? void 0 : r.ignoreCase) ? "i" : "")), this.test = r == null ? void 0 : r.test, this.iter = e.iter();
          let s = e.lineAt(i);
          this.curLineStart = s.from, this.matchPos = _p(e, i), this.getLine(this.curLineStart);
        }
        getLine(e) {
          this.iter.next(e), this.iter.lineBreak ? this.curLine = "" : (this.curLine = this.iter.value, this.curLineStart + this.curLine.length > this.to && (this.curLine = this.curLine.slice(0, this.to - this.curLineStart)), this.iter.next());
        }
        nextLine() {
          this.curLineStart = this.curLineStart + this.curLine.length + 1, this.curLineStart > this.to ? this.curLine = "" : this.getLine(0);
        }
        next() {
          for (let e = this.matchPos - this.curLineStart; ; ) {
            this.re.lastIndex = e;
            let n = this.matchPos <= this.to && this.re.exec(this.curLine);
            if (n) {
              let r = this.curLineStart + n.index, i = r + n[0].length;
              if (this.matchPos = _p(this.text, i + (r == i ? 1 : 0)), r == this.curLineStart + this.curLine.length && this.nextLine(), (r < i || r > this.value.to) && (!this.test || this.test(r, i, n)))
                return this.value = {
                  from: r,
                  to: i,
                  match: n
                }, this;
              e = this.matchPos - this.curLineStart;
            } else if (this.curLineStart + this.curLine.length < this.to)
              this.nextLine(), e = 0;
            else
              return this.done = true, this;
          }
        }
      }
      const Q0 = /* @__PURE__ */ new WeakMap();
      class Xa {
        constructor(e, n) {
          this.from = e, this.text = n;
        }
        get to() {
          return this.from + this.text.length;
        }
        static get(e, n, r) {
          let i = Q0.get(e);
          if (!i || i.from >= r || i.to <= n) {
            let a = new Xa(n, e.sliceString(n, r));
            return Q0.set(e, a), a;
          }
          if (i.from == n && i.to == r)
            return i;
          let { text: o, from: s } = i;
          return s > n && (o = e.sliceString(n, s) + o, s = n), i.to < r && (o += e.sliceString(i.to, r)), Q0.set(e, new Xa(s, o)), new Xa(n, o.slice(n - s, r - s));
        }
      }
      class ML {
        constructor(e, n, r, i, o) {
          this.text = e, this.to = o, this.done = false, this.value = TL, this.matchPos = _p(e, i), this.re = new RegExp(n, Qx + ((r == null ? void 0 : r.ignoreCase) ? "i" : "")), this.test = r == null ? void 0 : r.test, this.flat = Xa.get(e, i, this.chunkEnd(i + 5e3));
        }
        chunkEnd(e) {
          return e >= this.to ? this.to : this.text.lineAt(e).to;
        }
        next() {
          for (; ; ) {
            let e = this.re.lastIndex = this.matchPos - this.flat.from, n = this.re.exec(this.flat.text);
            if (n && !n[0] && n.index == e && (this.re.lastIndex = e + 1, n = this.re.exec(this.flat.text)), n) {
              let r = this.flat.from + n.index, i = r + n[0].length;
              if ((this.flat.to >= this.to || n.index + n[0].length <= this.flat.text.length - 10) && (!this.test || this.test(r, i, n)))
                return this.value = {
                  from: r,
                  to: i,
                  match: n
                }, this.matchPos = _p(this.text, i + (r == i ? 1 : 0)), this;
            }
            if (this.flat.to == this.to)
              return this.done = true, this;
            this.flat = Xa.get(this.text, this.flat.from, this.chunkEnd(this.flat.from + this.flat.text.length * 2));
          }
        }
      }
      typeof Symbol < "u" && (Jx.prototype[Symbol.iterator] = ML.prototype[Symbol.iterator] = function() {
        return this;
      });
      function KG(t) {
        try {
          return new RegExp(t, Qx), true;
        } catch {
          return false;
        }
      }
      function _p(t, e) {
        if (e >= t.length)
          return e;
        let n = t.lineAt(e), r;
        for (; e < n.to && (r = n.text.charCodeAt(e - n.from)) >= 56320 && r < 57344; )
          e++;
        return e;
      }
      function C1(t) {
        let e = String(t.state.doc.lineAt(t.state.selection.main.head).number), n = Qe("input", {
          class: "cm-textfield",
          name: "line",
          value: e
        }), r = Qe("form", {
          class: "cm-gotoLine",
          onkeydown: (o) => {
            o.keyCode == 27 ? (o.preventDefault(), t.dispatch({
              effects: Zc.of(false)
            }), t.focus()) : o.keyCode == 13 && (o.preventDefault(), i());
          },
          onsubmit: (o) => {
            o.preventDefault(), i();
          }
        }, Qe("label", t.state.phrase("Go to line"), ": ", n), " ", Qe("button", {
          class: "cm-button",
          type: "submit"
        }, t.state.phrase("go")), Qe("button", {
          name: "close",
          onclick: () => {
            t.dispatch({
              effects: Zc.of(false)
            }), t.focus();
          },
          "aria-label": t.state.phrase("close"),
          type: "button"
        }, [
          "\xD7"
        ]));
        function i() {
          let o = /^([+-])?(\d+)?(:\d+)?(%)?$/.exec(n.value);
          if (!o)
            return;
          let { state: s } = t, a = s.doc.lineAt(s.selection.main.head), [, l, c, u, h] = o, p = u ? +u.slice(1) : 0, v = c ? +c : a.number;
          if (c && h) {
            let C = v / 100;
            l && (C = C * (l == "-" ? -1 : 1) + a.number / s.doc.lines), v = Math.round(s.doc.lines * C);
          } else
            c && l && (v = v * (l == "-" ? -1 : 1) + a.number);
          let y = s.doc.line(Math.max(1, Math.min(s.doc.lines, v))), S = q.cursor(y.from + Math.max(0, Math.min(p, y.length)));
          t.dispatch({
            effects: [
              Zc.of(false),
              ce.scrollIntoView(S.from, {
                y: "center"
              })
            ],
            selection: S
          }), t.focus();
        }
        return {
          dom: r
        };
      }
      const Zc = Pe.define(), LT = Ut.define({
        create() {
          return true;
        },
        update(t, e) {
          for (let n of e.effects)
            n.is(Zc) && (t = n.value);
          return t;
        },
        provide: (t) => Ks.from(t, (e) => e ? C1 : null)
      }), qG = (t) => {
        let e = Nu(t, C1);
        if (!e) {
          let n = [
            Zc.of(true)
          ];
          t.state.field(LT, false) == null && n.push(Pe.appendConfig.of([
            LT,
            GG
          ])), t.dispatch({
            effects: n
          }), e = Nu(t, C1);
        }
        return e && e.dom.querySelector("input").select(), true;
      }, GG = ce.baseTheme({
        ".cm-panel.cm-gotoLine": {
          padding: "2px 6px 4px",
          position: "relative",
          "& label": {
            fontSize: "80%"
          },
          "& [name=close]": {
            position: "absolute",
            top: "0",
            bottom: "0",
            right: "4px",
            backgroundColor: "inherit",
            border: "none",
            font: "inherit",
            padding: "0"
          }
        }
      }), YG = {
        highlightWordAroundCursor: false,
        minSelectionLength: 1,
        maxMatches: 100,
        wholeWords: false
      }, AL = pe.define({
        combine(t) {
          return Ei(t, YG, {
            highlightWordAroundCursor: (e, n) => e || n,
            minSelectionLength: Math.min,
            maxMatches: Math.min
          });
        }
      });
      function XG(t) {
        let e = [
          tY,
          eY
        ];
        return t && e.push(AL.of(t)), e;
      }
      const QG = be.mark({
        class: "cm-selectionMatch"
      }), JG = be.mark({
        class: "cm-selectionMatch cm-selectionMatch-main"
      });
      function DT(t, e, n, r) {
        return (n == 0 || t(e.sliceDoc(n - 1, n)) != ht.Word) && (r == e.doc.length || t(e.sliceDoc(r, r + 1)) != ht.Word);
      }
      function ZG(t, e, n, r) {
        return t(e.sliceDoc(n, n + 1)) == ht.Word && t(e.sliceDoc(r - 1, r)) == ht.Word;
      }
      const eY = Ct.fromClass(class {
        constructor(t) {
          this.decorations = this.getDeco(t);
        }
        update(t) {
          (t.selectionSet || t.docChanged || t.viewportChanged) && (this.decorations = this.getDeco(t.view));
        }
        getDeco(t) {
          let e = t.state.facet(AL), { state: n } = t, r = n.selection;
          if (r.ranges.length > 1)
            return be.none;
          let i = r.main, o, s = null;
          if (i.empty) {
            if (!e.highlightWordAroundCursor)
              return be.none;
            let l = n.wordAt(i.head);
            if (!l)
              return be.none;
            s = n.charCategorizer(i.head), o = n.sliceDoc(l.from, l.to);
          } else {
            let l = i.to - i.from;
            if (l < e.minSelectionLength || l > 200)
              return be.none;
            if (e.wholeWords) {
              if (o = n.sliceDoc(i.from, i.to), s = n.charCategorizer(i.head), !(DT(s, n, i.from, i.to) && ZG(s, n, i.from, i.to)))
                return be.none;
            } else if (o = n.sliceDoc(i.from, i.to), !o)
              return be.none;
          }
          let a = [];
          for (let l of t.visibleRanges) {
            let c = new bl(n.doc, o, l.from, l.to);
            for (; !c.next().done; ) {
              let { from: u, to: h } = c.value;
              if ((!s || DT(s, n, u, h)) && (i.empty && u <= i.from && h >= i.to ? a.push(JG.range(u, h)) : (u >= i.to || h <= i.from) && a.push(QG.range(u, h)), a.length > e.maxMatches))
                return be.none;
            }
          }
          return be.set(a);
        }
      }, {
        decorations: (t) => t.decorations
      }), tY = ce.baseTheme({
        ".cm-selectionMatch": {
          backgroundColor: "#99ff7780"
        },
        ".cm-searchMatch .cm-selectionMatch": {
          backgroundColor: "transparent"
        }
      }), nY = ({ state: t, dispatch: e }) => {
        let { selection: n } = t, r = q.create(n.ranges.map((i) => t.wordAt(i.head) || q.cursor(i.head)), n.mainIndex);
        return r.eq(n) ? false : (e(t.update({
          selection: r
        })), true);
      };
      function rY(t, e) {
        let { main: n, ranges: r } = t.selection, i = t.wordAt(n.head), o = i && i.from == n.from && i.to == n.to;
        for (let s = false, a = new bl(t.doc, e, r[r.length - 1].to); ; )
          if (a.next(), a.done) {
            if (s)
              return null;
            a = new bl(t.doc, e, 0, Math.max(0, r[r.length - 1].from - 1)), s = true;
          } else {
            if (s && r.some((l) => l.from == a.value.from))
              continue;
            if (o) {
              let l = t.wordAt(a.value.from);
              if (!l || l.from != a.value.from || l.to != a.value.to)
                continue;
            }
            return a.value;
          }
      }
      const iY = ({ state: t, dispatch: e }) => {
        let { ranges: n } = t.selection;
        if (n.some((o) => o.from === o.to))
          return nY({
            state: t,
            dispatch: e
          });
        let r = t.sliceDoc(n[0].from, n[0].to);
        if (t.selection.ranges.some((o) => t.sliceDoc(o.from, o.to) != r))
          return false;
        let i = rY(t, r);
        return i ? (e(t.update({
          selection: t.selection.addRange(q.range(i.from, i.to), false),
          effects: ce.scrollIntoView(i.to)
        })), true) : false;
      }, Pl = pe.define({
        combine(t) {
          return Ei(t, {
            top: false,
            caseSensitive: false,
            literal: false,
            regexp: false,
            wholeWord: false,
            createPanel: (e) => new gY(e),
            scrollToMatch: (e) => ce.scrollIntoView(e)
          });
        }
      });
      class Zx {
        constructor(e) {
          this.search = e.search, this.caseSensitive = !!e.caseSensitive, this.literal = !!e.literal, this.regexp = !!e.regexp, this.replace = e.replace || "", this.valid = !!this.search && (!this.regexp || KG(this.search)), this.unquoted = this.unquote(this.search), this.wholeWord = !!e.wholeWord;
        }
        unquote(e) {
          return this.literal ? e : e.replace(/\\([nrt\\])/g, (n, r) => r == "n" ? `
` : r == "r" ? "\r" : r == "t" ? "	" : "\\");
        }
        eq(e) {
          return this.search == e.search && this.replace == e.replace && this.caseSensitive == e.caseSensitive && this.regexp == e.regexp && this.wholeWord == e.wholeWord;
        }
        create() {
          return this.regexp ? new lY(this) : new sY(this);
        }
        getCursor(e, n = 0, r) {
          let i = e.doc ? e : Ne.create({
            doc: e
          });
          return r == null && (r = i.doc.length), this.regexp ? fa(this, i, n, r) : ua(this, i, n, r);
        }
      }
      class EL {
        constructor(e) {
          this.spec = e;
        }
      }
      function ua(t, e, n, r) {
        return new bl(e.doc, t.unquoted, n, r, t.caseSensitive ? void 0 : (i) => i.toLowerCase(), t.wholeWord ? oY(e.doc, e.charCategorizer(e.selection.main.head)) : void 0);
      }
      function oY(t, e) {
        return (n, r, i, o) => ((o > n || o + i.length < r) && (o = Math.max(0, n - 2), i = t.sliceString(o, Math.min(t.length, r + 2))), (e(Ip(i, n - o)) != ht.Word || e(Bp(i, n - o)) != ht.Word) && (e(Bp(i, r - o)) != ht.Word || e(Ip(i, r - o)) != ht.Word));
      }
      class sY extends EL {
        constructor(e) {
          super(e);
        }
        nextMatch(e, n, r) {
          let i = ua(this.spec, e, r, e.doc.length).nextOverlapping();
          if (i.done) {
            let o = Math.min(e.doc.length, n + this.spec.unquoted.length);
            i = ua(this.spec, e, 0, o).nextOverlapping();
          }
          return i.done || i.value.from == n && i.value.to == r ? null : i.value;
        }
        prevMatchInRange(e, n, r) {
          for (let i = r; ; ) {
            let o = Math.max(n, i - 1e4 - this.spec.unquoted.length), s = ua(this.spec, e, o, i), a = null;
            for (; !s.nextOverlapping().done; )
              a = s.value;
            if (a)
              return a;
            if (o == n)
              return null;
            i -= 1e4;
          }
        }
        prevMatch(e, n, r) {
          let i = this.prevMatchInRange(e, 0, n);
          return i || (i = this.prevMatchInRange(e, Math.max(0, r - this.spec.unquoted.length), e.doc.length)), i && (i.from != n || i.to != r) ? i : null;
        }
        getReplacement(e) {
          return this.spec.unquote(this.spec.replace);
        }
        matchAll(e, n) {
          let r = ua(this.spec, e, 0, e.doc.length), i = [];
          for (; !r.next().done; ) {
            if (i.length >= n)
              return null;
            i.push(r.value);
          }
          return i;
        }
        highlight(e, n, r, i) {
          let o = ua(this.spec, e, Math.max(0, n - this.spec.unquoted.length), Math.min(r + this.spec.unquoted.length, e.doc.length));
          for (; !o.next().done; )
            i(o.value.from, o.value.to);
        }
      }
      function fa(t, e, n, r) {
        return new Jx(e.doc, t.search, {
          ignoreCase: !t.caseSensitive,
          test: t.wholeWord ? aY(e.charCategorizer(e.selection.main.head)) : void 0
        }, n, r);
      }
      function Ip(t, e) {
        return t.slice(en(t, e, false), e);
      }
      function Bp(t, e) {
        return t.slice(e, en(t, e));
      }
      function aY(t) {
        return (e, n, r) => !r[0].length || (t(Ip(r.input, r.index)) != ht.Word || t(Bp(r.input, r.index)) != ht.Word) && (t(Bp(r.input, r.index + r[0].length)) != ht.Word || t(Ip(r.input, r.index + r[0].length)) != ht.Word);
      }
      class lY extends EL {
        nextMatch(e, n, r) {
          let i = fa(this.spec, e, r, e.doc.length).next();
          return i.done && (i = fa(this.spec, e, 0, n).next()), i.done ? null : i.value;
        }
        prevMatchInRange(e, n, r) {
          for (let i = 1; ; i++) {
            let o = Math.max(n, r - i * 1e4), s = fa(this.spec, e, o, r), a = null;
            for (; !s.next().done; )
              a = s.value;
            if (a && (o == n || a.from > o + 10))
              return a;
            if (o == n)
              return null;
          }
        }
        prevMatch(e, n, r) {
          return this.prevMatchInRange(e, 0, n) || this.prevMatchInRange(e, r, e.doc.length);
        }
        getReplacement(e) {
          return this.spec.unquote(this.spec.replace).replace(/\$([$&]|\d+)/g, (n, r) => {
            if (r == "&")
              return e.match[0];
            if (r == "$")
              return "$";
            for (let i = r.length; i > 0; i--) {
              let o = +r.slice(0, i);
              if (o > 0 && o < e.match.length)
                return e.match[o] + r.slice(i);
            }
            return n;
          });
        }
        matchAll(e, n) {
          let r = fa(this.spec, e, 0, e.doc.length), i = [];
          for (; !r.next().done; ) {
            if (i.length >= n)
              return null;
            i.push(r.value);
          }
          return i;
        }
        highlight(e, n, r, i) {
          let o = fa(this.spec, e, Math.max(0, n - 250), Math.min(r + 250, e.doc.length));
          for (; !o.next().done; )
            i(o.value.from, o.value.to);
        }
      }
      const Jo = Pe.define(), eS = Pe.define(), Wo = Ut.define({
        create(t) {
          return new J0(T1(t).create(), null);
        },
        update(t, e) {
          for (let n of e.effects)
            n.is(Jo) ? t = new J0(n.value.create(), t.panel) : n.is(eS) && (t = new J0(t.query, n.value ? tS : null));
          return t;
        },
        provide: (t) => Ks.from(t, (e) => e.panel)
      });
      class J0 {
        constructor(e, n) {
          this.query = e, this.panel = n;
        }
      }
      const cY = be.mark({
        class: "cm-searchMatch"
      }), uY = be.mark({
        class: "cm-searchMatch cm-searchMatch-selected"
      }), fY = Ct.fromClass(class {
        constructor(t) {
          this.view = t, this.decorations = this.highlight(t.state.field(Wo));
        }
        update(t) {
          let e = t.state.field(Wo);
          (e != t.startState.field(Wo) || t.docChanged || t.selectionSet || t.viewportChanged) && (this.decorations = this.highlight(e));
        }
        highlight({ query: t, panel: e }) {
          if (!e || !t.spec.valid)
            return be.none;
          let { view: n } = this, r = new Ci();
          for (let i = 0, o = n.visibleRanges, s = o.length; i < s; i++) {
            let { from: a, to: l } = o[i];
            for (; i < s - 1 && l > o[i + 1].from - 2 * 250; )
              l = o[++i].to;
            t.highlight(n.state, a, l, (c, u) => {
              let h = n.state.selection.ranges.some((p) => p.from == c && p.to == u);
              r.add(c, u, h ? uY : cY);
            });
          }
          return r.finish();
        }
      }, {
        decorations: (t) => t.decorations
      });
      function ff(t) {
        return (e) => {
          let n = e.state.field(Wo, false);
          return n && n.query.spec.valid ? t(e, n) : RL(e);
        };
      }
      const Np = ff((t, { query: e }) => {
        let { to: n } = t.state.selection.main, r = e.nextMatch(t.state, n, n);
        if (!r)
          return false;
        let i = q.single(r.from, r.to), o = t.state.facet(Pl);
        return t.dispatch({
          selection: i,
          effects: [
            nS(t, r),
            o.scrollToMatch(i.main, t)
          ],
          userEvent: "select.search"
        }), OL(t), true;
      }), $p = ff((t, { query: e }) => {
        let { state: n } = t, { from: r } = n.selection.main, i = e.prevMatch(n, r, r);
        if (!i)
          return false;
        let o = q.single(i.from, i.to), s = t.state.facet(Pl);
        return t.dispatch({
          selection: o,
          effects: [
            nS(t, i),
            s.scrollToMatch(o.main, t)
          ],
          userEvent: "select.search"
        }), OL(t), true;
      }), hY = ff((t, { query: e }) => {
        let n = e.matchAll(t.state, 1e3);
        return !n || !n.length ? false : (t.dispatch({
          selection: q.create(n.map((r) => q.range(r.from, r.to))),
          userEvent: "select.search.matches"
        }), true);
      }), dY = ({ state: t, dispatch: e }) => {
        let n = t.selection;
        if (n.ranges.length > 1 || n.main.empty)
          return false;
        let { from: r, to: i } = n.main, o = [], s = 0;
        for (let a = new bl(t.doc, t.sliceDoc(r, i)); !a.next().done; ) {
          if (o.length > 1e3)
            return false;
          a.value.from == r && (s = o.length), o.push(q.range(a.value.from, a.value.to));
        }
        return e(t.update({
          selection: q.create(o, s),
          userEvent: "select.search.matches"
        })), true;
      }, _T = ff((t, { query: e }) => {
        let { state: n } = t, { from: r, to: i } = n.selection.main;
        if (n.readOnly)
          return false;
        let o = e.nextMatch(n, r, r);
        if (!o)
          return false;
        let s = o, a = [], l, c, u = [];
        if (s.from == r && s.to == i && (c = n.toText(e.getReplacement(s)), a.push({
          from: s.from,
          to: s.to,
          insert: c
        }), s = e.nextMatch(n, s.from, s.to), u.push(ce.announce.of(n.phrase("replaced match on line $", n.doc.lineAt(r).number) + "."))), s) {
          let h = a.length == 0 || a[0].from >= o.to ? 0 : o.to - o.from - c.length;
          l = q.single(s.from - h, s.to - h), u.push(nS(t, s)), u.push(n.facet(Pl).scrollToMatch(l.main, t));
        }
        return t.dispatch({
          changes: a,
          selection: l,
          effects: u,
          userEvent: "input.replace"
        }), true;
      }), pY = ff((t, { query: e }) => {
        if (t.state.readOnly)
          return false;
        let n = e.matchAll(t.state, 1e9).map((i) => {
          let { from: o, to: s } = i;
          return {
            from: o,
            to: s,
            insert: e.getReplacement(i)
          };
        });
        if (!n.length)
          return false;
        let r = t.state.phrase("replaced $ matches", n.length) + ".";
        return t.dispatch({
          changes: n,
          effects: ce.announce.of(r),
          userEvent: "input.replace.all"
        }), true;
      });
      function tS(t) {
        return t.state.facet(Pl).createPanel(t);
      }
      function T1(t, e) {
        var n, r, i, o, s;
        let a = t.selection.main, l = a.empty || a.to > a.from + 100 ? "" : t.sliceDoc(a.from, a.to);
        if (e && !l)
          return e;
        let c = t.facet(Pl);
        return new Zx({
          search: ((n = e == null ? void 0 : e.literal) !== null && n !== void 0 ? n : c.literal) ? l : l.replace(/\n/g, "\\n"),
          caseSensitive: (r = e == null ? void 0 : e.caseSensitive) !== null && r !== void 0 ? r : c.caseSensitive,
          literal: (i = e == null ? void 0 : e.literal) !== null && i !== void 0 ? i : c.literal,
          regexp: (o = e == null ? void 0 : e.regexp) !== null && o !== void 0 ? o : c.regexp,
          wholeWord: (s = e == null ? void 0 : e.wholeWord) !== null && s !== void 0 ? s : c.wholeWord
        });
      }
      function PL(t) {
        let e = Nu(t, tS);
        return e && e.dom.querySelector("[main-field]");
      }
      function OL(t) {
        let e = PL(t);
        e && e == t.root.activeElement && e.select();
      }
      const RL = (t) => {
        let e = t.state.field(Wo, false);
        if (e && e.panel) {
          let n = PL(t);
          if (n && n != t.root.activeElement) {
            let r = T1(t.state, e.query.spec);
            r.valid && t.dispatch({
              effects: Jo.of(r)
            }), n.focus(), n.select();
          }
        } else
          t.dispatch({
            effects: [
              eS.of(true),
              e ? Jo.of(T1(t.state, e.query.spec)) : Pe.appendConfig.of(yY)
            ]
          });
        return true;
      }, LL = (t) => {
        let e = t.state.field(Wo, false);
        if (!e || !e.panel)
          return false;
        let n = Nu(t, tS);
        return n && n.dom.contains(t.root.activeElement) && t.focus(), t.dispatch({
          effects: eS.of(false)
        }), true;
      }, mY = [
        {
          key: "Mod-f",
          run: RL,
          scope: "editor search-panel"
        },
        {
          key: "F3",
          run: Np,
          shift: $p,
          scope: "editor search-panel",
          preventDefault: true
        },
        {
          key: "Mod-g",
          run: Np,
          shift: $p,
          scope: "editor search-panel",
          preventDefault: true
        },
        {
          key: "Escape",
          run: LL,
          scope: "editor search-panel"
        },
        {
          key: "Mod-Shift-l",
          run: dY
        },
        {
          key: "Mod-Alt-g",
          run: qG
        },
        {
          key: "Mod-d",
          run: iY,
          preventDefault: true
        }
      ];
      class gY {
        constructor(e) {
          this.view = e;
          let n = this.query = e.state.field(Wo).query.spec;
          this.commit = this.commit.bind(this), this.searchField = Qe("input", {
            value: n.search,
            placeholder: Hn(e, "Find"),
            "aria-label": Hn(e, "Find"),
            class: "cm-textfield",
            name: "search",
            form: "",
            "main-field": "true",
            onchange: this.commit,
            onkeyup: this.commit
          }), this.replaceField = Qe("input", {
            value: n.replace,
            placeholder: Hn(e, "Replace"),
            "aria-label": Hn(e, "Replace"),
            class: "cm-textfield",
            name: "replace",
            form: "",
            onchange: this.commit,
            onkeyup: this.commit
          }), this.caseField = Qe("input", {
            type: "checkbox",
            name: "case",
            form: "",
            checked: n.caseSensitive,
            onchange: this.commit
          }), this.reField = Qe("input", {
            type: "checkbox",
            name: "re",
            form: "",
            checked: n.regexp,
            onchange: this.commit
          }), this.wordField = Qe("input", {
            type: "checkbox",
            name: "word",
            form: "",
            checked: n.wholeWord,
            onchange: this.commit
          });
          function r(i, o, s) {
            return Qe("button", {
              class: "cm-button",
              name: i,
              onclick: o,
              type: "button"
            }, s);
          }
          this.dom = Qe("div", {
            onkeydown: (i) => this.keydown(i),
            class: "cm-search"
          }, [
            this.searchField,
            r("next", () => Np(e), [
              Hn(e, "next")
            ]),
            r("prev", () => $p(e), [
              Hn(e, "previous")
            ]),
            r("select", () => hY(e), [
              Hn(e, "all")
            ]),
            Qe("label", null, [
              this.caseField,
              Hn(e, "match case")
            ]),
            Qe("label", null, [
              this.reField,
              Hn(e, "regexp")
            ]),
            Qe("label", null, [
              this.wordField,
              Hn(e, "by word")
            ]),
            ...e.state.readOnly ? [] : [
              Qe("br"),
              this.replaceField,
              r("replace", () => _T(e), [
                Hn(e, "replace")
              ]),
              r("replaceAll", () => pY(e), [
                Hn(e, "replace all")
              ])
            ],
            Qe("button", {
              name: "close",
              onclick: () => LL(e),
              "aria-label": Hn(e, "close"),
              type: "button"
            }, [
              "\xD7"
            ])
          ]);
        }
        commit() {
          let e = new Zx({
            search: this.searchField.value,
            caseSensitive: this.caseField.checked,
            regexp: this.reField.checked,
            wholeWord: this.wordField.checked,
            replace: this.replaceField.value
          });
          e.eq(this.query) || (this.query = e, this.view.dispatch({
            effects: Jo.of(e)
          }));
        }
        keydown(e) {
          ys(this.view, e, "search-panel") ? e.preventDefault() : e.keyCode == 13 && e.target == this.searchField ? (e.preventDefault(), (e.shiftKey ? $p : Np)(this.view)) : e.keyCode == 13 && e.target == this.replaceField && (e.preventDefault(), _T(this.view));
        }
        update(e) {
          for (let n of e.transactions)
            for (let r of n.effects)
              r.is(Jo) && !r.value.eq(this.query) && this.setQuery(r.value);
        }
        setQuery(e) {
          this.query = e, this.searchField.value = e.search, this.replaceField.value = e.replace, this.caseField.checked = e.caseSensitive, this.reField.checked = e.regexp, this.wordField.checked = e.wholeWord;
        }
        mount() {
          this.searchField.select();
        }
        get pos() {
          return 80;
        }
        get top() {
          return this.view.state.facet(Pl).top;
        }
      }
      function Hn(t, e) {
        return t.state.phrase(e);
      }
      const Bh = 30, Nh = /[\s\.,:;?!]/;
      function nS(t, { from: e, to: n }) {
        let r = t.state.doc.lineAt(e), i = t.state.doc.lineAt(n).to, o = Math.max(r.from, e - Bh), s = Math.min(i, n + Bh), a = t.state.sliceDoc(o, s);
        if (o != r.from) {
          for (let l = 0; l < Bh; l++)
            if (!Nh.test(a[l + 1]) && Nh.test(a[l])) {
              a = a.slice(l);
              break;
            }
        }
        if (s != i) {
          for (let l = a.length - 1; l > a.length - Bh; l--)
            if (!Nh.test(a[l - 1]) && Nh.test(a[l])) {
              a = a.slice(0, l);
              break;
            }
        }
        return ce.announce.of(`${t.state.phrase("current match")}. ${a} ${t.state.phrase("on line")} ${r.number}.`);
      }
      const vY = ce.baseTheme({
        ".cm-panel.cm-search": {
          padding: "2px 6px 4px",
          position: "relative",
          "& [name=close]": {
            position: "absolute",
            top: "0",
            right: "4px",
            backgroundColor: "inherit",
            border: "none",
            font: "inherit",
            padding: 0,
            margin: 0
          },
          "& input, & button, & label": {
            margin: ".2em .6em .2em 0"
          },
          "& input[type=checkbox]": {
            marginRight: ".2em"
          },
          "& label": {
            fontSize: "80%",
            whiteSpace: "pre"
          }
        },
        "&light .cm-searchMatch": {
          backgroundColor: "#ffff0054"
        },
        "&dark .cm-searchMatch": {
          backgroundColor: "#00ffff8a"
        },
        "&light .cm-searchMatch-selected": {
          backgroundColor: "#ff6a0054"
        },
        "&dark .cm-searchMatch-selected": {
          backgroundColor: "#ff00ff8a"
        }
      }), yY = [
        Wo,
        ns.low(fY),
        vY
      ];
      class DL {
        constructor(e, n, r, i) {
          this.state = e, this.pos = n, this.explicit = r, this.view = i, this.abortListeners = [], this.abortOnDocChange = false;
        }
        tokenBefore(e) {
          let n = mn(this.state).resolveInner(this.pos, -1);
          for (; n && e.indexOf(n.name) < 0; )
            n = n.parent;
          return n ? {
            from: n.from,
            to: this.pos,
            text: this.state.sliceDoc(n.from, this.pos),
            type: n.type
          } : null;
        }
        matchBefore(e) {
          let n = this.state.doc.lineAt(this.pos), r = Math.max(n.from, this.pos - 250), i = n.text.slice(r - n.from, this.pos - n.from), o = i.search(_L(e, false));
          return o < 0 ? null : {
            from: r + o,
            to: this.pos,
            text: i.slice(o)
          };
        }
        get aborted() {
          return this.abortListeners == null;
        }
        addEventListener(e, n, r) {
          e == "abort" && this.abortListeners && (this.abortListeners.push(n), r && r.onDocChange && (this.abortOnDocChange = true));
        }
      }
      function IT(t) {
        let e = Object.keys(t).join(""), n = /\w/.test(e);
        return n && (e = e.replace(/\w/g, "")), `[${n ? "\\w" : ""}${e.replace(/[^\w\s]/g, "\\$&")}]`;
      }
      function bY(t) {
        let e = /* @__PURE__ */ Object.create(null), n = /* @__PURE__ */ Object.create(null);
        for (let { label: i } of t) {
          e[i[0]] = true;
          for (let o = 1; o < i.length; o++)
            n[i[o]] = true;
        }
        let r = IT(e) + IT(n) + "*$";
        return [
          new RegExp("^" + r),
          new RegExp(r)
        ];
      }
      function xY(t) {
        let e = t.map((i) => typeof i == "string" ? {
          label: i
        } : i), [n, r] = e.every((i) => /^\w+$/.test(i.label)) ? [
          /\w*$/,
          /\w+$/
        ] : bY(e);
        return (i) => {
          let o = i.matchBefore(r);
          return o || i.explicit ? {
            from: o ? o.from : i.pos,
            options: e,
            validFor: n
          } : null;
        };
      }
      class BT {
        constructor(e, n, r, i) {
          this.completion = e, this.source = n, this.match = r, this.score = i;
        }
      }
      function Is(t) {
        return t.selection.main.from;
      }
      function _L(t, e) {
        var n;
        let { source: r } = t, i = e && r[0] != "^", o = r[r.length - 1] != "$";
        return !i && !o ? t : new RegExp(`${i ? "^" : ""}(?:${r})${o ? "$" : ""}`, (n = t.flags) !== null && n !== void 0 ? n : t.ignoreCase ? "i" : "");
      }
      const IL = Ai.define();
      function SY(t, e, n, r) {
        let { main: i } = t.selection, o = n - i.from, s = r - i.from;
        return Object.assign(Object.assign({}, t.changeByRange((a) => {
          if (a != i && n != r && t.sliceDoc(a.from + o, a.from + s) != t.sliceDoc(n, r))
            return {
              range: a
            };
          let l = t.toText(e);
          return {
            changes: {
              from: a.from + o,
              to: r == i.from ? a.to : a.from + s,
              insert: l
            },
            range: q.cursor(a.from + o + l.length)
          };
        })), {
          scrollIntoView: true,
          userEvent: "input.complete"
        });
      }
      const NT = /* @__PURE__ */ new WeakMap();
      function wY(t) {
        if (!Array.isArray(t))
          return t;
        let e = NT.get(t);
        return e || NT.set(t, e = xY(t)), e;
      }
      const zp = Pe.define(), Fu = Pe.define();
      class kY {
        constructor(e) {
          this.pattern = e, this.chars = [], this.folded = [], this.any = [], this.precise = [], this.byWord = [], this.score = 0, this.matched = [];
          for (let n = 0; n < e.length; ) {
            let r = Rn(e, n), i = di(r);
            this.chars.push(r);
            let o = e.slice(n, n + i), s = o.toUpperCase();
            this.folded.push(Rn(s == o ? o.toLowerCase() : s, 0)), n += i;
          }
          this.astral = e.length != this.chars.length;
        }
        ret(e, n) {
          return this.score = e, this.matched = n, this;
        }
        match(e) {
          if (this.pattern.length == 0)
            return this.ret(-100, []);
          if (e.length < this.pattern.length)
            return null;
          let { chars: n, folded: r, any: i, precise: o, byWord: s } = this;
          if (n.length == 1) {
            let k = Rn(e, 0), T = di(k), P = T == e.length ? 0 : -100;
            if (k != n[0])
              if (k == r[0])
                P += -200;
              else
                return null;
            return this.ret(P, [
              0,
              T
            ]);
          }
          let a = e.indexOf(this.pattern);
          if (a == 0)
            return this.ret(e.length == this.pattern.length ? 0 : -100, [
              0,
              this.pattern.length
            ]);
          let l = n.length, c = 0;
          if (a < 0) {
            for (let k = 0, T = Math.min(e.length, 200); k < T && c < l; ) {
              let P = Rn(e, k);
              (P == n[c] || P == r[c]) && (i[c++] = k), k += di(P);
            }
            if (c < l)
              return null;
          }
          let u = 0, h = 0, p = false, v = 0, y = -1, S = -1, C = /[a-z]/.test(e), w = true;
          for (let k = 0, T = Math.min(e.length, 200), P = 0; k < T && h < l; ) {
            let R = Rn(e, k);
            a < 0 && (u < l && R == n[u] && (o[u++] = k), v < l && (R == n[v] || R == r[v] ? (v == 0 && (y = k), S = k + 1, v++) : v = 0));
            let L, D = R < 255 ? R >= 48 && R <= 57 || R >= 97 && R <= 122 ? 2 : R >= 65 && R <= 90 ? 1 : 0 : (L = Sx(R)) != L.toLowerCase() ? 1 : L != L.toUpperCase() ? 2 : 0;
            (!k || D == 1 && C || P == 0 && D != 0) && (n[h] == R || r[h] == R && (p = true) ? s[h++] = k : s.length && (w = false)), P = D, k += di(R);
          }
          return h == l && s[0] == 0 && w ? this.result(-100 + (p ? -200 : 0), s, e) : v == l && y == 0 ? this.ret(-200 - e.length + (S == e.length ? 0 : -100), [
            0,
            S
          ]) : a > -1 ? this.ret(-700 - e.length, [
            a,
            a + this.pattern.length
          ]) : v == l ? this.ret(-200 + -700 - e.length, [
            y,
            S
          ]) : h == l ? this.result(-100 + (p ? -200 : 0) + -700 + (w ? 0 : -1100), s, e) : n.length == 2 ? null : this.result((i[0] ? -700 : 0) + -200 + -1100, i, e);
        }
        result(e, n, r) {
          let i = [], o = 0;
          for (let s of n) {
            let a = s + (this.astral ? di(Rn(r, s)) : 1);
            o && i[o - 1] == s ? i[o - 1] = a : (i[o++] = s, i[o++] = a);
          }
          return this.ret(e - r.length, i);
        }
      }
      class CY {
        constructor(e) {
          this.pattern = e, this.matched = [], this.score = 0, this.folded = e.toLowerCase();
        }
        match(e) {
          if (e.length < this.pattern.length)
            return null;
          let n = e.slice(0, this.pattern.length), r = n == this.pattern ? 0 : n.toLowerCase() == this.folded ? -200 : null;
          return r == null ? null : (this.matched = [
            0,
            n.length
          ], this.score = r + (e.length == this.pattern.length ? 0 : -100), this);
        }
      }
      const Ht = pe.define({
        combine(t) {
          return Ei(t, {
            activateOnTyping: true,
            activateOnCompletion: () => false,
            activateOnTypingDelay: 100,
            selectOnOpen: true,
            override: null,
            closeOnBlur: true,
            maxRenderedOptions: 100,
            defaultKeymap: true,
            tooltipClass: () => "",
            optionClass: () => "",
            aboveCursor: false,
            icons: true,
            addToOptions: [],
            positionInfo: TY,
            filterStrict: false,
            compareCompletions: (e, n) => e.label.localeCompare(n.label),
            interactionDelay: 75,
            updateSyncTime: 100
          }, {
            defaultKeymap: (e, n) => e && n,
            closeOnBlur: (e, n) => e && n,
            icons: (e, n) => e && n,
            tooltipClass: (e, n) => (r) => $T(e(r), n(r)),
            optionClass: (e, n) => (r) => $T(e(r), n(r)),
            addToOptions: (e, n) => e.concat(n),
            filterStrict: (e, n) => e || n
          });
        }
      });
      function $T(t, e) {
        return t ? e ? t + " " + e : t : e;
      }
      function TY(t, e, n, r, i, o) {
        let s = t.textDirection == rt.RTL, a = s, l = false, c = "top", u, h, p = e.left - i.left, v = i.right - e.right, y = r.right - r.left, S = r.bottom - r.top;
        if (a && p < Math.min(y, v) ? a = false : !a && v < Math.min(y, p) && (a = true), y <= (a ? p : v))
          u = Math.max(i.top, Math.min(n.top, i.bottom - S)) - e.top, h = Math.min(400, a ? p : v);
        else {
          l = true, h = Math.min(400, (s ? e.right : i.right - e.left) - 30);
          let k = i.bottom - e.bottom;
          k >= S || k > e.top ? u = n.bottom - e.top : (c = "bottom", u = e.bottom - n.top);
        }
        let C = (e.bottom - e.top) / o.offsetHeight, w = (e.right - e.left) / o.offsetWidth;
        return {
          style: `${c}: ${u / C}px; max-width: ${h / w}px`,
          class: "cm-completionInfo-" + (l ? s ? "left-narrow" : "right-narrow" : a ? "left" : "right")
        };
      }
      function MY(t) {
        let e = t.addToOptions.slice();
        return t.icons && e.push({
          render(n) {
            let r = document.createElement("div");
            return r.classList.add("cm-completionIcon"), n.type && r.classList.add(...n.type.split(/\s+/g).map((i) => "cm-completionIcon-" + i)), r.setAttribute("aria-hidden", "true"), r;
          },
          position: 20
        }), e.push({
          render(n, r, i, o) {
            let s = document.createElement("span");
            s.className = "cm-completionLabel";
            let a = n.displayLabel || n.label, l = 0;
            for (let c = 0; c < o.length; ) {
              let u = o[c++], h = o[c++];
              u > l && s.appendChild(document.createTextNode(a.slice(l, u)));
              let p = s.appendChild(document.createElement("span"));
              p.appendChild(document.createTextNode(a.slice(u, h))), p.className = "cm-completionMatchedText", l = h;
            }
            return l < a.length && s.appendChild(document.createTextNode(a.slice(l))), s;
          },
          position: 50
        }, {
          render(n) {
            if (!n.detail)
              return null;
            let r = document.createElement("span");
            return r.className = "cm-completionDetail", r.textContent = n.detail, r;
          },
          position: 80
        }), e.sort((n, r) => n.position - r.position).map((n) => n.render);
      }
      function Z0(t, e, n) {
        if (t <= n)
          return {
            from: 0,
            to: t
          };
        if (e < 0 && (e = 0), e <= t >> 1) {
          let i = Math.floor(e / n);
          return {
            from: i * n,
            to: (i + 1) * n
          };
        }
        let r = Math.floor((t - e) / n);
        return {
          from: t - (r + 1) * n,
          to: t - r * n
        };
      }
      class AY {
        constructor(e, n, r) {
          this.view = e, this.stateField = n, this.applyCompletion = r, this.info = null, this.infoDestroy = null, this.placeInfoReq = {
            read: () => this.measureInfo(),
            write: (l) => this.placeInfo(l),
            key: this
          }, this.space = null, this.currentClass = "";
          let i = e.state.field(n), { options: o, selected: s } = i.open, a = e.state.facet(Ht);
          this.optionContent = MY(a), this.optionClass = a.optionClass, this.tooltipClass = a.tooltipClass, this.range = Z0(o.length, s, a.maxRenderedOptions), this.dom = document.createElement("div"), this.dom.className = "cm-tooltip-autocomplete", this.updateTooltipClass(e.state), this.dom.addEventListener("mousedown", (l) => {
            let { options: c } = e.state.field(n).open;
            for (let u = l.target, h; u && u != this.dom; u = u.parentNode)
              if (u.nodeName == "LI" && (h = /-(\d+)$/.exec(u.id)) && +h[1] < c.length) {
                this.applyCompletion(e, c[+h[1]]), l.preventDefault();
                return;
              }
          }), this.dom.addEventListener("focusout", (l) => {
            let c = e.state.field(this.stateField, false);
            c && c.tooltip && e.state.facet(Ht).closeOnBlur && l.relatedTarget != e.contentDOM && e.dispatch({
              effects: Fu.of(null)
            });
          }), this.showOptions(o, i.id);
        }
        mount() {
          this.updateSel();
        }
        showOptions(e, n) {
          this.list && this.list.remove(), this.list = this.dom.appendChild(this.createListBox(e, n, this.range)), this.list.addEventListener("scroll", () => {
            this.info && this.view.requestMeasure(this.placeInfoReq);
          });
        }
        update(e) {
          var n;
          let r = e.state.field(this.stateField), i = e.startState.field(this.stateField);
          if (this.updateTooltipClass(e.state), r != i) {
            let { options: o, selected: s, disabled: a } = r.open;
            (!i.open || i.open.options != o) && (this.range = Z0(o.length, s, e.state.facet(Ht).maxRenderedOptions), this.showOptions(o, r.id)), this.updateSel(), a != ((n = i.open) === null || n === void 0 ? void 0 : n.disabled) && this.dom.classList.toggle("cm-tooltip-autocomplete-disabled", !!a);
          }
        }
        updateTooltipClass(e) {
          let n = this.tooltipClass(e);
          if (n != this.currentClass) {
            for (let r of this.currentClass.split(" "))
              r && this.dom.classList.remove(r);
            for (let r of n.split(" "))
              r && this.dom.classList.add(r);
            this.currentClass = n;
          }
        }
        positioned(e) {
          this.space = e, this.info && this.view.requestMeasure(this.placeInfoReq);
        }
        updateSel() {
          let e = this.view.state.field(this.stateField), n = e.open;
          if ((n.selected > -1 && n.selected < this.range.from || n.selected >= this.range.to) && (this.range = Z0(n.options.length, n.selected, this.view.state.facet(Ht).maxRenderedOptions), this.showOptions(n.options, e.id)), this.updateSelectedOption(n.selected)) {
            this.destroyInfo();
            let { completion: r } = n.options[n.selected], { info: i } = r;
            if (!i)
              return;
            let o = typeof i == "string" ? document.createTextNode(i) : i(r);
            if (!o)
              return;
            "then" in o ? o.then((s) => {
              s && this.view.state.field(this.stateField, false) == e && this.addInfoPane(s, r);
            }).catch((s) => Bn(this.view.state, s, "completion info")) : this.addInfoPane(o, r);
          }
        }
        addInfoPane(e, n) {
          this.destroyInfo();
          let r = this.info = document.createElement("div");
          if (r.className = "cm-tooltip cm-completionInfo", e.nodeType != null)
            r.appendChild(e), this.infoDestroy = null;
          else {
            let { dom: i, destroy: o } = e;
            r.appendChild(i), this.infoDestroy = o || null;
          }
          this.dom.appendChild(r), this.view.requestMeasure(this.placeInfoReq);
        }
        updateSelectedOption(e) {
          let n = null;
          for (let r = this.list.firstChild, i = this.range.from; r; r = r.nextSibling, i++)
            r.nodeName != "LI" || !r.id ? i-- : i == e ? r.hasAttribute("aria-selected") || (r.setAttribute("aria-selected", "true"), n = r) : r.hasAttribute("aria-selected") && r.removeAttribute("aria-selected");
          return n && PY(this.list, n), n;
        }
        measureInfo() {
          let e = this.dom.querySelector("[aria-selected]");
          if (!e || !this.info)
            return null;
          let n = this.dom.getBoundingClientRect(), r = this.info.getBoundingClientRect(), i = e.getBoundingClientRect(), o = this.space;
          if (!o) {
            let s = this.dom.ownerDocument.documentElement;
            o = {
              left: 0,
              top: 0,
              right: s.clientWidth,
              bottom: s.clientHeight
            };
          }
          return i.top > Math.min(o.bottom, n.bottom) - 10 || i.bottom < Math.max(o.top, n.top) + 10 ? null : this.view.state.facet(Ht).positionInfo(this.view, n, i, r, o, this.dom);
        }
        placeInfo(e) {
          this.info && (e ? (e.style && (this.info.style.cssText = e.style), this.info.className = "cm-tooltip cm-completionInfo " + (e.class || "")) : this.info.style.cssText = "top: -1e6px");
        }
        createListBox(e, n, r) {
          const i = document.createElement("ul");
          i.id = n, i.setAttribute("role", "listbox"), i.setAttribute("aria-expanded", "true"), i.setAttribute("aria-label", this.view.state.phrase("Completions")), i.addEventListener("mousedown", (s) => {
            s.target == i && s.preventDefault();
          });
          let o = null;
          for (let s = r.from; s < r.to; s++) {
            let { completion: a, match: l } = e[s], { section: c } = a;
            if (c) {
              let p = typeof c == "string" ? c : c.name;
              if (p != o && (s > r.from || r.from == 0))
                if (o = p, typeof c != "string" && c.header)
                  i.appendChild(c.header(c));
                else {
                  let v = i.appendChild(document.createElement("completion-section"));
                  v.textContent = p;
                }
            }
            const u = i.appendChild(document.createElement("li"));
            u.id = n + "-" + s, u.setAttribute("role", "option");
            let h = this.optionClass(a);
            h && (u.className = h);
            for (let p of this.optionContent) {
              let v = p(a, this.view.state, this.view, l);
              v && u.appendChild(v);
            }
          }
          return r.from && i.classList.add("cm-completionListIncompleteTop"), r.to < e.length && i.classList.add("cm-completionListIncompleteBottom"), i;
        }
        destroyInfo() {
          this.info && (this.infoDestroy && this.infoDestroy(), this.info.remove(), this.info = null);
        }
        destroy() {
          this.destroyInfo();
        }
      }
      function EY(t, e) {
        return (n) => new AY(n, t, e);
      }
      function PY(t, e) {
        let n = t.getBoundingClientRect(), r = e.getBoundingClientRect(), i = n.height / t.offsetHeight;
        r.top < n.top ? t.scrollTop -= (n.top - r.top) / i : r.bottom > n.bottom && (t.scrollTop += (r.bottom - n.bottom) / i);
      }
      function zT(t) {
        return (t.boost || 0) * 100 + (t.apply ? 10 : 0) + (t.info ? 5 : 0) + (t.type ? 1 : 0);
      }
      function OY(t, e) {
        let n = [], r = null, i = (c) => {
          n.push(c);
          let { section: u } = c.completion;
          if (u) {
            r || (r = []);
            let h = typeof u == "string" ? u : u.name;
            r.some((p) => p.name == h) || r.push(typeof u == "string" ? {
              name: h
            } : u);
          }
        }, o = e.facet(Ht);
        for (let c of t)
          if (c.hasResult()) {
            let u = c.result.getMatch;
            if (c.result.filter === false)
              for (let h of c.result.options)
                i(new BT(h, c.source, u ? u(h) : [], 1e9 - n.length));
            else {
              let h = e.sliceDoc(c.from, c.to), p, v = o.filterStrict ? new CY(h) : new kY(h);
              for (let y of c.result.options)
                if (p = v.match(y.label)) {
                  let S = y.displayLabel ? u ? u(y, p.matched) : [] : p.matched;
                  i(new BT(y, c.source, S, p.score + (y.boost || 0)));
                }
            }
          }
        if (r) {
          let c = /* @__PURE__ */ Object.create(null), u = 0, h = (p, v) => {
            var y, S;
            return ((y = p.rank) !== null && y !== void 0 ? y : 1e9) - ((S = v.rank) !== null && S !== void 0 ? S : 1e9) || (p.name < v.name ? -1 : 1);
          };
          for (let p of r.sort(h))
            u -= 1e5, c[p.name] = u;
          for (let p of n) {
            let { section: v } = p.completion;
            v && (p.score += c[typeof v == "string" ? v : v.name]);
          }
        }
        let s = [], a = null, l = o.compareCompletions;
        for (let c of n.sort((u, h) => h.score - u.score || l(u.completion, h.completion))) {
          let u = c.completion;
          !a || a.label != u.label || a.detail != u.detail || a.type != null && u.type != null && a.type != u.type || a.apply != u.apply || a.boost != u.boost ? s.push(c) : zT(c.completion) > zT(a) && (s[s.length - 1] = c), a = c.completion;
        }
        return s;
      }
      class Da {
        constructor(e, n, r, i, o, s) {
          this.options = e, this.attrs = n, this.tooltip = r, this.timestamp = i, this.selected = o, this.disabled = s;
        }
        setSelected(e, n) {
          return e == this.selected || e >= this.options.length ? this : new Da(this.options, FT(n, e), this.tooltip, this.timestamp, e, this.disabled);
        }
        static build(e, n, r, i, o, s) {
          if (i && !s && e.some((c) => c.isPending))
            return i.setDisabled();
          let a = OY(e, n);
          if (!a.length)
            return i && e.some((c) => c.isPending) ? i.setDisabled() : null;
          let l = n.facet(Ht).selectOnOpen ? 0 : -1;
          if (i && i.selected != l && i.selected != -1) {
            let c = i.options[i.selected].completion;
            for (let u = 0; u < a.length; u++)
              if (a[u].completion == c) {
                l = u;
                break;
              }
          }
          return new Da(a, FT(r, l), {
            pos: e.reduce((c, u) => u.hasResult() ? Math.min(c, u.from) : c, 1e8),
            create: BY,
            above: o.aboveCursor
          }, i ? i.timestamp : Date.now(), l, false);
        }
        map(e) {
          return new Da(this.options, this.attrs, Object.assign(Object.assign({}, this.tooltip), {
            pos: e.mapPos(this.tooltip.pos)
          }), this.timestamp, this.selected, this.disabled);
        }
        setDisabled() {
          return new Da(this.options, this.attrs, this.tooltip, this.timestamp, this.selected, true);
        }
      }
      class Fp {
        constructor(e, n, r) {
          this.active = e, this.id = n, this.open = r;
        }
        static start() {
          return new Fp(_Y, "cm-ac-" + Math.floor(Math.random() * 2e6).toString(36), null);
        }
        update(e) {
          let { state: n } = e, r = n.facet(Ht), o = (r.override || n.languageDataAt("autocomplete", Is(n)).map(wY)).map((l) => (this.active.find((u) => u.source == l) || new vr(l, this.active.some((u) => u.state != 0) ? 1 : 0)).update(e, r));
          o.length == this.active.length && o.every((l, c) => l == this.active[c]) && (o = this.active);
          let s = this.open, a = e.effects.some((l) => l.is(rS));
          s && e.docChanged && (s = s.map(e.changes)), e.selection || o.some((l) => l.hasResult() && e.changes.touchesRange(l.from, l.to)) || !RY(o, this.active) || a ? s = Da.build(o, n, this.id, s, r, a) : s && s.disabled && !o.some((l) => l.isPending) && (s = null), !s && o.every((l) => !l.isPending) && o.some((l) => l.hasResult()) && (o = o.map((l) => l.hasResult() ? new vr(l.source, 0) : l));
          for (let l of e.effects)
            l.is(NL) && (s = s && s.setSelected(l.value, this.id));
          return o == this.active && s == this.open ? this : new Fp(o, this.id, s);
        }
        get tooltip() {
          return this.open ? this.open.tooltip : null;
        }
        get attrs() {
          return this.open ? this.open.attrs : this.active.length ? LY : DY;
        }
      }
      function RY(t, e) {
        if (t == e)
          return true;
        for (let n = 0, r = 0; ; ) {
          for (; n < t.length && !t[n].hasResult(); )
            n++;
          for (; r < e.length && !e[r].hasResult(); )
            r++;
          let i = n == t.length, o = r == e.length;
          if (i || o)
            return i == o;
          if (t[n++].result != e[r++].result)
            return false;
        }
      }
      const LY = {
        "aria-autocomplete": "list"
      }, DY = {};
      function FT(t, e) {
        let n = {
          "aria-autocomplete": "list",
          "aria-haspopup": "listbox",
          "aria-controls": t
        };
        return e > -1 && (n["aria-activedescendant"] = t + "-" + e), n;
      }
      const _Y = [];
      function BL(t, e) {
        if (t.isUserEvent("input.complete")) {
          let r = t.annotation(IL);
          if (r && e.activateOnCompletion(r))
            return 12;
        }
        let n = t.isUserEvent("input.type");
        return n && e.activateOnTyping ? 5 : n ? 1 : t.isUserEvent("delete.backward") ? 2 : t.selection ? 8 : t.docChanged ? 16 : 0;
      }
      class vr {
        constructor(e, n, r = false) {
          this.source = e, this.state = n, this.explicit = r;
        }
        hasResult() {
          return false;
        }
        get isPending() {
          return this.state == 1;
        }
        update(e, n) {
          let r = BL(e, n), i = this;
          (r & 8 || r & 16 && this.touches(e)) && (i = new vr(i.source, 0)), r & 4 && i.state == 0 && (i = new vr(this.source, 1)), i = i.updateFor(e, r);
          for (let o of e.effects)
            if (o.is(zp))
              i = new vr(i.source, 1, o.value);
            else if (o.is(Fu))
              i = new vr(i.source, 0);
            else if (o.is(rS))
              for (let s of o.value)
                s.source == i.source && (i = s);
          return i;
        }
        updateFor(e, n) {
          return this.map(e.changes);
        }
        map(e) {
          return this;
        }
        touches(e) {
          return e.changes.touchesRange(Is(e.state));
        }
      }
      class Qa extends vr {
        constructor(e, n, r, i, o, s) {
          super(e, 3, n), this.limit = r, this.result = i, this.from = o, this.to = s;
        }
        hasResult() {
          return true;
        }
        updateFor(e, n) {
          var r;
          if (!(n & 3))
            return this.map(e.changes);
          let i = this.result;
          i.map && !e.changes.empty && (i = i.map(i, e.changes));
          let o = e.changes.mapPos(this.from), s = e.changes.mapPos(this.to, 1), a = Is(e.state);
          if (a > s || !i || n & 2 && (Is(e.startState) == this.from || a < this.limit))
            return new vr(this.source, n & 4 ? 1 : 0);
          let l = e.changes.mapPos(this.limit);
          return IY(i.validFor, e.state, o, s) ? new Qa(this.source, this.explicit, l, i, o, s) : i.update && (i = i.update(i, o, s, new DL(e.state, a, false))) ? new Qa(this.source, this.explicit, l, i, i.from, (r = i.to) !== null && r !== void 0 ? r : Is(e.state)) : new vr(this.source, 1, this.explicit);
        }
        map(e) {
          return e.empty ? this : (this.result.map ? this.result.map(this.result, e) : this.result) ? new Qa(this.source, this.explicit, e.mapPos(this.limit), this.result, e.mapPos(this.from), e.mapPos(this.to, 1)) : new vr(this.source, 0);
        }
        touches(e) {
          return e.changes.touchesRange(this.from, this.to);
        }
      }
      function IY(t, e, n, r) {
        if (!t)
          return false;
        let i = e.sliceDoc(n, r);
        return typeof t == "function" ? t(i, n, r, e) : _L(t, true).test(i);
      }
      const rS = Pe.define({
        map(t, e) {
          return t.map((n) => n.map(e));
        }
      }), NL = Pe.define(), Dn = Ut.define({
        create() {
          return Fp.start();
        },
        update(t, e) {
          return t.update(e);
        },
        provide: (t) => [
          Bx.from(t, (e) => e.tooltip),
          ce.contentAttributes.from(t, (e) => e.attrs)
        ]
      });
      function iS(t, e) {
        const n = e.completion.apply || e.completion.label;
        let r = t.state.field(Dn).active.find((i) => i.source == e.source);
        return r instanceof Qa ? (typeof n == "string" ? t.dispatch(Object.assign(Object.assign({}, SY(t.state, n, r.from, r.to)), {
          annotations: IL.of(e.completion)
        })) : n(t, e.completion, r.from, r.to), true) : false;
      }
      const BY = EY(Dn, iS);
      function $h(t, e = "option") {
        return (n) => {
          let r = n.state.field(Dn, false);
          if (!r || !r.open || r.open.disabled || Date.now() - r.open.timestamp < n.state.facet(Ht).interactionDelay)
            return false;
          let i = 1, o;
          e == "page" && (o = CR(n, r.open.tooltip)) && (i = Math.max(2, Math.floor(o.dom.offsetHeight / o.dom.querySelector("li").offsetHeight) - 1));
          let { length: s } = r.open.options, a = r.open.selected > -1 ? r.open.selected + i * (t ? 1 : -1) : t ? 0 : s - 1;
          return a < 0 ? a = e == "page" ? 0 : s - 1 : a >= s && (a = e == "page" ? s - 1 : 0), n.dispatch({
            effects: NL.of(a)
          }), true;
        };
      }
      const NY = (t) => {
        let e = t.state.field(Dn, false);
        return t.state.readOnly || !e || !e.open || e.open.selected < 0 || e.open.disabled || Date.now() - e.open.timestamp < t.state.facet(Ht).interactionDelay ? false : iS(t, e.open.options[e.open.selected]);
      }, VT = (t) => t.state.field(Dn, false) ? (t.dispatch({
        effects: zp.of(true)
      }), true) : false, $Y = (t) => {
        let e = t.state.field(Dn, false);
        return !e || !e.active.some((n) => n.state != 0) ? false : (t.dispatch({
          effects: Fu.of(null)
        }), true);
      };
      class zY {
        constructor(e, n) {
          this.active = e, this.context = n, this.time = Date.now(), this.updates = [], this.done = void 0;
        }
      }
      const FY = 50, VY = 1e3, HY = Ct.fromClass(class {
        constructor(t) {
          this.view = t, this.debounceUpdate = -1, this.running = [], this.debounceAccept = -1, this.pendingStart = false, this.composing = 0;
          for (let e of t.state.field(Dn).active)
            e.isPending && this.startQuery(e);
        }
        update(t) {
          let e = t.state.field(Dn), n = t.state.facet(Ht);
          if (!t.selectionSet && !t.docChanged && t.startState.field(Dn) == e)
            return;
          let r = t.transactions.some((o) => {
            let s = BL(o, n);
            return s & 8 || (o.selection || o.docChanged) && !(s & 3);
          });
          for (let o = 0; o < this.running.length; o++) {
            let s = this.running[o];
            if (r || s.context.abortOnDocChange && t.docChanged || s.updates.length + t.transactions.length > FY && Date.now() - s.time > VY) {
              for (let a of s.context.abortListeners)
                try {
                  a();
                } catch (l) {
                  Bn(this.view.state, l);
                }
              s.context.abortListeners = null, this.running.splice(o--, 1);
            } else
              s.updates.push(...t.transactions);
          }
          this.debounceUpdate > -1 && clearTimeout(this.debounceUpdate), t.transactions.some((o) => o.effects.some((s) => s.is(zp))) && (this.pendingStart = true);
          let i = this.pendingStart ? 50 : n.activateOnTypingDelay;
          if (this.debounceUpdate = e.active.some((o) => o.isPending && !this.running.some((s) => s.active.source == o.source)) ? setTimeout(() => this.startUpdate(), i) : -1, this.composing != 0)
            for (let o of t.transactions)
              o.isUserEvent("input.type") ? this.composing = 2 : this.composing == 2 && o.selection && (this.composing = 3);
        }
        startUpdate() {
          this.debounceUpdate = -1, this.pendingStart = false;
          let { state: t } = this.view, e = t.field(Dn);
          for (let n of e.active)
            n.isPending && !this.running.some((r) => r.active.source == n.source) && this.startQuery(n);
          this.running.length && e.open && e.open.disabled && (this.debounceAccept = setTimeout(() => this.accept(), this.view.state.facet(Ht).updateSyncTime));
        }
        startQuery(t) {
          let { state: e } = this.view, n = Is(e), r = new DL(e, n, t.explicit, this.view), i = new zY(t, r);
          this.running.push(i), Promise.resolve(t.source(r)).then((o) => {
            i.context.aborted || (i.done = o || null, this.scheduleAccept());
          }, (o) => {
            this.view.dispatch({
              effects: Fu.of(null)
            }), Bn(this.view.state, o);
          });
        }
        scheduleAccept() {
          this.running.every((t) => t.done !== void 0) ? this.accept() : this.debounceAccept < 0 && (this.debounceAccept = setTimeout(() => this.accept(), this.view.state.facet(Ht).updateSyncTime));
        }
        accept() {
          var t;
          this.debounceAccept > -1 && clearTimeout(this.debounceAccept), this.debounceAccept = -1;
          let e = [], n = this.view.state.facet(Ht), r = this.view.state.field(Dn);
          for (let i = 0; i < this.running.length; i++) {
            let o = this.running[i];
            if (o.done === void 0)
              continue;
            if (this.running.splice(i--, 1), o.done) {
              let a = Is(o.updates.length ? o.updates[0].startState : this.view.state), l = Math.min(a, o.done.from + (o.active.explicit ? 0 : 1)), c = new Qa(o.active.source, o.active.explicit, l, o.done, o.done.from, (t = o.done.to) !== null && t !== void 0 ? t : a);
              for (let u of o.updates)
                c = c.update(u, n);
              if (c.hasResult()) {
                e.push(c);
                continue;
              }
            }
            let s = r.active.find((a) => a.source == o.active.source);
            if (s && s.isPending)
              if (o.done == null) {
                let a = new vr(o.active.source, 0);
                for (let l of o.updates)
                  a = a.update(l, n);
                a.isPending || e.push(a);
              } else
                this.startQuery(s);
          }
          (e.length || r.open && r.open.disabled) && this.view.dispatch({
            effects: rS.of(e)
          });
        }
      }, {
        eventHandlers: {
          blur(t) {
            let e = this.view.state.field(Dn, false);
            if (e && e.tooltip && this.view.state.facet(Ht).closeOnBlur) {
              let n = e.open && CR(this.view, e.open.tooltip);
              (!n || !n.dom.contains(t.relatedTarget)) && setTimeout(() => this.view.dispatch({
                effects: Fu.of(null)
              }), 10);
            }
          },
          compositionstart() {
            this.composing = 1;
          },
          compositionend() {
            this.composing == 3 && setTimeout(() => this.view.dispatch({
              effects: zp.of(false)
            }), 20), this.composing = 0;
          }
        }
      }), jY = typeof navigator == "object" && /Win/.test(navigator.platform), WY = ns.highest(ce.domEventHandlers({
        keydown(t, e) {
          let n = e.state.field(Dn, false);
          if (!n || !n.open || n.open.disabled || n.open.selected < 0 || t.key.length > 1 || t.ctrlKey && !(jY && t.altKey) || t.metaKey)
            return false;
          let r = n.open.options[n.open.selected], i = n.active.find((s) => s.source == r.source), o = r.completion.commitCharacters || i.result.commitCharacters;
          return o && o.indexOf(t.key) > -1 && iS(e, r), false;
        }
      })), UY = ce.baseTheme({
        ".cm-tooltip.cm-tooltip-autocomplete": {
          "& > ul": {
            fontFamily: "monospace",
            whiteSpace: "nowrap",
            overflow: "hidden auto",
            maxWidth_fallback: "700px",
            maxWidth: "min(700px, 95vw)",
            minWidth: "250px",
            maxHeight: "10em",
            height: "100%",
            listStyle: "none",
            margin: 0,
            padding: 0,
            "& > li, & > completion-section": {
              padding: "1px 3px",
              lineHeight: 1.2
            },
            "& > li": {
              overflowX: "hidden",
              textOverflow: "ellipsis",
              cursor: "pointer"
            },
            "& > completion-section": {
              display: "list-item",
              borderBottom: "1px solid silver",
              paddingLeft: "0.5em",
              opacity: 0.7
            }
          }
        },
        "&light .cm-tooltip-autocomplete ul li[aria-selected]": {
          background: "#17c",
          color: "white"
        },
        "&light .cm-tooltip-autocomplete-disabled ul li[aria-selected]": {
          background: "#777"
        },
        "&dark .cm-tooltip-autocomplete ul li[aria-selected]": {
          background: "#347",
          color: "white"
        },
        "&dark .cm-tooltip-autocomplete-disabled ul li[aria-selected]": {
          background: "#444"
        },
        ".cm-completionListIncompleteTop:before, .cm-completionListIncompleteBottom:after": {
          content: '"\xB7\xB7\xB7"',
          opacity: 0.5,
          display: "block",
          textAlign: "center"
        },
        ".cm-tooltip.cm-completionInfo": {
          position: "absolute",
          padding: "3px 9px",
          width: "max-content",
          maxWidth: `${400}px`,
          boxSizing: "border-box",
          whiteSpace: "pre-line"
        },
        ".cm-completionInfo.cm-completionInfo-left": {
          right: "100%"
        },
        ".cm-completionInfo.cm-completionInfo-right": {
          left: "100%"
        },
        ".cm-completionInfo.cm-completionInfo-left-narrow": {
          right: `${30}px`
        },
        ".cm-completionInfo.cm-completionInfo-right-narrow": {
          left: `${30}px`
        },
        "&light .cm-snippetField": {
          backgroundColor: "#00000022"
        },
        "&dark .cm-snippetField": {
          backgroundColor: "#ffffff22"
        },
        ".cm-snippetFieldPosition": {
          verticalAlign: "text-top",
          width: 0,
          height: "1.15em",
          display: "inline-block",
          margin: "0 -0.7px -.7em",
          borderLeft: "1.4px dotted #888"
        },
        ".cm-completionMatchedText": {
          textDecoration: "underline"
        },
        ".cm-completionDetail": {
          marginLeft: "0.5em",
          fontStyle: "italic"
        },
        ".cm-completionIcon": {
          fontSize: "90%",
          width: ".8em",
          display: "inline-block",
          textAlign: "center",
          paddingRight: ".6em",
          opacity: "0.6",
          boxSizing: "content-box"
        },
        ".cm-completionIcon-function, .cm-completionIcon-method": {
          "&:after": {
            content: "'\u0192'"
          }
        },
        ".cm-completionIcon-class": {
          "&:after": {
            content: "'\u25CB'"
          }
        },
        ".cm-completionIcon-interface": {
          "&:after": {
            content: "'\u25CC'"
          }
        },
        ".cm-completionIcon-variable": {
          "&:after": {
            content: "'\u{1D465}'"
          }
        },
        ".cm-completionIcon-constant": {
          "&:after": {
            content: "'\u{1D436}'"
          }
        },
        ".cm-completionIcon-type": {
          "&:after": {
            content: "'\u{1D461}'"
          }
        },
        ".cm-completionIcon-enum": {
          "&:after": {
            content: "'\u222A'"
          }
        },
        ".cm-completionIcon-property": {
          "&:after": {
            content: "'\u25A1'"
          }
        },
        ".cm-completionIcon-keyword": {
          "&:after": {
            content: "'\u{1F511}\uFE0E'"
          }
        },
        ".cm-completionIcon-namespace": {
          "&:after": {
            content: "'\u25A2'"
          }
        },
        ".cm-completionIcon-text": {
          "&:after": {
            content: "'abc'",
            fontSize: "50%",
            verticalAlign: "middle"
          }
        }
      }), Vu = {
        brackets: [
          "(",
          "[",
          "{",
          "'",
          '"'
        ],
        before: ")]}:;>",
        stringPrefixes: []
      }, Es = Pe.define({
        map(t, e) {
          let n = e.mapPos(t, -1, Zt.TrackAfter);
          return n ?? void 0;
        }
      }), oS = new class extends Hs {
      }();
      oS.startSide = 1;
      oS.endSide = -1;
      const $L = Ut.define({
        create() {
          return Ve.empty;
        },
        update(t, e) {
          if (t = t.map(e.changes), e.selection) {
            let n = e.state.doc.lineAt(e.selection.main.head);
            t = t.update({
              filter: (r) => r >= n.from && r <= n.to
            });
          }
          for (let n of e.effects)
            n.is(Es) && (t = t.update({
              add: [
                oS.range(n.value, n.value + 1)
              ]
            }));
          return t;
        }
      });
      function KY() {
        return [
          GY,
          $L
        ];
      }
      const ev = "()[]{}<>\xAB\xBB\xBB\xAB\uFF3B\uFF3D\uFF5B\uFF5D";
      function zL(t) {
        for (let e = 0; e < ev.length; e += 2)
          if (ev.charCodeAt(e) == t)
            return ev.charAt(e + 1);
        return Sx(t < 128 ? t : t + 1);
      }
      function FL(t, e) {
        return t.languageDataAt("closeBrackets", e)[0] || Vu;
      }
      const qY = typeof navigator == "object" && /Android\b/.test(navigator.userAgent), GY = ce.inputHandler.of((t, e, n, r) => {
        if ((qY ? t.composing : t.compositionStarted) || t.state.readOnly)
          return false;
        let i = t.state.selection.main;
        if (r.length > 2 || r.length == 2 && di(Rn(r, 0)) == 1 || e != i.from || n != i.to)
          return false;
        let o = QY(t.state, r);
        return o ? (t.dispatch(o), true) : false;
      }), YY = ({ state: t, dispatch: e }) => {
        if (t.readOnly)
          return false;
        let r = FL(t, t.selection.main.head).brackets || Vu.brackets, i = null, o = t.changeByRange((s) => {
          if (s.empty) {
            let a = JY(t.doc, s.head);
            for (let l of r)
              if (l == a && Xm(t.doc, s.head) == zL(Rn(l, 0)))
                return {
                  changes: {
                    from: s.head - l.length,
                    to: s.head + l.length
                  },
                  range: q.cursor(s.head - l.length)
                };
          }
          return {
            range: i = s
          };
        });
        return i || e(t.update(o, {
          scrollIntoView: true,
          userEvent: "delete.backward"
        })), !i;
      }, XY = [
        {
          key: "Backspace",
          run: YY
        }
      ];
      function QY(t, e) {
        let n = FL(t, t.selection.main.head), r = n.brackets || Vu.brackets;
        for (let i of r) {
          let o = zL(Rn(i, 0));
          if (e == i)
            return o == i ? tX(t, i, r.indexOf(i + i + i) > -1, n) : ZY(t, i, o, n.before || Vu.before);
          if (e == o && VL(t, t.selection.main.from))
            return eX(t, i, o);
        }
        return null;
      }
      function VL(t, e) {
        let n = false;
        return t.field($L).between(0, t.doc.length, (r) => {
          r == e && (n = true);
        }), n;
      }
      function Xm(t, e) {
        let n = t.sliceString(e, e + 2);
        return n.slice(0, di(Rn(n, 0)));
      }
      function JY(t, e) {
        let n = t.sliceString(e - 2, e);
        return di(Rn(n, 0)) == n.length ? n : n.slice(1);
      }
      function ZY(t, e, n, r) {
        let i = null, o = t.changeByRange((s) => {
          if (!s.empty)
            return {
              changes: [
                {
                  insert: e,
                  from: s.from
                },
                {
                  insert: n,
                  from: s.to
                }
              ],
              effects: Es.of(s.to + e.length),
              range: q.range(s.anchor + e.length, s.head + e.length)
            };
          let a = Xm(t.doc, s.head);
          return !a || /\s/.test(a) || r.indexOf(a) > -1 ? {
            changes: {
              insert: e + n,
              from: s.head
            },
            effects: Es.of(s.head + e.length),
            range: q.cursor(s.head + e.length)
          } : {
            range: i = s
          };
        });
        return i ? null : t.update(o, {
          scrollIntoView: true,
          userEvent: "input.type"
        });
      }
      function eX(t, e, n) {
        let r = null, i = t.changeByRange((o) => o.empty && Xm(t.doc, o.head) == n ? {
          changes: {
            from: o.head,
            to: o.head + n.length,
            insert: n
          },
          range: q.cursor(o.head + n.length)
        } : r = {
          range: o
        });
        return r ? null : t.update(i, {
          scrollIntoView: true,
          userEvent: "input.type"
        });
      }
      function tX(t, e, n, r) {
        let i = r.stringPrefixes || Vu.stringPrefixes, o = null, s = t.changeByRange((a) => {
          if (!a.empty)
            return {
              changes: [
                {
                  insert: e,
                  from: a.from
                },
                {
                  insert: e,
                  from: a.to
                }
              ],
              effects: Es.of(a.to + e.length),
              range: q.range(a.anchor + e.length, a.head + e.length)
            };
          let l = a.head, c = Xm(t.doc, l), u;
          if (c == e) {
            if (HT(t, l))
              return {
                changes: {
                  insert: e + e,
                  from: l
                },
                effects: Es.of(l + e.length),
                range: q.cursor(l + e.length)
              };
            if (VL(t, l)) {
              let p = n && t.sliceDoc(l, l + e.length * 3) == e + e + e ? e + e + e : e;
              return {
                changes: {
                  from: l,
                  to: l + p.length,
                  insert: p
                },
                range: q.cursor(l + p.length)
              };
            }
          } else {
            if (n && t.sliceDoc(l - 2 * e.length, l) == e + e && (u = jT(t, l - 2 * e.length, i)) > -1 && HT(t, u))
              return {
                changes: {
                  insert: e + e + e + e,
                  from: l
                },
                effects: Es.of(l + e.length),
                range: q.cursor(l + e.length)
              };
            if (t.charCategorizer(l)(c) != ht.Word && jT(t, l, i) > -1 && !nX(t, l, e, i))
              return {
                changes: {
                  insert: e + e,
                  from: l
                },
                effects: Es.of(l + e.length),
                range: q.cursor(l + e.length)
              };
          }
          return {
            range: o = a
          };
        });
        return o ? null : t.update(s, {
          scrollIntoView: true,
          userEvent: "input.type"
        });
      }
      function HT(t, e) {
        let n = mn(t).resolveInner(e + 1);
        return n.parent && n.from == e;
      }
      function nX(t, e, n, r) {
        let i = mn(t).resolveInner(e, -1), o = r.reduce((s, a) => Math.max(s, a.length), 0);
        for (let s = 0; s < 5; s++) {
          let a = t.sliceDoc(i.from, Math.min(i.to, i.from + n.length + o)), l = a.indexOf(n);
          if (!l || l > -1 && r.indexOf(a.slice(0, l)) > -1) {
            let u = i.firstChild;
            for (; u && u.from == i.from && u.to - u.from > n.length + l; ) {
              if (t.sliceDoc(u.to - n.length, u.to) == n)
                return false;
              u = u.firstChild;
            }
            return true;
          }
          let c = i.to == e && i.parent;
          if (!c)
            break;
          i = c;
        }
        return false;
      }
      function jT(t, e, n) {
        let r = t.charCategorizer(e);
        if (r(t.sliceDoc(e - 1, e)) != ht.Word)
          return e;
        for (let i of n) {
          let o = e - i.length;
          if (t.sliceDoc(o, e) == i && r(t.sliceDoc(o - 1, o)) != ht.Word)
            return o;
        }
        return -1;
      }
      function rX(t = {}) {
        return [
          WY,
          Dn,
          Ht.of(t),
          HY,
          iX,
          UY
        ];
      }
      const HL = [
        {
          key: "Ctrl-Space",
          run: VT
        },
        {
          mac: "Alt-`",
          run: VT
        },
        {
          key: "Escape",
          run: $Y
        },
        {
          key: "ArrowDown",
          run: $h(true)
        },
        {
          key: "ArrowUp",
          run: $h(false)
        },
        {
          key: "PageDown",
          run: $h(true, "page")
        },
        {
          key: "PageUp",
          run: $h(false, "page")
        },
        {
          key: "Enter",
          run: NY
        }
      ], iX = ns.highest(Hm.computeN([
        Ht
      ], (t) => t.facet(Ht).defaultKeymap ? [
        HL
      ] : []));
      class WT {
        constructor(e, n, r) {
          this.from = e, this.to = n, this.diagnostic = r;
        }
      }
      class Ss {
        constructor(e, n, r) {
          this.diagnostics = e, this.panel = n, this.selected = r;
        }
        static init(e, n, r) {
          let i = r.facet(Hu).markerFilter;
          i && (e = i(e, r));
          let o = e.slice().sort((u, h) => u.from - h.from || u.to - h.to), s = new Ci(), a = [], l = 0;
          for (let u = 0; ; ) {
            let h = u == o.length ? null : o[u];
            if (!h && !a.length)
              break;
            let p, v;
            for (a.length ? (p = l, v = a.reduce((S, C) => Math.min(S, C.to), h && h.from > p ? h.from : 1e8)) : (p = h.from, v = h.to, a.push(h), u++); u < o.length; ) {
              let S = o[u];
              if (S.from == p && (S.to > S.from || S.to == p))
                a.push(S), u++, v = Math.min(S.to, v);
              else {
                v = Math.min(S.from, v);
                break;
              }
            }
            let y = vX(a);
            if (a.some((S) => S.from == S.to || S.from == S.to - 1 && r.doc.lineAt(S.from).to == S.from))
              s.add(p, p, be.widget({
                widget: new dX(y),
                diagnostics: a.slice()
              }));
            else {
              let S = a.reduce((C, w) => w.markClass ? C + " " + w.markClass : C, "");
              s.add(p, v, be.mark({
                class: "cm-lintRange cm-lintRange-" + y + S,
                diagnostics: a.slice(),
                inclusiveEnd: a.some((C) => C.to > v)
              }));
            }
            l = v;
            for (let S = 0; S < a.length; S++)
              a[S].to <= l && a.splice(S--, 1);
          }
          let c = s.finish();
          return new Ss(c, n, xl(c));
        }
      }
      function xl(t, e = null, n = 0) {
        let r = null;
        return t.between(n, 1e9, (i, o, { spec: s }) => {
          if (!(e && s.diagnostics.indexOf(e) < 0))
            if (!r)
              r = new WT(i, o, e || s.diagnostics[0]);
            else {
              if (s.diagnostics.indexOf(r.diagnostic) < 0)
                return false;
              r = new WT(r.from, o, r.diagnostic);
            }
        }), r;
      }
      function oX(t, e) {
        let n = e.pos, r = e.end || n, i = t.state.facet(Hu).hideOn(t, n, r);
        if (i != null)
          return i;
        let o = t.startState.doc.lineAt(e.pos);
        return !!(t.effects.some((s) => s.is(jL)) || t.changes.touchesRange(o.from, Math.max(o.to, r)));
      }
      function sX(t, e) {
        return t.field(qn, false) ? e : e.concat(Pe.appendConfig.of(yX));
      }
      const jL = Pe.define(), sS = Pe.define(), WL = Pe.define(), qn = Ut.define({
        create() {
          return new Ss(be.none, null, null);
        },
        update(t, e) {
          if (e.docChanged && t.diagnostics.size) {
            let n = t.diagnostics.map(e.changes), r = null, i = t.panel;
            if (t.selected) {
              let o = e.changes.mapPos(t.selected.from, 1);
              r = xl(n, t.selected.diagnostic, o) || xl(n, null, o);
            }
            !n.size && i && e.state.facet(Hu).autoPanel && (i = null), t = new Ss(n, i, r);
          }
          for (let n of e.effects)
            if (n.is(jL)) {
              let r = e.state.facet(Hu).autoPanel ? n.value.length ? ju.open : null : t.panel;
              t = Ss.init(n.value, r, e.state);
            } else
              n.is(sS) ? t = new Ss(t.diagnostics, n.value ? ju.open : null, t.selected) : n.is(WL) && (t = new Ss(t.diagnostics, t.panel, n.value));
          return t;
        },
        provide: (t) => [
          Ks.from(t, (e) => e.panel),
          ce.decorations.from(t, (e) => e.diagnostics)
        ]
      }), aX = be.mark({
        class: "cm-lintRange cm-lintRange-active"
      });
      function lX(t, e, n) {
        let { diagnostics: r } = t.state.field(qn), i, o = -1, s = -1;
        r.between(e - (n < 0 ? 1 : 0), e + (n > 0 ? 1 : 0), (l, c, { spec: u }) => {
          if (e >= l && e <= c && (l == c || (e > l || n > 0) && (e < c || n < 0)))
            return i = u.diagnostics, o = l, s = c, false;
        });
        let a = t.state.facet(Hu).tooltipFilter;
        return i && a && (i = a(i, t.state)), i ? {
          pos: o,
          end: s,
          above: t.state.doc.lineAt(o).to < s,
          create() {
            return {
              dom: cX(t, i)
            };
          }
        } : null;
      }
      function cX(t, e) {
        return Qe("ul", {
          class: "cm-tooltip-lint"
        }, e.map((n) => KL(t, n, false)));
      }
      const uX = (t) => {
        let e = t.state.field(qn, false);
        (!e || !e.panel) && t.dispatch({
          effects: sX(t.state, [
            sS.of(true)
          ])
        });
        let n = Nu(t, ju.open);
        return n && n.dom.querySelector(".cm-panel-lint ul").focus(), true;
      }, UT = (t) => {
        let e = t.state.field(qn, false);
        return !e || !e.panel ? false : (t.dispatch({
          effects: sS.of(false)
        }), true);
      }, fX = (t) => {
        let e = t.state.field(qn, false);
        if (!e)
          return false;
        let n = t.state.selection.main, r = e.diagnostics.iter(n.to + 1);
        return !r.value && (r = e.diagnostics.iter(0), !r.value || r.from == n.from && r.to == n.to) ? false : (t.dispatch({
          selection: {
            anchor: r.from,
            head: r.to
          },
          scrollIntoView: true
        }), true);
      }, hX = [
        {
          key: "Mod-Shift-m",
          run: uX,
          preventDefault: true
        },
        {
          key: "F8",
          run: fX
        }
      ], Hu = pe.define({
        combine(t) {
          return Object.assign({
            sources: t.map((e) => e.source).filter((e) => e != null)
          }, Ei(t.map((e) => e.config), {
            delay: 750,
            markerFilter: null,
            tooltipFilter: null,
            needsRefresh: null,
            hideOn: () => null
          }, {
            needsRefresh: (e, n) => e ? n ? (r) => e(r) || n(r) : e : n
          }));
        }
      });
      function UL(t) {
        let e = [];
        if (t)
          e:
            for (let { name: n } of t) {
              for (let r = 0; r < n.length; r++) {
                let i = n[r];
                if (/[a-zA-Z]/.test(i) && !e.some((o) => o.toLowerCase() == i.toLowerCase())) {
                  e.push(i);
                  continue e;
                }
              }
              e.push("");
            }
        return e;
      }
      function KL(t, e, n) {
        var r;
        let i = n ? UL(e.actions) : [];
        return Qe("li", {
          class: "cm-diagnostic cm-diagnostic-" + e.severity
        }, Qe("span", {
          class: "cm-diagnosticText"
        }, e.renderMessage ? e.renderMessage(t) : e.message), (r = e.actions) === null || r === void 0 ? void 0 : r.map((o, s) => {
          let a = false, l = (p) => {
            if (p.preventDefault(), a)
              return;
            a = true;
            let v = xl(t.state.field(qn).diagnostics, e);
            v && o.apply(t, v.from, v.to);
          }, { name: c } = o, u = i[s] ? c.indexOf(i[s]) : -1, h = u < 0 ? c : [
            c.slice(0, u),
            Qe("u", c.slice(u, u + 1)),
            c.slice(u + 1)
          ];
          return Qe("button", {
            type: "button",
            class: "cm-diagnosticAction",
            onclick: l,
            onmousedown: l,
            "aria-label": ` Action: ${c}${u < 0 ? "" : ` (access key "${i[s]})"`}.`
          }, h);
        }), e.source && Qe("div", {
          class: "cm-diagnosticSource"
        }, e.source));
      }
      class dX extends oo {
        constructor(e) {
          super(), this.sev = e;
        }
        eq(e) {
          return e.sev == this.sev;
        }
        toDOM() {
          return Qe("span", {
            class: "cm-lintPoint cm-lintPoint-" + this.sev
          });
        }
      }
      class KT {
        constructor(e, n) {
          this.diagnostic = n, this.id = "item_" + Math.floor(Math.random() * 4294967295).toString(16), this.dom = KL(e, n, true), this.dom.id = this.id, this.dom.setAttribute("role", "option");
        }
      }
      class ju {
        constructor(e) {
          this.view = e, this.items = [];
          let n = (i) => {
            if (i.keyCode == 27)
              UT(this.view), this.view.focus();
            else if (i.keyCode == 38 || i.keyCode == 33)
              this.moveSelection((this.selectedIndex - 1 + this.items.length) % this.items.length);
            else if (i.keyCode == 40 || i.keyCode == 34)
              this.moveSelection((this.selectedIndex + 1) % this.items.length);
            else if (i.keyCode == 36)
              this.moveSelection(0);
            else if (i.keyCode == 35)
              this.moveSelection(this.items.length - 1);
            else if (i.keyCode == 13)
              this.view.focus();
            else if (i.keyCode >= 65 && i.keyCode <= 90 && this.selectedIndex >= 0) {
              let { diagnostic: o } = this.items[this.selectedIndex], s = UL(o.actions);
              for (let a = 0; a < s.length; a++)
                if (s[a].toUpperCase().charCodeAt(0) == i.keyCode) {
                  let l = xl(this.view.state.field(qn).diagnostics, o);
                  l && o.actions[a].apply(e, l.from, l.to);
                }
            } else
              return;
            i.preventDefault();
          }, r = (i) => {
            for (let o = 0; o < this.items.length; o++)
              this.items[o].dom.contains(i.target) && this.moveSelection(o);
          };
          this.list = Qe("ul", {
            tabIndex: 0,
            role: "listbox",
            "aria-label": this.view.state.phrase("Diagnostics"),
            onkeydown: n,
            onclick: r
          }), this.dom = Qe("div", {
            class: "cm-panel-lint"
          }, this.list, Qe("button", {
            type: "button",
            name: "close",
            "aria-label": this.view.state.phrase("close"),
            onclick: () => UT(this.view)
          }, "\xD7")), this.update();
        }
        get selectedIndex() {
          let e = this.view.state.field(qn).selected;
          if (!e)
            return -1;
          for (let n = 0; n < this.items.length; n++)
            if (this.items[n].diagnostic == e.diagnostic)
              return n;
          return -1;
        }
        update() {
          let { diagnostics: e, selected: n } = this.view.state.field(qn), r = 0, i = false, o = null, s = /* @__PURE__ */ new Set();
          for (e.between(0, this.view.state.doc.length, (a, l, { spec: c }) => {
            for (let u of c.diagnostics) {
              if (s.has(u))
                continue;
              s.add(u);
              let h = -1, p;
              for (let v = r; v < this.items.length; v++)
                if (this.items[v].diagnostic == u) {
                  h = v;
                  break;
                }
              h < 0 ? (p = new KT(this.view, u), this.items.splice(r, 0, p), i = true) : (p = this.items[h], h > r && (this.items.splice(r, h - r), i = true)), n && p.diagnostic == n.diagnostic ? p.dom.hasAttribute("aria-selected") || (p.dom.setAttribute("aria-selected", "true"), o = p) : p.dom.hasAttribute("aria-selected") && p.dom.removeAttribute("aria-selected"), r++;
            }
          }); r < this.items.length && !(this.items.length == 1 && this.items[0].diagnostic.from < 0); )
            i = true, this.items.pop();
          this.items.length == 0 && (this.items.push(new KT(this.view, {
            from: -1,
            to: -1,
            severity: "info",
            message: this.view.state.phrase("No diagnostics")
          })), i = true), o ? (this.list.setAttribute("aria-activedescendant", o.id), this.view.requestMeasure({
            key: this,
            read: () => ({
              sel: o.dom.getBoundingClientRect(),
              panel: this.list.getBoundingClientRect()
            }),
            write: ({ sel: a, panel: l }) => {
              let c = l.height / this.list.offsetHeight;
              a.top < l.top ? this.list.scrollTop -= (l.top - a.top) / c : a.bottom > l.bottom && (this.list.scrollTop += (a.bottom - l.bottom) / c);
            }
          })) : this.selectedIndex < 0 && this.list.removeAttribute("aria-activedescendant"), i && this.sync();
        }
        sync() {
          let e = this.list.firstChild;
          function n() {
            let r = e;
            e = r.nextSibling, r.remove();
          }
          for (let r of this.items)
            if (r.dom.parentNode == this.list) {
              for (; e != r.dom; )
                n();
              e = r.dom.nextSibling;
            } else
              this.list.insertBefore(r.dom, e);
          for (; e; )
            n();
        }
        moveSelection(e) {
          if (this.selectedIndex < 0)
            return;
          let n = this.view.state.field(qn), r = xl(n.diagnostics, this.items[e].diagnostic);
          !r || this.view.dispatch({
            selection: {
              anchor: r.from,
              head: r.to
            },
            scrollIntoView: true,
            effects: WL.of(r)
          });
        }
        static open(e) {
          return new ju(e);
        }
      }
      function pX(t, e = 'viewBox="0 0 40 40"') {
        return `url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" ${e}>${encodeURIComponent(t)}</svg>')`;
      }
      function zh(t) {
        return pX(`<path d="m0 2.5 l2 -1.5 l1 0 l2 1.5 l1 0" stroke="${t}" fill="none" stroke-width=".7"/>`, 'width="6" height="3"');
      }
      const mX = ce.baseTheme({
        ".cm-diagnostic": {
          padding: "3px 6px 3px 8px",
          marginLeft: "-1px",
          display: "block",
          whiteSpace: "pre-wrap"
        },
        ".cm-diagnostic-error": {
          borderLeft: "5px solid #d11"
        },
        ".cm-diagnostic-warning": {
          borderLeft: "5px solid orange"
        },
        ".cm-diagnostic-info": {
          borderLeft: "5px solid #999"
        },
        ".cm-diagnostic-hint": {
          borderLeft: "5px solid #66d"
        },
        ".cm-diagnosticAction": {
          font: "inherit",
          border: "none",
          padding: "2px 4px",
          backgroundColor: "#444",
          color: "white",
          borderRadius: "3px",
          marginLeft: "8px",
          cursor: "pointer"
        },
        ".cm-diagnosticSource": {
          fontSize: "70%",
          opacity: 0.7
        },
        ".cm-lintRange": {
          backgroundPosition: "left bottom",
          backgroundRepeat: "repeat-x",
          paddingBottom: "0.7px"
        },
        ".cm-lintRange-error": {
          backgroundImage: zh("#d11")
        },
        ".cm-lintRange-warning": {
          backgroundImage: zh("orange")
        },
        ".cm-lintRange-info": {
          backgroundImage: zh("#999")
        },
        ".cm-lintRange-hint": {
          backgroundImage: zh("#66d")
        },
        ".cm-lintRange-active": {
          backgroundColor: "#ffdd9980"
        },
        ".cm-tooltip-lint": {
          padding: 0,
          margin: 0
        },
        ".cm-lintPoint": {
          position: "relative",
          "&:after": {
            content: '""',
            position: "absolute",
            bottom: 0,
            left: "-2px",
            borderLeft: "3px solid transparent",
            borderRight: "3px solid transparent",
            borderBottom: "4px solid #d11"
          }
        },
        ".cm-lintPoint-warning": {
          "&:after": {
            borderBottomColor: "orange"
          }
        },
        ".cm-lintPoint-info": {
          "&:after": {
            borderBottomColor: "#999"
          }
        },
        ".cm-lintPoint-hint": {
          "&:after": {
            borderBottomColor: "#66d"
          }
        },
        ".cm-panel.cm-panel-lint": {
          position: "relative",
          "& ul": {
            maxHeight: "100px",
            overflowY: "auto",
            "& [aria-selected]": {
              backgroundColor: "#ddd",
              "& u": {
                textDecoration: "underline"
              }
            },
            "&:focus [aria-selected]": {
              background_fallback: "#bdf",
              backgroundColor: "Highlight",
              color_fallback: "white",
              color: "HighlightText"
            },
            "& u": {
              textDecoration: "none"
            },
            padding: 0,
            margin: 0
          },
          "& [name=close]": {
            position: "absolute",
            top: "0",
            right: "2px",
            background: "inherit",
            border: "none",
            font: "inherit",
            padding: 0,
            margin: 0
          }
        }
      });
      function gX(t) {
        return t == "error" ? 4 : t == "warning" ? 3 : t == "info" ? 2 : 1;
      }
      function vX(t) {
        let e = "hint", n = 1;
        for (let r of t) {
          let i = gX(r.severity);
          i > n && (n = i, e = r.severity);
        }
        return e;
      }
      const yX = [
        qn,
        ce.decorations.compute([
          qn
        ], (t) => {
          let { selected: e, panel: n } = t.field(qn);
          return !e || !n || e.from == e.to ? be.none : be.set([
            aX.range(e.from, e.to)
          ]);
        }),
        dK(lX, {
          hideOn: oX
        }),
        mX
      ];
      var qT = function(e) {
        e === void 0 && (e = {});
        var { crosshairCursor: n = false } = e, r = [];
        e.closeBracketsKeymap !== false && (r = r.concat(XY)), e.defaultKeymap !== false && (r = r.concat(WG)), e.searchKeymap !== false && (r = r.concat(mY)), e.historyKeymap !== false && (r = r.concat(tG)), e.foldKeymap !== false && (r = r.concat(pq)), e.completionKeymap !== false && (r = r.concat(HL)), e.lintKeymap !== false && (r = r.concat(hX));
        var i = [];
        return e.lineNumbers !== false && i.push(CK()), e.highlightActiveLineGutter !== false && i.push(AK()), e.highlightSpecialChars !== false && i.push(HU()), e.history !== false && i.push(Kq()), e.foldGutter !== false && i.push(yq()), e.drawSelection !== false && i.push(OU()), e.dropCursor !== false && i.push(BU()), e.allowMultipleSelections !== false && i.push(Ne.allowMultipleSelections.of(true)), e.indentOnInput !== false && i.push(oq()), e.syntaxHighlighting !== false && i.push(WR(wq, {
          fallback: true
        })), e.bracketMatching !== false && i.push(Pq()), e.closeBrackets !== false && i.push(KY()), e.autocompletion !== false && i.push(rX()), e.rectangularSelection !== false && i.push(nK()), n !== false && i.push(oK()), e.highlightActiveLine !== false && i.push(GU()), e.highlightSelectionMatches !== false && i.push(XG()), e.tabSize && typeof e.tabSize == "number" && i.push(yl.of(" ".repeat(e.tabSize))), i.concat([
          Hm.of(r.flat())
        ]).filter(Boolean);
      };
      const bX = "#e5c07b", GT = "#e06c75", xX = "#56b6c2", SX = "#ffffff", Ad = "#abb2bf", M1 = "#7d8799", wX = "#61afef", kX = "#98c379", YT = "#d19a66", CX = "#c678dd", TX = "#21252b", XT = "#2c313a", QT = "#282c34", tv = "#353a42", MX = "#3E4451", JT = "#528bff", AX = ce.theme({
        "&": {
          color: Ad,
          backgroundColor: QT
        },
        ".cm-content": {
          caretColor: JT
        },
        ".cm-cursor, .cm-dropCursor": {
          borderLeftColor: JT
        },
        "&.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground, .cm-selectionBackground, .cm-content ::selection": {
          backgroundColor: MX
        },
        ".cm-panels": {
          backgroundColor: TX,
          color: Ad
        },
        ".cm-panels.cm-panels-top": {
          borderBottom: "2px solid black"
        },
        ".cm-panels.cm-panels-bottom": {
          borderTop: "2px solid black"
        },
        ".cm-searchMatch": {
          backgroundColor: "#72a1ff59",
          outline: "1px solid #457dff"
        },
        ".cm-searchMatch.cm-searchMatch-selected": {
          backgroundColor: "#6199ff2f"
        },
        ".cm-activeLine": {
          backgroundColor: "#6699ff0b"
        },
        ".cm-selectionMatch": {
          backgroundColor: "#aafe661a"
        },
        "&.cm-focused .cm-matchingBracket, &.cm-focused .cm-nonmatchingBracket": {
          backgroundColor: "#bad0f847"
        },
        ".cm-gutters": {
          backgroundColor: QT,
          color: M1,
          border: "none"
        },
        ".cm-activeLineGutter": {
          backgroundColor: XT
        },
        ".cm-foldPlaceholder": {
          backgroundColor: "transparent",
          border: "none",
          color: "#ddd"
        },
        ".cm-tooltip": {
          border: "none",
          backgroundColor: tv
        },
        ".cm-tooltip .cm-tooltip-arrow:before": {
          borderTopColor: "transparent",
          borderBottomColor: "transparent"
        },
        ".cm-tooltip .cm-tooltip-arrow:after": {
          borderTopColor: tv,
          borderBottomColor: tv
        },
        ".cm-tooltip-autocomplete": {
          "& > ul > li[aria-selected]": {
            backgroundColor: XT,
            color: Ad
          }
        }
      }, {
        dark: true
      }), EX = cf.define([
        {
          tag: G.keyword,
          color: CX
        },
        {
          tag: [
            G.name,
            G.deleted,
            G.character,
            G.propertyName,
            G.macroName
          ],
          color: GT
        },
        {
          tag: [
            G.function(G.variableName),
            G.labelName
          ],
          color: wX
        },
        {
          tag: [
            G.color,
            G.constant(G.name),
            G.standard(G.name)
          ],
          color: YT
        },
        {
          tag: [
            G.definition(G.name),
            G.separator
          ],
          color: Ad
        },
        {
          tag: [
            G.typeName,
            G.className,
            G.number,
            G.changed,
            G.annotation,
            G.modifier,
            G.self,
            G.namespace
          ],
          color: bX
        },
        {
          tag: [
            G.operator,
            G.operatorKeyword,
            G.url,
            G.escape,
            G.regexp,
            G.link,
            G.special(G.string)
          ],
          color: xX
        },
        {
          tag: [
            G.meta,
            G.comment
          ],
          color: M1
        },
        {
          tag: G.strong,
          fontWeight: "bold"
        },
        {
          tag: G.emphasis,
          fontStyle: "italic"
        },
        {
          tag: G.strikethrough,
          textDecoration: "line-through"
        },
        {
          tag: G.link,
          color: M1,
          textDecoration: "underline"
        },
        {
          tag: G.heading,
          fontWeight: "bold",
          color: GT
        },
        {
          tag: [
            G.atom,
            G.bool,
            G.special(G.variableName)
          ],
          color: YT
        },
        {
          tag: [
            G.processingInstruction,
            G.string,
            G.inserted
          ],
          color: kX
        },
        {
          tag: G.invalid,
          color: SX
        }
      ]), PX = [
        AX,
        WR(EX)
      ];
      var OX = ce.theme({
        "&": {
          backgroundColor: "#fff"
        }
      }, {
        dark: false
      }), RX = function(e) {
        e === void 0 && (e = {});
        var { indentWithTab: n = true, editable: r = true, readOnly: i = false, theme: o = "light", placeholder: s = "", basicSetup: a = true } = e, l = [];
        switch (n && l.unshift(Hm.of([
          UG
        ])), a && (typeof a == "boolean" ? l.unshift(qT()) : l.unshift(qT(a))), s && l.unshift(JU(s)), o) {
          case "light":
            l.push(OX);
            break;
          case "dark":
            l.push(PX);
            break;
          case "none":
            break;
          default:
            l.push(o);
            break;
        }
        return r === false && l.push(ce.editable.of(false)), i && l.push(Ne.readOnly.of(true)), [
          ...l
        ];
      }, LX = (t) => ({
        line: t.state.doc.lineAt(t.state.selection.main.from),
        lineCount: t.state.doc.lines,
        lineBreak: t.state.lineBreak,
        length: t.state.doc.length,
        readOnly: t.state.readOnly,
        tabSize: t.state.tabSize,
        selection: t.state.selection,
        selectionAsSingle: t.state.selection.asSingle().main,
        ranges: t.state.selection.ranges,
        selectionCode: t.state.sliceDoc(t.state.selection.main.from, t.state.selection.main.to),
        selections: t.state.selection.ranges.map((e) => t.state.sliceDoc(e.from, e.to)),
        selectedText: t.state.selection.ranges.some((e) => !e.empty)
      }), ZT = Ai.define(), DX = [];
      function _X(t) {
        var { value: e, selection: n, onChange: r, onStatistics: i, onCreateEditor: o, onUpdate: s, extensions: a = DX, autoFocus: l, theme: c = "light", height: u = null, minHeight: h = null, maxHeight: p = null, width: v = null, minWidth: y = null, maxWidth: S = null, placeholder: C = "", editable: w = true, readOnly: k = false, indentWithTab: T = true, basicSetup: P = true, root: R, initialState: L } = t, [D, F] = z.exports.useState(), [K, Y] = z.exports.useState(), [te, ne] = z.exports.useState(), ue = ce.theme({
          "&": {
            height: u,
            minHeight: h,
            maxHeight: p,
            width: v,
            minWidth: y,
            maxWidth: S
          },
          "& .cm-scroller": {
            height: "100% !important"
          }
        }), ye = ce.updateListener.of((Q) => {
          if (Q.docChanged && typeof r == "function" && !Q.transactions.some((ge) => ge.annotation(ZT))) {
            var V = Q.state.doc, ae = V.toString();
            r(ae, Q);
          }
          i && i(LX(Q));
        }), ke = RX({
          theme: c,
          editable: w,
          readOnly: k,
          placeholder: C,
          indentWithTab: T,
          basicSetup: P
        }), Ee = [
          ye,
          ue,
          ...ke
        ];
        return s && typeof s == "function" && Ee.push(ce.updateListener.of(s)), Ee = Ee.concat(a), z.exports.useLayoutEffect(() => {
          if (D && !te) {
            var Q = {
              doc: e,
              selection: n,
              extensions: Ee
            }, V = L ? Ne.fromJSON(L.json, Q, L.fields) : Ne.create(Q);
            if (ne(V), !K) {
              var ae = new ce({
                state: V,
                parent: D,
                root: R
              });
              Y(ae), o && o(ae, V);
            }
          }
          return () => {
            K && (ne(void 0), Y(void 0));
          };
        }, [
          D,
          te
        ]), z.exports.useEffect(() => {
          t.container && F(t.container);
        }, [
          t.container
        ]), z.exports.useEffect(() => () => {
          K && (K.destroy(), Y(void 0));
        }, [
          K
        ]), z.exports.useEffect(() => {
          l && K && K.focus();
        }, [
          l,
          K
        ]), z.exports.useEffect(() => {
          K && K.dispatch({
            effects: Pe.reconfigure.of(Ee)
          });
        }, [
          c,
          a,
          u,
          h,
          p,
          v,
          y,
          S,
          C,
          w,
          k,
          T,
          P,
          r,
          s
        ]), z.exports.useEffect(() => {
          if (e !== void 0) {
            var Q = K ? K.state.doc.toString() : "";
            K && e !== Q && K.dispatch({
              changes: {
                from: 0,
                to: Q.length,
                insert: e || ""
              },
              annotations: [
                ZT.of(true)
              ]
            });
          }
        }, [
          e,
          K
        ]), {
          state: te,
          setState: ne,
          view: K,
          setView: Y,
          container: D,
          setContainer: F
        };
      }
      var IX = [
        "className",
        "value",
        "selection",
        "extensions",
        "onChange",
        "onStatistics",
        "onCreateEditor",
        "onUpdate",
        "autoFocus",
        "theme",
        "height",
        "minHeight",
        "maxHeight",
        "width",
        "minWidth",
        "maxWidth",
        "basicSetup",
        "placeholder",
        "indentWithTab",
        "editable",
        "readOnly",
        "root",
        "initialState"
      ], qL = z.exports.forwardRef((t, e) => {
        var { className: n, value: r = "", selection: i, extensions: o = [], onChange: s, onStatistics: a, onCreateEditor: l, onUpdate: c, autoFocus: u, theme: h = "light", height: p, minHeight: v, maxHeight: y, width: S, minWidth: C, maxWidth: w, basicSetup: k, placeholder: T, indentWithTab: P, editable: R, readOnly: L, root: D, initialState: F } = t, K = hW(t, IX), Y = z.exports.useRef(null), { state: te, view: ne, container: ue, setContainer: ye } = _X({
          root: D,
          value: r,
          autoFocus: u,
          theme: h,
          height: p,
          minHeight: v,
          maxHeight: y,
          width: S,
          minWidth: C,
          maxWidth: w,
          basicSetup: k,
          placeholder: T,
          indentWithTab: P,
          editable: R,
          readOnly: L,
          selection: i,
          onChange: s,
          onStatistics: a,
          onCreateEditor: l,
          onUpdate: c,
          extensions: o,
          initialState: F
        });
        z.exports.useImperativeHandle(e, () => ({
          editor: Y.current,
          state: te,
          view: ne
        }), [
          Y,
          ue,
          te,
          ne
        ]);
        var ke = z.exports.useCallback((Q) => {
          Y.current = Q, ye(Q);
        }, [
          ye
        ]);
        if (typeof r != "string")
          throw new Error("value must be typeof string but got " + typeof r);
        var Ee = typeof h == "string" ? "cm-theme-" + h : "cm-theme";
        return Z("div", ku({
          ref: ke,
          className: "" + Ee + (n ? " " + n : "")
        }, K));
      });
      qL.displayName = "CodeMirror";
      function BX(t) {
        var e = t.Pos;
        function n(f, d, m) {
          if (d.line === m.line && d.ch >= m.ch - 1) {
            var g = f.getLine(d.line), b = g.charCodeAt(d.ch);
            55296 <= b && b <= 55551 && (m.ch += 1);
          }
          return {
            start: d,
            end: m
          };
        }
        var r = [
          {
            keys: "<Left>",
            type: "keyToKey",
            toKeys: "h"
          },
          {
            keys: "<Right>",
            type: "keyToKey",
            toKeys: "l"
          },
          {
            keys: "<Up>",
            type: "keyToKey",
            toKeys: "k"
          },
          {
            keys: "<Down>",
            type: "keyToKey",
            toKeys: "j"
          },
          {
            keys: "g<Up>",
            type: "keyToKey",
            toKeys: "gk"
          },
          {
            keys: "g<Down>",
            type: "keyToKey",
            toKeys: "gj"
          },
          {
            keys: "<Space>",
            type: "keyToKey",
            toKeys: "l"
          },
          {
            keys: "<BS>",
            type: "keyToKey",
            toKeys: "h"
          },
          {
            keys: "<Del>",
            type: "keyToKey",
            toKeys: "x"
          },
          {
            keys: "<C-Space>",
            type: "keyToKey",
            toKeys: "W"
          },
          {
            keys: "<C-BS>",
            type: "keyToKey",
            toKeys: "B"
          },
          {
            keys: "<S-Space>",
            type: "keyToKey",
            toKeys: "w"
          },
          {
            keys: "<S-BS>",
            type: "keyToKey",
            toKeys: "b"
          },
          {
            keys: "<C-n>",
            type: "keyToKey",
            toKeys: "j"
          },
          {
            keys: "<C-p>",
            type: "keyToKey",
            toKeys: "k"
          },
          {
            keys: "<C-[>",
            type: "keyToKey",
            toKeys: "<Esc>"
          },
          {
            keys: "<C-c>",
            type: "keyToKey",
            toKeys: "<Esc>"
          },
          {
            keys: "<C-[>",
            type: "keyToKey",
            toKeys: "<Esc>",
            context: "insert"
          },
          {
            keys: "<C-c>",
            type: "keyToKey",
            toKeys: "<Esc>",
            context: "insert"
          },
          {
            keys: "<C-Esc>",
            type: "keyToKey",
            toKeys: "<Esc>"
          },
          {
            keys: "<C-Esc>",
            type: "keyToKey",
            toKeys: "<Esc>",
            context: "insert"
          },
          {
            keys: "s",
            type: "keyToKey",
            toKeys: "cl",
            context: "normal"
          },
          {
            keys: "s",
            type: "keyToKey",
            toKeys: "c",
            context: "visual"
          },
          {
            keys: "S",
            type: "keyToKey",
            toKeys: "cc",
            context: "normal"
          },
          {
            keys: "S",
            type: "keyToKey",
            toKeys: "VdO",
            context: "visual"
          },
          {
            keys: "<Home>",
            type: "keyToKey",
            toKeys: "0"
          },
          {
            keys: "<End>",
            type: "keyToKey",
            toKeys: "$"
          },
          {
            keys: "<PageUp>",
            type: "keyToKey",
            toKeys: "<C-b>"
          },
          {
            keys: "<PageDown>",
            type: "keyToKey",
            toKeys: "<C-f>"
          },
          {
            keys: "<CR>",
            type: "keyToKey",
            toKeys: "j^",
            context: "normal"
          },
          {
            keys: "<Ins>",
            type: "keyToKey",
            toKeys: "i",
            context: "normal"
          },
          {
            keys: "<Ins>",
            type: "action",
            action: "toggleOverwrite",
            context: "insert"
          },
          {
            keys: "H",
            type: "motion",
            motion: "moveToTopLine",
            motionArgs: {
              linewise: true,
              toJumplist: true
            }
          },
          {
            keys: "M",
            type: "motion",
            motion: "moveToMiddleLine",
            motionArgs: {
              linewise: true,
              toJumplist: true
            }
          },
          {
            keys: "L",
            type: "motion",
            motion: "moveToBottomLine",
            motionArgs: {
              linewise: true,
              toJumplist: true
            }
          },
          {
            keys: "h",
            type: "motion",
            motion: "moveByCharacters",
            motionArgs: {
              forward: false
            }
          },
          {
            keys: "l",
            type: "motion",
            motion: "moveByCharacters",
            motionArgs: {
              forward: true
            }
          },
          {
            keys: "j",
            type: "motion",
            motion: "moveByLines",
            motionArgs: {
              forward: true,
              linewise: true
            }
          },
          {
            keys: "k",
            type: "motion",
            motion: "moveByLines",
            motionArgs: {
              forward: false,
              linewise: true
            }
          },
          {
            keys: "gj",
            type: "motion",
            motion: "moveByDisplayLines",
            motionArgs: {
              forward: true
            }
          },
          {
            keys: "gk",
            type: "motion",
            motion: "moveByDisplayLines",
            motionArgs: {
              forward: false
            }
          },
          {
            keys: "w",
            type: "motion",
            motion: "moveByWords",
            motionArgs: {
              forward: true,
              wordEnd: false
            }
          },
          {
            keys: "W",
            type: "motion",
            motion: "moveByWords",
            motionArgs: {
              forward: true,
              wordEnd: false,
              bigWord: true
            }
          },
          {
            keys: "e",
            type: "motion",
            motion: "moveByWords",
            motionArgs: {
              forward: true,
              wordEnd: true,
              inclusive: true
            }
          },
          {
            keys: "E",
            type: "motion",
            motion: "moveByWords",
            motionArgs: {
              forward: true,
              wordEnd: true,
              bigWord: true,
              inclusive: true
            }
          },
          {
            keys: "b",
            type: "motion",
            motion: "moveByWords",
            motionArgs: {
              forward: false,
              wordEnd: false
            }
          },
          {
            keys: "B",
            type: "motion",
            motion: "moveByWords",
            motionArgs: {
              forward: false,
              wordEnd: false,
              bigWord: true
            }
          },
          {
            keys: "ge",
            type: "motion",
            motion: "moveByWords",
            motionArgs: {
              forward: false,
              wordEnd: true,
              inclusive: true
            }
          },
          {
            keys: "gE",
            type: "motion",
            motion: "moveByWords",
            motionArgs: {
              forward: false,
              wordEnd: true,
              bigWord: true,
              inclusive: true
            }
          },
          {
            keys: "{",
            type: "motion",
            motion: "moveByParagraph",
            motionArgs: {
              forward: false,
              toJumplist: true
            }
          },
          {
            keys: "}",
            type: "motion",
            motion: "moveByParagraph",
            motionArgs: {
              forward: true,
              toJumplist: true
            }
          },
          {
            keys: "(",
            type: "motion",
            motion: "moveBySentence",
            motionArgs: {
              forward: false
            }
          },
          {
            keys: ")",
            type: "motion",
            motion: "moveBySentence",
            motionArgs: {
              forward: true
            }
          },
          {
            keys: "<C-f>",
            type: "motion",
            motion: "moveByPage",
            motionArgs: {
              forward: true
            }
          },
          {
            keys: "<C-b>",
            type: "motion",
            motion: "moveByPage",
            motionArgs: {
              forward: false
            }
          },
          {
            keys: "<C-d>",
            type: "motion",
            motion: "moveByScroll",
            motionArgs: {
              forward: true,
              explicitRepeat: true
            }
          },
          {
            keys: "<C-u>",
            type: "motion",
            motion: "moveByScroll",
            motionArgs: {
              forward: false,
              explicitRepeat: true
            }
          },
          {
            keys: "gg",
            type: "motion",
            motion: "moveToLineOrEdgeOfDocument",
            motionArgs: {
              forward: false,
              explicitRepeat: true,
              linewise: true,
              toJumplist: true
            }
          },
          {
            keys: "G",
            type: "motion",
            motion: "moveToLineOrEdgeOfDocument",
            motionArgs: {
              forward: true,
              explicitRepeat: true,
              linewise: true,
              toJumplist: true
            }
          },
          {
            keys: "g$",
            type: "motion",
            motion: "moveToEndOfDisplayLine"
          },
          {
            keys: "g^",
            type: "motion",
            motion: "moveToStartOfDisplayLine"
          },
          {
            keys: "g0",
            type: "motion",
            motion: "moveToStartOfDisplayLine"
          },
          {
            keys: "0",
            type: "motion",
            motion: "moveToStartOfLine"
          },
          {
            keys: "^",
            type: "motion",
            motion: "moveToFirstNonWhiteSpaceCharacter"
          },
          {
            keys: "+",
            type: "motion",
            motion: "moveByLines",
            motionArgs: {
              forward: true,
              toFirstChar: true
            }
          },
          {
            keys: "-",
            type: "motion",
            motion: "moveByLines",
            motionArgs: {
              forward: false,
              toFirstChar: true
            }
          },
          {
            keys: "_",
            type: "motion",
            motion: "moveByLines",
            motionArgs: {
              forward: true,
              toFirstChar: true,
              repeatOffset: -1
            }
          },
          {
            keys: "$",
            type: "motion",
            motion: "moveToEol",
            motionArgs: {
              inclusive: true
            }
          },
          {
            keys: "%",
            type: "motion",
            motion: "moveToMatchedSymbol",
            motionArgs: {
              inclusive: true,
              toJumplist: true
            }
          },
          {
            keys: "f<character>",
            type: "motion",
            motion: "moveToCharacter",
            motionArgs: {
              forward: true,
              inclusive: true
            }
          },
          {
            keys: "F<character>",
            type: "motion",
            motion: "moveToCharacter",
            motionArgs: {
              forward: false
            }
          },
          {
            keys: "t<character>",
            type: "motion",
            motion: "moveTillCharacter",
            motionArgs: {
              forward: true,
              inclusive: true
            }
          },
          {
            keys: "T<character>",
            type: "motion",
            motion: "moveTillCharacter",
            motionArgs: {
              forward: false
            }
          },
          {
            keys: ";",
            type: "motion",
            motion: "repeatLastCharacterSearch",
            motionArgs: {
              forward: true
            }
          },
          {
            keys: ",",
            type: "motion",
            motion: "repeatLastCharacterSearch",
            motionArgs: {
              forward: false
            }
          },
          {
            keys: "'<register>",
            type: "motion",
            motion: "goToMark",
            motionArgs: {
              toJumplist: true,
              linewise: true
            }
          },
          {
            keys: "`<register>",
            type: "motion",
            motion: "goToMark",
            motionArgs: {
              toJumplist: true
            }
          },
          {
            keys: "]`",
            type: "motion",
            motion: "jumpToMark",
            motionArgs: {
              forward: true
            }
          },
          {
            keys: "[`",
            type: "motion",
            motion: "jumpToMark",
            motionArgs: {
              forward: false
            }
          },
          {
            keys: "]'",
            type: "motion",
            motion: "jumpToMark",
            motionArgs: {
              forward: true,
              linewise: true
            }
          },
          {
            keys: "['",
            type: "motion",
            motion: "jumpToMark",
            motionArgs: {
              forward: false,
              linewise: true
            }
          },
          {
            keys: "]p",
            type: "action",
            action: "paste",
            isEdit: true,
            actionArgs: {
              after: true,
              isEdit: true,
              matchIndent: true
            }
          },
          {
            keys: "[p",
            type: "action",
            action: "paste",
            isEdit: true,
            actionArgs: {
              after: false,
              isEdit: true,
              matchIndent: true
            }
          },
          {
            keys: "]<character>",
            type: "motion",
            motion: "moveToSymbol",
            motionArgs: {
              forward: true,
              toJumplist: true
            }
          },
          {
            keys: "[<character>",
            type: "motion",
            motion: "moveToSymbol",
            motionArgs: {
              forward: false,
              toJumplist: true
            }
          },
          {
            keys: "|",
            type: "motion",
            motion: "moveToColumn"
          },
          {
            keys: "o",
            type: "motion",
            motion: "moveToOtherHighlightedEnd",
            context: "visual"
          },
          {
            keys: "O",
            type: "motion",
            motion: "moveToOtherHighlightedEnd",
            motionArgs: {
              sameLine: true
            },
            context: "visual"
          },
          {
            keys: "d",
            type: "operator",
            operator: "delete"
          },
          {
            keys: "y",
            type: "operator",
            operator: "yank"
          },
          {
            keys: "c",
            type: "operator",
            operator: "change"
          },
          {
            keys: "=",
            type: "operator",
            operator: "indentAuto"
          },
          {
            keys: ">",
            type: "operator",
            operator: "indent",
            operatorArgs: {
              indentRight: true
            }
          },
          {
            keys: "<",
            type: "operator",
            operator: "indent",
            operatorArgs: {
              indentRight: false
            }
          },
          {
            keys: "g~",
            type: "operator",
            operator: "changeCase"
          },
          {
            keys: "gu",
            type: "operator",
            operator: "changeCase",
            operatorArgs: {
              toLower: true
            },
            isEdit: true
          },
          {
            keys: "gU",
            type: "operator",
            operator: "changeCase",
            operatorArgs: {
              toLower: false
            },
            isEdit: true
          },
          {
            keys: "n",
            type: "motion",
            motion: "findNext",
            motionArgs: {
              forward: true,
              toJumplist: true
            }
          },
          {
            keys: "N",
            type: "motion",
            motion: "findNext",
            motionArgs: {
              forward: false,
              toJumplist: true
            }
          },
          {
            keys: "gn",
            type: "motion",
            motion: "findAndSelectNextInclusive",
            motionArgs: {
              forward: true
            }
          },
          {
            keys: "gN",
            type: "motion",
            motion: "findAndSelectNextInclusive",
            motionArgs: {
              forward: false
            }
          },
          {
            keys: "gq",
            type: "operator",
            operator: "hardWrap"
          },
          {
            keys: "gw",
            type: "operator",
            operator: "hardWrap",
            operatorArgs: {
              keepCursor: true
            }
          },
          {
            keys: "g?",
            type: "operator",
            operator: "rot13"
          },
          {
            keys: "x",
            type: "operatorMotion",
            operator: "delete",
            motion: "moveByCharacters",
            motionArgs: {
              forward: true
            },
            operatorMotionArgs: {
              visualLine: false
            }
          },
          {
            keys: "X",
            type: "operatorMotion",
            operator: "delete",
            motion: "moveByCharacters",
            motionArgs: {
              forward: false
            },
            operatorMotionArgs: {
              visualLine: true
            }
          },
          {
            keys: "D",
            type: "operatorMotion",
            operator: "delete",
            motion: "moveToEol",
            motionArgs: {
              inclusive: true
            },
            context: "normal"
          },
          {
            keys: "D",
            type: "operator",
            operator: "delete",
            operatorArgs: {
              linewise: true
            },
            context: "visual"
          },
          {
            keys: "Y",
            type: "operatorMotion",
            operator: "yank",
            motion: "expandToLine",
            motionArgs: {
              linewise: true
            },
            context: "normal"
          },
          {
            keys: "Y",
            type: "operator",
            operator: "yank",
            operatorArgs: {
              linewise: true
            },
            context: "visual"
          },
          {
            keys: "C",
            type: "operatorMotion",
            operator: "change",
            motion: "moveToEol",
            motionArgs: {
              inclusive: true
            },
            context: "normal"
          },
          {
            keys: "C",
            type: "operator",
            operator: "change",
            operatorArgs: {
              linewise: true
            },
            context: "visual"
          },
          {
            keys: "~",
            type: "operatorMotion",
            operator: "changeCase",
            motion: "moveByCharacters",
            motionArgs: {
              forward: true
            },
            operatorArgs: {
              shouldMoveCursor: true
            },
            context: "normal"
          },
          {
            keys: "~",
            type: "operator",
            operator: "changeCase",
            context: "visual"
          },
          {
            keys: "<C-u>",
            type: "operatorMotion",
            operator: "delete",
            motion: "moveToStartOfLine",
            context: "insert"
          },
          {
            keys: "<C-w>",
            type: "operatorMotion",
            operator: "delete",
            motion: "moveByWords",
            motionArgs: {
              forward: false,
              wordEnd: false
            },
            context: "insert"
          },
          {
            keys: "<C-w>",
            type: "idle",
            context: "normal"
          },
          {
            keys: "<C-i>",
            type: "action",
            action: "jumpListWalk",
            actionArgs: {
              forward: true
            }
          },
          {
            keys: "<C-o>",
            type: "action",
            action: "jumpListWalk",
            actionArgs: {
              forward: false
            }
          },
          {
            keys: "<C-e>",
            type: "action",
            action: "scroll",
            actionArgs: {
              forward: true,
              linewise: true
            }
          },
          {
            keys: "<C-y>",
            type: "action",
            action: "scroll",
            actionArgs: {
              forward: false,
              linewise: true
            }
          },
          {
            keys: "a",
            type: "action",
            action: "enterInsertMode",
            isEdit: true,
            actionArgs: {
              insertAt: "charAfter"
            },
            context: "normal"
          },
          {
            keys: "A",
            type: "action",
            action: "enterInsertMode",
            isEdit: true,
            actionArgs: {
              insertAt: "eol"
            },
            context: "normal"
          },
          {
            keys: "A",
            type: "action",
            action: "enterInsertMode",
            isEdit: true,
            actionArgs: {
              insertAt: "endOfSelectedArea"
            },
            context: "visual"
          },
          {
            keys: "i",
            type: "action",
            action: "enterInsertMode",
            isEdit: true,
            actionArgs: {
              insertAt: "inplace"
            },
            context: "normal"
          },
          {
            keys: "gi",
            type: "action",
            action: "enterInsertMode",
            isEdit: true,
            actionArgs: {
              insertAt: "lastEdit"
            },
            context: "normal"
          },
          {
            keys: "I",
            type: "action",
            action: "enterInsertMode",
            isEdit: true,
            actionArgs: {
              insertAt: "firstNonBlank"
            },
            context: "normal"
          },
          {
            keys: "gI",
            type: "action",
            action: "enterInsertMode",
            isEdit: true,
            actionArgs: {
              insertAt: "bol"
            },
            context: "normal"
          },
          {
            keys: "I",
            type: "action",
            action: "enterInsertMode",
            isEdit: true,
            actionArgs: {
              insertAt: "startOfSelectedArea"
            },
            context: "visual"
          },
          {
            keys: "o",
            type: "action",
            action: "newLineAndEnterInsertMode",
            isEdit: true,
            interlaceInsertRepeat: true,
            actionArgs: {
              after: true
            },
            context: "normal"
          },
          {
            keys: "O",
            type: "action",
            action: "newLineAndEnterInsertMode",
            isEdit: true,
            interlaceInsertRepeat: true,
            actionArgs: {
              after: false
            },
            context: "normal"
          },
          {
            keys: "v",
            type: "action",
            action: "toggleVisualMode"
          },
          {
            keys: "V",
            type: "action",
            action: "toggleVisualMode",
            actionArgs: {
              linewise: true
            }
          },
          {
            keys: "<C-v>",
            type: "action",
            action: "toggleVisualMode",
            actionArgs: {
              blockwise: true
            }
          },
          {
            keys: "<C-q>",
            type: "action",
            action: "toggleVisualMode",
            actionArgs: {
              blockwise: true
            }
          },
          {
            keys: "gv",
            type: "action",
            action: "reselectLastSelection"
          },
          {
            keys: "J",
            type: "action",
            action: "joinLines",
            isEdit: true
          },
          {
            keys: "gJ",
            type: "action",
            action: "joinLines",
            actionArgs: {
              keepSpaces: true
            },
            isEdit: true
          },
          {
            keys: "p",
            type: "action",
            action: "paste",
            isEdit: true,
            actionArgs: {
              after: true,
              isEdit: true
            }
          },
          {
            keys: "P",
            type: "action",
            action: "paste",
            isEdit: true,
            actionArgs: {
              after: false,
              isEdit: true
            }
          },
          {
            keys: "r<character>",
            type: "action",
            action: "replace",
            isEdit: true
          },
          {
            keys: "@<register>",
            type: "action",
            action: "replayMacro"
          },
          {
            keys: "q<register>",
            type: "action",
            action: "enterMacroRecordMode"
          },
          {
            keys: "R",
            type: "action",
            action: "enterInsertMode",
            isEdit: true,
            actionArgs: {
              replace: true
            },
            context: "normal"
          },
          {
            keys: "R",
            type: "operator",
            operator: "change",
            operatorArgs: {
              linewise: true,
              fullLine: true
            },
            context: "visual",
            exitVisualBlock: true
          },
          {
            keys: "u",
            type: "action",
            action: "undo",
            context: "normal"
          },
          {
            keys: "u",
            type: "operator",
            operator: "changeCase",
            operatorArgs: {
              toLower: true
            },
            context: "visual",
            isEdit: true
          },
          {
            keys: "U",
            type: "operator",
            operator: "changeCase",
            operatorArgs: {
              toLower: false
            },
            context: "visual",
            isEdit: true
          },
          {
            keys: "<C-r>",
            type: "action",
            action: "redo"
          },
          {
            keys: "m<register>",
            type: "action",
            action: "setMark"
          },
          {
            keys: '"<register>',
            type: "action",
            action: "setRegister"
          },
          {
            keys: "<C-r><register>",
            type: "action",
            action: "insertRegister",
            context: "insert",
            isEdit: true
          },
          {
            keys: "<C-o>",
            type: "action",
            action: "oneNormalCommand",
            context: "insert"
          },
          {
            keys: "zz",
            type: "action",
            action: "scrollToCursor",
            actionArgs: {
              position: "center"
            }
          },
          {
            keys: "z.",
            type: "action",
            action: "scrollToCursor",
            actionArgs: {
              position: "center"
            },
            motion: "moveToFirstNonWhiteSpaceCharacter"
          },
          {
            keys: "zt",
            type: "action",
            action: "scrollToCursor",
            actionArgs: {
              position: "top"
            }
          },
          {
            keys: "z<CR>",
            type: "action",
            action: "scrollToCursor",
            actionArgs: {
              position: "top"
            },
            motion: "moveToFirstNonWhiteSpaceCharacter"
          },
          {
            keys: "zb",
            type: "action",
            action: "scrollToCursor",
            actionArgs: {
              position: "bottom"
            }
          },
          {
            keys: "z-",
            type: "action",
            action: "scrollToCursor",
            actionArgs: {
              position: "bottom"
            },
            motion: "moveToFirstNonWhiteSpaceCharacter"
          },
          {
            keys: ".",
            type: "action",
            action: "repeatLastEdit"
          },
          {
            keys: "<C-a>",
            type: "action",
            action: "incrementNumberToken",
            isEdit: true,
            actionArgs: {
              increase: true,
              backtrack: false
            }
          },
          {
            keys: "<C-x>",
            type: "action",
            action: "incrementNumberToken",
            isEdit: true,
            actionArgs: {
              increase: false,
              backtrack: false
            }
          },
          {
            keys: "<C-t>",
            type: "action",
            action: "indent",
            actionArgs: {
              indentRight: true
            },
            context: "insert"
          },
          {
            keys: "<C-d>",
            type: "action",
            action: "indent",
            actionArgs: {
              indentRight: false
            },
            context: "insert"
          },
          {
            keys: "a<register>",
            type: "motion",
            motion: "textObjectManipulation"
          },
          {
            keys: "i<register>",
            type: "motion",
            motion: "textObjectManipulation",
            motionArgs: {
              textObjectInner: true
            }
          },
          {
            keys: "/",
            type: "search",
            searchArgs: {
              forward: true,
              querySrc: "prompt",
              toJumplist: true
            }
          },
          {
            keys: "?",
            type: "search",
            searchArgs: {
              forward: false,
              querySrc: "prompt",
              toJumplist: true
            }
          },
          {
            keys: "*",
            type: "search",
            searchArgs: {
              forward: true,
              querySrc: "wordUnderCursor",
              wholeWordOnly: true,
              toJumplist: true
            }
          },
          {
            keys: "#",
            type: "search",
            searchArgs: {
              forward: false,
              querySrc: "wordUnderCursor",
              wholeWordOnly: true,
              toJumplist: true
            }
          },
          {
            keys: "g*",
            type: "search",
            searchArgs: {
              forward: true,
              querySrc: "wordUnderCursor",
              toJumplist: true
            }
          },
          {
            keys: "g#",
            type: "search",
            searchArgs: {
              forward: false,
              querySrc: "wordUnderCursor",
              toJumplist: true
            }
          },
          {
            keys: ":",
            type: "ex"
          }
        ], i = /* @__PURE__ */ Object.create(null), o = r.length, s = [
          {
            name: "colorscheme",
            shortName: "colo"
          },
          {
            name: "map"
          },
          {
            name: "imap",
            shortName: "im"
          },
          {
            name: "nmap",
            shortName: "nm"
          },
          {
            name: "vmap",
            shortName: "vm"
          },
          {
            name: "omap",
            shortName: "om"
          },
          {
            name: "noremap",
            shortName: "no"
          },
          {
            name: "nnoremap",
            shortName: "nn"
          },
          {
            name: "vnoremap",
            shortName: "vn"
          },
          {
            name: "inoremap",
            shortName: "ino"
          },
          {
            name: "onoremap",
            shortName: "ono"
          },
          {
            name: "unmap"
          },
          {
            name: "mapclear",
            shortName: "mapc"
          },
          {
            name: "nmapclear",
            shortName: "nmapc"
          },
          {
            name: "vmapclear",
            shortName: "vmapc"
          },
          {
            name: "imapclear",
            shortName: "imapc"
          },
          {
            name: "omapclear",
            shortName: "omapc"
          },
          {
            name: "write",
            shortName: "w"
          },
          {
            name: "undo",
            shortName: "u"
          },
          {
            name: "redo",
            shortName: "red"
          },
          {
            name: "set",
            shortName: "se"
          },
          {
            name: "setlocal",
            shortName: "setl"
          },
          {
            name: "setglobal",
            shortName: "setg"
          },
          {
            name: "sort",
            shortName: "sor"
          },
          {
            name: "substitute",
            shortName: "s",
            possiblyAsync: true
          },
          {
            name: "startinsert",
            shortName: "start"
          },
          {
            name: "nohlsearch",
            shortName: "noh"
          },
          {
            name: "yank",
            shortName: "y"
          },
          {
            name: "delmarks",
            shortName: "delm"
          },
          {
            name: "marks",
            excludeFromCommandHistory: true
          },
          {
            name: "registers",
            shortName: "reg",
            excludeFromCommandHistory: true
          },
          {
            name: "vglobal",
            shortName: "v"
          },
          {
            name: "delete",
            shortName: "d"
          },
          {
            name: "join",
            shortName: "j"
          },
          {
            name: "normal",
            shortName: "norm"
          },
          {
            name: "global",
            shortName: "g"
          }
        ], a = hf("");
        function l(f) {
          f.setOption("disableInput", true), f.setOption("showCursorWhenSelecting", false), t.signal(f, "vim-mode-change", {
            mode: "normal"
          }), f.on("cursorActivity", Bf), Q(f), t.on(f.getInputField(), "paste", u(f));
        }
        function c(f) {
          f.setOption("disableInput", false), f.off("cursorActivity", Bf), t.off(f.getInputField(), "paste", u(f)), f.state.vim = null, cs && clearTimeout(cs);
        }
        function u(f) {
          var d = f.state.vim;
          return d.onPasteFn || (d.onPasteFn = function() {
            d.insertMode || (f.setCursor(dt(f.getCursor(), 0, 1)), lo.enterInsertMode(f, {}, d));
          }), d.onPasteFn;
        }
        var h = /[\d]/, p = [
          t.isWordChar,
          function(f) {
            return f && !t.isWordChar(f) && !/\s/.test(f);
          }
        ], v = [
          function(f) {
            return /\S/.test(f);
          }
        ], y = [
          "<",
          ">"
        ], S = [
          "-",
          '"',
          ".",
          ":",
          "_",
          "/",
          "+"
        ], C = /^\w$/, w = /^[A-Z]$/;
        try {
          w = new RegExp("^[\\p{Lu}]$", "u");
        } catch {
        }
        function k(f, d) {
          return d >= f.firstLine() && d <= f.lastLine();
        }
        function T(f) {
          return /^[a-z]$/.test(f);
        }
        function P(f) {
          return "()[]{}".indexOf(f) != -1;
        }
        function R(f) {
          return h.test(f);
        }
        function L(f) {
          return w.test(f);
        }
        function D(f) {
          return /^\s*$/.test(f);
        }
        function F(f) {
          return ".?!".indexOf(f) != -1;
        }
        function K(f, d) {
          for (var m = 0; m < d.length; m++)
            if (d[m] == f)
              return true;
          return false;
        }
        var Y = {};
        function te(f, d, m, g, b) {
          if (d === void 0 && !b)
            throw Error("defaultValue is required unless callback is provided");
          if (m || (m = "string"), Y[f] = {
            type: m,
            defaultValue: d,
            callback: b
          }, g)
            for (var x = 0; x < g.length; x++)
              Y[g[x]] = Y[f];
          d && ne(f, d);
        }
        function ne(f, d, m, g) {
          var b = Y[f];
          g = g || {};
          var x = g.scope;
          if (!b)
            return new Error("Unknown option: " + f);
          if (b.type == "boolean") {
            if (d && d !== true)
              return new Error("Invalid argument: " + f + "=" + d);
            d !== false && (d = true);
          }
          b.callback ? (x !== "local" && b.callback(d, void 0), x !== "global" && m && b.callback(d, m)) : (x !== "local" && (b.value = b.type == "boolean" ? !!d : d), x !== "global" && m && (m.state.vim.options[f] = {
            value: d
          }));
        }
        function ue(f, d, m) {
          var g = Y[f];
          m = m || {};
          var b = m.scope;
          if (!g)
            return new Error("Unknown option: " + f);
          if (g.callback) {
            let x = d && g.callback(void 0, d);
            return b !== "global" && x !== void 0 ? x : b !== "local" ? g.callback() : void 0;
          } else
            return (b !== "global" && d && d.state.vim.options[f] || b !== "local" && g || {}).value;
        }
        te("filetype", void 0, "string", [
          "ft"
        ], function(f, d) {
          if (d !== void 0)
            if (f === void 0) {
              let m = d.getOption("mode");
              return m == "null" ? "" : m;
            } else {
              let m = f == "" ? "null" : f;
              d.setOption("mode", m);
            }
        }), te("textwidth", 80, "number", [
          "tw"
        ], function(f, d) {
          if (d !== void 0)
            if (f === void 0) {
              var m = d.getOption("textwidth");
              return m;
            } else {
              var g = Math.round(f);
              g > 1 && d.setOption("textwidth", g);
            }
        });
        var ye = function() {
          var f = 100, d = -1, m = 0, g = 0, b = new Array(f);
          function x(E, I, _) {
            var H = d % f, j = b[H];
            function W(X) {
              var J = ++d % f, xe = b[J];
              xe && xe.clear(), b[J] = E.setBookmark(X);
            }
            if (j) {
              var $ = j.find();
              $ && !Kt($, I) && W(I);
            } else
              W(I);
            W(_), m = d, g = d - f + 1, g < 0 && (g = 0);
          }
          function M(E, I) {
            d += I, d > m ? d = m : d < g && (d = g);
            var _ = b[(f + d) % f];
            if (_ && !_.find()) {
              var H = I > 0 ? 1 : -1, j, W = E.getCursor();
              do
                if (d += H, _ = b[(f + d) % f], _ && (j = _.find()) && !Kt(W, j))
                  break;
              while (d < m && d > g);
            }
            return _;
          }
          function A(E, I) {
            var _ = d, H = M(E, I);
            return d = _, H && H.find();
          }
          return {
            cachedCursor: void 0,
            add: x,
            find: A,
            move: M
          };
        }, ke = function(f) {
          return f ? {
            changes: f.changes,
            expectCursorActivityForChange: f.expectCursorActivityForChange
          } : {
            changes: [],
            expectCursorActivityForChange: false
          };
        };
        class Ee {
          constructor() {
            this.latestRegister = void 0, this.isPlaying = false, this.isRecording = false, this.replaySearchQueries = [], this.onRecordingDone = void 0, this.lastInsertModeChanges = ke();
          }
          exitMacroRecordMode() {
            var d = V.macroModeState;
            d.onRecordingDone && d.onRecordingDone(), d.onRecordingDone = void 0, d.isRecording = false;
          }
          enterMacroRecordMode(d, m) {
            var g = V.registerController.getRegister(m);
            if (g) {
              if (g.clear(), this.latestRegister = m, d.openDialog) {
                var b = on("span", {
                  class: "cm-vim-message"
                }, "recording @" + m);
                this.onRecordingDone = d.openDialog(b, function() {
                }, {
                  bottom: true
                });
              }
              this.isRecording = true;
            }
          }
        }
        function Q(f) {
          return f.state.vim || (f.state.vim = {
            inputState: new df(),
            lastEditInputState: void 0,
            lastEditActionCommand: void 0,
            lastHPos: -1,
            lastHSPos: -1,
            lastMotion: null,
            marks: {},
            insertMode: false,
            insertModeReturn: false,
            insertModeRepeat: void 0,
            visualMode: false,
            visualLine: false,
            visualBlock: false,
            lastSelection: null,
            lastPastedText: void 0,
            sel: {
              anchor: new e(0, 0),
              head: new e(0, 0)
            },
            options: {},
            expectLiteralNext: false,
            status: ""
          }), f.state.vim;
        }
        var V;
        function ae() {
          V = {
            searchQuery: null,
            searchIsReversed: false,
            lastSubstituteReplacePart: void 0,
            jumpList: ye(),
            macroModeState: new Ee(),
            lastCharacterSearch: {
              increment: 0,
              forward: true,
              selectedCharacter: ""
            },
            registerController: new Zm({}),
            searchHistoryController: new is(),
            exCommandHistoryController: new is()
          };
          for (var f in Y) {
            var d = Y[f];
            d.value = d.defaultValue;
          }
        }
        class ge {
          constructor(d, m) {
            this.keyName = d, this.key = m.key, this.ctrlKey = m.ctrlKey, this.altKey = m.altKey, this.metaKey = m.metaKey, this.shiftKey = m.shiftKey;
          }
        }
        var Te, ve = {
          enterVimMode: l,
          leaveVimMode: c,
          buildKeyMap: function() {
          },
          getRegisterController: function() {
            return V.registerController;
          },
          resetVimGlobalState_: ae,
          getVimGlobalState_: function() {
            return V;
          },
          maybeInitVimState_: Q,
          suppressErrorLogging: false,
          InsertModeKey: ge,
          map: function(f, d, m) {
            Ft.map(f, d, m);
          },
          unmap: function(f, d) {
            return Ft.unmap(f, d);
          },
          noremap: function(f, d, m) {
            Ft.map(f, d, m, true);
          },
          mapclear: function(f) {
            var d = r.length, m = o, g = r.slice(0, d - m);
            if (r = r.slice(d - m), f)
              for (var b = g.length - 1; b >= 0; b--) {
                var x = g[b];
                if (f !== x.context)
                  if (x.context)
                    this._mapCommand(x);
                  else {
                    var M = [
                      "normal",
                      "insert",
                      "visual"
                    ];
                    for (var A in M)
                      if (M[A] !== f) {
                        var E = Object.assign({}, x);
                        E.context = M[A], this._mapCommand(E);
                      }
                  }
              }
          },
          langmap: Ol,
          vimKeyFromEvent: ao,
          setOption: ne,
          getOption: ue,
          defineOption: te,
          defineEx: function(f, d, m) {
            if (!d)
              d = f;
            else if (f.indexOf(d) !== 0)
              throw new Error('(Vim.defineEx) "' + d + '" is not a prefix of "' + f + '", command not registered');
            ia[f] = m, Ft.commandMap_[d] = {
              name: f,
              shortName: d,
              type: "api"
            };
          },
          handleKey: function(f, d, m) {
            var g = this.findKey(f, d, m);
            if (typeof g == "function")
              return g();
          },
          multiSelectHandleKey: he,
          findKey: function(f, d, m) {
            var g = Q(f), b = f;
            function x() {
              var _ = V.macroModeState;
              if (_.isRecording) {
                if (d == "q")
                  return _.exitMacroRecordMode(), Et(b), true;
                m != "mapping" && kg(_, d);
              }
            }
            function M() {
              if (d == "<Esc>") {
                if (g.visualMode)
                  ir(b);
                else if (g.insertMode)
                  Qr(b);
                else
                  return;
                return Et(b), true;
              }
            }
            function A() {
              if (M())
                return true;
              g.inputState.keyBuffer.push(d);
              var _ = g.inputState.keyBuffer.join(""), H = d.length == 1, j = Er.matchCommand(_, r, g.inputState, "insert"), W = g.inputState.changeQueue;
              if (j.type == "none")
                return Et(b), false;
              if (j.type == "partial") {
                if (j.expectLiteralNext && (g.expectLiteralNext = true), Te && window.clearTimeout(Te), Te = H && window.setTimeout(function() {
                  g.insertMode && g.inputState.keyBuffer.length && Et(b);
                }, ue("insertModeEscKeysTimeout")), H) {
                  var $ = b.listSelections();
                  (!W || W.removed.length != $.length) && (W = g.inputState.changeQueue = new Qm()), W.inserted += d;
                  for (var X = 0; X < $.length; X++) {
                    var J = zt($[X].anchor, $[X].head), xe = Xr($[X].anchor, $[X].head), fe = b.getRange(J, b.state.overwrite ? dt(xe, 0, 1) : xe);
                    W.removed[X] = (W.removed[X] || "") + fe;
                  }
                }
                return !H;
              } else
                j.type == "full" && (g.inputState.keyBuffer.length = 0);
              if (g.expectLiteralNext = false, Te && window.clearTimeout(Te), j.command && W) {
                for (var $ = b.listSelections(), X = 0; X < $.length; X++) {
                  var Ae = $[X].head;
                  b.replaceRange(W.removed[X] || "", dt(Ae, 0, -W.inserted.length), Ae, "+input");
                }
                V.macroModeState.lastInsertModeChanges.changes.pop();
              }
              return j.command || Et(b), j.command;
            }
            function E() {
              if (x() || M())
                return true;
              g.inputState.keyBuffer.push(d);
              var _ = g.inputState.keyBuffer.join("");
              if (/^[1-9]\d*$/.test(_))
                return true;
              var H = /^(\d*)(.*)$/.exec(_);
              if (!H)
                return Et(b), false;
              var j = g.visualMode ? "visual" : "normal", W = H[2] || H[1];
              g.inputState.operatorShortcut && g.inputState.operatorShortcut.slice(-1) == W && (W = g.inputState.operatorShortcut);
              var $ = Er.matchCommand(W, r, g.inputState, j);
              return $.type == "none" ? (Et(b), false) : $.type == "partial" ? ($.expectLiteralNext && (g.expectLiteralNext = true), true) : $.type == "clear" ? (Et(b), true) : (g.expectLiteralNext = false, g.inputState.keyBuffer.length = 0, H = /^(\d*)(.*)$/.exec(_), H && H[1] && H[1] != "0" && g.inputState.pushRepeatDigit(H[1]), $.command);
            }
            var I = g.insertMode ? A() : E();
            if (I === false)
              return !g.insertMode && (d.length === 1 || t.isMac && /<A-.>/.test(d)) ? function() {
                return true;
              } : void 0;
            if (I === true)
              return function() {
                return true;
              };
            if (I)
              return function() {
                return b.operation(function() {
                  b.curOp.isVimOp = true;
                  try {
                    if (typeof I != "object")
                      return;
                    I.type == "keyToKey" ? yt(b, I.toKeys, I) : Er.processCommand(b, g, I);
                  } catch (_) {
                    throw b.state.vim = void 0, Q(b), console.log(_), _;
                  }
                  return true;
                });
              };
          },
          handleEx: function(f, d) {
            Ft.processCommand(f, d);
          },
          defineMotion: Pr,
          defineAction: Zs,
          defineOperator: eg,
          mapCommand: Li,
          _mapCommand: oa,
          defineRegister: Jm,
          exitVisualMode: ir,
          exitInsertMode: Qr
        }, se = [], re = false, oe;
        function De(f) {
          if (!oe)
            throw new Error("No prompt to send key to");
          if (f[0] == "<") {
            var d = f.toLowerCase().slice(1, -1), m = d.split("-");
            if (d = m.pop() || "", d == "lt")
              f = "<";
            else if (d == "space")
              f = " ";
            else if (d == "cr")
              f = `
`;
            else if (Yr[d]) {
              var g = oe.value || "", b = {
                key: Yr[d],
                target: {
                  value: g,
                  selectionEnd: g.length,
                  selectionStart: g.length
                }
              };
              oe.onKeyDown && oe.onKeyDown(b, oe.value, M), oe && oe.onKeyUp && oe.onKeyUp(b, oe.value, M);
              return;
            }
          }
          if (f == `
`) {
            var x = oe;
            oe = null, x.onClose && x.onClose(x.value);
          } else
            oe.value = (oe.value || "") + f;
          function M(A) {
            !oe || (typeof A == "string" ? oe.value = A : oe = null);
          }
        }
        function yt(f, d, m) {
          var g = re;
          if (m) {
            if (se.indexOf(m) != -1)
              return;
            se.push(m), re = m.noremap != false;
          }
          try {
            for (var b = Q(f), x = /<(?:[CSMA]-)*\w+>|./gi, M; M = x.exec(d); ) {
              var A = M[0], E = b.insertMode;
              if (oe) {
                De(A);
                continue;
              }
              var I = ve.handleKey(f, A, "mapping");
              if (!I && E && b.insertMode) {
                if (A[0] == "<") {
                  var _ = A.toLowerCase().slice(1, -1), H = _.split("-");
                  if (_ = H.pop() || "", _ == "lt")
                    A = "<";
                  else if (_ == "space")
                    A = " ";
                  else if (_ == "cr")
                    A = `
`;
                  else if (Yr.hasOwnProperty(_)) {
                    A = Yr[_], O(f, A);
                    continue;
                  } else
                    A = A[0], x.lastIndex = M.index + 1;
                }
                f.replaceSelection(A);
              }
            }
          } finally {
            if (se.pop(), re = se.length ? g : false, !se.length && oe) {
              var j = oe;
              oe = null, ea(f, j);
            }
          }
        }
        var An = {
          Return: "CR",
          Backspace: "BS",
          Delete: "Del",
          Escape: "Esc",
          Insert: "Ins",
          ArrowLeft: "Left",
          ArrowRight: "Right",
          ArrowUp: "Up",
          ArrowDown: "Down",
          Enter: "CR",
          " ": "Space"
        }, so = {
          Shift: 1,
          Alt: 1,
          Command: 1,
          Control: 1,
          CapsLock: 1,
          AltGraph: 1,
          Dead: 1,
          Unidentified: 1
        }, Yr = {};
        "Left|Right|Up|Down|End|Home".split("|").concat(Object.keys(An)).forEach(function(f) {
          Yr[(An[f] || "").toLowerCase()] = Yr[f.toLowerCase()] = f;
        });
        function ao(f, d) {
          var _a3;
          var m = f.key;
          if (!so[m]) {
            m.length > 1 && m[0] == "n" && (m = m.replace("Numpad", "")), m = An[m] || m;
            var g = "";
            if (f.ctrlKey && (g += "C-"), f.altKey && (g += "A-"), f.metaKey && (g += "M-"), t.isMac && g == "A-" && m.length == 1 && (g = g.slice(2)), (g || m.length > 1) && f.shiftKey && (g += "S-"), d && !d.expectLiteralNext && m.length == 1) {
              if (a.keymap && m in a.keymap)
                (a.remapCtrl != false || !g) && (m = a.keymap[m]);
              else if (m.charCodeAt(0) > 128 && !i[m]) {
                var b = ((_a3 = f.code) == null ? void 0 : _a3.slice(-1)) || "";
                f.shiftKey || (b = b.toLowerCase()), b && (m = b, !g && f.altKey && (g = "A-"));
              }
            }
            return g += m, g.length > 1 && (g = "<" + g + ">"), g;
          }
        }
        function Ol(f, d) {
          a.string !== f && (a = hf(f)), a.remapCtrl = d;
        }
        function hf(f) {
          let d = {};
          if (!f)
            return {
              keymap: d,
              string: ""
            };
          function m(g) {
            return g.split(/\\?(.)/).filter(Boolean);
          }
          return f.split(/((?:[^\\,]|\\.)+),/).map((g) => {
            if (!g)
              return;
            const b = g.split(/((?:[^\\;]|\\.)+);/);
            if (b.length == 3) {
              const x = m(b[1]), M = m(b[2]);
              if (x.length !== M.length)
                return;
              for (let A = 0; A < x.length; ++A)
                d[x[A]] = M[A];
            } else if (b.length == 1) {
              const x = m(g);
              if (x.length % 2 !== 0)
                return;
              for (let M = 0; M < x.length; M += 2)
                d[x[M]] = x[M + 1];
            }
          }), {
            keymap: d,
            string: f
          };
        }
        te("langmap", void 0, "string", [
          "lmap"
        ], function(f, d) {
          if (f === void 0)
            return a.string;
          Ol(f);
        });
        class df {
          constructor() {
            this.prefixRepeat = [], this.motionRepeat = [], this.operator = null, this.operatorArgs = null, this.motion = null, this.motionArgs = null, this.keyBuffer = [], this.registerName = void 0, this.changeQueue = null;
          }
          pushRepeatDigit(d) {
            this.operator ? this.motionRepeat = this.motionRepeat.concat(d) : this.prefixRepeat = this.prefixRepeat.concat(d);
          }
          getRepeat() {
            var d = 0;
            return (this.prefixRepeat.length > 0 || this.motionRepeat.length > 0) && (d = 1, this.prefixRepeat.length > 0 && (d *= parseInt(this.prefixRepeat.join(""), 10)), this.motionRepeat.length > 0 && (d *= parseInt(this.motionRepeat.join(""), 10))), d;
          }
        }
        function Et(f, d) {
          f.state.vim.inputState = new df(), f.state.vim.expectLiteralNext = false, t.signal(f, "vim-command-done", d);
        }
        function Qm() {
          this.removed = [], this.inserted = "";
        }
        class nr {
          constructor(d, m, g) {
            this.clear(), this.keyBuffer = [
              d || ""
            ], this.insertModeChanges = [], this.searchQueries = [], this.linewise = !!m, this.blockwise = !!g;
          }
          setText(d, m, g) {
            this.keyBuffer = [
              d || ""
            ], this.linewise = !!m, this.blockwise = !!g;
          }
          pushText(d, m) {
            m && (this.linewise || this.keyBuffer.push(`
`), this.linewise = true), this.keyBuffer.push(d);
          }
          pushInsertModeChanges(d) {
            this.insertModeChanges.push(ke(d));
          }
          pushSearchQuery(d) {
            this.searchQueries.push(d);
          }
          clear() {
            this.keyBuffer = [], this.insertModeChanges = [], this.searchQueries = [], this.linewise = false;
          }
          toString() {
            return this.keyBuffer.join("");
          }
        }
        function Jm(f, d) {
          var m = V.registerController.registers;
          if (!f || f.length != 1)
            throw Error("Register name must be 1 character");
          if (m[f])
            throw Error("Register already defined " + f);
          m[f] = d, S.push(f);
        }
        class Zm {
          constructor(d) {
            this.registers = d, this.unnamedRegister = d['"'] = new nr(), d["."] = new nr(), d[":"] = new nr(), d["/"] = new nr(), d["+"] = new nr();
          }
          pushText(d, m, g, b, x) {
            if (d !== "_") {
              b && g.charAt(g.length - 1) !== `
` && (g += `
`);
              var M = this.isValidRegister(d) ? this.getRegister(d) : null;
              if (!M || !d) {
                switch (m) {
                  case "yank":
                    this.registers[0] = new nr(g, b, x);
                    break;
                  case "delete":
                  case "change":
                    g.indexOf(`
`) == -1 ? this.registers["-"] = new nr(g, b) : (this.shiftNumericRegisters_(), this.registers[1] = new nr(g, b));
                    break;
                }
                this.unnamedRegister.setText(g, b, x);
                return;
              }
              var A = L(d);
              A ? M.pushText(g, b) : M.setText(g, b, x), d === "+" && navigator.clipboard.writeText(g), this.unnamedRegister.setText(M.toString(), b);
            }
          }
          getRegister(d) {
            return this.isValidRegister(d) ? (d = d.toLowerCase(), this.registers[d] || (this.registers[d] = new nr()), this.registers[d]) : this.unnamedRegister;
          }
          isValidRegister(d) {
            return d && (K(d, S) || C.test(d));
          }
          shiftNumericRegisters_() {
            for (var d = 9; d >= 2; d--)
              this.registers[d] = this.getRegister("" + (d - 1));
          }
        }
        class is {
          constructor() {
            this.historyBuffer = [], this.iterator = 0, this.initialPrefix = null;
          }
          nextMatch(d, m) {
            var g = this.historyBuffer, b = m ? -1 : 1;
            this.initialPrefix === null && (this.initialPrefix = d);
            for (var x = this.iterator + b; m ? x >= 0 : x < g.length; x += b)
              for (var M = g[x], A = 0; A <= M.length; A++)
                if (this.initialPrefix == M.substring(0, A))
                  return this.iterator = x, M;
            if (x >= g.length)
              return this.iterator = g.length, this.initialPrefix;
            if (x < 0)
              return d;
          }
          pushInput(d) {
            var m = this.historyBuffer.indexOf(d);
            m > -1 && this.historyBuffer.splice(m, 1), d.length && this.historyBuffer.push(d);
          }
          reset() {
            this.initialPrefix = null, this.iterator = this.historyBuffer.length;
          }
        }
        var Er = {
          matchCommand: function(f, d, m, g) {
            var b = pf(f, d, g, m), x = b.full[0];
            if (!x)
              return b.partial.length ? {
                type: "partial",
                expectLiteralNext: b.partial.length == 1 && b.partial[0].keys.slice(-11) == "<character>"
              } : {
                type: "none"
              };
            if (x.keys.slice(-11) == "<character>" || x.keys.slice(-10) == "<register>") {
              var M = tg(f);
              if (!M || M.length > 1)
                return {
                  type: "clear"
                };
              m.selectedCharacter = M;
            }
            return {
              type: "full",
              command: x
            };
          },
          processCommand: function(f, d, m) {
            switch (d.inputState.repeatOverride = m.repeatOverride, m.type) {
              case "motion":
                this.processMotion(f, d, m);
                break;
              case "operator":
                this.processOperator(f, d, m);
                break;
              case "operatorMotion":
                this.processOperatorMotion(f, d, m);
                break;
              case "action":
                this.processAction(f, d, m);
                break;
              case "search":
                this.processSearch(f, d, m);
                break;
              case "ex":
              case "keyToEx":
                this.processEx(f, d, m);
                break;
            }
          },
          processMotion: function(f, d, m) {
            d.inputState.motion = m.motion, d.inputState.motionArgs = os(m.motionArgs), this.evalInput(f, d);
          },
          processOperator: function(f, d, m) {
            var g = d.inputState;
            if (g.operator)
              if (g.operator == m.operator) {
                g.motion = "expandToLine", g.motionArgs = {
                  linewise: true,
                  repeat: 1
                }, this.evalInput(f, d);
                return;
              } else
                Et(f);
            g.operator = m.operator, g.operatorArgs = os(m.operatorArgs), m.keys.length > 1 && (g.operatorShortcut = m.keys), m.exitVisualBlock && (d.visualBlock = false, co(f)), d.visualMode && this.evalInput(f, d);
          },
          processOperatorMotion: function(f, d, m) {
            var g = d.visualMode, b = os(m.operatorMotionArgs);
            b && g && b.visualLine && (d.visualLine = true), this.processOperator(f, d, m), g || this.processMotion(f, d, m);
          },
          processAction: function(f, d, m) {
            var g = d.inputState, b = g.getRepeat(), x = !!b, M = os(m.actionArgs) || {
              repeat: 1
            };
            g.selectedCharacter && (M.selectedCharacter = g.selectedCharacter), m.operator && this.processOperator(f, d, m), m.motion && this.processMotion(f, d, m), (m.motion || m.operator) && this.evalInput(f, d), M.repeat = b || 1, M.repeatIsExplicit = x, M.registerName = g.registerName, Et(f), d.lastMotion = null, m.isEdit && this.recordLastEdit(d, g, m), lo[m.action](f, M, d);
          },
          processSearch: function(f, d, m) {
            if (!f.getSearchCursor)
              return;
            var g = m.searchArgs.forward, b = m.searchArgs.wholeWordOnly;
            Pn(f).setReversed(!g);
            var x = g ? "/" : "?", M = Pn(f).getQuery(), A = f.getScrollInfo(), E = "";
            function I(fe, Ae, Le) {
              V.searchHistoryController.pushInput(fe), V.searchHistoryController.reset();
              try {
                ls(f, fe, Ae, Le);
              } catch {
                _e2(f, "Invalid regex: " + fe), Et(f);
                return;
              }
              Er.processMotion(f, d, {
                keys: "",
                type: "motion",
                motion: "findNext",
                motionArgs: {
                  forward: true,
                  toJumplist: m.searchArgs.toJumplist
                }
              });
            }
            function _(fe) {
              f.scrollTo(A.left, A.top), I(fe, true, true);
              var Ae = V.macroModeState;
              Ae.isRecording && Cg(Ae, fe);
            }
            function H() {
              return ue("pcre") ? "(JavaScript regexp: set pcre)" : "(Vim regexp: set nopcre)";
            }
            function j(fe, Ae, Le) {
              var Oe = ao(fe), ut, pt;
              Oe == "<Up>" || Oe == "<Down>" ? (ut = Oe == "<Up>", pt = fe.target ? fe.target.selectionEnd : 0, Ae = V.searchHistoryController.nextMatch(Ae, ut) || "", Le(Ae), pt && fe.target && (fe.target.selectionEnd = fe.target.selectionStart = Math.min(pt, fe.target.value.length))) : Oe && Oe != "<Left>" && Oe != "<Right>" && V.searchHistoryController.reset(), E = Ae, W();
            }
            function W() {
              var fe;
              try {
                fe = ls(f, E, true, true);
              } catch {
              }
              fe ? f.scrollIntoView(Lf(f, !g, fe), 30) : (fo(f), f.scrollTo(A.left, A.top));
            }
            function $(fe, Ae, Le) {
              var Oe = ao(fe);
              Oe == "<Esc>" || Oe == "<C-c>" || Oe == "<C-[>" || Oe == "<BS>" && Ae == "" ? (V.searchHistoryController.pushInput(Ae), V.searchHistoryController.reset(), ls(f, (M == null ? void 0 : M.source) || ""), fo(f), f.scrollTo(A.left, A.top), t.e_stop(fe), Et(f), Le(), f.focus()) : Oe == "<Up>" || Oe == "<Down>" ? t.e_stop(fe) : Oe == "<C-u>" && (t.e_stop(fe), Le(""));
            }
            switch (m.searchArgs.querySrc) {
              case "prompt":
                var X = V.macroModeState;
                if (X.isPlaying) {
                  let Ae = X.replaySearchQueries.shift();
                  I(Ae || "", true, false);
                } else
                  ea(f, {
                    onClose: _,
                    prefix: x,
                    desc: on("span", {
                      $cursor: "pointer",
                      onmousedown: function(Ae) {
                        Ae.preventDefault(), ne("pcre", !ue("pcre")), this.textContent = H(), W();
                      }
                    }, H()),
                    onKeyUp: j,
                    onKeyDown: $
                  });
                break;
              case "wordUnderCursor":
                var J = Il(f, {
                  noSymbol: true
                }), xe = true;
                if (J || (J = Il(f, {
                  noSymbol: false
                }), xe = false), !J) {
                  _e2(f, "No word under cursor"), Et(f);
                  return;
                }
                let fe = f.getLine(J.start.line).substring(J.start.ch, J.end.ch);
                xe && b ? fe = "\\b" + fe + "\\b" : fe = Oi(fe), V.jumpList.cachedCursor = f.getCursor(), f.setCursor(J.start), I(fe, true, false);
                break;
            }
          },
          processEx: function(f, d, m) {
            function g(A) {
              V.exCommandHistoryController.pushInput(A), V.exCommandHistoryController.reset(), Ft.processCommand(f, A), f.state.vim && Et(f), fo(f);
            }
            function b(A, E, I) {
              var _ = ao(A), H, j;
              (_ == "<Esc>" || _ == "<C-c>" || _ == "<C-[>" || _ == "<BS>" && E == "") && (V.exCommandHistoryController.pushInput(E), V.exCommandHistoryController.reset(), t.e_stop(A), Et(f), fo(f), I(), f.focus()), _ == "<Up>" || _ == "<Down>" ? (t.e_stop(A), H = _ == "<Up>", j = A.target ? A.target.selectionEnd : 0, E = V.exCommandHistoryController.nextMatch(E, H) || "", I(E), j && A.target && (A.target.selectionEnd = A.target.selectionStart = Math.min(j, A.target.value.length))) : _ == "<C-u>" ? (t.e_stop(A), I("")) : _ && _ != "<Left>" && _ != "<Right>" && V.exCommandHistoryController.reset();
            }
            function x(A, E) {
              var I = new t.StringStream(E), _ = {};
              try {
                if (Ft.parseInput_(f, I, _), _.commandName != "s") {
                  fo(f);
                  return;
                }
                var H = Ft.matchCommand_(_.commandName);
                if (!H || (Ft.parseCommandArgs_(I, _, H), !_.argString))
                  return;
                var j = Of(_.argString.slice(1), true, true);
                j && ta(f, j);
              } catch {
              }
            }
            if (m.type == "keyToEx")
              Ft.processCommand(f, m.exArgs.input);
            else {
              var M = {
                onClose: g,
                onKeyDown: b,
                onKeyUp: x,
                prefix: ":"
              };
              d.visualMode && (M.value = "'<,'>", M.selectValueOnOpen = false), ea(f, M);
            }
          },
          evalInput: function(f, d) {
            var m = d.inputState, g = m.motion, b = m.motionArgs || {
              repeat: 1
            }, x = m.operator, M = m.operatorArgs || {}, A = m.registerName, E = d.sel, I = ze(d.visualMode ? $t(f, E.head) : f.getCursor("head")), _ = ze(d.visualMode ? $t(f, E.anchor) : f.getCursor("anchor")), H = ze(I), j = ze(_), W, $, X;
            if (x && this.recordLastEdit(d, m), m.repeatOverride !== void 0 ? X = m.repeatOverride : X = m.getRepeat(), X > 0 && b.explicitRepeat ? b.repeatIsExplicit = true : (b.noRepeat || !b.explicitRepeat && X === 0) && (X = 1, b.repeatIsExplicit = false), m.selectedCharacter && (b.selectedCharacter = M.selectedCharacter = m.selectedCharacter), b.repeat = X, Et(f), g) {
              var J = vn[g](f, I, b, d, m);
              if (d.lastMotion = vn[g], !J)
                return;
              if (b.toJumplist) {
                var xe = V.jumpList, fe = xe.cachedCursor;
                fe ? (bf(f, fe, J), delete xe.cachedCursor) : bf(f, I, J);
              }
              J instanceof Array ? ($ = J[0], W = J[1]) : W = J, W || (W = ze(I)), d.visualMode ? (d.visualBlock && W.ch === 1 / 0 || (W = $t(f, W, H)), $ && ($ = $t(f, $)), $ = $ || j, E.anchor = $, E.head = W, co(f), En(f, d, "<", ct($, W) ? $ : W), En(f, d, ">", ct($, W) ? W : $)) : x || (W = $t(f, W, H), f.setCursor(W.line, W.ch));
            }
            if (x) {
              if (M.lastSel) {
                $ = j;
                var Ae = M.lastSel, Le = Math.abs(Ae.head.line - Ae.anchor.line), Oe = Math.abs(Ae.head.ch - Ae.anchor.ch);
                Ae.visualLine ? W = new e(j.line + Le, j.ch) : Ae.visualBlock ? W = new e(j.line + Le, j.ch + Oe) : Ae.head.line == Ae.anchor.line ? W = new e(j.line, j.ch + Oe) : W = new e(j.line + Le, j.ch), d.visualMode = true, d.visualLine = Ae.visualLine, d.visualBlock = Ae.visualBlock, E = d.sel = {
                  anchor: $,
                  head: W
                }, co(f);
              } else
                d.visualMode && (M.lastSel = {
                  anchor: ze(E.anchor),
                  head: ze(E.head),
                  visualBlock: d.visualBlock,
                  visualLine: d.visualLine
                });
              var ut, pt, Fe, Me, et;
              if (d.visualMode) {
                ut = zt(E.head, E.anchor), pt = Xr(E.head, E.anchor), Fe = d.visualLine || M.linewise, Me = d.visualBlock ? "block" : Fe ? "line" : "char";
                var sr = n(f, ut, pt);
                if (et = _l2(f, {
                  anchor: sr.start,
                  head: sr.end
                }, Me), Fe) {
                  var qt = et.ranges;
                  if (Me == "block")
                    for (var ar = 0; ar < qt.length; ar++)
                      qt[ar].head.ch = bt(f, qt[ar].head.line);
                  else
                    Me == "line" && (qt[0].head = new e(qt[0].head.line + 1, 0));
                }
              } else {
                if (ut = ze($ || j), pt = ze(W || H), ct(pt, ut)) {
                  var fs = ut;
                  ut = pt, pt = fs;
                }
                Fe = b.linewise || M.linewise, Fe ? ag(f, ut, pt) : b.forward && uo(f, ut, pt), Me = "char";
                var lD = !b.inclusive || Fe, sr = n(f, ut, pt);
                et = _l2(f, {
                  anchor: sr.start,
                  head: sr.end
                }, Me, lD);
              }
              f.setSelections(et.ranges, et.primary), d.lastMotion = null, M.repeat = X, M.registerName = A, M.linewise = Fe;
              var Tg = Js[x](f, M, et.ranges, j, W);
              d.visualMode && ir(f, Tg != null), Tg && f.setCursor(Tg);
            }
          },
          recordLastEdit: function(f, d, m) {
            var g = V.macroModeState;
            g.isPlaying || (f.lastEditInputState = d, f.lastEditActionCommand = m, g.lastInsertModeChanges.changes = [], g.lastInsertModeChanges.expectCursorActivityForChange = false, g.lastInsertModeChanges.visualBlock = f.visualBlock ? f.sel.head.line - f.sel.anchor.line : 0);
          }
        }, vn = {
          moveToTopLine: function(f, d, m) {
            var g = $l(f).top + m.repeat - 1;
            return new e(g, or(f.getLine(g)));
          },
          moveToMiddleLine: function(f) {
            var d = $l(f), m = Math.floor((d.top + d.bottom) * 0.5);
            return new e(m, or(f.getLine(m)));
          },
          moveToBottomLine: function(f, d, m) {
            var g = $l(f).bottom - m.repeat + 1;
            return new e(g, or(f.getLine(g)));
          },
          expandToLine: function(f, d, m) {
            var g = d;
            return new e(g.line + m.repeat - 1, 1 / 0);
          },
          findNext: function(f, d, m) {
            var g = Pn(f), b = g.getQuery();
            if (!!b) {
              var x = !m.forward;
              x = g.isReversed() ? !x : x, ta(f, b);
              var M = Lf(f, x, b, m.repeat);
              return M || _e2(f, "No match found " + b + (ue("pcre") ? " (set nopcre to use Vim regexps)" : "")), M;
            }
          },
          findAndSelectNextInclusive: function(f, d, m, g, b) {
            var x = Pn(f), M = x.getQuery();
            if (!!M) {
              var A = !m.forward;
              A = x.isReversed() ? !A : A;
              var E = wg(f, A, M, m.repeat, g);
              if (!!E) {
                if (b.operator)
                  return E;
                var I = E[0], _ = new e(E[1].line, E[1].ch - 1);
                if (g.visualMode) {
                  (g.visualLine || g.visualBlock) && (g.visualLine = false, g.visualBlock = false, t.signal(f, "vim-mode-change", {
                    mode: "visual",
                    subMode: ""
                  }));
                  var H = g.sel.anchor;
                  if (H)
                    return x.isReversed() ? m.forward ? [
                      H,
                      I
                    ] : [
                      H,
                      _
                    ] : m.forward ? [
                      H,
                      _
                    ] : [
                      H,
                      I
                    ];
                } else
                  g.visualMode = true, g.visualLine = false, g.visualBlock = false, t.signal(f, "vim-mode-change", {
                    mode: "visual",
                    subMode: ""
                  });
                return A ? [
                  _,
                  I
                ] : [
                  I,
                  _
                ];
              }
            }
          },
          goToMark: function(f, d, m, g) {
            var b = na(f, g, m.selectedCharacter || "");
            return b ? m.linewise ? {
              line: b.line,
              ch: or(f.getLine(b.line))
            } : b : null;
          },
          moveToOtherHighlightedEnd: function(f, d, m, g) {
            var b = g.sel;
            return g.visualBlock && m.sameLine ? [
              $t(f, new e(b.anchor.line, b.head.ch)),
              $t(f, new e(b.head.line, b.anchor.ch))
            ] : [
              b.head,
              b.anchor
            ];
          },
          jumpToMark: function(f, d, m, g) {
            for (var b = d, x = 0; x < m.repeat; x++) {
              var M = b;
              for (var A in g.marks)
                if (!!T(A)) {
                  var E = g.marks[A].find(), I = m.forward ? ct(E, M) : ct(M, E);
                  if (!I && !(m.linewise && E.line == M.line)) {
                    var _ = Kt(M, b), H = m.forward ? Ll(M, E, b) : Ll(b, E, M);
                    (_ || H) && (b = E);
                  }
                }
            }
            return m.linewise && (b = new e(b.line, or(f.getLine(b.line)))), b;
          },
          moveByCharacters: function(f, d, m) {
            var g = d, b = m.repeat, x = m.forward ? g.ch + b : g.ch - b;
            return new e(g.line, x);
          },
          moveByLines: function(f, d, m, g) {
            var b = d, x = b.ch;
            switch (g.lastMotion) {
              case this.moveByLines:
              case this.moveByDisplayLines:
              case this.moveByScroll:
              case this.moveToColumn:
              case this.moveToEol:
                x = g.lastHPos;
                break;
              default:
                g.lastHPos = x;
            }
            var M = m.repeat + (m.repeatOffset || 0), A = m.forward ? b.line + M : b.line - M, E = f.firstLine(), I = f.lastLine(), _ = f.findPosV(b, m.forward ? M : -M, "line", g.lastHSPos), H = m.forward ? _.line > A : _.line < A;
            return H && (A = _.line, x = _.ch), A < E && b.line == E ? this.moveToStartOfLine(f, d, m, g) : A > I && b.line == I ? wf(f, d, m, g, true) : (m.toFirstChar && (x = or(f.getLine(A)), g.lastHPos = x), g.lastHSPos = f.charCoords(new e(A, x), "div").left, new e(A, x));
          },
          moveByDisplayLines: function(f, d, m, g) {
            var b = d;
            switch (g.lastMotion) {
              case this.moveByDisplayLines:
              case this.moveByScroll:
              case this.moveByLines:
              case this.moveToColumn:
              case this.moveToEol:
                break;
              default:
                g.lastHSPos = f.charCoords(b, "div").left;
            }
            var x = m.repeat, M = f.findPosV(b, m.forward ? x : -x, "line", g.lastHSPos);
            if (M.hitSide)
              if (m.forward) {
                var A = f.charCoords(M, "div"), E = {
                  top: A.top + 8,
                  left: g.lastHSPos
                };
                M = f.coordsChar(E, "div");
              } else {
                var I = f.charCoords(new e(f.firstLine(), 0), "div");
                I.left = g.lastHSPos, M = f.coordsChar(I, "div");
              }
            return g.lastHPos = M.ch, M;
          },
          moveByPage: function(f, d, m) {
            var g = d, b = m.repeat;
            return f.findPosV(g, m.forward ? b : -b, "page");
          },
          moveByParagraph: function(f, d, m) {
            var g = m.forward ? 1 : -1;
            return kf(f, d, m.repeat, g).start;
          },
          moveBySentence: function(f, d, m) {
            var g = m.forward ? 1 : -1;
            return Cf(f, d, m.repeat, g);
          },
          moveByScroll: function(f, d, m, g) {
            var b = f.getScrollInfo(), x = null, M = m.repeat;
            M || (M = b.clientHeight / (2 * f.defaultTextHeight()));
            var A = f.charCoords(d, "local");
            if (m.repeat = M, x = vn.moveByDisplayLines(f, d, m, g), !x)
              return null;
            var E = f.charCoords(x, "local");
            return f.scrollTo(null, b.top + E.top - A.top), x;
          },
          moveByWords: function(f, d, m) {
            return fg(f, d, m.repeat, !!m.forward, !!m.wordEnd, !!m.bigWord);
          },
          moveTillCharacter: function(f, d, m) {
            var g = m.repeat, b = ss(f, g, m.forward, m.selectedCharacter, d), x = m.forward ? -1 : 1;
            return Ri(x, m), b ? (b.ch += x, b) : null;
          },
          moveToCharacter: function(f, d, m) {
            var g = m.repeat;
            return Ri(0, m), ss(f, g, m.forward, m.selectedCharacter, d) || d;
          },
          moveToSymbol: function(f, d, m) {
            var g = m.repeat;
            return m.selectedCharacter && ug(f, g, m.forward, m.selectedCharacter) || d;
          },
          moveToColumn: function(f, d, m, g) {
            var b = m.repeat;
            return g.lastHPos = b - 1, g.lastHSPos = f.charCoords(d, "div").left, hg(f, b);
          },
          moveToEol: function(f, d, m, g) {
            return wf(f, d, m, g, false);
          },
          moveToFirstNonWhiteSpaceCharacter: function(f, d) {
            var m = d;
            return new e(m.line, or(f.getLine(m.line)));
          },
          moveToMatchedSymbol: function(f, d) {
            for (var m = d, g = m.line, b = m.ch, x = f.getLine(g), M; b < x.length; b++)
              if (M = x.charAt(b), M && P(M)) {
                var A = f.getTokenTypeAt(new e(g, b + 1));
                if (A !== "string" && A !== "comment")
                  break;
              }
            if (b < x.length) {
              var E = M === "<" || M === ">" ? /[(){}[\]<>]/ : /[(){}[\]]/, I = f.findMatchingBracket(new e(g, b), {
                bracketRegex: E
              });
              return I.to;
            } else
              return m;
          },
          moveToStartOfLine: function(f, d) {
            return new e(d.line, 0);
          },
          moveToLineOrEdgeOfDocument: function(f, d, m) {
            var g = m.forward ? f.lastLine() : f.firstLine();
            return m.repeatIsExplicit && (g = m.repeat - f.getOption("firstLineNumber")), new e(g, or(f.getLine(g)));
          },
          moveToStartOfDisplayLine: function(f) {
            return f.execCommand("goLineLeft"), f.getCursor();
          },
          moveToEndOfDisplayLine: function(f) {
            f.execCommand("goLineRight");
            var d = f.getCursor();
            return d.sticky == "before" && d.ch--, d;
          },
          textObjectManipulation: function(f, d, m, g) {
            var b = {
              "(": ")",
              ")": "(",
              "{": "}",
              "}": "{",
              "[": "]",
              "]": "[",
              "<": ">",
              ">": "<"
            }, x = {
              "'": true,
              '"': true,
              "`": true
            }, M = m.selectedCharacter || "";
            M == "b" ? M = "(" : M == "B" && (M = "{");
            var A = !m.textObjectInner, E, I;
            if (b[M]) {
              if (I = true, E = Tf(f, d, M, A), !E) {
                var _ = f.getSearchCursor(new RegExp("\\" + M, "g"), d);
                _.find() && (E = Tf(f, _.from(), M, A));
              }
            } else if (x[M])
              I = true, E = dg(f, d, M, A);
            else if (M === "W" || M === "w")
              for (var H = m.repeat || 1; H-- > 0; ) {
                var j = Il(f, {
                  inclusive: A,
                  innerWord: !A,
                  bigWord: M === "W",
                  noSymbol: M === "W",
                  multiline: true
                }, E && E.end);
                j && (E || (E = j), E.end = j.end);
              }
            else if (M === "p")
              if (E = kf(f, d, m.repeat, 0, A), m.linewise = true, g.visualMode)
                g.visualLine || (g.visualLine = true);
              else {
                var W = g.inputState.operatorArgs;
                W && (W.linewise = true), E.end.line--;
              }
            else if (M === "t")
              E = lg(f, d, A);
            else if (M === "s") {
              var $ = f.getLine(d.line);
              d.ch > 0 && F($[d.ch]) && (d.ch -= 1);
              var X = as(f, d, m.repeat, 1, A), J = as(f, d, m.repeat, -1, A);
              D(f.getLine(J.line)[J.ch]) && D(f.getLine(X.line)[X.ch - 1]) && (J = {
                line: J.line,
                ch: J.ch + 1
              }), E = {
                start: J,
                end: X
              };
            }
            return E ? f.state.vim.visualMode ? og(f, E.start, E.end, I) : [
              E.start,
              E.end
            ] : null;
          },
          repeatLastCharacterSearch: function(f, d, m) {
            var g = V.lastCharacterSearch, b = m.repeat, x = m.forward === g.forward, M = (g.increment ? 1 : 0) * (x ? -1 : 1);
            f.moveH(-M, "char"), m.inclusive = !!x;
            var A = ss(f, b, x, g.selectedCharacter);
            return A ? (A.ch += M, A) : (f.moveH(M, "char"), d);
          }
        };
        function Pr(f, d) {
          vn[f] = d;
        }
        function Rl(f, d) {
          for (var m = [], g = 0; g < d; g++)
            m.push(f);
          return m;
        }
        var Js = {
          change: function(f, d, m) {
            var g, b, x = f.state.vim, M = m[0].anchor, A = m[0].head;
            if (x.visualMode)
              if (d.fullLine)
                A.ch = Number.MAX_VALUE, A.line--, f.setSelection(M, A), b = f.getSelection(), f.replaceSelection(""), g = M;
              else {
                b = f.getSelection();
                var _ = Rl("", m.length);
                f.replaceSelections(_), g = zt(m[0].head, m[0].anchor);
              }
            else {
              b = f.getRange(M, A);
              var E = x.lastEditInputState;
              if ((E == null ? void 0 : E.motion) == "moveByWords" && !D(b)) {
                var I = /\s+$/.exec(b);
                I && E.motionArgs && E.motionArgs.forward && (A = dt(A, 0, -I[0].length), b = b.slice(0, -I[0].length));
              }
              d.linewise && (M = new e(M.line, or(f.getLine(M.line))), A.line > M.line && (A = new e(A.line - 1, Number.MAX_VALUE))), f.replaceRange("", M, A), g = M;
            }
            V.registerController.pushText(d.registerName, "change", b, d.linewise, m.length > 1), lo.enterInsertMode(f, {
              head: g
            }, f.state.vim);
          },
          delete: function(f, d, m) {
            var g, b, x = f.state.vim;
            if (x.visualBlock) {
              b = f.getSelection();
              var E = Rl("", m.length);
              f.replaceSelections(E), g = zt(m[0].head, m[0].anchor);
            } else {
              var M = m[0].anchor, A = m[0].head;
              d.linewise && A.line != f.firstLine() && M.line == f.lastLine() && M.line == A.line - 1 && (M.line == f.firstLine() ? M.ch = 0 : M = new e(M.line - 1, bt(f, M.line - 1))), b = f.getRange(M, A), f.replaceRange("", M, A), g = M, d.linewise && (g = vn.moveToFirstNonWhiteSpaceCharacter(f, M));
            }
            return V.registerController.pushText(d.registerName, "delete", b, d.linewise, x.visualBlock), $t(f, g);
          },
          indent: function(f, d, m) {
            var g = f.state.vim, b = g.visualMode && d.repeat || 1;
            if (g.visualBlock) {
              for (var x = f.getOption("tabSize"), M = f.getOption("indentWithTabs") ? "	" : " ".repeat(x), A, E = m.length - 1; E >= 0; E--)
                if (A = zt(m[E].anchor, m[E].head), d.indentRight)
                  f.replaceRange(M.repeat(b), A, A);
                else {
                  for (var I = f.getLine(A.line), _ = 0, H = 0; H < b; H++) {
                    var j = I[A.ch + _];
                    if (j == "	")
                      _++;
                    else if (j == " ") {
                      _++;
                      for (var W = 1; W < M.length && (j = I[A.ch + _], j === " "); W++)
                        _++;
                    } else
                      break;
                  }
                  f.replaceRange("", A, dt(A, 0, _));
                }
              return A;
            } else if (f.indentMore)
              for (var H = 0; H < b; H++)
                d.indentRight ? f.indentMore() : f.indentLess();
            else {
              var $ = m[0].anchor.line, X = g.visualBlock ? m[m.length - 1].anchor.line : m[0].head.line;
              d.linewise && X--;
              for (var E = $; E <= X; E++)
                for (var H = 0; H < b; H++)
                  f.indentLine(E, d.indentRight);
            }
            return vn.moveToFirstNonWhiteSpaceCharacter(f, m[0].anchor);
          },
          indentAuto: function(f, d, m) {
            return f.execCommand("indentAuto"), vn.moveToFirstNonWhiteSpaceCharacter(f, m[0].anchor);
          },
          hardWrap: function(f, d, m, g) {
            if (!!f.hardWrap) {
              var b = m[0].anchor.line, x = m[0].head.line;
              d.linewise && x--;
              var M = f.hardWrap({
                from: b,
                to: x
              });
              return M > b && d.linewise && M--, d.keepCursor ? g : new e(M, 0);
            }
          },
          changeCase: function(f, d, m, g, b) {
            for (var x = f.getSelections(), M = [], A = d.toLower, E = 0; E < x.length; E++) {
              var I = x[E], _ = "";
              if (A === true)
                _ = I.toLowerCase();
              else if (A === false)
                _ = I.toUpperCase();
              else
                for (var H = 0; H < I.length; H++) {
                  var j = I.charAt(H);
                  _ += L(j) ? j.toLowerCase() : j.toUpperCase();
                }
              M.push(_);
            }
            return f.replaceSelections(M), d.shouldMoveCursor ? b : !f.state.vim.visualMode && d.linewise && m[0].anchor.line + 1 == m[0].head.line ? vn.moveToFirstNonWhiteSpaceCharacter(f, g) : d.linewise ? g : zt(m[0].anchor, m[0].head);
          },
          yank: function(f, d, m, g) {
            var b = f.state.vim, x = f.getSelection(), M = b.visualMode ? zt(b.sel.anchor, b.sel.head, m[0].head, m[0].anchor) : g;
            return V.registerController.pushText(d.registerName, "yank", x, d.linewise, b.visualBlock), M;
          },
          rot13: function(f, d, m, g, b) {
            for (var x = f.getSelections(), M = [], A = 0; A < x.length; A++) {
              const E = x[A].split("").map((I) => {
                const _ = I.charCodeAt(0);
                return _ >= 65 && _ <= 90 ? String.fromCharCode(65 + (_ - 65 + 13) % 26) : _ >= 97 && _ <= 122 ? String.fromCharCode(97 + (_ - 97 + 13) % 26) : I;
              }).join("");
              M.push(E);
            }
            return f.replaceSelections(M), d.shouldMoveCursor ? b : !f.state.vim.visualMode && d.linewise && m[0].anchor.line + 1 == m[0].head.line ? vn.moveToFirstNonWhiteSpaceCharacter(f, g) : d.linewise ? g : zt(m[0].anchor, m[0].head);
          }
        };
        function eg(f, d) {
          Js[f] = d;
        }
        var lo = {
          jumpListWalk: function(f, d, m) {
            if (!m.visualMode) {
              var g = d.repeat || 1, b = d.forward, x = V.jumpList, M = x.move(f, b ? g : -g), A = M ? M.find() : void 0;
              A = A || f.getCursor(), f.setCursor(A);
            }
          },
          scroll: function(f, d, m) {
            if (!m.visualMode) {
              var g = d.repeat || 1, b = f.defaultTextHeight(), x = f.getScrollInfo().top, M = b * g, A = d.forward ? x + M : x - M, E = ze(f.getCursor()), I = f.charCoords(E, "local");
              if (d.forward)
                A > I.top ? (E.line += (A - I.top) / b, E.line = Math.ceil(E.line), f.setCursor(E), I = f.charCoords(E, "local"), f.scrollTo(null, I.top)) : f.scrollTo(null, A);
              else {
                var _ = A + f.getScrollInfo().clientHeight;
                _ < I.bottom ? (E.line -= (I.bottom - _) / b, E.line = Math.floor(E.line), f.setCursor(E), I = f.charCoords(E, "local"), f.scrollTo(null, I.bottom - f.getScrollInfo().clientHeight)) : f.scrollTo(null, A);
              }
            }
          },
          scrollToCursor: function(f, d) {
            var m = f.getCursor().line, g = f.charCoords(new e(m, 0), "local"), b = f.getScrollInfo().clientHeight, x = g.top;
            switch (d.position) {
              case "center":
                x = g.bottom - b / 2;
                break;
              case "bottom":
                var M = new e(m, f.getLine(m).length - 1), A = f.charCoords(M, "local"), E = A.bottom - x;
                x = x - b + E;
                break;
            }
            f.scrollTo(null, x);
          },
          replayMacro: function(f, d, m) {
            var g = d.selectedCharacter || "", b = d.repeat || 1, x = V.macroModeState;
            for (g == "@" ? g = x.latestRegister || "" : x.latestRegister = g; b--; )
              us(f, m, x, g);
          },
          enterMacroRecordMode: function(f, d) {
            var m = V.macroModeState, g = d.selectedCharacter;
            V.registerController.isValidRegister(g) && m.enterMacroRecordMode(f, g);
          },
          toggleOverwrite: function(f) {
            f.state.overwrite ? (f.toggleOverwrite(false), f.setOption("keyMap", "vim-insert"), t.signal(f, "vim-mode-change", {
              mode: "insert"
            })) : (f.toggleOverwrite(true), f.setOption("keyMap", "vim-replace"), t.signal(f, "vim-mode-change", {
              mode: "replace"
            }));
          },
          enterInsertMode: function(f, d, m) {
            if (!f.getOption("readOnly")) {
              m.insertMode = true, m.insertModeRepeat = d && d.repeat || 1;
              var g = d ? d.insertAt : null, b = m.sel, x = d.head || f.getCursor("head"), M = f.listSelections().length;
              if (g == "eol")
                x = new e(x.line, bt(f, x.line));
              else if (g == "bol")
                x = new e(x.line, 0);
              else if (g == "charAfter") {
                var A = n(f, x, dt(x, 0, 1));
                x = A.end;
              } else if (g == "firstNonBlank") {
                var A = n(f, x, vn.moveToFirstNonWhiteSpaceCharacter(f, x));
                x = A.end;
              } else if (g == "startOfSelectedArea") {
                if (!m.visualMode)
                  return;
                m.visualBlock ? (x = new e(Math.min(b.head.line, b.anchor.line), Math.min(b.head.ch, b.anchor.ch)), M = Math.abs(b.head.line - b.anchor.line) + 1) : b.head.line < b.anchor.line ? x = b.head : x = new e(b.anchor.line, 0);
              } else if (g == "endOfSelectedArea") {
                if (!m.visualMode)
                  return;
                m.visualBlock ? (x = new e(Math.min(b.head.line, b.anchor.line), Math.max(b.head.ch, b.anchor.ch) + 1), M = Math.abs(b.head.line - b.anchor.line) + 1) : b.head.line >= b.anchor.line ? x = dt(b.head, 0, 1) : x = new e(b.anchor.line, 0);
              } else if (g == "inplace") {
                if (m.visualMode)
                  return;
              } else
                g == "lastEdit" && (x = Df(f) || x);
              f.setOption("disableInput", false), d && d.replace ? (f.toggleOverwrite(true), f.setOption("keyMap", "vim-replace"), t.signal(f, "vim-mode-change", {
                mode: "replace"
              })) : (f.toggleOverwrite(false), f.setOption("keyMap", "vim-insert"), t.signal(f, "vim-mode-change", {
                mode: "insert"
              })), V.macroModeState.isPlaying || (f.on("change", Vl), m.insertEnd && m.insertEnd.clear(), m.insertEnd = f.setBookmark(x, {
                insertLeft: true
              }), t.on(f.getInputField(), "keydown", Hl)), m.visualMode && ir(f), yf(f, x, M);
            }
          },
          toggleVisualMode: function(f, d, m) {
            var g = d.repeat, b = f.getCursor(), x;
            if (m.visualMode)
              m.visualLine != !!d.linewise || m.visualBlock != !!d.blockwise ? (m.visualLine = !!d.linewise, m.visualBlock = !!d.blockwise, t.signal(f, "vim-mode-change", {
                mode: "visual",
                subMode: m.visualLine ? "linewise" : m.visualBlock ? "blockwise" : ""
              }), co(f)) : ir(f);
            else {
              m.visualMode = true, m.visualLine = !!d.linewise, m.visualBlock = !!d.blockwise, x = $t(f, new e(b.line, b.ch + g - 1));
              var M = n(f, b, x);
              m.sel = {
                anchor: M.start,
                head: M.end
              }, t.signal(f, "vim-mode-change", {
                mode: "visual",
                subMode: m.visualLine ? "linewise" : m.visualBlock ? "blockwise" : ""
              }), co(f), En(f, m, "<", zt(b, x)), En(f, m, ">", Xr(b, x));
            }
          },
          reselectLastSelection: function(f, d, m) {
            var g = m.lastSelection;
            if (m.visualMode && rr(f, m), g) {
              var b = g.anchorMark.find(), x = g.headMark.find();
              if (!b || !x)
                return;
              m.sel = {
                anchor: b,
                head: x
              }, m.visualMode = true, m.visualLine = g.visualLine, m.visualBlock = g.visualBlock, co(f), En(f, m, "<", zt(b, x)), En(f, m, ">", Xr(b, x)), t.signal(f, "vim-mode-change", {
                mode: "visual",
                subMode: m.visualLine ? "linewise" : m.visualBlock ? "blockwise" : ""
              });
            }
          },
          joinLines: function(f, d, m) {
            var g, b;
            if (m.visualMode) {
              if (g = f.getCursor("anchor"), b = f.getCursor("head"), ct(b, g)) {
                var x = b;
                b = g, g = x;
              }
              b.ch = bt(f, b.line) - 1;
            } else {
              var M = Math.max(d.repeat, 2);
              g = f.getCursor(), b = $t(f, new e(g.line + M - 1, 1 / 0));
            }
            for (var A = 0, E = g.line; E < b.line; E++) {
              A = bt(f, g.line);
              var I = "", _ = 0;
              if (!d.keepSpaces) {
                var H = f.getLine(g.line + 1);
                _ = H.search(/\S/), _ == -1 ? _ = H.length : I = " ";
              }
              f.replaceRange(I, new e(g.line, A), new e(g.line + 1, _));
            }
            var j = $t(f, new e(g.line, A));
            m.visualMode && ir(f, false), f.setCursor(j);
          },
          newLineAndEnterInsertMode: function(f, d, m) {
            m.insertMode = true;
            var g = ze(f.getCursor());
            if (g.line === f.firstLine() && !d.after)
              f.replaceRange(`
`, new e(f.firstLine(), 0)), f.setCursor(f.firstLine(), 0);
            else {
              g.line = d.after ? g.line : g.line - 1, g.ch = bt(f, g.line), f.setCursor(g);
              var b = t.commands.newlineAndIndentContinueComment || t.commands.newlineAndIndent;
              b(f);
            }
            this.enterInsertMode(f, {
              repeat: d.repeat
            }, m);
          },
          paste: function(f, d, m) {
            var g = V.registerController.getRegister(d.registerName);
            if (d.registerName === "+")
              navigator.clipboard.readText().then((x) => {
                this.continuePaste(f, d, m, x, g);
              });
            else {
              var b = g.toString();
              this.continuePaste(f, d, m, b, g);
            }
          },
          continuePaste: function(f, d, m, g, b) {
            var x = ze(f.getCursor());
            if (!!g) {
              if (d.matchIndent) {
                var M = f.getOption("tabSize"), A = function(qt) {
                  var ar = qt.split("	").length - 1, fs = qt.split(" ").length - 1;
                  return ar * M + fs * 1;
                }, E = f.getLine(f.getCursor().line), I = A(E.match(/^\s*/)[0]), _ = g.replace(/\n$/, ""), H = g !== _, j = A(g.match(/^\s*/)[0]), g = _.replace(/^\s*/gm, function(qt) {
                  var ar = I + (A(qt) - j);
                  if (ar < 0)
                    return "";
                  if (f.getOption("indentWithTabs")) {
                    var fs = Math.floor(ar / M);
                    return Array(fs + 1).join("	");
                  } else
                    return Array(ar + 1).join(" ");
                });
                g += H ? `
` : "";
              }
              d.repeat > 1 && (g = Array(d.repeat + 1).join(g));
              var W = b.linewise, $ = b.blockwise, X = $ ? g.split(`
`) : void 0;
              if (X) {
                W && X.pop();
                for (var J = 0; J < X.length; J++)
                  X[J] = X[J] == "" ? " " : X[J];
                x.ch += d.after ? 1 : 0, x.ch = Math.min(bt(f, x.line), x.ch);
              } else
                W ? m.visualMode ? g = m.visualLine ? g.slice(0, -1) : `
` + g.slice(0, g.length - 1) + `
` : d.after ? (g = `
` + g.slice(0, g.length - 1), x.ch = bt(f, x.line)) : x.ch = 0 : x.ch += d.after ? 1 : 0;
              var xe;
              if (m.visualMode) {
                m.lastPastedText = g;
                var fe, Ae = ig(f), Le = Ae[0], Oe = Ae[1], ut = f.getSelection(), pt = f.listSelections(), Fe = new Array(pt.length).join("1").split("1");
                m.lastSelection && (fe = m.lastSelection.headMark.find()), V.registerController.unnamedRegister.setText(ut), $ ? (f.replaceSelections(Fe), Oe = new e(Le.line + g.length - 1, Le.ch), f.setCursor(Le), vf(f, Oe), f.replaceSelections(g), xe = Le) : m.visualBlock ? (f.replaceSelections(Fe), f.setCursor(Le), f.replaceRange(g, Le, Le), xe = Le) : (f.replaceRange(g, Le, Oe), xe = f.posFromIndex(f.indexFromPos(Le) + g.length - 1)), fe && (m.lastSelection.headMark = f.setBookmark(fe)), W && (xe.ch = 0);
              } else if ($ && X) {
                f.setCursor(x);
                for (var J = 0; J < X.length; J++) {
                  var Me = x.line + J;
                  Me > f.lastLine() && f.replaceRange(`
`, new e(Me, 0));
                  var et = bt(f, Me);
                  et < x.ch && ng(f, Me, x.ch);
                }
                f.setCursor(x), vf(f, new e(x.line + X.length - 1, x.ch)), f.replaceSelections(X), xe = x;
              } else if (f.replaceRange(g, x), W) {
                var Me = d.after ? x.line + 1 : x.line;
                xe = new e(Me, or(f.getLine(Me)));
              } else
                xe = ze(x), /\n/.test(g) || (xe.ch += g.length - (d.after ? 1 : 0));
              m.visualMode && ir(f, false), f.setCursor(xe);
            }
          },
          undo: function(f, d) {
            f.operation(function() {
              gf(f, t.commands.undo, d.repeat)(), f.setCursor($t(f, f.getCursor("start")));
            });
          },
          redo: function(f, d) {
            gf(f, t.commands.redo, d.repeat)();
          },
          setRegister: function(f, d, m) {
            m.inputState.registerName = d.selectedCharacter;
          },
          insertRegister: function(f, d, m) {
            var g = d.selectedCharacter, b = V.registerController.getRegister(g), x = b && b.toString();
            x && f.replaceSelection(x);
          },
          oneNormalCommand: function(f, d, m) {
            Qr(f, true), m.insertModeReturn = true, t.on(f, "vim-command-done", function g() {
              m.visualMode || (m.insertModeReturn && (m.insertModeReturn = false, m.insertMode || lo.enterInsertMode(f, {}, m)), t.off(f, "vim-command-done", g));
            });
          },
          setMark: function(f, d, m) {
            var g = d.selectedCharacter;
            g && En(f, m, g, f.getCursor());
          },
          replace: function(f, d, m) {
            var g = d.selectedCharacter || "", b = f.getCursor(), x, M, A = f.listSelections();
            if (m.visualMode)
              b = f.getCursor("start"), M = f.getCursor("end");
            else {
              var E = f.getLine(b.line);
              x = b.ch + d.repeat, x > E.length && (x = E.length), M = new e(b.line, x);
            }
            var I = n(f, b, M);
            if (b = I.start, M = I.end, g == `
`)
              m.visualMode || f.replaceRange("", b, M), (t.commands.newlineAndIndentContinueComment || t.commands.newlineAndIndent)(f);
            else {
              var _ = f.getRange(b, M);
              if (_ = _.replace(/[\uD800-\uDBFF][\uDC00-\uDFFF]/g, g), _ = _.replace(/[^\n]/g, g), m.visualBlock) {
                var H = new Array(f.getOption("tabSize") + 1).join(" ");
                _ = f.getSelection(), _ = _.replace(/[\uD800-\uDBFF][\uDC00-\uDFFF]/g, g);
                var j = _.replace(/\t/g, H).replace(/[^\n]/g, g).split(`
`);
                f.replaceSelections(j);
              } else
                f.replaceRange(_, b, M);
              m.visualMode ? (b = ct(A[0].anchor, A[0].head) ? A[0].anchor : A[0].head, f.setCursor(b), ir(f, false)) : f.setCursor(dt(M, 0, -1));
            }
          },
          incrementNumberToken: function(f, d) {
            for (var m = f.getCursor(), g = f.getLine(m.line), b = /(-?)(?:(0x)([\da-f]+)|(0b|0|)(\d+))/gi, x, M, A, E; (x = b.exec(g)) !== null && (M = x.index, A = M + x[0].length, !(m.ch < A)); )
              ;
            if (!(!d.backtrack && A <= m.ch)) {
              if (x) {
                var I = x[2] || x[4], _ = x[3] || x[5], H = d.increase ? 1 : -1, j = {
                  "0b": 2,
                  0: 8,
                  "": 10,
                  "0x": 16
                }[I.toLowerCase()], W = parseInt(x[1] + _, j) + H * d.repeat;
                E = W.toString(j);
                var $ = I ? new Array(_.length - E.length + 1 + x[1].length).join("0") : "";
                E.charAt(0) === "-" ? E = "-" + I + $ + E.substr(1) : E = I + $ + E;
                var X = new e(m.line, M), J = new e(m.line, A);
                f.replaceRange(E, X, J);
              } else
                return;
              f.setCursor(new e(m.line, M + E.length - 1));
            }
          },
          repeatLastEdit: function(f, d, m) {
            var g = m.lastEditInputState;
            if (!!g) {
              var b = d.repeat;
              b && d.repeatIsExplicit ? g.repeatOverride = b : b = g.repeatOverride || b, $f(f, m, b, false);
            }
          },
          indent: function(f, d) {
            f.indentLine(f.getCursor().line, d.indentRight);
          },
          exitInsertMode: function(f, d) {
            Qr(f);
          }
        };
        function Zs(f, d) {
          lo[f] = d;
        }
        function $t(f, d, m) {
          var g = f.state.vim, b = g.insertMode || g.visualMode, x = Math.min(Math.max(f.firstLine(), d.line), f.lastLine()), M = f.getLine(x), A = M.length - 1 + Number(!!b), E = Math.min(Math.max(0, d.ch), A), I = M.charCodeAt(E);
          if (56320 <= I && I <= 57343) {
            var _ = 1;
            m && m.line == x && m.ch > E && (_ = -1), E += _, E > A && (E -= 2);
          }
          return new e(x, E);
        }
        function os(f) {
          var d = {};
          for (var m in f)
            Object.prototype.hasOwnProperty.call(f, m) && (d[m] = f[m]);
          return d;
        }
        function dt(f, d, m) {
          return typeof d == "object" && (m = d.ch, d = d.line), new e(f.line + d, f.ch + m);
        }
        function pf(f, d, m, g) {
          g.operator && (m = "operatorPending");
          for (var b, x = [], M = [], A = re ? d.length - o : 0, E = A; E < d.length; E++) {
            var I = d[E];
            m == "insert" && I.context != "insert" || I.context && I.context != m || g.operator && I.type == "action" || !(b = mf(f, I.keys)) || (b == "partial" && x.push(I), b == "full" && M.push(I));
          }
          return {
            partial: x,
            full: M
          };
        }
        function mf(f, d) {
          const m = d.slice(-11) == "<character>", g = d.slice(-10) == "<register>";
          if (m || g) {
            var b = d.length - (m ? 11 : 10), x = f.slice(0, b), M = d.slice(0, b);
            return x == M && f.length > b ? "full" : M.indexOf(x) == 0 ? "partial" : false;
          } else
            return f == d ? "full" : d.indexOf(f) == 0 ? "partial" : false;
        }
        function tg(f) {
          var d = /^.*(<[^>]+>)$/.exec(f), m = d ? d[1] : f.slice(-1);
          if (m.length > 1)
            switch (m) {
              case "<CR>":
              case "<S-CR>":
                m = `
`;
                break;
              case "<Space>":
              case "<S-Space>":
                m = " ";
                break;
              default:
                m = "";
                break;
            }
          return m;
        }
        function gf(f, d, m) {
          return function() {
            for (var g = 0; g < m; g++)
              d(f);
          };
        }
        function ze(f) {
          return new e(f.line, f.ch);
        }
        function Kt(f, d) {
          return f.ch == d.ch && f.line == d.line;
        }
        function ct(f, d) {
          return f.line < d.line || f.line == d.line && f.ch < d.ch;
        }
        function zt(f, d) {
          return arguments.length > 2 && (d = zt.apply(void 0, Array.prototype.slice.call(arguments, 1))), ct(f, d) ? f : d;
        }
        function Xr(f, d) {
          return arguments.length > 2 && (d = Xr.apply(void 0, Array.prototype.slice.call(arguments, 1))), ct(f, d) ? d : f;
        }
        function Ll(f, d, m) {
          var g = ct(f, d), b = ct(d, m);
          return g && b;
        }
        function bt(f, d) {
          return f.getLine(d).length;
        }
        function Dl(f) {
          return f.trim ? f.trim() : f.replace(/^\s+|\s+$/g, "");
        }
        function Oi(f) {
          return f.replace(/([.?*+$\[\]\/\\(){}|\-])/g, "\\$1");
        }
        function ng(f, d, m) {
          var g = bt(f, d), b = new Array(m - g + 1).join(" ");
          f.setCursor(new e(d, g)), f.replaceRange(b, f.getCursor());
        }
        function vf(f, d) {
          var m = [], g = f.listSelections(), b = ze(f.clipPos(d)), x = !Kt(d, b), M = f.getCursor("head"), A = rg(g, M), E = Kt(g[A].head, g[A].anchor), I = g.length - 1, _ = I - A > A ? I : 0, H = g[_].anchor, j = Math.min(H.line, b.line), W = Math.max(H.line, b.line), $ = H.ch, X = b.ch, J = g[_].head.ch - $, xe = X - $;
          J > 0 && xe <= 0 ? ($++, x || X--) : J < 0 && xe >= 0 ? ($--, E || X++) : J < 0 && xe == -1 && ($--, X++);
          for (var fe = j; fe <= W; fe++) {
            var Ae = {
              anchor: new e(fe, $),
              head: new e(fe, X)
            };
            m.push(Ae);
          }
          return f.setSelections(m), d.ch = X, H.ch = $, H;
        }
        function yf(f, d, m) {
          for (var g = [], b = 0; b < m; b++) {
            var x = dt(d, b, 0);
            g.push({
              anchor: x,
              head: x
            });
          }
          f.setSelections(g, 0);
        }
        function rg(f, d, m) {
          for (var g = 0; g < f.length; g++) {
            var b = Kt(f[g].anchor, d), x = Kt(f[g].head, d);
            if (b || x)
              return g;
          }
          return -1;
        }
        function ig(f, d) {
          var m = f.listSelections(), g = m[0], b = m[m.length - 1], x = ct(g.anchor, g.head) ? g.anchor : g.head, M = ct(b.anchor, b.head) ? b.head : b.anchor;
          return [
            x,
            M
          ];
        }
        function rr(f, d) {
          var m = d.sel.anchor, g = d.sel.head;
          d.lastPastedText && (g = f.posFromIndex(f.indexFromPos(m) + d.lastPastedText.length), d.lastPastedText = void 0), d.lastSelection = {
            anchorMark: f.setBookmark(m),
            headMark: f.setBookmark(g),
            anchor: ze(m),
            head: ze(g),
            visualMode: d.visualMode,
            visualLine: d.visualLine,
            visualBlock: d.visualBlock
          };
        }
        function og(f, d, m, g) {
          var b = f.state.vim.sel, x = g ? d : b.head, M = g ? d : b.anchor, A;
          return ct(m, d) && (A = m, m = d, d = A), ct(x, M) ? (x = zt(d, x), M = Xr(M, m)) : (M = zt(d, M), x = Xr(x, m), x = dt(x, 0, -1), x.ch == -1 && x.line != f.firstLine() && (x = new e(x.line - 1, bt(f, x.line - 1)))), [
            M,
            x
          ];
        }
        function co(f, d, m) {
          var g = f.state.vim;
          d = d || g.sel, m || (m = g.visualLine ? "line" : g.visualBlock ? "block" : "char");
          var b = _l2(f, d, m);
          f.setSelections(b.ranges, b.primary);
        }
        function _l2(f, d, m, g) {
          var b = ze(d.head), x = ze(d.anchor);
          if (m == "char") {
            var M = !g && !ct(d.head, d.anchor) ? 1 : 0, A = ct(d.head, d.anchor) ? 1 : 0;
            return b = dt(d.head, 0, M), x = dt(d.anchor, 0, A), {
              ranges: [
                {
                  anchor: x,
                  head: b
                }
              ],
              primary: 0
            };
          } else if (m == "line") {
            if (ct(d.head, d.anchor))
              b.ch = 0, x.ch = bt(f, x.line);
            else {
              x.ch = 0;
              var E = f.lastLine();
              b.line > E && (b.line = E), b.ch = bt(f, b.line);
            }
            return {
              ranges: [
                {
                  anchor: x,
                  head: b
                }
              ],
              primary: 0
            };
          } else if (m == "block") {
            var I = Math.min(x.line, b.line), _ = x.ch, H = Math.max(x.line, b.line), j = b.ch;
            _ < j ? j += 1 : _ += 1;
            for (var W = H - I + 1, $ = b.line == I ? 0 : W - 1, X = [], J = 0; J < W; J++)
              X.push({
                anchor: new e(I + J, _),
                head: new e(I + J, j)
              });
            return {
              ranges: X,
              primary: $
            };
          }
          throw "never happens";
        }
        function sg(f) {
          var d = f.getCursor("head");
          return f.getSelection().length == 1 && (d = zt(d, f.getCursor("anchor"))), d;
        }
        function ir(f, d) {
          var m = f.state.vim;
          d !== false && f.setCursor($t(f, m.sel.head)), rr(f, m), m.visualMode = false, m.visualLine = false, m.visualBlock = false, m.insertMode || t.signal(f, "vim-mode-change", {
            mode: "normal"
          });
        }
        function uo(f, d, m) {
          var g = f.getRange(d, m);
          if (/\n\s*$/.test(g)) {
            var b = g.split(`
`);
            b.pop();
            for (var x = b.pop(); b.length > 0 && x && D(x); x = b.pop())
              m.line--, m.ch = 0;
            x ? (m.line--, m.ch = bt(f, m.line)) : m.ch = 0;
          }
        }
        function ag(f, d, m) {
          d.ch = 0, m.ch = 0, m.line++;
        }
        function or(f) {
          if (!f)
            return 0;
          var d = f.search(/\S/);
          return d == -1 ? f.length : d;
        }
        function Il(f, { inclusive: d, innerWord: m, bigWord: g, noSymbol: b, multiline: x }, M) {
          var A = M || sg(f), E = f.getLine(A.line), I = E, _ = A.line, H = _, j = A.ch, W, $ = b ? p[0] : v[0];
          if (m && /\s/.test(E.charAt(j)))
            $ = function(Le) {
              return /\s/.test(Le);
            };
          else {
            for (; !$(E.charAt(j)); )
              if (j++, j >= E.length) {
                if (!x)
                  return null;
                j--, W = Sf(f, A, true, g, true);
                break;
              }
            g ? $ = v[0] : ($ = p[0], $(E.charAt(j)) || ($ = p[1]));
          }
          for (var X = j, J = j; $(E.charAt(J)) && J >= 0; )
            J--;
          if (J++, W)
            X = W.to, H = W.line, I = f.getLine(H), !I && X == 0 && X++;
          else
            for (; $(E.charAt(X)) && X < E.length; )
              X++;
          if (d) {
            var xe = X, fe = A.ch <= J && /\s/.test(E.charAt(A.ch));
            if (!fe)
              for (; /\s/.test(I.charAt(X)) && X < I.length; )
                X++;
            if (xe == X || fe) {
              for (var Ae = J; /\s/.test(E.charAt(J - 1)) && J > 0; )
                J--;
              !J && !fe && (J = Ae);
            }
          }
          return {
            start: new e(_, J),
            end: new e(H, X)
          };
        }
        function lg(f, d, m) {
          var g = d;
          if (!t.findMatchingTag || !t.findEnclosingTag)
            return {
              start: g,
              end: g
            };
          var b = t.findMatchingTag(f, d) || t.findEnclosingTag(f, d);
          return !b || !b.open || !b.close ? {
            start: g,
            end: g
          } : m ? {
            start: b.open.from,
            end: b.close.to
          } : {
            start: b.open.to,
            end: b.close.from
          };
        }
        function bf(f, d, m) {
          Kt(d, m) || V.jumpList.add(f, d, m);
        }
        function Ri(f, d) {
          V.lastCharacterSearch.increment = f, V.lastCharacterSearch.forward = d.forward, V.lastCharacterSearch.selectedCharacter = d.selectedCharacter;
        }
        var cg = {
          "(": "bracket",
          ")": "bracket",
          "{": "bracket",
          "}": "bracket",
          "[": "section",
          "]": "section",
          "*": "comment",
          "/": "comment",
          m: "method",
          M: "method",
          "#": "preprocess"
        }, xf = {
          bracket: {
            isComplete: function(f) {
              if (f.nextCh === f.symb) {
                if (f.depth++, f.depth >= 1)
                  return true;
              } else
                f.nextCh === f.reverseSymb && f.depth--;
              return false;
            }
          },
          section: {
            init: function(f) {
              f.curMoveThrough = true, f.symb = (f.forward ? "]" : "[") === f.symb ? "{" : "}";
            },
            isComplete: function(f) {
              return f.index === 0 && f.nextCh === f.symb;
            }
          },
          comment: {
            isComplete: function(f) {
              var d = f.lastCh === "*" && f.nextCh === "/";
              return f.lastCh = f.nextCh, d;
            }
          },
          method: {
            init: function(f) {
              f.symb = f.symb === "m" ? "{" : "}", f.reverseSymb = f.symb === "{" ? "}" : "{";
            },
            isComplete: function(f) {
              return f.nextCh === f.symb;
            }
          },
          preprocess: {
            init: function(f) {
              f.index = 0;
            },
            isComplete: function(f) {
              var _a3;
              if (f.nextCh === "#") {
                var d = (_a3 = f.lineText.match(/^#(\w+)/)) == null ? void 0 : _a3[1];
                if (d === "endif") {
                  if (f.forward && f.depth === 0)
                    return true;
                  f.depth++;
                } else if (d === "if") {
                  if (!f.forward && f.depth === 0)
                    return true;
                  f.depth--;
                }
                if (d === "else" && f.depth === 0)
                  return true;
              }
              return false;
            }
          }
        };
        function ug(f, d, m, g) {
          var b = ze(f.getCursor()), x = m ? 1 : -1, M = m ? f.lineCount() : -1, A = b.ch, E = b.line, I = f.getLine(E), _ = {
            lineText: I,
            nextCh: I.charAt(A),
            lastCh: null,
            index: A,
            symb: g,
            reverseSymb: (m ? {
              ")": "(",
              "}": "{"
            } : {
              "(": ")",
              "{": "}"
            })[g],
            forward: m,
            depth: 0,
            curMoveThrough: false
          }, H = cg[g];
          if (!H)
            return b;
          var j = xf[H].init, W = xf[H].isComplete;
          for (j && j(_); E !== M && d; ) {
            if (_.index += x, _.nextCh = _.lineText.charAt(_.index), !_.nextCh) {
              if (E += x, _.lineText = f.getLine(E) || "", x > 0)
                _.index = 0;
              else {
                var $ = _.lineText.length;
                _.index = $ > 0 ? $ - 1 : 0;
              }
              _.nextCh = _.lineText.charAt(_.index);
            }
            W(_) && (b.line = E, b.ch = _.index, d--);
          }
          return _.nextCh || _.curMoveThrough ? new e(E, _.index) : b;
        }
        function Sf(f, d, m, g, b) {
          var x = d.line, M = d.ch, A = f.getLine(x), E = m ? 1 : -1, I = g ? v : p;
          if (b && A == "") {
            if (x += E, A = f.getLine(x), !k(f, x))
              return null;
            M = m ? 0 : A.length;
          }
          for (; ; ) {
            if (b && A == "")
              return {
                from: 0,
                to: 0,
                line: x
              };
            for (var _ = E > 0 ? A.length : -1, H = _, j = _; M != _; ) {
              for (var W = false, $ = 0; $ < I.length && !W; ++$)
                if (I[$](A.charAt(M))) {
                  for (H = M; M != _ && I[$](A.charAt(M)); )
                    M += E;
                  if (j = M, W = H != j, H == d.ch && x == d.line && j == H + E)
                    continue;
                  return {
                    from: Math.min(H, j + 1),
                    to: Math.max(H, j),
                    line: x
                  };
                }
              W || (M += E);
            }
            if (x += E, !k(f, x))
              return null;
            A = f.getLine(x), M = E > 0 ? 0 : A.length;
          }
        }
        function fg(f, d, m, g, b, x) {
          var M = ze(d), A = [];
          (g && !b || !g && b) && m++;
          for (var E = !(g && b), I = 0; I < m; I++) {
            var _ = Sf(f, d, g, x, E);
            if (!_) {
              var H = bt(f, f.lastLine());
              A.push(g ? {
                line: f.lastLine(),
                from: H,
                to: H
              } : {
                line: 0,
                from: 0,
                to: 0
              });
              break;
            }
            A.push(_), d = new e(_.line, g ? _.to - 1 : _.from);
          }
          var j = A.length != m, W = A[0], $ = A.pop();
          return g && !b ? (!j && (W.from != M.ch || W.line != M.line) && ($ = A.pop()), $ && new e($.line, $.from)) : g && b ? $ && new e($.line, $.to - 1) : !g && b ? (!j && (W.to != M.ch || W.line != M.line) && ($ = A.pop()), $ && new e($.line, $.to)) : $ && new e($.line, $.from);
        }
        function wf(f, d, m, g, b) {
          var x = d, M = new e(x.line + m.repeat - 1, 1 / 0), A = f.clipPos(M);
          return A.ch--, b || (g.lastHPos = 1 / 0, g.lastHSPos = f.charCoords(A, "div").left), M;
        }
        function ss(f, d, m, g, b) {
          if (!!g) {
            for (var x = b || f.getCursor(), M = x.ch, A, E = 0; E < d; E++) {
              var I = f.getLine(x.line);
              if (A = Bl(M, I, g, m), A == -1)
                return;
              M = A;
            }
            if (A != null)
              return new e(f.getCursor().line, A);
          }
        }
        function hg(f, d) {
          var m = f.getCursor().line;
          return $t(f, new e(m, d - 1));
        }
        function En(f, d, m, g) {
          !K(m, y) && !C.test(m) || (d.marks[m] && d.marks[m].clear(), d.marks[m] = f.setBookmark(g));
        }
        function Bl(f, d, m, g, b) {
          var x;
          return g ? x = d.indexOf(m, f + 1) : x = d.lastIndexOf(m, f - 1), x;
        }
        function kf(f, d, m, g, b) {
          var x = d.line, M = f.firstLine(), A = f.lastLine(), E, I, _ = x;
          function H(J) {
            return !f.getLine(J);
          }
          function j(J, xe, fe) {
            return fe ? H(J) != H(J + xe) : !H(J) && H(J + xe);
          }
          if (g) {
            for (; M <= _ && _ <= A && m > 0; )
              j(_, g) && m--, _ += g;
            return {
              start: new e(_, 0),
              end: d
            };
          }
          var W = f.state.vim;
          if (W.visualLine && j(x, 1, true)) {
            var $ = W.sel.anchor;
            j($.line, -1, true) && (!b || $.line != x) && (x += 1);
          }
          var X = H(x);
          for (_ = x; _ <= A && m; _++)
            j(_, 1, true) && (!b || H(_) != X) && m--;
          for (I = new e(_, 0), _ > A && !X ? X = true : b = false, _ = x; _ > M && !((!b || H(_) == X || _ == x) && j(_, -1, true)); _--)
            ;
          return E = new e(_, 0), {
            start: E,
            end: I
          };
        }
        function as(f, d, m, g, b) {
          function x(I) {
            I.line !== null && (I.pos + I.dir < 0 || I.pos + I.dir >= I.line.length ? I.line = null : I.pos += I.dir);
          }
          function M(I, _, H, j) {
            var W = I.getLine(_), $ = {
              line: W,
              ln: _,
              pos: H,
              dir: j
            };
            if ($.line === "")
              return {
                ln: $.ln,
                pos: $.pos
              };
            var X = $.pos;
            for (x($); $.line !== null; ) {
              if (X = $.pos, F($.line[$.pos]))
                if (b) {
                  for (x($); $.line !== null && D($.line[$.pos]); )
                    X = $.pos, x($);
                  return {
                    ln: $.ln,
                    pos: X + 1
                  };
                } else
                  return {
                    ln: $.ln,
                    pos: $.pos + 1
                  };
              x($);
            }
            return {
              ln: $.ln,
              pos: X + 1
            };
          }
          function A(I, _, H, j) {
            var W = I.getLine(_), $ = {
              line: W,
              ln: _,
              pos: H,
              dir: j
            };
            if ($.line === "")
              return {
                ln: $.ln,
                pos: $.pos
              };
            var X = $.pos;
            for (x($); $.line !== null; ) {
              if (!D($.line[$.pos]) && !F($.line[$.pos]))
                X = $.pos;
              else if (F($.line[$.pos]))
                return b ? D($.line[$.pos + 1]) ? {
                  ln: $.ln,
                  pos: $.pos + 1
                } : {
                  ln: $.ln,
                  pos: X
                } : {
                  ln: $.ln,
                  pos: X
                };
              x($);
            }
            return $.line = W, b && D($.line[$.pos]) ? {
              ln: $.ln,
              pos: $.pos
            } : {
              ln: $.ln,
              pos: X
            };
          }
          for (var E = {
            ln: d.line,
            pos: d.ch
          }; m > 0; )
            g < 0 ? E = A(f, E.ln, E.pos, g) : E = M(f, E.ln, E.pos, g), m--;
          return new e(E.ln, E.pos);
        }
        function Cf(f, d, m, g) {
          function b(E, I) {
            if (I.line !== null)
              if (I.pos + I.dir < 0 || I.pos + I.dir >= I.line.length) {
                if (I.ln += I.dir, !k(E, I.ln)) {
                  I.line = null;
                  return;
                }
                I.line = E.getLine(I.ln), I.pos = I.dir > 0 ? 0 : I.line.length - 1;
              } else
                I.pos += I.dir;
          }
          function x(E, I, _, H) {
            var J = E.getLine(I), j = J === "", W = {
              line: J,
              ln: I,
              pos: _,
              dir: H
            }, $ = {
              ln: W.ln,
              pos: W.pos
            }, X = W.line === "";
            for (b(E, W); W.line !== null; ) {
              if ($.ln = W.ln, $.pos = W.pos, W.line === "" && !X)
                return {
                  ln: W.ln,
                  pos: W.pos
                };
              if (j && W.line !== "" && !D(W.line[W.pos]))
                return {
                  ln: W.ln,
                  pos: W.pos
                };
              F(W.line[W.pos]) && !j && (W.pos === W.line.length - 1 || D(W.line[W.pos + 1])) && (j = true), b(E, W);
            }
            var J = E.getLine($.ln);
            $.pos = 0;
            for (var xe = J.length - 1; xe >= 0; --xe)
              if (!D(J[xe])) {
                $.pos = xe;
                break;
              }
            return $;
          }
          function M(E, I, _, H) {
            var J = E.getLine(I), j = {
              line: J,
              ln: I,
              pos: _,
              dir: H
            }, W = j.ln, $ = null, X = j.line === "";
            for (b(E, j); j.line !== null; ) {
              if (j.line === "" && !X)
                return $ !== null ? {
                  ln: W,
                  pos: $
                } : {
                  ln: j.ln,
                  pos: j.pos
                };
              if (F(j.line[j.pos]) && $ !== null && !(j.ln === W && j.pos + 1 === $))
                return {
                  ln: W,
                  pos: $
                };
              j.line !== "" && !D(j.line[j.pos]) && (X = false, W = j.ln, $ = j.pos), b(E, j);
            }
            var J = E.getLine(W);
            $ = 0;
            for (var xe = 0; xe < J.length; ++xe)
              if (!D(J[xe])) {
                $ = xe;
                break;
              }
            return {
              ln: W,
              pos: $
            };
          }
          for (var A = {
            ln: d.line,
            pos: d.ch
          }; m > 0; )
            g < 0 ? A = M(f, A.ln, A.pos, g) : A = x(f, A.ln, A.pos, g), m--;
          return new e(A.ln, A.pos);
        }
        function Tf(f, d, m, g) {
          var b = d, x = {
            "(": /[()]/,
            ")": /[()]/,
            "[": /[[\]]/,
            "]": /[[\]]/,
            "{": /[{}]/,
            "}": /[{}]/,
            "<": /[<>]/,
            ">": /[<>]/
          }[m], M = {
            "(": "(",
            ")": "(",
            "[": "[",
            "]": "[",
            "{": "{",
            "}": "{",
            "<": "<",
            ">": "<"
          }[m], A = f.getLine(b.line).charAt(b.ch), E = A === M ? 1 : 0, I = f.scanForBracket(new e(b.line, b.ch + E), -1, void 0, {
            bracketRegex: x
          }), _ = f.scanForBracket(new e(b.line, b.ch + E), 1, void 0, {
            bracketRegex: x
          });
          if (!I || !_)
            return null;
          var H = I.pos, j = _.pos;
          if (H.line == j.line && H.ch > j.ch || H.line > j.line) {
            var W = H;
            H = j, j = W;
          }
          return g ? j.ch += 1 : H.ch += 1, {
            start: H,
            end: j
          };
        }
        function dg(f, d, m, g) {
          var b = ze(d), x = f.getLine(b.line), M = x.split(""), A, E, I, _, H = M.indexOf(m);
          if (b.ch < H)
            b.ch = H;
          else if (H < b.ch && M[b.ch] == m) {
            var j = /string/.test(f.getTokenTypeAt(dt(d, 0, 1))), W = /string/.test(f.getTokenTypeAt(d)), $ = j && !W;
            $ || (E = b.ch, --b.ch);
          }
          if (M[b.ch] == m && !E)
            A = b.ch + 1;
          else
            for (I = b.ch; I > -1 && !A; I--)
              M[I] == m && (A = I + 1);
          if (A && !E)
            for (I = A, _ = M.length; I < _ && !E; I++)
              M[I] == m && (E = I);
          return !A || !E ? {
            start: b,
            end: b
          } : (g && (--A, ++E), {
            start: new e(b.line, A),
            end: new e(b.line, E)
          });
        }
        te("pcre", true, "boolean");
        class pg {
          constructor() {
            this.highlightTimeout;
          }
          getQuery() {
            return V.query;
          }
          setQuery(d) {
            V.query = d;
          }
          getOverlay() {
            return this.searchOverlay;
          }
          setOverlay(d) {
            this.searchOverlay = d;
          }
          isReversed() {
            return V.isReversed;
          }
          setReversed(d) {
            V.isReversed = d;
          }
          getScrollbarAnnotate() {
            return this.annotate;
          }
          setScrollbarAnnotate(d) {
            this.annotate = d;
          }
        }
        function Pn(f) {
          var d = f.state.vim;
          return d.searchState_ || (d.searchState_ = new pg());
        }
        function mg(f) {
          return Mf(f, "/");
        }
        function gg(f) {
          return Af(f, "/");
        }
        function Mf(f, d) {
          var m = Af(f, d) || [];
          if (!m.length)
            return [];
          var g = [];
          if (m[0] === 0) {
            for (var b = 0; b < m.length; b++)
              typeof m[b] == "number" && g.push(f.substring(m[b] + 1, m[b + 1]));
            return g;
          }
        }
        function Af(f, d) {
          d || (d = "/");
          for (var m = false, g = [], b = 0; b < f.length; b++) {
            var x = f.charAt(b);
            !m && x == d && g.push(b), m = !m && x == "\\";
          }
          return g;
        }
        function vg(f) {
          var d = {
            V: "|(){+?*.[$^",
            M: "|(){+?*.[",
            m: "|(){+?",
            v: "<>"
          }, m = {
            ">": "(?<=[\\w])(?=[^\\w]|$)",
            "<": "(?<=[^\\w]|^)(?=[\\w])"
          }, g = d.m, b = f.replace(/\\.|[\[|(){+*?.$^<>]/g, function(M) {
            if (M[0] === "\\") {
              var A = M[1];
              return A === "}" || g.indexOf(A) != -1 ? A : A in d ? (g = d[A], "") : A in m ? m[A] : M;
            } else
              return g.indexOf(M) != -1 ? m[M] || "\\" + M : M;
          }), x = b.indexOf("\\zs");
          return x != -1 && (b = "(?<=" + b.slice(0, x) + ")" + b.slice(x + 3)), x = b.indexOf("\\ze"), x != -1 && (b = b.slice(0, x) + "(?=" + b.slice(x + 3) + ")"), b;
        }
        var Ef = {
          "\\n": `
`,
          "\\r": "\r",
          "\\t": "	"
        };
        function yg(f) {
          for (var d = false, m = [], g = -1; g < f.length; g++) {
            var b = f.charAt(g) || "", x = f.charAt(g + 1) || "";
            Ef[b + x] ? (m.push(Ef[b + x]), g++) : d ? (m.push(b), d = false) : b === "\\" ? (d = true, R(x) || x === "$" ? m.push("$") : x !== "/" && x !== "\\" && m.push("\\")) : (b === "$" && m.push("$"), m.push(b), x === "/" && m.push("\\"));
          }
          return m.join("");
        }
        var Pf = {
          "\\/": "/",
          "\\\\": "\\",
          "\\n": `
`,
          "\\r": "\r",
          "\\t": "	",
          "\\&": "&"
        };
        function bg(f) {
          for (var d = new t.StringStream(f), m = []; !d.eol(); ) {
            for (; d.peek() && d.peek() != "\\"; )
              m.push(d.next());
            var g = false;
            for (var b in Pf)
              if (d.match(b, true)) {
                g = true, m.push(Pf[b]);
                break;
              }
            g || m.push(d.next());
          }
          return m.join("");
        }
        function Of(f, d, m) {
          var g = V.registerController.getRegister("/");
          g.setText(f);
          var b = gg(f), x, M;
          if (!b.length)
            x = f;
          else {
            x = f.substring(0, b[0]);
            var A = f.substring(b[0]);
            M = A.indexOf("i") != -1;
          }
          if (!x)
            return null;
          ue("pcre") || (x = vg(x)), m && (d = /^[^A-Z]*$/.test(x));
          var E = new RegExp(x, d || M ? "im" : "m");
          return E;
        }
        function on(f) {
          typeof f == "string" && (f = document.createElement(f));
          for (var d = 1; d < arguments.length; d++) {
            var m = arguments[d];
            if (!!m)
              if (typeof m != "object" && (m = document.createTextNode(m)), m.nodeType)
                f.appendChild(m);
              else
                for (var g in m)
                  !Object.prototype.hasOwnProperty.call(m, g) || (g[0] === "$" ? f.style[g.slice(1)] = m[g] : typeof m[g] == "function" ? f[g] = m[g] : f.setAttribute(g, m[g]));
          }
          return f;
        }
        function _e2(f, d, m) {
          var g = on("div", {
            $color: "red",
            $whiteSpace: "pre",
            class: "cm-vim-message"
          }, d);
          f.openNotification ? m ? (g = on("div", {}, g, on("div", {}, "Press ENTER or type command to continue")), f.state.closeVimNotification && f.state.closeVimNotification(), f.state.closeVimNotification = f.openNotification(g, {
            bottom: true,
            duration: 0
          })) : f.openNotification(g, {
            bottom: true,
            duration: 15e3
          }) : alert(g.innerText);
        }
        function xg(f, d) {
          return on("div", {
            $display: "flex",
            $flex: 1
          }, on("span", {
            $fontFamily: "monospace",
            $whiteSpace: "pre",
            $flex: 1,
            $display: "flex"
          }, f, on("input", {
            type: "text",
            autocorrect: "off",
            autocapitalize: "off",
            spellcheck: "false",
            $flex: 1
          })), d && on("span", {
            $color: "#888"
          }, d));
        }
        function ea(f, d) {
          var _a3;
          if (se.length) {
            d.value || (d.value = ""), oe = d;
            return;
          }
          var m = xg(d.prefix, d.desc);
          if (f.openDialog)
            f.openDialog(m, d.onClose, {
              onKeyDown: d.onKeyDown,
              onKeyUp: d.onKeyUp,
              bottom: true,
              selectValueOnOpen: false,
              value: d.value
            });
          else {
            var g = "";
            typeof d.prefix != "string" && d.prefix && (g += d.prefix.textContent), d.desc && (g += " " + d.desc), (_a3 = d.onClose) == null ? void 0 : _a3.call(d, prompt(g, ""));
          }
        }
        function Rf(f, d) {
          return f instanceof RegExp && d instanceof RegExp ? f.flags == d.flags && f.source == d.source : false;
        }
        function ls(f, d, m, g) {
          if (!!d) {
            var b = Pn(f), x = Of(d, !!m, !!g);
            if (!!x)
              return ta(f, x), Rf(x, b.getQuery()) || b.setQuery(x), x;
          }
        }
        function Sg(f) {
          if (f.source.charAt(0) == "^")
            var d = true;
          return {
            token: function(m) {
              if (d && !m.sol()) {
                m.skipToEnd();
                return;
              }
              var g = m.match(f, false);
              if (g)
                return g[0].length == 0 ? (m.next(), "searching") : !m.sol() && (m.backUp(1), !f.exec(m.next() + g[0])) ? (m.next(), null) : (m.match(f), "searching");
              for (; !m.eol() && (m.next(), !m.match(f, false)); )
                ;
            },
            query: f
          };
        }
        var cs = 0;
        function ta(f, d) {
          clearTimeout(cs);
          var m = Pn(f);
          m.highlightTimeout = cs, cs = setTimeout(function() {
            if (!!f.state.vim) {
              var g = Pn(f);
              g.highlightTimeout = void 0;
              var b = g.getOverlay();
              (!b || d != b.query) && (b && f.removeOverlay(b), b = Sg(d), f.addOverlay(b), f.showMatchesOnScrollbar && (g.getScrollbarAnnotate() && g.getScrollbarAnnotate().clear(), g.setScrollbarAnnotate(f.showMatchesOnScrollbar(d))), g.setOverlay(b));
            }
          }, 50);
        }
        function Lf(f, d, m, g) {
          return f.operation(function() {
            g === void 0 && (g = 1);
            for (var b = f.getCursor(), x = f.getSearchCursor(m, b), M = 0; M < g; M++) {
              var A = x.find(d);
              if (M == 0 && A && Kt(x.from(), b)) {
                var E = d ? x.from() : x.to();
                A = x.find(d), A && !A[0] && Kt(x.from(), E) && f.getLine(E.line).length == E.ch && (A = x.find(d));
              }
              if (!A && (x = f.getSearchCursor(m, d ? new e(f.lastLine()) : new e(f.firstLine(), 0)), !x.find(d)))
                return;
            }
            return x.from();
          });
        }
        function wg(f, d, m, g, b) {
          return f.operation(function() {
            g === void 0 && (g = 1);
            var x = f.getCursor(), M = f.getSearchCursor(m, x), A = M.find(!d);
            !b.visualMode && A && Kt(M.from(), x) && M.find(!d);
            for (var E = 0; E < g; E++)
              if (A = M.find(d), !A && (M = f.getSearchCursor(m, d ? new e(f.lastLine()) : new e(f.firstLine(), 0)), !M.find(d)))
                return;
            var I = M.from(), _ = M.to();
            return I && _ && [
              I,
              _
            ];
          });
        }
        function fo(f) {
          var d = Pn(f);
          d.highlightTimeout && (clearTimeout(d.highlightTimeout), d.highlightTimeout = void 0), f.removeOverlay(Pn(f).getOverlay()), d.setOverlay(null), d.getScrollbarAnnotate() && (d.getScrollbarAnnotate().clear(), d.setScrollbarAnnotate(null));
        }
        function Nl(f, d, m) {
          return typeof f != "number" && (f = f.line), d instanceof Array ? K(f, d) : typeof m == "number" ? f >= d && f <= m : f == d;
        }
        function $l(f) {
          var d = f.getScrollInfo(), m = 6, g = 10, b = f.coordsChar({
            left: 0,
            top: m + d.top
          }, "local"), x = d.clientHeight - g + d.top, M = f.coordsChar({
            left: 0,
            top: x
          }, "local");
          return {
            top: b.line,
            bottom: M.line
          };
        }
        function na(f, d, m) {
          if (m == "'" || m == "`")
            return V.jumpList.find(f, -1) || new e(0, 0);
          if (m == ".")
            return Df(f);
          var g = d.marks[m];
          return g && g.find();
        }
        function Df(f) {
          if (f.getLastEditEnd)
            return f.getLastEditEnd();
          for (var d = f.doc.history.done, m = d.length; m--; )
            if (d[m].changes)
              return ze(d[m].changes[0].to);
        }
        class ra {
          constructor() {
            this.commandMap_, this.buildCommandMap_();
          }
          processCommand(d, m, g) {
            var b = this;
            d.operation(function() {
              d.curOp && (d.curOp.isVimOp = true), b._processCommand(d, m, g);
            });
          }
          _processCommand(d, m, g) {
            var b = d.state.vim, x = V.registerController.getRegister(":"), M = x.toString(), A = new t.StringStream(m);
            x.setText(m);
            var E = g || {};
            E.input = m;
            try {
              this.parseInput_(d, A, E);
            } catch (H) {
              throw _e2(d, H + ""), H;
            }
            b.visualMode && ir(d);
            var I, _;
            if (!E.commandName)
              E.line !== void 0 && (_ = "move");
            else if (I = this.matchCommand_(E.commandName), I) {
              if (_ = I.name, I.excludeFromCommandHistory && x.setText(M), this.parseCommandArgs_(A, E, I), I.type == "exToKey") {
                yt(d, I.toKeys || "", I);
                return;
              } else if (I.type == "exToEx") {
                this.processCommand(d, I.toInput || "");
                return;
              }
            }
            if (!_) {
              _e2(d, 'Not an editor command ":' + m + '"');
              return;
            }
            try {
              ia[_](d, E), (!I || !I.possiblyAsync) && E.callback && E.callback();
            } catch (H) {
              throw _e2(d, H + ""), H;
            }
          }
          parseInput_(d, m, g) {
            var _a3, _b3;
            m.eatWhile(":"), m.eat("%") ? (g.line = d.firstLine(), g.lineEnd = d.lastLine()) : (g.line = this.parseLineSpec_(d, m), g.line !== void 0 && m.eat(",") && (g.lineEnd = this.parseLineSpec_(d, m))), g.line == null ? d.state.vim.visualMode ? (g.selectionLine = (_a3 = na(d, d.state.vim, "<")) == null ? void 0 : _a3.line, g.selectionLineEnd = (_b3 = na(d, d.state.vim, ">")) == null ? void 0 : _b3.line) : g.selectionLine = d.getCursor().line : (g.selectionLine = g.line, g.selectionLineEnd = g.lineEnd);
            var b = m.match(/^(\w+|!!|@@|[!#&*<=>@~])/);
            return b ? g.commandName = b[1] : g.commandName = (m.match(/.*/) || [
              ""
            ])[0], g;
          }
          parseLineSpec_(d, m) {
            var g = m.match(/^(\d+)/);
            if (g)
              return parseInt(g[1], 10) - 1;
            switch (m.next()) {
              case ".":
                return this.parseLineSpecOffset_(m, d.getCursor().line);
              case "$":
                return this.parseLineSpecOffset_(m, d.lastLine());
              case "'":
                var b = m.next() || "", x = na(d, d.state.vim, b);
                if (!x)
                  throw new Error("Mark not set");
                return this.parseLineSpecOffset_(m, x.line);
              case "-":
              case "+":
                return m.backUp(1), this.parseLineSpecOffset_(m, d.getCursor().line);
              default:
                m.backUp(1);
                return;
            }
          }
          parseLineSpecOffset_(d, m) {
            var g = d.match(/^([+-])?(\d+)/);
            if (g) {
              var b = parseInt(g[2], 10);
              g[1] == "-" ? m -= b : m += b;
            }
            return m;
          }
          parseCommandArgs_(d, m, g) {
            var _a3;
            if (!d.eol()) {
              m.argString = (_a3 = d.match(/.*/)) == null ? void 0 : _a3[0];
              var b = g.argDelimiter || /\s+/, x = Dl(m.argString || "").split(b);
              x.length && x[0] && (m.args = x);
            }
          }
          matchCommand_(d) {
            for (var m = d.length; m > 0; m--) {
              var g = d.substring(0, m);
              if (this.commandMap_[g]) {
                var b = this.commandMap_[g];
                if (b.name.indexOf(d) === 0)
                  return b;
              }
            }
          }
          buildCommandMap_() {
            this.commandMap_ = {};
            for (var d = 0; d < s.length; d++) {
              var m = s[d], g = m.shortName || m.name;
              this.commandMap_[g] = m;
            }
          }
          map(d, m, g, b) {
            if (d != ":" && d.charAt(0) == ":") {
              if (g)
                throw Error("Mode not supported for ex mappings");
              var x = d.substring(1);
              m != ":" && m.charAt(0) == ":" ? this.commandMap_[x] = {
                name: x,
                type: "exToEx",
                toInput: m.substring(1),
                user: true
              } : this.commandMap_[x] = {
                name: x,
                type: "exToKey",
                toKeys: m,
                user: true
              };
            } else {
              var M = {
                keys: d,
                type: "keyToKey",
                toKeys: m,
                noremap: !!b
              };
              g && (M.context = g), oa(M);
            }
          }
          unmap(d, m) {
            if (d != ":" && d.charAt(0) == ":") {
              if (m)
                throw Error("Mode not supported for ex mappings");
              var g = d.substring(1);
              if (this.commandMap_[g] && this.commandMap_[g].user)
                return delete this.commandMap_[g], true;
            } else
              for (var b = d, x = 0; x < r.length; x++)
                if (b == r[x].keys && r[x].context === m)
                  return r.splice(x, 1), _f2(b), true;
          }
        }
        var ia = {
          colorscheme: function(f, d) {
            if (!d.args || d.args.length < 1) {
              _e2(f, f.getOption("theme"));
              return;
            }
            f.setOption("theme", d.args[0]);
          },
          map: function(f, d, m, g) {
            var b = d.args;
            if (!b || b.length < 2) {
              f && _e2(f, "Invalid mapping: " + d.input);
              return;
            }
            Ft.map(b[0], b[1], m, g);
          },
          imap: function(f, d) {
            this.map(f, d, "insert");
          },
          nmap: function(f, d) {
            this.map(f, d, "normal");
          },
          vmap: function(f, d) {
            this.map(f, d, "visual");
          },
          omap: function(f, d) {
            this.map(f, d, "operatorPending");
          },
          noremap: function(f, d) {
            this.map(f, d, void 0, true);
          },
          inoremap: function(f, d) {
            this.map(f, d, "insert", true);
          },
          nnoremap: function(f, d) {
            this.map(f, d, "normal", true);
          },
          vnoremap: function(f, d) {
            this.map(f, d, "visual", true);
          },
          onoremap: function(f, d) {
            this.map(f, d, "operatorPending", true);
          },
          unmap: function(f, d, m) {
            var g = d.args;
            (!g || g.length < 1 || !Ft.unmap(g[0], m)) && f && _e2(f, "No such mapping: " + d.input);
          },
          mapclear: function(f, d) {
            ve.mapclear();
          },
          imapclear: function(f, d) {
            ve.mapclear("insert");
          },
          nmapclear: function(f, d) {
            ve.mapclear("normal");
          },
          vmapclear: function(f, d) {
            ve.mapclear("visual");
          },
          omapclear: function(f, d) {
            ve.mapclear("operatorPending");
          },
          move: function(f, d) {
            Er.processCommand(f, f.state.vim, {
              keys: "",
              type: "motion",
              motion: "moveToLineOrEdgeOfDocument",
              motionArgs: {
                forward: false,
                explicitRepeat: true,
                linewise: true
              },
              repeatOverride: d.line + 1
            });
          },
          set: function(f, d) {
            var m = d.args, g = d.setCfg || {};
            if (!m || m.length < 1) {
              f && _e2(f, "Invalid mapping: " + d.input);
              return;
            }
            var b = m[0].split("="), x = b.shift() || "", M = b.length > 0 ? b.join("=") : void 0, A = false, E = false;
            if (x.charAt(x.length - 1) == "?") {
              if (M)
                throw Error("Trailing characters: " + d.argString);
              x = x.substring(0, x.length - 1), A = true;
            } else
              x.charAt(x.length - 1) == "!" && (x = x.substring(0, x.length - 1), E = true);
            M === void 0 && x.substring(0, 2) == "no" && (x = x.substring(2), M = false);
            var I = Y[x] && Y[x].type == "boolean";
            if (I && (E ? M = !ue(x, f, g) : M == null && (M = true)), !I && M === void 0 || A) {
              var _ = ue(x, f, g);
              _ instanceof Error ? _e2(f, _.message) : _ === true || _ === false ? _e2(f, " " + (_ ? "" : "no") + x) : _e2(f, "  " + x + "=" + _);
            } else {
              var H = ne(x, M, f, g);
              H instanceof Error && _e2(f, H.message);
            }
          },
          setlocal: function(f, d) {
            d.setCfg = {
              scope: "local"
            }, this.set(f, d);
          },
          setglobal: function(f, d) {
            d.setCfg = {
              scope: "global"
            }, this.set(f, d);
          },
          registers: function(f, d) {
            var m = d.args, g = V.registerController.registers, b = `----------Registers----------

`;
            if (m)
              for (var A = m.join(""), E = 0; E < A.length; E++) {
                var x = A.charAt(E);
                if (!!V.registerController.isValidRegister(x)) {
                  var I = g[x] || new nr();
                  b += '"' + x + "    " + I.toString() + `
`;
                }
              }
            else
              for (var x in g) {
                var M = g[x].toString();
                M.length && (b += '"' + x + "    " + M + `
`);
              }
            _e2(f, b, true);
          },
          marks: function(f, d) {
            var m = d.args, g = f.state.vim.marks, b = `-----------Marks-----------
mark	line	col

`;
            if (m)
              for (var A = m.join(""), E = 0; E < A.length; E++) {
                var x = A.charAt(E), M = g[x] && g[x].find();
                M && (b += x + "	" + M.line + "	" + M.ch + `
`);
              }
            else
              for (var x in g) {
                var M = g[x] && g[x].find();
                M && (b += x + "	" + M.line + "	" + M.ch + `
`);
              }
            _e2(f, b, true);
          },
          sort: function(f, d) {
            var m, g, b, x, M;
            function A() {
              if (d.argString) {
                var Fe = new t.StringStream(d.argString);
                if (Fe.eat("!") && (m = true), Fe.eol())
                  return;
                if (!Fe.eatSpace())
                  return "Invalid arguments";
                var Me = Fe.match(/([dinuox]+)?\s*(\/.+\/)?\s*/);
                if (!Me || !Fe.eol())
                  return "Invalid arguments";
                if (Me[1]) {
                  g = Me[1].indexOf("i") != -1, b = Me[1].indexOf("u") != -1;
                  var et = Me[1].indexOf("d") != -1 || Me[1].indexOf("n") != -1, sr = Me[1].indexOf("x") != -1, qt = Me[1].indexOf("o") != -1;
                  if (Number(et) + Number(sr) + Number(qt) > 1)
                    return "Invalid arguments";
                  x = et && "decimal" || sr && "hex" || qt && "octal";
                }
                Me[2] && (M = new RegExp(Me[2].substr(1, Me[2].length - 2), g ? "i" : ""));
              }
            }
            var E = A();
            if (E) {
              _e2(f, E + ": " + d.argString);
              return;
            }
            var I = d.line || f.firstLine(), _ = d.lineEnd || d.line || f.lastLine();
            if (I == _)
              return;
            var H = new e(I, 0), j = new e(_, bt(f, _)), W = f.getRange(H, j).split(`
`), $ = x == "decimal" ? /(-?)([\d]+)/ : x == "hex" ? /(-?)(?:0x)?([0-9a-f]+)/i : x == "octal" ? /([0-7]+)/ : null, X = x == "decimal" ? 10 : x == "hex" ? 16 : x == "octal" ? 8 : void 0, J = [], xe = [];
            if (x || M)
              for (var fe = 0; fe < W.length; fe++) {
                var Ae = M ? W[fe].match(M) : null;
                Ae && Ae[0] != "" ? J.push(Ae) : $ && $.exec(W[fe]) ? J.push(W[fe]) : xe.push(W[fe]);
              }
            else
              xe = W;
            function Le(Fe, Me) {
              if (m) {
                var et;
                et = Fe, Fe = Me, Me = et;
              }
              g && (Fe = Fe.toLowerCase(), Me = Me.toLowerCase());
              var sr = $ && $.exec(Fe), qt = $ && $.exec(Me);
              if (!sr || !qt)
                return Fe < Me ? -1 : 1;
              var ar = parseInt((sr[1] + sr[2]).toLowerCase(), X), fs = parseInt((qt[1] + qt[2]).toLowerCase(), X);
              return ar - fs;
            }
            function Oe(Fe, Me) {
              if (m) {
                var et;
                et = Fe, Fe = Me, Me = et;
              }
              return g && (Fe[0] = Fe[0].toLowerCase(), Me[0] = Me[0].toLowerCase()), Fe[0] < Me[0] ? -1 : 1;
            }
            if (J.sort(M ? Oe : Le), M)
              for (var fe = 0; fe < J.length; fe++)
                J[fe] = J[fe].input;
            else
              x || xe.sort(Le);
            if (W = m ? J.concat(xe) : xe.concat(J), b) {
              var ut = W, pt;
              W = [];
              for (var fe = 0; fe < ut.length; fe++)
                ut[fe] != pt && W.push(ut[fe]), pt = ut[fe];
            }
            f.replaceRange(W.join(`
`), H, j);
          },
          vglobal: function(f, d) {
            this.global(f, d);
          },
          normal: function(f, d) {
            var m = false, g = d.argString;
            if (g && g[0] == "!" && (g = g.slice(1), m = true), g = g.trimStart(), !g) {
              _e2(f, "Argument is required.");
              return;
            }
            var b = d.line;
            if (typeof b == "number")
              for (var x = isNaN(d.lineEnd) ? b : d.lineEnd, M = b; M <= x; M++)
                f.setCursor(M, 0), yt(f, d.argString.trimStart(), {
                  noremap: m
                }), f.state.vim.insertMode && Qr(f, true);
            else
              yt(f, d.argString.trimStart(), {
                noremap: m
              }), f.state.vim.insertMode && Qr(f, true);
          },
          global: function(f, d) {
            var m = d.argString;
            if (!m) {
              _e2(f, "Regular Expression missing from global");
              return;
            }
            var g = d.commandName[0] === "v";
            m[0] === "!" && d.commandName[0] === "g" && (g = true, m = m.slice(1));
            var b = d.line !== void 0 ? d.line : f.firstLine(), x = d.lineEnd || d.line || f.lastLine(), M = mg(m), A = m, E = "";
            if (M && M.length && (A = M[0], E = M.slice(1, M.length).join("/")), A)
              try {
                ls(f, A, true, true);
              } catch {
                _e2(f, "Invalid regex: " + A);
                return;
              }
            for (var I = Pn(f).getQuery(), _ = [], H = b; H <= x; H++) {
              var j = f.getLine(H), W = I.test(j);
              W !== g && _.push(E ? f.getLineHandle(H) : j);
            }
            if (!E) {
              _e2(f, _.join(`
`));
              return;
            }
            var $ = 0, X = function() {
              if ($ < _.length) {
                var J = _[$++], xe = f.getLineNumber(J);
                if (xe == null) {
                  X();
                  return;
                }
                var fe = xe + 1 + E;
                Ft.processCommand(f, fe, {
                  callback: X
                });
              } else
                f.releaseLineHandles && f.releaseLineHandles();
            };
            X();
          },
          substitute: function(f, d) {
            if (!f.getSearchCursor)
              throw new Error("Search feature not available. Requires searchcursor.js or any other getSearchCursor implementation.");
            var m = d.argString, g = m ? Mf(m, m[0]) : [], b = "", x = "", M, A, E, I = false, _ = false;
            if (g && g.length)
              b = g[0], ue("pcre") && b !== "" && (b = new RegExp(b).source), x = g[1], x !== void 0 && (ue("pcre") ? x = bg(x.replace(/([^\\])&/g, "$1$$&")) : x = yg(x), V.lastSubstituteReplacePart = x), M = g[2] ? g[2].split(" ") : [];
            else if (m && m.length) {
              _e2(f, "Substitutions should be of the form :s/pattern/replace/");
              return;
            }
            if (M && (A = M[0], E = parseInt(M[1]), A && (A.indexOf("c") != -1 && (I = true), A.indexOf("g") != -1 && (_ = true), ue("pcre") ? b = b + "/" + A : b = b.replace(/\//g, "\\/") + "/" + A)), b)
              try {
                ls(f, b, true, true);
              } catch {
                _e2(f, "Invalid regex: " + b);
                return;
              }
            if (x = x || V.lastSubstituteReplacePart, x === void 0) {
              _e2(f, "No previous substitute regular expression");
              return;
            }
            var H = Pn(f), j = H.getQuery(), W = d.line !== void 0 ? d.line : f.getCursor().line, $ = d.lineEnd || W;
            W == f.firstLine() && $ == f.lastLine() && ($ = 1 / 0), E && (W = $, $ = W + E - 1);
            var X = $t(f, new e(W, 0)), J = f.getSearchCursor(j, X);
            zl(f, I, _, W, $, J, j, x, d.callback);
          },
          startinsert: function(f, d) {
            yt(f, d.argString == "!" ? "A" : "i", {});
          },
          redo: t.commands.redo,
          undo: t.commands.undo,
          write: function(f) {
            t.commands.save ? t.commands.save(f) : f.save && f.save();
          },
          nohlsearch: function(f) {
            fo(f);
          },
          yank: function(f) {
            var d = ze(f.getCursor()), m = d.line, g = f.getLine(m);
            V.registerController.pushText("0", "yank", g, true, true);
          },
          delete: function(f, d) {
            var m = d.selectionLine, g = isNaN(d.selectionLineEnd) ? m : d.selectionLineEnd;
            Js.delete(f, {
              linewise: true
            }, [
              {
                anchor: new e(m, 0),
                head: new e(g + 1, 0)
              }
            ]);
          },
          join: function(f, d) {
            var m = d.selectionLine, g = isNaN(d.selectionLineEnd) ? m : d.selectionLineEnd;
            f.setCursor(new e(m, 0)), lo.joinLines(f, {
              repeat: g - m
            }, f.state.vim);
          },
          delmarks: function(f, d) {
            if (!d.argString || !Dl(d.argString)) {
              _e2(f, "Argument required");
              return;
            }
            for (var m = f.state.vim, g = new t.StringStream(Dl(d.argString)); !g.eol(); ) {
              g.eatSpace();
              var b = g.pos;
              if (!g.match(/[a-zA-Z]/, false)) {
                _e2(f, "Invalid argument: " + d.argString.substring(b));
                return;
              }
              var x = g.next();
              if (g.match("-", true)) {
                if (!g.match(/[a-zA-Z]/, false)) {
                  _e2(f, "Invalid argument: " + d.argString.substring(b));
                  return;
                }
                var M = x, A = g.next();
                if (M && A && T(M) == T(A)) {
                  var E = M.charCodeAt(0), I = A.charCodeAt(0);
                  if (E >= I) {
                    _e2(f, "Invalid argument: " + d.argString.substring(b));
                    return;
                  }
                  for (var _ = 0; _ <= I - E; _++) {
                    var H = String.fromCharCode(E + _);
                    delete m.marks[H];
                  }
                } else {
                  _e2(f, "Invalid argument: " + M + "-");
                  return;
                }
              } else
                x && delete m.marks[x];
            }
          }
        }, Ft = new ra();
        ve.defineEx("version", "ve", (f) => {
          _e2(f, "Codemirror-vim version: 6.3.0");
        });
        function zl(f, d, m, g, b, x, M, A, E) {
          f.state.vim.exMode = true;
          var I = false, _ = 0, H, j, W;
          function $() {
            f.operation(function() {
              for (; !I; )
                X(), xe();
              fe();
            });
          }
          function X() {
            var Le = "", Oe = x.match || x.pos && x.pos.match;
            if (Oe)
              Le = A.replace(/\$(\d{1,3}|[$&])/g, function(Fe, Me) {
                if (Me == "$")
                  return "$";
                if (Me == "&")
                  return Oe[0];
                for (var et = Me; parseInt(et) >= Oe.length && et.length > 0; )
                  et = et.slice(0, et.length - 1);
                return et ? Oe[et] + Me.slice(et.length, Me.length) : Fe;
              });
            else {
              var ut = f.getRange(x.from(), x.to());
              Le = ut.replace(M, A);
            }
            var pt = x.to().line;
            x.replace(Le), j = x.to().line, b += j - pt, W = j < pt;
          }
          function J() {
            var Le = H && ze(x.to()), Oe = x.findNext();
            return Oe && !Oe[0] && Le && Kt(x.from(), Le) && (Oe = x.findNext()), Oe && _++, Oe;
          }
          function xe() {
            for (; J() && Nl(x.from(), g, b); )
              if (!(!m && x.from().line == j && !W)) {
                f.scrollIntoView(x.from(), 30), f.setSelection(x.from(), x.to()), H = x.from(), I = false;
                return;
              }
            I = true;
          }
          function fe(Le) {
            if (Le && Le(), f.focus(), H) {
              f.setCursor(H);
              var Oe = f.state.vim;
              Oe.exMode = false, Oe.lastHPos = Oe.lastHSPos = H.ch;
            }
            E ? E() : I && _e2(f, (_ ? "Found " + _ + " matches" : "No matches found") + " for pattern: " + M + (ue("pcre") ? " (set nopcre to use Vim regexps)" : ""));
          }
          function Ae(Le, Oe, ut) {
            t.e_stop(Le);
            var pt = ao(Le);
            switch (pt) {
              case "y":
                X(), xe();
                break;
              case "n":
                xe();
                break;
              case "a":
                var Fe = E;
                E = void 0, f.operation($), E = Fe;
                break;
              case "l":
                X();
              case "q":
              case "<Esc>":
              case "<C-c>":
              case "<C-[>":
                fe(ut);
                break;
            }
            return I && fe(ut), true;
          }
          if (xe(), I) {
            _e2(f, "No matches for " + M + (ue("pcre") ? " (set nopcre to use vim regexps)" : ""));
            return;
          }
          if (!d) {
            $(), E && E();
            return;
          }
          ea(f, {
            prefix: on("span", "replace with ", on("strong", A), " (y/n/a/q/l)"),
            onKeyDown: Ae
          });
        }
        function Qr(f, d) {
          var m = f.state.vim, g = V.macroModeState, b = V.registerController.getRegister("."), x = g.isPlaying, M = g.lastInsertModeChanges;
          x || (f.off("change", Vl), m.insertEnd && m.insertEnd.clear(), m.insertEnd = void 0, t.off(f.getInputField(), "keydown", Hl)), !x && m.insertModeRepeat && m.insertModeRepeat > 1 && ($f(f, m, m.insertModeRepeat - 1, true), m.lastEditInputState.repeatOverride = m.insertModeRepeat), delete m.insertModeRepeat, m.insertMode = false, d || f.setCursor(f.getCursor().line, f.getCursor().ch - 1), f.setOption("keyMap", "vim"), f.setOption("disableInput", true), f.toggleOverwrite(false), b.setText(M.changes.join("")), t.signal(f, "vim-mode-change", {
            mode: "normal"
          }), g.isRecording && If(g);
        }
        function oa(f) {
          r.unshift(f), f.keys && Fl(f.keys);
        }
        function Fl(f) {
          f.split(/(<(?:[CSMA]-)*\w+>|.)/i).forEach(function(d) {
            d && (i[d] || (i[d] = 0), i[d]++);
          });
        }
        function _f2(f) {
          f.split(/(<(?:[CSMA]-)*\w+>|.)/i).forEach(function(d) {
            i[d] && i[d]--;
          });
        }
        function Li(f, d, m, g, b) {
          var x = {
            keys: f,
            type: d
          };
          x[d] = m, x[d + "Args"] = g;
          for (var M in b)
            x[M] = b[M];
          oa(x);
        }
        te("insertModeEscKeysTimeout", 200, "number");
        function us(f, d, m, g) {
          var b = V.registerController.getRegister(g);
          if (g == ":") {
            b.keyBuffer[0] && Ft.processCommand(f, b.keyBuffer[0]), m.isPlaying = false;
            return;
          }
          var x = b.keyBuffer, M = 0;
          m.isPlaying = true, m.replaySearchQueries = b.searchQueries.slice(0);
          for (var A = 0; A < x.length; A++)
            for (var E = x[A], I, _, H = /<(?:[CSMA]-)*\w+>|./gi; I = H.exec(E); )
              if (_ = I[0], ve.handleKey(f, _, "macro"), d.insertMode) {
                var j = b.insertModeChanges[M++].changes;
                V.macroModeState.lastInsertModeChanges.changes = j, B(f, j, 1), Qr(f);
              }
          m.isPlaying = false;
        }
        function kg(f, d) {
          if (!f.isPlaying) {
            var m = f.latestRegister, g = V.registerController.getRegister(m);
            g && g.pushText(d);
          }
        }
        function If(f) {
          if (!f.isPlaying) {
            var d = f.latestRegister, m = V.registerController.getRegister(d);
            m && m.pushInsertModeChanges && m.pushInsertModeChanges(f.lastInsertModeChanges);
          }
        }
        function Cg(f, d) {
          if (!f.isPlaying) {
            var m = f.latestRegister, g = V.registerController.getRegister(m);
            g && g.pushSearchQuery && g.pushSearchQuery(d);
          }
        }
        function Vl(f, d) {
          var m = V.macroModeState, g = m.lastInsertModeChanges;
          if (!m.isPlaying)
            for (var b = f.state.vim; d; ) {
              if (g.expectCursorActivityForChange = true, g.ignoreCount > 1)
                g.ignoreCount--;
              else if (d.origin == "+input" || d.origin == "paste" || d.origin === void 0) {
                var x = f.listSelections().length;
                x > 1 && (g.ignoreCount = x);
                var M = d.text.join(`
`);
                if (g.maybeReset && (g.changes = [], g.maybeReset = false), M)
                  if (f.state.overwrite && !/\n/.test(M))
                    g.changes.push([
                      M
                    ]);
                  else {
                    if (M.length > 1) {
                      var A = b && b.insertEnd && b.insertEnd.find(), E = f.getCursor();
                      if (A && A.line == E.line) {
                        var I = A.ch - E.ch;
                        I > 0 && I < M.length && (g.changes.push([
                          M,
                          I
                        ]), M = "");
                      }
                    }
                    M && g.changes.push(M);
                  }
              }
              d = d.next;
            }
        }
        function Bf(f) {
          var _a3;
          var d = f.state.vim;
          if (d.insertMode) {
            var m = V.macroModeState;
            if (m.isPlaying)
              return;
            var g = m.lastInsertModeChanges;
            g.expectCursorActivityForChange ? g.expectCursorActivityForChange = false : (g.maybeReset = true, d.insertEnd && d.insertEnd.clear(), d.insertEnd = f.setBookmark(f.getCursor(), {
              insertLeft: true
            }));
          } else
            ((_a3 = f.curOp) == null ? void 0 : _a3.isVimOp) || Nf(f, d);
        }
        function Nf(f, d) {
          var m = f.getCursor("anchor"), g = f.getCursor("head");
          if (d.visualMode && !f.somethingSelected() ? ir(f, false) : !d.visualMode && !d.insertMode && f.somethingSelected() && (d.visualMode = true, d.visualLine = false, t.signal(f, "vim-mode-change", {
            mode: "visual"
          })), d.visualMode) {
            var b = ct(g, m) ? 0 : -1, x = ct(g, m) ? -1 : 0;
            g = dt(g, 0, b), m = dt(m, 0, x), d.sel = {
              anchor: m,
              head: g
            }, En(f, d, "<", zt(g, m)), En(f, d, ">", Xr(g, m));
          } else
            d.insertMode || (d.lastHPos = f.getCursor().ch);
        }
        function Hl(f) {
          var d = V.macroModeState, m = d.lastInsertModeChanges, g = t.keyName ? t.keyName(f) : f.key;
          !g || (g.indexOf("Delete") != -1 || g.indexOf("Backspace") != -1) && (m.maybeReset && (m.changes = [], m.maybeReset = false), m.changes.push(new ge(g, f)));
        }
        function $f(f, d, m, g) {
          var b = V.macroModeState;
          b.isPlaying = true;
          var x = d.lastEditActionCommand, M = d.inputState;
          function A() {
            x ? Er.processAction(f, d, x) : Er.evalInput(f, d);
          }
          function E(_) {
            if (b.lastInsertModeChanges.changes.length > 0) {
              _ = d.lastEditActionCommand ? _ : 1;
              var H = b.lastInsertModeChanges;
              B(f, H.changes, _);
            }
          }
          if (d.inputState = d.lastEditInputState, x && x.interlaceInsertRepeat)
            for (var I = 0; I < m; I++)
              A(), E(1);
          else
            g || A(), E(m);
          d.inputState = M, d.insertMode && !g && Qr(f), b.isPlaying = false;
        }
        function O(f, d) {
          t.lookupKey(d, "vim-insert", function(g) {
            return typeof g == "string" ? t.commands[g](f) : g(f), true;
          });
        }
        function B(f, d, m) {
          var g = f.getCursor("head"), b = V.macroModeState.lastInsertModeChanges.visualBlock;
          b && (yf(f, g, b + 1), m = f.listSelections().length, f.setCursor(g));
          for (var x = 0; x < m; x++) {
            b && f.setCursor(dt(g, x, 0));
            for (var M = 0; M < d.length; M++) {
              var A = d[M];
              if (A instanceof ge)
                O(f, A.keyName);
              else if (typeof A == "string")
                f.replaceSelection(A);
              else {
                var E = f.getCursor(), I = dt(E, 0, A[0].length - (A[1] || 0));
                f.replaceRange(A[0], E, A[1] ? E : I), f.setCursor(I);
              }
            }
          }
          b && f.setCursor(dt(g, 0, 1));
        }
        function U(f) {
          var d = new f.constructor();
          return Object.keys(f).forEach(function(m) {
            if (m != "insertEnd") {
              var g = f[m];
              Array.isArray(g) ? g = g.slice() : g && typeof g == "object" && g.constructor != Object && (g = U(g)), d[m] = g;
            }
          }), f.sel && (d.sel = {
            head: f.sel.head && ze(f.sel.head),
            anchor: f.sel.anchor && ze(f.sel.anchor)
          }), d;
        }
        function he(f, d, m) {
          var x = Q(f), g = f, b = false, x = ve.maybeInitVimState_(g), M = x.visualBlock || x.wasInVisualBlock;
          if (g.state.closeVimNotification) {
            var A = g.state.closeVimNotification;
            if (g.state.closeVimNotification = null, A(), d == "<CR>")
              return Et(g), true;
          }
          var E = g.isInMultiSelectMode();
          if (x.wasInVisualBlock && !E ? x.wasInVisualBlock = false : E && x.visualBlock && (x.wasInVisualBlock = true), d == "<Esc>" && !x.insertMode && !x.visualMode && E && x.status == "<Esc>")
            Et(g);
          else if (M || !E || g.inVirtualSelectionMode)
            b = ve.handleKey(g, d, m);
          else {
            var I = U(x), _ = x.inputState.changeQueueList || [];
            g.operation(function() {
              var _a3;
              g.curOp && (g.curOp.isVimOp = true);
              var H = 0;
              g.forEachSelection(function() {
                g.state.vim.inputState.changeQueue = _[H];
                var j = g.getCursor("head"), W = g.getCursor("anchor"), $ = ct(j, W) ? 0 : -1, X = ct(j, W) ? -1 : 0;
                j = dt(j, 0, $), W = dt(W, 0, X), g.state.vim.sel.head = j, g.state.vim.sel.anchor = W, b = ve.handleKey(g, d, m), g.virtualSelection && (_[H] = g.state.vim.inputState.changeQueue, g.state.vim = U(I)), H++;
              }), ((_a3 = g.curOp) == null ? void 0 : _a3.cursorActivity) && !b && (g.curOp.cursorActivity = false), g.state.vim = x, x.inputState.changeQueueList = _, x.inputState.changeQueue = null;
            }, true);
          }
          return b && !x.visualMode && !x.insertMode && x.visualMode != g.somethingSelected() && Nf(g, x), b;
        }
        return ae(), ve;
      }
      function jn(t, e) {
        var n = e.ch, r = e.line + 1;
        r < 1 && (r = 1, n = 0), r > t.lines && (r = t.lines, n = Number.MAX_VALUE);
        var i = t.line(r);
        return Math.min(i.from + Math.max(0, n), i.to);
      }
      function ur(t, e) {
        let n = t.lineAt(e);
        return {
          line: n.number - 1,
          ch: e - n.from
        };
      }
      class ui {
        constructor(e, n) {
          this.line = e, this.ch = n;
        }
      }
      function GL(t, e, n) {
        if (t.addEventListener)
          t.addEventListener(e, n, false);
        else {
          var r = t._handlers || (t._handlers = {});
          r[e] = (r[e] || []).concat(n);
        }
      }
      function YL(t, e, n) {
        if (t.removeEventListener)
          t.removeEventListener(e, n, false);
        else {
          var r = t._handlers, i = r && r[e];
          if (i) {
            var o = i.indexOf(n);
            o > -1 && (r[e] = i.slice(0, o).concat(i.slice(o + 1)));
          }
        }
      }
      function XL(t, e, ...n) {
        var r, i = (r = t._handlers) === null || r === void 0 ? void 0 : r[e];
        if (!!i)
          for (var o = 0; o < i.length; ++o)
            i[o](...n);
      }
      function eM(t, ...e) {
        if (!!t)
          for (var n = 0; n < t.length; ++n)
            t[n](...e);
      }
      let A1;
      try {
        A1 = new RegExp("[\\w\\p{Alphabetic}\\p{Number}_]", "u");
      } catch {
        A1 = /[\w]/;
      }
      function Cc(t, e) {
        var n = t.cm6;
        if (!n.state.readOnly) {
          var r = "input.type.compose";
          if (t.curOp && (t.curOp.lastChange || (r = "input.type.compose.start")), e.annotations)
            try {
              e.annotations.some(function(i) {
                i.value == "input" && (i.value = r);
              });
            } catch (i) {
              console.error(i);
            }
          else
            e.userEvent = r;
          return n.dispatch(e);
        }
      }
      function tM(t, e) {
        var n;
        t.curOp && (t.curOp.$changeStart = void 0), (e ? Ux : Lp)(t.cm6);
        let r = (n = t.curOp) === null || n === void 0 ? void 0 : n.$changeStart;
        r != null && t.cm6.dispatch({
          selection: {
            anchor: r
          }
        });
      }
      var NX = {
        Left: (t) => ys(t.cm6, {
          key: "Left"
        }, "editor"),
        Right: (t) => ys(t.cm6, {
          key: "Right"
        }, "editor"),
        Up: (t) => ys(t.cm6, {
          key: "Up"
        }, "editor"),
        Down: (t) => ys(t.cm6, {
          key: "Down"
        }, "editor"),
        Backspace: (t) => ys(t.cm6, {
          key: "Backspace"
        }, "editor"),
        Delete: (t) => ys(t.cm6, {
          key: "Delete"
        }, "editor")
      };
      class Re {
        openDialog(e, n, r) {
          return zX(this, e, n, r);
        }
        openNotification(e, n) {
          return $X(this, e, n);
        }
        constructor(e) {
          this.state = {}, this.marks = /* @__PURE__ */ Object.create(null), this.$mid = 0, this.options = {}, this._handlers = {}, this.$lastChangeEndOffset = 0, this.virtualSelection = null, this.cm6 = e, this.onChange = this.onChange.bind(this), this.onSelectionChange = this.onSelectionChange.bind(this);
        }
        on(e, n) {
          GL(this, e, n);
        }
        off(e, n) {
          YL(this, e, n);
        }
        signal(e, n, r) {
          XL(this, e, n, r);
        }
        indexFromPos(e) {
          return jn(this.cm6.state.doc, e);
        }
        posFromIndex(e) {
          return ur(this.cm6.state.doc, e);
        }
        foldCode(e) {
          let n = this.cm6, r = n.state.selection.ranges, i = this.cm6.state.doc, o = jn(i, e), s = q.create([
            q.range(o, o)
          ], 0).ranges;
          n.state.selection.ranges = s, zR(n), n.state.selection.ranges = r;
        }
        firstLine() {
          return 0;
        }
        lastLine() {
          return this.cm6.state.doc.lines - 1;
        }
        lineCount() {
          return this.cm6.state.doc.lines;
        }
        setCursor(e, n) {
          typeof e == "object" && (n = e.ch, e = e.line);
          var r = jn(this.cm6.state.doc, {
            line: e,
            ch: n || 0
          });
          this.cm6.dispatch({
            selection: {
              anchor: r
            }
          }, {
            scrollIntoView: !this.curOp
          }), this.curOp && !this.curOp.isVimOp && this.onBeforeEndOperation();
        }
        getCursor(e) {
          var n = this.cm6.state.selection.main, r = e == "head" || !e ? n.head : e == "anchor" ? n.anchor : e == "start" ? n.from : e == "end" ? n.to : null;
          if (r == null)
            throw new Error("Invalid cursor type");
          return this.posFromIndex(r);
        }
        listSelections() {
          var e = this.cm6.state.doc;
          return this.cm6.state.selection.ranges.map((n) => ({
            anchor: ur(e, n.anchor),
            head: ur(e, n.head)
          }));
        }
        setSelections(e, n) {
          var r = this.cm6.state.doc, i = e.map((o) => {
            var s = jn(r, o.head), a = jn(r, o.anchor);
            return s == a ? q.cursor(s, 1) : q.range(a, s);
          });
          this.cm6.dispatch({
            selection: q.create(i, n)
          });
        }
        setSelection(e, n, r) {
          this.setSelections([
            {
              anchor: e,
              head: n
            }
          ], 0), r && r.origin == "*mouse" && this.onBeforeEndOperation();
        }
        getLine(e) {
          var n = this.cm6.state.doc;
          return e < 0 || e >= n.lines ? "" : this.cm6.state.doc.line(e + 1).text;
        }
        getLineHandle(e) {
          return this.$lineHandleChanges || (this.$lineHandleChanges = []), {
            row: e,
            index: this.indexFromPos(new ui(e, 0))
          };
        }
        getLineNumber(e) {
          var n = this.$lineHandleChanges;
          if (!n)
            return null;
          for (var r = e.index, i = 0; i < n.length; i++)
            if (r = n[i].changes.mapPos(r, 1, Zt.TrackAfter), r == null)
              return null;
          var o = this.posFromIndex(r);
          return o.ch == 0 ? o.line : null;
        }
        releaseLineHandles() {
          this.$lineHandleChanges = void 0;
        }
        getRange(e, n) {
          var r = this.cm6.state.doc;
          return this.cm6.state.sliceDoc(jn(r, e), jn(r, n));
        }
        replaceRange(e, n, r, i) {
          r || (r = n);
          var o = this.cm6.state.doc, s = jn(o, n), a = jn(o, r);
          Cc(this, {
            changes: {
              from: s,
              to: a,
              insert: e
            }
          });
        }
        replaceSelection(e) {
          Cc(this, this.cm6.state.replaceSelection(e));
        }
        replaceSelections(e) {
          var n = this.cm6.state.selection.ranges, r = n.map((i, o) => ({
            from: i.from,
            to: i.to,
            insert: e[o] || ""
          }));
          Cc(this, {
            changes: r
          });
        }
        getSelection() {
          return this.getSelections().join(`
`);
        }
        getSelections() {
          var e = this.cm6;
          return e.state.selection.ranges.map((n) => e.state.sliceDoc(n.from, n.to));
        }
        somethingSelected() {
          return this.cm6.state.selection.ranges.some((e) => !e.empty);
        }
        getInputField() {
          return this.cm6.contentDOM;
        }
        clipPos(e) {
          var n = this.cm6.state.doc, r = e.ch, i = e.line + 1;
          i < 1 && (i = 1, r = 0), i > n.lines && (i = n.lines, r = Number.MAX_VALUE);
          var o = n.line(i);
          return r = Math.min(Math.max(0, r), o.to - o.from), new ui(i - 1, r);
        }
        getValue() {
          return this.cm6.state.doc.toString();
        }
        setValue(e) {
          var n = this.cm6;
          return n.dispatch({
            changes: {
              from: 0,
              to: n.state.doc.length,
              insert: e
            },
            selection: q.range(0, 0)
          });
        }
        focus() {
          return this.cm6.focus();
        }
        blur() {
          return this.cm6.contentDOM.blur();
        }
        defaultTextHeight() {
          return this.cm6.defaultLineHeight;
        }
        findMatchingBracket(e, n) {
          var r = this.cm6.state, i = jn(r.doc, e), o = mr(r, i + 1, -1);
          return o && o.end ? {
            to: ur(r.doc, o.end.from)
          } : (o = mr(r, i, 1), o && o.end ? {
            to: ur(r.doc, o.end.from)
          } : {
            to: void 0
          });
        }
        scanForBracket(e, n, r, i) {
          return HX(this, e, n, r, i);
        }
        indentLine(e, n) {
          n ? this.indentMore() : this.indentLess();
        }
        indentMore() {
          Yx(this.cm6);
        }
        indentLess() {
          Xx(this.cm6);
        }
        execCommand(e) {
          if (e == "indentAuto")
            Re.commands.indentAuto(this);
          else if (e == "goLineLeft")
            aL(this.cm6);
          else if (e == "goLineRight") {
            sL(this.cm6);
            let n = this.cm6.state, r = n.selection.main.head;
            r < n.doc.length && n.sliceDoc(r, r + 1) !== `
` && nG(this.cm6);
          } else
            console.log(e + " is not implemented");
        }
        setBookmark(e, n) {
          var r = (n == null ? void 0 : n.insertLeft) ? 1 : -1, i = this.indexFromPos(e), o = new UX(this, i, r);
          return o;
        }
        addOverlay({ query: e }) {
          let n = new Zx({
            regexp: true,
            search: e.source,
            caseSensitive: !/i/.test(e.flags)
          });
          if (n.valid) {
            n.forVim = true, this.cm6Query = n;
            let r = Jo.of(n);
            return this.cm6.dispatch({
              effects: r
            }), n;
          }
        }
        removeOverlay(e) {
          if (!this.cm6Query)
            return;
          this.cm6Query.forVim = false;
          let n = Jo.of(this.cm6Query);
          this.cm6.dispatch({
            effects: n
          });
        }
        getSearchCursor(e, n) {
          var r = this, i = null, o = null, s = false;
          n.ch == null && (n.ch = Number.MAX_VALUE);
          var a = jn(r.cm6.state.doc, n), l = e.source.replace(/(\\.|{(?:\d+(?:,\d*)?|,\d+)})|[{}]/g, function(v, y) {
            return y || "\\" + v;
          });
          function c(v, y = 0, S = v.length) {
            return new Jx(v, l, {
              ignoreCase: e.ignoreCase
            }, y, S);
          }
          function u(v) {
            var y = r.cm6.state.doc;
            if (v > y.length)
              return null;
            let S = c(y, v).next();
            return S.done ? null : S.value;
          }
          var h = 1e4;
          function p(v, y) {
            var S = r.cm6.state.doc;
            for (let C = 1; ; C++) {
              let w = Math.max(v, y - C * h), k = c(S, w, y), T = null;
              for (; !k.next().done; )
                T = k.value;
              if (T && (w == v || T.from > w + 10))
                return T;
              if (w == v)
                return null;
            }
          }
          return {
            findNext: function() {
              return this.find(false);
            },
            findPrevious: function() {
              return this.find(true);
            },
            find: function(v) {
              var y = r.cm6.state.doc;
              if (v) {
                let S = i ? s ? i.to - 1 : i.from : a;
                i = p(0, S);
              } else {
                let S = i ? s ? i.to + 1 : i.to : a;
                i = u(S);
              }
              return o = i && {
                from: ur(y, i.from),
                to: ur(y, i.to),
                match: i.match
              }, s = i ? i.from == i.to : false, i && i.match;
            },
            from: function() {
              return o == null ? void 0 : o.from;
            },
            to: function() {
              return o == null ? void 0 : o.to;
            },
            replace: function(v) {
              i && (Cc(r, {
                changes: {
                  from: i.from,
                  to: i.to,
                  insert: v
                }
              }), i.to = i.from + v.length, o && (o.to = ur(r.cm6.state.doc, i.to)));
            },
            get match() {
              return o && o.match;
            }
          };
        }
        findPosV(e, n, r, i) {
          let { cm6: o } = this;
          const s = o.state.doc;
          let a = r == "page" ? o.dom.clientHeight : 0;
          const l = jn(s, e);
          let c = q.cursor(l, 1, void 0, i), u = Math.round(Math.abs(n));
          for (let p = 0; p < u; p++)
            r == "page" ? c = o.moveVertically(c, n > 0, a) : r == "line" && (c = o.moveVertically(c, n > 0));
          let h = ur(s, c.head);
          return (n < 0 && c.head == 0 && i != 0 && e.line == 0 && e.ch != 0 || n > 0 && c.head == s.length && h.ch != i && e.line == h.line) && (h.hitSide = true), h;
        }
        charCoords(e, n) {
          var r = this.cm6.contentDOM.getBoundingClientRect(), i = jn(this.cm6.state.doc, e), o = this.cm6.coordsAtPos(i), s = -r.top;
          return {
            left: ((o == null ? void 0 : o.left) || 0) - r.left,
            top: ((o == null ? void 0 : o.top) || 0) + s,
            bottom: ((o == null ? void 0 : o.bottom) || 0) + s
          };
        }
        coordsChar(e, n) {
          var r = this.cm6.contentDOM.getBoundingClientRect(), i = this.cm6.posAtCoords({
            x: e.left + r.left,
            y: e.top + r.top
          }) || 0;
          return ur(this.cm6.state.doc, i);
        }
        getScrollInfo() {
          var e = this.cm6.scrollDOM;
          return {
            left: e.scrollLeft,
            top: e.scrollTop,
            height: e.scrollHeight,
            width: e.scrollWidth,
            clientHeight: e.clientHeight,
            clientWidth: e.clientWidth
          };
        }
        scrollTo(e, n) {
          e != null && (this.cm6.scrollDOM.scrollLeft = e), n != null && (this.cm6.scrollDOM.scrollTop = n);
        }
        scrollIntoView(e, n) {
          if (e) {
            var r = this.indexFromPos(e);
            this.cm6.dispatch({
              effects: ce.scrollIntoView(r)
            });
          } else
            this.cm6.dispatch({
              scrollIntoView: true,
              userEvent: "scroll"
            });
        }
        getWrapperElement() {
          return this.cm6.dom;
        }
        getMode() {
          return {
            name: this.getOption("mode")
          };
        }
        setSize(e, n) {
          this.cm6.dom.style.width = e + 4 + "px", this.cm6.dom.style.height = n + "px", this.refresh();
        }
        refresh() {
          this.cm6.measure();
        }
        destroy() {
          this.removeOverlay();
        }
        getLastEditEnd() {
          return this.posFromIndex(this.$lastChangeEndOffset);
        }
        onChange(e) {
          this.$lineHandleChanges && this.$lineHandleChanges.push(e);
          for (let r in this.marks)
            this.marks[r].update(e.changes);
          this.virtualSelection && (this.virtualSelection.ranges = this.virtualSelection.ranges.map((r) => r.map(e.changes)));
          var n = this.curOp = this.curOp || {};
          e.changes.iterChanges((r, i, o, s, a) => {
            (n.$changeStart == null || n.$changeStart > o) && (n.$changeStart = o), this.$lastChangeEndOffset = s;
            var l = {
              text: a.toJSON()
            };
            n.lastChange ? n.lastChange.next = n.lastChange = l : n.lastChange = n.change = l;
          }, true), n.changeHandlers || (n.changeHandlers = this._handlers.change && this._handlers.change.slice());
        }
        onSelectionChange() {
          var e = this.curOp = this.curOp || {};
          e.cursorActivityHandlers || (e.cursorActivityHandlers = this._handlers.cursorActivity && this._handlers.cursorActivity.slice()), this.curOp.cursorActivity = true;
        }
        operation(e, n) {
          this.curOp || (this.curOp = {
            $d: 0
          }), this.curOp.$d++;
          try {
            var r = e();
          } finally {
            this.curOp && (this.curOp.$d--, this.curOp.$d || this.onBeforeEndOperation());
          }
          return r;
        }
        onBeforeEndOperation() {
          var e = this.curOp, n = false;
          e && (e.change && eM(e.changeHandlers, this, e.change), e && e.cursorActivity && (eM(e.cursorActivityHandlers, this, null), e.isVimOp && (n = true)), this.curOp = null), n && this.scrollIntoView();
        }
        moveH(e, n) {
          if (n == "char") {
            var r = this.getCursor();
            this.setCursor(r.line, r.ch + e);
          }
        }
        setOption(e, n) {
          switch (e) {
            case "keyMap":
              this.state.keyMap = n;
              break;
            case "textwidth":
              this.state.textwidth = n;
              break;
          }
        }
        getOption(e) {
          switch (e) {
            case "firstLineNumber":
              return 1;
            case "tabSize":
              return this.cm6.state.tabSize || 4;
            case "readOnly":
              return this.cm6.state.readOnly;
            case "indentWithTabs":
              return this.cm6.state.facet(yl) == "	";
            case "indentUnit":
              return this.cm6.state.facet(yl).length || 2;
            case "textwidth":
              return this.state.textwidth;
            case "keyMap":
              return this.state.keyMap || "vim";
          }
        }
        toggleOverwrite(e) {
          this.state.overwrite = e;
        }
        getTokenTypeAt(e) {
          var n, r = this.indexFromPos(e), i = DR(this.cm6.state, r), o = i == null ? void 0 : i.resolve(r), s = ((n = o == null ? void 0 : o.type) === null || n === void 0 ? void 0 : n.name) || "";
          return /comment/i.test(s) ? "comment" : /string/i.test(s) ? "string" : "";
        }
        overWriteSelection(e) {
          var n = this.cm6.state.doc, r = this.cm6.state.selection, i = r.ranges.map((o) => {
            if (o.empty) {
              var s = o.to < n.length ? n.sliceString(o.from, o.to + 1) : "";
              if (s && !/\n/.test(s))
                return q.range(o.from, o.to + 1);
            }
            return o;
          });
          this.cm6.dispatch({
            selection: q.create(i, r.mainIndex)
          }), this.replaceSelection(e);
        }
        isInMultiSelectMode() {
          return this.cm6.state.selection.ranges.length > 1;
        }
        virtualSelectionMode() {
          return !!this.virtualSelection;
        }
        forEachSelection(e) {
          var n = this.cm6.state.selection;
          this.virtualSelection = q.create(n.ranges, n.mainIndex);
          for (var r = 0; r < this.virtualSelection.ranges.length; r++) {
            var i = this.virtualSelection.ranges[r];
            !i || (this.cm6.dispatch({
              selection: q.create([
                i
              ])
            }), e(), this.virtualSelection.ranges[r] = this.cm6.state.selection.ranges[0]);
          }
          this.cm6.dispatch({
            selection: this.virtualSelection
          }), this.virtualSelection = null;
        }
        hardWrap(e) {
          return KX(this, e);
        }
      }
      Re.isMac = typeof navigator < "u" && /Mac/.test(navigator.platform);
      Re.Pos = ui;
      Re.StringStream = Dq;
      Re.commands = {
        cursorCharLeft: function(t) {
          qx(t.cm6);
        },
        redo: function(t) {
          tM(t, false);
        },
        undo: function(t) {
          tM(t, true);
        },
        newlineAndIndent: function(t) {
          k1({
            state: t.cm6.state,
            dispatch: (e) => Cc(t, e)
          });
        },
        indentAuto: function(t) {
          kL(t.cm6);
        },
        newlineAndIndentContinueComment: void 0,
        save: void 0
      };
      Re.isWordChar = function(t) {
        return A1.test(t);
      };
      Re.keys = NX;
      Re.addClass = function(t, e) {
      };
      Re.rmClass = function(t, e) {
      };
      Re.e_preventDefault = function(t) {
        t.preventDefault();
      };
      Re.e_stop = function(t) {
        var e, n;
        (e = t == null ? void 0 : t.stopPropagation) === null || e === void 0 || e.call(t), (n = t == null ? void 0 : t.preventDefault) === null || n === void 0 || n.call(t);
      };
      Re.lookupKey = function(e, n, r) {
        var i = Re.keys[e];
        !i && /^Arrow/.test(e) && (i = Re.keys[e.slice(5)]), i && r(i);
      };
      Re.on = GL;
      Re.off = YL;
      Re.signal = XL;
      Re.findMatchingTag = jX;
      Re.findEnclosingTag = WX;
      Re.keyName = void 0;
      function QL(t, e, n) {
        var r = document.createElement("div");
        return r.appendChild(e), r;
      }
      function JL(t, e) {
        t.state.currentNotificationClose && t.state.currentNotificationClose(), t.state.currentNotificationClose = e;
      }
      function $X(t, e, n) {
        JL(t, a);
        var r = QL(t, e, n && n.bottom), i = false, o, s = n && typeof n.duration < "u" ? n.duration : 5e3;
        function a() {
          i || (i = true, clearTimeout(o), r.remove(), eD(t, r));
        }
        return r.onclick = function(l) {
          l.preventDefault(), a();
        }, ZL(t, r), s && (o = setTimeout(a, s)), a;
      }
      function ZL(t, e) {
        var n = t.state.dialog;
        t.state.dialog = e, e.style.flex = "1", e && n !== e && (n && n.contains(document.activeElement) && t.focus(), n && n.parentElement ? n.parentElement.replaceChild(e, n) : n && n.remove(), Re.signal(t, "dialog"));
      }
      function eD(t, e) {
        t.state.dialog == e && (t.state.dialog = null, Re.signal(t, "dialog"));
      }
      function zX(t, e, n, r) {
        r || (r = {}), JL(t, void 0);
        var i = QL(t, e, r.bottom), o = false;
        ZL(t, i);
        function s(l) {
          if (typeof l == "string")
            a.value = l;
          else {
            if (o)
              return;
            o = true, eD(t, i), t.state.dialog || t.focus(), r.onClose && r.onClose(i);
          }
        }
        var a = i.getElementsByTagName("input")[0];
        return a && (r.value && (a.value = r.value, r.selectValueOnOpen !== false && a.select()), r.onInput && Re.on(a, "input", function(l) {
          r.onInput(l, a.value, s);
        }), r.onKeyUp && Re.on(a, "keyup", function(l) {
          r.onKeyUp(l, a.value, s);
        }), Re.on(a, "keydown", function(l) {
          r && r.onKeyDown && r.onKeyDown(l, a.value, s) || (l.keyCode == 13 && n && n(a.value), (l.keyCode == 27 || r.closeOnEnter !== false && l.keyCode == 13) && (a.blur(), Re.e_stop(l), s()));
        }), r.closeOnBlur !== false && Re.on(a, "blur", function() {
          setTimeout(function() {
            document.activeElement !== a && s();
          });
        }), a.focus()), s;
      }
      var FX = {
        "(": ")>",
        ")": "(<",
        "[": "]>",
        "]": "[<",
        "{": "}>",
        "}": "{<",
        "<": ">>",
        ">": "<<"
      };
      function VX(t) {
        return t && t.bracketRegex || /[(){}[\]]/;
      }
      function HX(t, e, n, r, i) {
        for (var o = i && i.maxScanLineLength || 1e4, s = i && i.maxScanLines || 1e3, a = [], l = VX(i), c = n > 0 ? Math.min(e.line + s, t.lastLine() + 1) : Math.max(t.firstLine() - 1, e.line - s), u = e.line; u != c; u += n) {
          var h = t.getLine(u);
          if (!!h) {
            var p = n > 0 ? 0 : h.length - 1, v = n > 0 ? h.length : -1;
            if (!(h.length > o))
              for (u == e.line && (p = e.ch - (n < 0 ? 1 : 0)); p != v; p += n) {
                var y = h.charAt(p);
                if (l.test(y)) {
                  var S = FX[y];
                  if (S && S.charAt(1) == ">" == n > 0)
                    a.push(y);
                  else if (a.length)
                    a.pop();
                  else
                    return {
                      pos: new ui(u, p),
                      ch: y
                    };
                }
              }
          }
        }
        return u - n == (n > 0 ? t.lastLine() : t.firstLine()) ? false : null;
      }
      function jX(t, e) {
        return null;
      }
      function WX(t, e) {
        var n, r, i = t.cm6.state, o = t.indexFromPos(e);
        if (o < i.doc.length) {
          var s = i.sliceDoc(o, o + 1);
          s == "<" && o++;
        }
        for (var a = DR(i, o), l = (a == null ? void 0 : a.resolve(o)) || null; l; ) {
          if (((n = l.firstChild) === null || n === void 0 ? void 0 : n.type.name) == "OpenTag" && ((r = l.lastChild) === null || r === void 0 ? void 0 : r.type.name) == "CloseTag")
            return {
              open: nM(i.doc, l.firstChild),
              close: nM(i.doc, l.lastChild)
            };
          l = l.parent;
        }
      }
      function nM(t, e) {
        return {
          from: ur(t, e.from),
          to: ur(t, e.to)
        };
      }
      class UX {
        constructor(e, n, r) {
          this.cm = e, this.id = e.$mid++, this.offset = n, this.assoc = r, e.marks[this.id] = this;
        }
        clear() {
          delete this.cm.marks[this.id];
        }
        find() {
          return this.offset == null ? null : this.cm.posFromIndex(this.offset);
        }
        update(e) {
          this.offset != null && (this.offset = e.mapPos(this.offset, this.assoc, Zt.TrackDel));
        }
      }
      function KX(t, e) {
        for (var n, r = e.column || t.getOption("textwidth") || 80, i = e.allowMerge != false, o = Math.min(e.from, e.to), s = Math.max(e.from, e.to); o <= s; ) {
          var a = t.getLine(o);
          if (a.length > r) {
            var l = y(a, r, 5);
            if (l) {
              var c = (n = /^\s*/.exec(a)) === null || n === void 0 ? void 0 : n[0];
              t.replaceRange(`
` + c, new ui(o, l.start), new ui(o, l.end));
            }
            s++;
          } else if (i && /\S/.test(a) && o != s) {
            var u = t.getLine(o + 1);
            if (u && /\S/.test(u)) {
              var h = a.replace(/\s+$/, ""), p = u.replace(/^\s+/, ""), v = h + " " + p, l = y(v, r, 5);
              l && l.start > h.length || v.length < r ? (t.replaceRange(" ", new ui(o, h.length), new ui(o + 1, u.length - p.length)), o--, s--) : h.length < a.length && t.replaceRange("", new ui(o, h.length), new ui(o, a.length));
            }
          }
          o++;
        }
        return o;
        function y(S, C, w) {
          if (!(S.length < C)) {
            var k = S.slice(0, C), T = S.slice(C), P = /^(?:(\s+)|(\S+)(\s+))/.exec(T), R = /(?:(\s+)|(\s+)(\S+))$/.exec(k), L = 0, D = 0;
            if (R && !R[2] && (L = C - R[1].length, D = C), P && !P[2] && (L || (L = C), D = C + P[1].length), L)
              return {
                start: L,
                end: D
              };
            if (R && R[2] && R.index > w)
              return {
                start: R.index,
                end: R.index + R[2].length
              };
            if (P && P[2])
              return L = C + P[2].length, {
                start: L,
                end: L + P[3].length
              };
          }
        }
      }
      let E1 = RU || function() {
        let t = {
          cursorBlinkRate: 1200
        };
        return function() {
          return t;
        };
      }();
      class qX {
        constructor(e, n, r, i, o, s, a, l, c, u) {
          this.left = e, this.top = n, this.height = r, this.fontFamily = i, this.fontSize = o, this.fontWeight = s, this.color = a, this.className = l, this.letter = c, this.partial = u;
        }
        draw() {
          let e = document.createElement("div");
          return e.className = this.className, this.adjust(e), e;
        }
        adjust(e) {
          e.style.left = this.left + "px", e.style.top = this.top + "px", e.style.height = this.height + "px", e.style.lineHeight = this.height + "px", e.style.fontFamily = this.fontFamily, e.style.fontSize = this.fontSize, e.style.fontWeight = this.fontWeight, e.style.color = this.partial ? "transparent" : this.color, e.className = this.className, e.textContent = this.letter;
        }
        eq(e) {
          return this.left == e.left && this.top == e.top && this.height == e.height && this.fontFamily == e.fontFamily && this.fontSize == e.fontSize && this.fontWeight == e.fontWeight && this.color == e.color && this.className == e.className && this.letter == e.letter;
        }
      }
      class GX {
        constructor(e, n) {
          this.view = e, this.rangePieces = [], this.cursors = [], this.cm = n, this.measureReq = {
            read: this.readPos.bind(this),
            write: this.drawSel.bind(this)
          }, this.cursorLayer = e.scrollDOM.appendChild(document.createElement("div")), this.cursorLayer.className = "cm-cursorLayer cm-vimCursorLayer", this.cursorLayer.setAttribute("aria-hidden", "true"), e.requestMeasure(this.measureReq), this.setBlinkRate();
        }
        setBlinkRate() {
          let n = E1(this.cm.cm6.state).cursorBlinkRate;
          this.cursorLayer.style.animationDuration = n + "ms";
        }
        update(e) {
          (e.selectionSet || e.geometryChanged || e.viewportChanged) && (this.view.requestMeasure(this.measureReq), this.cursorLayer.style.animationName = this.cursorLayer.style.animationName == "cm-blink" ? "cm-blink2" : "cm-blink"), YX(e) && this.setBlinkRate();
        }
        scheduleRedraw() {
          this.view.requestMeasure(this.measureReq);
        }
        readPos() {
          let { state: e } = this.view, n = [];
          for (let r of e.selection.ranges) {
            let i = r == e.selection.main, o = ZX(this.cm, this.view, r, i);
            o && n.push(o);
          }
          return {
            cursors: n
          };
        }
        drawSel({ cursors: e }) {
          if (e.length != this.cursors.length || e.some((n, r) => !n.eq(this.cursors[r]))) {
            let n = this.cursorLayer.children;
            if (n.length !== e.length) {
              this.cursorLayer.textContent = "";
              for (const r of e)
                this.cursorLayer.appendChild(r.draw());
            } else
              e.forEach((r, i) => r.adjust(n[i]));
            this.cursors = e;
          }
        }
        destroy() {
          this.cursorLayer.remove();
        }
      }
      function YX(t) {
        return E1(t.startState) != E1(t.state);
      }
      const XX = {
        ".cm-vimMode .cm-line": {
          "& ::selection": {
            backgroundColor: "transparent !important"
          },
          "&::selection": {
            backgroundColor: "transparent !important"
          },
          caretColor: "transparent !important"
        },
        ".cm-fat-cursor": {
          position: "absolute",
          background: "#ff9696",
          border: "none",
          whiteSpace: "pre"
        },
        "&:not(.cm-focused) .cm-fat-cursor": {
          background: "none",
          outline: "solid 1px #ff9696",
          color: "transparent !important"
        }
      }, QX = ns.highest(ce.theme(XX));
      function JX(t) {
        let e = t.scrollDOM.getBoundingClientRect();
        return {
          left: (t.textDirection == rt.LTR ? e.left : e.right - t.scrollDOM.clientWidth) - t.scrollDOM.scrollLeft * t.scaleX,
          top: e.top - t.scrollDOM.scrollTop * t.scaleY
        };
      }
      function ZX(t, e, n, r) {
        var i, o, s, a;
        let l = n.head, c = false, u = 1, h = t.state.vim;
        if (h && (!h.insertMode || t.state.overwrite)) {
          if (c = true, h.visualBlock && !r)
            return null;
          n.anchor < n.head && (l < e.state.doc.length && e.state.sliceDoc(l, l + 1)) != `
` && l--, t.state.overwrite ? u = 0.2 : h.status && (u = 0.5);
        }
        if (c) {
          let v = l < e.state.doc.length && e.state.sliceDoc(l, l + 1);
          v && /[\uDC00-\uDFFF]/.test(v) && l > 1 && (l--, v = e.state.sliceDoc(l, l + 1));
          let y = e.coordsAtPos(l, 1);
          if (!y)
            return null;
          let S = JX(e), C = e.domAtPos(l), w = C ? C.node : e.contentDOM;
          for (w instanceof Text && C.offset >= w.data.length && !((i = w.parentElement) === null || i === void 0) && i.nextSibling && (w = (o = w.parentElement) === null || o === void 0 ? void 0 : o.nextSibling, C = {
            node: w,
            offset: 0
          }); C && C.node instanceof HTMLElement; )
            w = C.node, C = {
              node: C.node.childNodes[C.offset],
              offset: 0
            };
          if (!(w instanceof HTMLElement)) {
            if (!w.parentNode)
              return null;
            w = w.parentNode;
          }
          let k = getComputedStyle(w), T = y.left, P = (a = (s = e).coordsForChar) === null || a === void 0 ? void 0 : a.call(s, l);
          if (P && (T = P.left), !v || v == `
` || v == "\r")
            v = "\xA0";
          else if (v == "	") {
            v = "\xA0";
            var p = e.coordsAtPos(l + 1, -1);
            p && (T = p.left - (p.left - y.left) / parseInt(k.tabSize));
          } else
            /[\uD800-\uDBFF]/.test(v) && l < e.state.doc.length - 1 && (v += e.state.sliceDoc(l + 1, l + 2));
          let R = y.bottom - y.top;
          return new qX((T - S.left) / e.scaleX, (y.top - S.top + R * (1 - u)) / e.scaleY, R * u / e.scaleY, k.fontFamily, k.fontSize, k.fontWeight, k.color, r ? "cm-fat-cursor cm-cursor-primary" : "cm-fat-cursor cm-cursor-secondary", v, u != 1);
        } else
          return null;
      }
      var eQ = typeof navigator < "u" && /linux/i.test(navigator.platform) && / Gecko\/\d+/.exec(navigator.userAgent);
      const ms = BX(Re), tQ = 250, nQ = ce.baseTheme({
        ".cm-vimMode .cm-cursorLayer:not(.cm-vimCursorLayer)": {
          display: "none"
        },
        ".cm-vim-panel": {
          padding: "0px 10px",
          fontFamily: "monospace",
          minHeight: "1.3em",
          display: "flex"
        },
        ".cm-vim-panel input": {
          border: "none",
          outline: "none",
          backgroundColor: "inherit"
        },
        "&light .cm-searchMatch": {
          backgroundColor: "#ffff0054"
        },
        "&dark .cm-searchMatch": {
          backgroundColor: "#00ffff8a"
        }
      }), rQ = Ct.fromClass(class {
        constructor(t) {
          this.status = "", this.query = null, this.decorations = be.none, this.waitForCopy = false, this.lastKeydown = "", this.useNextTextInput = false, this.compositionText = "", this.view = t;
          const e = this.cm = new Re(t);
          ms.enterVimMode(this.cm), this.view.cm = this.cm, this.cm.state.vimPlugin = this, this.blockCursor = new GX(t, e), this.updateClass(), this.cm.on("vim-command-done", () => {
            e.state.vim && (e.state.vim.status = ""), this.blockCursor.scheduleRedraw(), this.updateStatus();
          }), this.cm.on("vim-mode-change", (n) => {
            !e.state.vim || (e.state.vim.mode = n.mode, n.subMode && (e.state.vim.mode += " block"), e.state.vim.status = "", this.blockCursor.scheduleRedraw(), this.updateClass(), this.updateStatus());
          }), this.cm.on("dialog", () => {
            this.cm.state.statusbar ? this.updateStatus() : t.dispatch({
              effects: tD.of(!!this.cm.state.dialog)
            });
          }), this.dom = document.createElement("span"), this.spacer = document.createElement("span"), this.spacer.style.flex = "1", this.statusButton = document.createElement("span"), this.statusButton.onclick = (n) => {
            ms.handleKey(this.cm, "<Esc>", "user"), this.cm.focus();
          }, this.statusButton.style.cssText = "cursor: pointer";
        }
        update(t) {
          var e;
          if ((t.viewportChanged || t.docChanged) && this.query && this.highlight(this.query), t.docChanged && this.cm.onChange(t), t.selectionSet && this.cm.onSelectionChange(), t.viewportChanged, this.cm.curOp && !this.cm.curOp.isVimOp && this.cm.onBeforeEndOperation(), t.transactions) {
            for (let n of t.transactions)
              for (let r of n.effects)
                if (r.is(Jo))
                  if (!((e = r.value) === null || e === void 0 ? void 0 : e.forVim))
                    this.highlight(null);
                  else {
                    let o = r.value.create();
                    this.highlight(o);
                  }
          }
          this.blockCursor.update(t);
        }
        updateClass() {
          const t = this.cm.state;
          !t.vim || t.vim.insertMode && !t.overwrite ? this.view.scrollDOM.classList.remove("cm-vimMode") : this.view.scrollDOM.classList.add("cm-vimMode");
        }
        updateStatus() {
          let t = this.cm.state.statusbar, e = this.cm.state.vim;
          if (!t || !e)
            return;
          let n = this.cm.state.dialog;
          if (n)
            n.parentElement != t && (t.textContent = "", t.appendChild(n));
          else {
            t.textContent = "";
            var r = (e.mode || "normal").toUpperCase();
            e.insertModeReturn && (r += "(C-O)"), this.statusButton.textContent = `--${r}--`, t.appendChild(this.statusButton), t.appendChild(this.spacer);
          }
          this.dom.textContent = e.status, t.appendChild(this.dom);
        }
        destroy() {
          ms.leaveVimMode(this.cm), this.updateClass(), this.blockCursor.destroy(), delete this.view.cm;
        }
        highlight(t) {
          if (this.query = t, !t)
            return this.decorations = be.none;
          let { view: e } = this, n = new Ci();
          for (let r = 0, i = e.visibleRanges, o = i.length; r < o; r++) {
            let { from: s, to: a } = i[r];
            for (; r < o - 1 && a > i[r + 1].from - 2 * tQ; )
              a = i[++r].to;
            t.highlight(e.state, s, a, (l, c) => {
              n.add(l, c, oQ);
            });
          }
          return this.decorations = n.finish();
        }
        handleKey(t, e) {
          const n = this.cm;
          let r = n.state.vim;
          if (!r)
            return;
          const i = ms.vimKeyFromEvent(t, r);
          if (Re.signal(this.cm, "inputEvent", {
            type: "handleKey",
            key: i
          }), !i)
            return;
          if (i == "<Esc>" && !r.insertMode && !r.visualMode && this.query) {
            const a = r.searchState_;
            a && (n.removeOverlay(a.getOverlay()), a.setOverlay(null));
          }
          if (i === "<C-c>" && !Re.isMac && n.somethingSelected())
            return this.waitForCopy = true, true;
          r.status = (r.status || "") + i;
          let s = ms.multiSelectHandleKey(n, i, "user");
          return r = ms.maybeInitVimState_(n), !s && r.insertMode && n.state.overwrite && (t.key && t.key.length == 1 && !/\n/.test(t.key) ? (s = true, n.overWriteSelection(t.key)) : t.key == "Backspace" && (s = true, Re.commands.cursorCharLeft(n))), s && (Re.signal(this.cm, "vim-keypress", i), t.preventDefault(), t.stopPropagation(), this.blockCursor.scheduleRedraw()), this.updateStatus(), !!s;
        }
      }, {
        eventHandlers: {
          copy: function(t, e) {
            !this.waitForCopy || (this.waitForCopy = false, Promise.resolve().then(() => {
              var n = this.cm, r = n.state.vim;
              !r || (r.insertMode ? n.setSelection(n.getCursor(), n.getCursor()) : n.operation(() => {
                n.curOp && (n.curOp.isVimOp = true), ms.handleKey(n, "<Esc>", "user");
              }));
            }));
          },
          compositionstart: function(t, e) {
            this.useNextTextInput = true, Re.signal(this.cm, "inputEvent", t);
          },
          compositionupdate: function(t, e) {
            Re.signal(this.cm, "inputEvent", t);
          },
          compositionend: function(t, e) {
            Re.signal(this.cm, "inputEvent", t);
          },
          keypress: function(t, e) {
            Re.signal(this.cm, "inputEvent", t), this.lastKeydown == "Dead" && this.handleKey(t, e);
          },
          keydown: function(t, e) {
            Re.signal(this.cm, "inputEvent", t), this.lastKeydown = t.key, this.lastKeydown == "Unidentified" || this.lastKeydown == "Process" || this.lastKeydown == "Dead" ? this.useNextTextInput = true : (this.useNextTextInput = false, this.handleKey(t, e));
          }
        },
        provide: () => [
          ce.inputHandler.of((t, e, n, r) => {
            var i, o, s = uQ(t);
            if (!s)
              return false;
            var a = (i = s.state) === null || i === void 0 ? void 0 : i.vim, l = s.state.vimPlugin;
            if (a && !a.insertMode && !(!((o = s.curOp) === null || o === void 0) && o.isVimOp)) {
              if (r === "\0\0")
                return true;
              if (Re.signal(s, "inputEvent", {
                type: "text",
                text: r,
                from: e,
                to: n
              }), r.length == 1 && l.useNextTextInput) {
                if (a.expectLiteralNext && t.composing)
                  return l.compositionText = r, false;
                if (l.compositionText) {
                  var c = l.compositionText;
                  l.compositionText = "";
                  var u = t.state.selection.main.head, h = t.state.sliceDoc(u - c.length, u);
                  if (c === h) {
                    var p = s.getCursor();
                    s.replaceRange("", s.posFromIndex(u - c.length), p);
                  }
                }
                return l.handleKey({
                  key: r,
                  preventDefault: () => {
                  },
                  stopPropagation: () => {
                  }
                }), iQ(t), true;
              }
            }
            return false;
          })
        ],
        decorations: (t) => t.decorations
      });
      function iQ(t) {
        var e = t.scrollDOM.parentElement;
        if (!!e) {
          if (eQ) {
            t.contentDOM.textContent = "\0\0", t.contentDOM.dispatchEvent(new CustomEvent("compositionend"));
            return;
          }
          var n = t.scrollDOM.nextSibling, r = window.getSelection(), i = r && {
            anchorNode: r.anchorNode,
            anchorOffset: r.anchorOffset,
            focusNode: r.focusNode,
            focusOffset: r.focusOffset
          };
          t.scrollDOM.remove(), e.insertBefore(t.scrollDOM, n);
          try {
            i && r && (r.setPosition(i.anchorNode, i.anchorOffset), i.focusNode && r.extend(i.focusNode, i.focusOffset));
          } catch (o) {
            console.error(o);
          }
          t.focus(), t.contentDOM.dispatchEvent(new CustomEvent("compositionend"));
        }
      }
      const oQ = be.mark({
        class: "cm-searchMatch"
      }), tD = Pe.define(), sQ = Ut.define({
        create: () => false,
        update(t, e) {
          for (let n of e.effects)
            n.is(tD) && (t = n.value);
          return t;
        },
        provide: (t) => Ks.from(t, (e) => e ? aQ : null)
      });
      function aQ(t) {
        let e = document.createElement("div");
        e.className = "cm-vim-panel";
        let n = t.cm;
        return n.state.dialog && e.appendChild(n.state.dialog), {
          top: false,
          dom: e
        };
      }
      function lQ(t) {
        let e = document.createElement("div");
        e.className = "cm-vim-panel";
        let n = t.cm;
        return n.state.statusbar = e, n.state.vimPlugin.updateStatus(), {
          dom: e
        };
      }
      function cQ(t = {}) {
        return [
          nQ,
          rQ,
          QX,
          t.status ? Ks.of(lQ) : sQ
        ];
      }
      function uQ(t) {
        return t.cm || null;
      }
      function rM(t) {
        return Z(qL, {
          ...t == null ? void 0 : t.extra,
          value: t == null ? void 0 : t.code,
          height: "100%",
          extensions: [
            cQ()
          ],
          onChange: t == null ? void 0 : t.onChange
        });
      }
      var fQ = "Expected a function", iM = 0 / 0, hQ = "[object Symbol]", dQ = /^\s+|\s+$/g, pQ = /^[-+]0x[0-9a-f]+$/i, mQ = /^0b[01]+$/i, gQ = /^0o[0-7]+$/i, vQ = parseInt, yQ = typeof Ao == "object" && Ao && Ao.Object === Object && Ao, bQ = typeof self == "object" && self && self.Object === Object && self, xQ = yQ || bQ || Function("return this")(), SQ = Object.prototype, wQ = SQ.toString, kQ = Math.max, CQ = Math.min, nv = function() {
        return xQ.Date.now();
      };
      function TQ(t, e, n) {
        var r, i, o, s, a, l, c = 0, u = false, h = false, p = true;
        if (typeof t != "function")
          throw new TypeError(fQ);
        e = oM(e) || 0, P1(n) && (u = !!n.leading, h = "maxWait" in n, o = h ? kQ(oM(n.maxWait) || 0, e) : o, p = "trailing" in n ? !!n.trailing : p);
        function v(L) {
          var D = r, F = i;
          return r = i = void 0, c = L, s = t.apply(F, D), s;
        }
        function y(L) {
          return c = L, a = setTimeout(w, e), u ? v(L) : s;
        }
        function S(L) {
          var D = L - l, F = L - c, K = e - D;
          return h ? CQ(K, o - F) : K;
        }
        function C(L) {
          var D = L - l, F = L - c;
          return l === void 0 || D >= e || D < 0 || h && F >= o;
        }
        function w() {
          var L = nv();
          if (C(L))
            return k(L);
          a = setTimeout(w, S(L));
        }
        function k(L) {
          return a = void 0, p && r ? v(L) : (r = i = void 0, s);
        }
        function T() {
          a !== void 0 && clearTimeout(a), c = 0, r = l = i = a = void 0;
        }
        function P() {
          return a === void 0 ? s : k(nv());
        }
        function R() {
          var L = nv(), D = C(L);
          if (r = arguments, i = this, l = L, D) {
            if (a === void 0)
              return y(l);
            if (h)
              return a = setTimeout(w, e), v(l);
          }
          return a === void 0 && (a = setTimeout(w, e)), s;
        }
        return R.cancel = T, R.flush = P, R;
      }
      function P1(t) {
        var e = typeof t;
        return !!t && (e == "object" || e == "function");
      }
      function MQ(t) {
        return !!t && typeof t == "object";
      }
      function AQ(t) {
        return typeof t == "symbol" || MQ(t) && wQ.call(t) == hQ;
      }
      function oM(t) {
        if (typeof t == "number")
          return t;
        if (AQ(t))
          return iM;
        if (P1(t)) {
          var e = typeof t.valueOf == "function" ? t.valueOf() : t;
          t = P1(e) ? e + "" : e;
        }
        if (typeof t != "string")
          return t === 0 ? t : +t;
        t = t.replace(dQ, "");
        var n = mQ.test(t);
        return n || gQ.test(t) ? vQ(t.slice(2), n ? 2 : 8) : pQ.test(t) ? iM : +t;
      }
      var EQ = TQ;
      const PQ = async (t = {}, e) => {
        let n;
        if (e.startsWith("data:")) {
          const r = e.replace(/^data:.*?base64,/, "");
          let i;
          if (typeof Buffer == "function" && typeof Buffer.from == "function")
            i = Buffer.from(r, "base64");
          else if (typeof atob == "function") {
            const o = atob(r);
            i = new Uint8Array(o.length);
            for (let s = 0; s < o.length; s++)
              i[s] = o.charCodeAt(s);
          } else
            throw new Error("Cannot decode base64-encoded data URL");
          n = await WebAssembly.instantiate(i, t);
        } else {
          const r = await fetch(e), i = r.headers.get("Content-Type") || "";
          if ("instantiateStreaming" in WebAssembly && i.startsWith("application/wasm"))
            n = await WebAssembly.instantiateStreaming(r, t);
          else {
            const o = await r.arrayBuffer();
            n = await WebAssembly.instantiate(o, t);
          }
        }
        return n.instance.exports;
      }, Vi = new Array(32).fill(void 0);
      Vi.push(void 0, null, true, false);
      function nD(t) {
        return Vi[t];
      }
      let eu = Vi.length;
      function OQ(t) {
        t < 36 || (Vi[t] = eu, eu = t);
      }
      function RQ(t) {
        const e = nD(t);
        return OQ(t), e;
      }
      const LQ = typeof TextDecoder > "u" ? (0, module.require)("util").TextDecoder : TextDecoder;
      let rD = new LQ("utf-8", {
        ignoreBOM: true,
        fatal: true
      });
      rD.decode();
      let Fh = null;
      function Ed() {
        return (Fh === null || Fh.buffer !== jp.buffer) && (Fh = new Uint8Array(jp.buffer)), Fh;
      }
      function aS(t, e) {
        return rD.decode(Ed().subarray(t, t + e));
      }
      let Vp = 0;
      const DQ = typeof TextEncoder > "u" ? (0, module.require)("util").TextEncoder : TextEncoder;
      let Pd = new DQ("utf-8");
      const _Q = typeof Pd.encodeInto == "function" ? function(t, e) {
        return Pd.encodeInto(t, e);
      } : function(t, e) {
        const n = Pd.encode(t);
        return e.set(n), {
          read: t.length,
          written: n.length
        };
      };
      function iD(t, e, n) {
        if (n === void 0) {
          const a = Pd.encode(t), l = e(a.length);
          return Ed().subarray(l, l + a.length).set(a), Vp = a.length, l;
        }
        let r = t.length, i = e(r);
        const o = Ed();
        let s = 0;
        for (; s < r; s++) {
          const a = t.charCodeAt(s);
          if (a > 127)
            break;
          o[i + s] = a;
        }
        if (s !== r) {
          s !== 0 && (t = t.slice(s)), i = n(i, r, r = s + t.length * 3);
          const a = Ed().subarray(i + s, i + r), l = _Q(t, a);
          s += l.written;
        }
        return Vp = s, i;
      }
      let Vh = null;
      function Hp() {
        return (Vh === null || Vh.buffer !== jp.buffer) && (Vh = new Int32Array(jp.buffer)), Vh;
      }
      function IQ(t) {
        try {
          const r = sM(-16), i = iD(t, oD, sD);
          HQ(r, i, Vp);
          var e = Hp()[r / 4 + 0], n = Hp()[r / 4 + 1];
          return aS(e, n);
        } finally {
          sM(16), aD(e, n);
        }
      }
      function BQ(t) {
        eu === Vi.length && Vi.push(Vi.length + 1);
        const e = eu;
        return eu = Vi[e], Vi[e] = t, e;
      }
      function NQ() {
        const t = new Error();
        return BQ(t);
      }
      function $Q(t, e) {
        const n = nD(e).stack, r = iD(n, oD, sD), i = Vp;
        Hp()[t / 4 + 1] = i, Hp()[t / 4 + 0] = r;
      }
      function zQ(t, e) {
        try {
          console.error(aS(t, e));
        } finally {
          aD(t, e);
        }
      }
      function FQ(t) {
        RQ(t);
      }
      function VQ(t, e) {
        throw new Error(aS(t, e));
      }
      const Qs = await PQ({
        "./monkey_wasm_bg.js": {
          __wbg_new_693216e109162396: NQ,
          __wbg_stack_0ddaca5d1abfb52f: $Q,
          __wbg_error_09919627ac0992f5: zQ,
          __wbindgen_object_drop_ref: FQ,
          __wbindgen_throw: VQ
        }
      }, "/monkey-rust/assets/monkey_wasm_bg.b0ae1639.wasm?init"), jp = Qs.memory;
      Qs.parse;
      const HQ = Qs.compile, sM = Qs.__wbindgen_add_to_stack_pointer, oD = Qs.__wbindgen_malloc, sD = Qs.__wbindgen_realloc, aD = Qs.__wbindgen_free, jQ = `
1 + 1;
if (true) { 10 }; 3333;
let a = [1, 2, 3];
`;
      function WQ() {
        let t = jQ.trimStart(), [e] = z.exports.useState(t);
        const n = (a) => {
          console.log(a), e = a, s(), console.log("change finished");
        };
        let [r, i] = z.exports.useState("");
        const o = () => {
          try {
            const a = IQ(e);
            i(a);
          } catch (a) {
            i(a.toString());
          }
        }, s = z.exports.useMemo(() => EQ(o, 200), [
          o
        ]);
        return z.exports.useEffect(() => {
          o();
        }, []), Xn(QP, {
          templateColumns: "repeat(2, 1fr)",
          height: "100vh",
          gap: 6,
          children: [
            Z(rM, {
              onChange: n,
              code: e
            }),
            Xn(eO, {
              size: "md",
              variant: "enclosed",
              children: [
                Z(nO, {
                  children: Z(tO, {
                    children: "Bytecode"
                  })
                }),
                Xn(rO, {
                  children: [
                    Z(Ry, {
                      padding: 0,
                      children: Z(rM, {
                        code: r,
                        extra: {
                          readOnly: true,
                          editable: false
                        }
                      })
                    }),
                    Z(Ry, {
                      children: Z("p", {
                        children: "two!"
                      })
                    })
                  ]
                })
              ]
            })
          ]
        });
      }
      rv.createRoot(document.getElementById("root")).render(Z(Wp.StrictMode, {
        children: Z(sW, {
          children: Z(WQ, {})
        })
      }));
    })();
  }
});
export default require_stdin();
