(async () => {
  var _a2, _b2, _c2, _d2, _e2, _f, _g2, _h2, _i, _j2, _k2, _l, _m2, _n2, _o2, _p2, _q2;
  function s_(t, e) {
    for (var n = 0; n < e.length; n++) {
      const r = e[n];
      if (typeof r != "string" && !Array.isArray(r)) {
        for (const i in r)
          if (i !== "default" && !(i in t)) {
            const o = Object.getOwnPropertyDescriptor(r, i);
            o && Object.defineProperty(t, i, o.get ? o : {
              enumerable: true,
              get: () => r[i]
            });
          }
      }
    }
    return Object.freeze(Object.defineProperty(t, Symbol.toStringTag, {
      value: "Module"
    }));
  }
  (function() {
    const e = document.createElement("link").relList;
    if (e && e.supports && e.supports("modulepreload"))
      return;
    for (const i of document.querySelectorAll('link[rel="modulepreload"]'))
      r(i);
    new MutationObserver((i) => {
      for (const o of i)
        if (o.type === "childList")
          for (const s of o.addedNodes)
            s.tagName === "LINK" && s.rel === "modulepreload" && r(s);
    }).observe(document, {
      childList: true,
      subtree: true
    });
    function n(i) {
      const o = {};
      return i.integrity && (o.integrity = i.integrity), i.referrerpolicy && (o.referrerPolicy = i.referrerpolicy), i.crossorigin === "use-credentials" ? o.credentials = "include" : i.crossorigin === "anonymous" ? o.credentials = "omit" : o.credentials = "same-origin", o;
    }
    function r(i) {
      if (i.ep)
        return;
      i.ep = true;
      const o = n(i);
      fetch(i.href, o);
    }
  })();
  var Ao = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
  function a_(t) {
    return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, "default") ? t.default : t;
  }
  var z = {
    exports: {}
  }, Be = {};
  var qu = Symbol.for("react.element"), l_ = Symbol.for("react.portal"), c_ = Symbol.for("react.fragment"), u_ = Symbol.for("react.strict_mode"), f_ = Symbol.for("react.profiler"), h_ = Symbol.for("react.provider"), d_ = Symbol.for("react.context"), p_ = Symbol.for("react.forward_ref"), m_ = Symbol.for("react.suspense"), g_ = Symbol.for("react.memo"), v_ = Symbol.for("react.lazy"), gS = Symbol.iterator;
  function y_(t) {
    return t === null || typeof t != "object" ? null : (t = gS && t[gS] || t["@@iterator"], typeof t == "function" ? t : null);
  }
  var hM = {
    isMounted: function() {
      return false;
    },
    enqueueForceUpdate: function() {
    },
    enqueueReplaceState: function() {
    },
    enqueueSetState: function() {
    }
  }, dM = Object.assign, pM = {};
  function wl(t, e, n) {
    this.props = t, this.context = e, this.refs = pM, this.updater = n || hM;
  }
  wl.prototype.isReactComponent = {};
  wl.prototype.setState = function(t, e) {
    if (typeof t != "object" && typeof t != "function" && t != null)
      throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
    this.updater.enqueueSetState(this, t, e, "setState");
  };
  wl.prototype.forceUpdate = function(t) {
    this.updater.enqueueForceUpdate(this, t, "forceUpdate");
  };
  function mM() {
  }
  mM.prototype = wl.prototype;
  function I1(t, e, n) {
    this.props = t, this.context = e, this.refs = pM, this.updater = n || hM;
  }
  var B1 = I1.prototype = new mM();
  B1.constructor = I1;
  dM(B1, wl.prototype);
  B1.isPureReactComponent = true;
  var vS = Array.isArray, gM = Object.prototype.hasOwnProperty, N1 = {
    current: null
  }, vM = {
    key: true,
    ref: true,
    __self: true,
    __source: true
  };
  function yM(t, e, n) {
    var r, i = {}, o = null, s = null;
    if (e != null)
      for (r in e.ref !== void 0 && (s = e.ref), e.key !== void 0 && (o = "" + e.key), e)
        gM.call(e, r) && !vM.hasOwnProperty(r) && (i[r] = e[r]);
    var a = arguments.length - 2;
    if (a === 1)
      i.children = n;
    else if (1 < a) {
      for (var l = Array(a), c = 0; c < a; c++)
        l[c] = arguments[c + 2];
      i.children = l;
    }
    if (t && t.defaultProps)
      for (r in a = t.defaultProps, a)
        i[r] === void 0 && (i[r] = a[r]);
    return {
      $$typeof: qu,
      type: t,
      key: o,
      ref: s,
      props: i,
      _owner: N1.current
    };
  }
  function b_(t, e) {
    return {
      $$typeof: qu,
      type: t.type,
      key: e,
      ref: t.ref,
      props: t.props,
      _owner: t._owner
    };
  }
  function $1(t) {
    return typeof t == "object" && t !== null && t.$$typeof === qu;
  }
  function x_(t) {
    var e = {
      "=": "=0",
      ":": "=2"
    };
    return "$" + t.replace(/[=:]/g, function(n) {
      return e[n];
    });
  }
  var yS = /\/+/g;
  function Ag(t, e) {
    return typeof t == "object" && t !== null && t.key != null ? x_("" + t.key) : e.toString(36);
  }
  function jh(t, e, n, r, i) {
    var o = typeof t;
    (o === "undefined" || o === "boolean") && (t = null);
    var s = false;
    if (t === null)
      s = true;
    else
      switch (o) {
        case "string":
        case "number":
          s = true;
          break;
        case "object":
          switch (t.$$typeof) {
            case qu:
            case l_:
              s = true;
          }
      }
    if (s)
      return s = t, i = i(s), t = r === "" ? "." + Ag(s, 0) : r, vS(i) ? (n = "", t != null && (n = t.replace(yS, "$&/") + "/"), jh(i, e, n, "", function(c) {
        return c;
      })) : i != null && ($1(i) && (i = b_(i, n + (!i.key || s && s.key === i.key ? "" : ("" + i.key).replace(yS, "$&/") + "/") + t)), e.push(i)), 1;
    if (s = 0, r = r === "" ? "." : r + ":", vS(t))
      for (var a = 0; a < t.length; a++) {
        o = t[a];
        var l = r + Ag(o, a);
        s += jh(o, e, n, l, i);
      }
    else if (l = y_(t), typeof l == "function")
      for (t = l.call(t), a = 0; !(o = t.next()).done; )
        o = o.value, l = r + Ag(o, a++), s += jh(o, e, n, l, i);
    else if (o === "object")
      throw e = String(t), Error("Objects are not valid as a React child (found: " + (e === "[object Object]" ? "object with keys {" + Object.keys(t).join(", ") + "}" : e) + "). If you meant to render a collection of children, use an array instead.");
    return s;
  }
  function Wf(t, e, n) {
    if (t == null)
      return t;
    var r = [], i = 0;
    return jh(t, r, "", "", function(o) {
      return e.call(n, o, i++);
    }), r;
  }
  function S_(t) {
    if (t._status === -1) {
      var e = t._result;
      e = e(), e.then(function(n) {
        (t._status === 0 || t._status === -1) && (t._status = 1, t._result = n);
      }, function(n) {
        (t._status === 0 || t._status === -1) && (t._status = 2, t._result = n);
      }), t._status === -1 && (t._status = 0, t._result = e);
    }
    if (t._status === 1)
      return t._result.default;
    throw t._result;
  }
  var Cn = {
    current: null
  }, Uh = {
    transition: null
  }, w_ = {
    ReactCurrentDispatcher: Cn,
    ReactCurrentBatchConfig: Uh,
    ReactCurrentOwner: N1
  };
  Be.Children = {
    map: Wf,
    forEach: function(t, e, n) {
      Wf(t, function() {
        e.apply(this, arguments);
      }, n);
    },
    count: function(t) {
      var e = 0;
      return Wf(t, function() {
        e++;
      }), e;
    },
    toArray: function(t) {
      return Wf(t, function(e) {
        return e;
      }) || [];
    },
    only: function(t) {
      if (!$1(t))
        throw Error("React.Children.only expected to receive a single React element child.");
      return t;
    }
  };
  Be.Component = wl;
  Be.Fragment = c_;
  Be.Profiler = f_;
  Be.PureComponent = I1;
  Be.StrictMode = u_;
  Be.Suspense = m_;
  Be.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = w_;
  Be.cloneElement = function(t, e, n) {
    if (t == null)
      throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + t + ".");
    var r = dM({}, t.props), i = t.key, o = t.ref, s = t._owner;
    if (e != null) {
      if (e.ref !== void 0 && (o = e.ref, s = N1.current), e.key !== void 0 && (i = "" + e.key), t.type && t.type.defaultProps)
        var a = t.type.defaultProps;
      for (l in e)
        gM.call(e, l) && !vM.hasOwnProperty(l) && (r[l] = e[l] === void 0 && a !== void 0 ? a[l] : e[l]);
    }
    var l = arguments.length - 2;
    if (l === 1)
      r.children = n;
    else if (1 < l) {
      a = Array(l);
      for (var c = 0; c < l; c++)
        a[c] = arguments[c + 2];
      r.children = a;
    }
    return {
      $$typeof: qu,
      type: t.type,
      key: i,
      ref: o,
      props: r,
      _owner: s
    };
  };
  Be.createContext = function(t) {
    return t = {
      $$typeof: d_,
      _currentValue: t,
      _currentValue2: t,
      _threadCount: 0,
      Provider: null,
      Consumer: null,
      _defaultValue: null,
      _globalName: null
    }, t.Provider = {
      $$typeof: h_,
      _context: t
    }, t.Consumer = t;
  };
  Be.createElement = yM;
  Be.createFactory = function(t) {
    var e = yM.bind(null, t);
    return e.type = t, e;
  };
  Be.createRef = function() {
    return {
      current: null
    };
  };
  Be.forwardRef = function(t) {
    return {
      $$typeof: p_,
      render: t
    };
  };
  Be.isValidElement = $1;
  Be.lazy = function(t) {
    return {
      $$typeof: v_,
      _payload: {
        _status: -1,
        _result: t
      },
      _init: S_
    };
  };
  Be.memo = function(t, e) {
    return {
      $$typeof: g_,
      type: t,
      compare: e === void 0 ? null : e
    };
  };
  Be.startTransition = function(t) {
    var e = Uh.transition;
    Uh.transition = {};
    try {
      t();
    } finally {
      Uh.transition = e;
    }
  };
  Be.unstable_act = function() {
    throw Error("act(...) is not supported in production builds of React.");
  };
  Be.useCallback = function(t, e) {
    return Cn.current.useCallback(t, e);
  };
  Be.useContext = function(t) {
    return Cn.current.useContext(t);
  };
  Be.useDebugValue = function() {
  };
  Be.useDeferredValue = function(t) {
    return Cn.current.useDeferredValue(t);
  };
  Be.useEffect = function(t, e) {
    return Cn.current.useEffect(t, e);
  };
  Be.useId = function() {
    return Cn.current.useId();
  };
  Be.useImperativeHandle = function(t, e, n) {
    return Cn.current.useImperativeHandle(t, e, n);
  };
  Be.useInsertionEffect = function(t, e) {
    return Cn.current.useInsertionEffect(t, e);
  };
  Be.useLayoutEffect = function(t, e) {
    return Cn.current.useLayoutEffect(t, e);
  };
  Be.useMemo = function(t, e) {
    return Cn.current.useMemo(t, e);
  };
  Be.useReducer = function(t, e, n) {
    return Cn.current.useReducer(t, e, n);
  };
  Be.useRef = function(t) {
    return Cn.current.useRef(t);
  };
  Be.useState = function(t) {
    return Cn.current.useState(t);
  };
  Be.useSyncExternalStore = function(t, e, n) {
    return Cn.current.useSyncExternalStore(t, e, n);
  };
  Be.useTransition = function() {
    return Cn.current.useTransition();
  };
  Be.version = "18.2.0";
  (function(t) {
    t.exports = Be;
  })(z);
  const Wp = a_(z.exports), bS = s_({
    __proto__: null,
    default: Wp
  }, [
    z.exports
  ]);
  var uv = {}, Hp = {
    exports: {}
  }, Jn = {}, bM = {
    exports: {}
  }, xM = {};
  (function(t) {
    function e(V, oe) {
      var he = V.length;
      V.push(oe);
      e:
        for (; 0 < he; ) {
          var Se = he - 1 >>> 1, ve = V[Se];
          if (0 < i(ve, oe))
            V[Se] = oe, V[he] = ve, he = Se;
          else
            break e;
        }
    }
    function n(V) {
      return V.length === 0 ? null : V[0];
    }
    function r(V) {
      if (V.length === 0)
        return null;
      var oe = V[0], he = V.pop();
      if (he !== oe) {
        V[0] = he;
        e:
          for (var Se = 0, ve = V.length, le = ve >>> 1; Se < le; ) {
            var re = 2 * (Se + 1) - 1, se = V[re], De = re + 1, vt = V[De];
            if (0 > i(se, he))
              De < ve && 0 > i(vt, se) ? (V[Se] = vt, V[De] = he, Se = De) : (V[Se] = se, V[re] = he, Se = re);
            else if (De < ve && 0 > i(vt, he))
              V[Se] = vt, V[De] = he, Se = De;
            else
              break e;
          }
      }
      return oe;
    }
    function i(V, oe) {
      var he = V.sortIndex - oe.sortIndex;
      return he !== 0 ? he : V.id - oe.id;
    }
    if (typeof performance == "object" && typeof performance.now == "function") {
      var o = performance;
      t.unstable_now = function() {
        return o.now();
      };
    } else {
      var s = Date, a = s.now();
      t.unstable_now = function() {
        return s.now() - a;
      };
    }
    var l = [], c = [], u = 1, h = null, p = 3, v = false, y = false, S = false, T = typeof setTimeout == "function" ? setTimeout : null, w = typeof clearTimeout == "function" ? clearTimeout : null, k = typeof setImmediate < "u" ? setImmediate : null;
    typeof navigator < "u" && navigator.scheduling !== void 0 && navigator.scheduling.isInputPending !== void 0 && navigator.scheduling.isInputPending.bind(navigator.scheduling);
    function C(V) {
      for (var oe = n(c); oe !== null; ) {
        if (oe.callback === null)
          r(c);
        else if (oe.startTime <= V)
          r(c), oe.sortIndex = oe.expirationTime, e(l, oe);
        else
          break;
        oe = n(c);
      }
    }
    function O(V) {
      if (S = false, C(V), !y)
        if (n(l) !== null)
          y = true, Le(L);
        else {
          var oe = n(c);
          oe !== null && ee(O, oe.startTime - V);
        }
    }
    function L(V, oe) {
      y = false, S && (S = false, w(F), F = -1), v = true;
      var he = p;
      try {
        for (C(oe), h = n(l); h !== null && (!(h.expirationTime > oe) || V && !te()); ) {
          var Se = h.callback;
          if (typeof Se == "function") {
            h.callback = null, p = h.priorityLevel;
            var ve = Se(h.expirationTime <= oe);
            oe = t.unstable_now(), typeof ve == "function" ? h.callback = ve : h === n(l) && r(l), C(oe);
          } else
            r(l);
          h = n(l);
        }
        if (h !== null)
          var le = true;
        else {
          var re = n(c);
          re !== null && ee(O, re.startTime - oe), le = false;
        }
        return le;
      } finally {
        h = null, p = he, v = false;
      }
    }
    var D = false, R = null, F = -1, K = 5, Y = -1;
    function te() {
      return !(t.unstable_now() - Y < K);
    }
    function ne() {
      if (R !== null) {
        var V = t.unstable_now();
        Y = V;
        var oe = true;
        try {
          oe = R(true, V);
        } finally {
          oe ? ae() : (D = false, R = null);
        }
      } else
        D = false;
    }
    var ae;
    if (typeof k == "function")
      ae = function() {
        k(ne);
      };
    else if (typeof MessageChannel < "u") {
      var ye = new MessageChannel(), Ce = ye.port2;
      ye.port1.onmessage = ne, ae = function() {
        Ce.postMessage(null);
      };
    } else
      ae = function() {
        T(ne, 0);
      };
    function Le(V) {
      R = V, D || (D = true, ae());
    }
    function ee(V, oe) {
      F = T(function() {
        V(t.unstable_now());
      }, oe);
    }
    t.unstable_IdlePriority = 5, t.unstable_ImmediatePriority = 1, t.unstable_LowPriority = 4, t.unstable_NormalPriority = 3, t.unstable_Profiling = null, t.unstable_UserBlockingPriority = 2, t.unstable_cancelCallback = function(V) {
      V.callback = null;
    }, t.unstable_continueExecution = function() {
      y || v || (y = true, Le(L));
    }, t.unstable_forceFrameRate = function(V) {
      0 > V || 125 < V ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : K = 0 < V ? Math.floor(1e3 / V) : 5;
    }, t.unstable_getCurrentPriorityLevel = function() {
      return p;
    }, t.unstable_getFirstCallbackNode = function() {
      return n(l);
    }, t.unstable_next = function(V) {
      switch (p) {
        case 1:
        case 2:
        case 3:
          var oe = 3;
          break;
        default:
          oe = p;
      }
      var he = p;
      p = oe;
      try {
        return V();
      } finally {
        p = he;
      }
    }, t.unstable_pauseExecution = function() {
    }, t.unstable_requestPaint = function() {
    }, t.unstable_runWithPriority = function(V, oe) {
      switch (V) {
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
          break;
        default:
          V = 3;
      }
      var he = p;
      p = V;
      try {
        return oe();
      } finally {
        p = he;
      }
    }, t.unstable_scheduleCallback = function(V, oe, he) {
      var Se = t.unstable_now();
      switch (typeof he == "object" && he !== null ? (he = he.delay, he = typeof he == "number" && 0 < he ? Se + he : Se) : he = Se, V) {
        case 1:
          var ve = -1;
          break;
        case 2:
          ve = 250;
          break;
        case 5:
          ve = 1073741823;
          break;
        case 4:
          ve = 1e4;
          break;
        default:
          ve = 5e3;
      }
      return ve = he + ve, V = {
        id: u++,
        callback: oe,
        priorityLevel: V,
        startTime: he,
        expirationTime: ve,
        sortIndex: -1
      }, he > Se ? (V.sortIndex = he, e(c, V), n(l) === null && V === n(c) && (S ? (w(F), F = -1) : S = true, ee(O, he - Se))) : (V.sortIndex = ve, e(l, V), y || v || (y = true, Le(L))), V;
    }, t.unstable_shouldYield = te, t.unstable_wrapCallback = function(V) {
      var oe = p;
      return function() {
        var he = p;
        p = oe;
        try {
          return V.apply(this, arguments);
        } finally {
          p = he;
        }
      };
    };
  })(xM);
  (function(t) {
    t.exports = xM;
  })(bM);
  var SM = z.exports, Qn = bM.exports;
  function Z(t) {
    for (var e = "https://reactjs.org/docs/error-decoder.html?invariant=" + t, n = 1; n < arguments.length; n++)
      e += "&args[]=" + encodeURIComponent(arguments[n]);
    return "Minified React error #" + t + "; visit " + e + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
  }
  var wM = /* @__PURE__ */ new Set(), nu = {};
  function Xs(t, e) {
    tl(t, e), tl(t + "Capture", e);
  }
  function tl(t, e) {
    for (nu[t] = e, t = 0; t < e.length; t++)
      wM.add(e[t]);
  }
  var Yi = !(typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u"), fv = Object.prototype.hasOwnProperty, k_ = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/, xS = {}, SS = {};
  function C_(t) {
    return fv.call(SS, t) ? true : fv.call(xS, t) ? false : k_.test(t) ? SS[t] = true : (xS[t] = true, false);
  }
  function T_(t, e, n, r) {
    if (n !== null && n.type === 0)
      return false;
    switch (typeof e) {
      case "function":
      case "symbol":
        return true;
      case "boolean":
        return r ? false : n !== null ? !n.acceptsBooleans : (t = t.toLowerCase().slice(0, 5), t !== "data-" && t !== "aria-");
      default:
        return false;
    }
  }
  function M_(t, e, n, r) {
    if (e === null || typeof e > "u" || T_(t, e, n, r))
      return true;
    if (r)
      return false;
    if (n !== null)
      switch (n.type) {
        case 3:
          return !e;
        case 4:
          return e === false;
        case 5:
          return isNaN(e);
        case 6:
          return isNaN(e) || 1 > e;
      }
    return false;
  }
  function Tn(t, e, n, r, i, o, s) {
    this.acceptsBooleans = e === 2 || e === 3 || e === 4, this.attributeName = r, this.attributeNamespace = i, this.mustUseProperty = n, this.propertyName = t, this.type = e, this.sanitizeURL = o, this.removeEmptyString = s;
  }
  var rn = {};
  "children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(t) {
    rn[t] = new Tn(t, 0, false, t, null, false, false);
  });
  [
    [
      "acceptCharset",
      "accept-charset"
    ],
    [
      "className",
      "class"
    ],
    [
      "htmlFor",
      "for"
    ],
    [
      "httpEquiv",
      "http-equiv"
    ]
  ].forEach(function(t) {
    var e = t[0];
    rn[e] = new Tn(e, 1, false, t[1], null, false, false);
  });
  [
    "contentEditable",
    "draggable",
    "spellCheck",
    "value"
  ].forEach(function(t) {
    rn[t] = new Tn(t, 2, false, t.toLowerCase(), null, false, false);
  });
  [
    "autoReverse",
    "externalResourcesRequired",
    "focusable",
    "preserveAlpha"
  ].forEach(function(t) {
    rn[t] = new Tn(t, 2, false, t, null, false, false);
  });
  "allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(t) {
    rn[t] = new Tn(t, 3, false, t.toLowerCase(), null, false, false);
  });
  [
    "checked",
    "multiple",
    "muted",
    "selected"
  ].forEach(function(t) {
    rn[t] = new Tn(t, 3, true, t, null, false, false);
  });
  [
    "capture",
    "download"
  ].forEach(function(t) {
    rn[t] = new Tn(t, 4, false, t, null, false, false);
  });
  [
    "cols",
    "rows",
    "size",
    "span"
  ].forEach(function(t) {
    rn[t] = new Tn(t, 6, false, t, null, false, false);
  });
  [
    "rowSpan",
    "start"
  ].forEach(function(t) {
    rn[t] = new Tn(t, 5, false, t.toLowerCase(), null, false, false);
  });
  var z1 = /[\-:]([a-z])/g;
  function F1(t) {
    return t[1].toUpperCase();
  }
  "accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(t) {
    var e = t.replace(z1, F1);
    rn[e] = new Tn(e, 1, false, t, null, false, false);
  });
  "xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(t) {
    var e = t.replace(z1, F1);
    rn[e] = new Tn(e, 1, false, t, "http://www.w3.org/1999/xlink", false, false);
  });
  [
    "xml:base",
    "xml:lang",
    "xml:space"
  ].forEach(function(t) {
    var e = t.replace(z1, F1);
    rn[e] = new Tn(e, 1, false, t, "http://www.w3.org/XML/1998/namespace", false, false);
  });
  [
    "tabIndex",
    "crossOrigin"
  ].forEach(function(t) {
    rn[t] = new Tn(t, 1, false, t.toLowerCase(), null, false, false);
  });
  rn.xlinkHref = new Tn("xlinkHref", 1, false, "xlink:href", "http://www.w3.org/1999/xlink", true, false);
  [
    "src",
    "href",
    "action",
    "formAction"
  ].forEach(function(t) {
    rn[t] = new Tn(t, 1, false, t.toLowerCase(), null, true, true);
  });
  function V1(t, e, n, r) {
    var i = rn.hasOwnProperty(e) ? rn[e] : null;
    (i !== null ? i.type !== 0 : r || !(2 < e.length) || e[0] !== "o" && e[0] !== "O" || e[1] !== "n" && e[1] !== "N") && (M_(e, n, i, r) && (n = null), r || i === null ? C_(e) && (n === null ? t.removeAttribute(e) : t.setAttribute(e, "" + n)) : i.mustUseProperty ? t[i.propertyName] = n === null ? i.type === 3 ? false : "" : n : (e = i.attributeName, r = i.attributeNamespace, n === null ? t.removeAttribute(e) : (i = i.type, n = i === 3 || i === 4 && n === true ? "" : "" + n, r ? t.setAttributeNS(r, e, n) : t.setAttribute(e, n))));
  }
  var oo = SM.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, Hf = Symbol.for("react.element"), da = Symbol.for("react.portal"), pa = Symbol.for("react.fragment"), W1 = Symbol.for("react.strict_mode"), hv = Symbol.for("react.profiler"), kM = Symbol.for("react.provider"), CM = Symbol.for("react.context"), H1 = Symbol.for("react.forward_ref"), dv = Symbol.for("react.suspense"), pv = Symbol.for("react.suspense_list"), j1 = Symbol.for("react.memo"), yo = Symbol.for("react.lazy"), TM = Symbol.for("react.offscreen"), wS = Symbol.iterator;
  function jl(t) {
    return t === null || typeof t != "object" ? null : (t = wS && t[wS] || t["@@iterator"], typeof t == "function" ? t : null);
  }
  var gt = Object.assign, Eg;
  function cc(t) {
    if (Eg === void 0)
      try {
        throw Error();
      } catch (n) {
        var e = n.stack.trim().match(/\n( *(at )?)/);
        Eg = e && e[1] || "";
      }
    return `
` + Eg + t;
  }
  var Pg = false;
  function Og(t, e) {
    if (!t || Pg)
      return "";
    Pg = true;
    var n = Error.prepareStackTrace;
    Error.prepareStackTrace = void 0;
    try {
      if (e)
        if (e = function() {
          throw Error();
        }, Object.defineProperty(e.prototype, "props", {
          set: function() {
            throw Error();
          }
        }), typeof Reflect == "object" && Reflect.construct) {
          try {
            Reflect.construct(e, []);
          } catch (c) {
            var r = c;
          }
          Reflect.construct(t, [], e);
        } else {
          try {
            e.call();
          } catch (c) {
            r = c;
          }
          t.call(e.prototype);
        }
      else {
        try {
          throw Error();
        } catch (c) {
          r = c;
        }
        t();
      }
    } catch (c) {
      if (c && r && typeof c.stack == "string") {
        for (var i = c.stack.split(`
`), o = r.stack.split(`
`), s = i.length - 1, a = o.length - 1; 1 <= s && 0 <= a && i[s] !== o[a]; )
          a--;
        for (; 1 <= s && 0 <= a; s--, a--)
          if (i[s] !== o[a]) {
            if (s !== 1 || a !== 1)
              do
                if (s--, a--, 0 > a || i[s] !== o[a]) {
                  var l = `
` + i[s].replace(" at new ", " at ");
                  return t.displayName && l.includes("<anonymous>") && (l = l.replace("<anonymous>", t.displayName)), l;
                }
              while (1 <= s && 0 <= a);
            break;
          }
      }
    } finally {
      Pg = false, Error.prepareStackTrace = n;
    }
    return (t = t ? t.displayName || t.name : "") ? cc(t) : "";
  }
  function A_(t) {
    switch (t.tag) {
      case 5:
        return cc(t.type);
      case 16:
        return cc("Lazy");
      case 13:
        return cc("Suspense");
      case 19:
        return cc("SuspenseList");
      case 0:
      case 2:
      case 15:
        return t = Og(t.type, false), t;
      case 11:
        return t = Og(t.type.render, false), t;
      case 1:
        return t = Og(t.type, true), t;
      default:
        return "";
    }
  }
  function mv(t) {
    if (t == null)
      return null;
    if (typeof t == "function")
      return t.displayName || t.name || null;
    if (typeof t == "string")
      return t;
    switch (t) {
      case pa:
        return "Fragment";
      case da:
        return "Portal";
      case hv:
        return "Profiler";
      case W1:
        return "StrictMode";
      case dv:
        return "Suspense";
      case pv:
        return "SuspenseList";
    }
    if (typeof t == "object")
      switch (t.$$typeof) {
        case CM:
          return (t.displayName || "Context") + ".Consumer";
        case kM:
          return (t._context.displayName || "Context") + ".Provider";
        case H1:
          var e = t.render;
          return t = t.displayName, t || (t = e.displayName || e.name || "", t = t !== "" ? "ForwardRef(" + t + ")" : "ForwardRef"), t;
        case j1:
          return e = t.displayName || null, e !== null ? e : mv(t.type) || "Memo";
        case yo:
          e = t._payload, t = t._init;
          try {
            return mv(t(e));
          } catch {
          }
      }
    return null;
  }
  function E_(t) {
    var e = t.type;
    switch (t.tag) {
      case 24:
        return "Cache";
      case 9:
        return (e.displayName || "Context") + ".Consumer";
      case 10:
        return (e._context.displayName || "Context") + ".Provider";
      case 18:
        return "DehydratedFragment";
      case 11:
        return t = e.render, t = t.displayName || t.name || "", e.displayName || (t !== "" ? "ForwardRef(" + t + ")" : "ForwardRef");
      case 7:
        return "Fragment";
      case 5:
        return e;
      case 4:
        return "Portal";
      case 3:
        return "Root";
      case 6:
        return "Text";
      case 16:
        return mv(e);
      case 8:
        return e === W1 ? "StrictMode" : "Mode";
      case 22:
        return "Offscreen";
      case 12:
        return "Profiler";
      case 21:
        return "Scope";
      case 13:
        return "Suspense";
      case 19:
        return "SuspenseList";
      case 25:
        return "TracingMarker";
      case 1:
      case 0:
      case 17:
      case 2:
      case 14:
      case 15:
        if (typeof e == "function")
          return e.displayName || e.name || null;
        if (typeof e == "string")
          return e;
    }
    return null;
  }
  function Ho(t) {
    switch (typeof t) {
      case "boolean":
      case "number":
      case "string":
      case "undefined":
        return t;
      case "object":
        return t;
      default:
        return "";
    }
  }
  function MM(t) {
    var e = t.type;
    return (t = t.nodeName) && t.toLowerCase() === "input" && (e === "checkbox" || e === "radio");
  }
  function P_(t) {
    var e = MM(t) ? "checked" : "value", n = Object.getOwnPropertyDescriptor(t.constructor.prototype, e), r = "" + t[e];
    if (!t.hasOwnProperty(e) && typeof n < "u" && typeof n.get == "function" && typeof n.set == "function") {
      var i = n.get, o = n.set;
      return Object.defineProperty(t, e, {
        configurable: true,
        get: function() {
          return i.call(this);
        },
        set: function(s) {
          r = "" + s, o.call(this, s);
        }
      }), Object.defineProperty(t, e, {
        enumerable: n.enumerable
      }), {
        getValue: function() {
          return r;
        },
        setValue: function(s) {
          r = "" + s;
        },
        stopTracking: function() {
          t._valueTracker = null, delete t[e];
        }
      };
    }
  }
  function jf(t) {
    t._valueTracker || (t._valueTracker = P_(t));
  }
  function AM(t) {
    if (!t)
      return false;
    var e = t._valueTracker;
    if (!e)
      return true;
    var n = e.getValue(), r = "";
    return t && (r = MM(t) ? t.checked ? "true" : "false" : t.value), t = r, t !== n ? (e.setValue(t), true) : false;
  }
  function Pd(t) {
    if (t = t || (typeof document < "u" ? document : void 0), typeof t > "u")
      return null;
    try {
      return t.activeElement || t.body;
    } catch {
      return t.body;
    }
  }
  function gv(t, e) {
    var n = e.checked;
    return gt({}, e, {
      defaultChecked: void 0,
      defaultValue: void 0,
      value: void 0,
      checked: n ?? t._wrapperState.initialChecked
    });
  }
  function kS(t, e) {
    var n = e.defaultValue == null ? "" : e.defaultValue, r = e.checked != null ? e.checked : e.defaultChecked;
    n = Ho(e.value != null ? e.value : n), t._wrapperState = {
      initialChecked: r,
      initialValue: n,
      controlled: e.type === "checkbox" || e.type === "radio" ? e.checked != null : e.value != null
    };
  }
  function EM(t, e) {
    e = e.checked, e != null && V1(t, "checked", e, false);
  }
  function vv(t, e) {
    EM(t, e);
    var n = Ho(e.value), r = e.type;
    if (n != null)
      r === "number" ? (n === 0 && t.value === "" || t.value != n) && (t.value = "" + n) : t.value !== "" + n && (t.value = "" + n);
    else if (r === "submit" || r === "reset") {
      t.removeAttribute("value");
      return;
    }
    e.hasOwnProperty("value") ? yv(t, e.type, n) : e.hasOwnProperty("defaultValue") && yv(t, e.type, Ho(e.defaultValue)), e.checked == null && e.defaultChecked != null && (t.defaultChecked = !!e.defaultChecked);
  }
  function CS(t, e, n) {
    if (e.hasOwnProperty("value") || e.hasOwnProperty("defaultValue")) {
      var r = e.type;
      if (!(r !== "submit" && r !== "reset" || e.value !== void 0 && e.value !== null))
        return;
      e = "" + t._wrapperState.initialValue, n || e === t.value || (t.value = e), t.defaultValue = e;
    }
    n = t.name, n !== "" && (t.name = ""), t.defaultChecked = !!t._wrapperState.initialChecked, n !== "" && (t.name = n);
  }
  function yv(t, e, n) {
    (e !== "number" || Pd(t.ownerDocument) !== t) && (n == null ? t.defaultValue = "" + t._wrapperState.initialValue : t.defaultValue !== "" + n && (t.defaultValue = "" + n));
  }
  var uc = Array.isArray;
  function Ba(t, e, n, r) {
    if (t = t.options, e) {
      e = {};
      for (var i = 0; i < n.length; i++)
        e["$" + n[i]] = true;
      for (n = 0; n < t.length; n++)
        i = e.hasOwnProperty("$" + t[n].value), t[n].selected !== i && (t[n].selected = i), i && r && (t[n].defaultSelected = true);
    } else {
      for (n = "" + Ho(n), e = null, i = 0; i < t.length; i++) {
        if (t[i].value === n) {
          t[i].selected = true, r && (t[i].defaultSelected = true);
          return;
        }
        e !== null || t[i].disabled || (e = t[i]);
      }
      e !== null && (e.selected = true);
    }
  }
  function bv(t, e) {
    if (e.dangerouslySetInnerHTML != null)
      throw Error(Z(91));
    return gt({}, e, {
      value: void 0,
      defaultValue: void 0,
      children: "" + t._wrapperState.initialValue
    });
  }
  function TS(t, e) {
    var n = e.value;
    if (n == null) {
      if (n = e.children, e = e.defaultValue, n != null) {
        if (e != null)
          throw Error(Z(92));
        if (uc(n)) {
          if (1 < n.length)
            throw Error(Z(93));
          n = n[0];
        }
        e = n;
      }
      e == null && (e = ""), n = e;
    }
    t._wrapperState = {
      initialValue: Ho(n)
    };
  }
  function PM(t, e) {
    var n = Ho(e.value), r = Ho(e.defaultValue);
    n != null && (n = "" + n, n !== t.value && (t.value = n), e.defaultValue == null && t.defaultValue !== n && (t.defaultValue = n)), r != null && (t.defaultValue = "" + r);
  }
  function MS(t) {
    var e = t.textContent;
    e === t._wrapperState.initialValue && e !== "" && e !== null && (t.value = e);
  }
  function OM(t) {
    switch (t) {
      case "svg":
        return "http://www.w3.org/2000/svg";
      case "math":
        return "http://www.w3.org/1998/Math/MathML";
      default:
        return "http://www.w3.org/1999/xhtml";
    }
  }
  function xv(t, e) {
    return t == null || t === "http://www.w3.org/1999/xhtml" ? OM(e) : t === "http://www.w3.org/2000/svg" && e === "foreignObject" ? "http://www.w3.org/1999/xhtml" : t;
  }
  var Uf, LM = function(t) {
    return typeof MSApp < "u" && MSApp.execUnsafeLocalFunction ? function(e, n, r, i) {
      MSApp.execUnsafeLocalFunction(function() {
        return t(e, n, r, i);
      });
    } : t;
  }(function(t, e) {
    if (t.namespaceURI !== "http://www.w3.org/2000/svg" || "innerHTML" in t)
      t.innerHTML = e;
    else {
      for (Uf = Uf || document.createElement("div"), Uf.innerHTML = "<svg>" + e.valueOf().toString() + "</svg>", e = Uf.firstChild; t.firstChild; )
        t.removeChild(t.firstChild);
      for (; e.firstChild; )
        t.appendChild(e.firstChild);
    }
  });
  function ru(t, e) {
    if (e) {
      var n = t.firstChild;
      if (n && n === t.lastChild && n.nodeType === 3) {
        n.nodeValue = e;
        return;
      }
    }
    t.textContent = e;
  }
  var Cc = {
    animationIterationCount: true,
    aspectRatio: true,
    borderImageOutset: true,
    borderImageSlice: true,
    borderImageWidth: true,
    boxFlex: true,
    boxFlexGroup: true,
    boxOrdinalGroup: true,
    columnCount: true,
    columns: true,
    flex: true,
    flexGrow: true,
    flexPositive: true,
    flexShrink: true,
    flexNegative: true,
    flexOrder: true,
    gridArea: true,
    gridRow: true,
    gridRowEnd: true,
    gridRowSpan: true,
    gridRowStart: true,
    gridColumn: true,
    gridColumnEnd: true,
    gridColumnSpan: true,
    gridColumnStart: true,
    fontWeight: true,
    lineClamp: true,
    lineHeight: true,
    opacity: true,
    order: true,
    orphans: true,
    tabSize: true,
    widows: true,
    zIndex: true,
    zoom: true,
    fillOpacity: true,
    floodOpacity: true,
    stopOpacity: true,
    strokeDasharray: true,
    strokeDashoffset: true,
    strokeMiterlimit: true,
    strokeOpacity: true,
    strokeWidth: true
  }, O_ = [
    "Webkit",
    "ms",
    "Moz",
    "O"
  ];
  Object.keys(Cc).forEach(function(t) {
    O_.forEach(function(e) {
      e = e + t.charAt(0).toUpperCase() + t.substring(1), Cc[e] = Cc[t];
    });
  });
  function RM(t, e, n) {
    return e == null || typeof e == "boolean" || e === "" ? "" : n || typeof e != "number" || e === 0 || Cc.hasOwnProperty(t) && Cc[t] ? ("" + e).trim() : e + "px";
  }
  function _M(t, e) {
    t = t.style;
    for (var n in e)
      if (e.hasOwnProperty(n)) {
        var r = n.indexOf("--") === 0, i = RM(n, e[n], r);
        n === "float" && (n = "cssFloat"), r ? t.setProperty(n, i) : t[n] = i;
      }
  }
  var L_ = gt({
    menuitem: true
  }, {
    area: true,
    base: true,
    br: true,
    col: true,
    embed: true,
    hr: true,
    img: true,
    input: true,
    keygen: true,
    link: true,
    meta: true,
    param: true,
    source: true,
    track: true,
    wbr: true
  });
  function Sv(t, e) {
    if (e) {
      if (L_[t] && (e.children != null || e.dangerouslySetInnerHTML != null))
        throw Error(Z(137, t));
      if (e.dangerouslySetInnerHTML != null) {
        if (e.children != null)
          throw Error(Z(60));
        if (typeof e.dangerouslySetInnerHTML != "object" || !("__html" in e.dangerouslySetInnerHTML))
          throw Error(Z(61));
      }
      if (e.style != null && typeof e.style != "object")
        throw Error(Z(62));
    }
  }
  function wv(t, e) {
    if (t.indexOf("-") === -1)
      return typeof e.is == "string";
    switch (t) {
      case "annotation-xml":
      case "color-profile":
      case "font-face":
      case "font-face-src":
      case "font-face-uri":
      case "font-face-format":
      case "font-face-name":
      case "missing-glyph":
        return false;
      default:
        return true;
    }
  }
  var kv = null;
  function U1(t) {
    return t = t.target || t.srcElement || window, t.correspondingUseElement && (t = t.correspondingUseElement), t.nodeType === 3 ? t.parentNode : t;
  }
  var Cv = null, Na = null, $a = null;
  function AS(t) {
    if (t = Xu(t)) {
      if (typeof Cv != "function")
        throw Error(Z(280));
      var e = t.stateNode;
      e && (e = Gp(e), Cv(t.stateNode, t.type, e));
    }
  }
  function DM(t) {
    Na ? $a ? $a.push(t) : $a = [
      t
    ] : Na = t;
  }
  function IM() {
    if (Na) {
      var t = Na, e = $a;
      if ($a = Na = null, AS(t), e)
        for (t = 0; t < e.length; t++)
          AS(e[t]);
    }
  }
  function BM(t, e) {
    return t(e);
  }
  function NM() {
  }
  var Lg = false;
  function $M(t, e, n) {
    if (Lg)
      return t(e, n);
    Lg = true;
    try {
      return BM(t, e, n);
    } finally {
      Lg = false, (Na !== null || $a !== null) && (NM(), IM());
    }
  }
  function iu(t, e) {
    var n = t.stateNode;
    if (n === null)
      return null;
    var r = Gp(n);
    if (r === null)
      return null;
    n = r[e];
    e:
      switch (e) {
        case "onClick":
        case "onClickCapture":
        case "onDoubleClick":
        case "onDoubleClickCapture":
        case "onMouseDown":
        case "onMouseDownCapture":
        case "onMouseMove":
        case "onMouseMoveCapture":
        case "onMouseUp":
        case "onMouseUpCapture":
        case "onMouseEnter":
          (r = !r.disabled) || (t = t.type, r = !(t === "button" || t === "input" || t === "select" || t === "textarea")), t = !r;
          break e;
        default:
          t = false;
      }
    if (t)
      return null;
    if (n && typeof n != "function")
      throw Error(Z(231, e, typeof n));
    return n;
  }
  var Tv = false;
  if (Yi)
    try {
      var Ul = {};
      Object.defineProperty(Ul, "passive", {
        get: function() {
          Tv = true;
        }
      }), window.addEventListener("test", Ul, Ul), window.removeEventListener("test", Ul, Ul);
    } catch {
      Tv = false;
    }
  function R_(t, e, n, r, i, o, s, a, l) {
    var c = Array.prototype.slice.call(arguments, 3);
    try {
      e.apply(n, c);
    } catch (u) {
      this.onError(u);
    }
  }
  var Tc = false, Od = null, Ld = false, Mv = null, __ = {
    onError: function(t) {
      Tc = true, Od = t;
    }
  };
  function D_(t, e, n, r, i, o, s, a, l) {
    Tc = false, Od = null, R_.apply(__, arguments);
  }
  function I_(t, e, n, r, i, o, s, a, l) {
    if (D_.apply(this, arguments), Tc) {
      if (Tc) {
        var c = Od;
        Tc = false, Od = null;
      } else
        throw Error(Z(198));
      Ld || (Ld = true, Mv = c);
    }
  }
  function Qs(t) {
    var e = t, n = t;
    if (t.alternate)
      for (; e.return; )
        e = e.return;
    else {
      t = e;
      do
        e = t, (e.flags & 4098) !== 0 && (n = e.return), t = e.return;
      while (t);
    }
    return e.tag === 3 ? n : null;
  }
  function zM(t) {
    if (t.tag === 13) {
      var e = t.memoizedState;
      if (e === null && (t = t.alternate, t !== null && (e = t.memoizedState)), e !== null)
        return e.dehydrated;
    }
    return null;
  }
  function ES(t) {
    if (Qs(t) !== t)
      throw Error(Z(188));
  }
  function B_(t) {
    var e = t.alternate;
    if (!e) {
      if (e = Qs(t), e === null)
        throw Error(Z(188));
      return e !== t ? null : t;
    }
    for (var n = t, r = e; ; ) {
      var i = n.return;
      if (i === null)
        break;
      var o = i.alternate;
      if (o === null) {
        if (r = i.return, r !== null) {
          n = r;
          continue;
        }
        break;
      }
      if (i.child === o.child) {
        for (o = i.child; o; ) {
          if (o === n)
            return ES(i), t;
          if (o === r)
            return ES(i), e;
          o = o.sibling;
        }
        throw Error(Z(188));
      }
      if (n.return !== r.return)
        n = i, r = o;
      else {
        for (var s = false, a = i.child; a; ) {
          if (a === n) {
            s = true, n = i, r = o;
            break;
          }
          if (a === r) {
            s = true, r = i, n = o;
            break;
          }
          a = a.sibling;
        }
        if (!s) {
          for (a = o.child; a; ) {
            if (a === n) {
              s = true, n = o, r = i;
              break;
            }
            if (a === r) {
              s = true, r = o, n = i;
              break;
            }
            a = a.sibling;
          }
          if (!s)
            throw Error(Z(189));
        }
      }
      if (n.alternate !== r)
        throw Error(Z(190));
    }
    if (n.tag !== 3)
      throw Error(Z(188));
    return n.stateNode.current === n ? t : e;
  }
  function FM(t) {
    return t = B_(t), t !== null ? VM(t) : null;
  }
  function VM(t) {
    if (t.tag === 5 || t.tag === 6)
      return t;
    for (t = t.child; t !== null; ) {
      var e = VM(t);
      if (e !== null)
        return e;
      t = t.sibling;
    }
    return null;
  }
  var WM = Qn.unstable_scheduleCallback, PS = Qn.unstable_cancelCallback, N_ = Qn.unstable_shouldYield, $_ = Qn.unstable_requestPaint, Mt = Qn.unstable_now, z_ = Qn.unstable_getCurrentPriorityLevel, K1 = Qn.unstable_ImmediatePriority, HM = Qn.unstable_UserBlockingPriority, Rd = Qn.unstable_NormalPriority, F_ = Qn.unstable_LowPriority, jM = Qn.unstable_IdlePriority, jp = null, Si = null;
  function V_(t) {
    if (Si && typeof Si.onCommitFiberRoot == "function")
      try {
        Si.onCommitFiberRoot(jp, t, void 0, (t.current.flags & 128) === 128);
      } catch {
      }
  }
  var Vr = Math.clz32 ? Math.clz32 : j_, W_ = Math.log, H_ = Math.LN2;
  function j_(t) {
    return t >>>= 0, t === 0 ? 32 : 31 - (W_(t) / H_ | 0) | 0;
  }
  var Kf = 64, qf = 4194304;
  function fc(t) {
    switch (t & -t) {
      case 1:
        return 1;
      case 2:
        return 2;
      case 4:
        return 4;
      case 8:
        return 8;
      case 16:
        return 16;
      case 32:
        return 32;
      case 64:
      case 128:
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
        return t & 4194240;
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
      case 67108864:
        return t & 130023424;
      case 134217728:
        return 134217728;
      case 268435456:
        return 268435456;
      case 536870912:
        return 536870912;
      case 1073741824:
        return 1073741824;
      default:
        return t;
    }
  }
  function _d(t, e) {
    var n = t.pendingLanes;
    if (n === 0)
      return 0;
    var r = 0, i = t.suspendedLanes, o = t.pingedLanes, s = n & 268435455;
    if (s !== 0) {
      var a = s & ~i;
      a !== 0 ? r = fc(a) : (o &= s, o !== 0 && (r = fc(o)));
    } else
      s = n & ~i, s !== 0 ? r = fc(s) : o !== 0 && (r = fc(o));
    if (r === 0)
      return 0;
    if (e !== 0 && e !== r && (e & i) === 0 && (i = r & -r, o = e & -e, i >= o || i === 16 && (o & 4194240) !== 0))
      return e;
    if ((r & 4) !== 0 && (r |= n & 16), e = t.entangledLanes, e !== 0)
      for (t = t.entanglements, e &= r; 0 < e; )
        n = 31 - Vr(e), i = 1 << n, r |= t[n], e &= ~i;
    return r;
  }
  function U_(t, e) {
    switch (t) {
      case 1:
      case 2:
      case 4:
        return e + 250;
      case 8:
      case 16:
      case 32:
      case 64:
      case 128:
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
        return e + 5e3;
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
      case 67108864:
        return -1;
      case 134217728:
      case 268435456:
      case 536870912:
      case 1073741824:
        return -1;
      default:
        return -1;
    }
  }
  function K_(t, e) {
    for (var n = t.suspendedLanes, r = t.pingedLanes, i = t.expirationTimes, o = t.pendingLanes; 0 < o; ) {
      var s = 31 - Vr(o), a = 1 << s, l = i[s];
      l === -1 ? ((a & n) === 0 || (a & r) !== 0) && (i[s] = U_(a, e)) : l <= e && (t.expiredLanes |= a), o &= ~a;
    }
  }
  function Av(t) {
    return t = t.pendingLanes & -1073741825, t !== 0 ? t : t & 1073741824 ? 1073741824 : 0;
  }
  function UM() {
    var t = Kf;
    return Kf <<= 1, (Kf & 4194240) === 0 && (Kf = 64), t;
  }
  function Rg(t) {
    for (var e = [], n = 0; 31 > n; n++)
      e.push(t);
    return e;
  }
  function Gu(t, e, n) {
    t.pendingLanes |= e, e !== 536870912 && (t.suspendedLanes = 0, t.pingedLanes = 0), t = t.eventTimes, e = 31 - Vr(e), t[e] = n;
  }
  function q_(t, e) {
    var n = t.pendingLanes & ~e;
    t.pendingLanes = e, t.suspendedLanes = 0, t.pingedLanes = 0, t.expiredLanes &= e, t.mutableReadLanes &= e, t.entangledLanes &= e, e = t.entanglements;
    var r = t.eventTimes;
    for (t = t.expirationTimes; 0 < n; ) {
      var i = 31 - Vr(n), o = 1 << i;
      e[i] = 0, r[i] = -1, t[i] = -1, n &= ~o;
    }
  }
  function q1(t, e) {
    var n = t.entangledLanes |= e;
    for (t = t.entanglements; n; ) {
      var r = 31 - Vr(n), i = 1 << r;
      i & e | t[r] & e && (t[r] |= e), n &= ~i;
    }
  }
  var Ye = 0;
  function KM(t) {
    return t &= -t, 1 < t ? 4 < t ? (t & 268435455) !== 0 ? 16 : 536870912 : 4 : 1;
  }
  var qM, G1, GM, YM, XM, Ev = false, Gf = [], Do = null, Io = null, Bo = null, ou = /* @__PURE__ */ new Map(), su = /* @__PURE__ */ new Map(), ko = [], G_ = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");
  function OS(t, e) {
    switch (t) {
      case "focusin":
      case "focusout":
        Do = null;
        break;
      case "dragenter":
      case "dragleave":
        Io = null;
        break;
      case "mouseover":
      case "mouseout":
        Bo = null;
        break;
      case "pointerover":
      case "pointerout":
        ou.delete(e.pointerId);
        break;
      case "gotpointercapture":
      case "lostpointercapture":
        su.delete(e.pointerId);
    }
  }
  function Kl(t, e, n, r, i, o) {
    return t === null || t.nativeEvent !== o ? (t = {
      blockedOn: e,
      domEventName: n,
      eventSystemFlags: r,
      nativeEvent: o,
      targetContainers: [
        i
      ]
    }, e !== null && (e = Xu(e), e !== null && G1(e)), t) : (t.eventSystemFlags |= r, e = t.targetContainers, i !== null && e.indexOf(i) === -1 && e.push(i), t);
  }
  function Y_(t, e, n, r, i) {
    switch (e) {
      case "focusin":
        return Do = Kl(Do, t, e, n, r, i), true;
      case "dragenter":
        return Io = Kl(Io, t, e, n, r, i), true;
      case "mouseover":
        return Bo = Kl(Bo, t, e, n, r, i), true;
      case "pointerover":
        var o = i.pointerId;
        return ou.set(o, Kl(ou.get(o) || null, t, e, n, r, i)), true;
      case "gotpointercapture":
        return o = i.pointerId, su.set(o, Kl(su.get(o) || null, t, e, n, r, i)), true;
    }
    return false;
  }
  function QM(t) {
    var e = Cs(t.target);
    if (e !== null) {
      var n = Qs(e);
      if (n !== null) {
        if (e = n.tag, e === 13) {
          if (e = zM(n), e !== null) {
            t.blockedOn = e, XM(t.priority, function() {
              GM(n);
            });
            return;
          }
        } else if (e === 3 && n.stateNode.current.memoizedState.isDehydrated) {
          t.blockedOn = n.tag === 3 ? n.stateNode.containerInfo : null;
          return;
        }
      }
    }
    t.blockedOn = null;
  }
  function Kh(t) {
    if (t.blockedOn !== null)
      return false;
    for (var e = t.targetContainers; 0 < e.length; ) {
      var n = Pv(t.domEventName, t.eventSystemFlags, e[0], t.nativeEvent);
      if (n === null) {
        n = t.nativeEvent;
        var r = new n.constructor(n.type, n);
        kv = r, n.target.dispatchEvent(r), kv = null;
      } else
        return e = Xu(n), e !== null && G1(e), t.blockedOn = n, false;
      e.shift();
    }
    return true;
  }
  function LS(t, e, n) {
    Kh(t) && n.delete(e);
  }
  function X_() {
    Ev = false, Do !== null && Kh(Do) && (Do = null), Io !== null && Kh(Io) && (Io = null), Bo !== null && Kh(Bo) && (Bo = null), ou.forEach(LS), su.forEach(LS);
  }
  function ql(t, e) {
    t.blockedOn === e && (t.blockedOn = null, Ev || (Ev = true, Qn.unstable_scheduleCallback(Qn.unstable_NormalPriority, X_)));
  }
  function au(t) {
    function e(i) {
      return ql(i, t);
    }
    if (0 < Gf.length) {
      ql(Gf[0], t);
      for (var n = 1; n < Gf.length; n++) {
        var r = Gf[n];
        r.blockedOn === t && (r.blockedOn = null);
      }
    }
    for (Do !== null && ql(Do, t), Io !== null && ql(Io, t), Bo !== null && ql(Bo, t), ou.forEach(e), su.forEach(e), n = 0; n < ko.length; n++)
      r = ko[n], r.blockedOn === t && (r.blockedOn = null);
    for (; 0 < ko.length && (n = ko[0], n.blockedOn === null); )
      QM(n), n.blockedOn === null && ko.shift();
  }
  var za = oo.ReactCurrentBatchConfig, Dd = true;
  function Q_(t, e, n, r) {
    var i = Ye, o = za.transition;
    za.transition = null;
    try {
      Ye = 1, Y1(t, e, n, r);
    } finally {
      Ye = i, za.transition = o;
    }
  }
  function J_(t, e, n, r) {
    var i = Ye, o = za.transition;
    za.transition = null;
    try {
      Ye = 4, Y1(t, e, n, r);
    } finally {
      Ye = i, za.transition = o;
    }
  }
  function Y1(t, e, n, r) {
    if (Dd) {
      var i = Pv(t, e, n, r);
      if (i === null)
        Wg(t, e, r, Id, n), OS(t, r);
      else if (Y_(i, t, e, n, r))
        r.stopPropagation();
      else if (OS(t, r), e & 4 && -1 < G_.indexOf(t)) {
        for (; i !== null; ) {
          var o = Xu(i);
          if (o !== null && qM(o), o = Pv(t, e, n, r), o === null && Wg(t, e, r, Id, n), o === i)
            break;
          i = o;
        }
        i !== null && r.stopPropagation();
      } else
        Wg(t, e, r, null, n);
    }
  }
  var Id = null;
  function Pv(t, e, n, r) {
    if (Id = null, t = U1(r), t = Cs(t), t !== null)
      if (e = Qs(t), e === null)
        t = null;
      else if (n = e.tag, n === 13) {
        if (t = zM(e), t !== null)
          return t;
        t = null;
      } else if (n === 3) {
        if (e.stateNode.current.memoizedState.isDehydrated)
          return e.tag === 3 ? e.stateNode.containerInfo : null;
        t = null;
      } else
        e !== t && (t = null);
    return Id = t, null;
  }
  function JM(t) {
    switch (t) {
      case "cancel":
      case "click":
      case "close":
      case "contextmenu":
      case "copy":
      case "cut":
      case "auxclick":
      case "dblclick":
      case "dragend":
      case "dragstart":
      case "drop":
      case "focusin":
      case "focusout":
      case "input":
      case "invalid":
      case "keydown":
      case "keypress":
      case "keyup":
      case "mousedown":
      case "mouseup":
      case "paste":
      case "pause":
      case "play":
      case "pointercancel":
      case "pointerdown":
      case "pointerup":
      case "ratechange":
      case "reset":
      case "resize":
      case "seeked":
      case "submit":
      case "touchcancel":
      case "touchend":
      case "touchstart":
      case "volumechange":
      case "change":
      case "selectionchange":
      case "textInput":
      case "compositionstart":
      case "compositionend":
      case "compositionupdate":
      case "beforeblur":
      case "afterblur":
      case "beforeinput":
      case "blur":
      case "fullscreenchange":
      case "focus":
      case "hashchange":
      case "popstate":
      case "select":
      case "selectstart":
        return 1;
      case "drag":
      case "dragenter":
      case "dragexit":
      case "dragleave":
      case "dragover":
      case "mousemove":
      case "mouseout":
      case "mouseover":
      case "pointermove":
      case "pointerout":
      case "pointerover":
      case "scroll":
      case "toggle":
      case "touchmove":
      case "wheel":
      case "mouseenter":
      case "mouseleave":
      case "pointerenter":
      case "pointerleave":
        return 4;
      case "message":
        switch (z_()) {
          case K1:
            return 1;
          case HM:
            return 4;
          case Rd:
          case F_:
            return 16;
          case jM:
            return 536870912;
          default:
            return 16;
        }
      default:
        return 16;
    }
  }
  var Eo = null, X1 = null, qh = null;
  function ZM() {
    if (qh)
      return qh;
    var t, e = X1, n = e.length, r, i = "value" in Eo ? Eo.value : Eo.textContent, o = i.length;
    for (t = 0; t < n && e[t] === i[t]; t++)
      ;
    var s = n - t;
    for (r = 1; r <= s && e[n - r] === i[o - r]; r++)
      ;
    return qh = i.slice(t, 1 < r ? 1 - r : void 0);
  }
  function Gh(t) {
    var e = t.keyCode;
    return "charCode" in t ? (t = t.charCode, t === 0 && e === 13 && (t = 13)) : t = e, t === 10 && (t = 13), 32 <= t || t === 13 ? t : 0;
  }
  function Yf() {
    return true;
  }
  function RS() {
    return false;
  }
  function Zn(t) {
    function e(n, r, i, o, s) {
      this._reactName = n, this._targetInst = i, this.type = r, this.nativeEvent = o, this.target = s, this.currentTarget = null;
      for (var a in t)
        t.hasOwnProperty(a) && (n = t[a], this[a] = n ? n(o) : o[a]);
      return this.isDefaultPrevented = (o.defaultPrevented != null ? o.defaultPrevented : o.returnValue === false) ? Yf : RS, this.isPropagationStopped = RS, this;
    }
    return gt(e.prototype, {
      preventDefault: function() {
        this.defaultPrevented = true;
        var n = this.nativeEvent;
        n && (n.preventDefault ? n.preventDefault() : typeof n.returnValue != "unknown" && (n.returnValue = false), this.isDefaultPrevented = Yf);
      },
      stopPropagation: function() {
        var n = this.nativeEvent;
        n && (n.stopPropagation ? n.stopPropagation() : typeof n.cancelBubble != "unknown" && (n.cancelBubble = true), this.isPropagationStopped = Yf);
      },
      persist: function() {
      },
      isPersistent: Yf
    }), e;
  }
  var kl = {
    eventPhase: 0,
    bubbles: 0,
    cancelable: 0,
    timeStamp: function(t) {
      return t.timeStamp || Date.now();
    },
    defaultPrevented: 0,
    isTrusted: 0
  }, Q1 = Zn(kl), Yu = gt({}, kl, {
    view: 0,
    detail: 0
  }), Z_ = Zn(Yu), _g, Dg, Gl, Up = gt({}, Yu, {
    screenX: 0,
    screenY: 0,
    clientX: 0,
    clientY: 0,
    pageX: 0,
    pageY: 0,
    ctrlKey: 0,
    shiftKey: 0,
    altKey: 0,
    metaKey: 0,
    getModifierState: J1,
    button: 0,
    buttons: 0,
    relatedTarget: function(t) {
      return t.relatedTarget === void 0 ? t.fromElement === t.srcElement ? t.toElement : t.fromElement : t.relatedTarget;
    },
    movementX: function(t) {
      return "movementX" in t ? t.movementX : (t !== Gl && (Gl && t.type === "mousemove" ? (_g = t.screenX - Gl.screenX, Dg = t.screenY - Gl.screenY) : Dg = _g = 0, Gl = t), _g);
    },
    movementY: function(t) {
      return "movementY" in t ? t.movementY : Dg;
    }
  }), _S = Zn(Up), eD = gt({}, Up, {
    dataTransfer: 0
  }), tD = Zn(eD), nD = gt({}, Yu, {
    relatedTarget: 0
  }), Ig = Zn(nD), rD = gt({}, kl, {
    animationName: 0,
    elapsedTime: 0,
    pseudoElement: 0
  }), iD = Zn(rD), oD = gt({}, kl, {
    clipboardData: function(t) {
      return "clipboardData" in t ? t.clipboardData : window.clipboardData;
    }
  }), sD = Zn(oD), aD = gt({}, kl, {
    data: 0
  }), DS = Zn(aD), lD = {
    Esc: "Escape",
    Spacebar: " ",
    Left: "ArrowLeft",
    Up: "ArrowUp",
    Right: "ArrowRight",
    Down: "ArrowDown",
    Del: "Delete",
    Win: "OS",
    Menu: "ContextMenu",
    Apps: "ContextMenu",
    Scroll: "ScrollLock",
    MozPrintableKey: "Unidentified"
  }, cD = {
    8: "Backspace",
    9: "Tab",
    12: "Clear",
    13: "Enter",
    16: "Shift",
    17: "Control",
    18: "Alt",
    19: "Pause",
    20: "CapsLock",
    27: "Escape",
    32: " ",
    33: "PageUp",
    34: "PageDown",
    35: "End",
    36: "Home",
    37: "ArrowLeft",
    38: "ArrowUp",
    39: "ArrowRight",
    40: "ArrowDown",
    45: "Insert",
    46: "Delete",
    112: "F1",
    113: "F2",
    114: "F3",
    115: "F4",
    116: "F5",
    117: "F6",
    118: "F7",
    119: "F8",
    120: "F9",
    121: "F10",
    122: "F11",
    123: "F12",
    144: "NumLock",
    145: "ScrollLock",
    224: "Meta"
  }, uD = {
    Alt: "altKey",
    Control: "ctrlKey",
    Meta: "metaKey",
    Shift: "shiftKey"
  };
  function fD(t) {
    var e = this.nativeEvent;
    return e.getModifierState ? e.getModifierState(t) : (t = uD[t]) ? !!e[t] : false;
  }
  function J1() {
    return fD;
  }
  var hD = gt({}, Yu, {
    key: function(t) {
      if (t.key) {
        var e = lD[t.key] || t.key;
        if (e !== "Unidentified")
          return e;
      }
      return t.type === "keypress" ? (t = Gh(t), t === 13 ? "Enter" : String.fromCharCode(t)) : t.type === "keydown" || t.type === "keyup" ? cD[t.keyCode] || "Unidentified" : "";
    },
    code: 0,
    location: 0,
    ctrlKey: 0,
    shiftKey: 0,
    altKey: 0,
    metaKey: 0,
    repeat: 0,
    locale: 0,
    getModifierState: J1,
    charCode: function(t) {
      return t.type === "keypress" ? Gh(t) : 0;
    },
    keyCode: function(t) {
      return t.type === "keydown" || t.type === "keyup" ? t.keyCode : 0;
    },
    which: function(t) {
      return t.type === "keypress" ? Gh(t) : t.type === "keydown" || t.type === "keyup" ? t.keyCode : 0;
    }
  }), dD = Zn(hD), pD = gt({}, Up, {
    pointerId: 0,
    width: 0,
    height: 0,
    pressure: 0,
    tangentialPressure: 0,
    tiltX: 0,
    tiltY: 0,
    twist: 0,
    pointerType: 0,
    isPrimary: 0
  }), IS = Zn(pD), mD = gt({}, Yu, {
    touches: 0,
    targetTouches: 0,
    changedTouches: 0,
    altKey: 0,
    metaKey: 0,
    ctrlKey: 0,
    shiftKey: 0,
    getModifierState: J1
  }), gD = Zn(mD), vD = gt({}, kl, {
    propertyName: 0,
    elapsedTime: 0,
    pseudoElement: 0
  }), yD = Zn(vD), bD = gt({}, Up, {
    deltaX: function(t) {
      return "deltaX" in t ? t.deltaX : "wheelDeltaX" in t ? -t.wheelDeltaX : 0;
    },
    deltaY: function(t) {
      return "deltaY" in t ? t.deltaY : "wheelDeltaY" in t ? -t.wheelDeltaY : "wheelDelta" in t ? -t.wheelDelta : 0;
    },
    deltaZ: 0,
    deltaMode: 0
  }), xD = Zn(bD), SD = [
    9,
    13,
    27,
    32
  ], Z1 = Yi && "CompositionEvent" in window, Mc = null;
  Yi && "documentMode" in document && (Mc = document.documentMode);
  var wD = Yi && "TextEvent" in window && !Mc, e2 = Yi && (!Z1 || Mc && 8 < Mc && 11 >= Mc), BS = String.fromCharCode(32), NS = false;
  function t2(t, e) {
    switch (t) {
      case "keyup":
        return SD.indexOf(e.keyCode) !== -1;
      case "keydown":
        return e.keyCode !== 229;
      case "keypress":
      case "mousedown":
      case "focusout":
        return true;
      default:
        return false;
    }
  }
  function n2(t) {
    return t = t.detail, typeof t == "object" && "data" in t ? t.data : null;
  }
  var ma = false;
  function kD(t, e) {
    switch (t) {
      case "compositionend":
        return n2(e);
      case "keypress":
        return e.which !== 32 ? null : (NS = true, BS);
      case "textInput":
        return t = e.data, t === BS && NS ? null : t;
      default:
        return null;
    }
  }
  function CD(t, e) {
    if (ma)
      return t === "compositionend" || !Z1 && t2(t, e) ? (t = ZM(), qh = X1 = Eo = null, ma = false, t) : null;
    switch (t) {
      case "paste":
        return null;
      case "keypress":
        if (!(e.ctrlKey || e.altKey || e.metaKey) || e.ctrlKey && e.altKey) {
          if (e.char && 1 < e.char.length)
            return e.char;
          if (e.which)
            return String.fromCharCode(e.which);
        }
        return null;
      case "compositionend":
        return e2 && e.locale !== "ko" ? null : e.data;
      default:
        return null;
    }
  }
  var TD = {
    color: true,
    date: true,
    datetime: true,
    "datetime-local": true,
    email: true,
    month: true,
    number: true,
    password: true,
    range: true,
    search: true,
    tel: true,
    text: true,
    time: true,
    url: true,
    week: true
  };
  function $S(t) {
    var e = t && t.nodeName && t.nodeName.toLowerCase();
    return e === "input" ? !!TD[t.type] : e === "textarea";
  }
  function r2(t, e, n, r) {
    DM(r), e = Bd(e, "onChange"), 0 < e.length && (n = new Q1("onChange", "change", null, n, r), t.push({
      event: n,
      listeners: e
    }));
  }
  var Ac = null, lu = null;
  function MD(t) {
    p2(t, 0);
  }
  function Kp(t) {
    var e = ya(t);
    if (AM(e))
      return t;
  }
  function AD(t, e) {
    if (t === "change")
      return e;
  }
  var i2 = false;
  if (Yi) {
    var Bg;
    if (Yi) {
      var Ng = "oninput" in document;
      if (!Ng) {
        var zS = document.createElement("div");
        zS.setAttribute("oninput", "return;"), Ng = typeof zS.oninput == "function";
      }
      Bg = Ng;
    } else
      Bg = false;
    i2 = Bg && (!document.documentMode || 9 < document.documentMode);
  }
  function FS() {
    Ac && (Ac.detachEvent("onpropertychange", o2), lu = Ac = null);
  }
  function o2(t) {
    if (t.propertyName === "value" && Kp(lu)) {
      var e = [];
      r2(e, lu, t, U1(t)), $M(MD, e);
    }
  }
  function ED(t, e, n) {
    t === "focusin" ? (FS(), Ac = e, lu = n, Ac.attachEvent("onpropertychange", o2)) : t === "focusout" && FS();
  }
  function PD(t) {
    if (t === "selectionchange" || t === "keyup" || t === "keydown")
      return Kp(lu);
  }
  function OD(t, e) {
    if (t === "click")
      return Kp(e);
  }
  function LD(t, e) {
    if (t === "input" || t === "change")
      return Kp(e);
  }
  function RD(t, e) {
    return t === e && (t !== 0 || 1 / t === 1 / e) || t !== t && e !== e;
  }
  var Kr = typeof Object.is == "function" ? Object.is : RD;
  function cu(t, e) {
    if (Kr(t, e))
      return true;
    if (typeof t != "object" || t === null || typeof e != "object" || e === null)
      return false;
    var n = Object.keys(t), r = Object.keys(e);
    if (n.length !== r.length)
      return false;
    for (r = 0; r < n.length; r++) {
      var i = n[r];
      if (!fv.call(e, i) || !Kr(t[i], e[i]))
        return false;
    }
    return true;
  }
  function VS(t) {
    for (; t && t.firstChild; )
      t = t.firstChild;
    return t;
  }
  function WS(t, e) {
    var n = VS(t);
    t = 0;
    for (var r; n; ) {
      if (n.nodeType === 3) {
        if (r = t + n.textContent.length, t <= e && r >= e)
          return {
            node: n,
            offset: e - t
          };
        t = r;
      }
      e: {
        for (; n; ) {
          if (n.nextSibling) {
            n = n.nextSibling;
            break e;
          }
          n = n.parentNode;
        }
        n = void 0;
      }
      n = VS(n);
    }
  }
  function s2(t, e) {
    return t && e ? t === e ? true : t && t.nodeType === 3 ? false : e && e.nodeType === 3 ? s2(t, e.parentNode) : "contains" in t ? t.contains(e) : t.compareDocumentPosition ? !!(t.compareDocumentPosition(e) & 16) : false : false;
  }
  function a2() {
    for (var t = window, e = Pd(); e instanceof t.HTMLIFrameElement; ) {
      try {
        var n = typeof e.contentWindow.location.href == "string";
      } catch {
        n = false;
      }
      if (n)
        t = e.contentWindow;
      else
        break;
      e = Pd(t.document);
    }
    return e;
  }
  function eb(t) {
    var e = t && t.nodeName && t.nodeName.toLowerCase();
    return e && (e === "input" && (t.type === "text" || t.type === "search" || t.type === "tel" || t.type === "url" || t.type === "password") || e === "textarea" || t.contentEditable === "true");
  }
  function _D(t) {
    var e = a2(), n = t.focusedElem, r = t.selectionRange;
    if (e !== n && n && n.ownerDocument && s2(n.ownerDocument.documentElement, n)) {
      if (r !== null && eb(n)) {
        if (e = r.start, t = r.end, t === void 0 && (t = e), "selectionStart" in n)
          n.selectionStart = e, n.selectionEnd = Math.min(t, n.value.length);
        else if (t = (e = n.ownerDocument || document) && e.defaultView || window, t.getSelection) {
          t = t.getSelection();
          var i = n.textContent.length, o = Math.min(r.start, i);
          r = r.end === void 0 ? o : Math.min(r.end, i), !t.extend && o > r && (i = r, r = o, o = i), i = WS(n, o);
          var s = WS(n, r);
          i && s && (t.rangeCount !== 1 || t.anchorNode !== i.node || t.anchorOffset !== i.offset || t.focusNode !== s.node || t.focusOffset !== s.offset) && (e = e.createRange(), e.setStart(i.node, i.offset), t.removeAllRanges(), o > r ? (t.addRange(e), t.extend(s.node, s.offset)) : (e.setEnd(s.node, s.offset), t.addRange(e)));
        }
      }
      for (e = [], t = n; t = t.parentNode; )
        t.nodeType === 1 && e.push({
          element: t,
          left: t.scrollLeft,
          top: t.scrollTop
        });
      for (typeof n.focus == "function" && n.focus(), n = 0; n < e.length; n++)
        t = e[n], t.element.scrollLeft = t.left, t.element.scrollTop = t.top;
    }
  }
  var DD = Yi && "documentMode" in document && 11 >= document.documentMode, ga = null, Ov = null, Ec = null, Lv = false;
  function HS(t, e, n) {
    var r = n.window === n ? n.document : n.nodeType === 9 ? n : n.ownerDocument;
    Lv || ga == null || ga !== Pd(r) || (r = ga, "selectionStart" in r && eb(r) ? r = {
      start: r.selectionStart,
      end: r.selectionEnd
    } : (r = (r.ownerDocument && r.ownerDocument.defaultView || window).getSelection(), r = {
      anchorNode: r.anchorNode,
      anchorOffset: r.anchorOffset,
      focusNode: r.focusNode,
      focusOffset: r.focusOffset
    }), Ec && cu(Ec, r) || (Ec = r, r = Bd(Ov, "onSelect"), 0 < r.length && (e = new Q1("onSelect", "select", null, e, n), t.push({
      event: e,
      listeners: r
    }), e.target = ga)));
  }
  function Xf(t, e) {
    var n = {};
    return n[t.toLowerCase()] = e.toLowerCase(), n["Webkit" + t] = "webkit" + e, n["Moz" + t] = "moz" + e, n;
  }
  var va = {
    animationend: Xf("Animation", "AnimationEnd"),
    animationiteration: Xf("Animation", "AnimationIteration"),
    animationstart: Xf("Animation", "AnimationStart"),
    transitionend: Xf("Transition", "TransitionEnd")
  }, $g = {}, l2 = {};
  Yi && (l2 = document.createElement("div").style, "AnimationEvent" in window || (delete va.animationend.animation, delete va.animationiteration.animation, delete va.animationstart.animation), "TransitionEvent" in window || delete va.transitionend.transition);
  function qp(t) {
    if ($g[t])
      return $g[t];
    if (!va[t])
      return t;
    var e = va[t], n;
    for (n in e)
      if (e.hasOwnProperty(n) && n in l2)
        return $g[t] = e[n];
    return t;
  }
  var c2 = qp("animationend"), u2 = qp("animationiteration"), f2 = qp("animationstart"), h2 = qp("transitionend"), d2 = /* @__PURE__ */ new Map(), jS = "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");
  function Zo(t, e) {
    d2.set(t, e), Xs(e, [
      t
    ]);
  }
  for (var zg = 0; zg < jS.length; zg++) {
    var Fg = jS[zg], ID = Fg.toLowerCase(), BD = Fg[0].toUpperCase() + Fg.slice(1);
    Zo(ID, "on" + BD);
  }
  Zo(c2, "onAnimationEnd");
  Zo(u2, "onAnimationIteration");
  Zo(f2, "onAnimationStart");
  Zo("dblclick", "onDoubleClick");
  Zo("focusin", "onFocus");
  Zo("focusout", "onBlur");
  Zo(h2, "onTransitionEnd");
  tl("onMouseEnter", [
    "mouseout",
    "mouseover"
  ]);
  tl("onMouseLeave", [
    "mouseout",
    "mouseover"
  ]);
  tl("onPointerEnter", [
    "pointerout",
    "pointerover"
  ]);
  tl("onPointerLeave", [
    "pointerout",
    "pointerover"
  ]);
  Xs("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" "));
  Xs("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" "));
  Xs("onBeforeInput", [
    "compositionend",
    "keypress",
    "textInput",
    "paste"
  ]);
  Xs("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" "));
  Xs("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" "));
  Xs("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" "));
  var hc = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "), ND = new Set("cancel close invalid load scroll toggle".split(" ").concat(hc));
  function US(t, e, n) {
    var r = t.type || "unknown-event";
    t.currentTarget = n, I_(r, e, void 0, t), t.currentTarget = null;
  }
  function p2(t, e) {
    e = (e & 4) !== 0;
    for (var n = 0; n < t.length; n++) {
      var r = t[n], i = r.event;
      r = r.listeners;
      e: {
        var o = void 0;
        if (e)
          for (var s = r.length - 1; 0 <= s; s--) {
            var a = r[s], l = a.instance, c = a.currentTarget;
            if (a = a.listener, l !== o && i.isPropagationStopped())
              break e;
            US(i, a, c), o = l;
          }
        else
          for (s = 0; s < r.length; s++) {
            if (a = r[s], l = a.instance, c = a.currentTarget, a = a.listener, l !== o && i.isPropagationStopped())
              break e;
            US(i, a, c), o = l;
          }
      }
    }
    if (Ld)
      throw t = Mv, Ld = false, Mv = null, t;
  }
  function ot(t, e) {
    var n = e[Bv];
    n === void 0 && (n = e[Bv] = /* @__PURE__ */ new Set());
    var r = t + "__bubble";
    n.has(r) || (m2(e, t, 2, false), n.add(r));
  }
  function Vg(t, e, n) {
    var r = 0;
    e && (r |= 4), m2(n, t, r, e);
  }
  var Qf = "_reactListening" + Math.random().toString(36).slice(2);
  function uu(t) {
    if (!t[Qf]) {
      t[Qf] = true, wM.forEach(function(n) {
        n !== "selectionchange" && (ND.has(n) || Vg(n, false, t), Vg(n, true, t));
      });
      var e = t.nodeType === 9 ? t : t.ownerDocument;
      e === null || e[Qf] || (e[Qf] = true, Vg("selectionchange", false, e));
    }
  }
  function m2(t, e, n, r) {
    switch (JM(e)) {
      case 1:
        var i = Q_;
        break;
      case 4:
        i = J_;
        break;
      default:
        i = Y1;
    }
    n = i.bind(null, e, n, t), i = void 0, !Tv || e !== "touchstart" && e !== "touchmove" && e !== "wheel" || (i = true), r ? i !== void 0 ? t.addEventListener(e, n, {
      capture: true,
      passive: i
    }) : t.addEventListener(e, n, true) : i !== void 0 ? t.addEventListener(e, n, {
      passive: i
    }) : t.addEventListener(e, n, false);
  }
  function Wg(t, e, n, r, i) {
    var o = r;
    if ((e & 1) === 0 && (e & 2) === 0 && r !== null)
      e:
        for (; ; ) {
          if (r === null)
            return;
          var s = r.tag;
          if (s === 3 || s === 4) {
            var a = r.stateNode.containerInfo;
            if (a === i || a.nodeType === 8 && a.parentNode === i)
              break;
            if (s === 4)
              for (s = r.return; s !== null; ) {
                var l = s.tag;
                if ((l === 3 || l === 4) && (l = s.stateNode.containerInfo, l === i || l.nodeType === 8 && l.parentNode === i))
                  return;
                s = s.return;
              }
            for (; a !== null; ) {
              if (s = Cs(a), s === null)
                return;
              if (l = s.tag, l === 5 || l === 6) {
                r = o = s;
                continue e;
              }
              a = a.parentNode;
            }
          }
          r = r.return;
        }
    $M(function() {
      var c = o, u = U1(n), h = [];
      e: {
        var p = d2.get(t);
        if (p !== void 0) {
          var v = Q1, y = t;
          switch (t) {
            case "keypress":
              if (Gh(n) === 0)
                break e;
            case "keydown":
            case "keyup":
              v = dD;
              break;
            case "focusin":
              y = "focus", v = Ig;
              break;
            case "focusout":
              y = "blur", v = Ig;
              break;
            case "beforeblur":
            case "afterblur":
              v = Ig;
              break;
            case "click":
              if (n.button === 2)
                break e;
            case "auxclick":
            case "dblclick":
            case "mousedown":
            case "mousemove":
            case "mouseup":
            case "mouseout":
            case "mouseover":
            case "contextmenu":
              v = _S;
              break;
            case "drag":
            case "dragend":
            case "dragenter":
            case "dragexit":
            case "dragleave":
            case "dragover":
            case "dragstart":
            case "drop":
              v = tD;
              break;
            case "touchcancel":
            case "touchend":
            case "touchmove":
            case "touchstart":
              v = gD;
              break;
            case c2:
            case u2:
            case f2:
              v = iD;
              break;
            case h2:
              v = yD;
              break;
            case "scroll":
              v = Z_;
              break;
            case "wheel":
              v = xD;
              break;
            case "copy":
            case "cut":
            case "paste":
              v = sD;
              break;
            case "gotpointercapture":
            case "lostpointercapture":
            case "pointercancel":
            case "pointerdown":
            case "pointermove":
            case "pointerout":
            case "pointerover":
            case "pointerup":
              v = IS;
          }
          var S = (e & 4) !== 0, T = !S && t === "scroll", w = S ? p !== null ? p + "Capture" : null : p;
          S = [];
          for (var k = c, C; k !== null; ) {
            C = k;
            var O = C.stateNode;
            if (C.tag === 5 && O !== null && (C = O, w !== null && (O = iu(k, w), O != null && S.push(fu(k, O, C)))), T)
              break;
            k = k.return;
          }
          0 < S.length && (p = new v(p, y, null, n, u), h.push({
            event: p,
            listeners: S
          }));
        }
      }
      if ((e & 7) === 0) {
        e: {
          if (p = t === "mouseover" || t === "pointerover", v = t === "mouseout" || t === "pointerout", p && n !== kv && (y = n.relatedTarget || n.fromElement) && (Cs(y) || y[Xi]))
            break e;
          if ((v || p) && (p = u.window === u ? u : (p = u.ownerDocument) ? p.defaultView || p.parentWindow : window, v ? (y = n.relatedTarget || n.toElement, v = c, y = y ? Cs(y) : null, y !== null && (T = Qs(y), y !== T || y.tag !== 5 && y.tag !== 6) && (y = null)) : (v = null, y = c), v !== y)) {
            if (S = _S, O = "onMouseLeave", w = "onMouseEnter", k = "mouse", (t === "pointerout" || t === "pointerover") && (S = IS, O = "onPointerLeave", w = "onPointerEnter", k = "pointer"), T = v == null ? p : ya(v), C = y == null ? p : ya(y), p = new S(O, k + "leave", v, n, u), p.target = T, p.relatedTarget = C, O = null, Cs(u) === c && (S = new S(w, k + "enter", y, n, u), S.target = C, S.relatedTarget = T, O = S), T = O, v && y)
              t: {
                for (S = v, w = y, k = 0, C = S; C; C = aa(C))
                  k++;
                for (C = 0, O = w; O; O = aa(O))
                  C++;
                for (; 0 < k - C; )
                  S = aa(S), k--;
                for (; 0 < C - k; )
                  w = aa(w), C--;
                for (; k--; ) {
                  if (S === w || w !== null && S === w.alternate)
                    break t;
                  S = aa(S), w = aa(w);
                }
                S = null;
              }
            else
              S = null;
            v !== null && KS(h, p, v, S, false), y !== null && T !== null && KS(h, T, y, S, true);
          }
        }
        e: {
          if (p = c ? ya(c) : window, v = p.nodeName && p.nodeName.toLowerCase(), v === "select" || v === "input" && p.type === "file")
            var L = AD;
          else if ($S(p))
            if (i2)
              L = LD;
            else {
              L = PD;
              var D = ED;
            }
          else
            (v = p.nodeName) && v.toLowerCase() === "input" && (p.type === "checkbox" || p.type === "radio") && (L = OD);
          if (L && (L = L(t, c))) {
            r2(h, L, n, u);
            break e;
          }
          D && D(t, p, c), t === "focusout" && (D = p._wrapperState) && D.controlled && p.type === "number" && yv(p, "number", p.value);
        }
        switch (D = c ? ya(c) : window, t) {
          case "focusin":
            ($S(D) || D.contentEditable === "true") && (ga = D, Ov = c, Ec = null);
            break;
          case "focusout":
            Ec = Ov = ga = null;
            break;
          case "mousedown":
            Lv = true;
            break;
          case "contextmenu":
          case "mouseup":
          case "dragend":
            Lv = false, HS(h, n, u);
            break;
          case "selectionchange":
            if (DD)
              break;
          case "keydown":
          case "keyup":
            HS(h, n, u);
        }
        var R;
        if (Z1)
          e: {
            switch (t) {
              case "compositionstart":
                var F = "onCompositionStart";
                break e;
              case "compositionend":
                F = "onCompositionEnd";
                break e;
              case "compositionupdate":
                F = "onCompositionUpdate";
                break e;
            }
            F = void 0;
          }
        else
          ma ? t2(t, n) && (F = "onCompositionEnd") : t === "keydown" && n.keyCode === 229 && (F = "onCompositionStart");
        F && (e2 && n.locale !== "ko" && (ma || F !== "onCompositionStart" ? F === "onCompositionEnd" && ma && (R = ZM()) : (Eo = u, X1 = "value" in Eo ? Eo.value : Eo.textContent, ma = true)), D = Bd(c, F), 0 < D.length && (F = new DS(F, t, null, n, u), h.push({
          event: F,
          listeners: D
        }), R ? F.data = R : (R = n2(n), R !== null && (F.data = R)))), (R = wD ? kD(t, n) : CD(t, n)) && (c = Bd(c, "onBeforeInput"), 0 < c.length && (u = new DS("onBeforeInput", "beforeinput", null, n, u), h.push({
          event: u,
          listeners: c
        }), u.data = R));
      }
      p2(h, e);
    });
  }
  function fu(t, e, n) {
    return {
      instance: t,
      listener: e,
      currentTarget: n
    };
  }
  function Bd(t, e) {
    for (var n = e + "Capture", r = []; t !== null; ) {
      var i = t, o = i.stateNode;
      i.tag === 5 && o !== null && (i = o, o = iu(t, n), o != null && r.unshift(fu(t, o, i)), o = iu(t, e), o != null && r.push(fu(t, o, i))), t = t.return;
    }
    return r;
  }
  function aa(t) {
    if (t === null)
      return null;
    do
      t = t.return;
    while (t && t.tag !== 5);
    return t || null;
  }
  function KS(t, e, n, r, i) {
    for (var o = e._reactName, s = []; n !== null && n !== r; ) {
      var a = n, l = a.alternate, c = a.stateNode;
      if (l !== null && l === r)
        break;
      a.tag === 5 && c !== null && (a = c, i ? (l = iu(n, o), l != null && s.unshift(fu(n, l, a))) : i || (l = iu(n, o), l != null && s.push(fu(n, l, a)))), n = n.return;
    }
    s.length !== 0 && t.push({
      event: e,
      listeners: s
    });
  }
  var $D = /\r\n?/g, zD = /\u0000|\uFFFD/g;
  function qS(t) {
    return (typeof t == "string" ? t : "" + t).replace($D, `
`).replace(zD, "");
  }
  function Jf(t, e, n) {
    if (e = qS(e), qS(t) !== e && n)
      throw Error(Z(425));
  }
  function Nd() {
  }
  var Rv = null, _v = null;
  function Dv(t, e) {
    return t === "textarea" || t === "noscript" || typeof e.children == "string" || typeof e.children == "number" || typeof e.dangerouslySetInnerHTML == "object" && e.dangerouslySetInnerHTML !== null && e.dangerouslySetInnerHTML.__html != null;
  }
  var Iv = typeof setTimeout == "function" ? setTimeout : void 0, FD = typeof clearTimeout == "function" ? clearTimeout : void 0, GS = typeof Promise == "function" ? Promise : void 0, VD = typeof queueMicrotask == "function" ? queueMicrotask : typeof GS < "u" ? function(t) {
    return GS.resolve(null).then(t).catch(WD);
  } : Iv;
  function WD(t) {
    setTimeout(function() {
      throw t;
    });
  }
  function Hg(t, e) {
    var n = e, r = 0;
    do {
      var i = n.nextSibling;
      if (t.removeChild(n), i && i.nodeType === 8)
        if (n = i.data, n === "/$") {
          if (r === 0) {
            t.removeChild(i), au(e);
            return;
          }
          r--;
        } else
          n !== "$" && n !== "$?" && n !== "$!" || r++;
      n = i;
    } while (n);
    au(e);
  }
  function No(t) {
    for (; t != null; t = t.nextSibling) {
      var e = t.nodeType;
      if (e === 1 || e === 3)
        break;
      if (e === 8) {
        if (e = t.data, e === "$" || e === "$!" || e === "$?")
          break;
        if (e === "/$")
          return null;
      }
    }
    return t;
  }
  function YS(t) {
    t = t.previousSibling;
    for (var e = 0; t; ) {
      if (t.nodeType === 8) {
        var n = t.data;
        if (n === "$" || n === "$!" || n === "$?") {
          if (e === 0)
            return t;
          e--;
        } else
          n === "/$" && e++;
      }
      t = t.previousSibling;
    }
    return null;
  }
  var Cl = Math.random().toString(36).slice(2), di = "__reactFiber$" + Cl, hu = "__reactProps$" + Cl, Xi = "__reactContainer$" + Cl, Bv = "__reactEvents$" + Cl, HD = "__reactListeners$" + Cl, jD = "__reactHandles$" + Cl;
  function Cs(t) {
    var e = t[di];
    if (e)
      return e;
    for (var n = t.parentNode; n; ) {
      if (e = n[Xi] || n[di]) {
        if (n = e.alternate, e.child !== null || n !== null && n.child !== null)
          for (t = YS(t); t !== null; ) {
            if (n = t[di])
              return n;
            t = YS(t);
          }
        return e;
      }
      t = n, n = t.parentNode;
    }
    return null;
  }
  function Xu(t) {
    return t = t[di] || t[Xi], !t || t.tag !== 5 && t.tag !== 6 && t.tag !== 13 && t.tag !== 3 ? null : t;
  }
  function ya(t) {
    if (t.tag === 5 || t.tag === 6)
      return t.stateNode;
    throw Error(Z(33));
  }
  function Gp(t) {
    return t[hu] || null;
  }
  var Nv = [], ba = -1;
  function es(t) {
    return {
      current: t
    };
  }
  function at(t) {
    0 > ba || (t.current = Nv[ba], Nv[ba] = null, ba--);
  }
  function rt(t, e) {
    ba++, Nv[ba] = t.current, t.current = e;
  }
  var jo = {}, dn = es(jo), Nn = es(false), zs = jo;
  function nl(t, e) {
    var n = t.type.contextTypes;
    if (!n)
      return jo;
    var r = t.stateNode;
    if (r && r.__reactInternalMemoizedUnmaskedChildContext === e)
      return r.__reactInternalMemoizedMaskedChildContext;
    var i = {}, o;
    for (o in n)
      i[o] = e[o];
    return r && (t = t.stateNode, t.__reactInternalMemoizedUnmaskedChildContext = e, t.__reactInternalMemoizedMaskedChildContext = i), i;
  }
  function $n(t) {
    return t = t.childContextTypes, t != null;
  }
  function $d() {
    at(Nn), at(dn);
  }
  function XS(t, e, n) {
    if (dn.current !== jo)
      throw Error(Z(168));
    rt(dn, e), rt(Nn, n);
  }
  function g2(t, e, n) {
    var r = t.stateNode;
    if (e = e.childContextTypes, typeof r.getChildContext != "function")
      return n;
    r = r.getChildContext();
    for (var i in r)
      if (!(i in e))
        throw Error(Z(108, E_(t) || "Unknown", i));
    return gt({}, n, r);
  }
  function zd(t) {
    return t = (t = t.stateNode) && t.__reactInternalMemoizedMergedChildContext || jo, zs = dn.current, rt(dn, t), rt(Nn, Nn.current), true;
  }
  function QS(t, e, n) {
    var r = t.stateNode;
    if (!r)
      throw Error(Z(169));
    n ? (t = g2(t, e, zs), r.__reactInternalMemoizedMergedChildContext = t, at(Nn), at(dn), rt(dn, t)) : at(Nn), rt(Nn, n);
  }
  var $i = null, Yp = false, jg = false;
  function v2(t) {
    $i === null ? $i = [
      t
    ] : $i.push(t);
  }
  function UD(t) {
    Yp = true, v2(t);
  }
  function ts() {
    if (!jg && $i !== null) {
      jg = true;
      var t = 0, e = Ye;
      try {
        var n = $i;
        for (Ye = 1; t < n.length; t++) {
          var r = n[t];
          do
            r = r(true);
          while (r !== null);
        }
        $i = null, Yp = false;
      } catch (i) {
        throw $i !== null && ($i = $i.slice(t + 1)), WM(K1, ts), i;
      } finally {
        Ye = e, jg = false;
      }
    }
    return null;
  }
  var xa = [], Sa = 0, Fd = null, Vd = 0, ur = [], fr = 0, Fs = null, Hi = 1, ji = "";
  function vs(t, e) {
    xa[Sa++] = Vd, xa[Sa++] = Fd, Fd = t, Vd = e;
  }
  function y2(t, e, n) {
    ur[fr++] = Hi, ur[fr++] = ji, ur[fr++] = Fs, Fs = t;
    var r = Hi;
    t = ji;
    var i = 32 - Vr(r) - 1;
    r &= ~(1 << i), n += 1;
    var o = 32 - Vr(e) + i;
    if (30 < o) {
      var s = i - i % 5;
      o = (r & (1 << s) - 1).toString(32), r >>= s, i -= s, Hi = 1 << 32 - Vr(e) + i | n << i | r, ji = o + t;
    } else
      Hi = 1 << o | n << i | r, ji = t;
  }
  function tb(t) {
    t.return !== null && (vs(t, 1), y2(t, 1, 0));
  }
  function nb(t) {
    for (; t === Fd; )
      Fd = xa[--Sa], xa[Sa] = null, Vd = xa[--Sa], xa[Sa] = null;
    for (; t === Fs; )
      Fs = ur[--fr], ur[fr] = null, ji = ur[--fr], ur[fr] = null, Hi = ur[--fr], ur[fr] = null;
  }
  var qn = null, Un = null, ut = false, Br = null;
  function b2(t, e) {
    var n = dr(5, null, null, 0);
    n.elementType = "DELETED", n.stateNode = e, n.return = t, e = t.deletions, e === null ? (t.deletions = [
      n
    ], t.flags |= 16) : e.push(n);
  }
  function JS(t, e) {
    switch (t.tag) {
      case 5:
        var n = t.type;
        return e = e.nodeType !== 1 || n.toLowerCase() !== e.nodeName.toLowerCase() ? null : e, e !== null ? (t.stateNode = e, qn = t, Un = No(e.firstChild), true) : false;
      case 6:
        return e = t.pendingProps === "" || e.nodeType !== 3 ? null : e, e !== null ? (t.stateNode = e, qn = t, Un = null, true) : false;
      case 13:
        return e = e.nodeType !== 8 ? null : e, e !== null ? (n = Fs !== null ? {
          id: Hi,
          overflow: ji
        } : null, t.memoizedState = {
          dehydrated: e,
          treeContext: n,
          retryLane: 1073741824
        }, n = dr(18, null, null, 0), n.stateNode = e, n.return = t, t.child = n, qn = t, Un = null, true) : false;
      default:
        return false;
    }
  }
  function $v(t) {
    return (t.mode & 1) !== 0 && (t.flags & 128) === 0;
  }
  function zv(t) {
    if (ut) {
      var e = Un;
      if (e) {
        var n = e;
        if (!JS(t, e)) {
          if ($v(t))
            throw Error(Z(418));
          e = No(n.nextSibling);
          var r = qn;
          e && JS(t, e) ? b2(r, n) : (t.flags = t.flags & -4097 | 2, ut = false, qn = t);
        }
      } else {
        if ($v(t))
          throw Error(Z(418));
        t.flags = t.flags & -4097 | 2, ut = false, qn = t;
      }
    }
  }
  function ZS(t) {
    for (t = t.return; t !== null && t.tag !== 5 && t.tag !== 3 && t.tag !== 13; )
      t = t.return;
    qn = t;
  }
  function Zf(t) {
    if (t !== qn)
      return false;
    if (!ut)
      return ZS(t), ut = true, false;
    var e;
    if ((e = t.tag !== 3) && !(e = t.tag !== 5) && (e = t.type, e = e !== "head" && e !== "body" && !Dv(t.type, t.memoizedProps)), e && (e = Un)) {
      if ($v(t))
        throw x2(), Error(Z(418));
      for (; e; )
        b2(t, e), e = No(e.nextSibling);
    }
    if (ZS(t), t.tag === 13) {
      if (t = t.memoizedState, t = t !== null ? t.dehydrated : null, !t)
        throw Error(Z(317));
      e: {
        for (t = t.nextSibling, e = 0; t; ) {
          if (t.nodeType === 8) {
            var n = t.data;
            if (n === "/$") {
              if (e === 0) {
                Un = No(t.nextSibling);
                break e;
              }
              e--;
            } else
              n !== "$" && n !== "$!" && n !== "$?" || e++;
          }
          t = t.nextSibling;
        }
        Un = null;
      }
    } else
      Un = qn ? No(t.stateNode.nextSibling) : null;
    return true;
  }
  function x2() {
    for (var t = Un; t; )
      t = No(t.nextSibling);
  }
  function rl() {
    Un = qn = null, ut = false;
  }
  function rb(t) {
    Br === null ? Br = [
      t
    ] : Br.push(t);
  }
  var KD = oo.ReactCurrentBatchConfig;
  function _r(t, e) {
    if (t && t.defaultProps) {
      e = gt({}, e), t = t.defaultProps;
      for (var n in t)
        e[n] === void 0 && (e[n] = t[n]);
      return e;
    }
    return e;
  }
  var Wd = es(null), Hd = null, wa = null, ib = null;
  function ob() {
    ib = wa = Hd = null;
  }
  function sb(t) {
    var e = Wd.current;
    at(Wd), t._currentValue = e;
  }
  function Fv(t, e, n) {
    for (; t !== null; ) {
      var r = t.alternate;
      if ((t.childLanes & e) !== e ? (t.childLanes |= e, r !== null && (r.childLanes |= e)) : r !== null && (r.childLanes & e) !== e && (r.childLanes |= e), t === n)
        break;
      t = t.return;
    }
  }
  function Fa(t, e) {
    Hd = t, ib = wa = null, t = t.dependencies, t !== null && t.firstContext !== null && ((t.lanes & e) !== 0 && (Dn = true), t.firstContext = null);
  }
  function Sr(t) {
    var e = t._currentValue;
    if (ib !== t)
      if (t = {
        context: t,
        memoizedValue: e,
        next: null
      }, wa === null) {
        if (Hd === null)
          throw Error(Z(308));
        wa = t, Hd.dependencies = {
          lanes: 0,
          firstContext: t
        };
      } else
        wa = wa.next = t;
    return e;
  }
  var Ts = null;
  function ab(t) {
    Ts === null ? Ts = [
      t
    ] : Ts.push(t);
  }
  function S2(t, e, n, r) {
    var i = e.interleaved;
    return i === null ? (n.next = n, ab(e)) : (n.next = i.next, i.next = n), e.interleaved = n, Qi(t, r);
  }
  function Qi(t, e) {
    t.lanes |= e;
    var n = t.alternate;
    for (n !== null && (n.lanes |= e), n = t, t = t.return; t !== null; )
      t.childLanes |= e, n = t.alternate, n !== null && (n.childLanes |= e), n = t, t = t.return;
    return n.tag === 3 ? n.stateNode : null;
  }
  var bo = false;
  function lb(t) {
    t.updateQueue = {
      baseState: t.memoizedState,
      firstBaseUpdate: null,
      lastBaseUpdate: null,
      shared: {
        pending: null,
        interleaved: null,
        lanes: 0
      },
      effects: null
    };
  }
  function w2(t, e) {
    t = t.updateQueue, e.updateQueue === t && (e.updateQueue = {
      baseState: t.baseState,
      firstBaseUpdate: t.firstBaseUpdate,
      lastBaseUpdate: t.lastBaseUpdate,
      shared: t.shared,
      effects: t.effects
    });
  }
  function Ki(t, e) {
    return {
      eventTime: t,
      lane: e,
      tag: 0,
      payload: null,
      callback: null,
      next: null
    };
  }
  function $o(t, e, n) {
    var r = t.updateQueue;
    if (r === null)
      return null;
    if (r = r.shared, (We & 2) !== 0) {
      var i = r.pending;
      return i === null ? e.next = e : (e.next = i.next, i.next = e), r.pending = e, Qi(t, n);
    }
    return i = r.interleaved, i === null ? (e.next = e, ab(r)) : (e.next = i.next, i.next = e), r.interleaved = e, Qi(t, n);
  }
  function Yh(t, e, n) {
    if (e = e.updateQueue, e !== null && (e = e.shared, (n & 4194240) !== 0)) {
      var r = e.lanes;
      r &= t.pendingLanes, n |= r, e.lanes = n, q1(t, n);
    }
  }
  function ew(t, e) {
    var n = t.updateQueue, r = t.alternate;
    if (r !== null && (r = r.updateQueue, n === r)) {
      var i = null, o = null;
      if (n = n.firstBaseUpdate, n !== null) {
        do {
          var s = {
            eventTime: n.eventTime,
            lane: n.lane,
            tag: n.tag,
            payload: n.payload,
            callback: n.callback,
            next: null
          };
          o === null ? i = o = s : o = o.next = s, n = n.next;
        } while (n !== null);
        o === null ? i = o = e : o = o.next = e;
      } else
        i = o = e;
      n = {
        baseState: r.baseState,
        firstBaseUpdate: i,
        lastBaseUpdate: o,
        shared: r.shared,
        effects: r.effects
      }, t.updateQueue = n;
      return;
    }
    t = n.lastBaseUpdate, t === null ? n.firstBaseUpdate = e : t.next = e, n.lastBaseUpdate = e;
  }
  function jd(t, e, n, r) {
    var i = t.updateQueue;
    bo = false;
    var o = i.firstBaseUpdate, s = i.lastBaseUpdate, a = i.shared.pending;
    if (a !== null) {
      i.shared.pending = null;
      var l = a, c = l.next;
      l.next = null, s === null ? o = c : s.next = c, s = l;
      var u = t.alternate;
      u !== null && (u = u.updateQueue, a = u.lastBaseUpdate, a !== s && (a === null ? u.firstBaseUpdate = c : a.next = c, u.lastBaseUpdate = l));
    }
    if (o !== null) {
      var h = i.baseState;
      s = 0, u = c = l = null, a = o;
      do {
        var p = a.lane, v = a.eventTime;
        if ((r & p) === p) {
          u !== null && (u = u.next = {
            eventTime: v,
            lane: 0,
            tag: a.tag,
            payload: a.payload,
            callback: a.callback,
            next: null
          });
          e: {
            var y = t, S = a;
            switch (p = e, v = n, S.tag) {
              case 1:
                if (y = S.payload, typeof y == "function") {
                  h = y.call(v, h, p);
                  break e;
                }
                h = y;
                break e;
              case 3:
                y.flags = y.flags & -65537 | 128;
              case 0:
                if (y = S.payload, p = typeof y == "function" ? y.call(v, h, p) : y, p == null)
                  break e;
                h = gt({}, h, p);
                break e;
              case 2:
                bo = true;
            }
          }
          a.callback !== null && a.lane !== 0 && (t.flags |= 64, p = i.effects, p === null ? i.effects = [
            a
          ] : p.push(a));
        } else
          v = {
            eventTime: v,
            lane: p,
            tag: a.tag,
            payload: a.payload,
            callback: a.callback,
            next: null
          }, u === null ? (c = u = v, l = h) : u = u.next = v, s |= p;
        if (a = a.next, a === null) {
          if (a = i.shared.pending, a === null)
            break;
          p = a, a = p.next, p.next = null, i.lastBaseUpdate = p, i.shared.pending = null;
        }
      } while (1);
      if (u === null && (l = h), i.baseState = l, i.firstBaseUpdate = c, i.lastBaseUpdate = u, e = i.shared.interleaved, e !== null) {
        i = e;
        do
          s |= i.lane, i = i.next;
        while (i !== e);
      } else
        o === null && (i.shared.lanes = 0);
      Ws |= s, t.lanes = s, t.memoizedState = h;
    }
  }
  function tw(t, e, n) {
    if (t = e.effects, e.effects = null, t !== null)
      for (e = 0; e < t.length; e++) {
        var r = t[e], i = r.callback;
        if (i !== null) {
          if (r.callback = null, r = n, typeof i != "function")
            throw Error(Z(191, i));
          i.call(r);
        }
      }
  }
  var k2 = new SM.Component().refs;
  function Vv(t, e, n, r) {
    e = t.memoizedState, n = n(r, e), n = n == null ? e : gt({}, e, n), t.memoizedState = n, t.lanes === 0 && (t.updateQueue.baseState = n);
  }
  var Xp = {
    isMounted: function(t) {
      return (t = t._reactInternals) ? Qs(t) === t : false;
    },
    enqueueSetState: function(t, e, n) {
      t = t._reactInternals;
      var r = Sn(), i = Fo(t), o = Ki(r, i);
      o.payload = e, n != null && (o.callback = n), e = $o(t, o, i), e !== null && (Wr(e, t, i, r), Yh(e, t, i));
    },
    enqueueReplaceState: function(t, e, n) {
      t = t._reactInternals;
      var r = Sn(), i = Fo(t), o = Ki(r, i);
      o.tag = 1, o.payload = e, n != null && (o.callback = n), e = $o(t, o, i), e !== null && (Wr(e, t, i, r), Yh(e, t, i));
    },
    enqueueForceUpdate: function(t, e) {
      t = t._reactInternals;
      var n = Sn(), r = Fo(t), i = Ki(n, r);
      i.tag = 2, e != null && (i.callback = e), e = $o(t, i, r), e !== null && (Wr(e, t, r, n), Yh(e, t, r));
    }
  };
  function nw(t, e, n, r, i, o, s) {
    return t = t.stateNode, typeof t.shouldComponentUpdate == "function" ? t.shouldComponentUpdate(r, o, s) : e.prototype && e.prototype.isPureReactComponent ? !cu(n, r) || !cu(i, o) : true;
  }
  function C2(t, e, n) {
    var r = false, i = jo, o = e.contextType;
    return typeof o == "object" && o !== null ? o = Sr(o) : (i = $n(e) ? zs : dn.current, r = e.contextTypes, o = (r = r != null) ? nl(t, i) : jo), e = new e(n, o), t.memoizedState = e.state !== null && e.state !== void 0 ? e.state : null, e.updater = Xp, t.stateNode = e, e._reactInternals = t, r && (t = t.stateNode, t.__reactInternalMemoizedUnmaskedChildContext = i, t.__reactInternalMemoizedMaskedChildContext = o), e;
  }
  function rw(t, e, n, r) {
    t = e.state, typeof e.componentWillReceiveProps == "function" && e.componentWillReceiveProps(n, r), typeof e.UNSAFE_componentWillReceiveProps == "function" && e.UNSAFE_componentWillReceiveProps(n, r), e.state !== t && Xp.enqueueReplaceState(e, e.state, null);
  }
  function Wv(t, e, n, r) {
    var i = t.stateNode;
    i.props = n, i.state = t.memoizedState, i.refs = k2, lb(t);
    var o = e.contextType;
    typeof o == "object" && o !== null ? i.context = Sr(o) : (o = $n(e) ? zs : dn.current, i.context = nl(t, o)), i.state = t.memoizedState, o = e.getDerivedStateFromProps, typeof o == "function" && (Vv(t, e, o, n), i.state = t.memoizedState), typeof e.getDerivedStateFromProps == "function" || typeof i.getSnapshotBeforeUpdate == "function" || typeof i.UNSAFE_componentWillMount != "function" && typeof i.componentWillMount != "function" || (e = i.state, typeof i.componentWillMount == "function" && i.componentWillMount(), typeof i.UNSAFE_componentWillMount == "function" && i.UNSAFE_componentWillMount(), e !== i.state && Xp.enqueueReplaceState(i, i.state, null), jd(t, n, i, r), i.state = t.memoizedState), typeof i.componentDidMount == "function" && (t.flags |= 4194308);
  }
  function Yl(t, e, n) {
    if (t = n.ref, t !== null && typeof t != "function" && typeof t != "object") {
      if (n._owner) {
        if (n = n._owner, n) {
          if (n.tag !== 1)
            throw Error(Z(309));
          var r = n.stateNode;
        }
        if (!r)
          throw Error(Z(147, t));
        var i = r, o = "" + t;
        return e !== null && e.ref !== null && typeof e.ref == "function" && e.ref._stringRef === o ? e.ref : (e = function(s) {
          var a = i.refs;
          a === k2 && (a = i.refs = {}), s === null ? delete a[o] : a[o] = s;
        }, e._stringRef = o, e);
      }
      if (typeof t != "string")
        throw Error(Z(284));
      if (!n._owner)
        throw Error(Z(290, t));
    }
    return t;
  }
  function eh(t, e) {
    throw t = Object.prototype.toString.call(e), Error(Z(31, t === "[object Object]" ? "object with keys {" + Object.keys(e).join(", ") + "}" : t));
  }
  function iw(t) {
    var e = t._init;
    return e(t._payload);
  }
  function T2(t) {
    function e(w, k) {
      if (t) {
        var C = w.deletions;
        C === null ? (w.deletions = [
          k
        ], w.flags |= 16) : C.push(k);
      }
    }
    function n(w, k) {
      if (!t)
        return null;
      for (; k !== null; )
        e(w, k), k = k.sibling;
      return null;
    }
    function r(w, k) {
      for (w = /* @__PURE__ */ new Map(); k !== null; )
        k.key !== null ? w.set(k.key, k) : w.set(k.index, k), k = k.sibling;
      return w;
    }
    function i(w, k) {
      return w = Vo(w, k), w.index = 0, w.sibling = null, w;
    }
    function o(w, k, C) {
      return w.index = C, t ? (C = w.alternate, C !== null ? (C = C.index, C < k ? (w.flags |= 2, k) : C) : (w.flags |= 2, k)) : (w.flags |= 1048576, k);
    }
    function s(w) {
      return t && w.alternate === null && (w.flags |= 2), w;
    }
    function a(w, k, C, O) {
      return k === null || k.tag !== 6 ? (k = Qg(C, w.mode, O), k.return = w, k) : (k = i(k, C), k.return = w, k);
    }
    function l(w, k, C, O) {
      var L = C.type;
      return L === pa ? u(w, k, C.props.children, O, C.key) : k !== null && (k.elementType === L || typeof L == "object" && L !== null && L.$$typeof === yo && iw(L) === k.type) ? (O = i(k, C.props), O.ref = Yl(w, k, C), O.return = w, O) : (O = td(C.type, C.key, C.props, null, w.mode, O), O.ref = Yl(w, k, C), O.return = w, O);
    }
    function c(w, k, C, O) {
      return k === null || k.tag !== 4 || k.stateNode.containerInfo !== C.containerInfo || k.stateNode.implementation !== C.implementation ? (k = Jg(C, w.mode, O), k.return = w, k) : (k = i(k, C.children || []), k.return = w, k);
    }
    function u(w, k, C, O, L) {
      return k === null || k.tag !== 7 ? (k = _s(C, w.mode, O, L), k.return = w, k) : (k = i(k, C), k.return = w, k);
    }
    function h(w, k, C) {
      if (typeof k == "string" && k !== "" || typeof k == "number")
        return k = Qg("" + k, w.mode, C), k.return = w, k;
      if (typeof k == "object" && k !== null) {
        switch (k.$$typeof) {
          case Hf:
            return C = td(k.type, k.key, k.props, null, w.mode, C), C.ref = Yl(w, null, k), C.return = w, C;
          case da:
            return k = Jg(k, w.mode, C), k.return = w, k;
          case yo:
            var O = k._init;
            return h(w, O(k._payload), C);
        }
        if (uc(k) || jl(k))
          return k = _s(k, w.mode, C, null), k.return = w, k;
        eh(w, k);
      }
      return null;
    }
    function p(w, k, C, O) {
      var L = k !== null ? k.key : null;
      if (typeof C == "string" && C !== "" || typeof C == "number")
        return L !== null ? null : a(w, k, "" + C, O);
      if (typeof C == "object" && C !== null) {
        switch (C.$$typeof) {
          case Hf:
            return C.key === L ? l(w, k, C, O) : null;
          case da:
            return C.key === L ? c(w, k, C, O) : null;
          case yo:
            return L = C._init, p(w, k, L(C._payload), O);
        }
        if (uc(C) || jl(C))
          return L !== null ? null : u(w, k, C, O, null);
        eh(w, C);
      }
      return null;
    }
    function v(w, k, C, O, L) {
      if (typeof O == "string" && O !== "" || typeof O == "number")
        return w = w.get(C) || null, a(k, w, "" + O, L);
      if (typeof O == "object" && O !== null) {
        switch (O.$$typeof) {
          case Hf:
            return w = w.get(O.key === null ? C : O.key) || null, l(k, w, O, L);
          case da:
            return w = w.get(O.key === null ? C : O.key) || null, c(k, w, O, L);
          case yo:
            var D = O._init;
            return v(w, k, C, D(O._payload), L);
        }
        if (uc(O) || jl(O))
          return w = w.get(C) || null, u(k, w, O, L, null);
        eh(k, O);
      }
      return null;
    }
    function y(w, k, C, O) {
      for (var L = null, D = null, R = k, F = k = 0, K = null; R !== null && F < C.length; F++) {
        R.index > F ? (K = R, R = null) : K = R.sibling;
        var Y = p(w, R, C[F], O);
        if (Y === null) {
          R === null && (R = K);
          break;
        }
        t && R && Y.alternate === null && e(w, R), k = o(Y, k, F), D === null ? L = Y : D.sibling = Y, D = Y, R = K;
      }
      if (F === C.length)
        return n(w, R), ut && vs(w, F), L;
      if (R === null) {
        for (; F < C.length; F++)
          R = h(w, C[F], O), R !== null && (k = o(R, k, F), D === null ? L = R : D.sibling = R, D = R);
        return ut && vs(w, F), L;
      }
      for (R = r(w, R); F < C.length; F++)
        K = v(R, w, F, C[F], O), K !== null && (t && K.alternate !== null && R.delete(K.key === null ? F : K.key), k = o(K, k, F), D === null ? L = K : D.sibling = K, D = K);
      return t && R.forEach(function(te) {
        return e(w, te);
      }), ut && vs(w, F), L;
    }
    function S(w, k, C, O) {
      var L = jl(C);
      if (typeof L != "function")
        throw Error(Z(150));
      if (C = L.call(C), C == null)
        throw Error(Z(151));
      for (var D = L = null, R = k, F = k = 0, K = null, Y = C.next(); R !== null && !Y.done; F++, Y = C.next()) {
        R.index > F ? (K = R, R = null) : K = R.sibling;
        var te = p(w, R, Y.value, O);
        if (te === null) {
          R === null && (R = K);
          break;
        }
        t && R && te.alternate === null && e(w, R), k = o(te, k, F), D === null ? L = te : D.sibling = te, D = te, R = K;
      }
      if (Y.done)
        return n(w, R), ut && vs(w, F), L;
      if (R === null) {
        for (; !Y.done; F++, Y = C.next())
          Y = h(w, Y.value, O), Y !== null && (k = o(Y, k, F), D === null ? L = Y : D.sibling = Y, D = Y);
        return ut && vs(w, F), L;
      }
      for (R = r(w, R); !Y.done; F++, Y = C.next())
        Y = v(R, w, F, Y.value, O), Y !== null && (t && Y.alternate !== null && R.delete(Y.key === null ? F : Y.key), k = o(Y, k, F), D === null ? L = Y : D.sibling = Y, D = Y);
      return t && R.forEach(function(ne) {
        return e(w, ne);
      }), ut && vs(w, F), L;
    }
    function T(w, k, C, O) {
      if (typeof C == "object" && C !== null && C.type === pa && C.key === null && (C = C.props.children), typeof C == "object" && C !== null) {
        switch (C.$$typeof) {
          case Hf:
            e: {
              for (var L = C.key, D = k; D !== null; ) {
                if (D.key === L) {
                  if (L = C.type, L === pa) {
                    if (D.tag === 7) {
                      n(w, D.sibling), k = i(D, C.props.children), k.return = w, w = k;
                      break e;
                    }
                  } else if (D.elementType === L || typeof L == "object" && L !== null && L.$$typeof === yo && iw(L) === D.type) {
                    n(w, D.sibling), k = i(D, C.props), k.ref = Yl(w, D, C), k.return = w, w = k;
                    break e;
                  }
                  n(w, D);
                  break;
                } else
                  e(w, D);
                D = D.sibling;
              }
              C.type === pa ? (k = _s(C.props.children, w.mode, O, C.key), k.return = w, w = k) : (O = td(C.type, C.key, C.props, null, w.mode, O), O.ref = Yl(w, k, C), O.return = w, w = O);
            }
            return s(w);
          case da:
            e: {
              for (D = C.key; k !== null; ) {
                if (k.key === D)
                  if (k.tag === 4 && k.stateNode.containerInfo === C.containerInfo && k.stateNode.implementation === C.implementation) {
                    n(w, k.sibling), k = i(k, C.children || []), k.return = w, w = k;
                    break e;
                  } else {
                    n(w, k);
                    break;
                  }
                else
                  e(w, k);
                k = k.sibling;
              }
              k = Jg(C, w.mode, O), k.return = w, w = k;
            }
            return s(w);
          case yo:
            return D = C._init, T(w, k, D(C._payload), O);
        }
        if (uc(C))
          return y(w, k, C, O);
        if (jl(C))
          return S(w, k, C, O);
        eh(w, C);
      }
      return typeof C == "string" && C !== "" || typeof C == "number" ? (C = "" + C, k !== null && k.tag === 6 ? (n(w, k.sibling), k = i(k, C), k.return = w, w = k) : (n(w, k), k = Qg(C, w.mode, O), k.return = w, w = k), s(w)) : n(w, k);
    }
    return T;
  }
  var il = T2(true), M2 = T2(false), Qu = {}, wi = es(Qu), du = es(Qu), pu = es(Qu);
  function Ms(t) {
    if (t === Qu)
      throw Error(Z(174));
    return t;
  }
  function cb(t, e) {
    switch (rt(pu, e), rt(du, t), rt(wi, Qu), t = e.nodeType, t) {
      case 9:
      case 11:
        e = (e = e.documentElement) ? e.namespaceURI : xv(null, "");
        break;
      default:
        t = t === 8 ? e.parentNode : e, e = t.namespaceURI || null, t = t.tagName, e = xv(e, t);
    }
    at(wi), rt(wi, e);
  }
  function ol() {
    at(wi), at(du), at(pu);
  }
  function A2(t) {
    Ms(pu.current);
    var e = Ms(wi.current), n = xv(e, t.type);
    e !== n && (rt(du, t), rt(wi, n));
  }
  function ub(t) {
    du.current === t && (at(wi), at(du));
  }
  var pt = es(0);
  function Ud(t) {
    for (var e = t; e !== null; ) {
      if (e.tag === 13) {
        var n = e.memoizedState;
        if (n !== null && (n = n.dehydrated, n === null || n.data === "$?" || n.data === "$!"))
          return e;
      } else if (e.tag === 19 && e.memoizedProps.revealOrder !== void 0) {
        if ((e.flags & 128) !== 0)
          return e;
      } else if (e.child !== null) {
        e.child.return = e, e = e.child;
        continue;
      }
      if (e === t)
        break;
      for (; e.sibling === null; ) {
        if (e.return === null || e.return === t)
          return null;
        e = e.return;
      }
      e.sibling.return = e.return, e = e.sibling;
    }
    return null;
  }
  var Ug = [];
  function fb() {
    for (var t = 0; t < Ug.length; t++)
      Ug[t]._workInProgressVersionPrimary = null;
    Ug.length = 0;
  }
  var Xh = oo.ReactCurrentDispatcher, Kg = oo.ReactCurrentBatchConfig, Vs = 0, mt = null, _t = null, Vt = null, Kd = false, Pc = false, mu = 0, qD = 0;
  function an() {
    throw Error(Z(321));
  }
  function hb(t, e) {
    if (e === null)
      return false;
    for (var n = 0; n < e.length && n < t.length; n++)
      if (!Kr(t[n], e[n]))
        return false;
    return true;
  }
  function db(t, e, n, r, i, o) {
    if (Vs = o, mt = e, e.memoizedState = null, e.updateQueue = null, e.lanes = 0, Xh.current = t === null || t.memoizedState === null ? QD : JD, t = n(r, i), Pc) {
      o = 0;
      do {
        if (Pc = false, mu = 0, 25 <= o)
          throw Error(Z(301));
        o += 1, Vt = _t = null, e.updateQueue = null, Xh.current = ZD, t = n(r, i);
      } while (Pc);
    }
    if (Xh.current = qd, e = _t !== null && _t.next !== null, Vs = 0, Vt = _t = mt = null, Kd = false, e)
      throw Error(Z(300));
    return t;
  }
  function pb() {
    var t = mu !== 0;
    return mu = 0, t;
  }
  function ai() {
    var t = {
      memoizedState: null,
      baseState: null,
      baseQueue: null,
      queue: null,
      next: null
    };
    return Vt === null ? mt.memoizedState = Vt = t : Vt = Vt.next = t, Vt;
  }
  function wr() {
    if (_t === null) {
      var t = mt.alternate;
      t = t !== null ? t.memoizedState : null;
    } else
      t = _t.next;
    var e = Vt === null ? mt.memoizedState : Vt.next;
    if (e !== null)
      Vt = e, _t = t;
    else {
      if (t === null)
        throw Error(Z(310));
      _t = t, t = {
        memoizedState: _t.memoizedState,
        baseState: _t.baseState,
        baseQueue: _t.baseQueue,
        queue: _t.queue,
        next: null
      }, Vt === null ? mt.memoizedState = Vt = t : Vt = Vt.next = t;
    }
    return Vt;
  }
  function gu(t, e) {
    return typeof e == "function" ? e(t) : e;
  }
  function qg(t) {
    var e = wr(), n = e.queue;
    if (n === null)
      throw Error(Z(311));
    n.lastRenderedReducer = t;
    var r = _t, i = r.baseQueue, o = n.pending;
    if (o !== null) {
      if (i !== null) {
        var s = i.next;
        i.next = o.next, o.next = s;
      }
      r.baseQueue = i = o, n.pending = null;
    }
    if (i !== null) {
      o = i.next, r = r.baseState;
      var a = s = null, l = null, c = o;
      do {
        var u = c.lane;
        if ((Vs & u) === u)
          l !== null && (l = l.next = {
            lane: 0,
            action: c.action,
            hasEagerState: c.hasEagerState,
            eagerState: c.eagerState,
            next: null
          }), r = c.hasEagerState ? c.eagerState : t(r, c.action);
        else {
          var h = {
            lane: u,
            action: c.action,
            hasEagerState: c.hasEagerState,
            eagerState: c.eagerState,
            next: null
          };
          l === null ? (a = l = h, s = r) : l = l.next = h, mt.lanes |= u, Ws |= u;
        }
        c = c.next;
      } while (c !== null && c !== o);
      l === null ? s = r : l.next = a, Kr(r, e.memoizedState) || (Dn = true), e.memoizedState = r, e.baseState = s, e.baseQueue = l, n.lastRenderedState = r;
    }
    if (t = n.interleaved, t !== null) {
      i = t;
      do
        o = i.lane, mt.lanes |= o, Ws |= o, i = i.next;
      while (i !== t);
    } else
      i === null && (n.lanes = 0);
    return [
      e.memoizedState,
      n.dispatch
    ];
  }
  function Gg(t) {
    var e = wr(), n = e.queue;
    if (n === null)
      throw Error(Z(311));
    n.lastRenderedReducer = t;
    var r = n.dispatch, i = n.pending, o = e.memoizedState;
    if (i !== null) {
      n.pending = null;
      var s = i = i.next;
      do
        o = t(o, s.action), s = s.next;
      while (s !== i);
      Kr(o, e.memoizedState) || (Dn = true), e.memoizedState = o, e.baseQueue === null && (e.baseState = o), n.lastRenderedState = o;
    }
    return [
      o,
      r
    ];
  }
  function E2() {
  }
  function P2(t, e) {
    var n = mt, r = wr(), i = e(), o = !Kr(r.memoizedState, i);
    if (o && (r.memoizedState = i, Dn = true), r = r.queue, mb(R2.bind(null, n, r, t), [
      t
    ]), r.getSnapshot !== e || o || Vt !== null && Vt.memoizedState.tag & 1) {
      if (n.flags |= 2048, vu(9, L2.bind(null, n, r, i, e), void 0, null), jt === null)
        throw Error(Z(349));
      (Vs & 30) !== 0 || O2(n, e, i);
    }
    return i;
  }
  function O2(t, e, n) {
    t.flags |= 16384, t = {
      getSnapshot: e,
      value: n
    }, e = mt.updateQueue, e === null ? (e = {
      lastEffect: null,
      stores: null
    }, mt.updateQueue = e, e.stores = [
      t
    ]) : (n = e.stores, n === null ? e.stores = [
      t
    ] : n.push(t));
  }
  function L2(t, e, n, r) {
    e.value = n, e.getSnapshot = r, _2(e) && D2(t);
  }
  function R2(t, e, n) {
    return n(function() {
      _2(e) && D2(t);
    });
  }
  function _2(t) {
    var e = t.getSnapshot;
    t = t.value;
    try {
      var n = e();
      return !Kr(t, n);
    } catch {
      return true;
    }
  }
  function D2(t) {
    var e = Qi(t, 1);
    e !== null && Wr(e, t, 1, -1);
  }
  function ow(t) {
    var e = ai();
    return typeof t == "function" && (t = t()), e.memoizedState = e.baseState = t, t = {
      pending: null,
      interleaved: null,
      lanes: 0,
      dispatch: null,
      lastRenderedReducer: gu,
      lastRenderedState: t
    }, e.queue = t, t = t.dispatch = XD.bind(null, mt, t), [
      e.memoizedState,
      t
    ];
  }
  function vu(t, e, n, r) {
    return t = {
      tag: t,
      create: e,
      destroy: n,
      deps: r,
      next: null
    }, e = mt.updateQueue, e === null ? (e = {
      lastEffect: null,
      stores: null
    }, mt.updateQueue = e, e.lastEffect = t.next = t) : (n = e.lastEffect, n === null ? e.lastEffect = t.next = t : (r = n.next, n.next = t, t.next = r, e.lastEffect = t)), t;
  }
  function I2() {
    return wr().memoizedState;
  }
  function Qh(t, e, n, r) {
    var i = ai();
    mt.flags |= t, i.memoizedState = vu(1 | e, n, void 0, r === void 0 ? null : r);
  }
  function Qp(t, e, n, r) {
    var i = wr();
    r = r === void 0 ? null : r;
    var o = void 0;
    if (_t !== null) {
      var s = _t.memoizedState;
      if (o = s.destroy, r !== null && hb(r, s.deps)) {
        i.memoizedState = vu(e, n, o, r);
        return;
      }
    }
    mt.flags |= t, i.memoizedState = vu(1 | e, n, o, r);
  }
  function sw(t, e) {
    return Qh(8390656, 8, t, e);
  }
  function mb(t, e) {
    return Qp(2048, 8, t, e);
  }
  function B2(t, e) {
    return Qp(4, 2, t, e);
  }
  function N2(t, e) {
    return Qp(4, 4, t, e);
  }
  function $2(t, e) {
    if (typeof e == "function")
      return t = t(), e(t), function() {
        e(null);
      };
    if (e != null)
      return t = t(), e.current = t, function() {
        e.current = null;
      };
  }
  function z2(t, e, n) {
    return n = n != null ? n.concat([
      t
    ]) : null, Qp(4, 4, $2.bind(null, e, t), n);
  }
  function gb() {
  }
  function F2(t, e) {
    var n = wr();
    e = e === void 0 ? null : e;
    var r = n.memoizedState;
    return r !== null && e !== null && hb(e, r[1]) ? r[0] : (n.memoizedState = [
      t,
      e
    ], t);
  }
  function V2(t, e) {
    var n = wr();
    e = e === void 0 ? null : e;
    var r = n.memoizedState;
    return r !== null && e !== null && hb(e, r[1]) ? r[0] : (t = t(), n.memoizedState = [
      t,
      e
    ], t);
  }
  function W2(t, e, n) {
    return (Vs & 21) === 0 ? (t.baseState && (t.baseState = false, Dn = true), t.memoizedState = n) : (Kr(n, e) || (n = UM(), mt.lanes |= n, Ws |= n, t.baseState = true), e);
  }
  function GD(t, e) {
    var n = Ye;
    Ye = n !== 0 && 4 > n ? n : 4, t(true);
    var r = Kg.transition;
    Kg.transition = {};
    try {
      t(false), e();
    } finally {
      Ye = n, Kg.transition = r;
    }
  }
  function H2() {
    return wr().memoizedState;
  }
  function YD(t, e, n) {
    var r = Fo(t);
    if (n = {
      lane: r,
      action: n,
      hasEagerState: false,
      eagerState: null,
      next: null
    }, j2(t))
      U2(e, n);
    else if (n = S2(t, e, n, r), n !== null) {
      var i = Sn();
      Wr(n, t, r, i), K2(n, e, r);
    }
  }
  function XD(t, e, n) {
    var r = Fo(t), i = {
      lane: r,
      action: n,
      hasEagerState: false,
      eagerState: null,
      next: null
    };
    if (j2(t))
      U2(e, i);
    else {
      var o = t.alternate;
      if (t.lanes === 0 && (o === null || o.lanes === 0) && (o = e.lastRenderedReducer, o !== null))
        try {
          var s = e.lastRenderedState, a = o(s, n);
          if (i.hasEagerState = true, i.eagerState = a, Kr(a, s)) {
            var l = e.interleaved;
            l === null ? (i.next = i, ab(e)) : (i.next = l.next, l.next = i), e.interleaved = i;
            return;
          }
        } catch {
        } finally {
        }
      n = S2(t, e, i, r), n !== null && (i = Sn(), Wr(n, t, r, i), K2(n, e, r));
    }
  }
  function j2(t) {
    var e = t.alternate;
    return t === mt || e !== null && e === mt;
  }
  function U2(t, e) {
    Pc = Kd = true;
    var n = t.pending;
    n === null ? e.next = e : (e.next = n.next, n.next = e), t.pending = e;
  }
  function K2(t, e, n) {
    if ((n & 4194240) !== 0) {
      var r = e.lanes;
      r &= t.pendingLanes, n |= r, e.lanes = n, q1(t, n);
    }
  }
  var qd = {
    readContext: Sr,
    useCallback: an,
    useContext: an,
    useEffect: an,
    useImperativeHandle: an,
    useInsertionEffect: an,
    useLayoutEffect: an,
    useMemo: an,
    useReducer: an,
    useRef: an,
    useState: an,
    useDebugValue: an,
    useDeferredValue: an,
    useTransition: an,
    useMutableSource: an,
    useSyncExternalStore: an,
    useId: an,
    unstable_isNewReconciler: false
  }, QD = {
    readContext: Sr,
    useCallback: function(t, e) {
      return ai().memoizedState = [
        t,
        e === void 0 ? null : e
      ], t;
    },
    useContext: Sr,
    useEffect: sw,
    useImperativeHandle: function(t, e, n) {
      return n = n != null ? n.concat([
        t
      ]) : null, Qh(4194308, 4, $2.bind(null, e, t), n);
    },
    useLayoutEffect: function(t, e) {
      return Qh(4194308, 4, t, e);
    },
    useInsertionEffect: function(t, e) {
      return Qh(4, 2, t, e);
    },
    useMemo: function(t, e) {
      var n = ai();
      return e = e === void 0 ? null : e, t = t(), n.memoizedState = [
        t,
        e
      ], t;
    },
    useReducer: function(t, e, n) {
      var r = ai();
      return e = n !== void 0 ? n(e) : e, r.memoizedState = r.baseState = e, t = {
        pending: null,
        interleaved: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: t,
        lastRenderedState: e
      }, r.queue = t, t = t.dispatch = YD.bind(null, mt, t), [
        r.memoizedState,
        t
      ];
    },
    useRef: function(t) {
      var e = ai();
      return t = {
        current: t
      }, e.memoizedState = t;
    },
    useState: ow,
    useDebugValue: gb,
    useDeferredValue: function(t) {
      return ai().memoizedState = t;
    },
    useTransition: function() {
      var t = ow(false), e = t[0];
      return t = GD.bind(null, t[1]), ai().memoizedState = t, [
        e,
        t
      ];
    },
    useMutableSource: function() {
    },
    useSyncExternalStore: function(t, e, n) {
      var r = mt, i = ai();
      if (ut) {
        if (n === void 0)
          throw Error(Z(407));
        n = n();
      } else {
        if (n = e(), jt === null)
          throw Error(Z(349));
        (Vs & 30) !== 0 || O2(r, e, n);
      }
      i.memoizedState = n;
      var o = {
        value: n,
        getSnapshot: e
      };
      return i.queue = o, sw(R2.bind(null, r, o, t), [
        t
      ]), r.flags |= 2048, vu(9, L2.bind(null, r, o, n, e), void 0, null), n;
    },
    useId: function() {
      var t = ai(), e = jt.identifierPrefix;
      if (ut) {
        var n = ji, r = Hi;
        n = (r & ~(1 << 32 - Vr(r) - 1)).toString(32) + n, e = ":" + e + "R" + n, n = mu++, 0 < n && (e += "H" + n.toString(32)), e += ":";
      } else
        n = qD++, e = ":" + e + "r" + n.toString(32) + ":";
      return t.memoizedState = e;
    },
    unstable_isNewReconciler: false
  }, JD = {
    readContext: Sr,
    useCallback: F2,
    useContext: Sr,
    useEffect: mb,
    useImperativeHandle: z2,
    useInsertionEffect: B2,
    useLayoutEffect: N2,
    useMemo: V2,
    useReducer: qg,
    useRef: I2,
    useState: function() {
      return qg(gu);
    },
    useDebugValue: gb,
    useDeferredValue: function(t) {
      var e = wr();
      return W2(e, _t.memoizedState, t);
    },
    useTransition: function() {
      var t = qg(gu)[0], e = wr().memoizedState;
      return [
        t,
        e
      ];
    },
    useMutableSource: E2,
    useSyncExternalStore: P2,
    useId: H2,
    unstable_isNewReconciler: false
  }, ZD = {
    readContext: Sr,
    useCallback: F2,
    useContext: Sr,
    useEffect: mb,
    useImperativeHandle: z2,
    useInsertionEffect: B2,
    useLayoutEffect: N2,
    useMemo: V2,
    useReducer: Gg,
    useRef: I2,
    useState: function() {
      return Gg(gu);
    },
    useDebugValue: gb,
    useDeferredValue: function(t) {
      var e = wr();
      return _t === null ? e.memoizedState = t : W2(e, _t.memoizedState, t);
    },
    useTransition: function() {
      var t = Gg(gu)[0], e = wr().memoizedState;
      return [
        t,
        e
      ];
    },
    useMutableSource: E2,
    useSyncExternalStore: P2,
    useId: H2,
    unstable_isNewReconciler: false
  };
  function sl(t, e) {
    try {
      var n = "", r = e;
      do
        n += A_(r), r = r.return;
      while (r);
      var i = n;
    } catch (o) {
      i = `
Error generating stack: ` + o.message + `
` + o.stack;
    }
    return {
      value: t,
      source: e,
      stack: i,
      digest: null
    };
  }
  function Yg(t, e, n) {
    return {
      value: t,
      source: null,
      stack: n ?? null,
      digest: e ?? null
    };
  }
  function Hv(t, e) {
    try {
      console.error(e.value);
    } catch (n) {
      setTimeout(function() {
        throw n;
      });
    }
  }
  var eI = typeof WeakMap == "function" ? WeakMap : Map;
  function q2(t, e, n) {
    n = Ki(-1, n), n.tag = 3, n.payload = {
      element: null
    };
    var r = e.value;
    return n.callback = function() {
      Yd || (Yd = true, Zv = r), Hv(t, e);
    }, n;
  }
  function G2(t, e, n) {
    n = Ki(-1, n), n.tag = 3;
    var r = t.type.getDerivedStateFromError;
    if (typeof r == "function") {
      var i = e.value;
      n.payload = function() {
        return r(i);
      }, n.callback = function() {
        Hv(t, e);
      };
    }
    var o = t.stateNode;
    return o !== null && typeof o.componentDidCatch == "function" && (n.callback = function() {
      Hv(t, e), typeof r != "function" && (zo === null ? zo = /* @__PURE__ */ new Set([
        this
      ]) : zo.add(this));
      var s = e.stack;
      this.componentDidCatch(e.value, {
        componentStack: s !== null ? s : ""
      });
    }), n;
  }
  function aw(t, e, n) {
    var r = t.pingCache;
    if (r === null) {
      r = t.pingCache = new eI();
      var i = /* @__PURE__ */ new Set();
      r.set(e, i);
    } else
      i = r.get(e), i === void 0 && (i = /* @__PURE__ */ new Set(), r.set(e, i));
    i.has(n) || (i.add(n), t = pI.bind(null, t, e, n), e.then(t, t));
  }
  function lw(t) {
    do {
      var e;
      if ((e = t.tag === 13) && (e = t.memoizedState, e = e !== null ? e.dehydrated !== null : true), e)
        return t;
      t = t.return;
    } while (t !== null);
    return null;
  }
  function cw(t, e, n, r, i) {
    return (t.mode & 1) === 0 ? (t === e ? t.flags |= 65536 : (t.flags |= 128, n.flags |= 131072, n.flags &= -52805, n.tag === 1 && (n.alternate === null ? n.tag = 17 : (e = Ki(-1, 1), e.tag = 2, $o(n, e, 1))), n.lanes |= 1), t) : (t.flags |= 65536, t.lanes = i, t);
  }
  var tI = oo.ReactCurrentOwner, Dn = false;
  function yn(t, e, n, r) {
    e.child = t === null ? M2(e, null, n, r) : il(e, t.child, n, r);
  }
  function uw(t, e, n, r, i) {
    n = n.render;
    var o = e.ref;
    return Fa(e, i), r = db(t, e, n, r, o, i), n = pb(), t !== null && !Dn ? (e.updateQueue = t.updateQueue, e.flags &= -2053, t.lanes &= ~i, Ji(t, e, i)) : (ut && n && tb(e), e.flags |= 1, yn(t, e, r, i), e.child);
  }
  function fw(t, e, n, r, i) {
    if (t === null) {
      var o = n.type;
      return typeof o == "function" && !Cb(o) && o.defaultProps === void 0 && n.compare === null && n.defaultProps === void 0 ? (e.tag = 15, e.type = o, Y2(t, e, o, r, i)) : (t = td(n.type, null, r, e, e.mode, i), t.ref = e.ref, t.return = e, e.child = t);
    }
    if (o = t.child, (t.lanes & i) === 0) {
      var s = o.memoizedProps;
      if (n = n.compare, n = n !== null ? n : cu, n(s, r) && t.ref === e.ref)
        return Ji(t, e, i);
    }
    return e.flags |= 1, t = Vo(o, r), t.ref = e.ref, t.return = e, e.child = t;
  }
  function Y2(t, e, n, r, i) {
    if (t !== null) {
      var o = t.memoizedProps;
      if (cu(o, r) && t.ref === e.ref)
        if (Dn = false, e.pendingProps = r = o, (t.lanes & i) !== 0)
          (t.flags & 131072) !== 0 && (Dn = true);
        else
          return e.lanes = t.lanes, Ji(t, e, i);
    }
    return jv(t, e, n, r, i);
  }
  function X2(t, e, n) {
    var r = e.pendingProps, i = r.children, o = t !== null ? t.memoizedState : null;
    if (r.mode === "hidden")
      if ((e.mode & 1) === 0)
        e.memoizedState = {
          baseLanes: 0,
          cachePool: null,
          transitions: null
        }, rt(Ca, Hn), Hn |= n;
      else {
        if ((n & 1073741824) === 0)
          return t = o !== null ? o.baseLanes | n : n, e.lanes = e.childLanes = 1073741824, e.memoizedState = {
            baseLanes: t,
            cachePool: null,
            transitions: null
          }, e.updateQueue = null, rt(Ca, Hn), Hn |= t, null;
        e.memoizedState = {
          baseLanes: 0,
          cachePool: null,
          transitions: null
        }, r = o !== null ? o.baseLanes : n, rt(Ca, Hn), Hn |= r;
      }
    else
      o !== null ? (r = o.baseLanes | n, e.memoizedState = null) : r = n, rt(Ca, Hn), Hn |= r;
    return yn(t, e, i, n), e.child;
  }
  function Q2(t, e) {
    var n = e.ref;
    (t === null && n !== null || t !== null && t.ref !== n) && (e.flags |= 512, e.flags |= 2097152);
  }
  function jv(t, e, n, r, i) {
    var o = $n(n) ? zs : dn.current;
    return o = nl(e, o), Fa(e, i), n = db(t, e, n, r, o, i), r = pb(), t !== null && !Dn ? (e.updateQueue = t.updateQueue, e.flags &= -2053, t.lanes &= ~i, Ji(t, e, i)) : (ut && r && tb(e), e.flags |= 1, yn(t, e, n, i), e.child);
  }
  function hw(t, e, n, r, i) {
    if ($n(n)) {
      var o = true;
      zd(e);
    } else
      o = false;
    if (Fa(e, i), e.stateNode === null)
      Jh(t, e), C2(e, n, r), Wv(e, n, r, i), r = true;
    else if (t === null) {
      var s = e.stateNode, a = e.memoizedProps;
      s.props = a;
      var l = s.context, c = n.contextType;
      typeof c == "object" && c !== null ? c = Sr(c) : (c = $n(n) ? zs : dn.current, c = nl(e, c));
      var u = n.getDerivedStateFromProps, h = typeof u == "function" || typeof s.getSnapshotBeforeUpdate == "function";
      h || typeof s.UNSAFE_componentWillReceiveProps != "function" && typeof s.componentWillReceiveProps != "function" || (a !== r || l !== c) && rw(e, s, r, c), bo = false;
      var p = e.memoizedState;
      s.state = p, jd(e, r, s, i), l = e.memoizedState, a !== r || p !== l || Nn.current || bo ? (typeof u == "function" && (Vv(e, n, u, r), l = e.memoizedState), (a = bo || nw(e, n, a, r, p, l, c)) ? (h || typeof s.UNSAFE_componentWillMount != "function" && typeof s.componentWillMount != "function" || (typeof s.componentWillMount == "function" && s.componentWillMount(), typeof s.UNSAFE_componentWillMount == "function" && s.UNSAFE_componentWillMount()), typeof s.componentDidMount == "function" && (e.flags |= 4194308)) : (typeof s.componentDidMount == "function" && (e.flags |= 4194308), e.memoizedProps = r, e.memoizedState = l), s.props = r, s.state = l, s.context = c, r = a) : (typeof s.componentDidMount == "function" && (e.flags |= 4194308), r = false);
    } else {
      s = e.stateNode, w2(t, e), a = e.memoizedProps, c = e.type === e.elementType ? a : _r(e.type, a), s.props = c, h = e.pendingProps, p = s.context, l = n.contextType, typeof l == "object" && l !== null ? l = Sr(l) : (l = $n(n) ? zs : dn.current, l = nl(e, l));
      var v = n.getDerivedStateFromProps;
      (u = typeof v == "function" || typeof s.getSnapshotBeforeUpdate == "function") || typeof s.UNSAFE_componentWillReceiveProps != "function" && typeof s.componentWillReceiveProps != "function" || (a !== h || p !== l) && rw(e, s, r, l), bo = false, p = e.memoizedState, s.state = p, jd(e, r, s, i);
      var y = e.memoizedState;
      a !== h || p !== y || Nn.current || bo ? (typeof v == "function" && (Vv(e, n, v, r), y = e.memoizedState), (c = bo || nw(e, n, c, r, p, y, l) || false) ? (u || typeof s.UNSAFE_componentWillUpdate != "function" && typeof s.componentWillUpdate != "function" || (typeof s.componentWillUpdate == "function" && s.componentWillUpdate(r, y, l), typeof s.UNSAFE_componentWillUpdate == "function" && s.UNSAFE_componentWillUpdate(r, y, l)), typeof s.componentDidUpdate == "function" && (e.flags |= 4), typeof s.getSnapshotBeforeUpdate == "function" && (e.flags |= 1024)) : (typeof s.componentDidUpdate != "function" || a === t.memoizedProps && p === t.memoizedState || (e.flags |= 4), typeof s.getSnapshotBeforeUpdate != "function" || a === t.memoizedProps && p === t.memoizedState || (e.flags |= 1024), e.memoizedProps = r, e.memoizedState = y), s.props = r, s.state = y, s.context = l, r = c) : (typeof s.componentDidUpdate != "function" || a === t.memoizedProps && p === t.memoizedState || (e.flags |= 4), typeof s.getSnapshotBeforeUpdate != "function" || a === t.memoizedProps && p === t.memoizedState || (e.flags |= 1024), r = false);
    }
    return Uv(t, e, n, r, o, i);
  }
  function Uv(t, e, n, r, i, o) {
    Q2(t, e);
    var s = (e.flags & 128) !== 0;
    if (!r && !s)
      return i && QS(e, n, false), Ji(t, e, o);
    r = e.stateNode, tI.current = e;
    var a = s && typeof n.getDerivedStateFromError != "function" ? null : r.render();
    return e.flags |= 1, t !== null && s ? (e.child = il(e, t.child, null, o), e.child = il(e, null, a, o)) : yn(t, e, a, o), e.memoizedState = r.state, i && QS(e, n, true), e.child;
  }
  function J2(t) {
    var e = t.stateNode;
    e.pendingContext ? XS(t, e.pendingContext, e.pendingContext !== e.context) : e.context && XS(t, e.context, false), cb(t, e.containerInfo);
  }
  function dw(t, e, n, r, i) {
    return rl(), rb(i), e.flags |= 256, yn(t, e, n, r), e.child;
  }
  var Kv = {
    dehydrated: null,
    treeContext: null,
    retryLane: 0
  };
  function qv(t) {
    return {
      baseLanes: t,
      cachePool: null,
      transitions: null
    };
  }
  function Z2(t, e, n) {
    var r = e.pendingProps, i = pt.current, o = false, s = (e.flags & 128) !== 0, a;
    if ((a = s) || (a = t !== null && t.memoizedState === null ? false : (i & 2) !== 0), a ? (o = true, e.flags &= -129) : (t === null || t.memoizedState !== null) && (i |= 1), rt(pt, i & 1), t === null)
      return zv(e), t = e.memoizedState, t !== null && (t = t.dehydrated, t !== null) ? ((e.mode & 1) === 0 ? e.lanes = 1 : t.data === "$!" ? e.lanes = 8 : e.lanes = 1073741824, null) : (s = r.children, t = r.fallback, o ? (r = e.mode, o = e.child, s = {
        mode: "hidden",
        children: s
      }, (r & 1) === 0 && o !== null ? (o.childLanes = 0, o.pendingProps = s) : o = em(s, r, 0, null), t = _s(t, r, n, null), o.return = e, t.return = e, o.sibling = t, e.child = o, e.child.memoizedState = qv(n), e.memoizedState = Kv, t) : vb(e, s));
    if (i = t.memoizedState, i !== null && (a = i.dehydrated, a !== null))
      return nI(t, e, s, r, a, i, n);
    if (o) {
      o = r.fallback, s = e.mode, i = t.child, a = i.sibling;
      var l = {
        mode: "hidden",
        children: r.children
      };
      return (s & 1) === 0 && e.child !== i ? (r = e.child, r.childLanes = 0, r.pendingProps = l, e.deletions = null) : (r = Vo(i, l), r.subtreeFlags = i.subtreeFlags & 14680064), a !== null ? o = Vo(a, o) : (o = _s(o, s, n, null), o.flags |= 2), o.return = e, r.return = e, r.sibling = o, e.child = r, r = o, o = e.child, s = t.child.memoizedState, s = s === null ? qv(n) : {
        baseLanes: s.baseLanes | n,
        cachePool: null,
        transitions: s.transitions
      }, o.memoizedState = s, o.childLanes = t.childLanes & ~n, e.memoizedState = Kv, r;
    }
    return o = t.child, t = o.sibling, r = Vo(o, {
      mode: "visible",
      children: r.children
    }), (e.mode & 1) === 0 && (r.lanes = n), r.return = e, r.sibling = null, t !== null && (n = e.deletions, n === null ? (e.deletions = [
      t
    ], e.flags |= 16) : n.push(t)), e.child = r, e.memoizedState = null, r;
  }
  function vb(t, e) {
    return e = em({
      mode: "visible",
      children: e
    }, t.mode, 0, null), e.return = t, t.child = e;
  }
  function th(t, e, n, r) {
    return r !== null && rb(r), il(e, t.child, null, n), t = vb(e, e.pendingProps.children), t.flags |= 2, e.memoizedState = null, t;
  }
  function nI(t, e, n, r, i, o, s) {
    if (n)
      return e.flags & 256 ? (e.flags &= -257, r = Yg(Error(Z(422))), th(t, e, s, r)) : e.memoizedState !== null ? (e.child = t.child, e.flags |= 128, null) : (o = r.fallback, i = e.mode, r = em({
        mode: "visible",
        children: r.children
      }, i, 0, null), o = _s(o, i, s, null), o.flags |= 2, r.return = e, o.return = e, r.sibling = o, e.child = r, (e.mode & 1) !== 0 && il(e, t.child, null, s), e.child.memoizedState = qv(s), e.memoizedState = Kv, o);
    if ((e.mode & 1) === 0)
      return th(t, e, s, null);
    if (i.data === "$!") {
      if (r = i.nextSibling && i.nextSibling.dataset, r)
        var a = r.dgst;
      return r = a, o = Error(Z(419)), r = Yg(o, r, void 0), th(t, e, s, r);
    }
    if (a = (s & t.childLanes) !== 0, Dn || a) {
      if (r = jt, r !== null) {
        switch (s & -s) {
          case 4:
            i = 2;
            break;
          case 16:
            i = 8;
            break;
          case 64:
          case 128:
          case 256:
          case 512:
          case 1024:
          case 2048:
          case 4096:
          case 8192:
          case 16384:
          case 32768:
          case 65536:
          case 131072:
          case 262144:
          case 524288:
          case 1048576:
          case 2097152:
          case 4194304:
          case 8388608:
          case 16777216:
          case 33554432:
          case 67108864:
            i = 32;
            break;
          case 536870912:
            i = 268435456;
            break;
          default:
            i = 0;
        }
        i = (i & (r.suspendedLanes | s)) !== 0 ? 0 : i, i !== 0 && i !== o.retryLane && (o.retryLane = i, Qi(t, i), Wr(r, t, i, -1));
      }
      return kb(), r = Yg(Error(Z(421))), th(t, e, s, r);
    }
    return i.data === "$?" ? (e.flags |= 128, e.child = t.child, e = mI.bind(null, t), i._reactRetry = e, null) : (t = o.treeContext, Un = No(i.nextSibling), qn = e, ut = true, Br = null, t !== null && (ur[fr++] = Hi, ur[fr++] = ji, ur[fr++] = Fs, Hi = t.id, ji = t.overflow, Fs = e), e = vb(e, r.children), e.flags |= 4096, e);
  }
  function pw(t, e, n) {
    t.lanes |= e;
    var r = t.alternate;
    r !== null && (r.lanes |= e), Fv(t.return, e, n);
  }
  function Xg(t, e, n, r, i) {
    var o = t.memoizedState;
    o === null ? t.memoizedState = {
      isBackwards: e,
      rendering: null,
      renderingStartTime: 0,
      last: r,
      tail: n,
      tailMode: i
    } : (o.isBackwards = e, o.rendering = null, o.renderingStartTime = 0, o.last = r, o.tail = n, o.tailMode = i);
  }
  function eA(t, e, n) {
    var r = e.pendingProps, i = r.revealOrder, o = r.tail;
    if (yn(t, e, r.children, n), r = pt.current, (r & 2) !== 0)
      r = r & 1 | 2, e.flags |= 128;
    else {
      if (t !== null && (t.flags & 128) !== 0)
        e:
          for (t = e.child; t !== null; ) {
            if (t.tag === 13)
              t.memoizedState !== null && pw(t, n, e);
            else if (t.tag === 19)
              pw(t, n, e);
            else if (t.child !== null) {
              t.child.return = t, t = t.child;
              continue;
            }
            if (t === e)
              break e;
            for (; t.sibling === null; ) {
              if (t.return === null || t.return === e)
                break e;
              t = t.return;
            }
            t.sibling.return = t.return, t = t.sibling;
          }
      r &= 1;
    }
    if (rt(pt, r), (e.mode & 1) === 0)
      e.memoizedState = null;
    else
      switch (i) {
        case "forwards":
          for (n = e.child, i = null; n !== null; )
            t = n.alternate, t !== null && Ud(t) === null && (i = n), n = n.sibling;
          n = i, n === null ? (i = e.child, e.child = null) : (i = n.sibling, n.sibling = null), Xg(e, false, i, n, o);
          break;
        case "backwards":
          for (n = null, i = e.child, e.child = null; i !== null; ) {
            if (t = i.alternate, t !== null && Ud(t) === null) {
              e.child = i;
              break;
            }
            t = i.sibling, i.sibling = n, n = i, i = t;
          }
          Xg(e, true, n, null, o);
          break;
        case "together":
          Xg(e, false, null, null, void 0);
          break;
        default:
          e.memoizedState = null;
      }
    return e.child;
  }
  function Jh(t, e) {
    (e.mode & 1) === 0 && t !== null && (t.alternate = null, e.alternate = null, e.flags |= 2);
  }
  function Ji(t, e, n) {
    if (t !== null && (e.dependencies = t.dependencies), Ws |= e.lanes, (n & e.childLanes) === 0)
      return null;
    if (t !== null && e.child !== t.child)
      throw Error(Z(153));
    if (e.child !== null) {
      for (t = e.child, n = Vo(t, t.pendingProps), e.child = n, n.return = e; t.sibling !== null; )
        t = t.sibling, n = n.sibling = Vo(t, t.pendingProps), n.return = e;
      n.sibling = null;
    }
    return e.child;
  }
  function rI(t, e, n) {
    switch (e.tag) {
      case 3:
        J2(e), rl();
        break;
      case 5:
        A2(e);
        break;
      case 1:
        $n(e.type) && zd(e);
        break;
      case 4:
        cb(e, e.stateNode.containerInfo);
        break;
      case 10:
        var r = e.type._context, i = e.memoizedProps.value;
        rt(Wd, r._currentValue), r._currentValue = i;
        break;
      case 13:
        if (r = e.memoizedState, r !== null)
          return r.dehydrated !== null ? (rt(pt, pt.current & 1), e.flags |= 128, null) : (n & e.child.childLanes) !== 0 ? Z2(t, e, n) : (rt(pt, pt.current & 1), t = Ji(t, e, n), t !== null ? t.sibling : null);
        rt(pt, pt.current & 1);
        break;
      case 19:
        if (r = (n & e.childLanes) !== 0, (t.flags & 128) !== 0) {
          if (r)
            return eA(t, e, n);
          e.flags |= 128;
        }
        if (i = e.memoizedState, i !== null && (i.rendering = null, i.tail = null, i.lastEffect = null), rt(pt, pt.current), r)
          break;
        return null;
      case 22:
      case 23:
        return e.lanes = 0, X2(t, e, n);
    }
    return Ji(t, e, n);
  }
  var tA, Gv, nA, rA;
  tA = function(t, e) {
    for (var n = e.child; n !== null; ) {
      if (n.tag === 5 || n.tag === 6)
        t.appendChild(n.stateNode);
      else if (n.tag !== 4 && n.child !== null) {
        n.child.return = n, n = n.child;
        continue;
      }
      if (n === e)
        break;
      for (; n.sibling === null; ) {
        if (n.return === null || n.return === e)
          return;
        n = n.return;
      }
      n.sibling.return = n.return, n = n.sibling;
    }
  };
  Gv = function() {
  };
  nA = function(t, e, n, r) {
    var i = t.memoizedProps;
    if (i !== r) {
      t = e.stateNode, Ms(wi.current);
      var o = null;
      switch (n) {
        case "input":
          i = gv(t, i), r = gv(t, r), o = [];
          break;
        case "select":
          i = gt({}, i, {
            value: void 0
          }), r = gt({}, r, {
            value: void 0
          }), o = [];
          break;
        case "textarea":
          i = bv(t, i), r = bv(t, r), o = [];
          break;
        default:
          typeof i.onClick != "function" && typeof r.onClick == "function" && (t.onclick = Nd);
      }
      Sv(n, r);
      var s;
      n = null;
      for (c in i)
        if (!r.hasOwnProperty(c) && i.hasOwnProperty(c) && i[c] != null)
          if (c === "style") {
            var a = i[c];
            for (s in a)
              a.hasOwnProperty(s) && (n || (n = {}), n[s] = "");
          } else
            c !== "dangerouslySetInnerHTML" && c !== "children" && c !== "suppressContentEditableWarning" && c !== "suppressHydrationWarning" && c !== "autoFocus" && (nu.hasOwnProperty(c) ? o || (o = []) : (o = o || []).push(c, null));
      for (c in r) {
        var l = r[c];
        if (a = i == null ? void 0 : i[c], r.hasOwnProperty(c) && l !== a && (l != null || a != null))
          if (c === "style")
            if (a) {
              for (s in a)
                !a.hasOwnProperty(s) || l && l.hasOwnProperty(s) || (n || (n = {}), n[s] = "");
              for (s in l)
                l.hasOwnProperty(s) && a[s] !== l[s] && (n || (n = {}), n[s] = l[s]);
            } else
              n || (o || (o = []), o.push(c, n)), n = l;
          else
            c === "dangerouslySetInnerHTML" ? (l = l ? l.__html : void 0, a = a ? a.__html : void 0, l != null && a !== l && (o = o || []).push(c, l)) : c === "children" ? typeof l != "string" && typeof l != "number" || (o = o || []).push(c, "" + l) : c !== "suppressContentEditableWarning" && c !== "suppressHydrationWarning" && (nu.hasOwnProperty(c) ? (l != null && c === "onScroll" && ot("scroll", t), o || a === l || (o = [])) : (o = o || []).push(c, l));
      }
      n && (o = o || []).push("style", n);
      var c = o;
      (e.updateQueue = c) && (e.flags |= 4);
    }
  };
  rA = function(t, e, n, r) {
    n !== r && (e.flags |= 4);
  };
  function Xl(t, e) {
    if (!ut)
      switch (t.tailMode) {
        case "hidden":
          e = t.tail;
          for (var n = null; e !== null; )
            e.alternate !== null && (n = e), e = e.sibling;
          n === null ? t.tail = null : n.sibling = null;
          break;
        case "collapsed":
          n = t.tail;
          for (var r = null; n !== null; )
            n.alternate !== null && (r = n), n = n.sibling;
          r === null ? e || t.tail === null ? t.tail = null : t.tail.sibling = null : r.sibling = null;
      }
  }
  function ln(t) {
    var e = t.alternate !== null && t.alternate.child === t.child, n = 0, r = 0;
    if (e)
      for (var i = t.child; i !== null; )
        n |= i.lanes | i.childLanes, r |= i.subtreeFlags & 14680064, r |= i.flags & 14680064, i.return = t, i = i.sibling;
    else
      for (i = t.child; i !== null; )
        n |= i.lanes | i.childLanes, r |= i.subtreeFlags, r |= i.flags, i.return = t, i = i.sibling;
    return t.subtreeFlags |= r, t.childLanes = n, e;
  }
  function iI(t, e, n) {
    var r = e.pendingProps;
    switch (nb(e), e.tag) {
      case 2:
      case 16:
      case 15:
      case 0:
      case 11:
      case 7:
      case 8:
      case 12:
      case 9:
      case 14:
        return ln(e), null;
      case 1:
        return $n(e.type) && $d(), ln(e), null;
      case 3:
        return r = e.stateNode, ol(), at(Nn), at(dn), fb(), r.pendingContext && (r.context = r.pendingContext, r.pendingContext = null), (t === null || t.child === null) && (Zf(e) ? e.flags |= 4 : t === null || t.memoizedState.isDehydrated && (e.flags & 256) === 0 || (e.flags |= 1024, Br !== null && (ny(Br), Br = null))), Gv(t, e), ln(e), null;
      case 5:
        ub(e);
        var i = Ms(pu.current);
        if (n = e.type, t !== null && e.stateNode != null)
          nA(t, e, n, r, i), t.ref !== e.ref && (e.flags |= 512, e.flags |= 2097152);
        else {
          if (!r) {
            if (e.stateNode === null)
              throw Error(Z(166));
            return ln(e), null;
          }
          if (t = Ms(wi.current), Zf(e)) {
            r = e.stateNode, n = e.type;
            var o = e.memoizedProps;
            switch (r[di] = e, r[hu] = o, t = (e.mode & 1) !== 0, n) {
              case "dialog":
                ot("cancel", r), ot("close", r);
                break;
              case "iframe":
              case "object":
              case "embed":
                ot("load", r);
                break;
              case "video":
              case "audio":
                for (i = 0; i < hc.length; i++)
                  ot(hc[i], r);
                break;
              case "source":
                ot("error", r);
                break;
              case "img":
              case "image":
              case "link":
                ot("error", r), ot("load", r);
                break;
              case "details":
                ot("toggle", r);
                break;
              case "input":
                kS(r, o), ot("invalid", r);
                break;
              case "select":
                r._wrapperState = {
                  wasMultiple: !!o.multiple
                }, ot("invalid", r);
                break;
              case "textarea":
                TS(r, o), ot("invalid", r);
            }
            Sv(n, o), i = null;
            for (var s in o)
              if (o.hasOwnProperty(s)) {
                var a = o[s];
                s === "children" ? typeof a == "string" ? r.textContent !== a && (o.suppressHydrationWarning !== true && Jf(r.textContent, a, t), i = [
                  "children",
                  a
                ]) : typeof a == "number" && r.textContent !== "" + a && (o.suppressHydrationWarning !== true && Jf(r.textContent, a, t), i = [
                  "children",
                  "" + a
                ]) : nu.hasOwnProperty(s) && a != null && s === "onScroll" && ot("scroll", r);
              }
            switch (n) {
              case "input":
                jf(r), CS(r, o, true);
                break;
              case "textarea":
                jf(r), MS(r);
                break;
              case "select":
              case "option":
                break;
              default:
                typeof o.onClick == "function" && (r.onclick = Nd);
            }
            r = i, e.updateQueue = r, r !== null && (e.flags |= 4);
          } else {
            s = i.nodeType === 9 ? i : i.ownerDocument, t === "http://www.w3.org/1999/xhtml" && (t = OM(n)), t === "http://www.w3.org/1999/xhtml" ? n === "script" ? (t = s.createElement("div"), t.innerHTML = "<script><\/script>", t = t.removeChild(t.firstChild)) : typeof r.is == "string" ? t = s.createElement(n, {
              is: r.is
            }) : (t = s.createElement(n), n === "select" && (s = t, r.multiple ? s.multiple = true : r.size && (s.size = r.size))) : t = s.createElementNS(t, n), t[di] = e, t[hu] = r, tA(t, e, false, false), e.stateNode = t;
            e: {
              switch (s = wv(n, r), n) {
                case "dialog":
                  ot("cancel", t), ot("close", t), i = r;
                  break;
                case "iframe":
                case "object":
                case "embed":
                  ot("load", t), i = r;
                  break;
                case "video":
                case "audio":
                  for (i = 0; i < hc.length; i++)
                    ot(hc[i], t);
                  i = r;
                  break;
                case "source":
                  ot("error", t), i = r;
                  break;
                case "img":
                case "image":
                case "link":
                  ot("error", t), ot("load", t), i = r;
                  break;
                case "details":
                  ot("toggle", t), i = r;
                  break;
                case "input":
                  kS(t, r), i = gv(t, r), ot("invalid", t);
                  break;
                case "option":
                  i = r;
                  break;
                case "select":
                  t._wrapperState = {
                    wasMultiple: !!r.multiple
                  }, i = gt({}, r, {
                    value: void 0
                  }), ot("invalid", t);
                  break;
                case "textarea":
                  TS(t, r), i = bv(t, r), ot("invalid", t);
                  break;
                default:
                  i = r;
              }
              Sv(n, i), a = i;
              for (o in a)
                if (a.hasOwnProperty(o)) {
                  var l = a[o];
                  o === "style" ? _M(t, l) : o === "dangerouslySetInnerHTML" ? (l = l ? l.__html : void 0, l != null && LM(t, l)) : o === "children" ? typeof l == "string" ? (n !== "textarea" || l !== "") && ru(t, l) : typeof l == "number" && ru(t, "" + l) : o !== "suppressContentEditableWarning" && o !== "suppressHydrationWarning" && o !== "autoFocus" && (nu.hasOwnProperty(o) ? l != null && o === "onScroll" && ot("scroll", t) : l != null && V1(t, o, l, s));
                }
              switch (n) {
                case "input":
                  jf(t), CS(t, r, false);
                  break;
                case "textarea":
                  jf(t), MS(t);
                  break;
                case "option":
                  r.value != null && t.setAttribute("value", "" + Ho(r.value));
                  break;
                case "select":
                  t.multiple = !!r.multiple, o = r.value, o != null ? Ba(t, !!r.multiple, o, false) : r.defaultValue != null && Ba(t, !!r.multiple, r.defaultValue, true);
                  break;
                default:
                  typeof i.onClick == "function" && (t.onclick = Nd);
              }
              switch (n) {
                case "button":
                case "input":
                case "select":
                case "textarea":
                  r = !!r.autoFocus;
                  break e;
                case "img":
                  r = true;
                  break e;
                default:
                  r = false;
              }
            }
            r && (e.flags |= 4);
          }
          e.ref !== null && (e.flags |= 512, e.flags |= 2097152);
        }
        return ln(e), null;
      case 6:
        if (t && e.stateNode != null)
          rA(t, e, t.memoizedProps, r);
        else {
          if (typeof r != "string" && e.stateNode === null)
            throw Error(Z(166));
          if (n = Ms(pu.current), Ms(wi.current), Zf(e)) {
            if (r = e.stateNode, n = e.memoizedProps, r[di] = e, (o = r.nodeValue !== n) && (t = qn, t !== null))
              switch (t.tag) {
                case 3:
                  Jf(r.nodeValue, n, (t.mode & 1) !== 0);
                  break;
                case 5:
                  t.memoizedProps.suppressHydrationWarning !== true && Jf(r.nodeValue, n, (t.mode & 1) !== 0);
              }
            o && (e.flags |= 4);
          } else
            r = (n.nodeType === 9 ? n : n.ownerDocument).createTextNode(r), r[di] = e, e.stateNode = r;
        }
        return ln(e), null;
      case 13:
        if (at(pt), r = e.memoizedState, t === null || t.memoizedState !== null && t.memoizedState.dehydrated !== null) {
          if (ut && Un !== null && (e.mode & 1) !== 0 && (e.flags & 128) === 0)
            x2(), rl(), e.flags |= 98560, o = false;
          else if (o = Zf(e), r !== null && r.dehydrated !== null) {
            if (t === null) {
              if (!o)
                throw Error(Z(318));
              if (o = e.memoizedState, o = o !== null ? o.dehydrated : null, !o)
                throw Error(Z(317));
              o[di] = e;
            } else
              rl(), (e.flags & 128) === 0 && (e.memoizedState = null), e.flags |= 4;
            ln(e), o = false;
          } else
            Br !== null && (ny(Br), Br = null), o = true;
          if (!o)
            return e.flags & 65536 ? e : null;
        }
        return (e.flags & 128) !== 0 ? (e.lanes = n, e) : (r = r !== null, r !== (t !== null && t.memoizedState !== null) && r && (e.child.flags |= 8192, (e.mode & 1) !== 0 && (t === null || (pt.current & 1) !== 0 ? It === 0 && (It = 3) : kb())), e.updateQueue !== null && (e.flags |= 4), ln(e), null);
      case 4:
        return ol(), Gv(t, e), t === null && uu(e.stateNode.containerInfo), ln(e), null;
      case 10:
        return sb(e.type._context), ln(e), null;
      case 17:
        return $n(e.type) && $d(), ln(e), null;
      case 19:
        if (at(pt), o = e.memoizedState, o === null)
          return ln(e), null;
        if (r = (e.flags & 128) !== 0, s = o.rendering, s === null)
          if (r)
            Xl(o, false);
          else {
            if (It !== 0 || t !== null && (t.flags & 128) !== 0)
              for (t = e.child; t !== null; ) {
                if (s = Ud(t), s !== null) {
                  for (e.flags |= 128, Xl(o, false), r = s.updateQueue, r !== null && (e.updateQueue = r, e.flags |= 4), e.subtreeFlags = 0, r = n, n = e.child; n !== null; )
                    o = n, t = r, o.flags &= 14680066, s = o.alternate, s === null ? (o.childLanes = 0, o.lanes = t, o.child = null, o.subtreeFlags = 0, o.memoizedProps = null, o.memoizedState = null, o.updateQueue = null, o.dependencies = null, o.stateNode = null) : (o.childLanes = s.childLanes, o.lanes = s.lanes, o.child = s.child, o.subtreeFlags = 0, o.deletions = null, o.memoizedProps = s.memoizedProps, o.memoizedState = s.memoizedState, o.updateQueue = s.updateQueue, o.type = s.type, t = s.dependencies, o.dependencies = t === null ? null : {
                      lanes: t.lanes,
                      firstContext: t.firstContext
                    }), n = n.sibling;
                  return rt(pt, pt.current & 1 | 2), e.child;
                }
                t = t.sibling;
              }
            o.tail !== null && Mt() > al && (e.flags |= 128, r = true, Xl(o, false), e.lanes = 4194304);
          }
        else {
          if (!r)
            if (t = Ud(s), t !== null) {
              if (e.flags |= 128, r = true, n = t.updateQueue, n !== null && (e.updateQueue = n, e.flags |= 4), Xl(o, true), o.tail === null && o.tailMode === "hidden" && !s.alternate && !ut)
                return ln(e), null;
            } else
              2 * Mt() - o.renderingStartTime > al && n !== 1073741824 && (e.flags |= 128, r = true, Xl(o, false), e.lanes = 4194304);
          o.isBackwards ? (s.sibling = e.child, e.child = s) : (n = o.last, n !== null ? n.sibling = s : e.child = s, o.last = s);
        }
        return o.tail !== null ? (e = o.tail, o.rendering = e, o.tail = e.sibling, o.renderingStartTime = Mt(), e.sibling = null, n = pt.current, rt(pt, r ? n & 1 | 2 : n & 1), e) : (ln(e), null);
      case 22:
      case 23:
        return wb(), r = e.memoizedState !== null, t !== null && t.memoizedState !== null !== r && (e.flags |= 8192), r && (e.mode & 1) !== 0 ? (Hn & 1073741824) !== 0 && (ln(e), e.subtreeFlags & 6 && (e.flags |= 8192)) : ln(e), null;
      case 24:
        return null;
      case 25:
        return null;
    }
    throw Error(Z(156, e.tag));
  }
  function oI(t, e) {
    switch (nb(e), e.tag) {
      case 1:
        return $n(e.type) && $d(), t = e.flags, t & 65536 ? (e.flags = t & -65537 | 128, e) : null;
      case 3:
        return ol(), at(Nn), at(dn), fb(), t = e.flags, (t & 65536) !== 0 && (t & 128) === 0 ? (e.flags = t & -65537 | 128, e) : null;
      case 5:
        return ub(e), null;
      case 13:
        if (at(pt), t = e.memoizedState, t !== null && t.dehydrated !== null) {
          if (e.alternate === null)
            throw Error(Z(340));
          rl();
        }
        return t = e.flags, t & 65536 ? (e.flags = t & -65537 | 128, e) : null;
      case 19:
        return at(pt), null;
      case 4:
        return ol(), null;
      case 10:
        return sb(e.type._context), null;
      case 22:
      case 23:
        return wb(), null;
      case 24:
        return null;
      default:
        return null;
    }
  }
  var nh = false, hn = false, sI = typeof WeakSet == "function" ? WeakSet : Set, ge = null;
  function ka(t, e) {
    var n = t.ref;
    if (n !== null)
      if (typeof n == "function")
        try {
          n(null);
        } catch (r) {
          xt(t, e, r);
        }
      else
        n.current = null;
  }
  function Yv(t, e, n) {
    try {
      n();
    } catch (r) {
      xt(t, e, r);
    }
  }
  var mw = false;
  function aI(t, e) {
    if (Rv = Dd, t = a2(), eb(t)) {
      if ("selectionStart" in t)
        var n = {
          start: t.selectionStart,
          end: t.selectionEnd
        };
      else
        e: {
          n = (n = t.ownerDocument) && n.defaultView || window;
          var r = n.getSelection && n.getSelection();
          if (r && r.rangeCount !== 0) {
            n = r.anchorNode;
            var i = r.anchorOffset, o = r.focusNode;
            r = r.focusOffset;
            try {
              n.nodeType, o.nodeType;
            } catch {
              n = null;
              break e;
            }
            var s = 0, a = -1, l = -1, c = 0, u = 0, h = t, p = null;
            t:
              for (; ; ) {
                for (var v; h !== n || i !== 0 && h.nodeType !== 3 || (a = s + i), h !== o || r !== 0 && h.nodeType !== 3 || (l = s + r), h.nodeType === 3 && (s += h.nodeValue.length), (v = h.firstChild) !== null; )
                  p = h, h = v;
                for (; ; ) {
                  if (h === t)
                    break t;
                  if (p === n && ++c === i && (a = s), p === o && ++u === r && (l = s), (v = h.nextSibling) !== null)
                    break;
                  h = p, p = h.parentNode;
                }
                h = v;
              }
            n = a === -1 || l === -1 ? null : {
              start: a,
              end: l
            };
          } else
            n = null;
        }
      n = n || {
        start: 0,
        end: 0
      };
    } else
      n = null;
    for (_v = {
      focusedElem: t,
      selectionRange: n
    }, Dd = false, ge = e; ge !== null; )
      if (e = ge, t = e.child, (e.subtreeFlags & 1028) !== 0 && t !== null)
        t.return = e, ge = t;
      else
        for (; ge !== null; ) {
          e = ge;
          try {
            var y = e.alternate;
            if ((e.flags & 1024) !== 0)
              switch (e.tag) {
                case 0:
                case 11:
                case 15:
                  break;
                case 1:
                  if (y !== null) {
                    var S = y.memoizedProps, T = y.memoizedState, w = e.stateNode, k = w.getSnapshotBeforeUpdate(e.elementType === e.type ? S : _r(e.type, S), T);
                    w.__reactInternalSnapshotBeforeUpdate = k;
                  }
                  break;
                case 3:
                  var C = e.stateNode.containerInfo;
                  C.nodeType === 1 ? C.textContent = "" : C.nodeType === 9 && C.documentElement && C.removeChild(C.documentElement);
                  break;
                case 5:
                case 6:
                case 4:
                case 17:
                  break;
                default:
                  throw Error(Z(163));
              }
          } catch (O) {
            xt(e, e.return, O);
          }
          if (t = e.sibling, t !== null) {
            t.return = e.return, ge = t;
            break;
          }
          ge = e.return;
        }
    return y = mw, mw = false, y;
  }
  function Oc(t, e, n) {
    var r = e.updateQueue;
    if (r = r !== null ? r.lastEffect : null, r !== null) {
      var i = r = r.next;
      do {
        if ((i.tag & t) === t) {
          var o = i.destroy;
          i.destroy = void 0, o !== void 0 && Yv(e, n, o);
        }
        i = i.next;
      } while (i !== r);
    }
  }
  function Jp(t, e) {
    if (e = e.updateQueue, e = e !== null ? e.lastEffect : null, e !== null) {
      var n = e = e.next;
      do {
        if ((n.tag & t) === t) {
          var r = n.create;
          n.destroy = r();
        }
        n = n.next;
      } while (n !== e);
    }
  }
  function Xv(t) {
    var e = t.ref;
    if (e !== null) {
      var n = t.stateNode;
      switch (t.tag) {
        case 5:
          t = n;
          break;
        default:
          t = n;
      }
      typeof e == "function" ? e(t) : e.current = t;
    }
  }
  function iA(t) {
    var e = t.alternate;
    e !== null && (t.alternate = null, iA(e)), t.child = null, t.deletions = null, t.sibling = null, t.tag === 5 && (e = t.stateNode, e !== null && (delete e[di], delete e[hu], delete e[Bv], delete e[HD], delete e[jD])), t.stateNode = null, t.return = null, t.dependencies = null, t.memoizedProps = null, t.memoizedState = null, t.pendingProps = null, t.stateNode = null, t.updateQueue = null;
  }
  function oA(t) {
    return t.tag === 5 || t.tag === 3 || t.tag === 4;
  }
  function gw(t) {
    e:
      for (; ; ) {
        for (; t.sibling === null; ) {
          if (t.return === null || oA(t.return))
            return null;
          t = t.return;
        }
        for (t.sibling.return = t.return, t = t.sibling; t.tag !== 5 && t.tag !== 6 && t.tag !== 18; ) {
          if (t.flags & 2 || t.child === null || t.tag === 4)
            continue e;
          t.child.return = t, t = t.child;
        }
        if (!(t.flags & 2))
          return t.stateNode;
      }
  }
  function Qv(t, e, n) {
    var r = t.tag;
    if (r === 5 || r === 6)
      t = t.stateNode, e ? n.nodeType === 8 ? n.parentNode.insertBefore(t, e) : n.insertBefore(t, e) : (n.nodeType === 8 ? (e = n.parentNode, e.insertBefore(t, n)) : (e = n, e.appendChild(t)), n = n._reactRootContainer, n != null || e.onclick !== null || (e.onclick = Nd));
    else if (r !== 4 && (t = t.child, t !== null))
      for (Qv(t, e, n), t = t.sibling; t !== null; )
        Qv(t, e, n), t = t.sibling;
  }
  function Jv(t, e, n) {
    var r = t.tag;
    if (r === 5 || r === 6)
      t = t.stateNode, e ? n.insertBefore(t, e) : n.appendChild(t);
    else if (r !== 4 && (t = t.child, t !== null))
      for (Jv(t, e, n), t = t.sibling; t !== null; )
        Jv(t, e, n), t = t.sibling;
  }
  var Yt = null, Dr = false;
  function ho(t, e, n) {
    for (n = n.child; n !== null; )
      sA(t, e, n), n = n.sibling;
  }
  function sA(t, e, n) {
    if (Si && typeof Si.onCommitFiberUnmount == "function")
      try {
        Si.onCommitFiberUnmount(jp, n);
      } catch {
      }
    switch (n.tag) {
      case 5:
        hn || ka(n, e);
      case 6:
        var r = Yt, i = Dr;
        Yt = null, ho(t, e, n), Yt = r, Dr = i, Yt !== null && (Dr ? (t = Yt, n = n.stateNode, t.nodeType === 8 ? t.parentNode.removeChild(n) : t.removeChild(n)) : Yt.removeChild(n.stateNode));
        break;
      case 18:
        Yt !== null && (Dr ? (t = Yt, n = n.stateNode, t.nodeType === 8 ? Hg(t.parentNode, n) : t.nodeType === 1 && Hg(t, n), au(t)) : Hg(Yt, n.stateNode));
        break;
      case 4:
        r = Yt, i = Dr, Yt = n.stateNode.containerInfo, Dr = true, ho(t, e, n), Yt = r, Dr = i;
        break;
      case 0:
      case 11:
      case 14:
      case 15:
        if (!hn && (r = n.updateQueue, r !== null && (r = r.lastEffect, r !== null))) {
          i = r = r.next;
          do {
            var o = i, s = o.destroy;
            o = o.tag, s !== void 0 && ((o & 2) !== 0 || (o & 4) !== 0) && Yv(n, e, s), i = i.next;
          } while (i !== r);
        }
        ho(t, e, n);
        break;
      case 1:
        if (!hn && (ka(n, e), r = n.stateNode, typeof r.componentWillUnmount == "function"))
          try {
            r.props = n.memoizedProps, r.state = n.memoizedState, r.componentWillUnmount();
          } catch (a) {
            xt(n, e, a);
          }
        ho(t, e, n);
        break;
      case 21:
        ho(t, e, n);
        break;
      case 22:
        n.mode & 1 ? (hn = (r = hn) || n.memoizedState !== null, ho(t, e, n), hn = r) : ho(t, e, n);
        break;
      default:
        ho(t, e, n);
    }
  }
  function vw(t) {
    var e = t.updateQueue;
    if (e !== null) {
      t.updateQueue = null;
      var n = t.stateNode;
      n === null && (n = t.stateNode = new sI()), e.forEach(function(r) {
        var i = gI.bind(null, t, r);
        n.has(r) || (n.add(r), r.then(i, i));
      });
    }
  }
  function Or(t, e) {
    var n = e.deletions;
    if (n !== null)
      for (var r = 0; r < n.length; r++) {
        var i = n[r];
        try {
          var o = t, s = e, a = s;
          e:
            for (; a !== null; ) {
              switch (a.tag) {
                case 5:
                  Yt = a.stateNode, Dr = false;
                  break e;
                case 3:
                  Yt = a.stateNode.containerInfo, Dr = true;
                  break e;
                case 4:
                  Yt = a.stateNode.containerInfo, Dr = true;
                  break e;
              }
              a = a.return;
            }
          if (Yt === null)
            throw Error(Z(160));
          sA(o, s, i), Yt = null, Dr = false;
          var l = i.alternate;
          l !== null && (l.return = null), i.return = null;
        } catch (c) {
          xt(i, e, c);
        }
      }
    if (e.subtreeFlags & 12854)
      for (e = e.child; e !== null; )
        aA(e, t), e = e.sibling;
  }
  function aA(t, e) {
    var n = t.alternate, r = t.flags;
    switch (t.tag) {
      case 0:
      case 11:
      case 14:
      case 15:
        if (Or(e, t), ei(t), r & 4) {
          try {
            Oc(3, t, t.return), Jp(3, t);
          } catch (S) {
            xt(t, t.return, S);
          }
          try {
            Oc(5, t, t.return);
          } catch (S) {
            xt(t, t.return, S);
          }
        }
        break;
      case 1:
        Or(e, t), ei(t), r & 512 && n !== null && ka(n, n.return);
        break;
      case 5:
        if (Or(e, t), ei(t), r & 512 && n !== null && ka(n, n.return), t.flags & 32) {
          var i = t.stateNode;
          try {
            ru(i, "");
          } catch (S) {
            xt(t, t.return, S);
          }
        }
        if (r & 4 && (i = t.stateNode, i != null)) {
          var o = t.memoizedProps, s = n !== null ? n.memoizedProps : o, a = t.type, l = t.updateQueue;
          if (t.updateQueue = null, l !== null)
            try {
              a === "input" && o.type === "radio" && o.name != null && EM(i, o), wv(a, s);
              var c = wv(a, o);
              for (s = 0; s < l.length; s += 2) {
                var u = l[s], h = l[s + 1];
                u === "style" ? _M(i, h) : u === "dangerouslySetInnerHTML" ? LM(i, h) : u === "children" ? ru(i, h) : V1(i, u, h, c);
              }
              switch (a) {
                case "input":
                  vv(i, o);
                  break;
                case "textarea":
                  PM(i, o);
                  break;
                case "select":
                  var p = i._wrapperState.wasMultiple;
                  i._wrapperState.wasMultiple = !!o.multiple;
                  var v = o.value;
                  v != null ? Ba(i, !!o.multiple, v, false) : p !== !!o.multiple && (o.defaultValue != null ? Ba(i, !!o.multiple, o.defaultValue, true) : Ba(i, !!o.multiple, o.multiple ? [] : "", false));
              }
              i[hu] = o;
            } catch (S) {
              xt(t, t.return, S);
            }
        }
        break;
      case 6:
        if (Or(e, t), ei(t), r & 4) {
          if (t.stateNode === null)
            throw Error(Z(162));
          i = t.stateNode, o = t.memoizedProps;
          try {
            i.nodeValue = o;
          } catch (S) {
            xt(t, t.return, S);
          }
        }
        break;
      case 3:
        if (Or(e, t), ei(t), r & 4 && n !== null && n.memoizedState.isDehydrated)
          try {
            au(e.containerInfo);
          } catch (S) {
            xt(t, t.return, S);
          }
        break;
      case 4:
        Or(e, t), ei(t);
        break;
      case 13:
        Or(e, t), ei(t), i = t.child, i.flags & 8192 && (o = i.memoizedState !== null, i.stateNode.isHidden = o, !o || i.alternate !== null && i.alternate.memoizedState !== null || (xb = Mt())), r & 4 && vw(t);
        break;
      case 22:
        if (u = n !== null && n.memoizedState !== null, t.mode & 1 ? (hn = (c = hn) || u, Or(e, t), hn = c) : Or(e, t), ei(t), r & 8192) {
          if (c = t.memoizedState !== null, (t.stateNode.isHidden = c) && !u && (t.mode & 1) !== 0)
            for (ge = t, u = t.child; u !== null; ) {
              for (h = ge = u; ge !== null; ) {
                switch (p = ge, v = p.child, p.tag) {
                  case 0:
                  case 11:
                  case 14:
                  case 15:
                    Oc(4, p, p.return);
                    break;
                  case 1:
                    ka(p, p.return);
                    var y = p.stateNode;
                    if (typeof y.componentWillUnmount == "function") {
                      r = p, n = p.return;
                      try {
                        e = r, y.props = e.memoizedProps, y.state = e.memoizedState, y.componentWillUnmount();
                      } catch (S) {
                        xt(r, n, S);
                      }
                    }
                    break;
                  case 5:
                    ka(p, p.return);
                    break;
                  case 22:
                    if (p.memoizedState !== null) {
                      bw(h);
                      continue;
                    }
                }
                v !== null ? (v.return = p, ge = v) : bw(h);
              }
              u = u.sibling;
            }
          e:
            for (u = null, h = t; ; ) {
              if (h.tag === 5) {
                if (u === null) {
                  u = h;
                  try {
                    i = h.stateNode, c ? (o = i.style, typeof o.setProperty == "function" ? o.setProperty("display", "none", "important") : o.display = "none") : (a = h.stateNode, l = h.memoizedProps.style, s = l != null && l.hasOwnProperty("display") ? l.display : null, a.style.display = RM("display", s));
                  } catch (S) {
                    xt(t, t.return, S);
                  }
                }
              } else if (h.tag === 6) {
                if (u === null)
                  try {
                    h.stateNode.nodeValue = c ? "" : h.memoizedProps;
                  } catch (S) {
                    xt(t, t.return, S);
                  }
              } else if ((h.tag !== 22 && h.tag !== 23 || h.memoizedState === null || h === t) && h.child !== null) {
                h.child.return = h, h = h.child;
                continue;
              }
              if (h === t)
                break e;
              for (; h.sibling === null; ) {
                if (h.return === null || h.return === t)
                  break e;
                u === h && (u = null), h = h.return;
              }
              u === h && (u = null), h.sibling.return = h.return, h = h.sibling;
            }
        }
        break;
      case 19:
        Or(e, t), ei(t), r & 4 && vw(t);
        break;
      case 21:
        break;
      default:
        Or(e, t), ei(t);
    }
  }
  function ei(t) {
    var e = t.flags;
    if (e & 2) {
      try {
        e: {
          for (var n = t.return; n !== null; ) {
            if (oA(n)) {
              var r = n;
              break e;
            }
            n = n.return;
          }
          throw Error(Z(160));
        }
        switch (r.tag) {
          case 5:
            var i = r.stateNode;
            r.flags & 32 && (ru(i, ""), r.flags &= -33);
            var o = gw(t);
            Jv(t, o, i);
            break;
          case 3:
          case 4:
            var s = r.stateNode.containerInfo, a = gw(t);
            Qv(t, a, s);
            break;
          default:
            throw Error(Z(161));
        }
      } catch (l) {
        xt(t, t.return, l);
      }
      t.flags &= -3;
    }
    e & 4096 && (t.flags &= -4097);
  }
  function lI(t, e, n) {
    ge = t, lA(t);
  }
  function lA(t, e, n) {
    for (var r = (t.mode & 1) !== 0; ge !== null; ) {
      var i = ge, o = i.child;
      if (i.tag === 22 && r) {
        var s = i.memoizedState !== null || nh;
        if (!s) {
          var a = i.alternate, l = a !== null && a.memoizedState !== null || hn;
          a = nh;
          var c = hn;
          if (nh = s, (hn = l) && !c)
            for (ge = i; ge !== null; )
              s = ge, l = s.child, s.tag === 22 && s.memoizedState !== null ? xw(i) : l !== null ? (l.return = s, ge = l) : xw(i);
          for (; o !== null; )
            ge = o, lA(o), o = o.sibling;
          ge = i, nh = a, hn = c;
        }
        yw(t);
      } else
        (i.subtreeFlags & 8772) !== 0 && o !== null ? (o.return = i, ge = o) : yw(t);
    }
  }
  function yw(t) {
    for (; ge !== null; ) {
      var e = ge;
      if ((e.flags & 8772) !== 0) {
        var n = e.alternate;
        try {
          if ((e.flags & 8772) !== 0)
            switch (e.tag) {
              case 0:
              case 11:
              case 15:
                hn || Jp(5, e);
                break;
              case 1:
                var r = e.stateNode;
                if (e.flags & 4 && !hn)
                  if (n === null)
                    r.componentDidMount();
                  else {
                    var i = e.elementType === e.type ? n.memoizedProps : _r(e.type, n.memoizedProps);
                    r.componentDidUpdate(i, n.memoizedState, r.__reactInternalSnapshotBeforeUpdate);
                  }
                var o = e.updateQueue;
                o !== null && tw(e, o, r);
                break;
              case 3:
                var s = e.updateQueue;
                if (s !== null) {
                  if (n = null, e.child !== null)
                    switch (e.child.tag) {
                      case 5:
                        n = e.child.stateNode;
                        break;
                      case 1:
                        n = e.child.stateNode;
                    }
                  tw(e, s, n);
                }
                break;
              case 5:
                var a = e.stateNode;
                if (n === null && e.flags & 4) {
                  n = a;
                  var l = e.memoizedProps;
                  switch (e.type) {
                    case "button":
                    case "input":
                    case "select":
                    case "textarea":
                      l.autoFocus && n.focus();
                      break;
                    case "img":
                      l.src && (n.src = l.src);
                  }
                }
                break;
              case 6:
                break;
              case 4:
                break;
              case 12:
                break;
              case 13:
                if (e.memoizedState === null) {
                  var c = e.alternate;
                  if (c !== null) {
                    var u = c.memoizedState;
                    if (u !== null) {
                      var h = u.dehydrated;
                      h !== null && au(h);
                    }
                  }
                }
                break;
              case 19:
              case 17:
              case 21:
              case 22:
              case 23:
              case 25:
                break;
              default:
                throw Error(Z(163));
            }
          hn || e.flags & 512 && Xv(e);
        } catch (p) {
          xt(e, e.return, p);
        }
      }
      if (e === t) {
        ge = null;
        break;
      }
      if (n = e.sibling, n !== null) {
        n.return = e.return, ge = n;
        break;
      }
      ge = e.return;
    }
  }
  function bw(t) {
    for (; ge !== null; ) {
      var e = ge;
      if (e === t) {
        ge = null;
        break;
      }
      var n = e.sibling;
      if (n !== null) {
        n.return = e.return, ge = n;
        break;
      }
      ge = e.return;
    }
  }
  function xw(t) {
    for (; ge !== null; ) {
      var e = ge;
      try {
        switch (e.tag) {
          case 0:
          case 11:
          case 15:
            var n = e.return;
            try {
              Jp(4, e);
            } catch (l) {
              xt(e, n, l);
            }
            break;
          case 1:
            var r = e.stateNode;
            if (typeof r.componentDidMount == "function") {
              var i = e.return;
              try {
                r.componentDidMount();
              } catch (l) {
                xt(e, i, l);
              }
            }
            var o = e.return;
            try {
              Xv(e);
            } catch (l) {
              xt(e, o, l);
            }
            break;
          case 5:
            var s = e.return;
            try {
              Xv(e);
            } catch (l) {
              xt(e, s, l);
            }
        }
      } catch (l) {
        xt(e, e.return, l);
      }
      if (e === t) {
        ge = null;
        break;
      }
      var a = e.sibling;
      if (a !== null) {
        a.return = e.return, ge = a;
        break;
      }
      ge = e.return;
    }
  }
  var cI = Math.ceil, Gd = oo.ReactCurrentDispatcher, yb = oo.ReactCurrentOwner, br = oo.ReactCurrentBatchConfig, We = 0, jt = null, Ot = null, tn = 0, Hn = 0, Ca = es(0), It = 0, yu = null, Ws = 0, Zp = 0, bb = 0, Lc = null, Pn = null, xb = 0, al = 1 / 0, Ni = null, Yd = false, Zv = null, zo = null, rh = false, Po = null, Xd = 0, Rc = 0, ey = null, Zh = -1, ed = 0;
  function Sn() {
    return (We & 6) !== 0 ? Mt() : Zh !== -1 ? Zh : Zh = Mt();
  }
  function Fo(t) {
    return (t.mode & 1) === 0 ? 1 : (We & 2) !== 0 && tn !== 0 ? tn & -tn : KD.transition !== null ? (ed === 0 && (ed = UM()), ed) : (t = Ye, t !== 0 || (t = window.event, t = t === void 0 ? 16 : JM(t.type)), t);
  }
  function Wr(t, e, n, r) {
    if (50 < Rc)
      throw Rc = 0, ey = null, Error(Z(185));
    Gu(t, n, r), ((We & 2) === 0 || t !== jt) && (t === jt && ((We & 2) === 0 && (Zp |= n), It === 4 && Co(t, tn)), zn(t, r), n === 1 && We === 0 && (e.mode & 1) === 0 && (al = Mt() + 500, Yp && ts()));
  }
  function zn(t, e) {
    var n = t.callbackNode;
    K_(t, e);
    var r = _d(t, t === jt ? tn : 0);
    if (r === 0)
      n !== null && PS(n), t.callbackNode = null, t.callbackPriority = 0;
    else if (e = r & -r, t.callbackPriority !== e) {
      if (n != null && PS(n), e === 1)
        t.tag === 0 ? UD(Sw.bind(null, t)) : v2(Sw.bind(null, t)), VD(function() {
          (We & 6) === 0 && ts();
        }), n = null;
      else {
        switch (KM(r)) {
          case 1:
            n = K1;
            break;
          case 4:
            n = HM;
            break;
          case 16:
            n = Rd;
            break;
          case 536870912:
            n = jM;
            break;
          default:
            n = Rd;
        }
        n = gA(n, cA.bind(null, t));
      }
      t.callbackPriority = e, t.callbackNode = n;
    }
  }
  function cA(t, e) {
    if (Zh = -1, ed = 0, (We & 6) !== 0)
      throw Error(Z(327));
    var n = t.callbackNode;
    if (Va() && t.callbackNode !== n)
      return null;
    var r = _d(t, t === jt ? tn : 0);
    if (r === 0)
      return null;
    if ((r & 30) !== 0 || (r & t.expiredLanes) !== 0 || e)
      e = Qd(t, r);
    else {
      e = r;
      var i = We;
      We |= 2;
      var o = fA();
      (jt !== t || tn !== e) && (Ni = null, al = Mt() + 500, Rs(t, e));
      do
        try {
          hI();
          break;
        } catch (a) {
          uA(t, a);
        }
      while (1);
      ob(), Gd.current = o, We = i, Ot !== null ? e = 0 : (jt = null, tn = 0, e = It);
    }
    if (e !== 0) {
      if (e === 2 && (i = Av(t), i !== 0 && (r = i, e = ty(t, i))), e === 1)
        throw n = yu, Rs(t, 0), Co(t, r), zn(t, Mt()), n;
      if (e === 6)
        Co(t, r);
      else {
        if (i = t.current.alternate, (r & 30) === 0 && !uI(i) && (e = Qd(t, r), e === 2 && (o = Av(t), o !== 0 && (r = o, e = ty(t, o))), e === 1))
          throw n = yu, Rs(t, 0), Co(t, r), zn(t, Mt()), n;
        switch (t.finishedWork = i, t.finishedLanes = r, e) {
          case 0:
          case 1:
            throw Error(Z(345));
          case 2:
            ys(t, Pn, Ni);
            break;
          case 3:
            if (Co(t, r), (r & 130023424) === r && (e = xb + 500 - Mt(), 10 < e)) {
              if (_d(t, 0) !== 0)
                break;
              if (i = t.suspendedLanes, (i & r) !== r) {
                Sn(), t.pingedLanes |= t.suspendedLanes & i;
                break;
              }
              t.timeoutHandle = Iv(ys.bind(null, t, Pn, Ni), e);
              break;
            }
            ys(t, Pn, Ni);
            break;
          case 4:
            if (Co(t, r), (r & 4194240) === r)
              break;
            for (e = t.eventTimes, i = -1; 0 < r; ) {
              var s = 31 - Vr(r);
              o = 1 << s, s = e[s], s > i && (i = s), r &= ~o;
            }
            if (r = i, r = Mt() - r, r = (120 > r ? 120 : 480 > r ? 480 : 1080 > r ? 1080 : 1920 > r ? 1920 : 3e3 > r ? 3e3 : 4320 > r ? 4320 : 1960 * cI(r / 1960)) - r, 10 < r) {
              t.timeoutHandle = Iv(ys.bind(null, t, Pn, Ni), r);
              break;
            }
            ys(t, Pn, Ni);
            break;
          case 5:
            ys(t, Pn, Ni);
            break;
          default:
            throw Error(Z(329));
        }
      }
    }
    return zn(t, Mt()), t.callbackNode === n ? cA.bind(null, t) : null;
  }
  function ty(t, e) {
    var n = Lc;
    return t.current.memoizedState.isDehydrated && (Rs(t, e).flags |= 256), t = Qd(t, e), t !== 2 && (e = Pn, Pn = n, e !== null && ny(e)), t;
  }
  function ny(t) {
    Pn === null ? Pn = t : Pn.push.apply(Pn, t);
  }
  function uI(t) {
    for (var e = t; ; ) {
      if (e.flags & 16384) {
        var n = e.updateQueue;
        if (n !== null && (n = n.stores, n !== null))
          for (var r = 0; r < n.length; r++) {
            var i = n[r], o = i.getSnapshot;
            i = i.value;
            try {
              if (!Kr(o(), i))
                return false;
            } catch {
              return false;
            }
          }
      }
      if (n = e.child, e.subtreeFlags & 16384 && n !== null)
        n.return = e, e = n;
      else {
        if (e === t)
          break;
        for (; e.sibling === null; ) {
          if (e.return === null || e.return === t)
            return true;
          e = e.return;
        }
        e.sibling.return = e.return, e = e.sibling;
      }
    }
    return true;
  }
  function Co(t, e) {
    for (e &= ~bb, e &= ~Zp, t.suspendedLanes |= e, t.pingedLanes &= ~e, t = t.expirationTimes; 0 < e; ) {
      var n = 31 - Vr(e), r = 1 << n;
      t[n] = -1, e &= ~r;
    }
  }
  function Sw(t) {
    if ((We & 6) !== 0)
      throw Error(Z(327));
    Va();
    var e = _d(t, 0);
    if ((e & 1) === 0)
      return zn(t, Mt()), null;
    var n = Qd(t, e);
    if (t.tag !== 0 && n === 2) {
      var r = Av(t);
      r !== 0 && (e = r, n = ty(t, r));
    }
    if (n === 1)
      throw n = yu, Rs(t, 0), Co(t, e), zn(t, Mt()), n;
    if (n === 6)
      throw Error(Z(345));
    return t.finishedWork = t.current.alternate, t.finishedLanes = e, ys(t, Pn, Ni), zn(t, Mt()), null;
  }
  function Sb(t, e) {
    var n = We;
    We |= 1;
    try {
      return t(e);
    } finally {
      We = n, We === 0 && (al = Mt() + 500, Yp && ts());
    }
  }
  function Hs(t) {
    Po !== null && Po.tag === 0 && (We & 6) === 0 && Va();
    var e = We;
    We |= 1;
    var n = br.transition, r = Ye;
    try {
      if (br.transition = null, Ye = 1, t)
        return t();
    } finally {
      Ye = r, br.transition = n, We = e, (We & 6) === 0 && ts();
    }
  }
  function wb() {
    Hn = Ca.current, at(Ca);
  }
  function Rs(t, e) {
    t.finishedWork = null, t.finishedLanes = 0;
    var n = t.timeoutHandle;
    if (n !== -1 && (t.timeoutHandle = -1, FD(n)), Ot !== null)
      for (n = Ot.return; n !== null; ) {
        var r = n;
        switch (nb(r), r.tag) {
          case 1:
            r = r.type.childContextTypes, r != null && $d();
            break;
          case 3:
            ol(), at(Nn), at(dn), fb();
            break;
          case 5:
            ub(r);
            break;
          case 4:
            ol();
            break;
          case 13:
            at(pt);
            break;
          case 19:
            at(pt);
            break;
          case 10:
            sb(r.type._context);
            break;
          case 22:
          case 23:
            wb();
        }
        n = n.return;
      }
    if (jt = t, Ot = t = Vo(t.current, null), tn = Hn = e, It = 0, yu = null, bb = Zp = Ws = 0, Pn = Lc = null, Ts !== null) {
      for (e = 0; e < Ts.length; e++)
        if (n = Ts[e], r = n.interleaved, r !== null) {
          n.interleaved = null;
          var i = r.next, o = n.pending;
          if (o !== null) {
            var s = o.next;
            o.next = i, r.next = s;
          }
          n.pending = r;
        }
      Ts = null;
    }
    return t;
  }
  function uA(t, e) {
    do {
      var n = Ot;
      try {
        if (ob(), Xh.current = qd, Kd) {
          for (var r = mt.memoizedState; r !== null; ) {
            var i = r.queue;
            i !== null && (i.pending = null), r = r.next;
          }
          Kd = false;
        }
        if (Vs = 0, Vt = _t = mt = null, Pc = false, mu = 0, yb.current = null, n === null || n.return === null) {
          It = 1, yu = e, Ot = null;
          break;
        }
        e: {
          var o = t, s = n.return, a = n, l = e;
          if (e = tn, a.flags |= 32768, l !== null && typeof l == "object" && typeof l.then == "function") {
            var c = l, u = a, h = u.tag;
            if ((u.mode & 1) === 0 && (h === 0 || h === 11 || h === 15)) {
              var p = u.alternate;
              p ? (u.updateQueue = p.updateQueue, u.memoizedState = p.memoizedState, u.lanes = p.lanes) : (u.updateQueue = null, u.memoizedState = null);
            }
            var v = lw(s);
            if (v !== null) {
              v.flags &= -257, cw(v, s, a, o, e), v.mode & 1 && aw(o, c, e), e = v, l = c;
              var y = e.updateQueue;
              if (y === null) {
                var S = /* @__PURE__ */ new Set();
                S.add(l), e.updateQueue = S;
              } else
                y.add(l);
              break e;
            } else {
              if ((e & 1) === 0) {
                aw(o, c, e), kb();
                break e;
              }
              l = Error(Z(426));
            }
          } else if (ut && a.mode & 1) {
            var T = lw(s);
            if (T !== null) {
              (T.flags & 65536) === 0 && (T.flags |= 256), cw(T, s, a, o, e), rb(sl(l, a));
              break e;
            }
          }
          o = l = sl(l, a), It !== 4 && (It = 2), Lc === null ? Lc = [
            o
          ] : Lc.push(o), o = s;
          do {
            switch (o.tag) {
              case 3:
                o.flags |= 65536, e &= -e, o.lanes |= e;
                var w = q2(o, l, e);
                ew(o, w);
                break e;
              case 1:
                a = l;
                var k = o.type, C = o.stateNode;
                if ((o.flags & 128) === 0 && (typeof k.getDerivedStateFromError == "function" || C !== null && typeof C.componentDidCatch == "function" && (zo === null || !zo.has(C)))) {
                  o.flags |= 65536, e &= -e, o.lanes |= e;
                  var O = G2(o, a, e);
                  ew(o, O);
                  break e;
                }
            }
            o = o.return;
          } while (o !== null);
        }
        dA(n);
      } catch (L) {
        e = L, Ot === n && n !== null && (Ot = n = n.return);
        continue;
      }
      break;
    } while (1);
  }
  function fA() {
    var t = Gd.current;
    return Gd.current = qd, t === null ? qd : t;
  }
  function kb() {
    (It === 0 || It === 3 || It === 2) && (It = 4), jt === null || (Ws & 268435455) === 0 && (Zp & 268435455) === 0 || Co(jt, tn);
  }
  function Qd(t, e) {
    var n = We;
    We |= 2;
    var r = fA();
    (jt !== t || tn !== e) && (Ni = null, Rs(t, e));
    do
      try {
        fI();
        break;
      } catch (i) {
        uA(t, i);
      }
    while (1);
    if (ob(), We = n, Gd.current = r, Ot !== null)
      throw Error(Z(261));
    return jt = null, tn = 0, It;
  }
  function fI() {
    for (; Ot !== null; )
      hA(Ot);
  }
  function hI() {
    for (; Ot !== null && !N_(); )
      hA(Ot);
  }
  function hA(t) {
    var e = mA(t.alternate, t, Hn);
    t.memoizedProps = t.pendingProps, e === null ? dA(t) : Ot = e, yb.current = null;
  }
  function dA(t) {
    var e = t;
    do {
      var n = e.alternate;
      if (t = e.return, (e.flags & 32768) === 0) {
        if (n = iI(n, e, Hn), n !== null) {
          Ot = n;
          return;
        }
      } else {
        if (n = oI(n, e), n !== null) {
          n.flags &= 32767, Ot = n;
          return;
        }
        if (t !== null)
          t.flags |= 32768, t.subtreeFlags = 0, t.deletions = null;
        else {
          It = 6, Ot = null;
          return;
        }
      }
      if (e = e.sibling, e !== null) {
        Ot = e;
        return;
      }
      Ot = e = t;
    } while (e !== null);
    It === 0 && (It = 5);
  }
  function ys(t, e, n) {
    var r = Ye, i = br.transition;
    try {
      br.transition = null, Ye = 1, dI(t, e, n, r);
    } finally {
      br.transition = i, Ye = r;
    }
    return null;
  }
  function dI(t, e, n, r) {
    do
      Va();
    while (Po !== null);
    if ((We & 6) !== 0)
      throw Error(Z(327));
    n = t.finishedWork;
    var i = t.finishedLanes;
    if (n === null)
      return null;
    if (t.finishedWork = null, t.finishedLanes = 0, n === t.current)
      throw Error(Z(177));
    t.callbackNode = null, t.callbackPriority = 0;
    var o = n.lanes | n.childLanes;
    if (q_(t, o), t === jt && (Ot = jt = null, tn = 0), (n.subtreeFlags & 2064) === 0 && (n.flags & 2064) === 0 || rh || (rh = true, gA(Rd, function() {
      return Va(), null;
    })), o = (n.flags & 15990) !== 0, (n.subtreeFlags & 15990) !== 0 || o) {
      o = br.transition, br.transition = null;
      var s = Ye;
      Ye = 1;
      var a = We;
      We |= 4, yb.current = null, aI(t, n), aA(n, t), _D(_v), Dd = !!Rv, _v = Rv = null, t.current = n, lI(n), $_(), We = a, Ye = s, br.transition = o;
    } else
      t.current = n;
    if (rh && (rh = false, Po = t, Xd = i), o = t.pendingLanes, o === 0 && (zo = null), V_(n.stateNode), zn(t, Mt()), e !== null)
      for (r = t.onRecoverableError, n = 0; n < e.length; n++)
        i = e[n], r(i.value, {
          componentStack: i.stack,
          digest: i.digest
        });
    if (Yd)
      throw Yd = false, t = Zv, Zv = null, t;
    return (Xd & 1) !== 0 && t.tag !== 0 && Va(), o = t.pendingLanes, (o & 1) !== 0 ? t === ey ? Rc++ : (Rc = 0, ey = t) : Rc = 0, ts(), null;
  }
  function Va() {
    if (Po !== null) {
      var t = KM(Xd), e = br.transition, n = Ye;
      try {
        if (br.transition = null, Ye = 16 > t ? 16 : t, Po === null)
          var r = false;
        else {
          if (t = Po, Po = null, Xd = 0, (We & 6) !== 0)
            throw Error(Z(331));
          var i = We;
          for (We |= 4, ge = t.current; ge !== null; ) {
            var o = ge, s = o.child;
            if ((ge.flags & 16) !== 0) {
              var a = o.deletions;
              if (a !== null) {
                for (var l = 0; l < a.length; l++) {
                  var c = a[l];
                  for (ge = c; ge !== null; ) {
                    var u = ge;
                    switch (u.tag) {
                      case 0:
                      case 11:
                      case 15:
                        Oc(8, u, o);
                    }
                    var h = u.child;
                    if (h !== null)
                      h.return = u, ge = h;
                    else
                      for (; ge !== null; ) {
                        u = ge;
                        var p = u.sibling, v = u.return;
                        if (iA(u), u === c) {
                          ge = null;
                          break;
                        }
                        if (p !== null) {
                          p.return = v, ge = p;
                          break;
                        }
                        ge = v;
                      }
                  }
                }
                var y = o.alternate;
                if (y !== null) {
                  var S = y.child;
                  if (S !== null) {
                    y.child = null;
                    do {
                      var T = S.sibling;
                      S.sibling = null, S = T;
                    } while (S !== null);
                  }
                }
                ge = o;
              }
            }
            if ((o.subtreeFlags & 2064) !== 0 && s !== null)
              s.return = o, ge = s;
            else
              e:
                for (; ge !== null; ) {
                  if (o = ge, (o.flags & 2048) !== 0)
                    switch (o.tag) {
                      case 0:
                      case 11:
                      case 15:
                        Oc(9, o, o.return);
                    }
                  var w = o.sibling;
                  if (w !== null) {
                    w.return = o.return, ge = w;
                    break e;
                  }
                  ge = o.return;
                }
          }
          var k = t.current;
          for (ge = k; ge !== null; ) {
            s = ge;
            var C = s.child;
            if ((s.subtreeFlags & 2064) !== 0 && C !== null)
              C.return = s, ge = C;
            else
              e:
                for (s = k; ge !== null; ) {
                  if (a = ge, (a.flags & 2048) !== 0)
                    try {
                      switch (a.tag) {
                        case 0:
                        case 11:
                        case 15:
                          Jp(9, a);
                      }
                    } catch (L) {
                      xt(a, a.return, L);
                    }
                  if (a === s) {
                    ge = null;
                    break e;
                  }
                  var O = a.sibling;
                  if (O !== null) {
                    O.return = a.return, ge = O;
                    break e;
                  }
                  ge = a.return;
                }
          }
          if (We = i, ts(), Si && typeof Si.onPostCommitFiberRoot == "function")
            try {
              Si.onPostCommitFiberRoot(jp, t);
            } catch {
            }
          r = true;
        }
        return r;
      } finally {
        Ye = n, br.transition = e;
      }
    }
    return false;
  }
  function ww(t, e, n) {
    e = sl(n, e), e = q2(t, e, 1), t = $o(t, e, 1), e = Sn(), t !== null && (Gu(t, 1, e), zn(t, e));
  }
  function xt(t, e, n) {
    if (t.tag === 3)
      ww(t, t, n);
    else
      for (; e !== null; ) {
        if (e.tag === 3) {
          ww(e, t, n);
          break;
        } else if (e.tag === 1) {
          var r = e.stateNode;
          if (typeof e.type.getDerivedStateFromError == "function" || typeof r.componentDidCatch == "function" && (zo === null || !zo.has(r))) {
            t = sl(n, t), t = G2(e, t, 1), e = $o(e, t, 1), t = Sn(), e !== null && (Gu(e, 1, t), zn(e, t));
            break;
          }
        }
        e = e.return;
      }
  }
  function pI(t, e, n) {
    var r = t.pingCache;
    r !== null && r.delete(e), e = Sn(), t.pingedLanes |= t.suspendedLanes & n, jt === t && (tn & n) === n && (It === 4 || It === 3 && (tn & 130023424) === tn && 500 > Mt() - xb ? Rs(t, 0) : bb |= n), zn(t, e);
  }
  function pA(t, e) {
    e === 0 && ((t.mode & 1) === 0 ? e = 1 : (e = qf, qf <<= 1, (qf & 130023424) === 0 && (qf = 4194304)));
    var n = Sn();
    t = Qi(t, e), t !== null && (Gu(t, e, n), zn(t, n));
  }
  function mI(t) {
    var e = t.memoizedState, n = 0;
    e !== null && (n = e.retryLane), pA(t, n);
  }
  function gI(t, e) {
    var n = 0;
    switch (t.tag) {
      case 13:
        var r = t.stateNode, i = t.memoizedState;
        i !== null && (n = i.retryLane);
        break;
      case 19:
        r = t.stateNode;
        break;
      default:
        throw Error(Z(314));
    }
    r !== null && r.delete(e), pA(t, n);
  }
  var mA;
  mA = function(t, e, n) {
    if (t !== null)
      if (t.memoizedProps !== e.pendingProps || Nn.current)
        Dn = true;
      else {
        if ((t.lanes & n) === 0 && (e.flags & 128) === 0)
          return Dn = false, rI(t, e, n);
        Dn = (t.flags & 131072) !== 0;
      }
    else
      Dn = false, ut && (e.flags & 1048576) !== 0 && y2(e, Vd, e.index);
    switch (e.lanes = 0, e.tag) {
      case 2:
        var r = e.type;
        Jh(t, e), t = e.pendingProps;
        var i = nl(e, dn.current);
        Fa(e, n), i = db(null, e, r, t, i, n);
        var o = pb();
        return e.flags |= 1, typeof i == "object" && i !== null && typeof i.render == "function" && i.$$typeof === void 0 ? (e.tag = 1, e.memoizedState = null, e.updateQueue = null, $n(r) ? (o = true, zd(e)) : o = false, e.memoizedState = i.state !== null && i.state !== void 0 ? i.state : null, lb(e), i.updater = Xp, e.stateNode = i, i._reactInternals = e, Wv(e, r, t, n), e = Uv(null, e, r, true, o, n)) : (e.tag = 0, ut && o && tb(e), yn(null, e, i, n), e = e.child), e;
      case 16:
        r = e.elementType;
        e: {
          switch (Jh(t, e), t = e.pendingProps, i = r._init, r = i(r._payload), e.type = r, i = e.tag = yI(r), t = _r(r, t), i) {
            case 0:
              e = jv(null, e, r, t, n);
              break e;
            case 1:
              e = hw(null, e, r, t, n);
              break e;
            case 11:
              e = uw(null, e, r, t, n);
              break e;
            case 14:
              e = fw(null, e, r, _r(r.type, t), n);
              break e;
          }
          throw Error(Z(306, r, ""));
        }
        return e;
      case 0:
        return r = e.type, i = e.pendingProps, i = e.elementType === r ? i : _r(r, i), jv(t, e, r, i, n);
      case 1:
        return r = e.type, i = e.pendingProps, i = e.elementType === r ? i : _r(r, i), hw(t, e, r, i, n);
      case 3:
        e: {
          if (J2(e), t === null)
            throw Error(Z(387));
          r = e.pendingProps, o = e.memoizedState, i = o.element, w2(t, e), jd(e, r, null, n);
          var s = e.memoizedState;
          if (r = s.element, o.isDehydrated)
            if (o = {
              element: r,
              isDehydrated: false,
              cache: s.cache,
              pendingSuspenseBoundaries: s.pendingSuspenseBoundaries,
              transitions: s.transitions
            }, e.updateQueue.baseState = o, e.memoizedState = o, e.flags & 256) {
              i = sl(Error(Z(423)), e), e = dw(t, e, r, n, i);
              break e;
            } else if (r !== i) {
              i = sl(Error(Z(424)), e), e = dw(t, e, r, n, i);
              break e;
            } else
              for (Un = No(e.stateNode.containerInfo.firstChild), qn = e, ut = true, Br = null, n = M2(e, null, r, n), e.child = n; n; )
                n.flags = n.flags & -3 | 4096, n = n.sibling;
          else {
            if (rl(), r === i) {
              e = Ji(t, e, n);
              break e;
            }
            yn(t, e, r, n);
          }
          e = e.child;
        }
        return e;
      case 5:
        return A2(e), t === null && zv(e), r = e.type, i = e.pendingProps, o = t !== null ? t.memoizedProps : null, s = i.children, Dv(r, i) ? s = null : o !== null && Dv(r, o) && (e.flags |= 32), Q2(t, e), yn(t, e, s, n), e.child;
      case 6:
        return t === null && zv(e), null;
      case 13:
        return Z2(t, e, n);
      case 4:
        return cb(e, e.stateNode.containerInfo), r = e.pendingProps, t === null ? e.child = il(e, null, r, n) : yn(t, e, r, n), e.child;
      case 11:
        return r = e.type, i = e.pendingProps, i = e.elementType === r ? i : _r(r, i), uw(t, e, r, i, n);
      case 7:
        return yn(t, e, e.pendingProps, n), e.child;
      case 8:
        return yn(t, e, e.pendingProps.children, n), e.child;
      case 12:
        return yn(t, e, e.pendingProps.children, n), e.child;
      case 10:
        e: {
          if (r = e.type._context, i = e.pendingProps, o = e.memoizedProps, s = i.value, rt(Wd, r._currentValue), r._currentValue = s, o !== null)
            if (Kr(o.value, s)) {
              if (o.children === i.children && !Nn.current) {
                e = Ji(t, e, n);
                break e;
              }
            } else
              for (o = e.child, o !== null && (o.return = e); o !== null; ) {
                var a = o.dependencies;
                if (a !== null) {
                  s = o.child;
                  for (var l = a.firstContext; l !== null; ) {
                    if (l.context === r) {
                      if (o.tag === 1) {
                        l = Ki(-1, n & -n), l.tag = 2;
                        var c = o.updateQueue;
                        if (c !== null) {
                          c = c.shared;
                          var u = c.pending;
                          u === null ? l.next = l : (l.next = u.next, u.next = l), c.pending = l;
                        }
                      }
                      o.lanes |= n, l = o.alternate, l !== null && (l.lanes |= n), Fv(o.return, n, e), a.lanes |= n;
                      break;
                    }
                    l = l.next;
                  }
                } else if (o.tag === 10)
                  s = o.type === e.type ? null : o.child;
                else if (o.tag === 18) {
                  if (s = o.return, s === null)
                    throw Error(Z(341));
                  s.lanes |= n, a = s.alternate, a !== null && (a.lanes |= n), Fv(s, n, e), s = o.sibling;
                } else
                  s = o.child;
                if (s !== null)
                  s.return = o;
                else
                  for (s = o; s !== null; ) {
                    if (s === e) {
                      s = null;
                      break;
                    }
                    if (o = s.sibling, o !== null) {
                      o.return = s.return, s = o;
                      break;
                    }
                    s = s.return;
                  }
                o = s;
              }
          yn(t, e, i.children, n), e = e.child;
        }
        return e;
      case 9:
        return i = e.type, r = e.pendingProps.children, Fa(e, n), i = Sr(i), r = r(i), e.flags |= 1, yn(t, e, r, n), e.child;
      case 14:
        return r = e.type, i = _r(r, e.pendingProps), i = _r(r.type, i), fw(t, e, r, i, n);
      case 15:
        return Y2(t, e, e.type, e.pendingProps, n);
      case 17:
        return r = e.type, i = e.pendingProps, i = e.elementType === r ? i : _r(r, i), Jh(t, e), e.tag = 1, $n(r) ? (t = true, zd(e)) : t = false, Fa(e, n), C2(e, r, i), Wv(e, r, i, n), Uv(null, e, r, true, t, n);
      case 19:
        return eA(t, e, n);
      case 22:
        return X2(t, e, n);
    }
    throw Error(Z(156, e.tag));
  };
  function gA(t, e) {
    return WM(t, e);
  }
  function vI(t, e, n, r) {
    this.tag = t, this.key = n, this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null, this.index = 0, this.ref = null, this.pendingProps = e, this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null, this.mode = r, this.subtreeFlags = this.flags = 0, this.deletions = null, this.childLanes = this.lanes = 0, this.alternate = null;
  }
  function dr(t, e, n, r) {
    return new vI(t, e, n, r);
  }
  function Cb(t) {
    return t = t.prototype, !(!t || !t.isReactComponent);
  }
  function yI(t) {
    if (typeof t == "function")
      return Cb(t) ? 1 : 0;
    if (t != null) {
      if (t = t.$$typeof, t === H1)
        return 11;
      if (t === j1)
        return 14;
    }
    return 2;
  }
  function Vo(t, e) {
    var n = t.alternate;
    return n === null ? (n = dr(t.tag, e, t.key, t.mode), n.elementType = t.elementType, n.type = t.type, n.stateNode = t.stateNode, n.alternate = t, t.alternate = n) : (n.pendingProps = e, n.type = t.type, n.flags = 0, n.subtreeFlags = 0, n.deletions = null), n.flags = t.flags & 14680064, n.childLanes = t.childLanes, n.lanes = t.lanes, n.child = t.child, n.memoizedProps = t.memoizedProps, n.memoizedState = t.memoizedState, n.updateQueue = t.updateQueue, e = t.dependencies, n.dependencies = e === null ? null : {
      lanes: e.lanes,
      firstContext: e.firstContext
    }, n.sibling = t.sibling, n.index = t.index, n.ref = t.ref, n;
  }
  function td(t, e, n, r, i, o) {
    var s = 2;
    if (r = t, typeof t == "function")
      Cb(t) && (s = 1);
    else if (typeof t == "string")
      s = 5;
    else
      e:
        switch (t) {
          case pa:
            return _s(n.children, i, o, e);
          case W1:
            s = 8, i |= 8;
            break;
          case hv:
            return t = dr(12, n, e, i | 2), t.elementType = hv, t.lanes = o, t;
          case dv:
            return t = dr(13, n, e, i), t.elementType = dv, t.lanes = o, t;
          case pv:
            return t = dr(19, n, e, i), t.elementType = pv, t.lanes = o, t;
          case TM:
            return em(n, i, o, e);
          default:
            if (typeof t == "object" && t !== null)
              switch (t.$$typeof) {
                case kM:
                  s = 10;
                  break e;
                case CM:
                  s = 9;
                  break e;
                case H1:
                  s = 11;
                  break e;
                case j1:
                  s = 14;
                  break e;
                case yo:
                  s = 16, r = null;
                  break e;
              }
            throw Error(Z(130, t == null ? t : typeof t, ""));
        }
    return e = dr(s, n, e, i), e.elementType = t, e.type = r, e.lanes = o, e;
  }
  function _s(t, e, n, r) {
    return t = dr(7, t, r, e), t.lanes = n, t;
  }
  function em(t, e, n, r) {
    return t = dr(22, t, r, e), t.elementType = TM, t.lanes = n, t.stateNode = {
      isHidden: false
    }, t;
  }
  function Qg(t, e, n) {
    return t = dr(6, t, null, e), t.lanes = n, t;
  }
  function Jg(t, e, n) {
    return e = dr(4, t.children !== null ? t.children : [], t.key, e), e.lanes = n, e.stateNode = {
      containerInfo: t.containerInfo,
      pendingChildren: null,
      implementation: t.implementation
    }, e;
  }
  function bI(t, e, n, r, i) {
    this.tag = e, this.containerInfo = t, this.finishedWork = this.pingCache = this.current = this.pendingChildren = null, this.timeoutHandle = -1, this.callbackNode = this.pendingContext = this.context = null, this.callbackPriority = 0, this.eventTimes = Rg(0), this.expirationTimes = Rg(-1), this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0, this.entanglements = Rg(0), this.identifierPrefix = r, this.onRecoverableError = i, this.mutableSourceEagerHydrationData = null;
  }
  function Tb(t, e, n, r, i, o, s, a, l) {
    return t = new bI(t, e, n, a, l), e === 1 ? (e = 1, o === true && (e |= 8)) : e = 0, o = dr(3, null, null, e), t.current = o, o.stateNode = t, o.memoizedState = {
      element: r,
      isDehydrated: n,
      cache: null,
      transitions: null,
      pendingSuspenseBoundaries: null
    }, lb(o), t;
  }
  function xI(t, e, n) {
    var r = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null;
    return {
      $$typeof: da,
      key: r == null ? null : "" + r,
      children: t,
      containerInfo: e,
      implementation: n
    };
  }
  function vA(t) {
    if (!t)
      return jo;
    t = t._reactInternals;
    e: {
      if (Qs(t) !== t || t.tag !== 1)
        throw Error(Z(170));
      var e = t;
      do {
        switch (e.tag) {
          case 3:
            e = e.stateNode.context;
            break e;
          case 1:
            if ($n(e.type)) {
              e = e.stateNode.__reactInternalMemoizedMergedChildContext;
              break e;
            }
        }
        e = e.return;
      } while (e !== null);
      throw Error(Z(171));
    }
    if (t.tag === 1) {
      var n = t.type;
      if ($n(n))
        return g2(t, n, e);
    }
    return e;
  }
  function yA(t, e, n, r, i, o, s, a, l) {
    return t = Tb(n, r, true, t, i, o, s, a, l), t.context = vA(null), n = t.current, r = Sn(), i = Fo(n), o = Ki(r, i), o.callback = e ?? null, $o(n, o, i), t.current.lanes = i, Gu(t, i, r), zn(t, r), t;
  }
  function tm(t, e, n, r) {
    var i = e.current, o = Sn(), s = Fo(i);
    return n = vA(n), e.context === null ? e.context = n : e.pendingContext = n, e = Ki(o, s), e.payload = {
      element: t
    }, r = r === void 0 ? null : r, r !== null && (e.callback = r), t = $o(i, e, s), t !== null && (Wr(t, i, s, o), Yh(t, i, s)), s;
  }
  function Jd(t) {
    if (t = t.current, !t.child)
      return null;
    switch (t.child.tag) {
      case 5:
        return t.child.stateNode;
      default:
        return t.child.stateNode;
    }
  }
  function kw(t, e) {
    if (t = t.memoizedState, t !== null && t.dehydrated !== null) {
      var n = t.retryLane;
      t.retryLane = n !== 0 && n < e ? n : e;
    }
  }
  function Mb(t, e) {
    kw(t, e), (t = t.alternate) && kw(t, e);
  }
  function SI() {
    return null;
  }
  var bA = typeof reportError == "function" ? reportError : function(t) {
    console.error(t);
  };
  function Ab(t) {
    this._internalRoot = t;
  }
  nm.prototype.render = Ab.prototype.render = function(t) {
    var e = this._internalRoot;
    if (e === null)
      throw Error(Z(409));
    tm(t, e, null, null);
  };
  nm.prototype.unmount = Ab.prototype.unmount = function() {
    var t = this._internalRoot;
    if (t !== null) {
      this._internalRoot = null;
      var e = t.containerInfo;
      Hs(function() {
        tm(null, t, null, null);
      }), e[Xi] = null;
    }
  };
  function nm(t) {
    this._internalRoot = t;
  }
  nm.prototype.unstable_scheduleHydration = function(t) {
    if (t) {
      var e = YM();
      t = {
        blockedOn: null,
        target: t,
        priority: e
      };
      for (var n = 0; n < ko.length && e !== 0 && e < ko[n].priority; n++)
        ;
      ko.splice(n, 0, t), n === 0 && QM(t);
    }
  };
  function Eb(t) {
    return !(!t || t.nodeType !== 1 && t.nodeType !== 9 && t.nodeType !== 11);
  }
  function rm(t) {
    return !(!t || t.nodeType !== 1 && t.nodeType !== 9 && t.nodeType !== 11 && (t.nodeType !== 8 || t.nodeValue !== " react-mount-point-unstable "));
  }
  function Cw() {
  }
  function wI(t, e, n, r, i) {
    if (i) {
      if (typeof r == "function") {
        var o = r;
        r = function() {
          var c = Jd(s);
          o.call(c);
        };
      }
      var s = yA(e, r, t, 0, null, false, false, "", Cw);
      return t._reactRootContainer = s, t[Xi] = s.current, uu(t.nodeType === 8 ? t.parentNode : t), Hs(), s;
    }
    for (; i = t.lastChild; )
      t.removeChild(i);
    if (typeof r == "function") {
      var a = r;
      r = function() {
        var c = Jd(l);
        a.call(c);
      };
    }
    var l = Tb(t, 0, false, null, null, false, false, "", Cw);
    return t._reactRootContainer = l, t[Xi] = l.current, uu(t.nodeType === 8 ? t.parentNode : t), Hs(function() {
      tm(e, l, n, r);
    }), l;
  }
  function im(t, e, n, r, i) {
    var o = n._reactRootContainer;
    if (o) {
      var s = o;
      if (typeof i == "function") {
        var a = i;
        i = function() {
          var l = Jd(s);
          a.call(l);
        };
      }
      tm(e, s, t, i);
    } else
      s = wI(n, e, t, i, r);
    return Jd(s);
  }
  qM = function(t) {
    switch (t.tag) {
      case 3:
        var e = t.stateNode;
        if (e.current.memoizedState.isDehydrated) {
          var n = fc(e.pendingLanes);
          n !== 0 && (q1(e, n | 1), zn(e, Mt()), (We & 6) === 0 && (al = Mt() + 500, ts()));
        }
        break;
      case 13:
        Hs(function() {
          var r = Qi(t, 1);
          if (r !== null) {
            var i = Sn();
            Wr(r, t, 1, i);
          }
        }), Mb(t, 1);
    }
  };
  G1 = function(t) {
    if (t.tag === 13) {
      var e = Qi(t, 134217728);
      if (e !== null) {
        var n = Sn();
        Wr(e, t, 134217728, n);
      }
      Mb(t, 134217728);
    }
  };
  GM = function(t) {
    if (t.tag === 13) {
      var e = Fo(t), n = Qi(t, e);
      if (n !== null) {
        var r = Sn();
        Wr(n, t, e, r);
      }
      Mb(t, e);
    }
  };
  YM = function() {
    return Ye;
  };
  XM = function(t, e) {
    var n = Ye;
    try {
      return Ye = t, e();
    } finally {
      Ye = n;
    }
  };
  Cv = function(t, e, n) {
    switch (e) {
      case "input":
        if (vv(t, n), e = n.name, n.type === "radio" && e != null) {
          for (n = t; n.parentNode; )
            n = n.parentNode;
          for (n = n.querySelectorAll("input[name=" + JSON.stringify("" + e) + '][type="radio"]'), e = 0; e < n.length; e++) {
            var r = n[e];
            if (r !== t && r.form === t.form) {
              var i = Gp(r);
              if (!i)
                throw Error(Z(90));
              AM(r), vv(r, i);
            }
          }
        }
        break;
      case "textarea":
        PM(t, n);
        break;
      case "select":
        e = n.value, e != null && Ba(t, !!n.multiple, e, false);
    }
  };
  BM = Sb;
  NM = Hs;
  var kI = {
    usingClientEntryPoint: false,
    Events: [
      Xu,
      ya,
      Gp,
      DM,
      IM,
      Sb
    ]
  }, Ql = {
    findFiberByHostInstance: Cs,
    bundleType: 0,
    version: "18.2.0",
    rendererPackageName: "react-dom"
  }, CI = {
    bundleType: Ql.bundleType,
    version: Ql.version,
    rendererPackageName: Ql.rendererPackageName,
    rendererConfig: Ql.rendererConfig,
    overrideHookState: null,
    overrideHookStateDeletePath: null,
    overrideHookStateRenamePath: null,
    overrideProps: null,
    overridePropsDeletePath: null,
    overridePropsRenamePath: null,
    setErrorHandler: null,
    setSuspenseHandler: null,
    scheduleUpdate: null,
    currentDispatcherRef: oo.ReactCurrentDispatcher,
    findHostInstanceByFiber: function(t) {
      return t = FM(t), t === null ? null : t.stateNode;
    },
    findFiberByHostInstance: Ql.findFiberByHostInstance || SI,
    findHostInstancesForRefresh: null,
    scheduleRefresh: null,
    scheduleRoot: null,
    setRefreshHandler: null,
    getCurrentFiber: null,
    reconcilerVersion: "18.2.0-next-9e3b772b8-20220608"
  };
  if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u") {
    var ih = __REACT_DEVTOOLS_GLOBAL_HOOK__;
    if (!ih.isDisabled && ih.supportsFiber)
      try {
        jp = ih.inject(CI), Si = ih;
      } catch {
      }
  }
  Jn.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = kI;
  Jn.createPortal = function(t, e) {
    var n = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null;
    if (!Eb(e))
      throw Error(Z(200));
    return xI(t, e, null, n);
  };
  Jn.createRoot = function(t, e) {
    if (!Eb(t))
      throw Error(Z(299));
    var n = false, r = "", i = bA;
    return e != null && (e.unstable_strictMode === true && (n = true), e.identifierPrefix !== void 0 && (r = e.identifierPrefix), e.onRecoverableError !== void 0 && (i = e.onRecoverableError)), e = Tb(t, 1, false, null, null, n, false, r, i), t[Xi] = e.current, uu(t.nodeType === 8 ? t.parentNode : t), new Ab(e);
  };
  Jn.findDOMNode = function(t) {
    if (t == null)
      return null;
    if (t.nodeType === 1)
      return t;
    var e = t._reactInternals;
    if (e === void 0)
      throw typeof t.render == "function" ? Error(Z(188)) : (t = Object.keys(t).join(","), Error(Z(268, t)));
    return t = FM(e), t = t === null ? null : t.stateNode, t;
  };
  Jn.flushSync = function(t) {
    return Hs(t);
  };
  Jn.hydrate = function(t, e, n) {
    if (!rm(e))
      throw Error(Z(200));
    return im(null, t, e, true, n);
  };
  Jn.hydrateRoot = function(t, e, n) {
    if (!Eb(t))
      throw Error(Z(405));
    var r = n != null && n.hydratedSources || null, i = false, o = "", s = bA;
    if (n != null && (n.unstable_strictMode === true && (i = true), n.identifierPrefix !== void 0 && (o = n.identifierPrefix), n.onRecoverableError !== void 0 && (s = n.onRecoverableError)), e = yA(e, null, t, 1, n ?? null, i, false, o, s), t[Xi] = e.current, uu(t), r)
      for (t = 0; t < r.length; t++)
        n = r[t], i = n._getVersion, i = i(n._source), e.mutableSourceEagerHydrationData == null ? e.mutableSourceEagerHydrationData = [
          n,
          i
        ] : e.mutableSourceEagerHydrationData.push(n, i);
    return new nm(e);
  };
  Jn.render = function(t, e, n) {
    if (!rm(e))
      throw Error(Z(200));
    return im(null, t, e, false, n);
  };
  Jn.unmountComponentAtNode = function(t) {
    if (!rm(t))
      throw Error(Z(40));
    return t._reactRootContainer ? (Hs(function() {
      im(null, null, t, false, function() {
        t._reactRootContainer = null, t[Xi] = null;
      });
    }), true) : false;
  };
  Jn.unstable_batchedUpdates = Sb;
  Jn.unstable_renderSubtreeIntoContainer = function(t, e, n, r) {
    if (!rm(n))
      throw Error(Z(200));
    if (t == null || t._reactInternals === void 0)
      throw Error(Z(38));
    return im(t, e, n, false, r);
  };
  Jn.version = "18.2.0-next-9e3b772b8-20220608";
  (function(t) {
    function e() {
      if (!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function"))
        try {
          __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(e);
        } catch (n) {
          console.error(n);
        }
    }
    e(), t.exports = Jn;
  })(Hp);
  var Tw = Hp.exports;
  uv.createRoot = Tw.createRoot, uv.hydrateRoot = Tw.hydrateRoot;
  function TI() {
    return Boolean(globalThis == null ? void 0 : globalThis.document);
  }
  function MI(t, ...e) {
    if (t == null)
      throw new TypeError("Cannot convert undefined or null to object");
    const n = {
      ...t
    };
    for (const r of e)
      if (r != null)
        for (const i in r)
          !Object.prototype.hasOwnProperty.call(r, i) || (i in n && delete n[i], n[i] = r[i]);
    return n;
  }
  const AI = (t) => t ? "" : void 0;
  function EI(t) {
    return Array.isArray(t);
  }
  function Hr(t) {
    const e = typeof t;
    return t != null && (e === "object" || e === "function") && !EI(t);
  }
  function PI(t) {
    const e = t == null ? 0 : t.length;
    return e ? t[e - 1] : void 0;
  }
  function OI(t) {
    const e = parseFloat(t.toString()), n = t.toString().replace(String(e), "");
    return {
      unitless: !n,
      value: e,
      unit: n
    };
  }
  function ry(t) {
    if (t == null)
      return t;
    const { unitless: e } = OI(t);
    return e || typeof t == "number" ? `${t}px` : t;
  }
  const xA = (t, e) => parseInt(t[1], 10) > parseInt(e[1], 10) ? 1 : -1, Pb = (t) => Object.fromEntries(Object.entries(t).sort(xA));
  function Mw(t) {
    const e = Pb(t);
    return Object.assign(Object.values(e), e);
  }
  function LI(t) {
    const e = Object.keys(Pb(t));
    return new Set(e);
  }
  function Aw(t) {
    if (!t)
      return t;
    t = ry(t) ?? t;
    const e = -0.02;
    return typeof t == "number" ? `${t + e}` : t.replace(/(\d+\.?\d*)/u, (n) => `${parseFloat(n) + e}`);
  }
  function dc(t, e) {
    const n = [
      "@media screen"
    ];
    return t && n.push("and", `(min-width: ${ry(t)})`), e && n.push("and", `(max-width: ${ry(e)})`), n.join(" ");
  }
  function RI(t) {
    if (!t)
      return null;
    t.base = t.base ?? "0px";
    const e = Mw(t), n = Object.entries(t).sort(xA).map(([o, s], a, l) => {
      let [, c] = l[a + 1] ?? [];
      return c = parseFloat(c) > 0 ? Aw(c) : void 0, {
        _minW: Aw(s),
        breakpoint: o,
        minW: s,
        maxW: c,
        maxWQuery: dc(null, c),
        minWQuery: dc(s),
        minMaxQuery: dc(s, c)
      };
    }), r = LI(t), i = Array.from(r.values());
    return {
      keys: r,
      normalized: e,
      isResponsive(o) {
        const s = Object.keys(o);
        return s.length > 0 && s.every((a) => r.has(a));
      },
      asObject: Pb(t),
      asArray: Mw(t),
      details: n,
      get(o) {
        return n.find((s) => s.breakpoint === o);
      },
      media: [
        null,
        ...e.map((o) => dc(o)).slice(1)
      ],
      toArrayValue(o) {
        if (!Hr(o))
          throw new Error("toArrayValue: value must be an object");
        const s = i.map((a) => o[a] ?? null);
        for (; PI(s) === null; )
          s.pop();
        return s;
      },
      toObjectValue(o) {
        if (!Array.isArray(o))
          throw new Error("toObjectValue: value must be an array");
        return o.reduce((s, a, l) => {
          const c = i[l];
          return c != null && a != null && (s[c] = a), s;
        }, {});
      }
    };
  }
  function iy(...t) {
    return function(n) {
      t.some((r) => (r == null ? void 0 : r(n), n == null ? void 0 : n.defaultPrevented));
    };
  }
  function _I(t) {
    return z.exports.Children.toArray(t).filter((e) => z.exports.isValidElement(e));
  }
  function DI(t) {
    const e = Object.assign({}, t);
    for (let n in e)
      e[n] === void 0 && delete e[n];
    return e;
  }
  function II(t, e) {
    return `${t} returned \`undefined\`. Seems you forgot to wrap component within ${e}`;
  }
  function Ei(t = {}) {
    const { name: e, strict: n = true, hookName: r = "useContext", providerName: i = "Provider", errorMessage: o, defaultValue: s } = t, a = z.exports.createContext(s);
    a.displayName = e;
    function l() {
      var _a3;
      const c = z.exports.useContext(a);
      if (!c && n) {
        const u = new Error(o ?? II(r, i));
        throw u.name = "ContextError", (_a3 = Error.captureStackTrace) == null ? void 0 : _a3.call(Error, u, l), u;
      }
      return c;
    }
    return [
      a.Provider,
      l,
      a
    ];
  }
  const Gr = (...t) => t.filter(Boolean).join(" ");
  function BI(t, e, n, r) {
    const i = typeof e == "string" ? e.split(".") : [
      e
    ];
    for (r = 0; r < i.length && t; r += 1)
      t = t[i[r]];
    return t === void 0 ? n : t;
  }
  const NI = (t) => {
    const e = /* @__PURE__ */ new WeakMap();
    return (r, i, o, s) => {
      if (typeof r > "u")
        return t(r, i, o);
      e.has(r) || e.set(r, /* @__PURE__ */ new Map());
      const a = e.get(r);
      if (a.has(i))
        return a.get(i);
      const l = t(r, i, o, s);
      return a.set(i, l), l;
    };
  }, SA = NI(BI), $I = (t) => t.default || t;
  function zI(t) {
    const { wasSelected: e, enabled: n, isSelected: r, mode: i = "unmount" } = t;
    return !!(!n || r || i === "keepMounted" && e);
  }
  function FI(t, e = []) {
    const n = Object.assign({}, t);
    for (const r of e)
      r in n && delete n[r];
    return n;
  }
  function VI(t, e) {
    const n = {};
    for (const r of e)
      r in t && (n[r] = t[r]);
    return n;
  }
  const WI = (t) => typeof t == "function";
  function vi(t, ...e) {
    return WI(t) ? t(...e) : t;
  }
  function HI(t, ...e) {
    const n = Object.getOwnPropertyDescriptors(t), r = Object.keys(n), i = (s) => {
      const a = {};
      for (let l = 0; l < s.length; l++) {
        const c = s[l];
        n[c] && (Object.defineProperty(a, c, n[c]), delete n[c]);
      }
      return a;
    }, o = (s) => i(Array.isArray(s) ? s : r.filter(s));
    return e.map(o).concat(i(r));
  }
  function Ew(t, e, n = {}) {
    const { stop: r, getKey: i } = n;
    function o(s, a = []) {
      if (Hr(s) || Array.isArray(s)) {
        const l = {};
        for (const [c, u] of Object.entries(s)) {
          const h = (i == null ? void 0 : i(c)) ?? c, p = [
            ...a,
            h
          ];
          if (r == null ? void 0 : r(s, p))
            return e(s, a);
          l[h] = o(u, p);
        }
        return l;
      }
      return e(s, a);
    }
    return o(t);
  }
  var oy = {
    exports: {}
  };
  (function(t, e) {
    var n = 200, r = "__lodash_hash_undefined__", i = 800, o = 16, s = 9007199254740991, a = "[object Arguments]", l = "[object Array]", c = "[object AsyncFunction]", u = "[object Boolean]", h = "[object Date]", p = "[object Error]", v = "[object Function]", y = "[object GeneratorFunction]", S = "[object Map]", T = "[object Number]", w = "[object Null]", k = "[object Object]", C = "[object Proxy]", O = "[object RegExp]", L = "[object Set]", D = "[object String]", R = "[object Undefined]", F = "[object WeakMap]", K = "[object ArrayBuffer]", Y = "[object DataView]", te = "[object Float32Array]", ne = "[object Float64Array]", ae = "[object Int8Array]", ye = "[object Int16Array]", Ce = "[object Int32Array]", Le = "[object Uint8Array]", ee = "[object Uint8ClampedArray]", V = "[object Uint16Array]", oe = "[object Uint32Array]", he = /[\\^$.*+?()[\]{}|]/g, Se = /^\[object .+?Constructor\]$/, ve = /^(?:0|[1-9]\d*)$/, le = {};
    le[te] = le[ne] = le[ae] = le[ye] = le[Ce] = le[Le] = le[ee] = le[V] = le[oe] = true, le[a] = le[l] = le[K] = le[u] = le[Y] = le[h] = le[p] = le[v] = le[S] = le[T] = le[k] = le[O] = le[L] = le[D] = le[F] = false;
    var re = typeof Ao == "object" && Ao && Ao.Object === Object && Ao, se = typeof self == "object" && self && self.Object === Object && self, De = re || se || Function("return this")(), vt = e && !e.nodeType && e, Mn = vt && true && t && !t.nodeType && t, so = Mn && Mn.exports === vt, Qr = so && re.process, ao = function() {
      try {
        var P = Mn && Mn.require && Mn.require("util").types;
        return P || Qr && Qr.binding && Qr.binding("util");
      } catch {
      }
    }(), Ll = ao && ao.isTypedArray;
    function mf(P, B, U) {
      switch (U.length) {
        case 0:
          return P.call(B);
        case 1:
          return P.call(B, U[0]);
        case 2:
          return P.call(B, U[0], U[1]);
        case 3:
          return P.call(B, U[0], U[1], U[2]);
      }
      return P.apply(B, U);
    }
    function gf(P, B) {
      for (var U = -1, pe = Array(P); ++U < P; )
        pe[U] = B(U);
      return pe;
    }
    function Et(P) {
      return function(B) {
        return P(B);
      };
    }
    function Jm(P, B) {
      return P == null ? void 0 : P[B];
    }
    function tr(P, B) {
      return function(U) {
        return P(B(U));
      };
    }
    var Zm = Array.prototype, eg = Function.prototype, os = Object.prototype, Er = De["__core-js_shared__"], gn = eg.toString, Pr = os.hasOwnProperty, Rl = function() {
      var P = /[^.]+$/.exec(Er && Er.keys && Er.keys.IE_PROTO || "");
      return P ? "Symbol(src)_1." + P : "";
    }(), Zs = os.toString, tg = gn.call(Object), lo = RegExp("^" + gn.call(Pr).replace(he, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"), ea = so ? De.Buffer : void 0, $t = De.Symbol, ss = De.Uint8Array, ht = ea ? ea.allocUnsafe : void 0, vf = tr(Object.getPrototypeOf, Object), yf = Object.create, ng = os.propertyIsEnumerable, bf = Zm.splice, Fe = $t ? $t.toStringTag : void 0, qt = function() {
      try {
        var P = Ie(Object, "defineProperty");
        return P({}, "", {}), P;
      } catch {
      }
    }(), lt = ea ? ea.isBuffer : void 0, zt = Math.max, Jr = Date.now, _l2 = Ie(De, "Map"), yt = Ie(Object, "create"), Dl = function() {
      function P() {
      }
      return function(B) {
        if (!Di(B))
          return {};
        if (yf)
          return yf(B);
        P.prototype = B;
        var U = new P();
        return P.prototype = void 0, U;
      };
    }();
    function Ri(P) {
      var B = -1, U = P == null ? 0 : P.length;
      for (this.clear(); ++B < U; ) {
        var pe = P[B];
        this.set(pe[0], pe[1]);
      }
    }
    function rg() {
      this.__data__ = yt ? yt(null) : {}, this.size = 0;
    }
    function xf(P) {
      var B = this.has(P) && delete this.__data__[P];
      return this.size -= B ? 1 : 0, B;
    }
    function Sf(P) {
      var B = this.__data__;
      if (yt) {
        var U = B[P];
        return U === r ? void 0 : U;
      }
      return Pr.call(B, P) ? B[P] : void 0;
    }
    function ig(P) {
      var B = this.__data__;
      return yt ? B[P] !== void 0 : Pr.call(B, P);
    }
    function og(P, B) {
      var U = this.__data__;
      return this.size += this.has(P) ? 0 : 1, U[P] = yt && B === void 0 ? r : B, this;
    }
    Ri.prototype.clear = rg, Ri.prototype.delete = xf, Ri.prototype.get = Sf, Ri.prototype.has = ig, Ri.prototype.set = og;
    function nr(P) {
      var B = -1, U = P == null ? 0 : P.length;
      for (this.clear(); ++B < U; ) {
        var pe = P[B];
        this.set(pe[0], pe[1]);
      }
    }
    function sg() {
      this.__data__ = [], this.size = 0;
    }
    function co(P) {
      var B = this.__data__, U = An(B, P);
      if (U < 0)
        return false;
      var pe = B.length - 1;
      return U == pe ? B.pop() : bf.call(B, U, 1), --this.size, true;
    }
    function Il(P) {
      var B = this.__data__, U = An(B, P);
      return U < 0 ? void 0 : B[U][1];
    }
    function ag(P) {
      return An(this.__data__, P) > -1;
    }
    function rr(P, B) {
      var U = this.__data__, pe = An(U, P);
      return pe < 0 ? (++this.size, U.push([
        P,
        B
      ])) : U[pe][1] = B, this;
    }
    nr.prototype.clear = sg, nr.prototype.delete = co, nr.prototype.get = Il, nr.prototype.has = ag, nr.prototype.set = rr;
    function uo(P) {
      var B = -1, U = P == null ? 0 : P.length;
      for (this.clear(); ++B < U; ) {
        var pe = P[B];
        this.set(pe[0], pe[1]);
      }
    }
    function lg() {
      this.size = 0, this.__data__ = {
        hash: new Ri(),
        map: new (_l2 || nr)(),
        string: new Ri()
      };
    }
    function ir(P) {
      var B = sn(this, P).delete(P);
      return this.size -= B ? 1 : 0, B;
    }
    function Bl(P) {
      return sn(this, P).get(P);
    }
    function cg(P) {
      return sn(this, P).has(P);
    }
    function wf(P, B) {
      var U = sn(this, P), pe = U.size;
      return U.set(P, B), this.size += U.size == pe ? 0 : 1, this;
    }
    uo.prototype.clear = lg, uo.prototype.delete = ir, uo.prototype.get = Bl, uo.prototype.has = cg, uo.prototype.set = wf;
    function _i2(P) {
      var B = this.__data__ = new nr(P);
      this.size = B.size;
    }
    function ug() {
      this.__data__ = new nr(), this.size = 0;
    }
    function kf(P) {
      var B = this.__data__, U = B.delete(P);
      return this.size = B.size, U;
    }
    function fg(P) {
      return this.__data__.get(P);
    }
    function Cf(P) {
      return this.__data__.has(P);
    }
    function hg(P, B) {
      var U = this.__data__;
      if (U instanceof nr) {
        var pe = U.__data__;
        if (!_l2 || pe.length < n - 1)
          return pe.push([
            P,
            B
          ]), this.size = ++U.size, this;
        U = this.__data__ = new uo(pe);
      }
      return U.set(P, B), this.size = U.size, this;
    }
    _i2.prototype.clear = ug, _i2.prototype.delete = kf, _i2.prototype.get = fg, _i2.prototype.has = Cf, _i2.prototype.set = hg;
    function Tf(P, B) {
      var U = Ft(P), pe = !U && oa(P), f = !U && !pe && sa(P), d = !U && !pe && !f && $f(P), m = U || pe || f || d, g = m ? gf(P.length, String) : [], b = g.length;
      for (var x in P)
        (B || Pr.call(P, x)) && !(m && (x == "length" || f && (x == "offset" || x == "parent") || d && (x == "buffer" || x == "byteLength" || x == "byteOffset") || Df(x, b))) && g.push(x);
      return g;
    }
    function as(P, B, U) {
      (U !== void 0 && !ia(P[B], U) || U === void 0 && !(B in P)) && Nl(P, B, U);
    }
    function dg(P, B, U) {
      var pe = P[B];
      (!(Pr.call(P, B) && ia(pe, U)) || U === void 0 && !(B in P)) && Nl(P, B, U);
    }
    function An(P, B) {
      for (var U = P.length; U--; )
        if (ia(P[U][0], B))
          return U;
      return -1;
    }
    function Nl(P, B, U) {
      B == "__proto__" && qt ? qt(P, B, {
        configurable: true,
        enumerable: true,
        value: U,
        writable: true
      }) : P[B] = U;
    }
    var Mf = _f2();
    function ls(P) {
      return P == null ? P === void 0 ? R : w : Fe && Fe in Object(P) ? Sg(P) : kg(P);
    }
    function Af(P) {
      return fs(P) && ls(P) == a;
    }
    function Ef(P) {
      if (!Di(P) || us(P))
        return false;
      var B = Vl(P) ? lo : Se;
      return B.test(Bf(P));
    }
    function pg(P) {
      return fs(P) && Nf(P.length) && !!le[ls(P)];
    }
    function mg(P) {
      if (!Di(P))
        return If(P);
      var B = na(P), U = [];
      for (var pe in P)
        pe == "constructor" && (B || !Pr.call(P, pe)) || U.push(pe);
      return U;
    }
    function En(P, B, U, pe, f) {
      P !== B && Mf(B, function(d, m) {
        if (f || (f = new _i2()), Di(d))
          gg(P, B, m, U, En, pe, f);
        else {
          var g = pe ? pe($l(P, m), d, m + "", P, B, f) : void 0;
          g === void 0 && (g = d), as(P, m, g);
        }
      }, Wl);
    }
    function gg(P, B, U, pe, f, d, m) {
      var g = $l(P, U), b = $l(B, U), x = m.get(b);
      if (x) {
        as(P, U, x);
        return;
      }
      var M = d ? d(g, b, U + "", P, B, m) : void 0, A = M === void 0;
      if (A) {
        var E = Ft(b), I = !E && sa(b), _ = !E && !I && $f(b);
        M = b, E || I || _ ? Ft(g) ? M = g : Zr(g) ? M = bg(g) : I ? (A = false, M = Of(b, true)) : _ ? (A = false, M = Lf(b, true)) : M = [] : Cg(b) || oa(b) ? (M = g, oa(g) ? M = Tg(g) : (!Di(g) || Vl(g)) && (M = ta(b))) : A = false;
      }
      A && (m.set(b, M), f(M, b, pe, d, m), m.delete(b)), as(P, U, M);
    }
    function vg(P, B) {
      return zl(fo(P, B, Hl), P + "");
    }
    var Pf = qt ? function(P, B) {
      return qt(P, "toString", {
        configurable: true,
        enumerable: false,
        value: Ff(B),
        writable: true
      });
    } : Hl;
    function Of(P, B) {
      if (B)
        return P.slice();
      var U = P.length, pe = ht ? ht(U) : new P.constructor(U);
      return P.copy(pe), pe;
    }
    function yg(P) {
      var B = new P.constructor(P.byteLength);
      return new ss(B).set(new ss(P)), B;
    }
    function Lf(P, B) {
      var U = B ? yg(P.buffer) : P.buffer;
      return new P.constructor(U, P.byteOffset, P.length);
    }
    function bg(P, B) {
      var U = -1, pe = P.length;
      for (B || (B = Array(pe)); ++U < pe; )
        B[U] = P[U];
      return B;
    }
    function Rf(P, B, U, pe) {
      var f = !U;
      U || (U = {});
      for (var d = -1, m = B.length; ++d < m; ) {
        var g = B[d], b = pe ? pe(U[g], P[g], g, U, P) : void 0;
        b === void 0 && (b = P[g]), f ? Nl(U, g, b) : dg(U, g, b);
      }
      return U;
    }
    function xg(P) {
      return vg(function(B, U) {
        var pe = -1, f = U.length, d = f > 1 ? U[f - 1] : void 0, m = f > 2 ? U[2] : void 0;
        for (d = P.length > 3 && typeof d == "function" ? (f--, d) : void 0, m && cs(U[0], U[1], m) && (d = f < 3 ? void 0 : d, f = 1), B = Object(B); ++pe < f; ) {
          var g = U[pe];
          g && P(B, g, pe, d);
        }
        return B;
      });
    }
    function _f2(P) {
      return function(B, U, pe) {
        for (var f = -1, d = Object(B), m = pe(B), g = m.length; g--; ) {
          var b = m[P ? g : ++f];
          if (U(d[b], b, d) === false)
            break;
        }
        return B;
      };
    }
    function sn(P, B) {
      var U = P.__data__;
      return wg(B) ? U[typeof B == "string" ? "string" : "hash"] : U.map;
    }
    function Ie(P, B) {
      var U = Jm(P, B);
      return Ef(U) ? U : void 0;
    }
    function Sg(P) {
      var B = Pr.call(P, Fe), U = P[Fe];
      try {
        P[Fe] = void 0;
        var pe = true;
      } catch {
      }
      var f = Zs.call(P);
      return pe && (B ? P[Fe] = U : delete P[Fe]), f;
    }
    function ta(P) {
      return typeof P.constructor == "function" && !na(P) ? Dl(vf(P)) : {};
    }
    function Df(P, B) {
      var U = typeof P;
      return B = B ?? s, !!B && (U == "number" || U != "symbol" && ve.test(P)) && P > -1 && P % 1 == 0 && P < B;
    }
    function cs(P, B, U) {
      if (!Di(U))
        return false;
      var pe = typeof B;
      return (pe == "number" ? Fl(U) && Df(B, U.length) : pe == "string" && B in U) ? ia(U[B], P) : false;
    }
    function wg(P) {
      var B = typeof P;
      return B == "string" || B == "number" || B == "symbol" || B == "boolean" ? P !== "__proto__" : P === null;
    }
    function us(P) {
      return !!Rl && Rl in P;
    }
    function na(P) {
      var B = P && P.constructor, U = typeof B == "function" && B.prototype || os;
      return P === U;
    }
    function If(P) {
      var B = [];
      if (P != null)
        for (var U in Object(P))
          B.push(U);
      return B;
    }
    function kg(P) {
      return Zs.call(P);
    }
    function fo(P, B, U) {
      return B = zt(B === void 0 ? P.length - 1 : B, 0), function() {
        for (var pe = arguments, f = -1, d = zt(pe.length - B, 0), m = Array(d); ++f < d; )
          m[f] = pe[B + f];
        f = -1;
        for (var g = Array(B + 1); ++f < B; )
          g[f] = pe[f];
        return g[B] = U(m), mf(P, this, g);
      };
    }
    function $l(P, B) {
      if (!(B === "constructor" && typeof P[B] == "function") && B != "__proto__")
        return P[B];
    }
    var zl = ra(Pf);
    function ra(P) {
      var B = 0, U = 0;
      return function() {
        var pe = Jr(), f = o - (pe - U);
        if (U = pe, f > 0) {
          if (++B >= i)
            return arguments[0];
        } else
          B = 0;
        return P.apply(void 0, arguments);
      };
    }
    function Bf(P) {
      if (P != null) {
        try {
          return gn.call(P);
        } catch {
        }
        try {
          return P + "";
        } catch {
        }
      }
      return "";
    }
    function ia(P, B) {
      return P === B || P !== P && B !== B;
    }
    var oa = Af(function() {
      return arguments;
    }()) ? Af : function(P) {
      return fs(P) && Pr.call(P, "callee") && !ng.call(P, "callee");
    }, Ft = Array.isArray;
    function Fl(P) {
      return P != null && Nf(P.length) && !Vl(P);
    }
    function Zr(P) {
      return fs(P) && Fl(P);
    }
    var sa = lt || Vf;
    function Vl(P) {
      if (!Di(P))
        return false;
      var B = ls(P);
      return B == v || B == y || B == c || B == C;
    }
    function Nf(P) {
      return typeof P == "number" && P > -1 && P % 1 == 0 && P <= s;
    }
    function Di(P) {
      var B = typeof P;
      return P != null && (B == "object" || B == "function");
    }
    function fs(P) {
      return P != null && typeof P == "object";
    }
    function Cg(P) {
      if (!fs(P) || ls(P) != k)
        return false;
      var B = vf(P);
      if (B === null)
        return true;
      var U = Pr.call(B, "constructor") && B.constructor;
      return typeof U == "function" && U instanceof U && gn.call(U) == tg;
    }
    var $f = Ll ? Et(Ll) : pg;
    function Tg(P) {
      return Rf(P, Wl(P));
    }
    function Wl(P) {
      return Fl(P) ? Tf(P, true) : mg(P);
    }
    var zf = xg(function(P, B, U, pe) {
      En(P, B, U, pe);
    });
    function Ff(P) {
      return function() {
        return P;
      };
    }
    function Hl(P) {
      return P;
    }
    function Vf() {
      return false;
    }
    t.exports = zf;
  })(oy, oy.exports);
  const yi = oy.exports;
  function nd(t, e = []) {
    const n = z.exports.useRef(t);
    return z.exports.useEffect(() => {
      n.current = t;
    }), z.exports.useCallback((...r) => {
      var _a3;
      return (_a3 = n.current) == null ? void 0 : _a3.call(n, ...r);
    }, e);
  }
  function jI(t) {
    const { value: e, defaultValue: n, onChange: r, shouldUpdate: i = (p, v) => p !== v } = t, o = nd(r), s = nd(i), [a, l] = z.exports.useState(n), c = e !== void 0, u = c ? e : a, h = nd((p) => {
      const y = typeof p == "function" ? p(u) : p;
      !s(u, y) || (c || l(y), o(y));
    }, [
      c,
      o,
      u,
      s
    ]);
    return [
      u,
      h
    ];
  }
  const sy = Boolean(globalThis == null ? void 0 : globalThis.document) ? z.exports.useLayoutEffect : z.exports.useEffect, Pw = (t, e) => {
    const n = z.exports.useRef(false), r = z.exports.useRef(false);
    z.exports.useEffect(() => {
      if (n.current && r.current)
        return t();
      r.current = true;
    }, e), z.exports.useEffect(() => (n.current = true, () => {
      n.current = false;
    }), []);
  };
  function UI(t, e) {
    if (t != null) {
      if (typeof t == "function") {
        t(e);
        return;
      }
      try {
        t.current = e;
      } catch {
        throw new Error(`Cannot assign value '${e}' to ref '${t}'`);
      }
    }
  }
  function Ob(...t) {
    return (e) => {
      t.forEach((n) => {
        UI(n, e);
      });
    };
  }
  function KI(t, e) {
    const n = nd(t);
    z.exports.useEffect(() => {
      if (e == null)
        return;
      let r = null;
      return r = window.setTimeout(() => {
        n();
      }, e), () => {
        r && window.clearTimeout(r);
      };
    }, [
      e,
      n
    ]);
  }
  const Rt = {
    open: (t, e) => `${t}[data-open], ${t}[open], ${t}[data-state=open] ${e}`,
    closed: (t, e) => `${t}[data-closed], ${t}[data-state=closed] ${e}`,
    hover: (t, e) => `${t}:hover ${e}, ${t}[data-hover] ${e}`,
    focus: (t, e) => `${t}:focus ${e}, ${t}[data-focus] ${e}`,
    focusVisible: (t, e) => `${t}:focus-visible ${e}`,
    focusWithin: (t, e) => `${t}:focus-within ${e}`,
    active: (t, e) => `${t}:active ${e}, ${t}[data-active] ${e}`,
    disabled: (t, e) => `${t}:disabled ${e}, ${t}[data-disabled] ${e}`,
    invalid: (t, e) => `${t}:invalid ${e}, ${t}[data-invalid] ${e}`,
    checked: (t, e) => `${t}:checked ${e}, ${t}[data-checked] ${e}`,
    indeterminate: (t, e) => `${t}:indeterminate ${e}, ${t}[aria-checked=mixed] ${e}, ${t}[data-indeterminate] ${e}`,
    readOnly: (t, e) => `${t}:read-only ${e}, ${t}[readonly] ${e}, ${t}[data-read-only] ${e}`,
    expanded: (t, e) => `${t}:read-only ${e}, ${t}[aria-expanded=true] ${e}, ${t}[data-expanded] ${e}`,
    placeholderShown: (t, e) => `${t}:placeholder-shown ${e}`
  }, ti = (t) => wA((e) => t(e, "&"), "[role=group]", "[data-group]", ".group"), Ii = (t) => wA((e) => t(e, "~ &"), "[data-peer]", ".peer"), wA = (t, ...e) => e.map(t).join(", "), om = {
    _hover: "&:hover, &[data-hover]",
    _active: "&:active, &[data-active]",
    _focus: "&:focus, &[data-focus]",
    _highlighted: "&[data-highlighted]",
    _focusWithin: "&:focus-within, &[data-focus-within]",
    _focusVisible: "&:focus-visible, &[data-focus-visible]",
    _disabled: "&:disabled, &[disabled], &[aria-disabled=true], &[data-disabled]",
    _readOnly: "&[aria-readonly=true], &[readonly], &[data-readonly]",
    _before: "&::before",
    _after: "&::after",
    _empty: "&:empty, &[data-empty]",
    _expanded: "&[aria-expanded=true], &[data-expanded], &[data-state=expanded]",
    _checked: "&[aria-checked=true], &[data-checked], &[data-state=checked]",
    _grabbed: "&[aria-grabbed=true], &[data-grabbed]",
    _pressed: "&[aria-pressed=true], &[data-pressed]",
    _invalid: "&[aria-invalid=true], &[data-invalid]",
    _valid: "&[data-valid], &[data-state=valid]",
    _loading: "&[data-loading], &[aria-busy=true]",
    _selected: "&[aria-selected=true], &[data-selected]",
    _hidden: "&[hidden], &[data-hidden]",
    _autofill: "&:-webkit-autofill",
    _even: "&:nth-of-type(even)",
    _odd: "&:nth-of-type(odd)",
    _first: "&:first-of-type",
    _firstLetter: "&::first-letter",
    _last: "&:last-of-type",
    _notFirst: "&:not(:first-of-type)",
    _notLast: "&:not(:last-of-type)",
    _visited: "&:visited",
    _activeLink: "&[aria-current=page]",
    _activeStep: "&[aria-current=step]",
    _indeterminate: "&:indeterminate, &[aria-checked=mixed], &[data-indeterminate], &[data-state=indeterminate]",
    _groupOpen: ti(Rt.open),
    _groupClosed: ti(Rt.closed),
    _groupHover: ti(Rt.hover),
    _peerHover: Ii(Rt.hover),
    _groupFocus: ti(Rt.focus),
    _peerFocus: Ii(Rt.focus),
    _groupFocusVisible: ti(Rt.focusVisible),
    _peerFocusVisible: Ii(Rt.focusVisible),
    _groupActive: ti(Rt.active),
    _peerActive: Ii(Rt.active),
    _groupDisabled: ti(Rt.disabled),
    _peerDisabled: Ii(Rt.disabled),
    _groupInvalid: ti(Rt.invalid),
    _peerInvalid: Ii(Rt.invalid),
    _groupChecked: ti(Rt.checked),
    _peerChecked: Ii(Rt.checked),
    _groupFocusWithin: ti(Rt.focusWithin),
    _peerFocusWithin: Ii(Rt.focusWithin),
    _peerPlaceholderShown: Ii(Rt.placeholderShown),
    _placeholder: "&::placeholder, &[data-placeholder]",
    _placeholderShown: "&:placeholder-shown, &[data-placeholder-shown]",
    _fullScreen: "&:fullscreen, &[data-fullscreen]",
    _selection: "&::selection",
    _rtl: "[dir=rtl] &, &[dir=rtl]",
    _ltr: "[dir=ltr] &, &[dir=ltr]",
    _mediaDark: "@media (prefers-color-scheme: dark)",
    _mediaReduceMotion: "@media (prefers-reduced-motion: reduce)",
    _dark: ".chakra-ui-dark &:not([data-theme]),[data-theme=dark] &:not([data-theme]),&[data-theme=dark]",
    _light: ".chakra-ui-light &:not([data-theme]),[data-theme=light] &:not([data-theme]),&[data-theme=light]",
    _horizontal: "&[data-orientation=horizontal]",
    _vertical: "&[data-orientation=vertical]",
    _open: "&[data-open], &[open], &[data-state=open]",
    _closed: "&[data-closed], &[data-state=closed]",
    _complete: "&[data-complete]",
    _incomplete: "&[data-incomplete]",
    _current: "&[data-current]"
  }, kA = Object.keys(om), qI = (t) => /!(important)?$/.test(t), Ow = (t) => typeof t == "string" ? t.replace(/!(important)?$/, "").trim() : t, GI = (t, e) => (n) => {
    const r = String(e), i = qI(r), o = Ow(r), s = t ? `${t}.${o}` : o;
    let a = Hr(n.__cssMap) && s in n.__cssMap ? n.__cssMap[s].varRef : e;
    return a = Ow(a), i ? `${a} !important` : a;
  };
  function Lb(t) {
    const { scale: e, transform: n, compose: r } = t;
    return (o, s) => {
      const a = GI(e, o)(s);
      let l = (n == null ? void 0 : n(a, s)) ?? a;
      return r && (l = r(l, s)), l;
    };
  }
  const oh = (...t) => (e) => t.reduce((n, r) => r(n), e);
  function ar(t, e) {
    return (n) => {
      const r = {
        property: n,
        scale: t
      };
      return r.transform = Lb({
        scale: t,
        transform: e
      }), r;
    };
  }
  const YI = ({ rtl: t, ltr: e }) => (n) => n.direction === "rtl" ? t : e;
  function XI(t) {
    const { property: e, scale: n, transform: r } = t;
    return {
      scale: n,
      property: YI(e),
      transform: n ? Lb({
        scale: n,
        compose: r
      }) : r
    };
  }
  const CA = [
    "rotate(var(--chakra-rotate, 0))",
    "scaleX(var(--chakra-scale-x, 1))",
    "scaleY(var(--chakra-scale-y, 1))",
    "skewX(var(--chakra-skew-x, 0))",
    "skewY(var(--chakra-skew-y, 0))"
  ];
  function QI() {
    return [
      "translateX(var(--chakra-translate-x, 0))",
      "translateY(var(--chakra-translate-y, 0))",
      ...CA
    ].join(" ");
  }
  function JI() {
    return [
      "translate3d(var(--chakra-translate-x, 0), var(--chakra-translate-y, 0), 0)",
      ...CA
    ].join(" ");
  }
  const ZI = {
    "--chakra-blur": "var(--chakra-empty,/*!*/ /*!*/)",
    "--chakra-brightness": "var(--chakra-empty,/*!*/ /*!*/)",
    "--chakra-contrast": "var(--chakra-empty,/*!*/ /*!*/)",
    "--chakra-grayscale": "var(--chakra-empty,/*!*/ /*!*/)",
    "--chakra-hue-rotate": "var(--chakra-empty,/*!*/ /*!*/)",
    "--chakra-invert": "var(--chakra-empty,/*!*/ /*!*/)",
    "--chakra-saturate": "var(--chakra-empty,/*!*/ /*!*/)",
    "--chakra-sepia": "var(--chakra-empty,/*!*/ /*!*/)",
    "--chakra-drop-shadow": "var(--chakra-empty,/*!*/ /*!*/)",
    filter: [
      "var(--chakra-blur)",
      "var(--chakra-brightness)",
      "var(--chakra-contrast)",
      "var(--chakra-grayscale)",
      "var(--chakra-hue-rotate)",
      "var(--chakra-invert)",
      "var(--chakra-saturate)",
      "var(--chakra-sepia)",
      "var(--chakra-drop-shadow)"
    ].join(" ")
  }, eB = {
    backdropFilter: [
      "var(--chakra-backdrop-blur)",
      "var(--chakra-backdrop-brightness)",
      "var(--chakra-backdrop-contrast)",
      "var(--chakra-backdrop-grayscale)",
      "var(--chakra-backdrop-hue-rotate)",
      "var(--chakra-backdrop-invert)",
      "var(--chakra-backdrop-opacity)",
      "var(--chakra-backdrop-saturate)",
      "var(--chakra-backdrop-sepia)"
    ].join(" "),
    "--chakra-backdrop-blur": "var(--chakra-empty,/*!*/ /*!*/)",
    "--chakra-backdrop-brightness": "var(--chakra-empty,/*!*/ /*!*/)",
    "--chakra-backdrop-contrast": "var(--chakra-empty,/*!*/ /*!*/)",
    "--chakra-backdrop-grayscale": "var(--chakra-empty,/*!*/ /*!*/)",
    "--chakra-backdrop-hue-rotate": "var(--chakra-empty,/*!*/ /*!*/)",
    "--chakra-backdrop-invert": "var(--chakra-empty,/*!*/ /*!*/)",
    "--chakra-backdrop-opacity": "var(--chakra-empty,/*!*/ /*!*/)",
    "--chakra-backdrop-saturate": "var(--chakra-empty,/*!*/ /*!*/)",
    "--chakra-backdrop-sepia": "var(--chakra-empty,/*!*/ /*!*/)"
  };
  function tB(t) {
    return {
      "--chakra-ring-offset-shadow": "var(--chakra-ring-inset) 0 0 0 var(--chakra-ring-offset-width) var(--chakra-ring-offset-color)",
      "--chakra-ring-shadow": "var(--chakra-ring-inset) 0 0 0 calc(var(--chakra-ring-width) + var(--chakra-ring-offset-width)) var(--chakra-ring-color)",
      "--chakra-ring-width": t,
      boxShadow: [
        "var(--chakra-ring-offset-shadow)",
        "var(--chakra-ring-shadow)",
        "var(--chakra-shadow, 0 0 #0000)"
      ].join(", ")
    };
  }
  const nB = {
    "row-reverse": {
      space: "--chakra-space-x-reverse",
      divide: "--chakra-divide-x-reverse"
    },
    "column-reverse": {
      space: "--chakra-space-y-reverse",
      divide: "--chakra-divide-y-reverse"
    }
  }, ay = {
    "to-t": "to top",
    "to-tr": "to top right",
    "to-r": "to right",
    "to-br": "to bottom right",
    "to-b": "to bottom",
    "to-bl": "to bottom left",
    "to-l": "to left",
    "to-tl": "to top left"
  }, rB = new Set(Object.values(ay)), ly = /* @__PURE__ */ new Set([
    "none",
    "-moz-initial",
    "inherit",
    "initial",
    "revert",
    "unset"
  ]), iB = (t) => t.trim();
  function oB(t, e) {
    if (t == null || ly.has(t))
      return t;
    if (!(cy(t) || ly.has(t)))
      return `url('${t}')`;
    const i = /(^[a-z-A-Z]+)\((.*)\)/g.exec(t), o = i == null ? void 0 : i[1], s = i == null ? void 0 : i[2];
    if (!o || !s)
      return t;
    const a = o.includes("-gradient") ? o : `${o}-gradient`, [l, ...c] = s.split(",").map(iB).filter(Boolean);
    if ((c == null ? void 0 : c.length) === 0)
      return t;
    const u = l in ay ? ay[l] : l;
    c.unshift(u);
    const h = c.map((p) => {
      if (rB.has(p))
        return p;
      const v = p.indexOf(" "), [y, S] = v !== -1 ? [
        p.substr(0, v),
        p.substr(v + 1)
      ] : [
        p
      ], T = cy(S) ? S : S && S.split(" "), w = `colors.${y}`, k = w in e.__cssMap ? e.__cssMap[w].varRef : y;
      return T ? [
        k,
        ...Array.isArray(T) ? T : [
          T
        ]
      ].join(" ") : k;
    });
    return `${a}(${h.join(", ")})`;
  }
  const cy = (t) => typeof t == "string" && t.includes("(") && t.includes(")"), sB = (t, e) => oB(t, e ?? {});
  function aB(t) {
    return /^var\(--.+\)$/.test(t);
  }
  const lB = (t) => {
    const e = parseFloat(t.toString()), n = t.toString().replace(String(e), "");
    return {
      unitless: !n,
      value: e,
      unit: n
    };
  }, ni = (t) => (e) => `${t}(${e})`, Ne = {
    filter(t) {
      return t !== "auto" ? t : ZI;
    },
    backdropFilter(t) {
      return t !== "auto" ? t : eB;
    },
    ring(t) {
      return tB(Ne.px(t));
    },
    bgClip(t) {
      return t === "text" ? {
        color: "transparent",
        backgroundClip: "text"
      } : {
        backgroundClip: t
      };
    },
    transform(t) {
      return t === "auto" ? QI() : t === "auto-gpu" ? JI() : t;
    },
    vh(t) {
      return t === "$100vh" ? "var(--chakra-vh)" : t;
    },
    px(t) {
      if (t == null)
        return t;
      const { unitless: e } = lB(t);
      return e || typeof t == "number" ? `${t}px` : t;
    },
    fraction(t) {
      return typeof t != "number" || t > 1 ? t : `${t * 100}%`;
    },
    float(t, e) {
      const n = {
        left: "right",
        right: "left"
      };
      return e.direction === "rtl" ? n[t] : t;
    },
    degree(t) {
      if (aB(t) || t == null)
        return t;
      const e = typeof t == "string" && !t.endsWith("deg");
      return typeof t == "number" || e ? `${t}deg` : t;
    },
    gradient: sB,
    blur: ni("blur"),
    opacity: ni("opacity"),
    brightness: ni("brightness"),
    contrast: ni("contrast"),
    dropShadow: ni("drop-shadow"),
    grayscale: ni("grayscale"),
    hueRotate: (t) => ni("hue-rotate")(Ne.degree(t)),
    invert: ni("invert"),
    saturate: ni("saturate"),
    sepia: ni("sepia"),
    bgImage(t) {
      return t == null || cy(t) || ly.has(t) ? t : `url(${t})`;
    },
    outline(t) {
      const e = String(t) === "0" || String(t) === "none";
      return t !== null && e ? {
        outline: "2px solid transparent",
        outlineOffset: "2px"
      } : {
        outline: t
      };
    },
    flexDirection(t) {
      const { space: e, divide: n } = nB[t] ?? {}, r = {
        flexDirection: t
      };
      return e && (r[e] = 1), n && (r[n] = 1), r;
    }
  }, N = {
    borderWidths: ar("borderWidths"),
    borderStyles: ar("borderStyles"),
    colors: ar("colors"),
    borders: ar("borders"),
    gradients: ar("gradients", Ne.gradient),
    radii: ar("radii", Ne.px),
    space: ar("space", oh(Ne.vh, Ne.px)),
    spaceT: ar("space", oh(Ne.vh, Ne.px)),
    degreeT(t) {
      return {
        property: t,
        transform: Ne.degree
      };
    },
    prop(t, e, n) {
      return {
        property: t,
        scale: e,
        ...e && {
          transform: Lb({
            scale: e,
            transform: n
          })
        }
      };
    },
    propT(t, e) {
      return {
        property: t,
        transform: e
      };
    },
    sizes: ar("sizes", oh(Ne.vh, Ne.px)),
    sizesT: ar("sizes", oh(Ne.vh, Ne.fraction)),
    shadows: ar("shadows"),
    logical: XI,
    blur: ar("blur", Ne.blur)
  }, rd = {
    background: N.colors("background"),
    backgroundColor: N.colors("backgroundColor"),
    backgroundImage: N.gradients("backgroundImage"),
    backgroundSize: true,
    backgroundPosition: true,
    backgroundRepeat: true,
    backgroundAttachment: true,
    backgroundClip: {
      transform: Ne.bgClip
    },
    bgSize: N.prop("backgroundSize"),
    bgPosition: N.prop("backgroundPosition"),
    bg: N.colors("background"),
    bgColor: N.colors("backgroundColor"),
    bgPos: N.prop("backgroundPosition"),
    bgRepeat: N.prop("backgroundRepeat"),
    bgAttachment: N.prop("backgroundAttachment"),
    bgGradient: N.gradients("backgroundImage"),
    bgClip: {
      transform: Ne.bgClip
    }
  };
  Object.assign(rd, {
    bgImage: rd.backgroundImage,
    bgImg: rd.backgroundImage
  });
  const je = {
    border: N.borders("border"),
    borderWidth: N.borderWidths("borderWidth"),
    borderStyle: N.borderStyles("borderStyle"),
    borderColor: N.colors("borderColor"),
    borderRadius: N.radii("borderRadius"),
    borderTop: N.borders("borderTop"),
    borderBlockStart: N.borders("borderBlockStart"),
    borderTopLeftRadius: N.radii("borderTopLeftRadius"),
    borderStartStartRadius: N.logical({
      scale: "radii",
      property: {
        ltr: "borderTopLeftRadius",
        rtl: "borderTopRightRadius"
      }
    }),
    borderEndStartRadius: N.logical({
      scale: "radii",
      property: {
        ltr: "borderBottomLeftRadius",
        rtl: "borderBottomRightRadius"
      }
    }),
    borderTopRightRadius: N.radii("borderTopRightRadius"),
    borderStartEndRadius: N.logical({
      scale: "radii",
      property: {
        ltr: "borderTopRightRadius",
        rtl: "borderTopLeftRadius"
      }
    }),
    borderEndEndRadius: N.logical({
      scale: "radii",
      property: {
        ltr: "borderBottomRightRadius",
        rtl: "borderBottomLeftRadius"
      }
    }),
    borderRight: N.borders("borderRight"),
    borderInlineEnd: N.borders("borderInlineEnd"),
    borderBottom: N.borders("borderBottom"),
    borderBlockEnd: N.borders("borderBlockEnd"),
    borderBottomLeftRadius: N.radii("borderBottomLeftRadius"),
    borderBottomRightRadius: N.radii("borderBottomRightRadius"),
    borderLeft: N.borders("borderLeft"),
    borderInlineStart: {
      property: "borderInlineStart",
      scale: "borders"
    },
    borderInlineStartRadius: N.logical({
      scale: "radii",
      property: {
        ltr: [
          "borderTopLeftRadius",
          "borderBottomLeftRadius"
        ],
        rtl: [
          "borderTopRightRadius",
          "borderBottomRightRadius"
        ]
      }
    }),
    borderInlineEndRadius: N.logical({
      scale: "radii",
      property: {
        ltr: [
          "borderTopRightRadius",
          "borderBottomRightRadius"
        ],
        rtl: [
          "borderTopLeftRadius",
          "borderBottomLeftRadius"
        ]
      }
    }),
    borderX: N.borders([
      "borderLeft",
      "borderRight"
    ]),
    borderInline: N.borders("borderInline"),
    borderY: N.borders([
      "borderTop",
      "borderBottom"
    ]),
    borderBlock: N.borders("borderBlock"),
    borderTopWidth: N.borderWidths("borderTopWidth"),
    borderBlockStartWidth: N.borderWidths("borderBlockStartWidth"),
    borderTopColor: N.colors("borderTopColor"),
    borderBlockStartColor: N.colors("borderBlockStartColor"),
    borderTopStyle: N.borderStyles("borderTopStyle"),
    borderBlockStartStyle: N.borderStyles("borderBlockStartStyle"),
    borderBottomWidth: N.borderWidths("borderBottomWidth"),
    borderBlockEndWidth: N.borderWidths("borderBlockEndWidth"),
    borderBottomColor: N.colors("borderBottomColor"),
    borderBlockEndColor: N.colors("borderBlockEndColor"),
    borderBottomStyle: N.borderStyles("borderBottomStyle"),
    borderBlockEndStyle: N.borderStyles("borderBlockEndStyle"),
    borderLeftWidth: N.borderWidths("borderLeftWidth"),
    borderInlineStartWidth: N.borderWidths("borderInlineStartWidth"),
    borderLeftColor: N.colors("borderLeftColor"),
    borderInlineStartColor: N.colors("borderInlineStartColor"),
    borderLeftStyle: N.borderStyles("borderLeftStyle"),
    borderInlineStartStyle: N.borderStyles("borderInlineStartStyle"),
    borderRightWidth: N.borderWidths("borderRightWidth"),
    borderInlineEndWidth: N.borderWidths("borderInlineEndWidth"),
    borderRightColor: N.colors("borderRightColor"),
    borderInlineEndColor: N.colors("borderInlineEndColor"),
    borderRightStyle: N.borderStyles("borderRightStyle"),
    borderInlineEndStyle: N.borderStyles("borderInlineEndStyle"),
    borderTopRadius: N.radii([
      "borderTopLeftRadius",
      "borderTopRightRadius"
    ]),
    borderBottomRadius: N.radii([
      "borderBottomLeftRadius",
      "borderBottomRightRadius"
    ]),
    borderLeftRadius: N.radii([
      "borderTopLeftRadius",
      "borderBottomLeftRadius"
    ]),
    borderRightRadius: N.radii([
      "borderTopRightRadius",
      "borderBottomRightRadius"
    ])
  };
  Object.assign(je, {
    rounded: je.borderRadius,
    roundedTop: je.borderTopRadius,
    roundedTopLeft: je.borderTopLeftRadius,
    roundedTopRight: je.borderTopRightRadius,
    roundedTopStart: je.borderStartStartRadius,
    roundedTopEnd: je.borderStartEndRadius,
    roundedBottom: je.borderBottomRadius,
    roundedBottomLeft: je.borderBottomLeftRadius,
    roundedBottomRight: je.borderBottomRightRadius,
    roundedBottomStart: je.borderEndStartRadius,
    roundedBottomEnd: je.borderEndEndRadius,
    roundedLeft: je.borderLeftRadius,
    roundedRight: je.borderRightRadius,
    roundedStart: je.borderInlineStartRadius,
    roundedEnd: je.borderInlineEndRadius,
    borderStart: je.borderInlineStart,
    borderEnd: je.borderInlineEnd,
    borderTopStartRadius: je.borderStartStartRadius,
    borderTopEndRadius: je.borderStartEndRadius,
    borderBottomStartRadius: je.borderEndStartRadius,
    borderBottomEndRadius: je.borderEndEndRadius,
    borderStartRadius: je.borderInlineStartRadius,
    borderEndRadius: je.borderInlineEndRadius,
    borderStartWidth: je.borderInlineStartWidth,
    borderEndWidth: je.borderInlineEndWidth,
    borderStartColor: je.borderInlineStartColor,
    borderEndColor: je.borderInlineEndColor,
    borderStartStyle: je.borderInlineStartStyle,
    borderEndStyle: je.borderInlineEndStyle
  });
  const cB = {
    color: N.colors("color"),
    textColor: N.colors("color"),
    fill: N.colors("fill"),
    stroke: N.colors("stroke"),
    accentColor: N.colors("accentColor"),
    textFillColor: N.colors("textFillColor")
  }, Zd = {
    alignItems: true,
    alignContent: true,
    justifyItems: true,
    justifyContent: true,
    flexWrap: true,
    flexDirection: {
      transform: Ne.flexDirection
    },
    flex: true,
    flexFlow: true,
    flexGrow: true,
    flexShrink: true,
    flexBasis: N.sizes("flexBasis"),
    justifySelf: true,
    alignSelf: true,
    order: true,
    placeItems: true,
    placeContent: true,
    placeSelf: true,
    gap: N.space("gap"),
    rowGap: N.space("rowGap"),
    columnGap: N.space("columnGap")
  };
  Object.assign(Zd, {
    flexDir: Zd.flexDirection
  });
  const lr = {
    width: N.sizesT("width"),
    inlineSize: N.sizesT("inlineSize"),
    height: N.sizes("height"),
    blockSize: N.sizes("blockSize"),
    boxSize: N.sizes([
      "width",
      "height"
    ]),
    minWidth: N.sizes("minWidth"),
    minInlineSize: N.sizes("minInlineSize"),
    minHeight: N.sizes("minHeight"),
    minBlockSize: N.sizes("minBlockSize"),
    maxWidth: N.sizes("maxWidth"),
    maxInlineSize: N.sizes("maxInlineSize"),
    maxHeight: N.sizes("maxHeight"),
    maxBlockSize: N.sizes("maxBlockSize"),
    overflow: true,
    overflowX: true,
    overflowY: true,
    overscrollBehavior: true,
    overscrollBehaviorX: true,
    overscrollBehaviorY: true,
    display: true,
    aspectRatio: true,
    hideFrom: {
      scale: "breakpoints",
      transform: (t, e) => {
        var _a3, _b3;
        return {
          [`@media screen and (min-width: ${((_b3 = (_a3 = e.__breakpoints) == null ? void 0 : _a3.get(t)) == null ? void 0 : _b3.minW) ?? t})`]: {
            display: "none"
          }
        };
      }
    },
    hideBelow: {
      scale: "breakpoints",
      transform: (t, e) => {
        var _a3, _b3;
        return {
          [`@media screen and (max-width: ${((_b3 = (_a3 = e.__breakpoints) == null ? void 0 : _a3.get(t)) == null ? void 0 : _b3._minW) ?? t})`]: {
            display: "none"
          }
        };
      }
    },
    verticalAlign: true,
    boxSizing: true,
    boxDecorationBreak: true,
    float: N.propT("float", Ne.float),
    objectFit: true,
    objectPosition: true,
    visibility: true,
    isolation: true
  };
  Object.assign(lr, {
    w: lr.width,
    h: lr.height,
    minW: lr.minWidth,
    maxW: lr.maxWidth,
    minH: lr.minHeight,
    maxH: lr.maxHeight,
    overscroll: lr.overscrollBehavior,
    overscrollX: lr.overscrollBehaviorX,
    overscrollY: lr.overscrollBehaviorY
  });
  const uB = {
    filter: {
      transform: Ne.filter
    },
    blur: N.blur("--chakra-blur"),
    brightness: N.propT("--chakra-brightness", Ne.brightness),
    contrast: N.propT("--chakra-contrast", Ne.contrast),
    hueRotate: N.propT("--chakra-hue-rotate", Ne.hueRotate),
    invert: N.propT("--chakra-invert", Ne.invert),
    saturate: N.propT("--chakra-saturate", Ne.saturate),
    dropShadow: N.propT("--chakra-drop-shadow", Ne.dropShadow),
    backdropFilter: {
      transform: Ne.backdropFilter
    },
    backdropBlur: N.blur("--chakra-backdrop-blur"),
    backdropBrightness: N.propT("--chakra-backdrop-brightness", Ne.brightness),
    backdropContrast: N.propT("--chakra-backdrop-contrast", Ne.contrast),
    backdropHueRotate: N.propT("--chakra-backdrop-hue-rotate", Ne.hueRotate),
    backdropInvert: N.propT("--chakra-backdrop-invert", Ne.invert),
    backdropSaturate: N.propT("--chakra-backdrop-saturate", Ne.saturate)
  }, fB = {
    ring: {
      transform: Ne.ring
    },
    ringColor: N.colors("--chakra-ring-color"),
    ringOffset: N.prop("--chakra-ring-offset-width"),
    ringOffsetColor: N.colors("--chakra-ring-offset-color"),
    ringInset: N.prop("--chakra-ring-inset")
  }, hB = {
    appearance: true,
    cursor: true,
    resize: true,
    userSelect: true,
    pointerEvents: true,
    outline: {
      transform: Ne.outline
    },
    outlineOffset: true,
    outlineColor: N.colors("outlineColor")
  }, TA = {
    gridGap: N.space("gridGap"),
    gridColumnGap: N.space("gridColumnGap"),
    gridRowGap: N.space("gridRowGap"),
    gridColumn: true,
    gridRow: true,
    gridAutoFlow: true,
    gridAutoColumns: true,
    gridColumnStart: true,
    gridColumnEnd: true,
    gridRowStart: true,
    gridRowEnd: true,
    gridAutoRows: true,
    gridTemplate: true,
    gridTemplateColumns: true,
    gridTemplateRows: true,
    gridTemplateAreas: true,
    gridArea: true
  };
  function dB(t, e, n, r) {
    const i = typeof e == "string" ? e.split(".") : [
      e
    ];
    for (r = 0; r < i.length && t; r += 1)
      t = t[i[r]];
    return t === void 0 ? n : t;
  }
  const pB = (t) => {
    const e = /* @__PURE__ */ new WeakMap();
    return (r, i, o, s) => {
      if (typeof r > "u")
        return t(r, i, o);
      e.has(r) || e.set(r, /* @__PURE__ */ new Map());
      const a = e.get(r);
      if (a.has(i))
        return a.get(i);
      const l = t(r, i, o, s);
      return a.set(i, l), l;
    };
  }, mB = pB(dB), gB = {
    border: "0px",
    clip: "rect(0, 0, 0, 0)",
    width: "1px",
    height: "1px",
    margin: "-1px",
    padding: "0px",
    overflow: "hidden",
    whiteSpace: "nowrap",
    position: "absolute"
  }, vB = {
    position: "static",
    width: "auto",
    height: "auto",
    clip: "auto",
    padding: "0",
    margin: "0",
    overflow: "visible",
    whiteSpace: "normal"
  }, Zg = (t, e, n) => {
    const r = {}, i = mB(t, e, {});
    for (const o in i)
      o in n && n[o] != null || (r[o] = i[o]);
    return r;
  }, yB = {
    srOnly: {
      transform(t) {
        return t === true ? gB : t === "focusable" ? vB : {};
      }
    },
    layerStyle: {
      processResult: true,
      transform: (t, e, n) => Zg(e, `layerStyles.${t}`, n)
    },
    textStyle: {
      processResult: true,
      transform: (t, e, n) => Zg(e, `textStyles.${t}`, n)
    },
    apply: {
      processResult: true,
      transform: (t, e, n) => Zg(e, t, n)
    }
  }, _c = {
    position: true,
    pos: N.prop("position"),
    zIndex: N.prop("zIndex", "zIndices"),
    inset: N.spaceT("inset"),
    insetX: N.spaceT([
      "left",
      "right"
    ]),
    insetInline: N.spaceT("insetInline"),
    insetY: N.spaceT([
      "top",
      "bottom"
    ]),
    insetBlock: N.spaceT("insetBlock"),
    top: N.spaceT("top"),
    insetBlockStart: N.spaceT("insetBlockStart"),
    bottom: N.spaceT("bottom"),
    insetBlockEnd: N.spaceT("insetBlockEnd"),
    left: N.spaceT("left"),
    insetInlineStart: N.logical({
      scale: "space",
      property: {
        ltr: "left",
        rtl: "right"
      }
    }),
    right: N.spaceT("right"),
    insetInlineEnd: N.logical({
      scale: "space",
      property: {
        ltr: "right",
        rtl: "left"
      }
    })
  };
  Object.assign(_c, {
    insetStart: _c.insetInlineStart,
    insetEnd: _c.insetInlineEnd
  });
  const uy = {
    boxShadow: N.shadows("boxShadow"),
    mixBlendMode: true,
    blendMode: N.prop("mixBlendMode"),
    backgroundBlendMode: true,
    bgBlendMode: N.prop("backgroundBlendMode"),
    opacity: true
  };
  Object.assign(uy, {
    shadow: uy.boxShadow
  });
  const st = {
    margin: N.spaceT("margin"),
    marginTop: N.spaceT("marginTop"),
    marginBlockStart: N.spaceT("marginBlockStart"),
    marginRight: N.spaceT("marginRight"),
    marginInlineEnd: N.spaceT("marginInlineEnd"),
    marginBottom: N.spaceT("marginBottom"),
    marginBlockEnd: N.spaceT("marginBlockEnd"),
    marginLeft: N.spaceT("marginLeft"),
    marginInlineStart: N.spaceT("marginInlineStart"),
    marginX: N.spaceT([
      "marginInlineStart",
      "marginInlineEnd"
    ]),
    marginInline: N.spaceT("marginInline"),
    marginY: N.spaceT([
      "marginTop",
      "marginBottom"
    ]),
    marginBlock: N.spaceT("marginBlock"),
    padding: N.space("padding"),
    paddingTop: N.space("paddingTop"),
    paddingBlockStart: N.space("paddingBlockStart"),
    paddingRight: N.space("paddingRight"),
    paddingBottom: N.space("paddingBottom"),
    paddingBlockEnd: N.space("paddingBlockEnd"),
    paddingLeft: N.space("paddingLeft"),
    paddingInlineStart: N.space("paddingInlineStart"),
    paddingInlineEnd: N.space("paddingInlineEnd"),
    paddingX: N.space([
      "paddingInlineStart",
      "paddingInlineEnd"
    ]),
    paddingInline: N.space("paddingInline"),
    paddingY: N.space([
      "paddingTop",
      "paddingBottom"
    ]),
    paddingBlock: N.space("paddingBlock")
  };
  Object.assign(st, {
    m: st.margin,
    mt: st.marginTop,
    mr: st.marginRight,
    me: st.marginInlineEnd,
    marginEnd: st.marginInlineEnd,
    mb: st.marginBottom,
    ml: st.marginLeft,
    ms: st.marginInlineStart,
    marginStart: st.marginInlineStart,
    mx: st.marginX,
    my: st.marginY,
    p: st.padding,
    pt: st.paddingTop,
    py: st.paddingY,
    px: st.paddingX,
    pb: st.paddingBottom,
    pl: st.paddingLeft,
    ps: st.paddingInlineStart,
    paddingStart: st.paddingInlineStart,
    pr: st.paddingRight,
    pe: st.paddingInlineEnd,
    paddingEnd: st.paddingInlineEnd
  });
  const bB = {
    scrollBehavior: true,
    scrollSnapAlign: true,
    scrollSnapStop: true,
    scrollSnapType: true,
    scrollMargin: N.spaceT("scrollMargin"),
    scrollMarginTop: N.spaceT("scrollMarginTop"),
    scrollMarginBottom: N.spaceT("scrollMarginBottom"),
    scrollMarginLeft: N.spaceT("scrollMarginLeft"),
    scrollMarginRight: N.spaceT("scrollMarginRight"),
    scrollMarginX: N.spaceT([
      "scrollMarginLeft",
      "scrollMarginRight"
    ]),
    scrollMarginY: N.spaceT([
      "scrollMarginTop",
      "scrollMarginBottom"
    ]),
    scrollPadding: N.spaceT("scrollPadding"),
    scrollPaddingTop: N.spaceT("scrollPaddingTop"),
    scrollPaddingBottom: N.spaceT("scrollPaddingBottom"),
    scrollPaddingLeft: N.spaceT("scrollPaddingLeft"),
    scrollPaddingRight: N.spaceT("scrollPaddingRight"),
    scrollPaddingX: N.spaceT([
      "scrollPaddingLeft",
      "scrollPaddingRight"
    ]),
    scrollPaddingY: N.spaceT([
      "scrollPaddingTop",
      "scrollPaddingBottom"
    ])
  }, xB = {
    fontFamily: N.prop("fontFamily", "fonts"),
    fontSize: N.prop("fontSize", "fontSizes", Ne.px),
    fontWeight: N.prop("fontWeight", "fontWeights"),
    lineHeight: N.prop("lineHeight", "lineHeights"),
    letterSpacing: N.prop("letterSpacing", "letterSpacings"),
    textAlign: true,
    fontStyle: true,
    textIndent: true,
    wordBreak: true,
    overflowWrap: true,
    textOverflow: true,
    textTransform: true,
    whiteSpace: true,
    isTruncated: {
      transform(t) {
        if (t === true)
          return {
            overflow: "hidden",
            textOverflow: "ellipsis",
            whiteSpace: "nowrap"
          };
      }
    },
    noOfLines: {
      static: {
        overflow: "hidden",
        textOverflow: "ellipsis",
        display: "-webkit-box",
        WebkitBoxOrient: "vertical",
        WebkitLineClamp: "var(--chakra-line-clamp)"
      },
      property: "--chakra-line-clamp"
    }
  }, SB = {
    textDecorationColor: N.colors("textDecorationColor"),
    textDecoration: true,
    textDecor: {
      property: "textDecoration"
    },
    textDecorationLine: true,
    textDecorationStyle: true,
    textDecorationThickness: true,
    textUnderlineOffset: true,
    textShadow: N.shadows("textShadow")
  }, wB = {
    clipPath: true,
    transform: N.propT("transform", Ne.transform),
    transformOrigin: true,
    translateX: N.spaceT("--chakra-translate-x"),
    translateY: N.spaceT("--chakra-translate-y"),
    skewX: N.degreeT("--chakra-skew-x"),
    skewY: N.degreeT("--chakra-skew-y"),
    scaleX: N.prop("--chakra-scale-x"),
    scaleY: N.prop("--chakra-scale-y"),
    scale: N.prop([
      "--chakra-scale-x",
      "--chakra-scale-y"
    ]),
    rotate: N.degreeT("--chakra-rotate")
  }, kB = {
    listStyleType: true,
    listStylePosition: true,
    listStylePos: N.prop("listStylePosition"),
    listStyleImage: true,
    listStyleImg: N.prop("listStyleImage")
  }, CB = {
    transition: true,
    transitionDelay: true,
    animation: true,
    willChange: true,
    transitionDuration: N.prop("transitionDuration", "transition.duration"),
    transitionProperty: N.prop("transitionProperty", "transition.property"),
    transitionTimingFunction: N.prop("transitionTimingFunction", "transition.easing")
  }, Rb = yi({}, rd, je, cB, Zd, lr, uB, fB, hB, TA, yB, _c, uy, st, bB, xB, SB, wB, kB, CB);
  Object.assign({}, st, lr, Zd, TA, _c);
  const TB = [
    ...Object.keys(Rb),
    ...kA
  ], MB = {
    ...Rb,
    ...om
  }, AB = (t) => t in MB, EB = (t) => (e) => {
    if (!e.__breakpoints)
      return t;
    const { isResponsive: n, toArrayValue: r, media: i } = e.__breakpoints, o = {};
    for (const s in t) {
      let a = vi(t[s], e);
      if (a == null)
        continue;
      if (a = Hr(a) && n(a) ? r(a) : a, !Array.isArray(a)) {
        o[s] = a;
        continue;
      }
      const l = a.slice(0, i.length).length;
      for (let c = 0; c < l; c += 1) {
        const u = i == null ? void 0 : i[c];
        if (!u) {
          o[s] = a[c];
          continue;
        }
        o[u] = o[u] || {}, a[c] != null && (o[u][s] = a[c]);
      }
    }
    return o;
  };
  function PB(t) {
    const e = [];
    let n = "", r = false;
    for (let i = 0; i < t.length; i++) {
      const o = t[i];
      o === "(" ? (r = true, n += o) : o === ")" ? (r = false, n += o) : o === "," && !r ? (e.push(n), n = "") : n += o;
    }
    return n = n.trim(), n && e.push(n), e;
  }
  function OB(t) {
    return /^var\(--.+\)$/.test(t);
  }
  const LB = (t, e) => t.startsWith("--") && typeof e == "string" && !OB(e), RB = (t, e) => {
    if (e == null)
      return e;
    const n = (s) => {
      var _a3, _b3;
      return (_b3 = (_a3 = t.__cssMap) == null ? void 0 : _a3[s]) == null ? void 0 : _b3.varRef;
    }, r = (s) => n(s) ?? s, [i, o] = PB(e);
    return e = n(i) ?? r(o) ?? r(e), e;
  };
  function _B(t) {
    const { configs: e = {}, pseudos: n = {}, theme: r } = t, i = (o, s = false) => {
      var _a3;
      const a = vi(o, r), l = EB(a)(r);
      let c = {};
      for (let u in l) {
        const h = l[u];
        let p = vi(h, r);
        u in n && (u = n[u]), LB(u, p) && (p = RB(r, p));
        let v = e[u];
        if (v === true && (v = {
          property: u
        }), Hr(p)) {
          c[u] = c[u] ?? {}, c[u] = yi({}, c[u], i(p, true));
          continue;
        }
        let y = ((_a3 = v == null ? void 0 : v.transform) == null ? void 0 : _a3.call(v, p, r, a)) ?? p;
        y = (v == null ? void 0 : v.processResult) ? i(y, true) : y;
        const S = vi(v == null ? void 0 : v.property, r);
        if (!s && (v == null ? void 0 : v.static)) {
          const T = vi(v.static, r);
          c = yi({}, c, T);
        }
        if (S && Array.isArray(S)) {
          for (const T of S)
            c[T] = y;
          continue;
        }
        if (S) {
          S === "&" && Hr(y) ? c = yi({}, c, y) : c[S] = y;
          continue;
        }
        if (Hr(y)) {
          c = yi({}, c, y);
          continue;
        }
        c[u] = y;
      }
      return c;
    };
    return i;
  }
  const MA = (t) => (e) => _B({
    theme: e,
    pseudos: om,
    configs: Rb
  })(t);
  function it(t) {
    return {
      definePartsStyle(e) {
        return e;
      },
      defineMultiStyleConfig(e) {
        return {
          parts: t,
          ...e
        };
      }
    };
  }
  function DB(t, e) {
    if (Array.isArray(t))
      return t;
    if (Hr(t))
      return e(t);
    if (t != null)
      return [
        t
      ];
  }
  function IB(t, e) {
    for (let n = e + 1; n < t.length; n++)
      if (t[n] != null)
        return n;
    return -1;
  }
  function BB(t) {
    const e = t.__breakpoints;
    return function(r, i, o, s) {
      var _a3, _b3;
      if (!e)
        return;
      const a = {}, l = DB(o, e.toArrayValue);
      if (!l)
        return a;
      const c = l.length, u = c === 1, h = !!r.parts;
      for (let p = 0; p < c; p++) {
        const v = e.details[p], y = e.details[IB(l, p)], S = dc(v.minW, y == null ? void 0 : y._minW), T = vi((_a3 = r[i]) == null ? void 0 : _a3[l[p]], s);
        if (!!T) {
          if (h) {
            (_b3 = r.parts) == null ? void 0 : _b3.forEach((w) => {
              yi(a, {
                [w]: u ? T[w] : {
                  [S]: T[w]
                }
              });
            });
            continue;
          }
          if (!h) {
            u ? yi(a, T) : a[S] = T;
            continue;
          }
          a[S] = T;
        }
      }
      return a;
    };
  }
  function NB(t) {
    return (e) => {
      const { variant: n, size: r, theme: i } = e, o = BB(i);
      return yi({}, vi(t.baseStyle ?? {}, e), o(t, "sizes", r, e), o(t, "variants", n, e));
    };
  }
  function sm(t) {
    return FI(t, [
      "styleConfig",
      "size",
      "variant",
      "colorScheme"
    ]);
  }
  function AA(t) {
    return Hr(t) && t.reference ? t.reference : String(t);
  }
  const am = (t, ...e) => e.map(AA).join(` ${t} `).replace(/calc/g, ""), Lw = (...t) => `calc(${am("+", ...t)})`, Rw = (...t) => `calc(${am("-", ...t)})`, fy = (...t) => `calc(${am("*", ...t)})`, _w = (...t) => `calc(${am("/", ...t)})`, Dw = (t) => {
    const e = AA(t);
    return e != null && !Number.isNaN(parseFloat(e)) ? String(e).startsWith("-") ? String(e).slice(1) : `-${e}` : fy(e, -1);
  }, zi = Object.assign((t) => ({
    add: (...e) => zi(Lw(t, ...e)),
    subtract: (...e) => zi(Rw(t, ...e)),
    multiply: (...e) => zi(fy(t, ...e)),
    divide: (...e) => zi(_w(t, ...e)),
    negate: () => zi(Dw(t)),
    toString: () => t.toString()
  }), {
    add: Lw,
    subtract: Rw,
    multiply: fy,
    divide: _w,
    negate: Dw
  });
  function $B(t, e = "-") {
    return t.replace(/\s+/g, e);
  }
  function zB(t) {
    const e = $B(t.toString());
    return VB(FB(e));
  }
  function FB(t) {
    return t.includes("\\.") ? t : !Number.isInteger(parseFloat(t.toString())) ? t.replace(".", "\\.") : t;
  }
  function VB(t) {
    return t.replace(/[!-,/:-@[-^`{-~]/g, "\\$&");
  }
  function WB(t, e = "") {
    return [
      e,
      t
    ].filter(Boolean).join("-");
  }
  function HB(t, e) {
    return `var(${t}${e ? `, ${e}` : ""})`;
  }
  function jB(t, e = "") {
    return zB(`--${WB(t, e)}`);
  }
  function ke(t, e, n) {
    const r = jB(t, n);
    return {
      variable: r,
      reference: HB(r, e)
    };
  }
  function UB(t, e) {
    const n = {};
    for (const r of e) {
      if (Array.isArray(r)) {
        const [i, o] = r;
        n[i] = ke(`${t}-${i}`, o);
        continue;
      }
      n[r] = ke(`${t}-${r}`);
    }
    return n;
  }
  const KB = [
    "colors",
    "borders",
    "borderWidths",
    "borderStyles",
    "fonts",
    "fontSizes",
    "fontWeights",
    "gradients",
    "letterSpacings",
    "lineHeights",
    "radii",
    "space",
    "shadows",
    "sizes",
    "zIndices",
    "transition",
    "blur",
    "breakpoints"
  ];
  function qB(t) {
    return VI(t, KB);
  }
  function GB(t) {
    return t.semanticTokens;
  }
  function YB(t) {
    const { __cssMap: e, __cssVars: n, __breakpoints: r, ...i } = t;
    return i;
  }
  function XB(t) {
    const e = qB(t), n = GB(t), r = (o) => kA.includes(o) || o === "default", i = {};
    return Ew(e, (o, s) => {
      o != null && (i[s.join(".")] = {
        isSemantic: false,
        value: o
      });
    }), Ew(n, (o, s) => {
      o != null && (i[s.join(".")] = {
        isSemantic: true,
        value: o
      });
    }, {
      stop: (o) => Object.keys(o).every(r)
    }), i;
  }
  function Iw(t, e) {
    return ke(String(t).replace(/\./g, "-"), void 0, e);
  }
  function QB(t) {
    var _a3;
    const e = XB(t), n = (_a3 = t.config) == null ? void 0 : _a3.cssVarPrefix;
    let r = {};
    const i = {};
    function o(s, a) {
      const c = [
        String(s).split(".")[0],
        a
      ].join(".");
      if (!e[c])
        return a;
      const { reference: h } = Iw(c, n);
      return h;
    }
    for (const [s, a] of Object.entries(e)) {
      const { isSemantic: l, value: c } = a, { variable: u, reference: h } = Iw(s, n);
      if (!l) {
        if (s.startsWith("space")) {
          const v = s.split("."), [y, ...S] = v, T = `${y}.-${S.join(".")}`, w = zi.negate(c), k = zi.negate(h);
          i[T] = {
            value: w,
            var: u,
            varRef: k
          };
        }
        r[u] = c, i[s] = {
          value: c,
          var: u,
          varRef: h
        };
        continue;
      }
      const p = Hr(c) ? c : {
        default: c
      };
      r = yi(r, Object.entries(p).reduce((v, [y, S]) => {
        if (!S)
          return v;
        const T = o(s, `${S}`);
        if (y === "default")
          return v[u] = T, v;
        const w = (om == null ? void 0 : om[y]) ?? y;
        return v[w] = {
          [u]: T
        }, v;
      }, {})), i[s] = {
        value: h,
        var: u,
        varRef: h
      };
    }
    return {
      cssVars: r,
      cssMap: i
    };
  }
  function JB(t) {
    const e = YB(t), { cssMap: n, cssVars: r } = QB(e);
    return Object.assign(e, {
      __cssVars: {
        ...{
          "--chakra-ring-inset": "var(--chakra-empty,/*!*/ /*!*/)",
          "--chakra-ring-offset-width": "0px",
          "--chakra-ring-offset-color": "#fff",
          "--chakra-ring-color": "rgba(66, 153, 225, 0.6)",
          "--chakra-ring-offset-shadow": "0 0 #0000",
          "--chakra-ring-shadow": "0 0 #0000",
          "--chakra-space-x-reverse": "0",
          "--chakra-space-y-reverse": "0"
        },
        ...r
      },
      __cssMap: n,
      __breakpoints: RI(e.breakpoints)
    }), e;
  }
  function Ge(t, e = {}) {
    let n = false;
    function r() {
      if (!n) {
        n = true;
        return;
      }
      throw new Error("[anatomy] .part(...) should only be called once. Did you mean to use .extend(...) ?");
    }
    function i(...u) {
      r();
      for (const h of u)
        e[h] = l(h);
      return Ge(t, e);
    }
    function o(...u) {
      for (const h of u)
        h in e || (e[h] = l(h));
      return Ge(t, e);
    }
    function s() {
      return Object.fromEntries(Object.entries(e).map(([h, p]) => [
        h,
        p.selector
      ]));
    }
    function a() {
      return Object.fromEntries(Object.entries(e).map(([h, p]) => [
        h,
        p.className
      ]));
    }
    function l(u) {
      const v = `chakra-${([
        "container",
        "root"
      ].includes(u ?? "") ? [
        t
      ] : [
        t,
        u
      ]).filter(Boolean).join("__")}`;
      return {
        className: v,
        selector: `.${v}`,
        toString: () => u
      };
    }
    return {
      parts: i,
      toPart: l,
      extend: o,
      selectors: s,
      classnames: a,
      get keys() {
        return Object.keys(e);
      },
      __type: {}
    };
  }
  const ZB = Ge("accordion").parts("root", "container", "button", "panel", "icon"), eN = Ge("alert").parts("title", "description", "container", "icon", "spinner"), tN = Ge("avatar").parts("label", "badge", "container", "excessLabel", "group"), nN = Ge("breadcrumb").parts("link", "item", "container", "separator");
  Ge("button").parts();
  const rN = Ge("checkbox").parts("control", "icon", "container", "label");
  Ge("progress").parts("track", "filledTrack", "label");
  const iN = Ge("drawer").parts("overlay", "dialogContainer", "dialog", "header", "closeButton", "body", "footer"), oN = Ge("editable").parts("preview", "input", "textarea"), sN = Ge("form").parts("container", "requiredIndicator", "helperText"), aN = Ge("formError").parts("text", "icon"), lN = Ge("input").parts("addon", "field", "element", "group"), cN = Ge("list").parts("container", "item", "icon"), uN = Ge("menu").parts("button", "list", "item", "groupTitle", "icon", "command", "divider"), fN = Ge("modal").parts("overlay", "dialogContainer", "dialog", "header", "closeButton", "body", "footer"), hN = Ge("numberinput").parts("root", "field", "stepperGroup", "stepper");
  Ge("pininput").parts("field");
  const dN = Ge("popover").parts("content", "header", "body", "footer", "popper", "arrow", "closeButton"), pN = Ge("progress").parts("label", "filledTrack", "track"), mN = Ge("radio").parts("container", "control", "label"), gN = Ge("select").parts("field", "icon"), vN = Ge("slider").parts("container", "track", "thumb", "filledTrack", "mark"), yN = Ge("stat").parts("container", "label", "helpText", "number", "icon"), bN = Ge("switch").parts("container", "track", "thumb", "label"), xN = Ge("table").parts("table", "thead", "tbody", "tr", "th", "td", "tfoot", "caption"), SN = Ge("tabs").parts("root", "tab", "tablist", "tabpanel", "tabpanels", "indicator"), wN = Ge("tag").parts("container", "label", "closeButton"), kN = Ge("card").parts("container", "header", "body", "footer");
  Ge("stepper").parts("stepper", "step", "title", "description", "indicator", "separator", "icon", "number");
  const { definePartsStyle: CN, defineMultiStyleConfig: TN } = it(ZB.keys), MN = {
    borderTopWidth: "1px",
    borderColor: "inherit",
    _last: {
      borderBottomWidth: "1px"
    }
  }, AN = {
    transitionProperty: "common",
    transitionDuration: "normal",
    fontSize: "md",
    _focusVisible: {
      boxShadow: "outline"
    },
    _hover: {
      bg: "blackAlpha.50"
    },
    _disabled: {
      opacity: 0.4,
      cursor: "not-allowed"
    },
    px: "4",
    py: "2"
  }, EN = {
    pt: "2",
    px: "4",
    pb: "5"
  }, PN = {
    fontSize: "1.25em"
  }, ON = CN({
    container: MN,
    button: AN,
    panel: EN,
    icon: PN
  }), LN = TN({
    baseStyle: ON
  });
  function As(t, e, n) {
    return Math.min(Math.max(t, n), e);
  }
  class RN extends Error {
    constructor(e) {
      super(`Failed to parse color: "${e}"`);
    }
  }
  var pc = RN;
  function _b(t) {
    if (typeof t != "string")
      throw new pc(t);
    if (t.trim().toLowerCase() === "transparent")
      return [
        0,
        0,
        0,
        0
      ];
    let e = t.trim();
    e = FN.test(t) ? IN(t) : t;
    const n = BN.exec(e);
    if (n) {
      const s = Array.from(n).slice(1);
      return [
        ...s.slice(0, 3).map((a) => parseInt(bu(a, 2), 16)),
        parseInt(bu(s[3] || "f", 2), 16) / 255
      ];
    }
    const r = NN.exec(e);
    if (r) {
      const s = Array.from(r).slice(1);
      return [
        ...s.slice(0, 3).map((a) => parseInt(a, 16)),
        parseInt(s[3] || "ff", 16) / 255
      ];
    }
    const i = $N.exec(e);
    if (i) {
      const s = Array.from(i).slice(1);
      return [
        ...s.slice(0, 3).map((a) => parseInt(a, 10)),
        parseFloat(s[3] || "1")
      ];
    }
    const o = zN.exec(e);
    if (o) {
      const [s, a, l, c] = Array.from(o).slice(1).map(parseFloat);
      if (As(0, 100, a) !== a)
        throw new pc(t);
      if (As(0, 100, l) !== l)
        throw new pc(t);
      return [
        ...VN(s, a, l),
        Number.isNaN(c) ? 1 : c
      ];
    }
    throw new pc(t);
  }
  function _N(t) {
    let e = 5381, n = t.length;
    for (; n; )
      e = e * 33 ^ t.charCodeAt(--n);
    return (e >>> 0) % 2341;
  }
  const Bw = (t) => parseInt(t.replace(/_/g, ""), 36), DN = "1q29ehhb 1n09sgk7 1kl1ekf_ _yl4zsno 16z9eiv3 1p29lhp8 _bd9zg04 17u0____ _iw9zhe5 _to73___ _r45e31e _7l6g016 _jh8ouiv _zn3qba8 1jy4zshs 11u87k0u 1ro9yvyo 1aj3xael 1gz9zjz0 _3w8l4xo 1bf1ekf_ _ke3v___ _4rrkb__ 13j776yz _646mbhl _nrjr4__ _le6mbhl 1n37ehkb _m75f91n _qj3bzfz 1939yygw 11i5z6x8 _1k5f8xs 1509441m 15t5lwgf _ae2th1n _tg1ugcv 1lp1ugcv 16e14up_ _h55rw7n _ny9yavn _7a11xb_ 1ih442g9 _pv442g9 1mv16xof 14e6y7tu 1oo9zkds 17d1cisi _4v9y70f _y98m8kc 1019pq0v 12o9zda8 _348j4f4 1et50i2o _8epa8__ _ts6senj 1o350i2o 1mi9eiuo 1259yrp0 1ln80gnw _632xcoy 1cn9zldc _f29edu4 1n490c8q _9f9ziet 1b94vk74 _m49zkct 1kz6s73a 1eu9dtog _q58s1rz 1dy9sjiq __u89jo3 _aj5nkwg _ld89jo3 13h9z6wx _qa9z2ii _l119xgq _bs5arju 1hj4nwk9 1qt4nwk9 1ge6wau6 14j9zlcw 11p1edc_ _ms1zcxe _439shk6 _jt9y70f _754zsow 1la40eju _oq5p___ _x279qkz 1fa5r3rv _yd2d9ip _424tcku _8y1di2_ _zi2uabw _yy7rn9h 12yz980_ __39ljp6 1b59zg0x _n39zfzp 1fy9zest _b33k___ _hp9wq92 1il50hz4 _io472ub _lj9z3eo 19z9ykg0 _8t8iu3a 12b9bl4a 1ak5yw0o _896v4ku _tb8k8lv _s59zi6t _c09ze0p 1lg80oqn 1id9z8wb _238nba5 1kq6wgdi _154zssg _tn3zk49 _da9y6tc 1sg7cv4f _r12jvtt 1gq5fmkz 1cs9rvci _lp9jn1c _xw1tdnb 13f9zje6 16f6973h _vo7ir40 _bt5arjf _rc45e4t _hr4e100 10v4e100 _hc9zke2 _w91egv_ _sj2r1kk 13c87yx8 _vqpds__ _ni8ggk8 _tj9yqfb 1ia2j4r4 _7x9b10u 1fc9ld4j 1eq9zldr _5j9lhpx _ez9zl6o _md61fzm".split(" ").reduce((t, e) => {
    const n = Bw(e.substring(0, 3)), r = Bw(e.substring(3)).toString(16);
    let i = "";
    for (let o = 0; o < 6 - r.length; o++)
      i += "0";
    return t[n] = `${i}${r}`, t;
  }, {});
  function IN(t) {
    const e = t.toLowerCase().trim(), n = DN[_N(e)];
    if (!n)
      throw new pc(t);
    return `#${n}`;
  }
  const bu = (t, e) => Array.from(Array(e)).map(() => t).join(""), BN = new RegExp(`^#${bu("([a-f0-9])", 3)}([a-f0-9])?$`, "i"), NN = new RegExp(`^#${bu("([a-f0-9]{2})", 3)}([a-f0-9]{2})?$`, "i"), $N = new RegExp(`^rgba?\\(\\s*(\\d+)\\s*${bu(",\\s*(\\d+)\\s*", 2)}(?:,\\s*([\\d.]+))?\\s*\\)$`, "i"), zN = /^hsla?\(\s*([\d.]+)\s*,\s*([\d.]+)%\s*,\s*([\d.]+)%(?:\s*,\s*([\d.]+))?\s*\)$/i, FN = /^[a-z]+$/i, Nw = (t) => Math.round(t * 255), VN = (t, e, n) => {
    let r = n / 100;
    if (e === 0)
      return [
        r,
        r,
        r
      ].map(Nw);
    const i = (t % 360 + 360) % 360 / 60, o = (1 - Math.abs(2 * r - 1)) * (e / 100), s = o * (1 - Math.abs(i % 2 - 1));
    let a = 0, l = 0, c = 0;
    i >= 0 && i < 1 ? (a = o, l = s) : i >= 1 && i < 2 ? (a = s, l = o) : i >= 2 && i < 3 ? (l = o, c = s) : i >= 3 && i < 4 ? (l = s, c = o) : i >= 4 && i < 5 ? (a = s, c = o) : i >= 5 && i < 6 && (a = o, c = s);
    const u = r - o / 2, h = a + u, p = l + u, v = c + u;
    return [
      h,
      p,
      v
    ].map(Nw);
  };
  function WN(t, e, n, r) {
    return `rgba(${As(0, 255, t).toFixed()}, ${As(0, 255, e).toFixed()}, ${As(0, 255, n).toFixed()}, ${parseFloat(As(0, 1, r).toFixed(3))})`;
  }
  function HN(t, e) {
    const [n, r, i, o] = _b(t);
    return WN(n, r, i, o - e);
  }
  function jN(t) {
    const [e, n, r, i] = _b(t);
    let o = (s) => {
      const a = As(0, 255, s).toString(16);
      return a.length === 1 ? `0${a}` : a;
    };
    return `#${o(e)}${o(n)}${o(r)}${i < 1 ? o(Math.round(i * 255)) : ""}`;
  }
  const UN = (t) => Object.keys(t).length === 0;
  function KN(t, e, n, r, i) {
    for (e = e.split ? e.split(".") : e, r = 0; r < e.length; r++)
      t = t ? t[e[r]] : i;
    return t === i ? n : t;
  }
  const xn = (t, e, n) => {
    const r = KN(t, `colors.${e}`, e);
    try {
      return jN(r), r;
    } catch {
      return n ?? "#000000";
    }
  }, qN = (t) => {
    const [e, n, r] = _b(t);
    return (e * 299 + n * 587 + r * 114) / 1e3;
  }, GN = (t) => (e) => {
    const n = xn(e, t);
    return qN(n) < 128 ? "dark" : "light";
  }, YN = (t) => (e) => GN(t)(e) === "dark", ll = (t, e) => (n) => {
    const r = xn(n, t);
    return HN(r, 1 - e);
  };
  function $w(t = "1rem", e = "rgba(255, 255, 255, 0.15)") {
    return {
      backgroundImage: `linear-gradient(
    45deg,
    ${e} 25%,
    transparent 25%,
    transparent 50%,
    ${e} 50%,
    ${e} 75%,
    transparent 75%,
    transparent
  )`,
      backgroundSize: `${t} ${t}`
    };
  }
  const XN = () => `#${Math.floor(Math.random() * 16777215).toString(16).padEnd(6, "0")}`;
  function QN(t) {
    const e = XN();
    return !t || UN(t) ? e : t.string && t.colors ? ZN(t.string, t.colors) : t.string && !t.colors ? JN(t.string) : t.colors && !t.string ? e5(t.colors) : e;
  }
  function JN(t) {
    let e = 0;
    if (t.length === 0)
      return e.toString();
    for (let r = 0; r < t.length; r += 1)
      e = t.charCodeAt(r) + ((e << 5) - e), e = e & e;
    let n = "#";
    for (let r = 0; r < 3; r += 1) {
      const i = e >> r * 8 & 255;
      n += `00${i.toString(16)}`.substr(-2);
    }
    return n;
  }
  function ZN(t, e) {
    let n = 0;
    if (t.length === 0)
      return e[0];
    for (let r = 0; r < t.length; r += 1)
      n = t.charCodeAt(r) + ((n << 5) - n), n = n & n;
    return n = (n % e.length + e.length) % e.length, e[n];
  }
  function e5(t) {
    return t[Math.floor(Math.random() * t.length)];
  }
  function we(t, e) {
    return (n) => n.colorMode === "dark" ? e : t;
  }
  function Db(t) {
    const { orientation: e, vertical: n, horizontal: r } = t;
    return e ? e === "vertical" ? n : r : {};
  }
  function EA(t) {
    return Hr(t) && t.reference ? t.reference : String(t);
  }
  const lm = (t, ...e) => e.map(EA).join(` ${t} `).replace(/calc/g, ""), zw = (...t) => `calc(${lm("+", ...t)})`, Fw = (...t) => `calc(${lm("-", ...t)})`, hy = (...t) => `calc(${lm("*", ...t)})`, Vw = (...t) => `calc(${lm("/", ...t)})`, Ww = (t) => {
    const e = EA(t);
    return e != null && !Number.isNaN(parseFloat(e)) ? String(e).startsWith("-") ? String(e).slice(1) : `-${e}` : hy(e, -1);
  }, Fi = Object.assign((t) => ({
    add: (...e) => Fi(zw(t, ...e)),
    subtract: (...e) => Fi(Fw(t, ...e)),
    multiply: (...e) => Fi(hy(t, ...e)),
    divide: (...e) => Fi(Vw(t, ...e)),
    negate: () => Fi(Ww(t)),
    toString: () => t.toString()
  }), {
    add: zw,
    subtract: Fw,
    multiply: hy,
    divide: Vw,
    negate: Ww
  });
  function t5(t) {
    return !Number.isInteger(parseFloat(t.toString()));
  }
  function n5(t, e = "-") {
    return t.replace(/\s+/g, e);
  }
  function PA(t) {
    const e = n5(t.toString());
    return e.includes("\\.") ? t : t5(t) ? e.replace(".", "\\.") : t;
  }
  function r5(t, e = "") {
    return [
      e,
      PA(t)
    ].filter(Boolean).join("-");
  }
  function i5(t, e) {
    return `var(${PA(t)}${e ? `, ${e}` : ""})`;
  }
  function o5(t, e = "") {
    return `--${r5(t, e)}`;
  }
  function Nt(t, e) {
    const n = o5(t, e == null ? void 0 : e.prefix);
    return {
      variable: n,
      reference: i5(n, s5(e == null ? void 0 : e.fallback))
    };
  }
  function s5(t) {
    return typeof t == "string" ? t : t == null ? void 0 : t.reference;
  }
  const { definePartsStyle: Ju, defineMultiStyleConfig: a5 } = it(eN.keys), Gn = ke("alert-fg"), Zi = ke("alert-bg"), l5 = Ju({
    container: {
      bg: Zi.reference,
      px: "4",
      py: "3"
    },
    title: {
      fontWeight: "bold",
      lineHeight: "6",
      marginEnd: "2"
    },
    description: {
      lineHeight: "6"
    },
    icon: {
      color: Gn.reference,
      flexShrink: 0,
      marginEnd: "3",
      w: "5",
      h: "6"
    },
    spinner: {
      color: Gn.reference,
      flexShrink: 0,
      marginEnd: "3",
      w: "5",
      h: "5"
    }
  });
  function Ib(t) {
    const { theme: e, colorScheme: n } = t, r = ll(`${n}.200`, 0.16)(e);
    return {
      light: `colors.${n}.100`,
      dark: r
    };
  }
  const c5 = Ju((t) => {
    const { colorScheme: e } = t, n = Ib(t);
    return {
      container: {
        [Gn.variable]: `colors.${e}.600`,
        [Zi.variable]: n.light,
        _dark: {
          [Gn.variable]: `colors.${e}.200`,
          [Zi.variable]: n.dark
        }
      }
    };
  }), u5 = Ju((t) => {
    const { colorScheme: e } = t, n = Ib(t);
    return {
      container: {
        [Gn.variable]: `colors.${e}.600`,
        [Zi.variable]: n.light,
        _dark: {
          [Gn.variable]: `colors.${e}.200`,
          [Zi.variable]: n.dark
        },
        paddingStart: "3",
        borderStartWidth: "4px",
        borderStartColor: Gn.reference
      }
    };
  }), f5 = Ju((t) => {
    const { colorScheme: e } = t, n = Ib(t);
    return {
      container: {
        [Gn.variable]: `colors.${e}.600`,
        [Zi.variable]: n.light,
        _dark: {
          [Gn.variable]: `colors.${e}.200`,
          [Zi.variable]: n.dark
        },
        pt: "2",
        borderTopWidth: "4px",
        borderTopColor: Gn.reference
      }
    };
  }), h5 = Ju((t) => {
    const { colorScheme: e } = t;
    return {
      container: {
        [Gn.variable]: "colors.white",
        [Zi.variable]: `colors.${e}.600`,
        _dark: {
          [Gn.variable]: "colors.gray.900",
          [Zi.variable]: `colors.${e}.200`
        },
        color: Gn.reference
      }
    };
  }), d5 = {
    subtle: c5,
    "left-accent": u5,
    "top-accent": f5,
    solid: h5
  }, p5 = a5({
    baseStyle: l5,
    variants: d5,
    defaultProps: {
      variant: "subtle",
      colorScheme: "blue"
    }
  }), OA = {
    px: "1px",
    0.5: "0.125rem",
    1: "0.25rem",
    1.5: "0.375rem",
    2: "0.5rem",
    2.5: "0.625rem",
    3: "0.75rem",
    3.5: "0.875rem",
    4: "1rem",
    5: "1.25rem",
    6: "1.5rem",
    7: "1.75rem",
    8: "2rem",
    9: "2.25rem",
    10: "2.5rem",
    12: "3rem",
    14: "3.5rem",
    16: "4rem",
    20: "5rem",
    24: "6rem",
    28: "7rem",
    32: "8rem",
    36: "9rem",
    40: "10rem",
    44: "11rem",
    48: "12rem",
    52: "13rem",
    56: "14rem",
    60: "15rem",
    64: "16rem",
    72: "18rem",
    80: "20rem",
    96: "24rem"
  }, m5 = {
    max: "max-content",
    min: "min-content",
    full: "100%",
    "3xs": "14rem",
    "2xs": "16rem",
    xs: "20rem",
    sm: "24rem",
    md: "28rem",
    lg: "32rem",
    xl: "36rem",
    "2xl": "42rem",
    "3xl": "48rem",
    "4xl": "56rem",
    "5xl": "64rem",
    "6xl": "72rem",
    "7xl": "80rem",
    "8xl": "90rem",
    prose: "60ch"
  }, g5 = {
    sm: "640px",
    md: "768px",
    lg: "1024px",
    xl: "1280px"
  }, LA = {
    ...OA,
    ...m5,
    container: g5
  }, v5 = (t) => typeof t == "function";
  function wn(t, ...e) {
    return v5(t) ? t(...e) : t;
  }
  const { definePartsStyle: RA, defineMultiStyleConfig: y5 } = it(tN.keys), Wa = ke("avatar-border-color"), Dc = ke("avatar-bg"), xu = ke("avatar-font-size"), cl = ke("avatar-size"), b5 = {
    borderRadius: "full",
    border: "0.2em solid",
    borderColor: Wa.reference,
    [Wa.variable]: "white",
    _dark: {
      [Wa.variable]: "colors.gray.800"
    }
  }, x5 = {
    bg: Dc.reference,
    fontSize: xu.reference,
    width: cl.reference,
    height: cl.reference,
    lineHeight: "1",
    [Dc.variable]: "colors.gray.200",
    _dark: {
      [Dc.variable]: "colors.whiteAlpha.400"
    }
  }, S5 = (t) => {
    const { name: e, theme: n } = t, r = e ? QN({
      string: e
    }) : "colors.gray.400", i = YN(r)(n);
    let o = "white";
    return i || (o = "gray.800"), {
      bg: Dc.reference,
      fontSize: xu.reference,
      color: o,
      borderColor: Wa.reference,
      verticalAlign: "top",
      width: cl.reference,
      height: cl.reference,
      "&:not([data-loaded])": {
        [Dc.variable]: r
      },
      [Wa.variable]: "colors.white",
      _dark: {
        [Wa.variable]: "colors.gray.800"
      }
    };
  }, w5 = {
    fontSize: xu.reference,
    lineHeight: "1"
  }, k5 = RA((t) => ({
    badge: wn(b5, t),
    excessLabel: wn(x5, t),
    container: wn(S5, t),
    label: w5
  }));
  function po(t) {
    const e = t !== "100%" ? LA[t] : void 0;
    return RA({
      container: {
        [cl.variable]: e ?? t,
        [xu.variable]: `calc(${e ?? t} / 2.5)`
      },
      excessLabel: {
        [cl.variable]: e ?? t,
        [xu.variable]: `calc(${e ?? t} / 2.5)`
      }
    });
  }
  const C5 = {
    "2xs": po(4),
    xs: po(6),
    sm: po(8),
    md: po(12),
    lg: po(16),
    xl: po(24),
    "2xl": po(32),
    full: po("100%")
  }, T5 = y5({
    baseStyle: k5,
    sizes: C5,
    defaultProps: {
      size: "md"
    }
  }), At = UB("badge", [
    "bg",
    "color",
    "shadow"
  ]), M5 = {
    px: 1,
    textTransform: "uppercase",
    fontSize: "xs",
    borderRadius: "sm",
    fontWeight: "bold",
    bg: At.bg.reference,
    color: At.color.reference,
    boxShadow: At.shadow.reference
  }, A5 = (t) => {
    const { colorScheme: e, theme: n } = t, r = ll(`${e}.500`, 0.6)(n);
    return {
      [At.bg.variable]: `colors.${e}.500`,
      [At.color.variable]: "colors.white",
      _dark: {
        [At.bg.variable]: r,
        [At.color.variable]: "colors.whiteAlpha.800"
      }
    };
  }, E5 = (t) => {
    const { colorScheme: e, theme: n } = t, r = ll(`${e}.200`, 0.16)(n);
    return {
      [At.bg.variable]: `colors.${e}.100`,
      [At.color.variable]: `colors.${e}.800`,
      _dark: {
        [At.bg.variable]: r,
        [At.color.variable]: `colors.${e}.200`
      }
    };
  }, P5 = (t) => {
    const { colorScheme: e, theme: n } = t, r = ll(`${e}.200`, 0.8)(n);
    return {
      [At.color.variable]: `colors.${e}.500`,
      _dark: {
        [At.color.variable]: r
      },
      [At.shadow.variable]: `inset 0 0 0px 1px ${At.color.reference}`
    };
  }, O5 = {
    solid: A5,
    subtle: E5,
    outline: P5
  }, Ic = {
    baseStyle: M5,
    variants: O5,
    defaultProps: {
      variant: "subtle",
      colorScheme: "gray"
    }
  }, { defineMultiStyleConfig: L5, definePartsStyle: R5 } = it(nN.keys), e0 = ke("breadcrumb-link-decor"), _5 = {
    transitionProperty: "common",
    transitionDuration: "fast",
    transitionTimingFunction: "ease-out",
    outline: "none",
    color: "inherit",
    textDecoration: e0.reference,
    [e0.variable]: "none",
    "&:not([aria-current=page])": {
      cursor: "pointer",
      _hover: {
        [e0.variable]: "underline"
      },
      _focusVisible: {
        boxShadow: "outline"
      }
    }
  }, D5 = R5({
    link: _5
  }), I5 = L5({
    baseStyle: D5
  }), B5 = {
    lineHeight: "1.2",
    borderRadius: "md",
    fontWeight: "semibold",
    transitionProperty: "common",
    transitionDuration: "normal",
    _focusVisible: {
      boxShadow: "outline"
    },
    _disabled: {
      opacity: 0.4,
      cursor: "not-allowed",
      boxShadow: "none"
    },
    _hover: {
      _disabled: {
        bg: "initial"
      }
    }
  }, _A = (t) => {
    const { colorScheme: e, theme: n } = t;
    if (e === "gray")
      return {
        color: we("gray.800", "whiteAlpha.900")(t),
        _hover: {
          bg: we("gray.100", "whiteAlpha.200")(t)
        },
        _active: {
          bg: we("gray.200", "whiteAlpha.300")(t)
        }
      };
    const r = ll(`${e}.200`, 0.12)(n), i = ll(`${e}.200`, 0.24)(n);
    return {
      color: we(`${e}.600`, `${e}.200`)(t),
      bg: "transparent",
      _hover: {
        bg: we(`${e}.50`, r)(t)
      },
      _active: {
        bg: we(`${e}.100`, i)(t)
      }
    };
  }, N5 = (t) => {
    const { colorScheme: e } = t, n = we("gray.200", "whiteAlpha.300")(t);
    return {
      border: "1px solid",
      borderColor: e === "gray" ? n : "currentColor",
      ".chakra-button__group[data-attached][data-orientation=horizontal] > &:not(:last-of-type)": {
        marginEnd: "-1px"
      },
      ".chakra-button__group[data-attached][data-orientation=vertical] > &:not(:last-of-type)": {
        marginBottom: "-1px"
      },
      ...wn(_A, t)
    };
  }, $5 = {
    yellow: {
      bg: "yellow.400",
      color: "black",
      hoverBg: "yellow.500",
      activeBg: "yellow.600"
    },
    cyan: {
      bg: "cyan.400",
      color: "black",
      hoverBg: "cyan.500",
      activeBg: "cyan.600"
    }
  }, z5 = (t) => {
    const { colorScheme: e } = t;
    if (e === "gray") {
      const a = we("gray.100", "whiteAlpha.200")(t);
      return {
        bg: a,
        color: we("gray.800", "whiteAlpha.900")(t),
        _hover: {
          bg: we("gray.200", "whiteAlpha.300")(t),
          _disabled: {
            bg: a
          }
        },
        _active: {
          bg: we("gray.300", "whiteAlpha.400")(t)
        }
      };
    }
    const { bg: n = `${e}.500`, color: r = "white", hoverBg: i = `${e}.600`, activeBg: o = `${e}.700` } = $5[e] ?? {}, s = we(n, `${e}.200`)(t);
    return {
      bg: s,
      color: we(r, "gray.800")(t),
      _hover: {
        bg: we(i, `${e}.300`)(t),
        _disabled: {
          bg: s
        }
      },
      _active: {
        bg: we(o, `${e}.400`)(t)
      }
    };
  }, F5 = (t) => {
    const { colorScheme: e } = t;
    return {
      padding: 0,
      height: "auto",
      lineHeight: "normal",
      verticalAlign: "baseline",
      color: we(`${e}.500`, `${e}.200`)(t),
      _hover: {
        textDecoration: "underline",
        _disabled: {
          textDecoration: "none"
        }
      },
      _active: {
        color: we(`${e}.700`, `${e}.500`)(t)
      }
    };
  }, V5 = {
    bg: "none",
    color: "inherit",
    display: "inline",
    lineHeight: "inherit",
    m: "0",
    p: "0"
  }, W5 = {
    ghost: _A,
    outline: N5,
    solid: z5,
    link: F5,
    unstyled: V5
  }, H5 = {
    lg: {
      h: "12",
      minW: "12",
      fontSize: "lg",
      px: "6"
    },
    md: {
      h: "10",
      minW: "10",
      fontSize: "md",
      px: "4"
    },
    sm: {
      h: "8",
      minW: "8",
      fontSize: "sm",
      px: "3"
    },
    xs: {
      h: "6",
      minW: "6",
      fontSize: "xs",
      px: "2"
    }
  }, j5 = {
    baseStyle: B5,
    variants: W5,
    sizes: H5,
    defaultProps: {
      variant: "solid",
      size: "md",
      colorScheme: "gray"
    }
  }, { definePartsStyle: Ds, defineMultiStyleConfig: U5 } = it(kN.keys), ep = ke("card-bg"), qi = ke("card-padding"), DA = ke("card-shadow"), id = ke("card-radius"), IA = ke("card-border-width", "0"), BA = ke("card-border-color"), K5 = Ds({
    container: {
      [ep.variable]: "colors.chakra-body-bg",
      backgroundColor: ep.reference,
      boxShadow: DA.reference,
      borderRadius: id.reference,
      color: "chakra-body-text",
      borderWidth: IA.reference,
      borderColor: BA.reference
    },
    body: {
      padding: qi.reference,
      flex: "1 1 0%"
    },
    header: {
      padding: qi.reference
    },
    footer: {
      padding: qi.reference
    }
  }), q5 = {
    sm: Ds({
      container: {
        [id.variable]: "radii.base",
        [qi.variable]: "space.3"
      }
    }),
    md: Ds({
      container: {
        [id.variable]: "radii.md",
        [qi.variable]: "space.5"
      }
    }),
    lg: Ds({
      container: {
        [id.variable]: "radii.xl",
        [qi.variable]: "space.7"
      }
    })
  }, G5 = {
    elevated: Ds({
      container: {
        [DA.variable]: "shadows.base",
        _dark: {
          [ep.variable]: "colors.gray.700"
        }
      }
    }),
    outline: Ds({
      container: {
        [IA.variable]: "1px",
        [BA.variable]: "colors.chakra-border-color"
      }
    }),
    filled: Ds({
      container: {
        [ep.variable]: "colors.chakra-subtle-bg"
      }
    }),
    unstyled: {
      body: {
        [qi.variable]: 0
      },
      header: {
        [qi.variable]: 0
      },
      footer: {
        [qi.variable]: 0
      }
    }
  }, Y5 = U5({
    baseStyle: K5,
    variants: G5,
    sizes: q5,
    defaultProps: {
      variant: "elevated",
      size: "md"
    }
  }), { definePartsStyle: od, defineMultiStyleConfig: X5 } = it(rN.keys), Bc = ke("checkbox-size"), Q5 = (t) => {
    const { colorScheme: e } = t;
    return {
      w: Bc.reference,
      h: Bc.reference,
      transitionProperty: "box-shadow",
      transitionDuration: "normal",
      border: "2px solid",
      borderRadius: "sm",
      borderColor: "inherit",
      color: "white",
      _checked: {
        bg: we(`${e}.500`, `${e}.200`)(t),
        borderColor: we(`${e}.500`, `${e}.200`)(t),
        color: we("white", "gray.900")(t),
        _hover: {
          bg: we(`${e}.600`, `${e}.300`)(t),
          borderColor: we(`${e}.600`, `${e}.300`)(t)
        },
        _disabled: {
          borderColor: we("gray.200", "transparent")(t),
          bg: we("gray.200", "whiteAlpha.300")(t),
          color: we("gray.500", "whiteAlpha.500")(t)
        }
      },
      _indeterminate: {
        bg: we(`${e}.500`, `${e}.200`)(t),
        borderColor: we(`${e}.500`, `${e}.200`)(t),
        color: we("white", "gray.900")(t)
      },
      _disabled: {
        bg: we("gray.100", "whiteAlpha.100")(t),
        borderColor: we("gray.100", "transparent")(t)
      },
      _focusVisible: {
        boxShadow: "outline"
      },
      _invalid: {
        borderColor: we("red.500", "red.300")(t)
      }
    };
  }, J5 = {
    _disabled: {
      cursor: "not-allowed"
    }
  }, Z5 = {
    userSelect: "none",
    _disabled: {
      opacity: 0.4
    }
  }, e$ = {
    transitionProperty: "transform",
    transitionDuration: "normal"
  }, t$ = od((t) => ({
    icon: e$,
    container: J5,
    control: wn(Q5, t),
    label: Z5
  })), n$ = {
    sm: od({
      control: {
        [Bc.variable]: "sizes.3"
      },
      label: {
        fontSize: "sm"
      },
      icon: {
        fontSize: "3xs"
      }
    }),
    md: od({
      control: {
        [Bc.variable]: "sizes.4"
      },
      label: {
        fontSize: "md"
      },
      icon: {
        fontSize: "2xs"
      }
    }),
    lg: od({
      control: {
        [Bc.variable]: "sizes.5"
      },
      label: {
        fontSize: "lg"
      },
      icon: {
        fontSize: "2xs"
      }
    })
  }, tp = X5({
    baseStyle: t$,
    sizes: n$,
    defaultProps: {
      size: "md",
      colorScheme: "blue"
    }
  }), Nc = Nt("close-button-size"), Jl = Nt("close-button-bg"), r$ = {
    w: [
      Nc.reference
    ],
    h: [
      Nc.reference
    ],
    borderRadius: "md",
    transitionProperty: "common",
    transitionDuration: "normal",
    _disabled: {
      opacity: 0.4,
      cursor: "not-allowed",
      boxShadow: "none"
    },
    _hover: {
      [Jl.variable]: "colors.blackAlpha.100",
      _dark: {
        [Jl.variable]: "colors.whiteAlpha.100"
      }
    },
    _active: {
      [Jl.variable]: "colors.blackAlpha.200",
      _dark: {
        [Jl.variable]: "colors.whiteAlpha.200"
      }
    },
    _focusVisible: {
      boxShadow: "outline"
    },
    bg: Jl.reference
  }, i$ = {
    lg: {
      [Nc.variable]: "sizes.10",
      fontSize: "md"
    },
    md: {
      [Nc.variable]: "sizes.8",
      fontSize: "xs"
    },
    sm: {
      [Nc.variable]: "sizes.6",
      fontSize: "2xs"
    }
  }, o$ = {
    baseStyle: r$,
    sizes: i$,
    defaultProps: {
      size: "md"
    }
  }, { variants: s$, defaultProps: a$ } = Ic, l$ = {
    fontFamily: "mono",
    fontSize: "sm",
    px: "0.2em",
    borderRadius: "sm",
    bg: At.bg.reference,
    color: At.color.reference,
    boxShadow: At.shadow.reference
  }, c$ = {
    baseStyle: l$,
    variants: s$,
    defaultProps: a$
  }, u$ = {
    w: "100%",
    mx: "auto",
    maxW: "prose",
    px: "4"
  }, f$ = {
    baseStyle: u$
  }, h$ = {
    opacity: 0.6,
    borderColor: "inherit"
  }, d$ = {
    borderStyle: "solid"
  }, p$ = {
    borderStyle: "dashed"
  }, m$ = {
    solid: d$,
    dashed: p$
  }, g$ = {
    baseStyle: h$,
    variants: m$,
    defaultProps: {
      variant: "solid"
    }
  }, { definePartsStyle: dy, defineMultiStyleConfig: v$ } = it(iN.keys), t0 = ke("drawer-bg"), n0 = ke("drawer-box-shadow");
  function la(t) {
    return dy(t === "full" ? {
      dialog: {
        maxW: "100vw",
        h: "100vh"
      }
    } : {
      dialog: {
        maxW: t
      }
    });
  }
  const y$ = {
    bg: "blackAlpha.600",
    zIndex: "modal"
  }, b$ = {
    display: "flex",
    zIndex: "modal",
    justifyContent: "center"
  }, x$ = (t) => {
    const { isFullHeight: e } = t;
    return {
      ...e && {
        height: "100vh"
      },
      zIndex: "modal",
      maxH: "100vh",
      color: "inherit",
      [t0.variable]: "colors.white",
      [n0.variable]: "shadows.lg",
      _dark: {
        [t0.variable]: "colors.gray.700",
        [n0.variable]: "shadows.dark-lg"
      },
      bg: t0.reference,
      boxShadow: n0.reference
    };
  }, S$ = {
    px: "6",
    py: "4",
    fontSize: "xl",
    fontWeight: "semibold"
  }, w$ = {
    position: "absolute",
    top: "2",
    insetEnd: "3"
  }, k$ = {
    px: "6",
    py: "2",
    flex: "1",
    overflow: "auto"
  }, C$ = {
    px: "6",
    py: "4"
  }, T$ = dy((t) => ({
    overlay: y$,
    dialogContainer: b$,
    dialog: wn(x$, t),
    header: S$,
    closeButton: w$,
    body: k$,
    footer: C$
  })), M$ = {
    xs: la("xs"),
    sm: la("md"),
    md: la("lg"),
    lg: la("2xl"),
    xl: la("4xl"),
    full: la("full")
  }, A$ = v$({
    baseStyle: T$,
    sizes: M$,
    defaultProps: {
      size: "xs"
    }
  }), { definePartsStyle: E$, defineMultiStyleConfig: P$ } = it(oN.keys), O$ = {
    borderRadius: "md",
    py: "1",
    transitionProperty: "common",
    transitionDuration: "normal"
  }, L$ = {
    borderRadius: "md",
    py: "1",
    transitionProperty: "common",
    transitionDuration: "normal",
    width: "full",
    _focusVisible: {
      boxShadow: "outline"
    },
    _placeholder: {
      opacity: 0.6
    }
  }, R$ = {
    borderRadius: "md",
    py: "1",
    transitionProperty: "common",
    transitionDuration: "normal",
    width: "full",
    _focusVisible: {
      boxShadow: "outline"
    },
    _placeholder: {
      opacity: 0.6
    }
  }, _$ = E$({
    preview: O$,
    input: L$,
    textarea: R$
  }), D$ = P$({
    baseStyle: _$
  }), { definePartsStyle: I$, defineMultiStyleConfig: B$ } = it(sN.keys), Ha = ke("form-control-color"), N$ = {
    marginStart: "1",
    [Ha.variable]: "colors.red.500",
    _dark: {
      [Ha.variable]: "colors.red.300"
    },
    color: Ha.reference
  }, $$ = {
    mt: "2",
    [Ha.variable]: "colors.gray.600",
    _dark: {
      [Ha.variable]: "colors.whiteAlpha.600"
    },
    color: Ha.reference,
    lineHeight: "normal",
    fontSize: "sm"
  }, z$ = I$({
    container: {
      width: "100%",
      position: "relative"
    },
    requiredIndicator: N$,
    helperText: $$
  }), F$ = B$({
    baseStyle: z$
  }), { definePartsStyle: V$, defineMultiStyleConfig: W$ } = it(aN.keys), ja = ke("form-error-color"), H$ = {
    [ja.variable]: "colors.red.500",
    _dark: {
      [ja.variable]: "colors.red.300"
    },
    color: ja.reference,
    mt: "2",
    fontSize: "sm",
    lineHeight: "normal"
  }, j$ = {
    marginEnd: "0.5em",
    [ja.variable]: "colors.red.500",
    _dark: {
      [ja.variable]: "colors.red.300"
    },
    color: ja.reference
  }, U$ = V$({
    text: H$,
    icon: j$
  }), K$ = W$({
    baseStyle: U$
  }), q$ = {
    fontSize: "md",
    marginEnd: "3",
    mb: "2",
    fontWeight: "medium",
    transitionProperty: "common",
    transitionDuration: "normal",
    opacity: 1,
    _disabled: {
      opacity: 0.4
    }
  }, G$ = {
    baseStyle: q$
  }, Y$ = {
    fontFamily: "heading",
    fontWeight: "bold"
  }, X$ = {
    "4xl": {
      fontSize: [
        "6xl",
        null,
        "7xl"
      ],
      lineHeight: 1
    },
    "3xl": {
      fontSize: [
        "5xl",
        null,
        "6xl"
      ],
      lineHeight: 1
    },
    "2xl": {
      fontSize: [
        "4xl",
        null,
        "5xl"
      ],
      lineHeight: [
        1.2,
        null,
        1
      ]
    },
    xl: {
      fontSize: [
        "3xl",
        null,
        "4xl"
      ],
      lineHeight: [
        1.33,
        null,
        1.2
      ]
    },
    lg: {
      fontSize: [
        "2xl",
        null,
        "3xl"
      ],
      lineHeight: [
        1.33,
        null,
        1.2
      ]
    },
    md: {
      fontSize: "xl",
      lineHeight: 1.2
    },
    sm: {
      fontSize: "md",
      lineHeight: 1.2
    },
    xs: {
      fontSize: "sm",
      lineHeight: 1.2
    }
  }, Q$ = {
    baseStyle: Y$,
    sizes: X$,
    defaultProps: {
      size: "xl"
    }
  }, { definePartsStyle: Ui, defineMultiStyleConfig: J$ } = it(lN.keys), Ta = ke("input-height"), Ma = ke("input-font-size"), Aa = ke("input-padding"), Ea = ke("input-border-radius"), Z$ = Ui({
    addon: {
      height: Ta.reference,
      fontSize: Ma.reference,
      px: Aa.reference,
      borderRadius: Ea.reference
    },
    field: {
      width: "100%",
      height: Ta.reference,
      fontSize: Ma.reference,
      px: Aa.reference,
      borderRadius: Ea.reference,
      minWidth: 0,
      outline: 0,
      position: "relative",
      appearance: "none",
      transitionProperty: "common",
      transitionDuration: "normal",
      _disabled: {
        opacity: 0.4,
        cursor: "not-allowed"
      }
    }
  }), mo = {
    lg: {
      [Ma.variable]: "fontSizes.lg",
      [Aa.variable]: "space.4",
      [Ea.variable]: "radii.md",
      [Ta.variable]: "sizes.12"
    },
    md: {
      [Ma.variable]: "fontSizes.md",
      [Aa.variable]: "space.4",
      [Ea.variable]: "radii.md",
      [Ta.variable]: "sizes.10"
    },
    sm: {
      [Ma.variable]: "fontSizes.sm",
      [Aa.variable]: "space.3",
      [Ea.variable]: "radii.sm",
      [Ta.variable]: "sizes.8"
    },
    xs: {
      [Ma.variable]: "fontSizes.xs",
      [Aa.variable]: "space.2",
      [Ea.variable]: "radii.sm",
      [Ta.variable]: "sizes.6"
    }
  }, e3 = {
    lg: Ui({
      field: mo.lg,
      group: mo.lg
    }),
    md: Ui({
      field: mo.md,
      group: mo.md
    }),
    sm: Ui({
      field: mo.sm,
      group: mo.sm
    }),
    xs: Ui({
      field: mo.xs,
      group: mo.xs
    })
  };
  function Bb(t) {
    const { focusBorderColor: e, errorBorderColor: n } = t;
    return {
      focusBorderColor: e || we("blue.500", "blue.300")(t),
      errorBorderColor: n || we("red.500", "red.300")(t)
    };
  }
  const t3 = Ui((t) => {
    const { theme: e } = t, { focusBorderColor: n, errorBorderColor: r } = Bb(t);
    return {
      field: {
        border: "1px solid",
        borderColor: "inherit",
        bg: "inherit",
        _hover: {
          borderColor: we("gray.300", "whiteAlpha.400")(t)
        },
        _readOnly: {
          boxShadow: "none !important",
          userSelect: "all"
        },
        _invalid: {
          borderColor: xn(e, r),
          boxShadow: `0 0 0 1px ${xn(e, r)}`
        },
        _focusVisible: {
          zIndex: 1,
          borderColor: xn(e, n),
          boxShadow: `0 0 0 1px ${xn(e, n)}`
        }
      },
      addon: {
        border: "1px solid",
        borderColor: we("inherit", "whiteAlpha.50")(t),
        bg: we("gray.100", "whiteAlpha.300")(t)
      }
    };
  }), n3 = Ui((t) => {
    const { theme: e } = t, { focusBorderColor: n, errorBorderColor: r } = Bb(t);
    return {
      field: {
        border: "2px solid",
        borderColor: "transparent",
        bg: we("gray.100", "whiteAlpha.50")(t),
        _hover: {
          bg: we("gray.200", "whiteAlpha.100")(t)
        },
        _readOnly: {
          boxShadow: "none !important",
          userSelect: "all"
        },
        _invalid: {
          borderColor: xn(e, r)
        },
        _focusVisible: {
          bg: "transparent",
          borderColor: xn(e, n)
        }
      },
      addon: {
        border: "2px solid",
        borderColor: "transparent",
        bg: we("gray.100", "whiteAlpha.50")(t)
      }
    };
  }), r3 = Ui((t) => {
    const { theme: e } = t, { focusBorderColor: n, errorBorderColor: r } = Bb(t);
    return {
      field: {
        borderBottom: "1px solid",
        borderColor: "inherit",
        borderRadius: "0",
        px: "0",
        bg: "transparent",
        _readOnly: {
          boxShadow: "none !important",
          userSelect: "all"
        },
        _invalid: {
          borderColor: xn(e, r),
          boxShadow: `0px 1px 0px 0px ${xn(e, r)}`
        },
        _focusVisible: {
          borderColor: xn(e, n),
          boxShadow: `0px 1px 0px 0px ${xn(e, n)}`
        }
      },
      addon: {
        borderBottom: "2px solid",
        borderColor: "inherit",
        borderRadius: "0",
        px: "0",
        bg: "transparent"
      }
    };
  }), i3 = Ui({
    field: {
      bg: "transparent",
      px: "0",
      height: "auto"
    },
    addon: {
      bg: "transparent",
      px: "0",
      height: "auto"
    }
  }), o3 = {
    outline: t3,
    filled: n3,
    flushed: r3,
    unstyled: i3
  }, qe = J$({
    baseStyle: Z$,
    sizes: e3,
    variants: o3,
    defaultProps: {
      size: "md",
      variant: "outline"
    }
  }), r0 = ke("kbd-bg"), s3 = {
    [r0.variable]: "colors.gray.100",
    _dark: {
      [r0.variable]: "colors.whiteAlpha.100"
    },
    bg: r0.reference,
    borderRadius: "md",
    borderWidth: "1px",
    borderBottomWidth: "3px",
    fontSize: "0.8em",
    fontWeight: "bold",
    lineHeight: "normal",
    px: "0.4em",
    whiteSpace: "nowrap"
  }, a3 = {
    baseStyle: s3
  }, l3 = {
    transitionProperty: "common",
    transitionDuration: "fast",
    transitionTimingFunction: "ease-out",
    cursor: "pointer",
    textDecoration: "none",
    outline: "none",
    color: "inherit",
    _hover: {
      textDecoration: "underline"
    },
    _focusVisible: {
      boxShadow: "outline"
    }
  }, c3 = {
    baseStyle: l3
  }, { defineMultiStyleConfig: u3, definePartsStyle: f3 } = it(cN.keys), h3 = {
    marginEnd: "2",
    display: "inline",
    verticalAlign: "text-bottom"
  }, d3 = f3({
    icon: h3
  }), p3 = u3({
    baseStyle: d3
  }), { defineMultiStyleConfig: m3, definePartsStyle: g3 } = it(uN.keys), ci = ke("menu-bg"), i0 = ke("menu-shadow"), v3 = {
    [ci.variable]: "#fff",
    [i0.variable]: "shadows.sm",
    _dark: {
      [ci.variable]: "colors.gray.700",
      [i0.variable]: "shadows.dark-lg"
    },
    color: "inherit",
    minW: "3xs",
    py: "2",
    zIndex: "dropdown",
    borderRadius: "md",
    borderWidth: "1px",
    bg: ci.reference,
    boxShadow: i0.reference
  }, y3 = {
    py: "1.5",
    px: "3",
    transitionProperty: "background",
    transitionDuration: "ultra-fast",
    transitionTimingFunction: "ease-in",
    _focus: {
      [ci.variable]: "colors.gray.100",
      _dark: {
        [ci.variable]: "colors.whiteAlpha.100"
      }
    },
    _active: {
      [ci.variable]: "colors.gray.200",
      _dark: {
        [ci.variable]: "colors.whiteAlpha.200"
      }
    },
    _expanded: {
      [ci.variable]: "colors.gray.100",
      _dark: {
        [ci.variable]: "colors.whiteAlpha.100"
      }
    },
    _disabled: {
      opacity: 0.4,
      cursor: "not-allowed"
    },
    bg: ci.reference
  }, b3 = {
    mx: 4,
    my: 2,
    fontWeight: "semibold",
    fontSize: "sm"
  }, x3 = {
    display: "inline-flex",
    alignItems: "center",
    justifyContent: "center",
    flexShrink: 0
  }, S3 = {
    opacity: 0.6
  }, w3 = {
    border: 0,
    borderBottom: "1px solid",
    borderColor: "inherit",
    my: "2",
    opacity: 0.6
  }, k3 = {
    transitionProperty: "common",
    transitionDuration: "normal"
  }, C3 = g3({
    button: k3,
    list: v3,
    item: y3,
    groupTitle: b3,
    icon: x3,
    command: S3,
    divider: w3
  }), T3 = m3({
    baseStyle: C3
  }), { defineMultiStyleConfig: M3, definePartsStyle: py } = it(fN.keys), o0 = ke("modal-bg"), s0 = ke("modal-shadow"), A3 = {
    bg: "blackAlpha.600",
    zIndex: "modal"
  }, E3 = (t) => {
    const { isCentered: e, scrollBehavior: n } = t;
    return {
      display: "flex",
      zIndex: "modal",
      justifyContent: "center",
      alignItems: e ? "center" : "flex-start",
      overflow: n === "inside" ? "hidden" : "auto",
      overscrollBehaviorY: "none"
    };
  }, P3 = (t) => {
    const { isCentered: e, scrollBehavior: n } = t;
    return {
      borderRadius: "md",
      color: "inherit",
      my: e ? "auto" : "16",
      mx: e ? "auto" : void 0,
      zIndex: "modal",
      maxH: n === "inside" ? "calc(100% - 7.5rem)" : void 0,
      [o0.variable]: "colors.white",
      [s0.variable]: "shadows.lg",
      _dark: {
        [o0.variable]: "colors.gray.700",
        [s0.variable]: "shadows.dark-lg"
      },
      bg: o0.reference,
      boxShadow: s0.reference
    };
  }, O3 = {
    px: "6",
    py: "4",
    fontSize: "xl",
    fontWeight: "semibold"
  }, L3 = {
    position: "absolute",
    top: "2",
    insetEnd: "3"
  }, R3 = (t) => {
    const { scrollBehavior: e } = t;
    return {
      px: "6",
      py: "2",
      flex: "1",
      overflow: e === "inside" ? "auto" : void 0
    };
  }, _3 = {
    px: "6",
    py: "4"
  }, D3 = py((t) => ({
    overlay: A3,
    dialogContainer: wn(E3, t),
    dialog: wn(P3, t),
    header: O3,
    closeButton: L3,
    body: wn(R3, t),
    footer: _3
  }));
  function Lr(t) {
    return py(t === "full" ? {
      dialog: {
        maxW: "100vw",
        minH: "$100vh",
        my: "0",
        borderRadius: "0"
      }
    } : {
      dialog: {
        maxW: t
      }
    });
  }
  const I3 = {
    xs: Lr("xs"),
    sm: Lr("sm"),
    md: Lr("md"),
    lg: Lr("lg"),
    xl: Lr("xl"),
    "2xl": Lr("2xl"),
    "3xl": Lr("3xl"),
    "4xl": Lr("4xl"),
    "5xl": Lr("5xl"),
    "6xl": Lr("6xl"),
    full: Lr("full")
  }, B3 = M3({
    baseStyle: D3,
    sizes: I3,
    defaultProps: {
      size: "md"
    }
  }), NA = {
    letterSpacings: {
      tighter: "-0.05em",
      tight: "-0.025em",
      normal: "0",
      wide: "0.025em",
      wider: "0.05em",
      widest: "0.1em"
    },
    lineHeights: {
      normal: "normal",
      none: 1,
      shorter: 1.25,
      short: 1.375,
      base: 1.5,
      tall: 1.625,
      taller: "2",
      3: ".75rem",
      4: "1rem",
      5: "1.25rem",
      6: "1.5rem",
      7: "1.75rem",
      8: "2rem",
      9: "2.25rem",
      10: "2.5rem"
    },
    fontWeights: {
      hairline: 100,
      thin: 200,
      light: 300,
      normal: 400,
      medium: 500,
      semibold: 600,
      bold: 700,
      extrabold: 800,
      black: 900
    },
    fonts: {
      heading: '-apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol"',
      body: '-apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol"',
      mono: 'SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace'
    },
    fontSizes: {
      "3xs": "0.45rem",
      "2xs": "0.625rem",
      xs: "0.75rem",
      sm: "0.875rem",
      md: "1rem",
      lg: "1.125rem",
      xl: "1.25rem",
      "2xl": "1.5rem",
      "3xl": "1.875rem",
      "4xl": "2.25rem",
      "5xl": "3rem",
      "6xl": "3.75rem",
      "7xl": "4.5rem",
      "8xl": "6rem",
      "9xl": "8rem"
    }
  }, { defineMultiStyleConfig: N3, definePartsStyle: $A } = it(hN.keys), Nb = Nt("number-input-stepper-width"), zA = Nt("number-input-input-padding"), $3 = Fi(Nb).add("0.5rem").toString(), a0 = Nt("number-input-bg"), l0 = Nt("number-input-color"), c0 = Nt("number-input-border-color"), z3 = {
    [Nb.variable]: "sizes.6",
    [zA.variable]: $3
  }, F3 = (t) => {
    var _a3;
    return ((_a3 = wn(qe.baseStyle, t)) == null ? void 0 : _a3.field) ?? {};
  }, V3 = {
    width: Nb.reference
  }, W3 = {
    borderStart: "1px solid",
    borderStartColor: c0.reference,
    color: l0.reference,
    bg: a0.reference,
    [l0.variable]: "colors.chakra-body-text",
    [c0.variable]: "colors.chakra-border-color",
    _dark: {
      [l0.variable]: "colors.whiteAlpha.800",
      [c0.variable]: "colors.whiteAlpha.300"
    },
    _active: {
      [a0.variable]: "colors.gray.200",
      _dark: {
        [a0.variable]: "colors.whiteAlpha.300"
      }
    },
    _disabled: {
      opacity: 0.4,
      cursor: "not-allowed"
    }
  }, H3 = $A((t) => ({
    root: z3,
    field: wn(F3, t) ?? {},
    stepperGroup: V3,
    stepper: W3
  }));
  function sh(t) {
    var _a3, _b3;
    const e = (_a3 = qe.sizes) == null ? void 0 : _a3[t], n = {
      lg: "md",
      md: "md",
      sm: "sm",
      xs: "sm"
    }, r = ((_b3 = e.field) == null ? void 0 : _b3.fontSize) ?? "md", i = NA.fontSizes[r];
    return $A({
      field: {
        ...e.field,
        paddingInlineEnd: zA.reference,
        verticalAlign: "top"
      },
      stepper: {
        fontSize: Fi(i).multiply(0.75).toString(),
        _first: {
          borderTopEndRadius: n[t]
        },
        _last: {
          borderBottomEndRadius: n[t],
          mt: "-1px",
          borderTopWidth: 1
        }
      }
    });
  }
  const j3 = {
    xs: sh("xs"),
    sm: sh("sm"),
    md: sh("md"),
    lg: sh("lg")
  }, U3 = N3({
    baseStyle: H3,
    sizes: j3,
    variants: qe.variants,
    defaultProps: qe.defaultProps
  }), K3 = {
    ...(_a2 = qe.baseStyle) == null ? void 0 : _a2.field,
    textAlign: "center"
  }, q3 = {
    lg: {
      fontSize: "lg",
      w: 12,
      h: 12,
      borderRadius: "md"
    },
    md: {
      fontSize: "md",
      w: 10,
      h: 10,
      borderRadius: "md"
    },
    sm: {
      fontSize: "sm",
      w: 8,
      h: 8,
      borderRadius: "sm"
    },
    xs: {
      fontSize: "xs",
      w: 6,
      h: 6,
      borderRadius: "sm"
    }
  }, G3 = {
    outline: (t) => {
      var _a3, _b3;
      return ((_b3 = wn((_a3 = qe.variants) == null ? void 0 : _a3.outline, t)) == null ? void 0 : _b3.field) ?? {};
    },
    flushed: (t) => {
      var _a3, _b3;
      return ((_b3 = wn((_a3 = qe.variants) == null ? void 0 : _a3.flushed, t)) == null ? void 0 : _b3.field) ?? {};
    },
    filled: (t) => {
      var _a3, _b3;
      return ((_b3 = wn((_a3 = qe.variants) == null ? void 0 : _a3.filled, t)) == null ? void 0 : _b3.field) ?? {};
    },
    unstyled: ((_b2 = qe.variants) == null ? void 0 : _b2.unstyled.field) ?? {}
  }, Y3 = {
    baseStyle: K3,
    sizes: q3,
    variants: G3,
    defaultProps: qe.defaultProps
  }, { defineMultiStyleConfig: X3, definePartsStyle: Q3 } = it(dN.keys), ah = Nt("popper-bg"), J3 = Nt("popper-arrow-bg"), Hw = Nt("popper-arrow-shadow-color"), Z3 = {
    zIndex: "popover"
  }, ez = {
    [ah.variable]: "colors.white",
    bg: ah.reference,
    [J3.variable]: ah.reference,
    [Hw.variable]: "colors.gray.200",
    _dark: {
      [ah.variable]: "colors.gray.700",
      [Hw.variable]: "colors.whiteAlpha.300"
    },
    width: "xs",
    border: "1px solid",
    borderColor: "inherit",
    borderRadius: "md",
    boxShadow: "sm",
    zIndex: "inherit",
    _focusVisible: {
      outline: 0,
      boxShadow: "outline"
    }
  }, tz = {
    px: 3,
    py: 2,
    borderBottomWidth: "1px"
  }, nz = {
    px: 3,
    py: 2
  }, rz = {
    px: 3,
    py: 2,
    borderTopWidth: "1px"
  }, iz = {
    position: "absolute",
    borderRadius: "md",
    top: 1,
    insetEnd: 2,
    padding: 2
  }, oz = Q3({
    popper: Z3,
    content: ez,
    header: tz,
    body: nz,
    footer: rz,
    closeButton: iz
  }), sz = X3({
    baseStyle: oz
  }), { defineMultiStyleConfig: az, definePartsStyle: mc } = it(pN.keys), lz = (t) => {
    const { colorScheme: e, theme: n, isIndeterminate: r, hasStripe: i } = t, o = we($w(), $w("1rem", "rgba(0,0,0,0.1)"))(t), s = we(`${e}.500`, `${e}.200`)(t), a = `linear-gradient(
    to right,
    transparent 0%,
    ${xn(n, s)} 50%,
    transparent 100%
  )`;
    return {
      ...!r && i && o,
      ...r ? {
        bgImage: a
      } : {
        bgColor: s
      }
    };
  }, cz = {
    lineHeight: "1",
    fontSize: "0.25em",
    fontWeight: "bold",
    color: "white"
  }, uz = (t) => ({
    bg: we("gray.100", "whiteAlpha.300")(t)
  }), fz = (t) => ({
    transitionProperty: "common",
    transitionDuration: "slow",
    ...lz(t)
  }), hz = mc((t) => ({
    label: cz,
    filledTrack: fz(t),
    track: uz(t)
  })), dz = {
    xs: mc({
      track: {
        h: "1"
      }
    }),
    sm: mc({
      track: {
        h: "2"
      }
    }),
    md: mc({
      track: {
        h: "3"
      }
    }),
    lg: mc({
      track: {
        h: "4"
      }
    })
  }, pz = az({
    sizes: dz,
    baseStyle: hz,
    defaultProps: {
      size: "md",
      colorScheme: "blue"
    }
  }), { defineMultiStyleConfig: mz, definePartsStyle: sd } = it(mN.keys), gz = (t) => {
    var _a3;
    const e = (_a3 = wn(tp.baseStyle, t)) == null ? void 0 : _a3.control;
    return {
      ...e,
      borderRadius: "full",
      _checked: {
        ...e == null ? void 0 : e._checked,
        _before: {
          content: '""',
          display: "inline-block",
          pos: "relative",
          w: "50%",
          h: "50%",
          borderRadius: "50%",
          bg: "currentColor"
        }
      }
    };
  }, vz = sd((t) => {
    var _a3, _b3;
    return {
      label: (_a3 = tp.baseStyle) == null ? void 0 : _a3.call(tp, t).label,
      container: (_b3 = tp.baseStyle) == null ? void 0 : _b3.call(tp, t).container,
      control: gz(t)
    };
  }), yz = {
    md: sd({
      control: {
        w: "4",
        h: "4"
      },
      label: {
        fontSize: "md"
      }
    }),
    lg: sd({
      control: {
        w: "5",
        h: "5"
      },
      label: {
        fontSize: "lg"
      }
    }),
    sm: sd({
      control: {
        width: "3",
        height: "3"
      },
      label: {
        fontSize: "sm"
      }
    })
  }, bz = mz({
    baseStyle: vz,
    sizes: yz,
    defaultProps: {
      size: "md",
      colorScheme: "blue"
    }
  }), { defineMultiStyleConfig: xz, definePartsStyle: Sz } = it(gN.keys), lh = ke("select-bg"), wz = {
    ...(_c2 = qe.baseStyle) == null ? void 0 : _c2.field,
    appearance: "none",
    paddingBottom: "1px",
    lineHeight: "normal",
    bg: lh.reference,
    [lh.variable]: "colors.white",
    _dark: {
      [lh.variable]: "colors.gray.700"
    },
    "> option, > optgroup": {
      bg: lh.reference
    }
  }, kz = {
    width: "6",
    height: "100%",
    insetEnd: "2",
    position: "relative",
    color: "currentColor",
    fontSize: "xl",
    _disabled: {
      opacity: 0.5
    }
  }, Cz = Sz({
    field: wz,
    icon: kz
  }), ch = {
    paddingInlineEnd: "8"
  }, Tz = {
    lg: {
      ...(_d2 = qe.sizes) == null ? void 0 : _d2.lg,
      field: {
        ...(_e2 = qe.sizes) == null ? void 0 : _e2.lg.field,
        ...ch
      }
    },
    md: {
      ...(_f = qe.sizes) == null ? void 0 : _f.md,
      field: {
        ...(_g2 = qe.sizes) == null ? void 0 : _g2.md.field,
        ...ch
      }
    },
    sm: {
      ...(_h2 = qe.sizes) == null ? void 0 : _h2.sm,
      field: {
        ...(_i = qe.sizes) == null ? void 0 : _i.sm.field,
        ...ch
      }
    },
    xs: {
      ...(_j2 = qe.sizes) == null ? void 0 : _j2.xs,
      field: {
        ...(_k2 = qe.sizes) == null ? void 0 : _k2.xs.field,
        ...ch
      },
      icon: {
        insetEnd: "1"
      }
    }
  }, Mz = xz({
    baseStyle: Cz,
    sizes: Tz,
    variants: qe.variants,
    defaultProps: qe.defaultProps
  }), u0 = ke("skeleton-start-color"), f0 = ke("skeleton-end-color"), Az = {
    [u0.variable]: "colors.gray.100",
    [f0.variable]: "colors.gray.400",
    _dark: {
      [u0.variable]: "colors.gray.800",
      [f0.variable]: "colors.gray.600"
    },
    background: u0.reference,
    borderColor: f0.reference,
    opacity: 0.7,
    borderRadius: "sm"
  }, Ez = {
    baseStyle: Az
  }, h0 = ke("skip-link-bg"), Pz = {
    borderRadius: "md",
    fontWeight: "semibold",
    _focusVisible: {
      boxShadow: "outline",
      padding: "4",
      position: "fixed",
      top: "6",
      insetStart: "6",
      [h0.variable]: "colors.white",
      _dark: {
        [h0.variable]: "colors.gray.700"
      },
      bg: h0.reference
    }
  }, Oz = {
    baseStyle: Pz
  }, { defineMultiStyleConfig: Lz, definePartsStyle: cm } = it(vN.keys), js = ke("slider-thumb-size"), Su = ke("slider-track-size"), To = ke("slider-bg"), Rz = (t) => {
    const { orientation: e } = t;
    return {
      display: "inline-block",
      position: "relative",
      cursor: "pointer",
      _disabled: {
        opacity: 0.6,
        cursor: "default",
        pointerEvents: "none"
      },
      ...Db({
        orientation: e,
        vertical: {
          h: "100%",
          px: zi(js.reference).divide(2).toString()
        },
        horizontal: {
          w: "100%",
          py: zi(js.reference).divide(2).toString()
        }
      })
    };
  }, _z = (t) => ({
    ...Db({
      orientation: t.orientation,
      horizontal: {
        h: Su.reference
      },
      vertical: {
        w: Su.reference
      }
    }),
    overflow: "hidden",
    borderRadius: "sm",
    [To.variable]: "colors.gray.200",
    _dark: {
      [To.variable]: "colors.whiteAlpha.200"
    },
    _disabled: {
      [To.variable]: "colors.gray.300",
      _dark: {
        [To.variable]: "colors.whiteAlpha.300"
      }
    },
    bg: To.reference
  }), Dz = (t) => {
    const { orientation: e } = t;
    return {
      ...Db({
        orientation: e,
        vertical: {
          left: "50%"
        },
        horizontal: {
          top: "50%"
        }
      }),
      w: js.reference,
      h: js.reference,
      display: "flex",
      alignItems: "center",
      justifyContent: "center",
      position: "absolute",
      outline: 0,
      zIndex: 1,
      borderRadius: "full",
      bg: "white",
      boxShadow: "base",
      border: "1px solid",
      borderColor: "transparent",
      transitionProperty: "transform",
      transitionDuration: "normal",
      _focusVisible: {
        boxShadow: "outline"
      },
      _active: {
        "--slider-thumb-scale": "1.15"
      },
      _disabled: {
        bg: "gray.300"
      }
    };
  }, Iz = (t) => {
    const { colorScheme: e } = t;
    return {
      width: "inherit",
      height: "inherit",
      [To.variable]: `colors.${e}.500`,
      _dark: {
        [To.variable]: `colors.${e}.200`
      },
      bg: To.reference
    };
  }, Bz = cm((t) => ({
    container: Rz(t),
    track: _z(t),
    thumb: Dz(t),
    filledTrack: Iz(t)
  })), Nz = cm({
    container: {
      [js.variable]: "sizes.4",
      [Su.variable]: "sizes.1"
    }
  }), $z = cm({
    container: {
      [js.variable]: "sizes.3.5",
      [Su.variable]: "sizes.1"
    }
  }), zz = cm({
    container: {
      [js.variable]: "sizes.2.5",
      [Su.variable]: "sizes.0.5"
    }
  }), Fz = {
    lg: Nz,
    md: $z,
    sm: zz
  }, Vz = Lz({
    baseStyle: Bz,
    sizes: Fz,
    defaultProps: {
      size: "md",
      colorScheme: "blue"
    }
  }), Ss = Nt("spinner-size"), Wz = {
    width: [
      Ss.reference
    ],
    height: [
      Ss.reference
    ]
  }, Hz = {
    xs: {
      [Ss.variable]: "sizes.3"
    },
    sm: {
      [Ss.variable]: "sizes.4"
    },
    md: {
      [Ss.variable]: "sizes.6"
    },
    lg: {
      [Ss.variable]: "sizes.8"
    },
    xl: {
      [Ss.variable]: "sizes.12"
    }
  }, jz = {
    baseStyle: Wz,
    sizes: Hz,
    defaultProps: {
      size: "md"
    }
  }, { defineMultiStyleConfig: Uz, definePartsStyle: FA } = it(yN.keys), Kz = {
    fontWeight: "medium"
  }, qz = {
    opacity: 0.8,
    marginBottom: "2"
  }, Gz = {
    verticalAlign: "baseline",
    fontWeight: "semibold"
  }, Yz = {
    marginEnd: 1,
    w: "3.5",
    h: "3.5",
    verticalAlign: "middle"
  }, Xz = FA({
    container: {},
    label: Kz,
    helpText: qz,
    number: Gz,
    icon: Yz
  }), Qz = {
    md: FA({
      label: {
        fontSize: "sm"
      },
      helpText: {
        fontSize: "sm"
      },
      number: {
        fontSize: "2xl"
      }
    })
  }, Jz = Uz({
    baseStyle: Xz,
    sizes: Qz,
    defaultProps: {
      size: "md"
    }
  }), { defineMultiStyleConfig: Zz, definePartsStyle: gc } = it([
    "stepper",
    "step",
    "title",
    "description",
    "indicator",
    "separator",
    "icon",
    "number"
  ]), Vi = ke("stepper-indicator-size"), Pa = ke("stepper-icon-size"), Oa = ke("stepper-title-font-size"), vc = ke("stepper-description-font-size"), Zl = ke("stepper-accent-color"), e4 = gc(({ colorScheme: t }) => ({
    stepper: {
      display: "flex",
      justifyContent: "space-between",
      gap: "4",
      "&[data-orientation=vertical]": {
        flexDirection: "column",
        alignItems: "flex-start"
      },
      "&[data-orientation=horizontal]": {
        flexDirection: "row",
        alignItems: "center"
      },
      [Zl.variable]: `colors.${t}.500`,
      _dark: {
        [Zl.variable]: `colors.${t}.200`
      }
    },
    title: {
      fontSize: Oa.reference,
      fontWeight: "medium"
    },
    description: {
      fontSize: vc.reference,
      color: "chakra-subtle-text"
    },
    number: {
      fontSize: Oa.reference
    },
    step: {
      flexShrink: 0,
      position: "relative",
      display: "flex",
      gap: "2",
      "&[data-orientation=horizontal]": {
        alignItems: "center"
      },
      flex: "1",
      "&:last-of-type:not([data-stretch])": {
        flex: "initial"
      }
    },
    icon: {
      flexShrink: 0,
      width: Pa.reference,
      height: Pa.reference
    },
    indicator: {
      flexShrink: 0,
      borderRadius: "full",
      width: Vi.reference,
      height: Vi.reference,
      display: "flex",
      justifyContent: "center",
      alignItems: "center",
      "&[data-status=active]": {
        borderWidth: "2px",
        borderColor: Zl.reference
      },
      "&[data-status=complete]": {
        bg: Zl.reference,
        color: "chakra-inverse-text"
      },
      "&[data-status=incomplete]": {
        borderWidth: "2px"
      }
    },
    separator: {
      bg: "chakra-border-color",
      flex: "1",
      "&[data-status=complete]": {
        bg: Zl.reference
      },
      "&[data-orientation=horizontal]": {
        width: "100%",
        height: "2px",
        marginStart: "2"
      },
      "&[data-orientation=vertical]": {
        width: "2px",
        position: "absolute",
        height: "100%",
        maxHeight: `calc(100% - ${Vi.reference} - 8px)`,
        top: `calc(${Vi.reference} + 4px)`,
        insetStart: `calc(${Vi.reference} / 2 - 1px)`
      }
    }
  })), t4 = Zz({
    baseStyle: e4,
    sizes: {
      xs: gc({
        stepper: {
          [Vi.variable]: "sizes.4",
          [Pa.variable]: "sizes.3",
          [Oa.variable]: "fontSizes.xs",
          [vc.variable]: "fontSizes.xs"
        }
      }),
      sm: gc({
        stepper: {
          [Vi.variable]: "sizes.6",
          [Pa.variable]: "sizes.4",
          [Oa.variable]: "fontSizes.sm",
          [vc.variable]: "fontSizes.xs"
        }
      }),
      md: gc({
        stepper: {
          [Vi.variable]: "sizes.8",
          [Pa.variable]: "sizes.5",
          [Oa.variable]: "fontSizes.md",
          [vc.variable]: "fontSizes.sm"
        }
      }),
      lg: gc({
        stepper: {
          [Vi.variable]: "sizes.10",
          [Pa.variable]: "sizes.6",
          [Oa.variable]: "fontSizes.lg",
          [vc.variable]: "fontSizes.md"
        }
      })
    },
    defaultProps: {
      size: "md",
      colorScheme: "blue"
    }
  }), { defineMultiStyleConfig: n4, definePartsStyle: ad } = it(bN.keys), $c = Nt("switch-track-width"), Is = Nt("switch-track-height"), d0 = Nt("switch-track-diff"), r4 = Fi.subtract($c, Is), my = Nt("switch-thumb-x"), ec = Nt("switch-bg"), i4 = (t) => {
    const { colorScheme: e } = t;
    return {
      borderRadius: "full",
      p: "0.5",
      width: [
        $c.reference
      ],
      height: [
        Is.reference
      ],
      transitionProperty: "common",
      transitionDuration: "fast",
      [ec.variable]: "colors.gray.300",
      _dark: {
        [ec.variable]: "colors.whiteAlpha.400"
      },
      _focusVisible: {
        boxShadow: "outline"
      },
      _disabled: {
        opacity: 0.4,
        cursor: "not-allowed"
      },
      _checked: {
        [ec.variable]: `colors.${e}.500`,
        _dark: {
          [ec.variable]: `colors.${e}.200`
        }
      },
      bg: ec.reference
    };
  }, o4 = {
    bg: "white",
    transitionProperty: "transform",
    transitionDuration: "normal",
    borderRadius: "inherit",
    width: [
      Is.reference
    ],
    height: [
      Is.reference
    ],
    _checked: {
      transform: `translateX(${my.reference})`
    }
  }, s4 = ad((t) => ({
    container: {
      [d0.variable]: r4,
      [my.variable]: d0.reference,
      _rtl: {
        [my.variable]: Fi(d0).negate().toString()
      }
    },
    track: i4(t),
    thumb: o4
  })), a4 = {
    sm: ad({
      container: {
        [$c.variable]: "1.375rem",
        [Is.variable]: "sizes.3"
      }
    }),
    md: ad({
      container: {
        [$c.variable]: "1.875rem",
        [Is.variable]: "sizes.4"
      }
    }),
    lg: ad({
      container: {
        [$c.variable]: "2.875rem",
        [Is.variable]: "sizes.6"
      }
    })
  }, l4 = n4({
    baseStyle: s4,
    sizes: a4,
    defaultProps: {
      size: "md",
      colorScheme: "blue"
    }
  }), { defineMultiStyleConfig: c4, definePartsStyle: Ua } = it(xN.keys), u4 = Ua({
    table: {
      fontVariantNumeric: "lining-nums tabular-nums",
      borderCollapse: "collapse",
      width: "full"
    },
    th: {
      fontFamily: "heading",
      fontWeight: "bold",
      textTransform: "uppercase",
      letterSpacing: "wider",
      textAlign: "start"
    },
    td: {
      textAlign: "start"
    },
    caption: {
      mt: 4,
      fontFamily: "heading",
      textAlign: "center",
      fontWeight: "medium"
    }
  }), np = {
    "&[data-is-numeric=true]": {
      textAlign: "end"
    }
  }, f4 = Ua((t) => {
    const { colorScheme: e } = t;
    return {
      th: {
        color: we("gray.600", "gray.400")(t),
        borderBottom: "1px",
        borderColor: we(`${e}.100`, `${e}.700`)(t),
        ...np
      },
      td: {
        borderBottom: "1px",
        borderColor: we(`${e}.100`, `${e}.700`)(t),
        ...np
      },
      caption: {
        color: we("gray.600", "gray.100")(t)
      },
      tfoot: {
        tr: {
          "&:last-of-type": {
            th: {
              borderBottomWidth: 0
            }
          }
        }
      }
    };
  }), h4 = Ua((t) => {
    const { colorScheme: e } = t;
    return {
      th: {
        color: we("gray.600", "gray.400")(t),
        borderBottom: "1px",
        borderColor: we(`${e}.100`, `${e}.700`)(t),
        ...np
      },
      td: {
        borderBottom: "1px",
        borderColor: we(`${e}.100`, `${e}.700`)(t),
        ...np
      },
      caption: {
        color: we("gray.600", "gray.100")(t)
      },
      tbody: {
        tr: {
          "&:nth-of-type(odd)": {
            "th, td": {
              borderBottomWidth: "1px",
              borderColor: we(`${e}.100`, `${e}.700`)(t)
            },
            td: {
              background: we(`${e}.100`, `${e}.700`)(t)
            }
          }
        }
      },
      tfoot: {
        tr: {
          "&:last-of-type": {
            th: {
              borderBottomWidth: 0
            }
          }
        }
      }
    };
  }), d4 = {
    simple: f4,
    striped: h4,
    unstyled: {}
  }, p4 = {
    sm: Ua({
      th: {
        px: "4",
        py: "1",
        lineHeight: "4",
        fontSize: "xs"
      },
      td: {
        px: "4",
        py: "2",
        fontSize: "sm",
        lineHeight: "4"
      },
      caption: {
        px: "4",
        py: "2",
        fontSize: "xs"
      }
    }),
    md: Ua({
      th: {
        px: "6",
        py: "3",
        lineHeight: "4",
        fontSize: "xs"
      },
      td: {
        px: "6",
        py: "4",
        lineHeight: "5"
      },
      caption: {
        px: "6",
        py: "2",
        fontSize: "sm"
      }
    }),
    lg: Ua({
      th: {
        px: "8",
        py: "4",
        lineHeight: "5",
        fontSize: "sm"
      },
      td: {
        px: "8",
        py: "5",
        lineHeight: "6"
      },
      caption: {
        px: "6",
        py: "2",
        fontSize: "md"
      }
    })
  }, m4 = c4({
    baseStyle: u4,
    variants: d4,
    sizes: p4,
    defaultProps: {
      variant: "simple",
      size: "md",
      colorScheme: "gray"
    }
  }), Rn = ke("tabs-color"), Nr = ke("tabs-bg"), uh = ke("tabs-border-color"), { defineMultiStyleConfig: g4, definePartsStyle: ki } = it(SN.keys), v4 = (t) => {
    const { orientation: e } = t;
    return {
      display: e === "vertical" ? "flex" : "block"
    };
  }, y4 = (t) => {
    const { isFitted: e } = t;
    return {
      flex: e ? 1 : void 0,
      transitionProperty: "common",
      transitionDuration: "normal",
      _focusVisible: {
        zIndex: 1,
        boxShadow: "outline"
      },
      _disabled: {
        cursor: "not-allowed",
        opacity: 0.4
      }
    };
  }, b4 = (t) => {
    const { align: e = "start", orientation: n } = t;
    return {
      justifyContent: {
        end: "flex-end",
        center: "center",
        start: "flex-start"
      }[e],
      flexDirection: n === "vertical" ? "column" : "row"
    };
  }, x4 = {
    p: 4
  }, S4 = ki((t) => ({
    root: v4(t),
    tab: y4(t),
    tablist: b4(t),
    tabpanel: x4
  })), w4 = {
    sm: ki({
      tab: {
        py: 1,
        px: 4,
        fontSize: "sm"
      }
    }),
    md: ki({
      tab: {
        fontSize: "md",
        py: 2,
        px: 4
      }
    }),
    lg: ki({
      tab: {
        fontSize: "lg",
        py: 3,
        px: 4
      }
    })
  }, k4 = ki((t) => {
    const { colorScheme: e, orientation: n } = t, r = n === "vertical", i = r ? "borderStart" : "borderBottom", o = r ? "marginStart" : "marginBottom";
    return {
      tablist: {
        [i]: "2px solid",
        borderColor: "inherit"
      },
      tab: {
        [i]: "2px solid",
        borderColor: "transparent",
        [o]: "-2px",
        _selected: {
          [Rn.variable]: `colors.${e}.600`,
          _dark: {
            [Rn.variable]: `colors.${e}.300`
          },
          borderColor: "currentColor"
        },
        _active: {
          [Nr.variable]: "colors.gray.200",
          _dark: {
            [Nr.variable]: "colors.whiteAlpha.300"
          }
        },
        _disabled: {
          _active: {
            bg: "none"
          }
        },
        color: Rn.reference,
        bg: Nr.reference
      }
    };
  }), C4 = ki((t) => {
    const { colorScheme: e } = t;
    return {
      tab: {
        borderTopRadius: "md",
        border: "1px solid",
        borderColor: "transparent",
        mb: "-1px",
        [uh.variable]: "transparent",
        _selected: {
          [Rn.variable]: `colors.${e}.600`,
          [uh.variable]: "colors.white",
          _dark: {
            [Rn.variable]: `colors.${e}.300`,
            [uh.variable]: "colors.gray.800"
          },
          borderColor: "inherit",
          borderBottomColor: uh.reference
        },
        color: Rn.reference
      },
      tablist: {
        mb: "-1px",
        borderBottom: "1px solid",
        borderColor: "inherit"
      }
    };
  }), T4 = ki((t) => {
    const { colorScheme: e } = t;
    return {
      tab: {
        border: "1px solid",
        borderColor: "inherit",
        [Nr.variable]: "colors.gray.50",
        _dark: {
          [Nr.variable]: "colors.whiteAlpha.50"
        },
        mb: "-1px",
        _notLast: {
          marginEnd: "-1px"
        },
        _selected: {
          [Nr.variable]: "colors.white",
          [Rn.variable]: `colors.${e}.600`,
          _dark: {
            [Nr.variable]: "colors.gray.800",
            [Rn.variable]: `colors.${e}.300`
          },
          borderColor: "inherit",
          borderTopColor: "currentColor",
          borderBottomColor: "transparent"
        },
        color: Rn.reference,
        bg: Nr.reference
      },
      tablist: {
        mb: "-1px",
        borderBottom: "1px solid",
        borderColor: "inherit"
      }
    };
  }), M4 = ki((t) => {
    const { colorScheme: e, theme: n } = t;
    return {
      tab: {
        borderRadius: "full",
        fontWeight: "semibold",
        color: "gray.600",
        _selected: {
          color: xn(n, `${e}.700`),
          bg: xn(n, `${e}.100`)
        }
      }
    };
  }), A4 = ki((t) => {
    const { colorScheme: e } = t;
    return {
      tab: {
        borderRadius: "full",
        fontWeight: "semibold",
        [Rn.variable]: "colors.gray.600",
        _dark: {
          [Rn.variable]: "inherit"
        },
        _selected: {
          [Rn.variable]: "colors.white",
          [Nr.variable]: `colors.${e}.600`,
          _dark: {
            [Rn.variable]: "colors.gray.800",
            [Nr.variable]: `colors.${e}.300`
          }
        },
        color: Rn.reference,
        bg: Nr.reference
      }
    };
  }), E4 = ki({}), P4 = {
    line: k4,
    enclosed: C4,
    "enclosed-colored": T4,
    "soft-rounded": M4,
    "solid-rounded": A4,
    unstyled: E4
  }, O4 = g4({
    baseStyle: S4,
    sizes: w4,
    variants: P4,
    defaultProps: {
      size: "md",
      variant: "line",
      colorScheme: "blue"
    }
  }), { defineMultiStyleConfig: L4, definePartsStyle: Bs } = it(wN.keys), jw = ke("tag-bg"), Uw = ke("tag-color"), p0 = ke("tag-shadow"), ld = ke("tag-min-height"), cd = ke("tag-min-width"), ud = ke("tag-font-size"), fd = ke("tag-padding-inline"), R4 = {
    fontWeight: "medium",
    lineHeight: 1.2,
    outline: 0,
    [Uw.variable]: At.color.reference,
    [jw.variable]: At.bg.reference,
    [p0.variable]: At.shadow.reference,
    color: Uw.reference,
    bg: jw.reference,
    boxShadow: p0.reference,
    borderRadius: "md",
    minH: ld.reference,
    minW: cd.reference,
    fontSize: ud.reference,
    px: fd.reference,
    _focusVisible: {
      [p0.variable]: "shadows.outline"
    }
  }, _4 = {
    lineHeight: 1.2,
    overflow: "visible"
  }, D4 = {
    fontSize: "lg",
    w: "5",
    h: "5",
    transitionProperty: "common",
    transitionDuration: "normal",
    borderRadius: "full",
    marginStart: "1.5",
    marginEnd: "-1",
    opacity: 0.5,
    _disabled: {
      opacity: 0.4
    },
    _focusVisible: {
      boxShadow: "outline",
      bg: "rgba(0, 0, 0, 0.14)"
    },
    _hover: {
      opacity: 0.8
    },
    _active: {
      opacity: 1
    }
  }, I4 = Bs({
    container: R4,
    label: _4,
    closeButton: D4
  }), B4 = {
    sm: Bs({
      container: {
        [ld.variable]: "sizes.5",
        [cd.variable]: "sizes.5",
        [ud.variable]: "fontSizes.xs",
        [fd.variable]: "space.2"
      },
      closeButton: {
        marginEnd: "-2px",
        marginStart: "0.35rem"
      }
    }),
    md: Bs({
      container: {
        [ld.variable]: "sizes.6",
        [cd.variable]: "sizes.6",
        [ud.variable]: "fontSizes.sm",
        [fd.variable]: "space.2"
      }
    }),
    lg: Bs({
      container: {
        [ld.variable]: "sizes.8",
        [cd.variable]: "sizes.8",
        [ud.variable]: "fontSizes.md",
        [fd.variable]: "space.3"
      }
    })
  }, N4 = {
    subtle: Bs((t) => {
      var _a3;
      return {
        container: (_a3 = Ic.variants) == null ? void 0 : _a3.subtle(t)
      };
    }),
    solid: Bs((t) => {
      var _a3;
      return {
        container: (_a3 = Ic.variants) == null ? void 0 : _a3.solid(t)
      };
    }),
    outline: Bs((t) => {
      var _a3;
      return {
        container: (_a3 = Ic.variants) == null ? void 0 : _a3.outline(t)
      };
    })
  }, $4 = L4({
    variants: N4,
    baseStyle: I4,
    sizes: B4,
    defaultProps: {
      size: "md",
      variant: "subtle",
      colorScheme: "gray"
    }
  }), z4 = {
    ...(_l = qe.baseStyle) == null ? void 0 : _l.field,
    paddingY: "2",
    minHeight: "20",
    lineHeight: "short",
    verticalAlign: "top"
  }, F4 = {
    outline: (t) => {
      var _a3;
      return ((_a3 = qe.variants) == null ? void 0 : _a3.outline(t).field) ?? {};
    },
    flushed: (t) => {
      var _a3;
      return ((_a3 = qe.variants) == null ? void 0 : _a3.flushed(t).field) ?? {};
    },
    filled: (t) => {
      var _a3;
      return ((_a3 = qe.variants) == null ? void 0 : _a3.filled(t).field) ?? {};
    },
    unstyled: ((_m2 = qe.variants) == null ? void 0 : _m2.unstyled.field) ?? {}
  }, V4 = {
    xs: ((_n2 = qe.sizes) == null ? void 0 : _n2.xs.field) ?? {},
    sm: ((_o2 = qe.sizes) == null ? void 0 : _o2.sm.field) ?? {},
    md: ((_p2 = qe.sizes) == null ? void 0 : _p2.md.field) ?? {},
    lg: ((_q2 = qe.sizes) == null ? void 0 : _q2.lg.field) ?? {}
  }, W4 = {
    baseStyle: z4,
    sizes: V4,
    variants: F4,
    defaultProps: {
      size: "md",
      variant: "outline"
    }
  }, fh = Nt("tooltip-bg"), m0 = Nt("tooltip-fg"), H4 = Nt("popper-arrow-bg"), j4 = {
    bg: fh.reference,
    color: m0.reference,
    [fh.variable]: "colors.gray.700",
    [m0.variable]: "colors.whiteAlpha.900",
    _dark: {
      [fh.variable]: "colors.gray.300",
      [m0.variable]: "colors.gray.900"
    },
    [H4.variable]: fh.reference,
    px: "2",
    py: "0.5",
    borderRadius: "sm",
    fontWeight: "medium",
    fontSize: "sm",
    boxShadow: "md",
    maxW: "xs",
    zIndex: "tooltip"
  }, U4 = {
    baseStyle: j4
  }, K4 = {
    Accordion: LN,
    Alert: p5,
    Avatar: T5,
    Badge: Ic,
    Breadcrumb: I5,
    Button: j5,
    Checkbox: tp,
    CloseButton: o$,
    Code: c$,
    Container: f$,
    Divider: g$,
    Drawer: A$,
    Editable: D$,
    Form: F$,
    FormError: K$,
    FormLabel: G$,
    Heading: Q$,
    Input: qe,
    Kbd: a3,
    Link: c3,
    List: p3,
    Menu: T3,
    Modal: B3,
    NumberInput: U3,
    PinInput: Y3,
    Popover: sz,
    Progress: pz,
    Radio: bz,
    Select: Mz,
    Skeleton: Ez,
    SkipLink: Oz,
    Slider: Vz,
    Spinner: jz,
    Stat: Jz,
    Switch: l4,
    Table: m4,
    Tabs: O4,
    Tag: $4,
    Textarea: W4,
    Tooltip: U4,
    Card: Y5,
    Stepper: t4
  }, q4 = {
    none: 0,
    "1px": "1px solid",
    "2px": "2px solid",
    "4px": "4px solid",
    "8px": "8px solid"
  }, G4 = {
    base: "0em",
    sm: "30em",
    md: "48em",
    lg: "62em",
    xl: "80em",
    "2xl": "96em"
  }, Y4 = {
    transparent: "transparent",
    current: "currentColor",
    black: "#000000",
    white: "#FFFFFF",
    whiteAlpha: {
      50: "rgba(255, 255, 255, 0.04)",
      100: "rgba(255, 255, 255, 0.06)",
      200: "rgba(255, 255, 255, 0.08)",
      300: "rgba(255, 255, 255, 0.16)",
      400: "rgba(255, 255, 255, 0.24)",
      500: "rgba(255, 255, 255, 0.36)",
      600: "rgba(255, 255, 255, 0.48)",
      700: "rgba(255, 255, 255, 0.64)",
      800: "rgba(255, 255, 255, 0.80)",
      900: "rgba(255, 255, 255, 0.92)"
    },
    blackAlpha: {
      50: "rgba(0, 0, 0, 0.04)",
      100: "rgba(0, 0, 0, 0.06)",
      200: "rgba(0, 0, 0, 0.08)",
      300: "rgba(0, 0, 0, 0.16)",
      400: "rgba(0, 0, 0, 0.24)",
      500: "rgba(0, 0, 0, 0.36)",
      600: "rgba(0, 0, 0, 0.48)",
      700: "rgba(0, 0, 0, 0.64)",
      800: "rgba(0, 0, 0, 0.80)",
      900: "rgba(0, 0, 0, 0.92)"
    },
    gray: {
      50: "#F7FAFC",
      100: "#EDF2F7",
      200: "#E2E8F0",
      300: "#CBD5E0",
      400: "#A0AEC0",
      500: "#718096",
      600: "#4A5568",
      700: "#2D3748",
      800: "#1A202C",
      900: "#171923"
    },
    red: {
      50: "#FFF5F5",
      100: "#FED7D7",
      200: "#FEB2B2",
      300: "#FC8181",
      400: "#F56565",
      500: "#E53E3E",
      600: "#C53030",
      700: "#9B2C2C",
      800: "#822727",
      900: "#63171B"
    },
    orange: {
      50: "#FFFAF0",
      100: "#FEEBC8",
      200: "#FBD38D",
      300: "#F6AD55",
      400: "#ED8936",
      500: "#DD6B20",
      600: "#C05621",
      700: "#9C4221",
      800: "#7B341E",
      900: "#652B19"
    },
    yellow: {
      50: "#FFFFF0",
      100: "#FEFCBF",
      200: "#FAF089",
      300: "#F6E05E",
      400: "#ECC94B",
      500: "#D69E2E",
      600: "#B7791F",
      700: "#975A16",
      800: "#744210",
      900: "#5F370E"
    },
    green: {
      50: "#F0FFF4",
      100: "#C6F6D5",
      200: "#9AE6B4",
      300: "#68D391",
      400: "#48BB78",
      500: "#38A169",
      600: "#2F855A",
      700: "#276749",
      800: "#22543D",
      900: "#1C4532"
    },
    teal: {
      50: "#E6FFFA",
      100: "#B2F5EA",
      200: "#81E6D9",
      300: "#4FD1C5",
      400: "#38B2AC",
      500: "#319795",
      600: "#2C7A7B",
      700: "#285E61",
      800: "#234E52",
      900: "#1D4044"
    },
    blue: {
      50: "#ebf8ff",
      100: "#bee3f8",
      200: "#90cdf4",
      300: "#63b3ed",
      400: "#4299e1",
      500: "#3182ce",
      600: "#2b6cb0",
      700: "#2c5282",
      800: "#2a4365",
      900: "#1A365D"
    },
    cyan: {
      50: "#EDFDFD",
      100: "#C4F1F9",
      200: "#9DECF9",
      300: "#76E4F7",
      400: "#0BC5EA",
      500: "#00B5D8",
      600: "#00A3C4",
      700: "#0987A0",
      800: "#086F83",
      900: "#065666"
    },
    purple: {
      50: "#FAF5FF",
      100: "#E9D8FD",
      200: "#D6BCFA",
      300: "#B794F4",
      400: "#9F7AEA",
      500: "#805AD5",
      600: "#6B46C1",
      700: "#553C9A",
      800: "#44337A",
      900: "#322659"
    },
    pink: {
      50: "#FFF5F7",
      100: "#FED7E2",
      200: "#FBB6CE",
      300: "#F687B3",
      400: "#ED64A6",
      500: "#D53F8C",
      600: "#B83280",
      700: "#97266D",
      800: "#702459",
      900: "#521B41"
    }
  }, X4 = {
    none: "0",
    sm: "0.125rem",
    base: "0.25rem",
    md: "0.375rem",
    lg: "0.5rem",
    xl: "0.75rem",
    "2xl": "1rem",
    "3xl": "1.5rem",
    full: "9999px"
  }, Q4 = {
    xs: "0 0 0 1px rgba(0, 0, 0, 0.05)",
    sm: "0 1px 2px 0 rgba(0, 0, 0, 0.05)",
    base: "0 1px 3px 0 rgba(0, 0, 0, 0.1), 0 1px 2px 0 rgba(0, 0, 0, 0.06)",
    md: "0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06)",
    lg: "0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05)",
    xl: "0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04)",
    "2xl": "0 25px 50px -12px rgba(0, 0, 0, 0.25)",
    outline: "0 0 0 3px rgba(66, 153, 225, 0.6)",
    inner: "inset 0 2px 4px 0 rgba(0,0,0,0.06)",
    none: "none",
    "dark-lg": "rgba(0, 0, 0, 0.1) 0px 0px 0px 1px, rgba(0, 0, 0, 0.2) 0px 5px 10px, rgba(0, 0, 0, 0.4) 0px 15px 40px"
  }, J4 = {
    common: "background-color, border-color, color, fill, stroke, opacity, box-shadow, transform",
    colors: "background-color, border-color, color, fill, stroke",
    dimensions: "width, height",
    position: "left, right, top, bottom",
    background: "background-color, background-image, background-position"
  }, Z4 = {
    "ease-in": "cubic-bezier(0.4, 0, 1, 1)",
    "ease-out": "cubic-bezier(0, 0, 0.2, 1)",
    "ease-in-out": "cubic-bezier(0.4, 0, 0.2, 1)"
  }, eF = {
    "ultra-fast": "50ms",
    faster: "100ms",
    fast: "150ms",
    normal: "200ms",
    slow: "300ms",
    slower: "400ms",
    "ultra-slow": "500ms"
  }, tF = {
    property: J4,
    easing: Z4,
    duration: eF
  }, nF = {
    hide: -1,
    auto: "auto",
    base: 0,
    docked: 10,
    dropdown: 1e3,
    sticky: 1100,
    banner: 1200,
    overlay: 1300,
    modal: 1400,
    popover: 1500,
    skipLink: 1600,
    toast: 1700,
    tooltip: 1800
  }, rF = {
    none: 0,
    sm: "4px",
    base: "8px",
    md: "12px",
    lg: "16px",
    xl: "24px",
    "2xl": "40px",
    "3xl": "64px"
  }, VA = {
    breakpoints: G4,
    zIndices: nF,
    radii: X4,
    blur: rF,
    colors: Y4,
    ...NA,
    sizes: LA,
    shadows: Q4,
    space: OA,
    borders: q4,
    transition: tF
  }, WA = {
    colors: {
      "chakra-body-text": {
        _light: "gray.800",
        _dark: "whiteAlpha.900"
      },
      "chakra-body-bg": {
        _light: "white",
        _dark: "gray.800"
      },
      "chakra-border-color": {
        _light: "gray.200",
        _dark: "whiteAlpha.300"
      },
      "chakra-inverse-text": {
        _light: "white",
        _dark: "gray.800"
      },
      "chakra-subtle-bg": {
        _light: "gray.100",
        _dark: "gray.700"
      },
      "chakra-subtle-text": {
        _light: "gray.600",
        _dark: "gray.400"
      },
      "chakra-placeholder-color": {
        _light: "gray.500",
        _dark: "whiteAlpha.400"
      }
    }
  }, HA = {
    global: {
      body: {
        fontFamily: "body",
        color: "chakra-body-text",
        bg: "chakra-body-bg",
        transitionProperty: "background-color",
        transitionDuration: "normal",
        lineHeight: "base"
      },
      "*::placeholder": {
        color: "chakra-placeholder-color"
      },
      "*, *::before, &::after": {
        borderColor: "chakra-border-color"
      }
    }
  }, jA = "ltr", UA = {
    useSystemColorMode: false,
    initialColorMode: "light",
    cssVarPrefix: "chakra"
  }, iF = {
    semanticTokens: WA,
    direction: jA,
    ...VA,
    components: K4,
    styles: HA,
    config: UA
  };
  ({
    ...VA
  });
  var um = {
    exports: {}
  }, fm = {};
  var oF = z.exports, sF = Symbol.for("react.element"), aF = Symbol.for("react.fragment"), lF = Object.prototype.hasOwnProperty, cF = oF.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, uF = {
    key: true,
    ref: true,
    __self: true,
    __source: true
  };
  function KA(t, e, n) {
    var r, i = {}, o = null, s = null;
    n !== void 0 && (o = "" + n), e.key !== void 0 && (o = "" + e.key), e.ref !== void 0 && (s = e.ref);
    for (r in e)
      lF.call(e, r) && !uF.hasOwnProperty(r) && (i[r] = e[r]);
    if (t && t.defaultProps)
      for (r in e = t.defaultProps, e)
        i[r] === void 0 && (i[r] = e[r]);
    return {
      $$typeof: sF,
      type: t,
      key: o,
      ref: s,
      props: i,
      _owner: cF.current
    };
  }
  fm.Fragment = aF;
  fm.jsx = KA;
  fm.jsxs = KA;
  (function(t) {
    t.exports = fm;
  })(um);
  const rp = um.exports.Fragment, J = um.exports.jsx, Yn = um.exports.jsxs;
  var fF = false;
  function hF(t) {
    if (t.sheet)
      return t.sheet;
    for (var e = 0; e < document.styleSheets.length; e++)
      if (document.styleSheets[e].ownerNode === t)
        return document.styleSheets[e];
  }
  function dF(t) {
    var e = document.createElement("style");
    return e.setAttribute("data-emotion", t.key), t.nonce !== void 0 && e.setAttribute("nonce", t.nonce), e.appendChild(document.createTextNode("")), e.setAttribute("data-s", ""), e;
  }
  var pF = function() {
    function t(n) {
      var r = this;
      this._insertTag = function(i) {
        var o;
        r.tags.length === 0 ? r.insertionPoint ? o = r.insertionPoint.nextSibling : r.prepend ? o = r.container.firstChild : o = r.before : o = r.tags[r.tags.length - 1].nextSibling, r.container.insertBefore(i, o), r.tags.push(i);
      }, this.isSpeedy = n.speedy === void 0 ? !fF : n.speedy, this.tags = [], this.ctr = 0, this.nonce = n.nonce, this.key = n.key, this.container = n.container, this.prepend = n.prepend, this.insertionPoint = n.insertionPoint, this.before = null;
    }
    var e = t.prototype;
    return e.hydrate = function(r) {
      r.forEach(this._insertTag);
    }, e.insert = function(r) {
      this.ctr % (this.isSpeedy ? 65e3 : 1) === 0 && this._insertTag(dF(this));
      var i = this.tags[this.tags.length - 1];
      if (this.isSpeedy) {
        var o = hF(i);
        try {
          o.insertRule(r, o.cssRules.length);
        } catch {
        }
      } else
        i.appendChild(document.createTextNode(r));
      this.ctr++;
    }, e.flush = function() {
      this.tags.forEach(function(r) {
        var i;
        return (i = r.parentNode) == null ? void 0 : i.removeChild(r);
      }), this.tags = [], this.ctr = 0;
    }, t;
  }(), cn = "-ms-", ip = "-moz-", Ue = "-webkit-", qA = "comm", $b = "rule", zb = "decl", mF = "@import", GA = "@keyframes", gF = "@layer", vF = Math.abs, hm = String.fromCharCode, yF = Object.assign;
  function bF(t, e) {
    return Qt(t, 0) ^ 45 ? (((e << 2 ^ Qt(t, 0)) << 2 ^ Qt(t, 1)) << 2 ^ Qt(t, 2)) << 2 ^ Qt(t, 3) : 0;
  }
  function YA(t) {
    return t.trim();
  }
  function xF(t, e) {
    return (t = e.exec(t)) ? t[0] : t;
  }
  function Ke(t, e, n) {
    return t.replace(e, n);
  }
  function gy(t, e) {
    return t.indexOf(e);
  }
  function Qt(t, e) {
    return t.charCodeAt(e) | 0;
  }
  function wu(t, e, n) {
    return t.slice(e, n);
  }
  function ui(t) {
    return t.length;
  }
  function Fb(t) {
    return t.length;
  }
  function hh(t, e) {
    return e.push(t), t;
  }
  function SF(t, e) {
    return t.map(e).join("");
  }
  var dm = 1, ul = 1, XA = 0, Fn = 0, Pt = 0, Tl = "";
  function pm(t, e, n, r, i, o, s) {
    return {
      value: t,
      root: e,
      parent: n,
      type: r,
      props: i,
      children: o,
      line: dm,
      column: ul,
      length: s,
      return: ""
    };
  }
  function tc(t, e) {
    return yF(pm("", null, null, "", null, null, 0), t, {
      length: -t.length
    }, e);
  }
  function wF() {
    return Pt;
  }
  function kF() {
    return Pt = Fn > 0 ? Qt(Tl, --Fn) : 0, ul--, Pt === 10 && (ul = 1, dm--), Pt;
  }
  function Xn() {
    return Pt = Fn < XA ? Qt(Tl, Fn++) : 0, ul++, Pt === 10 && (ul = 1, dm++), Pt;
  }
  function Ci() {
    return Qt(Tl, Fn);
  }
  function hd() {
    return Fn;
  }
  function Zu(t, e) {
    return wu(Tl, t, e);
  }
  function ku(t) {
    switch (t) {
      case 0:
      case 9:
      case 10:
      case 13:
      case 32:
        return 5;
      case 33:
      case 43:
      case 44:
      case 47:
      case 62:
      case 64:
      case 126:
      case 59:
      case 123:
      case 125:
        return 4;
      case 58:
        return 3;
      case 34:
      case 39:
      case 40:
      case 91:
        return 2;
      case 41:
      case 93:
        return 1;
    }
    return 0;
  }
  function QA(t) {
    return dm = ul = 1, XA = ui(Tl = t), Fn = 0, [];
  }
  function JA(t) {
    return Tl = "", t;
  }
  function dd(t) {
    return YA(Zu(Fn - 1, vy(t === 91 ? t + 2 : t === 40 ? t + 1 : t)));
  }
  function CF(t) {
    for (; (Pt = Ci()) && Pt < 33; )
      Xn();
    return ku(t) > 2 || ku(Pt) > 3 ? "" : " ";
  }
  function TF(t, e) {
    for (; --e && Xn() && !(Pt < 48 || Pt > 102 || Pt > 57 && Pt < 65 || Pt > 70 && Pt < 97); )
      ;
    return Zu(t, hd() + (e < 6 && Ci() == 32 && Xn() == 32));
  }
  function vy(t) {
    for (; Xn(); )
      switch (Pt) {
        case t:
          return Fn;
        case 34:
        case 39:
          t !== 34 && t !== 39 && vy(Pt);
          break;
        case 40:
          t === 41 && vy(t);
          break;
        case 92:
          Xn();
          break;
      }
    return Fn;
  }
  function MF(t, e) {
    for (; Xn() && t + Pt !== 47 + 10; )
      if (t + Pt === 42 + 42 && Ci() === 47)
        break;
    return "/*" + Zu(e, Fn - 1) + "*" + hm(t === 47 ? t : Xn());
  }
  function AF(t) {
    for (; !ku(Ci()); )
      Xn();
    return Zu(t, Fn);
  }
  function EF(t) {
    return JA(pd("", null, null, null, [
      ""
    ], t = QA(t), 0, [
      0
    ], t));
  }
  function pd(t, e, n, r, i, o, s, a, l) {
    for (var c = 0, u = 0, h = s, p = 0, v = 0, y = 0, S = 1, T = 1, w = 1, k = 0, C = "", O = i, L = o, D = r, R = C; T; )
      switch (y = k, k = Xn()) {
        case 40:
          if (y != 108 && Qt(R, h - 1) == 58) {
            gy(R += Ke(dd(k), "&", "&\f"), "&\f") != -1 && (w = -1);
            break;
          }
        case 34:
        case 39:
        case 91:
          R += dd(k);
          break;
        case 9:
        case 10:
        case 13:
        case 32:
          R += CF(y);
          break;
        case 92:
          R += TF(hd() - 1, 7);
          continue;
        case 47:
          switch (Ci()) {
            case 42:
            case 47:
              hh(PF(MF(Xn(), hd()), e, n), l);
              break;
            default:
              R += "/";
          }
          break;
        case 123 * S:
          a[c++] = ui(R) * w;
        case 125 * S:
        case 59:
        case 0:
          switch (k) {
            case 0:
            case 125:
              T = 0;
            case 59 + u:
              w == -1 && (R = Ke(R, /\f/g, "")), v > 0 && ui(R) - h && hh(v > 32 ? qw(R + ";", r, n, h - 1) : qw(Ke(R, " ", "") + ";", r, n, h - 2), l);
              break;
            case 59:
              R += ";";
            default:
              if (hh(D = Kw(R, e, n, c, u, i, a, C, O = [], L = [], h), o), k === 123)
                if (u === 0)
                  pd(R, e, D, D, O, o, h, a, L);
                else
                  switch (p === 99 && Qt(R, 3) === 110 ? 100 : p) {
                    case 100:
                    case 108:
                    case 109:
                    case 115:
                      pd(t, D, D, r && hh(Kw(t, D, D, 0, 0, i, a, C, i, O = [], h), L), i, L, h, a, r ? O : L);
                      break;
                    default:
                      pd(R, D, D, D, [
                        ""
                      ], L, 0, a, L);
                  }
          }
          c = u = v = 0, S = w = 1, C = R = "", h = s;
          break;
        case 58:
          h = 1 + ui(R), v = y;
        default:
          if (S < 1) {
            if (k == 123)
              --S;
            else if (k == 125 && S++ == 0 && kF() == 125)
              continue;
          }
          switch (R += hm(k), k * S) {
            case 38:
              w = u > 0 ? 1 : (R += "\f", -1);
              break;
            case 44:
              a[c++] = (ui(R) - 1) * w, w = 1;
              break;
            case 64:
              Ci() === 45 && (R += dd(Xn())), p = Ci(), u = h = ui(C = R += AF(hd())), k++;
              break;
            case 45:
              y === 45 && ui(R) == 2 && (S = 0);
          }
      }
    return o;
  }
  function Kw(t, e, n, r, i, o, s, a, l, c, u) {
    for (var h = i - 1, p = i === 0 ? o : [
      ""
    ], v = Fb(p), y = 0, S = 0, T = 0; y < r; ++y)
      for (var w = 0, k = wu(t, h + 1, h = vF(S = s[y])), C = t; w < v; ++w)
        (C = YA(S > 0 ? p[w] + " " + k : Ke(k, /&\f/g, p[w]))) && (l[T++] = C);
    return pm(t, e, n, i === 0 ? $b : a, l, c, u);
  }
  function PF(t, e, n) {
    return pm(t, e, n, qA, hm(wF()), wu(t, 2, -2), 0);
  }
  function qw(t, e, n, r) {
    return pm(t, e, n, zb, wu(t, 0, r), wu(t, r + 1, -1), r);
  }
  function Ka(t, e) {
    for (var n = "", r = Fb(t), i = 0; i < r; i++)
      n += e(t[i], i, t, e) || "";
    return n;
  }
  function OF(t, e, n, r) {
    switch (t.type) {
      case gF:
        if (t.children.length)
          break;
      case mF:
      case zb:
        return t.return = t.return || t.value;
      case qA:
        return "";
      case GA:
        return t.return = t.value + "{" + Ka(t.children, r) + "}";
      case $b:
        t.value = t.props.join(",");
    }
    return ui(n = Ka(t.children, r)) ? t.return = t.value + "{" + n + "}" : "";
  }
  function LF(t) {
    var e = Fb(t);
    return function(n, r, i, o) {
      for (var s = "", a = 0; a < e; a++)
        s += t[a](n, r, i, o) || "";
      return s;
    };
  }
  function RF(t) {
    return function(e) {
      e.root || (e = e.return) && t(e);
    };
  }
  var Gw = function(e) {
    var n = /* @__PURE__ */ new WeakMap();
    return function(r) {
      if (n.has(r))
        return n.get(r);
      var i = e(r);
      return n.set(r, i), i;
    };
  };
  function ZA(t) {
    var e = /* @__PURE__ */ Object.create(null);
    return function(n) {
      return e[n] === void 0 && (e[n] = t(n)), e[n];
    };
  }
  var _F = function(e, n, r) {
    for (var i = 0, o = 0; i = o, o = Ci(), i === 38 && o === 12 && (n[r] = 1), !ku(o); )
      Xn();
    return Zu(e, Fn);
  }, DF = function(e, n) {
    var r = -1, i = 44;
    do
      switch (ku(i)) {
        case 0:
          i === 38 && Ci() === 12 && (n[r] = 1), e[r] += _F(Fn - 1, n, r);
          break;
        case 2:
          e[r] += dd(i);
          break;
        case 4:
          if (i === 44) {
            e[++r] = Ci() === 58 ? "&\f" : "", n[r] = e[r].length;
            break;
          }
        default:
          e[r] += hm(i);
      }
    while (i = Xn());
    return e;
  }, IF = function(e, n) {
    return JA(DF(QA(e), n));
  }, Yw = /* @__PURE__ */ new WeakMap(), BF = function(e) {
    if (!(e.type !== "rule" || !e.parent || e.length < 1)) {
      for (var n = e.value, r = e.parent, i = e.column === r.column && e.line === r.line; r.type !== "rule"; )
        if (r = r.parent, !r)
          return;
      if (!(e.props.length === 1 && n.charCodeAt(0) !== 58 && !Yw.get(r)) && !i) {
        Yw.set(e, true);
        for (var o = [], s = IF(n, o), a = r.props, l = 0, c = 0; l < s.length; l++)
          for (var u = 0; u < a.length; u++, c++)
            e.props[c] = o[l] ? s[l].replace(/&\f/g, a[u]) : a[u] + " " + s[l];
      }
    }
  }, NF = function(e) {
    if (e.type === "decl") {
      var n = e.value;
      n.charCodeAt(0) === 108 && n.charCodeAt(2) === 98 && (e.return = "", e.value = "");
    }
  };
  function eE(t, e) {
    switch (bF(t, e)) {
      case 5103:
        return Ue + "print-" + t + t;
      case 5737:
      case 4201:
      case 3177:
      case 3433:
      case 1641:
      case 4457:
      case 2921:
      case 5572:
      case 6356:
      case 5844:
      case 3191:
      case 6645:
      case 3005:
      case 6391:
      case 5879:
      case 5623:
      case 6135:
      case 4599:
      case 4855:
      case 4215:
      case 6389:
      case 5109:
      case 5365:
      case 5621:
      case 3829:
        return Ue + t + t;
      case 5349:
      case 4246:
      case 4810:
      case 6968:
      case 2756:
        return Ue + t + ip + t + cn + t + t;
      case 6828:
      case 4268:
        return Ue + t + cn + t + t;
      case 6165:
        return Ue + t + cn + "flex-" + t + t;
      case 5187:
        return Ue + t + Ke(t, /(\w+).+(:[^]+)/, Ue + "box-$1$2" + cn + "flex-$1$2") + t;
      case 5443:
        return Ue + t + cn + "flex-item-" + Ke(t, /flex-|-self/, "") + t;
      case 4675:
        return Ue + t + cn + "flex-line-pack" + Ke(t, /align-content|flex-|-self/, "") + t;
      case 5548:
        return Ue + t + cn + Ke(t, "shrink", "negative") + t;
      case 5292:
        return Ue + t + cn + Ke(t, "basis", "preferred-size") + t;
      case 6060:
        return Ue + "box-" + Ke(t, "-grow", "") + Ue + t + cn + Ke(t, "grow", "positive") + t;
      case 4554:
        return Ue + Ke(t, /([^-])(transform)/g, "$1" + Ue + "$2") + t;
      case 6187:
        return Ke(Ke(Ke(t, /(zoom-|grab)/, Ue + "$1"), /(image-set)/, Ue + "$1"), t, "") + t;
      case 5495:
      case 3959:
        return Ke(t, /(image-set\([^]*)/, Ue + "$1$`$1");
      case 4968:
        return Ke(Ke(t, /(.+:)(flex-)?(.*)/, Ue + "box-pack:$3" + cn + "flex-pack:$3"), /s.+-b[^;]+/, "justify") + Ue + t + t;
      case 4095:
      case 3583:
      case 4068:
      case 2532:
        return Ke(t, /(.+)-inline(.+)/, Ue + "$1$2") + t;
      case 8116:
      case 7059:
      case 5753:
      case 5535:
      case 5445:
      case 5701:
      case 4933:
      case 4677:
      case 5533:
      case 5789:
      case 5021:
      case 4765:
        if (ui(t) - 1 - e > 6)
          switch (Qt(t, e + 1)) {
            case 109:
              if (Qt(t, e + 4) !== 45)
                break;
            case 102:
              return Ke(t, /(.+:)(.+)-([^]+)/, "$1" + Ue + "$2-$3$1" + ip + (Qt(t, e + 3) == 108 ? "$3" : "$2-$3")) + t;
            case 115:
              return ~gy(t, "stretch") ? eE(Ke(t, "stretch", "fill-available"), e) + t : t;
          }
        break;
      case 4949:
        if (Qt(t, e + 1) !== 115)
          break;
      case 6444:
        switch (Qt(t, ui(t) - 3 - (~gy(t, "!important") && 10))) {
          case 107:
            return Ke(t, ":", ":" + Ue) + t;
          case 101:
            return Ke(t, /(.+:)([^;!]+)(;|!.+)?/, "$1" + Ue + (Qt(t, 14) === 45 ? "inline-" : "") + "box$3$1" + Ue + "$2$3$1" + cn + "$2box$3") + t;
        }
        break;
      case 5936:
        switch (Qt(t, e + 11)) {
          case 114:
            return Ue + t + cn + Ke(t, /[svh]\w+-[tblr]{2}/, "tb") + t;
          case 108:
            return Ue + t + cn + Ke(t, /[svh]\w+-[tblr]{2}/, "tb-rl") + t;
          case 45:
            return Ue + t + cn + Ke(t, /[svh]\w+-[tblr]{2}/, "lr") + t;
        }
        return Ue + t + cn + t + t;
    }
    return t;
  }
  var $F = function(e, n, r, i) {
    if (e.length > -1 && !e.return)
      switch (e.type) {
        case zb:
          e.return = eE(e.value, e.length);
          break;
        case GA:
          return Ka([
            tc(e, {
              value: Ke(e.value, "@", "@" + Ue)
            })
          ], i);
        case $b:
          if (e.length)
            return SF(e.props, function(o) {
              switch (xF(o, /(::plac\w+|:read-\w+)/)) {
                case ":read-only":
                case ":read-write":
                  return Ka([
                    tc(e, {
                      props: [
                        Ke(o, /:(read-\w+)/, ":" + ip + "$1")
                      ]
                    })
                  ], i);
                case "::placeholder":
                  return Ka([
                    tc(e, {
                      props: [
                        Ke(o, /:(plac\w+)/, ":" + Ue + "input-$1")
                      ]
                    }),
                    tc(e, {
                      props: [
                        Ke(o, /:(plac\w+)/, ":" + ip + "$1")
                      ]
                    }),
                    tc(e, {
                      props: [
                        Ke(o, /:(plac\w+)/, cn + "input-$1")
                      ]
                    })
                  ], i);
              }
              return "";
            });
      }
  }, zF = [
    $F
  ], FF = function(e) {
    var n = e.key;
    if (n === "css") {
      var r = document.querySelectorAll("style[data-emotion]:not([data-s])");
      Array.prototype.forEach.call(r, function(S) {
        var T = S.getAttribute("data-emotion");
        T.indexOf(" ") !== -1 && (document.head.appendChild(S), S.setAttribute("data-s", ""));
      });
    }
    var i = e.stylisPlugins || zF, o = {}, s, a = [];
    s = e.container || document.head, Array.prototype.forEach.call(document.querySelectorAll('style[data-emotion^="' + n + ' "]'), function(S) {
      for (var T = S.getAttribute("data-emotion").split(" "), w = 1; w < T.length; w++)
        o[T[w]] = true;
      a.push(S);
    });
    var l, c = [
      BF,
      NF
    ];
    {
      var u, h = [
        OF,
        RF(function(S) {
          u.insert(S);
        })
      ], p = LF(c.concat(i, h)), v = function(T) {
        return Ka(EF(T), p);
      };
      l = function(T, w, k, C) {
        u = k, v(T ? T + "{" + w.styles + "}" : w.styles), C && (y.inserted[w.name] = true);
      };
    }
    var y = {
      key: n,
      sheet: new pF({
        key: n,
        container: s,
        nonce: e.nonce,
        speedy: e.speedy,
        prepend: e.prepend,
        insertionPoint: e.insertionPoint
      }),
      nonce: e.nonce,
      inserted: o,
      registered: {},
      insert: l
    };
    return y.sheet.hydrate(a), y;
  };
  function Cu() {
    return Cu = Object.assign ? Object.assign.bind() : function(t) {
      for (var e = 1; e < arguments.length; e++) {
        var n = arguments[e];
        for (var r in n)
          ({}).hasOwnProperty.call(n, r) && (t[r] = n[r]);
      }
      return t;
    }, Cu.apply(null, arguments);
  }
  var tE = {
    exports: {}
  }, Xe = {};
  var Ut = typeof Symbol == "function" && Symbol.for, Vb = Ut ? Symbol.for("react.element") : 60103, Wb = Ut ? Symbol.for("react.portal") : 60106, mm = Ut ? Symbol.for("react.fragment") : 60107, gm = Ut ? Symbol.for("react.strict_mode") : 60108, vm = Ut ? Symbol.for("react.profiler") : 60114, ym = Ut ? Symbol.for("react.provider") : 60109, bm = Ut ? Symbol.for("react.context") : 60110, Hb = Ut ? Symbol.for("react.async_mode") : 60111, xm = Ut ? Symbol.for("react.concurrent_mode") : 60111, Sm = Ut ? Symbol.for("react.forward_ref") : 60112, wm = Ut ? Symbol.for("react.suspense") : 60113, VF = Ut ? Symbol.for("react.suspense_list") : 60120, km = Ut ? Symbol.for("react.memo") : 60115, Cm = Ut ? Symbol.for("react.lazy") : 60116, WF = Ut ? Symbol.for("react.block") : 60121, HF = Ut ? Symbol.for("react.fundamental") : 60117, jF = Ut ? Symbol.for("react.responder") : 60118, UF = Ut ? Symbol.for("react.scope") : 60119;
  function er(t) {
    if (typeof t == "object" && t !== null) {
      var e = t.$$typeof;
      switch (e) {
        case Vb:
          switch (t = t.type, t) {
            case Hb:
            case xm:
            case mm:
            case vm:
            case gm:
            case wm:
              return t;
            default:
              switch (t = t && t.$$typeof, t) {
                case bm:
                case Sm:
                case Cm:
                case km:
                case ym:
                  return t;
                default:
                  return e;
              }
          }
        case Wb:
          return e;
      }
    }
  }
  function nE(t) {
    return er(t) === xm;
  }
  Xe.AsyncMode = Hb;
  Xe.ConcurrentMode = xm;
  Xe.ContextConsumer = bm;
  Xe.ContextProvider = ym;
  Xe.Element = Vb;
  Xe.ForwardRef = Sm;
  Xe.Fragment = mm;
  Xe.Lazy = Cm;
  Xe.Memo = km;
  Xe.Portal = Wb;
  Xe.Profiler = vm;
  Xe.StrictMode = gm;
  Xe.Suspense = wm;
  Xe.isAsyncMode = function(t) {
    return nE(t) || er(t) === Hb;
  };
  Xe.isConcurrentMode = nE;
  Xe.isContextConsumer = function(t) {
    return er(t) === bm;
  };
  Xe.isContextProvider = function(t) {
    return er(t) === ym;
  };
  Xe.isElement = function(t) {
    return typeof t == "object" && t !== null && t.$$typeof === Vb;
  };
  Xe.isForwardRef = function(t) {
    return er(t) === Sm;
  };
  Xe.isFragment = function(t) {
    return er(t) === mm;
  };
  Xe.isLazy = function(t) {
    return er(t) === Cm;
  };
  Xe.isMemo = function(t) {
    return er(t) === km;
  };
  Xe.isPortal = function(t) {
    return er(t) === Wb;
  };
  Xe.isProfiler = function(t) {
    return er(t) === vm;
  };
  Xe.isStrictMode = function(t) {
    return er(t) === gm;
  };
  Xe.isSuspense = function(t) {
    return er(t) === wm;
  };
  Xe.isValidElementType = function(t) {
    return typeof t == "string" || typeof t == "function" || t === mm || t === xm || t === vm || t === gm || t === wm || t === VF || typeof t == "object" && t !== null && (t.$$typeof === Cm || t.$$typeof === km || t.$$typeof === ym || t.$$typeof === bm || t.$$typeof === Sm || t.$$typeof === HF || t.$$typeof === jF || t.$$typeof === UF || t.$$typeof === WF);
  };
  Xe.typeOf = er;
  (function(t) {
    t.exports = Xe;
  })(tE);
  var rE = tE.exports, KF = {
    $$typeof: true,
    render: true,
    defaultProps: true,
    displayName: true,
    propTypes: true
  }, qF = {
    $$typeof: true,
    compare: true,
    defaultProps: true,
    displayName: true,
    propTypes: true,
    type: true
  }, iE = {};
  iE[rE.ForwardRef] = KF;
  iE[rE.Memo] = qF;
  var GF = true;
  function oE(t, e, n) {
    var r = "";
    return n.split(" ").forEach(function(i) {
      t[i] !== void 0 ? e.push(t[i] + ";") : i && (r += i + " ");
    }), r;
  }
  var jb = function(e, n, r) {
    var i = e.key + "-" + n.name;
    (r === false || GF === false) && e.registered[i] === void 0 && (e.registered[i] = n.styles);
  }, Ub = function(e, n, r) {
    jb(e, n, r);
    var i = e.key + "-" + n.name;
    if (e.inserted[n.name] === void 0) {
      var o = n;
      do
        e.insert(n === o ? "." + i : "", o, e.sheet, true), o = o.next;
      while (o !== void 0);
    }
  };
  function YF(t) {
    for (var e = 0, n, r = 0, i = t.length; i >= 4; ++r, i -= 4)
      n = t.charCodeAt(r) & 255 | (t.charCodeAt(++r) & 255) << 8 | (t.charCodeAt(++r) & 255) << 16 | (t.charCodeAt(++r) & 255) << 24, n = (n & 65535) * 1540483477 + ((n >>> 16) * 59797 << 16), n ^= n >>> 24, e = (n & 65535) * 1540483477 + ((n >>> 16) * 59797 << 16) ^ (e & 65535) * 1540483477 + ((e >>> 16) * 59797 << 16);
    switch (i) {
      case 3:
        e ^= (t.charCodeAt(r + 2) & 255) << 16;
      case 2:
        e ^= (t.charCodeAt(r + 1) & 255) << 8;
      case 1:
        e ^= t.charCodeAt(r) & 255, e = (e & 65535) * 1540483477 + ((e >>> 16) * 59797 << 16);
    }
    return e ^= e >>> 13, e = (e & 65535) * 1540483477 + ((e >>> 16) * 59797 << 16), ((e ^ e >>> 15) >>> 0).toString(36);
  }
  var XF = {
    animationIterationCount: 1,
    aspectRatio: 1,
    borderImageOutset: 1,
    borderImageSlice: 1,
    borderImageWidth: 1,
    boxFlex: 1,
    boxFlexGroup: 1,
    boxOrdinalGroup: 1,
    columnCount: 1,
    columns: 1,
    flex: 1,
    flexGrow: 1,
    flexPositive: 1,
    flexShrink: 1,
    flexNegative: 1,
    flexOrder: 1,
    gridRow: 1,
    gridRowEnd: 1,
    gridRowSpan: 1,
    gridRowStart: 1,
    gridColumn: 1,
    gridColumnEnd: 1,
    gridColumnSpan: 1,
    gridColumnStart: 1,
    msGridRow: 1,
    msGridRowSpan: 1,
    msGridColumn: 1,
    msGridColumnSpan: 1,
    fontWeight: 1,
    lineHeight: 1,
    opacity: 1,
    order: 1,
    orphans: 1,
    scale: 1,
    tabSize: 1,
    widows: 1,
    zIndex: 1,
    zoom: 1,
    WebkitLineClamp: 1,
    fillOpacity: 1,
    floodOpacity: 1,
    stopOpacity: 1,
    strokeDasharray: 1,
    strokeDashoffset: 1,
    strokeMiterlimit: 1,
    strokeOpacity: 1,
    strokeWidth: 1
  }, QF = false, JF = /[A-Z]|^ms/g, ZF = /_EMO_([^_]+?)_([^]*?)_EMO_/g, sE = function(e) {
    return e.charCodeAt(1) === 45;
  }, Xw = function(e) {
    return e != null && typeof e != "boolean";
  }, g0 = ZA(function(t) {
    return sE(t) ? t : t.replace(JF, "-$&").toLowerCase();
  }), Qw = function(e, n) {
    switch (e) {
      case "animation":
      case "animationName":
        if (typeof n == "string")
          return n.replace(ZF, function(r, i, o) {
            return fi = {
              name: i,
              styles: o,
              next: fi
            }, i;
          });
    }
    return XF[e] !== 1 && !sE(e) && typeof n == "number" && n !== 0 ? n + "px" : n;
  }, eV = "Component selectors can only be used in conjunction with @emotion/babel-plugin, the swc Emotion plugin, or another Emotion-aware compiler transform.";
  function Tu(t, e, n) {
    if (n == null)
      return "";
    var r = n;
    if (r.__emotion_styles !== void 0)
      return r;
    switch (typeof n) {
      case "boolean":
        return "";
      case "object": {
        var i = n;
        if (i.anim === 1)
          return fi = {
            name: i.name,
            styles: i.styles,
            next: fi
          }, i.name;
        var o = n;
        if (o.styles !== void 0) {
          var s = o.next;
          if (s !== void 0)
            for (; s !== void 0; )
              fi = {
                name: s.name,
                styles: s.styles,
                next: fi
              }, s = s.next;
          var a = o.styles + ";";
          return a;
        }
        return tV(t, e, n);
      }
      case "function": {
        if (t !== void 0) {
          var l = fi, c = n(t);
          return fi = l, Tu(t, e, c);
        }
        break;
      }
    }
    var u = n;
    if (e == null)
      return u;
    var h = e[u];
    return h !== void 0 ? h : u;
  }
  function tV(t, e, n) {
    var r = "";
    if (Array.isArray(n))
      for (var i = 0; i < n.length; i++)
        r += Tu(t, e, n[i]) + ";";
    else
      for (var o in n) {
        var s = n[o];
        if (typeof s != "object") {
          var a = s;
          e != null && e[a] !== void 0 ? r += o + "{" + e[a] + "}" : Xw(a) && (r += g0(o) + ":" + Qw(o, a) + ";");
        } else {
          if (o === "NO_COMPONENT_SELECTOR" && QF)
            throw new Error(eV);
          if (Array.isArray(s) && typeof s[0] == "string" && (e == null || e[s[0]] === void 0))
            for (var l = 0; l < s.length; l++)
              Xw(s[l]) && (r += g0(o) + ":" + Qw(o, s[l]) + ";");
          else {
            var c = Tu(t, e, s);
            switch (o) {
              case "animation":
              case "animationName": {
                r += g0(o) + ":" + c + ";";
                break;
              }
              default:
                r += o + "{" + c + "}";
            }
          }
        }
      }
    return r;
  }
  var Jw = /label:\s*([^\s;{]+)\s*(;|$)/g, fi;
  function Tm(t, e, n) {
    if (t.length === 1 && typeof t[0] == "object" && t[0] !== null && t[0].styles !== void 0)
      return t[0];
    var r = true, i = "";
    fi = void 0;
    var o = t[0];
    if (o == null || o.raw === void 0)
      r = false, i += Tu(n, e, o);
    else {
      var s = o;
      i += s[0];
    }
    for (var a = 1; a < t.length; a++)
      if (i += Tu(n, e, t[a]), r) {
        var l = o;
        i += l[a];
      }
    Jw.lastIndex = 0;
    for (var c = "", u; (u = Jw.exec(i)) !== null; )
      c += "-" + u[1];
    var h = YF(i) + c;
    return {
      name: h,
      styles: i,
      next: fi
    };
  }
  var nV = function(e) {
    return e();
  }, aE = bS["useInsertionEffect"] ? bS["useInsertionEffect"] : false, lE = aE || nV, Zw = aE || z.exports.useLayoutEffect, rV = false, Kb = z.exports.createContext(typeof HTMLElement < "u" ? FF({
    key: "css"
  }) : null);
  Kb.Provider;
  var iV = function() {
    return z.exports.useContext(Kb);
  }, qb = function(e) {
    return z.exports.forwardRef(function(n, r) {
      var i = z.exports.useContext(Kb);
      return e(n, i, r);
    });
  }, fl = z.exports.createContext({}), oV = function(e, n) {
    if (typeof n == "function") {
      var r = n(e);
      return r;
    }
    return Cu({}, e, n);
  }, sV = Gw(function(t) {
    return Gw(function(e) {
      return oV(t, e);
    });
  }), aV = function(e) {
    var n = z.exports.useContext(fl);
    return e.theme !== n && (n = sV(n)(e.theme)), J(fl.Provider, {
      value: n,
      children: e.children
    });
  }, Gb = {}.hasOwnProperty, yy = "__EMOTION_TYPE_PLEASE_DO_NOT_USE__", lV = function(e, n) {
    var r = {};
    for (var i in n)
      Gb.call(n, i) && (r[i] = n[i]);
    return r[yy] = e, r;
  }, cV = function(e) {
    var n = e.cache, r = e.serialized, i = e.isStringTag;
    return jb(n, r, i), lE(function() {
      return Ub(n, r, i);
    }), null;
  }, uV = qb(function(t, e, n) {
    var r = t.css;
    typeof r == "string" && e.registered[r] !== void 0 && (r = e.registered[r]);
    var i = t[yy], o = [
      r
    ], s = "";
    typeof t.className == "string" ? s = oE(e.registered, o, t.className) : t.className != null && (s = t.className + " ");
    var a = Tm(o, void 0, z.exports.useContext(fl));
    s += e.key + "-" + a.name;
    var l = {};
    for (var c in t)
      Gb.call(t, c) && c !== "css" && c !== yy && !rV && (l[c] = t[c]);
    return l.className = s, n && (l.ref = n), Yn(rp, {
      children: [
        J(cV, {
          cache: e,
          serialized: a,
          isStringTag: typeof i == "string"
        }),
        J(i, {
          ...l
        })
      ]
    });
  }), fV = uV, ek = function(e, n) {
    var r = arguments;
    if (n == null || !Gb.call(n, "css"))
      return z.exports.createElement.apply(void 0, r);
    var i = r.length, o = new Array(i);
    o[0] = fV, o[1] = lV(e, n);
    for (var s = 2; s < i; s++)
      o[s] = r[s];
    return z.exports.createElement.apply(null, o);
  };
  (function(t) {
    var e;
    (function(n) {
    })(e || (e = t.JSX || (t.JSX = {})));
  })(ek || (ek = {}));
  var Mm = qb(function(t, e) {
    var n = t.styles, r = Tm([
      n
    ], void 0, z.exports.useContext(fl)), i = z.exports.useRef();
    return Zw(function() {
      var o = e.key + "-global", s = new e.sheet.constructor({
        key: o,
        nonce: e.sheet.nonce,
        container: e.sheet.container,
        speedy: e.sheet.isSpeedy
      }), a = false, l = document.querySelector('style[data-emotion="' + o + " " + r.name + '"]');
      return e.sheet.tags.length && (s.before = e.sheet.tags[0]), l !== null && (a = true, l.setAttribute("data-emotion", o), s.hydrate([
        l
      ])), i.current = [
        s,
        a
      ], function() {
        s.flush();
      };
    }, [
      e
    ]), Zw(function() {
      var o = i.current, s = o[0], a = o[1];
      if (a) {
        o[1] = false;
        return;
      }
      if (r.next !== void 0 && Ub(e, r.next, true), s.tags.length) {
        var l = s.tags[s.tags.length - 1].nextElementSibling;
        s.before = l, s.flush();
      }
      e.insert("", r, s, false);
    }, [
      e,
      r.name
    ]), null;
  });
  function hV() {
    for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++)
      e[n] = arguments[n];
    return Tm(e);
  }
  function dV() {
    var t = hV.apply(void 0, arguments), e = "animation-" + t.name;
    return {
      name: e,
      styles: "@keyframes " + e + "{" + t.styles + "}",
      anim: 1,
      toString: function() {
        return "_EMO_" + this.name + "_" + this.styles + "_EMO_";
      }
    };
  }
  const Yb = z.exports.createContext({});
  Yb.displayName = "ColorModeContext";
  function Xb() {
    const t = z.exports.useContext(Yb);
    if (t === void 0)
      throw new Error("useColorMode must be used within a ColorModeProvider");
    return t;
  }
  const dh = {
    light: "chakra-ui-light",
    dark: "chakra-ui-dark"
  };
  function pV(t = {}) {
    const { preventTransition: e = true, nonce: n } = t, r = {
      setDataset: (i) => {
        const o = e ? r.preventTransition() : void 0;
        document.documentElement.dataset.theme = i, document.documentElement.style.colorScheme = i, o == null ? void 0 : o();
      },
      setClassName(i) {
        document.body.classList.add(i ? dh.dark : dh.light), document.body.classList.remove(i ? dh.light : dh.dark);
      },
      query() {
        return window.matchMedia("(prefers-color-scheme: dark)");
      },
      getSystemTheme(i) {
        return r.query().matches ?? i === "dark" ? "dark" : "light";
      },
      addListener(i) {
        const o = r.query(), s = (a) => {
          i(a.matches ? "dark" : "light");
        };
        return typeof o.addListener == "function" ? o.addListener(s) : o.addEventListener("change", s), () => {
          typeof o.removeListener == "function" ? o.removeListener(s) : o.removeEventListener("change", s);
        };
      },
      preventTransition() {
        const i = document.createElement("style");
        return i.appendChild(document.createTextNode("*{-webkit-transition:none!important;-moz-transition:none!important;-o-transition:none!important;-ms-transition:none!important;transition:none!important}")), n !== void 0 && (i.nonce = n), document.head.appendChild(i), () => {
          window.getComputedStyle(document.body), requestAnimationFrame(() => {
            requestAnimationFrame(() => {
              document.head.removeChild(i);
            });
          });
        };
      }
    };
    return r;
  }
  const mV = "chakra-ui-color-mode";
  function gV(t) {
    return {
      ssr: false,
      type: "localStorage",
      get(e) {
        if (!(globalThis == null ? void 0 : globalThis.document))
          return e;
        let n;
        try {
          n = localStorage.getItem(t) || e;
        } catch {
        }
        return n || e;
      },
      set(e) {
        try {
          localStorage.setItem(t, e);
        } catch {
        }
      }
    };
  }
  const vV = gV(mV), tk = () => {
  }, yV = TI() ? z.exports.useLayoutEffect : z.exports.useEffect;
  function nk(t, e) {
    return t.type === "cookie" && t.ssr ? t.get(e) : e;
  }
  const cE = function(e) {
    const { value: n, children: r, options: { useSystemColorMode: i, initialColorMode: o, disableTransitionOnChange: s } = {}, colorModeManager: a = vV } = e, l = iV(), c = o === "dark" ? "dark" : "light", [u, h] = z.exports.useState(() => nk(a, c)), [p, v] = z.exports.useState(() => nk(a)), { getSystemTheme: y, setClassName: S, setDataset: T, addListener: w } = z.exports.useMemo(() => pV({
      preventTransition: s,
      nonce: l == null ? void 0 : l.nonce
    }), [
      s,
      l == null ? void 0 : l.nonce
    ]), k = o === "system" && !u ? p : u, C = z.exports.useCallback((D) => {
      const R = D === "system" ? y() : D;
      h(R), S(R === "dark"), T(R), a.set(R);
    }, [
      a,
      y,
      S,
      T
    ]);
    yV(() => {
      o === "system" && v(y());
    }, []), z.exports.useEffect(() => {
      const D = a.get();
      if (D) {
        C(D);
        return;
      }
      if (o === "system") {
        C("system");
        return;
      }
      C(c);
    }, [
      a,
      c,
      o,
      C
    ]);
    const O = z.exports.useCallback(() => {
      C(k === "dark" ? "light" : "dark");
    }, [
      k,
      C
    ]);
    z.exports.useEffect(() => {
      if (!!i)
        return w(C);
    }, [
      i,
      w,
      C
    ]);
    const L = z.exports.useMemo(() => ({
      colorMode: n ?? k,
      toggleColorMode: n ? tk : O,
      setColorMode: n ? tk : C,
      forced: n !== void 0
    }), [
      k,
      O,
      C,
      n
    ]);
    return J(Yb.Provider, {
      value: L,
      children: r
    });
  };
  cE.displayName = "ColorModeProvider";
  const uE = String.raw, fE = uE`
  :root,
  :host {
    --chakra-vh: 100vh;
  }

  @supports (height: -webkit-fill-available) {
    :root,
    :host {
      --chakra-vh: -webkit-fill-available;
    }
  }

  @supports (height: -moz-fill-available) {
    :root,
    :host {
      --chakra-vh: -moz-fill-available;
    }
  }

  @supports (height: 100dvh) {
    :root,
    :host {
      --chakra-vh: 100dvh;
    }
  }
`, bV = () => J(Mm, {
    styles: fE
  }), xV = ({ scope: t = "" }) => J(Mm, {
    styles: uE`
      html {
        line-height: 1.5;
        -webkit-text-size-adjust: 100%;
        font-family: system-ui, sans-serif;
        -webkit-font-smoothing: antialiased;
        text-rendering: optimizeLegibility;
        -moz-osx-font-smoothing: grayscale;
        touch-action: manipulation;
      }

      body {
        position: relative;
        min-height: 100%;
        margin: 0;
        font-feature-settings: "kern";
      }

      ${t} :where(*, *::before, *::after) {
        border-width: 0;
        border-style: solid;
        box-sizing: border-box;
        word-wrap: break-word;
      }

      main {
        display: block;
      }

      ${t} hr {
        border-top-width: 1px;
        box-sizing: content-box;
        height: 0;
        overflow: visible;
      }

      ${t} :where(pre, code, kbd,samp) {
        font-family: SFMono-Regular, Menlo, Monaco, Consolas, monospace;
        font-size: 1em;
      }

      ${t} a {
        background-color: transparent;
        color: inherit;
        text-decoration: inherit;
      }

      ${t} abbr[title] {
        border-bottom: none;
        text-decoration: underline;
        -webkit-text-decoration: underline dotted;
        text-decoration: underline dotted;
      }

      ${t} :where(b, strong) {
        font-weight: bold;
      }

      ${t} small {
        font-size: 80%;
      }

      ${t} :where(sub,sup) {
        font-size: 75%;
        line-height: 0;
        position: relative;
        vertical-align: baseline;
      }

      ${t} sub {
        bottom: -0.25em;
      }

      ${t} sup {
        top: -0.5em;
      }

      ${t} img {
        border-style: none;
      }

      ${t} :where(button, input, optgroup, select, textarea) {
        font-family: inherit;
        font-size: 100%;
        line-height: 1.15;
        margin: 0;
      }

      ${t} :where(button, input) {
        overflow: visible;
      }

      ${t} :where(button, select) {
        text-transform: none;
      }

      ${t} :where(
          button::-moz-focus-inner,
          [type="button"]::-moz-focus-inner,
          [type="reset"]::-moz-focus-inner,
          [type="submit"]::-moz-focus-inner
        ) {
        border-style: none;
        padding: 0;
      }

      ${t} fieldset {
        padding: 0.35em 0.75em 0.625em;
      }

      ${t} legend {
        box-sizing: border-box;
        color: inherit;
        display: table;
        max-width: 100%;
        padding: 0;
        white-space: normal;
      }

      ${t} progress {
        vertical-align: baseline;
      }

      ${t} textarea {
        overflow: auto;
      }

      ${t} :where([type="checkbox"], [type="radio"]) {
        box-sizing: border-box;
        padding: 0;
      }

      ${t} input[type="number"]::-webkit-inner-spin-button,
      ${t} input[type="number"]::-webkit-outer-spin-button {
        -webkit-appearance: none !important;
      }

      ${t} input[type="number"] {
        -moz-appearance: textfield;
      }

      ${t} input[type="search"] {
        -webkit-appearance: textfield;
        outline-offset: -2px;
      }

      ${t} input[type="search"]::-webkit-search-decoration {
        -webkit-appearance: none !important;
      }

      ${t} ::-webkit-file-upload-button {
        -webkit-appearance: button;
        font: inherit;
      }

      ${t} details {
        display: block;
      }

      ${t} summary {
        display: list-item;
      }

      template {
        display: none;
      }

      [hidden] {
        display: none !important;
      }

      ${t} :where(
          blockquote,
          dl,
          dd,
          h1,
          h2,
          h3,
          h4,
          h5,
          h6,
          hr,
          figure,
          p,
          pre
        ) {
        margin: 0;
      }

      ${t} button {
        background: transparent;
        padding: 0;
      }

      ${t} fieldset {
        margin: 0;
        padding: 0;
      }

      ${t} :where(ol, ul) {
        margin: 0;
        padding: 0;
      }

      ${t} textarea {
        resize: vertical;
      }

      ${t} :where(button, [role="button"]) {
        cursor: pointer;
      }

      ${t} button::-moz-focus-inner {
        border: 0 !important;
      }

      ${t} table {
        border-collapse: collapse;
      }

      ${t} :where(h1, h2, h3, h4, h5, h6) {
        font-size: inherit;
        font-weight: inherit;
      }

      ${t} :where(button, input, optgroup, select, textarea) {
        padding: 0;
        line-height: inherit;
        color: inherit;
      }

      ${t} :where(img, svg, video, canvas, audio, iframe, embed, object) {
        display: block;
      }

      ${t} :where(img, video) {
        max-width: 100%;
        height: auto;
      }

      [data-js-focus-visible]
        :focus:not([data-focus-visible-added]):not(
          [data-focus-visible-disabled]
        ) {
        outline: none;
        box-shadow: none;
      }

      ${t} select::-ms-expand {
        display: none;
      }

      ${fE}
    `
  });
  function SV(t) {
    const { cssVarsRoot: e, theme: n, children: r } = t, i = z.exports.useMemo(() => JB(n), [
      n
    ]);
    return Yn(aV, {
      theme: i,
      children: [
        J(wV, {
          root: e
        }),
        r
      ]
    });
  }
  function wV({ root: t = ":host, :root" }) {
    const e = [
      t,
      "[data-theme]"
    ].join(",");
    return J(Mm, {
      styles: (n) => ({
        [e]: n.__cssVars
      })
    });
  }
  Ei({
    name: "StylesContext",
    errorMessage: "useStyles: `styles` is undefined. Seems you forgot to wrap the components in `<StylesProvider />` "
  });
  function kV() {
    const { colorMode: t } = Xb();
    return J(Mm, {
      styles: (e) => {
        const n = SA(e, "styles.global"), r = vi(n, {
          theme: e,
          colorMode: t
        });
        return r ? MA(r)(e) : void 0;
      }
    });
  }
  const [CV, TV] = Ei({
    strict: false,
    name: "PortalManagerContext"
  });
  function hE(t) {
    const { children: e, zIndex: n } = t;
    return J(CV, {
      value: {
        zIndex: n
      },
      children: e
    });
  }
  hE.displayName = "PortalManager";
  const dE = z.exports.createContext({
    getDocument() {
      return document;
    },
    getWindow() {
      return window;
    }
  });
  dE.displayName = "EnvironmentContext";
  function pE(t) {
    const { children: e, environment: n, disabled: r } = t, i = z.exports.useRef(null), o = z.exports.useMemo(() => n || {
      getDocument: () => {
        var _a3;
        return ((_a3 = i.current) == null ? void 0 : _a3.ownerDocument) ?? document;
      },
      getWindow: () => {
        var _a3;
        return ((_a3 = i.current) == null ? void 0 : _a3.ownerDocument.defaultView) ?? window;
      }
    }, [
      n
    ]), s = !r || !n;
    return Yn(dE.Provider, {
      value: o,
      children: [
        e,
        s && J("span", {
          id: "__chakra_env",
          hidden: true,
          ref: i
        })
      ]
    });
  }
  pE.displayName = "EnvironmentProvider";
  const MV = (t) => {
    const { children: e, colorModeManager: n, portalZIndex: r, resetScope: i, resetCSS: o = true, theme: s = {}, environment: a, cssVarsRoot: l, disableEnvironment: c, disableGlobalStyle: u } = t, h = J(pE, {
      environment: a,
      disabled: c,
      children: e
    });
    return J(SV, {
      theme: s,
      cssVarsRoot: l,
      children: Yn(cE, {
        colorModeManager: n,
        options: s.config,
        children: [
          o ? J(xV, {
            scope: i
          }) : J(bV, {}),
          !u && J(kV, {}),
          r ? J(hE, {
            zIndex: r,
            children: h
          }) : h
        ]
      })
    });
  };
  var by = function(t, e) {
    return by = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function(n, r) {
      n.__proto__ = r;
    } || function(n, r) {
      for (var i in r)
        Object.prototype.hasOwnProperty.call(r, i) && (n[i] = r[i]);
    }, by(t, e);
  };
  function mE(t, e) {
    if (typeof e != "function" && e !== null)
      throw new TypeError("Class extends value " + String(e) + " is not a constructor or null");
    by(t, e);
    function n() {
      this.constructor = t;
    }
    t.prototype = e === null ? Object.create(e) : (n.prototype = e.prototype, new n());
  }
  var ie = function() {
    return ie = Object.assign || function(e) {
      for (var n, r = 1, i = arguments.length; r < i; r++) {
        n = arguments[r];
        for (var o in n)
          Object.prototype.hasOwnProperty.call(n, o) && (e[o] = n[o]);
      }
      return e;
    }, ie.apply(this, arguments);
  };
  function Tr(t, e) {
    var n = {};
    for (var r in t)
      Object.prototype.hasOwnProperty.call(t, r) && e.indexOf(r) < 0 && (n[r] = t[r]);
    if (t != null && typeof Object.getOwnPropertySymbols == "function")
      for (var i = 0, r = Object.getOwnPropertySymbols(t); i < r.length; i++)
        e.indexOf(r[i]) < 0 && Object.prototype.propertyIsEnumerable.call(t, r[i]) && (n[r[i]] = t[r[i]]);
    return n;
  }
  function AV(t) {
    var e = typeof Symbol == "function" && Symbol.iterator, n = e && t[e], r = 0;
    if (n)
      return n.call(t);
    if (t && typeof t.length == "number")
      return {
        next: function() {
          return t && r >= t.length && (t = void 0), {
            value: t && t[r++],
            done: !t
          };
        }
      };
    throw new TypeError(e ? "Object is not iterable." : "Symbol.iterator is not defined.");
  }
  function wt(t, e) {
    var n = typeof Symbol == "function" && t[Symbol.iterator];
    if (!n)
      return t;
    var r = n.call(t), i, o = [], s;
    try {
      for (; (e === void 0 || e-- > 0) && !(i = r.next()).done; )
        o.push(i.value);
    } catch (a) {
      s = {
        error: a
      };
    } finally {
      try {
        i && !i.done && (n = r.return) && n.call(r);
      } finally {
        if (s)
          throw s.error;
      }
    }
    return o;
  }
  function jr(t, e, n) {
    if (n || arguments.length === 2)
      for (var r = 0, i = e.length, o; r < i; r++)
        (o || !(r in e)) && (o || (o = Array.prototype.slice.call(e, 0, r)), o[r] = e[r]);
    return t.concat(o || Array.prototype.slice.call(e));
  }
  var EV = "production", Qb = typeof process > "u" || process.env === void 0 ? EV : "production", Bi = function(t) {
    return {
      isEnabled: function(e) {
        return t.some(function(n) {
          return !!e[n];
        });
      }
    };
  }, Mu = {
    measureLayout: Bi([
      "layout",
      "layoutId",
      "drag"
    ]),
    animation: Bi([
      "animate",
      "exit",
      "variants",
      "whileHover",
      "whileTap",
      "whileFocus",
      "whileDrag",
      "whileInView"
    ]),
    exit: Bi([
      "exit"
    ]),
    drag: Bi([
      "drag",
      "dragControls"
    ]),
    focus: Bi([
      "whileFocus"
    ]),
    hover: Bi([
      "whileHover",
      "onHoverStart",
      "onHoverEnd"
    ]),
    tap: Bi([
      "whileTap",
      "onTap",
      "onTapStart",
      "onTapCancel"
    ]),
    pan: Bi([
      "onPan",
      "onPanStart",
      "onPanSessionStart",
      "onPanEnd"
    ]),
    inView: Bi([
      "whileInView",
      "onViewportEnter",
      "onViewportLeave"
    ])
  };
  function PV(t) {
    for (var e in t)
      t[e] !== null && (e === "projectionNodeConstructor" ? Mu.projectionNodeConstructor = t[e] : Mu[e].Component = t[e]);
  }
  var OV = function() {
  }, op = function() {
  }, gE = z.exports.createContext({
    strict: false
  }), vE = Object.keys(Mu), LV = vE.length;
  function RV(t, e, n) {
    var r = [], i = z.exports.useContext(gE);
    if (!e)
      return null;
    Qb !== "production" && n && i.strict;
    for (var o = 0; o < LV; o++) {
      var s = vE[o], a = Mu[s], l = a.isEnabled, c = a.Component;
      l(t) && c && r.push(J(c, {
        ...ie({
          key: s
        }, t, {
          visualElement: e
        })
      }));
    }
    return r;
  }
  var Jb = z.exports.createContext({
    transformPagePoint: function(t) {
      return t;
    },
    isStatic: false,
    reducedMotion: "never"
  }), Am = z.exports.createContext({});
  function _V() {
    return z.exports.useContext(Am).visualElement;
  }
  var Ml = z.exports.createContext(null), Al = typeof document < "u", sp = Al ? z.exports.useLayoutEffect : z.exports.useEffect, xy = {
    current: null
  }, yE = false;
  function DV() {
    if (yE = true, !!Al)
      if (window.matchMedia) {
        var t = window.matchMedia("(prefers-reduced-motion)"), e = function() {
          return xy.current = t.matches;
        };
        t.addListener(e), e();
      } else
        xy.current = false;
  }
  function IV() {
    !yE && DV();
    var t = wt(z.exports.useState(xy.current), 1), e = t[0];
    return e;
  }
  function BV() {
    var t = IV(), e = z.exports.useContext(Jb).reducedMotion;
    return e === "never" ? false : e === "always" ? true : t;
  }
  function NV(t, e, n, r) {
    var i = z.exports.useContext(gE), o = _V(), s = z.exports.useContext(Ml), a = BV(), l = z.exports.useRef(void 0);
    r || (r = i.renderer), !l.current && r && (l.current = r(t, {
      visualState: e,
      parent: o,
      props: n,
      presenceId: s == null ? void 0 : s.id,
      blockInitialAnimation: (s == null ? void 0 : s.initial) === false,
      shouldReduceMotion: a
    }));
    var c = l.current;
    return sp(function() {
      c == null ? void 0 : c.syncRender();
    }), z.exports.useEffect(function() {
      var u;
      (u = c == null ? void 0 : c.animationState) === null || u === void 0 || u.animateChanges();
    }), sp(function() {
      return function() {
        return c == null ? void 0 : c.notifyUnmount();
      };
    }, []), c;
  }
  function La(t) {
    return typeof t == "object" && Object.prototype.hasOwnProperty.call(t, "current");
  }
  function $V(t, e, n) {
    return z.exports.useCallback(function(r) {
      var i;
      r && ((i = t.mount) === null || i === void 0 || i.call(t, r)), e && (r ? e.mount(r) : e.unmount()), n && (typeof n == "function" ? n(r) : La(n) && (n.current = r));
    }, [
      e
    ]);
  }
  function bE(t) {
    return Array.isArray(t);
  }
  function Ir(t) {
    return typeof t == "string" || bE(t);
  }
  function zV(t) {
    var e = {};
    return t.forEachValue(function(n, r) {
      return e[r] = n.get();
    }), e;
  }
  function FV(t) {
    var e = {};
    return t.forEachValue(function(n, r) {
      return e[r] = n.getVelocity();
    }), e;
  }
  function xE(t, e, n, r, i) {
    var o;
    return r === void 0 && (r = {}), i === void 0 && (i = {}), typeof e == "function" && (e = e(n ?? t.custom, r, i)), typeof e == "string" && (e = (o = t.variants) === null || o === void 0 ? void 0 : o[e]), typeof e == "function" && (e = e(n ?? t.custom, r, i)), e;
  }
  function Em(t, e, n) {
    var r = t.getProps();
    return xE(r, e, n ?? r.custom, zV(t), FV(t));
  }
  function Pm(t) {
    var e;
    return typeof ((e = t.animate) === null || e === void 0 ? void 0 : e.start) == "function" || Ir(t.initial) || Ir(t.animate) || Ir(t.whileHover) || Ir(t.whileDrag) || Ir(t.whileTap) || Ir(t.whileFocus) || Ir(t.exit);
  }
  function SE(t) {
    return Boolean(Pm(t) || t.variants);
  }
  function VV(t, e) {
    if (Pm(t)) {
      var n = t.initial, r = t.animate;
      return {
        initial: n === false || Ir(n) ? n : void 0,
        animate: Ir(r) ? r : void 0
      };
    }
    return t.inherit !== false ? e : {};
  }
  function WV(t) {
    var e = VV(t, z.exports.useContext(Am)), n = e.initial, r = e.animate;
    return z.exports.useMemo(function() {
      return {
        initial: n,
        animate: r
      };
    }, [
      rk(n),
      rk(r)
    ]);
  }
  function rk(t) {
    return Array.isArray(t) ? t.join(" ") : t;
  }
  function ef(t) {
    var e = z.exports.useRef(null);
    return e.current === null && (e.current = t()), e.current;
  }
  var zc = {
    hasAnimatedSinceResize: true,
    hasEverUpdated: false
  }, HV = 1;
  function jV() {
    return ef(function() {
      if (zc.hasEverUpdated)
        return HV++;
    });
  }
  var Zb = z.exports.createContext({}), wE = z.exports.createContext({});
  function UV(t, e, n, r) {
    var i, o = e.layoutId, s = e.layout, a = e.drag, l = e.dragConstraints, c = e.layoutScroll, u = z.exports.useContext(wE);
    !r || !n || (n == null ? void 0 : n.projection) || (n.projection = new r(t, n.getLatestValues(), (i = n.parent) === null || i === void 0 ? void 0 : i.projection), n.projection.setOptions({
      layoutId: o,
      layout: s,
      alwaysMeasureLayout: Boolean(a) || l && La(l),
      visualElement: n,
      scheduleRender: function() {
        return n.scheduleRender();
      },
      animationType: typeof s == "string" ? s : "both",
      initialPromotionConfig: u,
      layoutScroll: c
    }));
  }
  var KV = function(t) {
    mE(e, t);
    function e() {
      return t !== null && t.apply(this, arguments) || this;
    }
    return e.prototype.getSnapshotBeforeUpdate = function() {
      return this.updateProps(), null;
    }, e.prototype.componentDidUpdate = function() {
    }, e.prototype.updateProps = function() {
      var n = this.props, r = n.visualElement, i = n.props;
      r && r.setProps(i);
    }, e.prototype.render = function() {
      return this.props.children;
    }, e;
  }(Wp.Component);
  function qV(t) {
    var e = t.preloadedFeatures, n = t.createVisualElement, r = t.projectionNodeConstructor, i = t.useRender, o = t.useVisualState, s = t.Component;
    e && PV(e);
    function a(l, c) {
      var u = GV(l);
      l = ie(ie({}, l), {
        layoutId: u
      });
      var h = z.exports.useContext(Jb), p = null, v = WV(l), y = h.isStatic ? void 0 : jV(), S = o(l, h.isStatic);
      return !h.isStatic && Al && (v.visualElement = NV(s, S, ie(ie({}, h), l), n), UV(y, l, v.visualElement, r || Mu.projectionNodeConstructor), p = RV(l, v.visualElement, e)), Yn(KV, {
        visualElement: v.visualElement,
        props: ie(ie({}, h), l),
        children: [
          p,
          J(Am.Provider, {
            value: v,
            children: i(s, l, y, $V(S, v.visualElement, c), S, h.isStatic, v.visualElement)
          })
        ]
      });
    }
    return z.exports.forwardRef(a);
  }
  function GV(t) {
    var e, n = t.layoutId, r = (e = z.exports.useContext(Zb)) === null || e === void 0 ? void 0 : e.id;
    return r && n !== void 0 ? r + "-" + n : n;
  }
  function YV(t) {
    function e(r, i) {
      return i === void 0 && (i = {}), qV(t(r, i));
    }
    if (typeof Proxy > "u")
      return e;
    var n = /* @__PURE__ */ new Map();
    return new Proxy(e, {
      get: function(r, i) {
        return n.has(i) || n.set(i, e(i)), n.get(i);
      }
    });
  }
  var XV = [
    "animate",
    "circle",
    "defs",
    "desc",
    "ellipse",
    "g",
    "image",
    "line",
    "filter",
    "marker",
    "mask",
    "metadata",
    "path",
    "pattern",
    "polygon",
    "polyline",
    "rect",
    "stop",
    "svg",
    "switch",
    "symbol",
    "text",
    "tspan",
    "use",
    "view"
  ];
  function ex(t) {
    return typeof t != "string" || t.includes("-") ? false : !!(XV.indexOf(t) > -1 || /[A-Z]/.test(t));
  }
  var ap = {};
  function QV(t) {
    Object.assign(ap, t);
  }
  var Sy = [
    "",
    "X",
    "Y",
    "Z"
  ], JV = [
    "translate",
    "scale",
    "rotate",
    "skew"
  ], Au = [
    "transformPerspective",
    "x",
    "y",
    "z"
  ];
  JV.forEach(function(t) {
    return Sy.forEach(function(e) {
      return Au.push(t + e);
    });
  });
  function ZV(t, e) {
    return Au.indexOf(t) - Au.indexOf(e);
  }
  var e6 = new Set(Au);
  function tf(t) {
    return e6.has(t);
  }
  var t6 = /* @__PURE__ */ new Set([
    "originX",
    "originY",
    "originZ"
  ]);
  function kE(t) {
    return t6.has(t);
  }
  function CE(t, e) {
    var n = e.layout, r = e.layoutId;
    return tf(t) || kE(t) || (n || r !== void 0) && (!!ap[t] || t === "opacity");
  }
  var eo = function(t) {
    return Boolean(t !== null && typeof t == "object" && t.getVelocity);
  }, n6 = {
    x: "translateX",
    y: "translateY",
    z: "translateZ",
    transformPerspective: "perspective"
  };
  function r6(t, e, n, r) {
    var i = t.transform, o = t.transformKeys, s = e.enableHardwareAcceleration, a = s === void 0 ? true : s, l = e.allowTransformNone, c = l === void 0 ? true : l, u = "";
    o.sort(ZV);
    for (var h = false, p = o.length, v = 0; v < p; v++) {
      var y = o[v];
      u += "".concat(n6[y] || y, "(").concat(i[y], ") "), y === "z" && (h = true);
    }
    return !h && a ? u += "translateZ(0)" : u = u.trim(), r ? u = r(i, n ? "" : u) : c && n && (u = "none"), u;
  }
  function i6(t) {
    var e = t.originX, n = e === void 0 ? "50%" : e, r = t.originY, i = r === void 0 ? "50%" : r, o = t.originZ, s = o === void 0 ? 0 : o;
    return "".concat(n, " ").concat(i, " ").concat(s);
  }
  function TE(t) {
    return t.startsWith("--");
  }
  var o6 = function(t, e) {
    return e && typeof t == "number" ? e.transform(t) : t;
  };
  const ME = (t, e) => (n) => Math.max(Math.min(n, e), t), Fc = (t) => t % 1 ? Number(t.toFixed(5)) : t, Eu = /(-)?([\d]*\.?[\d])+/g, wy = /(#[0-9a-f]{6}|#[0-9a-f]{3}|#(?:[0-9a-f]{2}){2,4}|(rgb|hsl)a?\((-?[\d\.]+%?[,\s]+){2,3}\s*\/*\s*[\d\.]+%?\))/gi, s6 = /^(#[0-9a-f]{3}|#(?:[0-9a-f]{2}){2,4}|(rgb|hsl)a?\((-?[\d\.]+%?[,\s]+){2,3}\s*\/*\s*[\d\.]+%?\))$/i;
  function nf(t) {
    return typeof t == "string";
  }
  const Js = {
    test: (t) => typeof t == "number",
    parse: parseFloat,
    transform: (t) => t
  }, Vc = Object.assign(Object.assign({}, Js), {
    transform: ME(0, 1)
  }), ph = Object.assign(Object.assign({}, Js), {
    default: 1
  }), rf = (t) => ({
    test: (e) => nf(e) && e.endsWith(t) && e.split(" ").length === 1,
    parse: parseFloat,
    transform: (e) => `${e}${t}`
  }), go = rf("deg"), Ti = rf("%"), Te = rf("px"), a6 = rf("vh"), l6 = rf("vw"), ik = Object.assign(Object.assign({}, Ti), {
    parse: (t) => Ti.parse(t) / 100,
    transform: (t) => Ti.transform(t * 100)
  }), tx = (t, e) => (n) => Boolean(nf(n) && s6.test(n) && n.startsWith(t) || e && Object.prototype.hasOwnProperty.call(n, e)), AE = (t, e, n) => (r) => {
    if (!nf(r))
      return r;
    const [i, o, s, a] = r.match(Eu);
    return {
      [t]: parseFloat(i),
      [e]: parseFloat(o),
      [n]: parseFloat(s),
      alpha: a !== void 0 ? parseFloat(a) : 1
    };
  }, Es = {
    test: tx("hsl", "hue"),
    parse: AE("hue", "saturation", "lightness"),
    transform: ({ hue: t, saturation: e, lightness: n, alpha: r = 1 }) => "hsla(" + Math.round(t) + ", " + Ti.transform(Fc(e)) + ", " + Ti.transform(Fc(n)) + ", " + Fc(Vc.transform(r)) + ")"
  }, c6 = ME(0, 255), v0 = Object.assign(Object.assign({}, Js), {
    transform: (t) => Math.round(c6(t))
  }), Oo = {
    test: tx("rgb", "red"),
    parse: AE("red", "green", "blue"),
    transform: ({ red: t, green: e, blue: n, alpha: r = 1 }) => "rgba(" + v0.transform(t) + ", " + v0.transform(e) + ", " + v0.transform(n) + ", " + Fc(Vc.transform(r)) + ")"
  };
  function u6(t) {
    let e = "", n = "", r = "", i = "";
    return t.length > 5 ? (e = t.substr(1, 2), n = t.substr(3, 2), r = t.substr(5, 2), i = t.substr(7, 2)) : (e = t.substr(1, 1), n = t.substr(2, 1), r = t.substr(3, 1), i = t.substr(4, 1), e += e, n += n, r += r, i += i), {
      red: parseInt(e, 16),
      green: parseInt(n, 16),
      blue: parseInt(r, 16),
      alpha: i ? parseInt(i, 16) / 255 : 1
    };
  }
  const ky = {
    test: tx("#"),
    parse: u6,
    transform: Oo.transform
  }, vn = {
    test: (t) => Oo.test(t) || ky.test(t) || Es.test(t),
    parse: (t) => Oo.test(t) ? Oo.parse(t) : Es.test(t) ? Es.parse(t) : ky.parse(t),
    transform: (t) => nf(t) ? t : t.hasOwnProperty("red") ? Oo.transform(t) : Es.transform(t)
  }, EE = "${c}", PE = "${n}";
  function f6(t) {
    var e, n, r, i;
    return isNaN(t) && nf(t) && ((n = (e = t.match(Eu)) === null || e === void 0 ? void 0 : e.length) !== null && n !== void 0 ? n : 0) + ((i = (r = t.match(wy)) === null || r === void 0 ? void 0 : r.length) !== null && i !== void 0 ? i : 0) > 0;
  }
  function OE(t) {
    typeof t == "number" && (t = `${t}`);
    const e = [];
    let n = 0;
    const r = t.match(wy);
    r && (n = r.length, t = t.replace(wy, EE), e.push(...r.map(vn.parse)));
    const i = t.match(Eu);
    return i && (t = t.replace(Eu, PE), e.push(...i.map(Js.parse))), {
      values: e,
      numColors: n,
      tokenised: t
    };
  }
  function LE(t) {
    return OE(t).values;
  }
  function RE(t) {
    const { values: e, numColors: n, tokenised: r } = OE(t), i = e.length;
    return (o) => {
      let s = r;
      for (let a = 0; a < i; a++)
        s = s.replace(a < n ? EE : PE, a < n ? vn.transform(o[a]) : Fc(o[a]));
      return s;
    };
  }
  const h6 = (t) => typeof t == "number" ? 0 : t;
  function d6(t) {
    const e = LE(t);
    return RE(t)(e.map(h6));
  }
  const to = {
    test: f6,
    parse: LE,
    createTransformer: RE,
    getAnimatableNone: d6
  }, p6 = /* @__PURE__ */ new Set([
    "brightness",
    "contrast",
    "saturate",
    "opacity"
  ]);
  function m6(t) {
    let [e, n] = t.slice(0, -1).split("(");
    if (e === "drop-shadow")
      return t;
    const [r] = n.match(Eu) || [];
    if (!r)
      return t;
    const i = n.replace(r, "");
    let o = p6.has(e) ? 1 : 0;
    return r !== n && (o *= 100), e + "(" + o + i + ")";
  }
  const g6 = /([a-z-]*)\(.*?\)/g, Cy = Object.assign(Object.assign({}, to), {
    getAnimatableNone: (t) => {
      const e = t.match(g6);
      return e ? e.map(m6).join(" ") : t;
    }
  });
  var ok = ie(ie({}, Js), {
    transform: Math.round
  }), _E = {
    borderWidth: Te,
    borderTopWidth: Te,
    borderRightWidth: Te,
    borderBottomWidth: Te,
    borderLeftWidth: Te,
    borderRadius: Te,
    radius: Te,
    borderTopLeftRadius: Te,
    borderTopRightRadius: Te,
    borderBottomRightRadius: Te,
    borderBottomLeftRadius: Te,
    width: Te,
    maxWidth: Te,
    height: Te,
    maxHeight: Te,
    size: Te,
    top: Te,
    right: Te,
    bottom: Te,
    left: Te,
    padding: Te,
    paddingTop: Te,
    paddingRight: Te,
    paddingBottom: Te,
    paddingLeft: Te,
    margin: Te,
    marginTop: Te,
    marginRight: Te,
    marginBottom: Te,
    marginLeft: Te,
    rotate: go,
    rotateX: go,
    rotateY: go,
    rotateZ: go,
    scale: ph,
    scaleX: ph,
    scaleY: ph,
    scaleZ: ph,
    skew: go,
    skewX: go,
    skewY: go,
    distance: Te,
    translateX: Te,
    translateY: Te,
    translateZ: Te,
    x: Te,
    y: Te,
    z: Te,
    perspective: Te,
    transformPerspective: Te,
    opacity: Vc,
    originX: ik,
    originY: ik,
    originZ: Te,
    zIndex: ok,
    fillOpacity: Vc,
    strokeOpacity: Vc,
    numOctaves: ok
  };
  function nx(t, e, n, r) {
    var i, o = t.style, s = t.vars, a = t.transform, l = t.transformKeys, c = t.transformOrigin;
    l.length = 0;
    var u = false, h = false, p = true;
    for (var v in e) {
      var y = e[v];
      if (TE(v)) {
        s[v] = y;
        continue;
      }
      var S = _E[v], T = o6(y, S);
      if (tf(v)) {
        if (u = true, a[v] = T, l.push(v), !p)
          continue;
        y !== ((i = S.default) !== null && i !== void 0 ? i : 0) && (p = false);
      } else
        kE(v) ? (c[v] = T, h = true) : o[v] = T;
    }
    u ? o.transform = r6(t, n, p, r) : r ? o.transform = r({}, "") : !e.transform && o.transform && (o.transform = "none"), h && (o.transformOrigin = i6(c));
  }
  var rx = function() {
    return {
      style: {},
      transform: {},
      transformKeys: [],
      transformOrigin: {},
      vars: {}
    };
  };
  function DE(t, e, n) {
    for (var r in e)
      !eo(e[r]) && !CE(r, n) && (t[r] = e[r]);
  }
  function v6(t, e, n) {
    var r = t.transformTemplate;
    return z.exports.useMemo(function() {
      var i = rx();
      nx(i, e, {
        enableHardwareAcceleration: !n
      }, r);
      var o = i.vars, s = i.style;
      return ie(ie({}, o), s);
    }, [
      e
    ]);
  }
  function y6(t, e, n) {
    var r = t.style || {}, i = {};
    return DE(i, r, t), Object.assign(i, v6(t, e, n)), t.transformValues && (i = t.transformValues(i)), i;
  }
  function b6(t, e, n) {
    var r = {}, i = y6(t, e, n);
    return Boolean(t.drag) && t.dragListener !== false && (r.draggable = false, i.userSelect = i.WebkitUserSelect = i.WebkitTouchCallout = "none", i.touchAction = t.drag === true ? "none" : "pan-".concat(t.drag === "x" ? "y" : "x")), r.style = i, r;
  }
  var x6 = /* @__PURE__ */ new Set([
    "initial",
    "animate",
    "exit",
    "style",
    "variants",
    "transition",
    "transformTemplate",
    "transformValues",
    "custom",
    "inherit",
    "layout",
    "layoutId",
    "layoutDependency",
    "onLayoutAnimationStart",
    "onLayoutAnimationComplete",
    "onLayoutMeasure",
    "onBeforeLayoutMeasure",
    "onAnimationStart",
    "onAnimationComplete",
    "onUpdate",
    "onDragStart",
    "onDrag",
    "onDragEnd",
    "onMeasureDragConstraints",
    "onDirectionLock",
    "onDragTransitionEnd",
    "drag",
    "dragControls",
    "dragListener",
    "dragConstraints",
    "dragDirectionLock",
    "dragSnapToOrigin",
    "_dragX",
    "_dragY",
    "dragElastic",
    "dragMomentum",
    "dragPropagation",
    "dragTransition",
    "whileDrag",
    "onPan",
    "onPanStart",
    "onPanEnd",
    "onPanSessionStart",
    "onTap",
    "onTapStart",
    "onTapCancel",
    "onHoverStart",
    "onHoverEnd",
    "whileFocus",
    "whileTap",
    "whileHover",
    "whileInView",
    "onViewportEnter",
    "onViewportLeave",
    "viewport",
    "layoutScroll"
  ]);
  function lp(t) {
    return x6.has(t);
  }
  var IE = function(t) {
    return !lp(t);
  };
  function S6(t) {
    !t || (IE = function(e) {
      return e.startsWith("on") ? !lp(e) : t(e);
    });
  }
  try {
    S6(require("@emotion/is-prop-valid").default);
  } catch {
  }
  function w6(t, e, n) {
    var r = {};
    for (var i in t)
      (IE(i) || n === true && lp(i) || !e && !lp(i) || t.draggable && i.startsWith("onDrag")) && (r[i] = t[i]);
    return r;
  }
  function sk(t, e, n) {
    return typeof t == "string" ? t : Te.transform(e + n * t);
  }
  function k6(t, e, n) {
    var r = sk(e, t.x, t.width), i = sk(n, t.y, t.height);
    return "".concat(r, " ").concat(i);
  }
  var C6 = {
    offset: "stroke-dashoffset",
    array: "stroke-dasharray"
  }, T6 = {
    offset: "strokeDashoffset",
    array: "strokeDasharray"
  };
  function M6(t, e, n, r, i) {
    n === void 0 && (n = 1), r === void 0 && (r = 0), i === void 0 && (i = true), t.pathLength = 1;
    var o = i ? C6 : T6;
    t[o.offset] = Te.transform(-r);
    var s = Te.transform(e), a = Te.transform(n);
    t[o.array] = "".concat(s, " ").concat(a);
  }
  function ix(t, e, n, r) {
    var i = e.attrX, o = e.attrY, s = e.originX, a = e.originY, l = e.pathLength, c = e.pathSpacing, u = c === void 0 ? 1 : c, h = e.pathOffset, p = h === void 0 ? 0 : h, v = Tr(e, [
      "attrX",
      "attrY",
      "originX",
      "originY",
      "pathLength",
      "pathSpacing",
      "pathOffset"
    ]);
    nx(t, v, n, r), t.attrs = t.style, t.style = {};
    var y = t.attrs, S = t.style, T = t.dimensions;
    y.transform && (T && (S.transform = y.transform), delete y.transform), T && (s !== void 0 || a !== void 0 || S.transform) && (S.transformOrigin = k6(T, s !== void 0 ? s : 0.5, a !== void 0 ? a : 0.5)), i !== void 0 && (y.x = i), o !== void 0 && (y.y = o), l !== void 0 && M6(y, l, u, p, false);
  }
  var BE = function() {
    return ie(ie({}, rx()), {
      attrs: {}
    });
  };
  function A6(t, e) {
    var n = z.exports.useMemo(function() {
      var i = BE();
      return ix(i, e, {
        enableHardwareAcceleration: false
      }, t.transformTemplate), ie(ie({}, i.attrs), {
        style: ie({}, i.style)
      });
    }, [
      e
    ]);
    if (t.style) {
      var r = {};
      DE(r, t.style, t), n.style = ie(ie({}, r), n.style);
    }
    return n;
  }
  function E6(t) {
    t === void 0 && (t = false);
    var e = function(n, r, i, o, s, a) {
      var l = s.latestValues, c = ex(n) ? A6 : b6, u = c(r, l, a), h = w6(r, typeof n == "string", t), p = ie(ie(ie({}, h), u), {
        ref: o
      });
      return i && (p["data-projection-id"] = i), z.exports.createElement(n, p);
    };
    return e;
  }
  var P6 = /([a-z])([A-Z])/g, O6 = "$1-$2", NE = function(t) {
    return t.replace(P6, O6).toLowerCase();
  };
  function $E(t, e, n, r) {
    var i = e.style, o = e.vars;
    Object.assign(t.style, i, r && r.getProjectionStyles(n));
    for (var s in o)
      t.style.setProperty(s, o[s]);
  }
  var zE = /* @__PURE__ */ new Set([
    "baseFrequency",
    "diffuseConstant",
    "kernelMatrix",
    "kernelUnitLength",
    "keySplines",
    "keyTimes",
    "limitingConeAngle",
    "markerHeight",
    "markerWidth",
    "numOctaves",
    "targetX",
    "targetY",
    "surfaceScale",
    "specularConstant",
    "specularExponent",
    "stdDeviation",
    "tableValues",
    "viewBox",
    "gradientTransform",
    "pathLength"
  ]);
  function FE(t, e, n, r) {
    $E(t, e, void 0, r);
    for (var i in e.attrs)
      t.setAttribute(zE.has(i) ? i : NE(i), e.attrs[i]);
  }
  function ox(t) {
    var e = t.style, n = {};
    for (var r in e)
      (eo(e[r]) || CE(r, t)) && (n[r] = e[r]);
    return n;
  }
  function VE(t) {
    var e = ox(t);
    for (var n in t)
      if (eo(t[n])) {
        var r = n === "x" || n === "y" ? "attr" + n.toUpperCase() : n;
        e[r] = t[n];
      }
    return e;
  }
  function sx(t) {
    return typeof t == "object" && typeof t.start == "function";
  }
  var Pu = function(t) {
    return Array.isArray(t);
  }, L6 = function(t) {
    return Boolean(t && typeof t == "object" && t.mix && t.toValue);
  }, WE = function(t) {
    return Pu(t) ? t[t.length - 1] || 0 : t;
  };
  function md(t) {
    var e = eo(t) ? t.get() : t;
    return L6(e) ? e.toValue() : e;
  }
  function ak(t, e, n, r) {
    var i = t.scrapeMotionValuesFromProps, o = t.createRenderState, s = t.onMount, a = {
      latestValues: R6(e, n, r, i),
      renderState: o()
    };
    return s && (a.mount = function(l) {
      return s(e, l, a);
    }), a;
  }
  var HE = function(t) {
    return function(e, n) {
      var r = z.exports.useContext(Am), i = z.exports.useContext(Ml);
      return n ? ak(t, e, r, i) : ef(function() {
        return ak(t, e, r, i);
      });
    };
  };
  function R6(t, e, n, r) {
    var i = {}, o = (n == null ? void 0 : n.initial) === false, s = r(t);
    for (var a in s)
      i[a] = md(s[a]);
    var l = t.initial, c = t.animate, u = Pm(t), h = SE(t);
    e && h && !u && t.inherit !== false && (l ?? (l = e.initial), c ?? (c = e.animate));
    var p = o || l === false, v = p ? c : l;
    if (v && typeof v != "boolean" && !sx(v)) {
      var y = Array.isArray(v) ? v : [
        v
      ];
      y.forEach(function(S) {
        var T = xE(t, S);
        if (!!T) {
          var w = T.transitionEnd;
          T.transition;
          var k = Tr(T, [
            "transitionEnd",
            "transition"
          ]);
          for (var C in k) {
            var O = k[C];
            if (Array.isArray(O)) {
              var L = p ? O.length - 1 : 0;
              O = O[L];
            }
            O !== null && (i[C] = O);
          }
          for (var C in w)
            i[C] = w[C];
        }
      });
    }
    return i;
  }
  var _6 = {
    useVisualState: HE({
      scrapeMotionValuesFromProps: VE,
      createRenderState: BE,
      onMount: function(t, e, n) {
        var r = n.renderState, i = n.latestValues;
        try {
          r.dimensions = typeof e.getBBox == "function" ? e.getBBox() : e.getBoundingClientRect();
        } catch {
          r.dimensions = {
            x: 0,
            y: 0,
            width: 0,
            height: 0
          };
        }
        ix(r, i, {
          enableHardwareAcceleration: false
        }, t.transformTemplate), FE(e, r);
      }
    })
  }, D6 = {
    useVisualState: HE({
      scrapeMotionValuesFromProps: ox,
      createRenderState: rx
    })
  };
  function I6(t, e, n, r, i) {
    var o = e.forwardMotionProps, s = o === void 0 ? false : o, a = ex(t) ? _6 : D6;
    return ie(ie({}, a), {
      preloadedFeatures: n,
      useRender: E6(s),
      createVisualElement: r,
      projectionNodeConstructor: i,
      Component: t
    });
  }
  var nt;
  (function(t) {
    t.Animate = "animate", t.Hover = "whileHover", t.Tap = "whileTap", t.Drag = "whileDrag", t.Focus = "whileFocus", t.InView = "whileInView", t.Exit = "exit";
  })(nt || (nt = {}));
  function Om(t, e, n, r) {
    return r === void 0 && (r = {
      passive: true
    }), t.addEventListener(e, n, r), function() {
      return t.removeEventListener(e, n);
    };
  }
  function Ty(t, e, n, r) {
    z.exports.useEffect(function() {
      var i = t.current;
      if (n && i)
        return Om(i, e, n, r);
    }, [
      t,
      e,
      n,
      r
    ]);
  }
  function B6(t) {
    var e = t.whileFocus, n = t.visualElement, r = function() {
      var o;
      (o = n.animationState) === null || o === void 0 || o.setActive(nt.Focus, true);
    }, i = function() {
      var o;
      (o = n.animationState) === null || o === void 0 || o.setActive(nt.Focus, false);
    };
    Ty(n, "focus", e ? r : void 0), Ty(n, "blur", e ? i : void 0);
  }
  function jE(t) {
    return typeof PointerEvent < "u" && t instanceof PointerEvent ? t.pointerType === "mouse" : t instanceof MouseEvent;
  }
  function UE(t) {
    var e = !!t.touches;
    return e;
  }
  function N6(t) {
    return function(e) {
      var n = e instanceof MouseEvent, r = !n || n && e.button === 0;
      r && t(e);
    };
  }
  var $6 = {
    pageX: 0,
    pageY: 0
  };
  function z6(t, e) {
    e === void 0 && (e = "page");
    var n = t.touches[0] || t.changedTouches[0], r = n || $6;
    return {
      x: r[e + "X"],
      y: r[e + "Y"]
    };
  }
  function F6(t, e) {
    return e === void 0 && (e = "page"), {
      x: t[e + "X"],
      y: t[e + "Y"]
    };
  }
  function ax(t, e) {
    return e === void 0 && (e = "page"), {
      point: UE(t) ? z6(t, e) : F6(t, e)
    };
  }
  var KE = function(t, e) {
    e === void 0 && (e = false);
    var n = function(r) {
      return t(r, ax(r));
    };
    return e ? N6(n) : n;
  }, V6 = function() {
    return Al && window.onpointerdown === null;
  }, W6 = function() {
    return Al && window.ontouchstart === null;
  }, H6 = function() {
    return Al && window.onmousedown === null;
  }, j6 = {
    pointerdown: "mousedown",
    pointermove: "mousemove",
    pointerup: "mouseup",
    pointercancel: "mousecancel",
    pointerover: "mouseover",
    pointerout: "mouseout",
    pointerenter: "mouseenter",
    pointerleave: "mouseleave"
  }, U6 = {
    pointerdown: "touchstart",
    pointermove: "touchmove",
    pointerup: "touchend",
    pointercancel: "touchcancel"
  };
  function qE(t) {
    return V6() ? t : W6() ? U6[t] : H6() ? j6[t] : t;
  }
  function qa(t, e, n, r) {
    return Om(t, qE(e), KE(n, e === "pointerdown"), r);
  }
  function cp(t, e, n, r) {
    return Ty(t, qE(e), n && KE(n, e === "pointerdown"), r);
  }
  function GE(t) {
    var e = null;
    return function() {
      var n = function() {
        e = null;
      };
      return e === null ? (e = t, n) : false;
    };
  }
  var lk = GE("dragHorizontal"), ck = GE("dragVertical");
  function YE(t) {
    var e = false;
    if (t === "y")
      e = ck();
    else if (t === "x")
      e = lk();
    else {
      var n = lk(), r = ck();
      n && r ? e = function() {
        n(), r();
      } : (n && n(), r && r());
    }
    return e;
  }
  function XE() {
    var t = YE(true);
    return t ? (t(), false) : true;
  }
  function uk(t, e, n) {
    return function(r, i) {
      var o;
      !jE(r) || XE() || ((o = t.animationState) === null || o === void 0 || o.setActive(nt.Hover, e), n == null ? void 0 : n(r, i));
    };
  }
  function K6(t) {
    var e = t.onHoverStart, n = t.onHoverEnd, r = t.whileHover, i = t.visualElement;
    cp(i, "pointerenter", e || r ? uk(i, true, e) : void 0, {
      passive: !e
    }), cp(i, "pointerleave", n || r ? uk(i, false, n) : void 0, {
      passive: !n
    });
  }
  var QE = function(t, e) {
    return e ? t === e ? true : QE(t, e.parentElement) : false;
  };
  function lx(t) {
    return z.exports.useEffect(function() {
      return function() {
        return t();
      };
    }, []);
  }
  const up = (t, e, n) => Math.min(Math.max(n, t), e), y0 = 1e-3, q6 = 0.01, fk = 10, G6 = 0.05, Y6 = 1;
  function X6({ duration: t = 800, bounce: e = 0.25, velocity: n = 0, mass: r = 1 }) {
    let i, o;
    OV(t <= fk * 1e3);
    let s = 1 - e;
    s = up(G6, Y6, s), t = up(q6, fk, t / 1e3), s < 1 ? (i = (c) => {
      const u = c * s, h = u * t, p = u - n, v = My(c, s), y = Math.exp(-h);
      return y0 - p / v * y;
    }, o = (c) => {
      const h = c * s * t, p = h * n + n, v = Math.pow(s, 2) * Math.pow(c, 2) * t, y = Math.exp(-h), S = My(Math.pow(c, 2), s);
      return (-i(c) + y0 > 0 ? -1 : 1) * ((p - v) * y) / S;
    }) : (i = (c) => {
      const u = Math.exp(-c * t), h = (c - n) * t + 1;
      return -y0 + u * h;
    }, o = (c) => {
      const u = Math.exp(-c * t), h = (n - c) * (t * t);
      return u * h;
    });
    const a = 5 / t, l = J6(i, o, a);
    if (t = t * 1e3, isNaN(l))
      return {
        stiffness: 100,
        damping: 10,
        duration: t
      };
    {
      const c = Math.pow(l, 2) * r;
      return {
        stiffness: c,
        damping: s * 2 * Math.sqrt(r * c),
        duration: t
      };
    }
  }
  const Q6 = 12;
  function J6(t, e, n) {
    let r = n;
    for (let i = 1; i < Q6; i++)
      r = r - t(r) / e(r);
    return r;
  }
  function My(t, e) {
    return t * Math.sqrt(1 - e * e);
  }
  const Z6 = [
    "duration",
    "bounce"
  ], e8 = [
    "stiffness",
    "damping",
    "mass"
  ];
  function hk(t, e) {
    return e.some((n) => t[n] !== void 0);
  }
  function t8(t) {
    let e = Object.assign({
      velocity: 0,
      stiffness: 100,
      damping: 10,
      mass: 1,
      isResolvedFromDuration: false
    }, t);
    if (!hk(t, e8) && hk(t, Z6)) {
      const n = X6(t);
      e = Object.assign(Object.assign(Object.assign({}, e), n), {
        velocity: 0,
        mass: 1
      }), e.isResolvedFromDuration = true;
    }
    return e;
  }
  function cx(t) {
    var { from: e = 0, to: n = 1, restSpeed: r = 2, restDelta: i } = t, o = Tr(t, [
      "from",
      "to",
      "restSpeed",
      "restDelta"
    ]);
    const s = {
      done: false,
      value: e
    };
    let { stiffness: a, damping: l, mass: c, velocity: u, duration: h, isResolvedFromDuration: p } = t8(o), v = dk, y = dk;
    function S() {
      const T = u ? -(u / 1e3) : 0, w = n - e, k = l / (2 * Math.sqrt(a * c)), C = Math.sqrt(a / c) / 1e3;
      if (i === void 0 && (i = Math.min(Math.abs(n - e) / 100, 0.4)), k < 1) {
        const O = My(C, k);
        v = (L) => {
          const D = Math.exp(-k * C * L);
          return n - D * ((T + k * C * w) / O * Math.sin(O * L) + w * Math.cos(O * L));
        }, y = (L) => {
          const D = Math.exp(-k * C * L);
          return k * C * D * (Math.sin(O * L) * (T + k * C * w) / O + w * Math.cos(O * L)) - D * (Math.cos(O * L) * (T + k * C * w) - O * w * Math.sin(O * L));
        };
      } else if (k === 1)
        v = (O) => n - Math.exp(-C * O) * (w + (T + C * w) * O);
      else {
        const O = C * Math.sqrt(k * k - 1);
        v = (L) => {
          const D = Math.exp(-k * C * L), R = Math.min(O * L, 300);
          return n - D * ((T + k * C * w) * Math.sinh(R) + O * w * Math.cosh(R)) / O;
        };
      }
    }
    return S(), {
      next: (T) => {
        const w = v(T);
        if (p)
          s.done = T >= h;
        else {
          const k = y(T) * 1e3, C = Math.abs(k) <= r, O = Math.abs(n - w) <= i;
          s.done = C && O;
        }
        return s.value = s.done ? n : w, s;
      },
      flipTarget: () => {
        u = -u, [e, n] = [
          n,
          e
        ], S();
      }
    };
  }
  cx.needsInterpolation = (t, e) => typeof t == "string" || typeof e == "string";
  const dk = (t) => 0, Ou = (t, e, n) => {
    const r = e - t;
    return r === 0 ? 1 : (n - t) / r;
  }, St = (t, e, n) => -n * t + n * e + t;
  function b0(t, e, n) {
    return n < 0 && (n += 1), n > 1 && (n -= 1), n < 1 / 6 ? t + (e - t) * 6 * n : n < 1 / 2 ? e : n < 2 / 3 ? t + (e - t) * (2 / 3 - n) * 6 : t;
  }
  function pk({ hue: t, saturation: e, lightness: n, alpha: r }) {
    t /= 360, e /= 100, n /= 100;
    let i = 0, o = 0, s = 0;
    if (!e)
      i = o = s = n;
    else {
      const a = n < 0.5 ? n * (1 + e) : n + e - n * e, l = 2 * n - a;
      i = b0(l, a, t + 1 / 3), o = b0(l, a, t), s = b0(l, a, t - 1 / 3);
    }
    return {
      red: Math.round(i * 255),
      green: Math.round(o * 255),
      blue: Math.round(s * 255),
      alpha: r
    };
  }
  const n8 = (t, e, n) => {
    const r = t * t, i = e * e;
    return Math.sqrt(Math.max(0, n * (i - r) + r));
  }, r8 = [
    ky,
    Oo,
    Es
  ], mk = (t) => r8.find((e) => e.test(t)), JE = (t, e) => {
    let n = mk(t), r = mk(e), i = n.parse(t), o = r.parse(e);
    n === Es && (i = pk(i), n = Oo), r === Es && (o = pk(o), r = Oo);
    const s = Object.assign({}, i);
    return (a) => {
      for (const l in s)
        l !== "alpha" && (s[l] = n8(i[l], o[l], a));
      return s.alpha = St(i.alpha, o.alpha, a), n.transform(s);
    };
  }, Ay = (t) => typeof t == "number", i8 = (t, e) => (n) => e(t(n)), Lm = (...t) => t.reduce(i8);
  function ZE(t, e) {
    return Ay(t) ? (n) => St(t, e, n) : vn.test(t) ? JE(t, e) : tP(t, e);
  }
  const eP = (t, e) => {
    const n = [
      ...t
    ], r = n.length, i = t.map((o, s) => ZE(o, e[s]));
    return (o) => {
      for (let s = 0; s < r; s++)
        n[s] = i[s](o);
      return n;
    };
  }, o8 = (t, e) => {
    const n = Object.assign(Object.assign({}, t), e), r = {};
    for (const i in n)
      t[i] !== void 0 && e[i] !== void 0 && (r[i] = ZE(t[i], e[i]));
    return (i) => {
      for (const o in r)
        n[o] = r[o](i);
      return n;
    };
  };
  function gk(t) {
    const e = to.parse(t), n = e.length;
    let r = 0, i = 0, o = 0;
    for (let s = 0; s < n; s++)
      r || typeof e[s] == "number" ? r++ : e[s].hue !== void 0 ? o++ : i++;
    return {
      parsed: e,
      numNumbers: r,
      numRGB: i,
      numHSL: o
    };
  }
  const tP = (t, e) => {
    const n = to.createTransformer(e), r = gk(t), i = gk(e);
    return r.numHSL === i.numHSL && r.numRGB === i.numRGB && r.numNumbers >= i.numNumbers ? Lm(eP(r.parsed, i.parsed), n) : (s) => `${s > 0 ? e : t}`;
  }, s8 = (t, e) => (n) => St(t, e, n);
  function a8(t) {
    if (typeof t == "number")
      return s8;
    if (typeof t == "string")
      return vn.test(t) ? JE : tP;
    if (Array.isArray(t))
      return eP;
    if (typeof t == "object")
      return o8;
  }
  function l8(t, e, n) {
    const r = [], i = n || a8(t[0]), o = t.length - 1;
    for (let s = 0; s < o; s++) {
      let a = i(t[s], t[s + 1]);
      if (e) {
        const l = Array.isArray(e) ? e[s] : e;
        a = Lm(l, a);
      }
      r.push(a);
    }
    return r;
  }
  function c8([t, e], [n]) {
    return (r) => n(Ou(t, e, r));
  }
  function u8(t, e) {
    const n = t.length, r = n - 1;
    return (i) => {
      let o = 0, s = false;
      if (i <= t[0] ? s = true : i >= t[r] && (o = r - 1, s = true), !s) {
        let l = 1;
        for (; l < n && !(t[l] > i || l === r); l++)
          ;
        o = l - 1;
      }
      const a = Ou(t[o], t[o + 1], i);
      return e[o](a);
    };
  }
  function nP(t, e, { clamp: n = true, ease: r, mixer: i } = {}) {
    const o = t.length;
    op(o === e.length), op(!r || !Array.isArray(r) || r.length === o - 1), t[0] > t[o - 1] && (t = [].concat(t), e = [].concat(e), t.reverse(), e.reverse());
    const s = l8(e, r, i), a = o === 2 ? c8(t, s) : u8(t, s);
    return n ? (l) => a(up(t[0], t[o - 1], l)) : a;
  }
  const Rm = (t) => (e) => 1 - t(1 - e), ux = (t) => (e) => e <= 0.5 ? t(2 * e) / 2 : (2 - t(2 * (1 - e))) / 2, f8 = (t) => (e) => Math.pow(e, t), rP = (t) => (e) => e * e * ((t + 1) * e - t), h8 = (t) => {
    const e = rP(t);
    return (n) => (n *= 2) < 1 ? 0.5 * e(n) : 0.5 * (2 - Math.pow(2, -10 * (n - 1)));
  }, iP = 1.525, d8 = 4 / 11, p8 = 8 / 11, m8 = 9 / 10, fx = (t) => t, hx = f8(2), g8 = Rm(hx), oP = ux(hx), sP = (t) => 1 - Math.sin(Math.acos(t)), dx = Rm(sP), v8 = ux(dx), px = rP(iP), y8 = Rm(px), b8 = ux(px), x8 = h8(iP), S8 = 4356 / 361, w8 = 35442 / 1805, k8 = 16061 / 1805, fp = (t) => {
    if (t === 1 || t === 0)
      return t;
    const e = t * t;
    return t < d8 ? 7.5625 * e : t < p8 ? 9.075 * e - 9.9 * t + 3.4 : t < m8 ? S8 * e - w8 * t + k8 : 10.8 * t * t - 20.52 * t + 10.72;
  }, C8 = Rm(fp), T8 = (t) => t < 0.5 ? 0.5 * (1 - fp(1 - t * 2)) : 0.5 * fp(t * 2 - 1) + 0.5;
  function M8(t, e) {
    return t.map(() => e || oP).splice(0, t.length - 1);
  }
  function A8(t) {
    const e = t.length;
    return t.map((n, r) => r !== 0 ? r / (e - 1) : 0);
  }
  function E8(t, e) {
    return t.map((n) => n * e);
  }
  function gd({ from: t = 0, to: e = 1, ease: n, offset: r, duration: i = 300 }) {
    const o = {
      done: false,
      value: t
    }, s = Array.isArray(e) ? e : [
      t,
      e
    ], a = E8(r && r.length === s.length ? r : A8(s), i);
    function l() {
      return nP(a, s, {
        ease: Array.isArray(n) ? n : M8(s, n)
      });
    }
    let c = l();
    return {
      next: (u) => (o.value = c(u), o.done = u >= i, o),
      flipTarget: () => {
        s.reverse(), c = l();
      }
    };
  }
  function P8({ velocity: t = 0, from: e = 0, power: n = 0.8, timeConstant: r = 350, restDelta: i = 0.5, modifyTarget: o }) {
    const s = {
      done: false,
      value: e
    };
    let a = n * t;
    const l = e + a, c = o === void 0 ? l : o(l);
    return c !== l && (a = c - e), {
      next: (u) => {
        const h = -a * Math.exp(-u / r);
        return s.done = !(h > i || h < -i), s.value = s.done ? c : c + h, s;
      },
      flipTarget: () => {
      }
    };
  }
  const vk = {
    keyframes: gd,
    spring: cx,
    decay: P8
  };
  function O8(t) {
    if (Array.isArray(t.to))
      return gd;
    if (vk[t.type])
      return vk[t.type];
    const e = new Set(Object.keys(t));
    return e.has("ease") || e.has("duration") && !e.has("dampingRatio") ? gd : e.has("dampingRatio") || e.has("stiffness") || e.has("mass") || e.has("damping") || e.has("restSpeed") || e.has("restDelta") ? cx : gd;
  }
  const aP = 1 / 60 * 1e3, L8 = typeof performance < "u" ? () => performance.now() : () => Date.now(), lP = typeof window < "u" ? (t) => window.requestAnimationFrame(t) : (t) => setTimeout(() => t(L8()), aP);
  function R8(t) {
    let e = [], n = [], r = 0, i = false, o = false;
    const s = /* @__PURE__ */ new WeakSet(), a = {
      schedule: (l, c = false, u = false) => {
        const h = u && i, p = h ? e : n;
        return c && s.add(l), p.indexOf(l) === -1 && (p.push(l), h && i && (r = e.length)), l;
      },
      cancel: (l) => {
        const c = n.indexOf(l);
        c !== -1 && n.splice(c, 1), s.delete(l);
      },
      process: (l) => {
        if (i) {
          o = true;
          return;
        }
        if (i = true, [e, n] = [
          n,
          e
        ], n.length = 0, r = e.length, r)
          for (let c = 0; c < r; c++) {
            const u = e[c];
            u(l), s.has(u) && (a.schedule(u), t());
          }
        i = false, o && (o = false, a.process(l));
      }
    };
    return a;
  }
  const _8 = 40;
  let Ey = true, Lu = false, Py = false;
  const Ga = {
    delta: 0,
    timestamp: 0
  }, of = [
    "read",
    "update",
    "preRender",
    "render",
    "postRender"
  ], _m = of.reduce((t, e) => (t[e] = R8(() => Lu = true), t), {}), Ur = of.reduce((t, e) => {
    const n = _m[e];
    return t[e] = (r, i = false, o = false) => (Lu || I8(), n.schedule(r, i, o)), t;
  }, {}), hl = of.reduce((t, e) => (t[e] = _m[e].cancel, t), {}), x0 = of.reduce((t, e) => (t[e] = () => _m[e].process(Ga), t), {}), D8 = (t) => _m[t].process(Ga), cP = (t) => {
    Lu = false, Ga.delta = Ey ? aP : Math.max(Math.min(t - Ga.timestamp, _8), 1), Ga.timestamp = t, Py = true, of.forEach(D8), Py = false, Lu && (Ey = false, lP(cP));
  }, I8 = () => {
    Lu = true, Ey = true, Py || lP(cP);
  }, hp = () => Ga;
  function uP(t, e, n = 0) {
    return t - e - n;
  }
  function B8(t, e, n = 0, r = true) {
    return r ? uP(e + -t, e, n) : e - (t - e) + n;
  }
  function N8(t, e, n, r) {
    return r ? t >= e + n : t <= -n;
  }
  const $8 = (t) => {
    const e = ({ delta: n }) => t(n);
    return {
      start: () => Ur.update(e, true),
      stop: () => hl.update(e)
    };
  };
  function fP(t) {
    var e, n, { from: r, autoplay: i = true, driver: o = $8, elapsed: s = 0, repeat: a = 0, repeatType: l = "loop", repeatDelay: c = 0, onPlay: u, onStop: h, onComplete: p, onRepeat: v, onUpdate: y } = t, S = Tr(t, [
      "from",
      "autoplay",
      "driver",
      "elapsed",
      "repeat",
      "repeatType",
      "repeatDelay",
      "onPlay",
      "onStop",
      "onComplete",
      "onRepeat",
      "onUpdate"
    ]);
    let { to: T } = S, w, k = 0, C = S.duration, O, L = false, D = true, R;
    const F = O8(S);
    !((n = (e = F).needsInterpolation) === null || n === void 0) && n.call(e, r, T) && (R = nP([
      0,
      100
    ], [
      r,
      T
    ], {
      clamp: false
    }), r = 0, T = 100);
    const K = F(Object.assign(Object.assign({}, S), {
      from: r,
      to: T
    }));
    function Y() {
      k++, l === "reverse" ? (D = k % 2 === 0, s = B8(s, C, c, D)) : (s = uP(s, C, c), l === "mirror" && K.flipTarget()), L = false, v && v();
    }
    function te() {
      w.stop(), p && p();
    }
    function ne(ye) {
      if (D || (ye = -ye), s += ye, !L) {
        const Ce = K.next(Math.max(0, s));
        O = Ce.value, R && (O = R(O)), L = D ? Ce.done : s <= 0;
      }
      y == null ? void 0 : y(O), L && (k === 0 && (C ?? (C = s)), k < a ? N8(s, C, c, D) && Y() : te());
    }
    function ae() {
      u == null ? void 0 : u(), w = o(ne), w.start();
    }
    return i && ae(), {
      stop: () => {
        h == null ? void 0 : h(), w.stop();
      }
    };
  }
  function hP(t, e) {
    return e ? t * (1e3 / e) : 0;
  }
  function z8({ from: t = 0, velocity: e = 0, min: n, max: r, power: i = 0.8, timeConstant: o = 750, bounceStiffness: s = 500, bounceDamping: a = 10, restDelta: l = 1, modifyTarget: c, driver: u, onUpdate: h, onComplete: p, onStop: v }) {
    let y;
    function S(C) {
      return n !== void 0 && C < n || r !== void 0 && C > r;
    }
    function T(C) {
      return n === void 0 ? r : r === void 0 || Math.abs(n - C) < Math.abs(r - C) ? n : r;
    }
    function w(C) {
      y == null ? void 0 : y.stop(), y = fP(Object.assign(Object.assign({}, C), {
        driver: u,
        onUpdate: (O) => {
          var L;
          h == null ? void 0 : h(O), (L = C.onUpdate) === null || L === void 0 || L.call(C, O);
        },
        onComplete: p,
        onStop: v
      }));
    }
    function k(C) {
      w(Object.assign({
        type: "spring",
        stiffness: s,
        damping: a,
        restDelta: l
      }, C));
    }
    if (S(t))
      k({
        from: t,
        velocity: e,
        to: T(t)
      });
    else {
      let C = i * e + t;
      typeof c < "u" && (C = c(C));
      const O = T(C), L = O === n ? -1 : 1;
      let D, R;
      const F = (K) => {
        D = R, R = K, e = hP(K - D, hp().delta), (L === 1 && K > O || L === -1 && K < O) && k({
          from: K,
          to: O,
          velocity: e
        });
      };
      w({
        type: "decay",
        from: t,
        velocity: e,
        timeConstant: o,
        power: i,
        restDelta: l,
        modifyTarget: c,
        onUpdate: S(C) ? F : void 0
      });
    }
    return {
      stop: () => y == null ? void 0 : y.stop()
    };
  }
  const Oy = (t) => t.hasOwnProperty("x") && t.hasOwnProperty("y"), yk = (t) => Oy(t) && t.hasOwnProperty("z"), mh = (t, e) => Math.abs(t - e);
  function dP(t, e) {
    if (Ay(t) && Ay(e))
      return mh(t, e);
    if (Oy(t) && Oy(e)) {
      const n = mh(t.x, e.x), r = mh(t.y, e.y), i = yk(t) && yk(e) ? mh(t.z, e.z) : 0;
      return Math.sqrt(Math.pow(n, 2) + Math.pow(r, 2) + Math.pow(i, 2));
    }
  }
  const pP = (t, e) => 1 - 3 * e + 3 * t, mP = (t, e) => 3 * e - 6 * t, gP = (t) => 3 * t, dp = (t, e, n) => ((pP(e, n) * t + mP(e, n)) * t + gP(e)) * t, vP = (t, e, n) => 3 * pP(e, n) * t * t + 2 * mP(e, n) * t + gP(e), F8 = 1e-7, V8 = 10;
  function W8(t, e, n, r, i) {
    let o, s, a = 0;
    do
      s = e + (n - e) / 2, o = dp(s, r, i) - t, o > 0 ? n = s : e = s;
    while (Math.abs(o) > F8 && ++a < V8);
    return s;
  }
  const H8 = 8, j8 = 1e-3;
  function U8(t, e, n, r) {
    for (let i = 0; i < H8; ++i) {
      const o = vP(e, n, r);
      if (o === 0)
        return e;
      const s = dp(e, n, r) - t;
      e -= s / o;
    }
    return e;
  }
  const vd = 11, gh = 1 / (vd - 1);
  function K8(t, e, n, r) {
    if (t === e && n === r)
      return fx;
    const i = new Float32Array(vd);
    for (let s = 0; s < vd; ++s)
      i[s] = dp(s * gh, t, n);
    function o(s) {
      let a = 0, l = 1;
      const c = vd - 1;
      for (; l !== c && i[l] <= s; ++l)
        a += gh;
      --l;
      const u = (s - i[l]) / (i[l + 1] - i[l]), h = a + u * gh, p = vP(h, t, n);
      return p >= j8 ? U8(s, h, t, n) : p === 0 ? h : W8(s, a, a + gh, t, n);
    }
    return (s) => s === 0 || s === 1 ? s : dp(o(s), e, r);
  }
  function q8(t) {
    var e = t.onTap, n = t.onTapStart, r = t.onTapCancel, i = t.whileTap, o = t.visualElement, s = e || n || r || i, a = z.exports.useRef(false), l = z.exports.useRef(null), c = {
      passive: !(n || e || r || y)
    };
    function u() {
      var S;
      (S = l.current) === null || S === void 0 || S.call(l), l.current = null;
    }
    function h() {
      var S;
      return u(), a.current = false, (S = o.animationState) === null || S === void 0 || S.setActive(nt.Tap, false), !XE();
    }
    function p(S, T) {
      !h() || (QE(o.getInstance(), S.target) ? e == null ? void 0 : e(S, T) : r == null ? void 0 : r(S, T));
    }
    function v(S, T) {
      !h() || (r == null ? void 0 : r(S, T));
    }
    function y(S, T) {
      var w;
      u(), !a.current && (a.current = true, l.current = Lm(qa(window, "pointerup", p, c), qa(window, "pointercancel", v, c)), (w = o.animationState) === null || w === void 0 || w.setActive(nt.Tap, true), n == null ? void 0 : n(S, T));
    }
    cp(o, "pointerdown", s ? y : void 0, c), lx(u);
  }
  var bk = /* @__PURE__ */ new Set();
  function G8(t, e, n) {
    t || bk.has(e) || (console.warn(e), n && console.warn(n), bk.add(e));
  }
  var Ly = /* @__PURE__ */ new WeakMap(), S0 = /* @__PURE__ */ new WeakMap(), Y8 = function(t) {
    var e;
    (e = Ly.get(t.target)) === null || e === void 0 || e(t);
  }, X8 = function(t) {
    t.forEach(Y8);
  };
  function Q8(t) {
    var e = t.root, n = Tr(t, [
      "root"
    ]), r = e || document;
    S0.has(r) || S0.set(r, {});
    var i = S0.get(r), o = JSON.stringify(n);
    return i[o] || (i[o] = new IntersectionObserver(X8, ie({
      root: e
    }, n))), i[o];
  }
  function J8(t, e, n) {
    var r = Q8(e);
    return Ly.set(t, n), r.observe(t), function() {
      Ly.delete(t), r.unobserve(t);
    };
  }
  function Z8(t) {
    var e = t.visualElement, n = t.whileInView, r = t.onViewportEnter, i = t.onViewportLeave, o = t.viewport, s = o === void 0 ? {} : o, a = z.exports.useRef({
      hasEnteredView: false,
      isInView: false
    }), l = Boolean(n || r || i);
    s.once && a.current.hasEnteredView && (l = false);
    var c = typeof IntersectionObserver > "u" ? nW : tW;
    c(l, a.current, e, s);
  }
  var eW = {
    some: 0,
    all: 1
  };
  function tW(t, e, n, r) {
    var i = r.root, o = r.margin, s = r.amount, a = s === void 0 ? "some" : s, l = r.once;
    z.exports.useEffect(function() {
      if (!!t) {
        var c = {
          root: i == null ? void 0 : i.current,
          rootMargin: o,
          threshold: typeof a == "number" ? a : eW[a]
        }, u = function(h) {
          var p, v = h.isIntersecting;
          if (e.isInView !== v && (e.isInView = v, !(l && !v && e.hasEnteredView))) {
            v && (e.hasEnteredView = true), (p = n.animationState) === null || p === void 0 || p.setActive(nt.InView, v);
            var y = n.getProps(), S = v ? y.onViewportEnter : y.onViewportLeave;
            S == null ? void 0 : S(h);
          }
        };
        return J8(n.getInstance(), c, u);
      }
    }, [
      t,
      i,
      o,
      a
    ]);
  }
  function nW(t, e, n, r) {
    var i = r.fallback, o = i === void 0 ? true : i;
    z.exports.useEffect(function() {
      !t || !o || (Qb !== "production" && G8(false, "IntersectionObserver not available on this device. whileInView animations will trigger on mount."), requestAnimationFrame(function() {
        var s;
        e.hasEnteredView = true;
        var a = n.getProps().onViewportEnter;
        a == null ? void 0 : a(null), (s = n.animationState) === null || s === void 0 || s.setActive(nt.InView, true);
      }));
    }, [
      t
    ]);
  }
  var Lo = function(t) {
    return function(e) {
      return t(e), null;
    };
  }, rW = {
    inView: Lo(Z8),
    tap: Lo(q8),
    focus: Lo(B6),
    hover: Lo(K6)
  }, iW = 0, oW = function() {
    return iW++;
  }, yP = function() {
    return ef(oW);
  };
  function bP() {
    var t = z.exports.useContext(Ml);
    if (t === null)
      return [
        true,
        null
      ];
    var e = t.isPresent, n = t.onExitComplete, r = t.register, i = yP();
    z.exports.useEffect(function() {
      return r(i);
    }, []);
    var o = function() {
      return n == null ? void 0 : n(i);
    };
    return !e && n ? [
      false,
      o
    ] : [
      true
    ];
  }
  function sW() {
    return aW(z.exports.useContext(Ml));
  }
  function aW(t) {
    return t === null ? true : t.isPresent;
  }
  function xP(t, e) {
    if (!Array.isArray(e))
      return false;
    var n = e.length;
    if (n !== t.length)
      return false;
    for (var r = 0; r < n; r++)
      if (e[r] !== t[r])
        return false;
    return true;
  }
  var pp = function(t) {
    return t * 1e3;
  }, lW = {
    linear: fx,
    easeIn: hx,
    easeInOut: oP,
    easeOut: g8,
    circIn: sP,
    circInOut: v8,
    circOut: dx,
    backIn: px,
    backInOut: b8,
    backOut: y8,
    anticipate: x8,
    bounceIn: C8,
    bounceInOut: T8,
    bounceOut: fp
  }, xk = function(t) {
    if (Array.isArray(t)) {
      op(t.length === 4);
      var e = wt(t, 4), n = e[0], r = e[1], i = e[2], o = e[3];
      return K8(n, r, i, o);
    } else if (typeof t == "string")
      return lW[t];
    return t;
  }, cW = function(t) {
    return Array.isArray(t) && typeof t[0] != "number";
  }, Sk = function(t, e) {
    return t === "zIndex" ? false : !!(typeof e == "number" || Array.isArray(e) || typeof e == "string" && to.test(e) && !e.startsWith("url("));
  }, ds = function() {
    return {
      type: "spring",
      stiffness: 500,
      damping: 25,
      restSpeed: 10
    };
  }, vh = function(t) {
    return {
      type: "spring",
      stiffness: 550,
      damping: t === 0 ? 2 * Math.sqrt(550) : 30,
      restSpeed: 10
    };
  }, w0 = function() {
    return {
      type: "keyframes",
      ease: "linear",
      duration: 0.3
    };
  }, uW = function(t) {
    return {
      type: "keyframes",
      duration: 0.8,
      values: t
    };
  }, wk = {
    x: ds,
    y: ds,
    z: ds,
    rotate: ds,
    rotateX: ds,
    rotateY: ds,
    rotateZ: ds,
    scaleX: vh,
    scaleY: vh,
    scale: vh,
    opacity: w0,
    backgroundColor: w0,
    color: w0,
    default: vh
  }, fW = function(t, e) {
    var n;
    return Pu(e) ? n = uW : n = wk[t] || wk.default, ie({
      to: e
    }, n(e));
  }, hW = ie(ie({}, _E), {
    color: vn,
    backgroundColor: vn,
    outlineColor: vn,
    fill: vn,
    stroke: vn,
    borderColor: vn,
    borderTopColor: vn,
    borderRightColor: vn,
    borderBottomColor: vn,
    borderLeftColor: vn,
    filter: Cy,
    WebkitFilter: Cy
  }), mx = function(t) {
    return hW[t];
  };
  function gx(t, e) {
    var n, r = mx(t);
    return r !== Cy && (r = to), (n = r.getAnimatableNone) === null || n === void 0 ? void 0 : n.call(r, e);
  }
  var dW = {
    current: false
  };
  function pW(t) {
    t.when, t.delay, t.delayChildren, t.staggerChildren, t.staggerDirection, t.repeat, t.repeatType, t.repeatDelay, t.from;
    var e = Tr(t, [
      "when",
      "delay",
      "delayChildren",
      "staggerChildren",
      "staggerDirection",
      "repeat",
      "repeatType",
      "repeatDelay",
      "from"
    ]);
    return !!Object.keys(e).length;
  }
  function mW(t) {
    var e = t.ease, n = t.times, r = t.yoyo, i = t.flip, o = t.loop, s = Tr(t, [
      "ease",
      "times",
      "yoyo",
      "flip",
      "loop"
    ]), a = ie({}, s);
    return n && (a.offset = n), s.duration && (a.duration = pp(s.duration)), s.repeatDelay && (a.repeatDelay = pp(s.repeatDelay)), e && (a.ease = cW(e) ? e.map(xk) : xk(e)), s.type === "tween" && (a.type = "keyframes"), (r || o || i) && (r ? a.repeatType = "reverse" : o ? a.repeatType = "loop" : i && (a.repeatType = "mirror"), a.repeat = o || r || i || s.repeat), s.type !== "spring" && (a.type = "keyframes"), a;
  }
  function gW(t, e) {
    var n, r, i = vx(t, e) || {};
    return (r = (n = i.delay) !== null && n !== void 0 ? n : t.delay) !== null && r !== void 0 ? r : 0;
  }
  function vW(t) {
    return Array.isArray(t.to) && t.to[0] === null && (t.to = jr([], wt(t.to), false), t.to[0] = t.from), t;
  }
  function yW(t, e, n) {
    var r;
    return Array.isArray(e.to) && ((r = t.duration) !== null && r !== void 0 || (t.duration = 0.8)), vW(e), pW(t) || (t = ie(ie({}, t), fW(n, e.to))), ie(ie({}, e), mW(t));
  }
  function bW(t, e, n, r, i) {
    var o, s = vx(r, t), a = (o = s.from) !== null && o !== void 0 ? o : e.get(), l = Sk(t, n);
    a === "none" && l && typeof n == "string" ? a = gx(t, n) : kk(a) && typeof n == "string" ? a = Ck(n) : !Array.isArray(n) && kk(n) && typeof a == "string" && (n = Ck(a));
    var c = Sk(t, a);
    function u() {
      var p = {
        from: a,
        to: n,
        velocity: e.getVelocity(),
        onComplete: i,
        onUpdate: function(v) {
          return e.set(v);
        }
      };
      return s.type === "inertia" || s.type === "decay" ? z8(ie(ie({}, p), s)) : fP(ie(ie({}, yW(s, p, t)), {
        onUpdate: function(v) {
          var y;
          p.onUpdate(v), (y = s.onUpdate) === null || y === void 0 || y.call(s, v);
        },
        onComplete: function() {
          var v;
          p.onComplete(), (v = s.onComplete) === null || v === void 0 || v.call(s);
        }
      }));
    }
    function h() {
      var p, v, y = WE(n);
      return e.set(y), i(), (p = s == null ? void 0 : s.onUpdate) === null || p === void 0 || p.call(s, y), (v = s == null ? void 0 : s.onComplete) === null || v === void 0 || v.call(s), {
        stop: function() {
        }
      };
    }
    return !c || !l || s.type === false ? h : u;
  }
  function kk(t) {
    return t === 0 || typeof t == "string" && parseFloat(t) === 0 && t.indexOf(" ") === -1;
  }
  function Ck(t) {
    return typeof t == "number" ? 0 : gx("", t);
  }
  function vx(t, e) {
    return t[e] || t.default || t;
  }
  function yx(t, e, n, r) {
    return r === void 0 && (r = {}), dW.current && (r = {
      type: false
    }), e.start(function(i) {
      var o, s, a = bW(t, e, n, r, i), l = gW(r, t), c = function() {
        return s = a();
      };
      return l ? o = window.setTimeout(c, pp(l)) : c(), function() {
        clearTimeout(o), s == null ? void 0 : s.stop();
      };
    });
  }
  var xW = function(t) {
    return /^\-?\d*\.?\d+$/.test(t);
  }, SW = function(t) {
    return /^0[^.\s]+$/.test(t);
  };
  function bx(t, e) {
    t.indexOf(e) === -1 && t.push(e);
  }
  function xx(t, e) {
    var n = t.indexOf(e);
    n > -1 && t.splice(n, 1);
  }
  var Wc = function() {
    function t() {
      this.subscriptions = [];
    }
    return t.prototype.add = function(e) {
      var n = this;
      return bx(this.subscriptions, e), function() {
        return xx(n.subscriptions, e);
      };
    }, t.prototype.notify = function(e, n, r) {
      var i = this.subscriptions.length;
      if (!!i)
        if (i === 1)
          this.subscriptions[0](e, n, r);
        else
          for (var o = 0; o < i; o++) {
            var s = this.subscriptions[o];
            s && s(e, n, r);
          }
    }, t.prototype.getSize = function() {
      return this.subscriptions.length;
    }, t.prototype.clear = function() {
      this.subscriptions.length = 0;
    }, t;
  }(), wW = function(t) {
    return !isNaN(parseFloat(t));
  }, kW = function() {
    function t(e) {
      var n = this;
      this.version = "6.5.1", this.timeDelta = 0, this.lastUpdated = 0, this.updateSubscribers = new Wc(), this.velocityUpdateSubscribers = new Wc(), this.renderSubscribers = new Wc(), this.canTrackVelocity = false, this.updateAndNotify = function(r, i) {
        i === void 0 && (i = true), n.prev = n.current, n.current = r;
        var o = hp(), s = o.delta, a = o.timestamp;
        n.lastUpdated !== a && (n.timeDelta = s, n.lastUpdated = a, Ur.postRender(n.scheduleVelocityCheck)), n.prev !== n.current && n.updateSubscribers.notify(n.current), n.velocityUpdateSubscribers.getSize() && n.velocityUpdateSubscribers.notify(n.getVelocity()), i && n.renderSubscribers.notify(n.current);
      }, this.scheduleVelocityCheck = function() {
        return Ur.postRender(n.velocityCheck);
      }, this.velocityCheck = function(r) {
        var i = r.timestamp;
        i !== n.lastUpdated && (n.prev = n.current, n.velocityUpdateSubscribers.notify(n.getVelocity()));
      }, this.hasAnimated = false, this.prev = this.current = e, this.canTrackVelocity = wW(this.current);
    }
    return t.prototype.onChange = function(e) {
      return this.updateSubscribers.add(e);
    }, t.prototype.clearListeners = function() {
      this.updateSubscribers.clear();
    }, t.prototype.onRenderRequest = function(e) {
      return e(this.get()), this.renderSubscribers.add(e);
    }, t.prototype.attach = function(e) {
      this.passiveEffect = e;
    }, t.prototype.set = function(e, n) {
      n === void 0 && (n = true), !n || !this.passiveEffect ? this.updateAndNotify(e, n) : this.passiveEffect(e, this.updateAndNotify);
    }, t.prototype.get = function() {
      return this.current;
    }, t.prototype.getPrevious = function() {
      return this.prev;
    }, t.prototype.getVelocity = function() {
      return this.canTrackVelocity ? hP(parseFloat(this.current) - parseFloat(this.prev), this.timeDelta) : 0;
    }, t.prototype.start = function(e) {
      var n = this;
      return this.stop(), new Promise(function(r) {
        n.hasAnimated = true, n.stopAnimation = e(r);
      }).then(function() {
        return n.clearAnimation();
      });
    }, t.prototype.stop = function() {
      this.stopAnimation && this.stopAnimation(), this.clearAnimation();
    }, t.prototype.isAnimating = function() {
      return !!this.stopAnimation;
    }, t.prototype.clearAnimation = function() {
      this.stopAnimation = null;
    }, t.prototype.destroy = function() {
      this.updateSubscribers.clear(), this.renderSubscribers.clear(), this.stop();
    }, t;
  }();
  function dl(t) {
    return new kW(t);
  }
  var SP = function(t) {
    return function(e) {
      return e.test(t);
    };
  }, CW = {
    test: function(t) {
      return t === "auto";
    },
    parse: function(t) {
      return t;
    }
  }, wP = [
    Js,
    Te,
    Ti,
    go,
    l6,
    a6,
    CW
  ], nc = function(t) {
    return wP.find(SP(t));
  }, TW = jr(jr([], wt(wP), false), [
    vn,
    to
  ], false), MW = function(t) {
    return TW.find(SP(t));
  };
  function AW(t, e, n) {
    t.hasValue(e) ? t.getValue(e).set(n) : t.addValue(e, dl(n));
  }
  function EW(t, e) {
    var n = Em(t, e), r = n ? t.makeTargetAnimatable(n, false) : {}, i = r.transitionEnd, o = i === void 0 ? {} : i;
    r.transition;
    var s = Tr(r, [
      "transitionEnd",
      "transition"
    ]);
    s = ie(ie({}, s), o);
    for (var a in s) {
      var l = WE(s[a]);
      AW(t, a, l);
    }
  }
  function PW(t, e, n) {
    var r, i, o, s, a = Object.keys(e).filter(function(v) {
      return !t.hasValue(v);
    }), l = a.length;
    if (!!l)
      for (var c = 0; c < l; c++) {
        var u = a[c], h = e[u], p = null;
        Array.isArray(h) && (p = h[0]), p === null && (p = (i = (r = n[u]) !== null && r !== void 0 ? r : t.readValue(u)) !== null && i !== void 0 ? i : e[u]), p != null && (typeof p == "string" && (xW(p) || SW(p)) ? p = parseFloat(p) : !MW(p) && to.test(h) && (p = gx(u, h)), t.addValue(u, dl(p)), (o = (s = n)[u]) !== null && o !== void 0 || (s[u] = p), t.setBaseTarget(u, p));
      }
  }
  function OW(t, e) {
    if (!!e) {
      var n = e[t] || e.default || e;
      return n.from;
    }
  }
  function LW(t, e, n) {
    var r, i, o = {};
    for (var s in t)
      o[s] = (r = OW(s, e)) !== null && r !== void 0 ? r : (i = n.getValue(s)) === null || i === void 0 ? void 0 : i.get();
    return o;
  }
  function RW(t, e, n) {
    n === void 0 && (n = {}), t.notifyAnimationStart(e);
    var r;
    if (Array.isArray(e)) {
      var i = e.map(function(s) {
        return Ry(t, s, n);
      });
      r = Promise.all(i);
    } else if (typeof e == "string")
      r = Ry(t, e, n);
    else {
      var o = typeof e == "function" ? Em(t, e, n.custom) : e;
      r = kP(t, o, n);
    }
    return r.then(function() {
      return t.notifyAnimationComplete(e);
    });
  }
  function Ry(t, e, n) {
    var r;
    n === void 0 && (n = {});
    var i = Em(t, e, n.custom), o = (i || {}).transition, s = o === void 0 ? t.getDefaultTransition() || {} : o;
    n.transitionOverride && (s = n.transitionOverride);
    var a = i ? function() {
      return kP(t, i, n);
    } : function() {
      return Promise.resolve();
    }, l = !((r = t.variantChildren) === null || r === void 0) && r.size ? function(v) {
      v === void 0 && (v = 0);
      var y = s.delayChildren, S = y === void 0 ? 0 : y, T = s.staggerChildren, w = s.staggerDirection;
      return _W(t, e, S + v, T, w, n);
    } : function() {
      return Promise.resolve();
    }, c = s.when;
    if (c) {
      var u = wt(c === "beforeChildren" ? [
        a,
        l
      ] : [
        l,
        a
      ], 2), h = u[0], p = u[1];
      return h().then(p);
    } else
      return Promise.all([
        a(),
        l(n.delay)
      ]);
  }
  function kP(t, e, n) {
    var r, i = n === void 0 ? {} : n, o = i.delay, s = o === void 0 ? 0 : o, a = i.transitionOverride, l = i.type, c = t.makeTargetAnimatable(e), u = c.transition, h = u === void 0 ? t.getDefaultTransition() : u, p = c.transitionEnd, v = Tr(c, [
      "transition",
      "transitionEnd"
    ]);
    a && (h = a);
    var y = [], S = l && ((r = t.animationState) === null || r === void 0 ? void 0 : r.getState()[l]);
    for (var T in v) {
      var w = t.getValue(T), k = v[T];
      if (!(!w || k === void 0 || S && IW(S, T))) {
        var C = ie({
          delay: s
        }, h);
        t.shouldReduceMotion && tf(T) && (C = ie(ie({}, C), {
          type: false,
          delay: 0
        }));
        var O = yx(T, w, k, C);
        y.push(O);
      }
    }
    return Promise.all(y).then(function() {
      p && EW(t, p);
    });
  }
  function _W(t, e, n, r, i, o) {
    n === void 0 && (n = 0), r === void 0 && (r = 0), i === void 0 && (i = 1);
    var s = [], a = (t.variantChildren.size - 1) * r, l = i === 1 ? function(c) {
      return c === void 0 && (c = 0), c * r;
    } : function(c) {
      return c === void 0 && (c = 0), a - c * r;
    };
    return Array.from(t.variantChildren).sort(DW).forEach(function(c, u) {
      s.push(Ry(c, e, ie(ie({}, o), {
        delay: n + l(u)
      })).then(function() {
        return c.notifyAnimationComplete(e);
      }));
    }), Promise.all(s);
  }
  function DW(t, e) {
    return t.sortNodePosition(e);
  }
  function IW(t, e) {
    var n = t.protectedKeys, r = t.needsAnimating, i = n.hasOwnProperty(e) && r[e] !== true;
    return r[e] = false, i;
  }
  var Sx = [
    nt.Animate,
    nt.InView,
    nt.Focus,
    nt.Hover,
    nt.Tap,
    nt.Drag,
    nt.Exit
  ], BW = jr([], wt(Sx), false).reverse(), NW = Sx.length;
  function $W(t) {
    return function(e) {
      return Promise.all(e.map(function(n) {
        var r = n.animation, i = n.options;
        return RW(t, r, i);
      }));
    };
  }
  function zW(t) {
    var e = $W(t), n = VW(), r = {}, i = true, o = function(u, h) {
      var p = Em(t, h);
      if (p) {
        p.transition;
        var v = p.transitionEnd, y = Tr(p, [
          "transition",
          "transitionEnd"
        ]);
        u = ie(ie(ie({}, u), y), v);
      }
      return u;
    };
    function s(u) {
      return r[u] !== void 0;
    }
    function a(u) {
      e = u(t);
    }
    function l(u, h) {
      for (var p, v = t.getProps(), y = t.getVariantContext(true) || {}, S = [], T = /* @__PURE__ */ new Set(), w = {}, k = 1 / 0, C = function(R) {
        var F = BW[R], K = n[F], Y = (p = v[F]) !== null && p !== void 0 ? p : y[F], te = Ir(Y), ne = F === h ? K.isActive : null;
        ne === false && (k = R);
        var ae = Y === y[F] && Y !== v[F] && te;
        if (ae && i && t.manuallyAnimateOnMount && (ae = false), K.protectedKeys = ie({}, w), !K.isActive && ne === null || !Y && !K.prevProp || sx(Y) || typeof Y == "boolean")
          return "continue";
        var ye = FW(K.prevProp, Y), Ce = ye || F === h && K.isActive && !ae && te || R > k && te, Le = Array.isArray(Y) ? Y : [
          Y
        ], ee = Le.reduce(o, {});
        ne === false && (ee = {});
        var V = K.prevResolvedValues, oe = V === void 0 ? {} : V, he = ie(ie({}, oe), ee), Se = function(se) {
          Ce = true, T.delete(se), K.needsAnimating[se] = true;
        };
        for (var ve in he) {
          var le = ee[ve], re = oe[ve];
          w.hasOwnProperty(ve) || (le !== re ? Pu(le) && Pu(re) ? !xP(le, re) || ye ? Se(ve) : K.protectedKeys[ve] = true : le !== void 0 ? Se(ve) : T.add(ve) : le !== void 0 && T.has(ve) ? Se(ve) : K.protectedKeys[ve] = true);
        }
        K.prevProp = Y, K.prevResolvedValues = ee, K.isActive && (w = ie(ie({}, w), ee)), i && t.blockInitialAnimation && (Ce = false), Ce && !ae && S.push.apply(S, jr([], wt(Le.map(function(se) {
          return {
            animation: se,
            options: ie({
              type: F
            }, u)
          };
        })), false));
      }, O = 0; O < NW; O++)
        C(O);
      if (r = ie({}, w), T.size) {
        var L = {};
        T.forEach(function(R) {
          var F = t.getBaseTarget(R);
          F !== void 0 && (L[R] = F);
        }), S.push({
          animation: L
        });
      }
      var D = Boolean(S.length);
      return i && v.initial === false && !t.manuallyAnimateOnMount && (D = false), i = false, D ? e(S) : Promise.resolve();
    }
    function c(u, h, p) {
      var v;
      if (n[u].isActive === h)
        return Promise.resolve();
      (v = t.variantChildren) === null || v === void 0 || v.forEach(function(T) {
        var w;
        return (w = T.animationState) === null || w === void 0 ? void 0 : w.setActive(u, h);
      }), n[u].isActive = h;
      var y = l(p, u);
      for (var S in n)
        n[S].protectedKeys = {};
      return y;
    }
    return {
      isAnimated: s,
      animateChanges: l,
      setActive: c,
      setAnimateFunction: a,
      getState: function() {
        return n;
      }
    };
  }
  function FW(t, e) {
    return typeof e == "string" ? e !== t : bE(e) ? !xP(e, t) : false;
  }
  function ps(t) {
    return t === void 0 && (t = false), {
      isActive: t,
      protectedKeys: {},
      needsAnimating: {},
      prevResolvedValues: {}
    };
  }
  function VW() {
    var t;
    return t = {}, t[nt.Animate] = ps(true), t[nt.InView] = ps(), t[nt.Hover] = ps(), t[nt.Tap] = ps(), t[nt.Drag] = ps(), t[nt.Focus] = ps(), t[nt.Exit] = ps(), t;
  }
  var WW = {
    animation: Lo(function(t) {
      var e = t.visualElement, n = t.animate;
      e.animationState || (e.animationState = zW(e)), sx(n) && z.exports.useEffect(function() {
        return n.subscribe(e);
      }, [
        n
      ]);
    }),
    exit: Lo(function(t) {
      var e = t.custom, n = t.visualElement, r = wt(bP(), 2), i = r[0], o = r[1], s = z.exports.useContext(Ml);
      z.exports.useEffect(function() {
        var a, l;
        n.isPresent = i;
        var c = (a = n.animationState) === null || a === void 0 ? void 0 : a.setActive(nt.Exit, !i, {
          custom: (l = s == null ? void 0 : s.custom) !== null && l !== void 0 ? l : e
        });
        !i && (c == null ? void 0 : c.then(o));
      }, [
        i
      ]);
    })
  }, CP = function() {
    function t(e, n, r) {
      var i = this, o = r === void 0 ? {} : r, s = o.transformPagePoint;
      if (this.startEvent = null, this.lastMoveEvent = null, this.lastMoveEventInfo = null, this.handlers = {}, this.updatePoint = function() {
        if (!!(i.lastMoveEvent && i.lastMoveEventInfo)) {
          var p = C0(i.lastMoveEventInfo, i.history), v = i.startEvent !== null, y = dP(p.offset, {
            x: 0,
            y: 0
          }) >= 3;
          if (!(!v && !y)) {
            var S = p.point, T = hp().timestamp;
            i.history.push(ie(ie({}, S), {
              timestamp: T
            }));
            var w = i.handlers, k = w.onStart, C = w.onMove;
            v || (k && k(i.lastMoveEvent, p), i.startEvent = i.lastMoveEvent), C && C(i.lastMoveEvent, p);
          }
        }
      }, this.handlePointerMove = function(p, v) {
        if (i.lastMoveEvent = p, i.lastMoveEventInfo = k0(v, i.transformPagePoint), jE(p) && p.buttons === 0) {
          i.handlePointerUp(p, v);
          return;
        }
        Ur.update(i.updatePoint, true);
      }, this.handlePointerUp = function(p, v) {
        i.end();
        var y = i.handlers, S = y.onEnd, T = y.onSessionEnd, w = C0(k0(v, i.transformPagePoint), i.history);
        i.startEvent && S && S(p, w), T && T(p, w);
      }, !(UE(e) && e.touches.length > 1)) {
        this.handlers = n, this.transformPagePoint = s;
        var a = ax(e), l = k0(a, this.transformPagePoint), c = l.point, u = hp().timestamp;
        this.history = [
          ie(ie({}, c), {
            timestamp: u
          })
        ];
        var h = n.onSessionStart;
        h && h(e, C0(l, this.history)), this.removeListeners = Lm(qa(window, "pointermove", this.handlePointerMove), qa(window, "pointerup", this.handlePointerUp), qa(window, "pointercancel", this.handlePointerUp));
      }
    }
    return t.prototype.updateHandlers = function(e) {
      this.handlers = e;
    }, t.prototype.end = function() {
      this.removeListeners && this.removeListeners(), hl.update(this.updatePoint);
    }, t;
  }();
  function k0(t, e) {
    return e ? {
      point: e(t.point)
    } : t;
  }
  function Tk(t, e) {
    return {
      x: t.x - e.x,
      y: t.y - e.y
    };
  }
  function C0(t, e) {
    var n = t.point;
    return {
      point: n,
      delta: Tk(n, TP(e)),
      offset: Tk(n, HW(e)),
      velocity: jW(e, 0.1)
    };
  }
  function HW(t) {
    return t[0];
  }
  function TP(t) {
    return t[t.length - 1];
  }
  function jW(t, e) {
    if (t.length < 2)
      return {
        x: 0,
        y: 0
      };
    for (var n = t.length - 1, r = null, i = TP(t); n >= 0 && (r = t[n], !(i.timestamp - r.timestamp > pp(e))); )
      n--;
    if (!r)
      return {
        x: 0,
        y: 0
      };
    var o = (i.timestamp - r.timestamp) / 1e3;
    if (o === 0)
      return {
        x: 0,
        y: 0
      };
    var s = {
      x: (i.x - r.x) / o,
      y: (i.y - r.y) / o
    };
    return s.x === 1 / 0 && (s.x = 0), s.y === 1 / 0 && (s.y = 0), s;
  }
  function no(t) {
    return t.max - t.min;
  }
  function Mk(t, e, n) {
    return e === void 0 && (e = 0), n === void 0 && (n = 0.01), dP(t, e) < n;
  }
  function Ak(t, e, n, r) {
    r === void 0 && (r = 0.5), t.origin = r, t.originPoint = St(e.min, e.max, t.origin), t.scale = no(n) / no(e), (Mk(t.scale, 1, 1e-4) || isNaN(t.scale)) && (t.scale = 1), t.translate = St(n.min, n.max, t.origin) - t.originPoint, (Mk(t.translate) || isNaN(t.translate)) && (t.translate = 0);
  }
  function Hc(t, e, n, r) {
    Ak(t.x, e.x, n.x, r == null ? void 0 : r.originX), Ak(t.y, e.y, n.y, r == null ? void 0 : r.originY);
  }
  function Ek(t, e, n) {
    t.min = n.min + e.min, t.max = t.min + no(e);
  }
  function UW(t, e, n) {
    Ek(t.x, e.x, n.x), Ek(t.y, e.y, n.y);
  }
  function Pk(t, e, n) {
    t.min = e.min - n.min, t.max = t.min + no(e);
  }
  function jc(t, e, n) {
    Pk(t.x, e.x, n.x), Pk(t.y, e.y, n.y);
  }
  function KW(t, e, n) {
    var r = e.min, i = e.max;
    return r !== void 0 && t < r ? t = n ? St(r, t, n.min) : Math.max(t, r) : i !== void 0 && t > i && (t = n ? St(i, t, n.max) : Math.min(t, i)), t;
  }
  function Ok(t, e, n) {
    return {
      min: e !== void 0 ? t.min + e : void 0,
      max: n !== void 0 ? t.max + n - (t.max - t.min) : void 0
    };
  }
  function qW(t, e) {
    var n = e.top, r = e.left, i = e.bottom, o = e.right;
    return {
      x: Ok(t.x, r, o),
      y: Ok(t.y, n, i)
    };
  }
  function Lk(t, e) {
    var n, r = e.min - t.min, i = e.max - t.max;
    return e.max - e.min < t.max - t.min && (n = wt([
      i,
      r
    ], 2), r = n[0], i = n[1]), {
      min: r,
      max: i
    };
  }
  function GW(t, e) {
    return {
      x: Lk(t.x, e.x),
      y: Lk(t.y, e.y)
    };
  }
  function YW(t, e) {
    var n = 0.5, r = no(t), i = no(e);
    return i > r ? n = Ou(e.min, e.max - r, t.min) : r > i && (n = Ou(t.min, t.max - i, e.min)), up(0, 1, n);
  }
  function XW(t, e) {
    var n = {};
    return e.min !== void 0 && (n.min = e.min - t.min), e.max !== void 0 && (n.max = e.max - t.min), n;
  }
  var _y = 0.35;
  function QW(t) {
    return t === void 0 && (t = _y), t === false ? t = 0 : t === true && (t = _y), {
      x: Rk(t, "left", "right"),
      y: Rk(t, "top", "bottom")
    };
  }
  function Rk(t, e, n) {
    return {
      min: _k(t, e),
      max: _k(t, n)
    };
  }
  function _k(t, e) {
    var n;
    return typeof t == "number" ? t : (n = t[e]) !== null && n !== void 0 ? n : 0;
  }
  var Dk = function() {
    return {
      translate: 0,
      scale: 1,
      origin: 0,
      originPoint: 0
    };
  }, Uc = function() {
    return {
      x: Dk(),
      y: Dk()
    };
  }, Ik = function() {
    return {
      min: 0,
      max: 0
    };
  }, un = function() {
    return {
      x: Ik(),
      y: Ik()
    };
  };
  function li(t) {
    return [
      t("x"),
      t("y")
    ];
  }
  function MP(t) {
    var e = t.top, n = t.left, r = t.right, i = t.bottom;
    return {
      x: {
        min: n,
        max: r
      },
      y: {
        min: e,
        max: i
      }
    };
  }
  function JW(t) {
    var e = t.x, n = t.y;
    return {
      top: n.min,
      right: e.max,
      bottom: n.max,
      left: e.min
    };
  }
  function ZW(t, e) {
    if (!e)
      return t;
    var n = e({
      x: t.left,
      y: t.top
    }), r = e({
      x: t.right,
      y: t.bottom
    });
    return {
      top: n.y,
      left: n.x,
      bottom: r.y,
      right: r.x
    };
  }
  function T0(t) {
    return t === void 0 || t === 1;
  }
  function AP(t) {
    var e = t.scale, n = t.scaleX, r = t.scaleY;
    return !T0(e) || !T0(n) || !T0(r);
  }
  function vo(t) {
    return AP(t) || Bk(t.x) || Bk(t.y) || t.z || t.rotate || t.rotateX || t.rotateY;
  }
  function Bk(t) {
    return t && t !== "0%";
  }
  function mp(t, e, n) {
    var r = t - n, i = e * r;
    return n + i;
  }
  function Nk(t, e, n, r, i) {
    return i !== void 0 && (t = mp(t, i, r)), mp(t, n, r) + e;
  }
  function Dy(t, e, n, r, i) {
    e === void 0 && (e = 0), n === void 0 && (n = 1), t.min = Nk(t.min, e, n, r, i), t.max = Nk(t.max, e, n, r, i);
  }
  function EP(t, e) {
    var n = e.x, r = e.y;
    Dy(t.x, n.translate, n.scale, n.originPoint), Dy(t.y, r.translate, r.scale, r.originPoint);
  }
  function e9(t, e, n, r) {
    var i, o;
    r === void 0 && (r = false);
    var s = n.length;
    if (!!s) {
      e.x = e.y = 1;
      for (var a, l, c = 0; c < s; c++)
        a = n[c], l = a.projectionDelta, ((o = (i = a.instance) === null || i === void 0 ? void 0 : i.style) === null || o === void 0 ? void 0 : o.display) !== "contents" && (r && a.options.layoutScroll && a.scroll && a !== a.root && Ra(t, {
          x: -a.scroll.x,
          y: -a.scroll.y
        }), l && (e.x *= l.x.scale, e.y *= l.y.scale, EP(t, l)), r && vo(a.latestValues) && Ra(t, a.latestValues));
    }
  }
  function xo(t, e) {
    t.min = t.min + e, t.max = t.max + e;
  }
  function $k(t, e, n) {
    var r = wt(n, 3), i = r[0], o = r[1], s = r[2], a = e[s] !== void 0 ? e[s] : 0.5, l = St(t.min, t.max, a);
    Dy(t, e[i], e[o], l, e.scale);
  }
  var t9 = [
    "x",
    "scaleX",
    "originX"
  ], n9 = [
    "y",
    "scaleY",
    "originY"
  ];
  function Ra(t, e) {
    $k(t.x, e, t9), $k(t.y, e, n9);
  }
  function PP(t, e) {
    return MP(ZW(t.getBoundingClientRect(), e));
  }
  function r9(t, e, n) {
    var r = PP(t, n), i = e.scroll;
    return i && (xo(r.x, i.x), xo(r.y, i.y)), r;
  }
  var i9 = /* @__PURE__ */ new WeakMap(), o9 = function() {
    function t(e) {
      this.openGlobalLock = null, this.isDragging = false, this.currentDirection = null, this.originPoint = {
        x: 0,
        y: 0
      }, this.constraints = false, this.hasMutatedConstraints = false, this.elastic = un(), this.visualElement = e;
    }
    return t.prototype.start = function(e, n) {
      var r = this, i = n === void 0 ? {} : n, o = i.snapToCursor, s = o === void 0 ? false : o;
      if (this.visualElement.isPresent !== false) {
        var a = function(h) {
          r.stopAnimation(), s && r.snapToCursor(ax(h, "page").point);
        }, l = function(h, p) {
          var v, y = r.getProps(), S = y.drag, T = y.dragPropagation, w = y.onDragStart;
          S && !T && (r.openGlobalLock && r.openGlobalLock(), r.openGlobalLock = YE(S), !r.openGlobalLock) || (r.isDragging = true, r.currentDirection = null, r.resolveConstraints(), r.visualElement.projection && (r.visualElement.projection.isAnimationBlocked = true, r.visualElement.projection.target = void 0), li(function(k) {
            var C, O, L = r.getAxisMotionValue(k).get() || 0;
            if (Ti.test(L)) {
              var D = (O = (C = r.visualElement.projection) === null || C === void 0 ? void 0 : C.layout) === null || O === void 0 ? void 0 : O.actual[k];
              if (D) {
                var R = no(D);
                L = R * (parseFloat(L) / 100);
              }
            }
            r.originPoint[k] = L;
          }), w == null ? void 0 : w(h, p), (v = r.visualElement.animationState) === null || v === void 0 || v.setActive(nt.Drag, true));
        }, c = function(h, p) {
          var v = r.getProps(), y = v.dragPropagation, S = v.dragDirectionLock, T = v.onDirectionLock, w = v.onDrag;
          if (!(!y && !r.openGlobalLock)) {
            var k = p.offset;
            if (S && r.currentDirection === null) {
              r.currentDirection = s9(k), r.currentDirection !== null && (T == null ? void 0 : T(r.currentDirection));
              return;
            }
            r.updateAxis("x", p.point, k), r.updateAxis("y", p.point, k), r.visualElement.syncRender(), w == null ? void 0 : w(h, p);
          }
        }, u = function(h, p) {
          return r.stop(h, p);
        };
        this.panSession = new CP(e, {
          onSessionStart: a,
          onStart: l,
          onMove: c,
          onSessionEnd: u
        }, {
          transformPagePoint: this.visualElement.getTransformPagePoint()
        });
      }
    }, t.prototype.stop = function(e, n) {
      var r = this.isDragging;
      if (this.cancel(), !!r) {
        var i = n.velocity;
        this.startAnimation(i);
        var o = this.getProps().onDragEnd;
        o == null ? void 0 : o(e, n);
      }
    }, t.prototype.cancel = function() {
      var e, n;
      this.isDragging = false, this.visualElement.projection && (this.visualElement.projection.isAnimationBlocked = false), (e = this.panSession) === null || e === void 0 || e.end(), this.panSession = void 0;
      var r = this.getProps().dragPropagation;
      !r && this.openGlobalLock && (this.openGlobalLock(), this.openGlobalLock = null), (n = this.visualElement.animationState) === null || n === void 0 || n.setActive(nt.Drag, false);
    }, t.prototype.updateAxis = function(e, n, r) {
      var i = this.getProps().drag;
      if (!(!r || !yh(e, i, this.currentDirection))) {
        var o = this.getAxisMotionValue(e), s = this.originPoint[e] + r[e];
        this.constraints && this.constraints[e] && (s = KW(s, this.constraints[e], this.elastic[e])), o.set(s);
      }
    }, t.prototype.resolveConstraints = function() {
      var e = this, n = this.getProps(), r = n.dragConstraints, i = n.dragElastic, o = (this.visualElement.projection || {}).layout, s = this.constraints;
      r && La(r) ? this.constraints || (this.constraints = this.resolveRefConstraints()) : r && o ? this.constraints = qW(o.actual, r) : this.constraints = false, this.elastic = QW(i), s !== this.constraints && o && this.constraints && !this.hasMutatedConstraints && li(function(a) {
        e.getAxisMotionValue(a) && (e.constraints[a] = XW(o.actual[a], e.constraints[a]));
      });
    }, t.prototype.resolveRefConstraints = function() {
      var e = this.getProps(), n = e.dragConstraints, r = e.onMeasureDragConstraints;
      if (!n || !La(n))
        return false;
      var i = n.current, o = this.visualElement.projection;
      if (!o || !o.layout)
        return false;
      var s = r9(i, o.root, this.visualElement.getTransformPagePoint()), a = GW(o.layout.actual, s);
      if (r) {
        var l = r(JW(a));
        this.hasMutatedConstraints = !!l, l && (a = MP(l));
      }
      return a;
    }, t.prototype.startAnimation = function(e) {
      var n = this, r = this.getProps(), i = r.drag, o = r.dragMomentum, s = r.dragElastic, a = r.dragTransition, l = r.dragSnapToOrigin, c = r.onDragTransitionEnd, u = this.constraints || {}, h = li(function(p) {
        var v;
        if (!!yh(p, i, n.currentDirection)) {
          var y = (v = u == null ? void 0 : u[p]) !== null && v !== void 0 ? v : {};
          l && (y = {
            min: 0,
            max: 0
          });
          var S = s ? 200 : 1e6, T = s ? 40 : 1e7, w = ie(ie({
            type: "inertia",
            velocity: o ? e[p] : 0,
            bounceStiffness: S,
            bounceDamping: T,
            timeConstant: 750,
            restDelta: 1,
            restSpeed: 10
          }, a), y);
          return n.startAxisValueAnimation(p, w);
        }
      });
      return Promise.all(h).then(c);
    }, t.prototype.startAxisValueAnimation = function(e, n) {
      var r = this.getAxisMotionValue(e);
      return yx(e, r, 0, n);
    }, t.prototype.stopAnimation = function() {
      var e = this;
      li(function(n) {
        return e.getAxisMotionValue(n).stop();
      });
    }, t.prototype.getAxisMotionValue = function(e) {
      var n, r, i = "_drag" + e.toUpperCase(), o = this.visualElement.getProps()[i];
      return o || this.visualElement.getValue(e, (r = (n = this.visualElement.getProps().initial) === null || n === void 0 ? void 0 : n[e]) !== null && r !== void 0 ? r : 0);
    }, t.prototype.snapToCursor = function(e) {
      var n = this;
      li(function(r) {
        var i = n.getProps().drag;
        if (!!yh(r, i, n.currentDirection)) {
          var o = n.visualElement.projection, s = n.getAxisMotionValue(r);
          if (o && o.layout) {
            var a = o.layout.actual[r], l = a.min, c = a.max;
            s.set(e[r] - St(l, c, 0.5));
          }
        }
      });
    }, t.prototype.scalePositionWithinConstraints = function() {
      var e = this, n, r = this.getProps(), i = r.drag, o = r.dragConstraints, s = this.visualElement.projection;
      if (!(!La(o) || !s || !this.constraints)) {
        this.stopAnimation();
        var a = {
          x: 0,
          y: 0
        };
        li(function(c) {
          var u = e.getAxisMotionValue(c);
          if (u) {
            var h = u.get();
            a[c] = YW({
              min: h,
              max: h
            }, e.constraints[c]);
          }
        });
        var l = this.visualElement.getProps().transformTemplate;
        this.visualElement.getInstance().style.transform = l ? l({}, "") : "none", (n = s.root) === null || n === void 0 || n.updateScroll(), s.updateLayout(), this.resolveConstraints(), li(function(c) {
          if (!!yh(c, i, null)) {
            var u = e.getAxisMotionValue(c), h = e.constraints[c], p = h.min, v = h.max;
            u.set(St(p, v, a[c]));
          }
        });
      }
    }, t.prototype.addListeners = function() {
      var e = this, n;
      i9.set(this.visualElement, this);
      var r = this.visualElement.getInstance(), i = qa(r, "pointerdown", function(c) {
        var u = e.getProps(), h = u.drag, p = u.dragListener, v = p === void 0 ? true : p;
        h && v && e.start(c);
      }), o = function() {
        var c = e.getProps().dragConstraints;
        La(c) && (e.constraints = e.resolveRefConstraints());
      }, s = this.visualElement.projection, a = s.addEventListener("measure", o);
      s && !s.layout && ((n = s.root) === null || n === void 0 || n.updateScroll(), s.updateLayout()), o();
      var l = Om(window, "resize", function() {
        return e.scalePositionWithinConstraints();
      });
      return s.addEventListener("didUpdate", function(c) {
        var u = c.delta, h = c.hasLayoutChanged;
        e.isDragging && h && (li(function(p) {
          var v = e.getAxisMotionValue(p);
          !v || (e.originPoint[p] += u[p].translate, v.set(v.get() + u[p].translate));
        }), e.visualElement.syncRender());
      }), function() {
        l(), i(), a();
      };
    }, t.prototype.getProps = function() {
      var e = this.visualElement.getProps(), n = e.drag, r = n === void 0 ? false : n, i = e.dragDirectionLock, o = i === void 0 ? false : i, s = e.dragPropagation, a = s === void 0 ? false : s, l = e.dragConstraints, c = l === void 0 ? false : l, u = e.dragElastic, h = u === void 0 ? _y : u, p = e.dragMomentum, v = p === void 0 ? true : p;
      return ie(ie({}, e), {
        drag: r,
        dragDirectionLock: o,
        dragPropagation: a,
        dragConstraints: c,
        dragElastic: h,
        dragMomentum: v
      });
    }, t;
  }();
  function yh(t, e, n) {
    return (e === true || e === t) && (n === null || n === t);
  }
  function s9(t, e) {
    e === void 0 && (e = 10);
    var n = null;
    return Math.abs(t.y) > e ? n = "y" : Math.abs(t.x) > e && (n = "x"), n;
  }
  function a9(t) {
    var e = t.dragControls, n = t.visualElement, r = ef(function() {
      return new o9(n);
    });
    z.exports.useEffect(function() {
      return e && e.subscribe(r);
    }, [
      r,
      e
    ]), z.exports.useEffect(function() {
      return r.addListeners();
    }, [
      r
    ]);
  }
  function l9(t) {
    var e = t.onPan, n = t.onPanStart, r = t.onPanEnd, i = t.onPanSessionStart, o = t.visualElement, s = e || n || r || i, a = z.exports.useRef(null), l = z.exports.useContext(Jb).transformPagePoint, c = {
      onSessionStart: i,
      onStart: n,
      onMove: e,
      onEnd: function(h, p) {
        a.current = null, r && r(h, p);
      }
    };
    z.exports.useEffect(function() {
      a.current !== null && a.current.updateHandlers(c);
    });
    function u(h) {
      a.current = new CP(h, c, {
        transformPagePoint: l
      });
    }
    cp(o, "pointerdown", s && u), lx(function() {
      return a.current && a.current.end();
    });
  }
  var c9 = {
    pan: Lo(l9),
    drag: Lo(a9)
  }, bh = [
    "LayoutMeasure",
    "BeforeLayoutMeasure",
    "LayoutUpdate",
    "ViewportBoxUpdate",
    "Update",
    "Render",
    "AnimationComplete",
    "LayoutAnimationComplete",
    "AnimationStart",
    "LayoutAnimationStart",
    "SetAxisTarget",
    "Unmount"
  ];
  function u9() {
    var t = bh.map(function() {
      return new Wc();
    }), e = {}, n = {
      clearAllListeners: function() {
        return t.forEach(function(r) {
          return r.clear();
        });
      },
      updatePropListeners: function(r) {
        bh.forEach(function(i) {
          var o, s = "on" + i, a = r[s];
          (o = e[i]) === null || o === void 0 || o.call(e), a && (e[i] = n[s](a));
        });
      }
    };
    return t.forEach(function(r, i) {
      n["on" + bh[i]] = function(o) {
        return r.add(o);
      }, n["notify" + bh[i]] = function() {
        for (var o = [], s = 0; s < arguments.length; s++)
          o[s] = arguments[s];
        return r.notify.apply(r, jr([], wt(o), false));
      };
    }), n;
  }
  function f9(t, e, n) {
    var r;
    for (var i in e) {
      var o = e[i], s = n[i];
      if (eo(o))
        t.addValue(i, o);
      else if (eo(s))
        t.addValue(i, dl(o));
      else if (s !== o)
        if (t.hasValue(i)) {
          var a = t.getValue(i);
          !a.hasAnimated && a.set(o);
        } else
          t.addValue(i, dl((r = t.getStaticValue(i)) !== null && r !== void 0 ? r : o));
    }
    for (var i in n)
      e[i] === void 0 && t.removeValue(i);
    return e;
  }
  var OP = function(t) {
    var e = t.treeType, n = e === void 0 ? "" : e, r = t.build, i = t.getBaseTarget, o = t.makeTargetAnimatable, s = t.measureViewportBox, a = t.render, l = t.readValueFromInstance, c = t.removeValueFromRenderState, u = t.sortNodePosition, h = t.scrapeMotionValuesFromProps;
    return function(p, v) {
      var y = p.parent, S = p.props, T = p.presenceId, w = p.blockInitialAnimation, k = p.visualState, C = p.shouldReduceMotion;
      v === void 0 && (v = {});
      var O = false, L = k.latestValues, D = k.renderState, R, F = u9(), K = /* @__PURE__ */ new Map(), Y = /* @__PURE__ */ new Map(), te = {}, ne = ie({}, L), ae;
      function ye() {
        !R || !O || (Ce(), a(R, D, S.style, le.projection));
      }
      function Ce() {
        r(le, D, L, v, S);
      }
      function Le() {
        F.notifyUpdate(L);
      }
      function ee(re, se) {
        var De = se.onChange(function(Mn) {
          L[re] = Mn, S.onUpdate && Ur.update(Le, false, true);
        }), vt = se.onRenderRequest(le.scheduleRender);
        Y.set(re, function() {
          De(), vt();
        });
      }
      var V = h(S);
      for (var oe in V) {
        var he = V[oe];
        L[oe] !== void 0 && eo(he) && he.set(L[oe], false);
      }
      var Se = Pm(S), ve = SE(S), le = ie(ie({
        treeType: n,
        current: null,
        depth: y ? y.depth + 1 : 0,
        parent: y,
        children: /* @__PURE__ */ new Set(),
        presenceId: T,
        shouldReduceMotion: C,
        variantChildren: ve ? /* @__PURE__ */ new Set() : void 0,
        isVisible: void 0,
        manuallyAnimateOnMount: Boolean(y == null ? void 0 : y.isMounted()),
        blockInitialAnimation: w,
        isMounted: function() {
          return Boolean(R);
        },
        mount: function(re) {
          O = true, R = le.current = re, le.projection && le.projection.mount(re), ve && y && !Se && (ae = y == null ? void 0 : y.addVariantChild(le)), K.forEach(function(se, De) {
            return ee(De, se);
          }), y == null ? void 0 : y.children.add(le), le.setProps(S);
        },
        unmount: function() {
          var re;
          (re = le.projection) === null || re === void 0 || re.unmount(), hl.update(Le), hl.render(ye), Y.forEach(function(se) {
            return se();
          }), ae == null ? void 0 : ae(), y == null ? void 0 : y.children.delete(le), F.clearAllListeners(), R = void 0, O = false;
        },
        addVariantChild: function(re) {
          var se, De = le.getClosestVariantNode();
          if (De)
            return (se = De.variantChildren) === null || se === void 0 || se.add(re), function() {
              return De.variantChildren.delete(re);
            };
        },
        sortNodePosition: function(re) {
          return !u || n !== re.treeType ? 0 : u(le.getInstance(), re.getInstance());
        },
        getClosestVariantNode: function() {
          return ve ? le : y == null ? void 0 : y.getClosestVariantNode();
        },
        getLayoutId: function() {
          return S.layoutId;
        },
        getInstance: function() {
          return R;
        },
        getStaticValue: function(re) {
          return L[re];
        },
        setStaticValue: function(re, se) {
          return L[re] = se;
        },
        getLatestValues: function() {
          return L;
        },
        setVisibility: function(re) {
          le.isVisible !== re && (le.isVisible = re, le.scheduleRender());
        },
        makeTargetAnimatable: function(re, se) {
          return se === void 0 && (se = true), o(le, re, S, se);
        },
        measureViewportBox: function() {
          return s(R, S);
        },
        addValue: function(re, se) {
          le.hasValue(re) && le.removeValue(re), K.set(re, se), L[re] = se.get(), ee(re, se);
        },
        removeValue: function(re) {
          var se;
          K.delete(re), (se = Y.get(re)) === null || se === void 0 || se(), Y.delete(re), delete L[re], c(re, D);
        },
        hasValue: function(re) {
          return K.has(re);
        },
        getValue: function(re, se) {
          var De = K.get(re);
          return De === void 0 && se !== void 0 && (De = dl(se), le.addValue(re, De)), De;
        },
        forEachValue: function(re) {
          return K.forEach(re);
        },
        readValue: function(re) {
          var se;
          return (se = L[re]) !== null && se !== void 0 ? se : l(R, re, v);
        },
        setBaseTarget: function(re, se) {
          ne[re] = se;
        },
        getBaseTarget: function(re) {
          if (i) {
            var se = i(S, re);
            if (se !== void 0 && !eo(se))
              return se;
          }
          return ne[re];
        }
      }, F), {
        build: function() {
          return Ce(), D;
        },
        scheduleRender: function() {
          Ur.render(ye, false, true);
        },
        syncRender: ye,
        setProps: function(re) {
          (re.transformTemplate || S.transformTemplate) && le.scheduleRender(), S = re, F.updatePropListeners(re), te = f9(le, h(S), te);
        },
        getProps: function() {
          return S;
        },
        getVariant: function(re) {
          var se;
          return (se = S.variants) === null || se === void 0 ? void 0 : se[re];
        },
        getDefaultTransition: function() {
          return S.transition;
        },
        getTransformPagePoint: function() {
          return S.transformPagePoint;
        },
        getVariantContext: function(re) {
          if (re === void 0 && (re = false), re)
            return y == null ? void 0 : y.getVariantContext();
          if (!Se) {
            var se = (y == null ? void 0 : y.getVariantContext()) || {};
            return S.initial !== void 0 && (se.initial = S.initial), se;
          }
          for (var De = {}, vt = 0; vt < h9; vt++) {
            var Mn = LP[vt], so = S[Mn];
            (Ir(so) || so === false) && (De[Mn] = so);
          }
          return De;
        }
      });
      return le;
    };
  }, LP = jr([
    "initial"
  ], wt(Sx), false), h9 = LP.length;
  function Iy(t) {
    return typeof t == "string" && t.startsWith("var(--");
  }
  var RP = /var\((--[a-zA-Z0-9-_]+),? ?([a-zA-Z0-9 ()%#.,-]+)?\)/;
  function d9(t) {
    var e = RP.exec(t);
    if (!e)
      return [
        ,
      ];
    var n = wt(e, 3), r = n[1], i = n[2];
    return [
      r,
      i
    ];
  }
  function By(t, e, n) {
    var r = wt(d9(t), 2), i = r[0], o = r[1];
    if (!!i) {
      var s = window.getComputedStyle(e).getPropertyValue(i);
      return s ? s.trim() : Iy(o) ? By(o, e) : o;
    }
  }
  function p9(t, e, n) {
    var r, i = Tr(e, []), o = t.getInstance();
    if (!(o instanceof Element))
      return {
        target: i,
        transitionEnd: n
      };
    n && (n = ie({}, n)), t.forEachValue(function(c) {
      var u = c.get();
      if (!!Iy(u)) {
        var h = By(u, o);
        h && c.set(h);
      }
    });
    for (var s in i) {
      var a = i[s];
      if (!!Iy(a)) {
        var l = By(a, o);
        !l || (i[s] = l, n && ((r = n[s]) !== null && r !== void 0 || (n[s] = a)));
      }
    }
    return {
      target: i,
      transitionEnd: n
    };
  }
  var m9 = /* @__PURE__ */ new Set([
    "width",
    "height",
    "top",
    "left",
    "right",
    "bottom",
    "x",
    "y"
  ]), _P = function(t) {
    return m9.has(t);
  }, g9 = function(t) {
    return Object.keys(t).some(_P);
  }, DP = function(t, e) {
    t.set(e, false), t.set(e);
  }, zk = function(t) {
    return t === Js || t === Te;
  }, Fk;
  (function(t) {
    t.width = "width", t.height = "height", t.left = "left", t.right = "right", t.top = "top", t.bottom = "bottom";
  })(Fk || (Fk = {}));
  var Vk = function(t, e) {
    return parseFloat(t.split(", ")[e]);
  }, Wk = function(t, e) {
    return function(n, r) {
      var i = r.transform;
      if (i === "none" || !i)
        return 0;
      var o = i.match(/^matrix3d\((.+)\)$/);
      if (o)
        return Vk(o[1], e);
      var s = i.match(/^matrix\((.+)\)$/);
      return s ? Vk(s[1], t) : 0;
    };
  }, v9 = /* @__PURE__ */ new Set([
    "x",
    "y",
    "z"
  ]), y9 = Au.filter(function(t) {
    return !v9.has(t);
  });
  function b9(t) {
    var e = [];
    return y9.forEach(function(n) {
      var r = t.getValue(n);
      r !== void 0 && (e.push([
        n,
        r.get()
      ]), r.set(n.startsWith("scale") ? 1 : 0));
    }), e.length && t.syncRender(), e;
  }
  var Hk = {
    width: function(t, e) {
      var n = t.x, r = e.paddingLeft, i = r === void 0 ? "0" : r, o = e.paddingRight, s = o === void 0 ? "0" : o;
      return n.max - n.min - parseFloat(i) - parseFloat(s);
    },
    height: function(t, e) {
      var n = t.y, r = e.paddingTop, i = r === void 0 ? "0" : r, o = e.paddingBottom, s = o === void 0 ? "0" : o;
      return n.max - n.min - parseFloat(i) - parseFloat(s);
    },
    top: function(t, e) {
      var n = e.top;
      return parseFloat(n);
    },
    left: function(t, e) {
      var n = e.left;
      return parseFloat(n);
    },
    bottom: function(t, e) {
      var n = t.y, r = e.top;
      return parseFloat(r) + (n.max - n.min);
    },
    right: function(t, e) {
      var n = t.x, r = e.left;
      return parseFloat(r) + (n.max - n.min);
    },
    x: Wk(4, 13),
    y: Wk(5, 14)
  }, x9 = function(t, e, n) {
    var r = e.measureViewportBox(), i = e.getInstance(), o = getComputedStyle(i), s = o.display, a = {};
    s === "none" && e.setStaticValue("display", t.display || "block"), n.forEach(function(c) {
      a[c] = Hk[c](r, o);
    }), e.syncRender();
    var l = e.measureViewportBox();
    return n.forEach(function(c) {
      var u = e.getValue(c);
      DP(u, a[c]), t[c] = Hk[c](l, o);
    }), t;
  }, S9 = function(t, e, n, r) {
    n === void 0 && (n = {}), r === void 0 && (r = {}), e = ie({}, e), r = ie({}, r);
    var i = Object.keys(e).filter(_P), o = [], s = false, a = [];
    if (i.forEach(function(u) {
      var h = t.getValue(u);
      if (!!t.hasValue(u)) {
        var p = n[u], v = nc(p), y = e[u], S;
        if (Pu(y)) {
          var T = y.length, w = y[0] === null ? 1 : 0;
          p = y[w], v = nc(p);
          for (var k = w; k < T; k++)
            S ? op(nc(y[k]) === S) : S = nc(y[k]);
        } else
          S = nc(y);
        if (v !== S)
          if (zk(v) && zk(S)) {
            var C = h.get();
            typeof C == "string" && h.set(parseFloat(C)), typeof y == "string" ? e[u] = parseFloat(y) : Array.isArray(y) && S === Te && (e[u] = y.map(parseFloat));
          } else
            (v == null ? void 0 : v.transform) && (S == null ? void 0 : S.transform) && (p === 0 || y === 0) ? p === 0 ? h.set(S.transform(p)) : e[u] = v.transform(y) : (s || (o = b9(t), s = true), a.push(u), r[u] = r[u] !== void 0 ? r[u] : e[u], DP(h, y));
      }
    }), a.length) {
      var l = a.indexOf("height") >= 0 ? window.pageYOffset : null, c = x9(e, t, a);
      return o.length && o.forEach(function(u) {
        var h = wt(u, 2), p = h[0], v = h[1];
        t.getValue(p).set(v);
      }), t.syncRender(), l !== null && window.scrollTo({
        top: l
      }), {
        target: c,
        transitionEnd: r
      };
    } else
      return {
        target: e,
        transitionEnd: r
      };
  };
  function w9(t, e, n, r) {
    return g9(e) ? S9(t, e, n, r) : {
      target: e,
      transitionEnd: r
    };
  }
  var k9 = function(t, e, n, r) {
    var i = p9(t, e, r);
    return e = i.target, r = i.transitionEnd, w9(t, e, n, r);
  };
  function C9(t) {
    return window.getComputedStyle(t);
  }
  var IP = {
    treeType: "dom",
    readValueFromInstance: function(t, e) {
      if (tf(e)) {
        var n = mx(e);
        return n && n.default || 0;
      } else {
        var r = C9(t);
        return (TE(e) ? r.getPropertyValue(e) : r[e]) || 0;
      }
    },
    sortNodePosition: function(t, e) {
      return t.compareDocumentPosition(e) & 2 ? 1 : -1;
    },
    getBaseTarget: function(t, e) {
      var n;
      return (n = t.style) === null || n === void 0 ? void 0 : n[e];
    },
    measureViewportBox: function(t, e) {
      var n = e.transformPagePoint;
      return PP(t, n);
    },
    resetTransform: function(t, e, n) {
      var r = n.transformTemplate;
      e.style.transform = r ? r({}, "") : "none", t.scheduleRender();
    },
    restoreTransform: function(t, e) {
      t.style.transform = e.style.transform;
    },
    removeValueFromRenderState: function(t, e) {
      var n = e.vars, r = e.style;
      delete n[t], delete r[t];
    },
    makeTargetAnimatable: function(t, e, n, r) {
      var i = n.transformValues;
      r === void 0 && (r = true);
      var o = e.transition, s = e.transitionEnd, a = Tr(e, [
        "transition",
        "transitionEnd"
      ]), l = LW(a, o || {}, t);
      if (i && (s && (s = i(s)), a && (a = i(a)), l && (l = i(l))), r) {
        PW(t, a, l);
        var c = k9(t, a, l, s);
        s = c.transitionEnd, a = c.target;
      }
      return ie({
        transition: o,
        transitionEnd: s
      }, a);
    },
    scrapeMotionValuesFromProps: ox,
    build: function(t, e, n, r, i) {
      t.isVisible !== void 0 && (e.style.visibility = t.isVisible ? "visible" : "hidden"), nx(e, n, r, i.transformTemplate);
    },
    render: $E
  }, T9 = OP(IP), M9 = OP(ie(ie({}, IP), {
    getBaseTarget: function(t, e) {
      return t[e];
    },
    readValueFromInstance: function(t, e) {
      var n;
      return tf(e) ? ((n = mx(e)) === null || n === void 0 ? void 0 : n.default) || 0 : (e = zE.has(e) ? e : NE(e), t.getAttribute(e));
    },
    scrapeMotionValuesFromProps: VE,
    build: function(t, e, n, r, i) {
      ix(e, n, r, i.transformTemplate);
    },
    render: FE
  })), A9 = function(t, e) {
    return ex(t) ? M9(e, {
      enableHardwareAcceleration: false
    }) : T9(e, {
      enableHardwareAcceleration: true
    });
  };
  function jk(t, e) {
    return e.max === e.min ? 0 : t / (e.max - e.min) * 100;
  }
  var rc = {
    correct: function(t, e) {
      if (!e.target)
        return t;
      if (typeof t == "string")
        if (Te.test(t))
          t = parseFloat(t);
        else
          return t;
      var n = jk(t, e.target.x), r = jk(t, e.target.y);
      return "".concat(n, "% ").concat(r, "%");
    }
  }, Uk = "_$css", E9 = {
    correct: function(t, e) {
      var n = e.treeScale, r = e.projectionDelta, i = t, o = t.includes("var("), s = [];
      o && (t = t.replace(RP, function(S) {
        return s.push(S), Uk;
      }));
      var a = to.parse(t);
      if (a.length > 5)
        return i;
      var l = to.createTransformer(t), c = typeof a[0] != "number" ? 1 : 0, u = r.x.scale * n.x, h = r.y.scale * n.y;
      a[0 + c] /= u, a[1 + c] /= h;
      var p = St(u, h, 0.5);
      typeof a[2 + c] == "number" && (a[2 + c] /= p), typeof a[3 + c] == "number" && (a[3 + c] /= p);
      var v = l(a);
      if (o) {
        var y = 0;
        v = v.replace(Uk, function() {
          var S = s[y];
          return y++, S;
        });
      }
      return v;
    }
  }, P9 = function(t) {
    mE(e, t);
    function e() {
      return t !== null && t.apply(this, arguments) || this;
    }
    return e.prototype.componentDidMount = function() {
      var n = this, r = this.props, i = r.visualElement, o = r.layoutGroup, s = r.switchLayoutGroup, a = r.layoutId, l = i.projection;
      QV(L9), l && ((o == null ? void 0 : o.group) && o.group.add(l), (s == null ? void 0 : s.register) && a && s.register(l), l.root.didUpdate(), l.addEventListener("animationComplete", function() {
        n.safeToRemove();
      }), l.setOptions(ie(ie({}, l.options), {
        onExitComplete: function() {
          return n.safeToRemove();
        }
      }))), zc.hasEverUpdated = true;
    }, e.prototype.getSnapshotBeforeUpdate = function(n) {
      var r = this, i = this.props, o = i.layoutDependency, s = i.visualElement, a = i.drag, l = i.isPresent, c = s.projection;
      return c && (c.isPresent = l, a || n.layoutDependency !== o || o === void 0 ? c.willUpdate() : this.safeToRemove(), n.isPresent !== l && (l ? c.promote() : c.relegate() || Ur.postRender(function() {
        var u;
        !((u = c.getStack()) === null || u === void 0) && u.members.length || r.safeToRemove();
      }))), null;
    }, e.prototype.componentDidUpdate = function() {
      var n = this.props.visualElement.projection;
      n && (n.root.didUpdate(), !n.currentAnimation && n.isLead() && this.safeToRemove());
    }, e.prototype.componentWillUnmount = function() {
      var n = this.props, r = n.visualElement, i = n.layoutGroup, o = n.switchLayoutGroup, s = r.projection;
      s && (s.scheduleCheckAfterUnmount(), (i == null ? void 0 : i.group) && i.group.remove(s), (o == null ? void 0 : o.deregister) && o.deregister(s));
    }, e.prototype.safeToRemove = function() {
      var n = this.props.safeToRemove;
      n == null ? void 0 : n();
    }, e.prototype.render = function() {
      return null;
    }, e;
  }(Wp.Component);
  function O9(t) {
    var e = wt(bP(), 2), n = e[0], r = e[1], i = z.exports.useContext(Zb);
    return J(P9, {
      ...ie({}, t, {
        layoutGroup: i,
        switchLayoutGroup: z.exports.useContext(wE),
        isPresent: n,
        safeToRemove: r
      })
    });
  }
  var L9 = {
    borderRadius: ie(ie({}, rc), {
      applyTo: [
        "borderTopLeftRadius",
        "borderTopRightRadius",
        "borderBottomLeftRadius",
        "borderBottomRightRadius"
      ]
    }),
    borderTopLeftRadius: rc,
    borderTopRightRadius: rc,
    borderBottomLeftRadius: rc,
    borderBottomRightRadius: rc,
    boxShadow: E9
  }, R9 = {
    measureLayout: O9
  };
  function _9(t, e, n) {
    n === void 0 && (n = {});
    var r = eo(t) ? t : dl(t);
    return yx("", r, e, n), {
      stop: function() {
        return r.stop();
      },
      isAnimating: function() {
        return r.isAnimating();
      }
    };
  }
  var BP = [
    "TopLeft",
    "TopRight",
    "BottomLeft",
    "BottomRight"
  ], D9 = BP.length, Kk = function(t) {
    return typeof t == "string" ? parseFloat(t) : t;
  }, qk = function(t) {
    return typeof t == "number" || Te.test(t);
  };
  function I9(t, e, n, r, i, o) {
    var s, a, l, c;
    i ? (t.opacity = St(0, (s = n.opacity) !== null && s !== void 0 ? s : 1, B9(r)), t.opacityExit = St((a = e.opacity) !== null && a !== void 0 ? a : 1, 0, N9(r))) : o && (t.opacity = St((l = e.opacity) !== null && l !== void 0 ? l : 1, (c = n.opacity) !== null && c !== void 0 ? c : 1, r));
    for (var u = 0; u < D9; u++) {
      var h = "border".concat(BP[u], "Radius"), p = Gk(e, h), v = Gk(n, h);
      if (!(p === void 0 && v === void 0)) {
        p || (p = 0), v || (v = 0);
        var y = p === 0 || v === 0 || qk(p) === qk(v);
        y ? (t[h] = Math.max(St(Kk(p), Kk(v), r), 0), (Ti.test(v) || Ti.test(p)) && (t[h] += "%")) : t[h] = v;
      }
    }
    (e.rotate || n.rotate) && (t.rotate = St(e.rotate || 0, n.rotate || 0, r));
  }
  function Gk(t, e) {
    var n;
    return (n = t[e]) !== null && n !== void 0 ? n : t.borderRadius;
  }
  var B9 = NP(0, 0.5, dx), N9 = NP(0.5, 0.95, fx);
  function NP(t, e, n) {
    return function(r) {
      return r < t ? 0 : r > e ? 1 : n(Ou(t, e, r));
    };
  }
  function Yk(t, e) {
    t.min = e.min, t.max = e.max;
  }
  function Rr(t, e) {
    Yk(t.x, e.x), Yk(t.y, e.y);
  }
  function Xk(t, e, n, r, i) {
    return t -= e, t = mp(t, 1 / n, r), i !== void 0 && (t = mp(t, 1 / i, r)), t;
  }
  function $9(t, e, n, r, i, o, s) {
    if (e === void 0 && (e = 0), n === void 0 && (n = 1), r === void 0 && (r = 0.5), o === void 0 && (o = t), s === void 0 && (s = t), Ti.test(e)) {
      e = parseFloat(e);
      var a = St(s.min, s.max, e / 100);
      e = a - s.min;
    }
    if (typeof e == "number") {
      var l = St(o.min, o.max, r);
      t === o && (l -= e), t.min = Xk(t.min, e, n, l, i), t.max = Xk(t.max, e, n, l, i);
    }
  }
  function Qk(t, e, n, r, i) {
    var o = wt(n, 3), s = o[0], a = o[1], l = o[2];
    $9(t, e[s], e[a], e[l], e.scale, r, i);
  }
  var z9 = [
    "x",
    "scaleX",
    "originX"
  ], F9 = [
    "y",
    "scaleY",
    "originY"
  ];
  function Jk(t, e, n, r) {
    Qk(t.x, e, z9, n == null ? void 0 : n.x, r == null ? void 0 : r.x), Qk(t.y, e, F9, n == null ? void 0 : n.y, r == null ? void 0 : r.y);
  }
  function Zk(t) {
    return t.translate === 0 && t.scale === 1;
  }
  function $P(t) {
    return Zk(t.x) && Zk(t.y);
  }
  function zP(t, e) {
    return t.x.min === e.x.min && t.x.max === e.x.max && t.y.min === e.y.min && t.y.max === e.y.max;
  }
  var V9 = function() {
    function t() {
      this.members = [];
    }
    return t.prototype.add = function(e) {
      bx(this.members, e), e.scheduleRender();
    }, t.prototype.remove = function(e) {
      if (xx(this.members, e), e === this.prevLead && (this.prevLead = void 0), e === this.lead) {
        var n = this.members[this.members.length - 1];
        n && this.promote(n);
      }
    }, t.prototype.relegate = function(e) {
      var n = this.members.findIndex(function(s) {
        return e === s;
      });
      if (n === 0)
        return false;
      for (var r, i = n; i >= 0; i--) {
        var o = this.members[i];
        if (o.isPresent !== false) {
          r = o;
          break;
        }
      }
      return r ? (this.promote(r), true) : false;
    }, t.prototype.promote = function(e, n) {
      var r, i = this.lead;
      if (e !== i && (this.prevLead = i, this.lead = e, e.show(), i)) {
        i.instance && i.scheduleRender(), e.scheduleRender(), e.resumeFrom = i, n && (e.resumeFrom.preserveOpacity = true), i.snapshot && (e.snapshot = i.snapshot, e.snapshot.latestValues = i.animationValues || i.latestValues, e.snapshot.isShared = true), !((r = e.root) === null || r === void 0) && r.isUpdating && (e.isLayoutDirty = true);
        var o = e.options.crossfade;
        o === false && i.hide();
      }
    }, t.prototype.exitAnimationComplete = function() {
      this.members.forEach(function(e) {
        var n, r, i, o, s;
        (r = (n = e.options).onExitComplete) === null || r === void 0 || r.call(n), (s = (i = e.resumingFrom) === null || i === void 0 ? void 0 : (o = i.options).onExitComplete) === null || s === void 0 || s.call(o);
      });
    }, t.prototype.scheduleRender = function() {
      this.members.forEach(function(e) {
        e.instance && e.scheduleRender(false);
      });
    }, t.prototype.removeLeadSnapshot = function() {
      this.lead && this.lead.snapshot && (this.lead.snapshot = void 0);
    }, t;
  }(), W9 = "translate3d(0px, 0px, 0) scale(1, 1) scale(1, 1)";
  function eC(t, e, n) {
    var r = t.x.translate / e.x, i = t.y.translate / e.y, o = "translate3d(".concat(r, "px, ").concat(i, "px, 0) ");
    if (o += "scale(".concat(1 / e.x, ", ").concat(1 / e.y, ") "), n) {
      var s = n.rotate, a = n.rotateX, l = n.rotateY;
      s && (o += "rotate(".concat(s, "deg) ")), a && (o += "rotateX(".concat(a, "deg) ")), l && (o += "rotateY(".concat(l, "deg) "));
    }
    var c = t.x.scale * e.x, u = t.y.scale * e.y;
    return o += "scale(".concat(c, ", ").concat(u, ")"), o === W9 ? "none" : o;
  }
  var H9 = function(t, e) {
    return t.depth - e.depth;
  }, j9 = function() {
    function t() {
      this.children = [], this.isDirty = false;
    }
    return t.prototype.add = function(e) {
      bx(this.children, e), this.isDirty = true;
    }, t.prototype.remove = function(e) {
      xx(this.children, e), this.isDirty = true;
    }, t.prototype.forEach = function(e) {
      this.isDirty && this.children.sort(H9), this.isDirty = false, this.children.forEach(e);
    }, t;
  }(), tC = 1e3;
  function FP(t) {
    var e = t.attachResizeListener, n = t.defaultParent, r = t.measureScroll, i = t.checkIsScrollRoot, o = t.resetTransform;
    return function() {
      function s(a, l, c) {
        var u = this;
        l === void 0 && (l = {}), c === void 0 && (c = n == null ? void 0 : n()), this.children = /* @__PURE__ */ new Set(), this.options = {}, this.isTreeAnimating = false, this.isAnimationBlocked = false, this.isLayoutDirty = false, this.updateManuallyBlocked = false, this.updateBlockedByResize = false, this.isUpdating = false, this.isSVG = false, this.needsReset = false, this.shouldResetTransform = false, this.treeScale = {
          x: 1,
          y: 1
        }, this.eventHandlers = /* @__PURE__ */ new Map(), this.potentialNodes = /* @__PURE__ */ new Map(), this.checkUpdateFailed = function() {
          u.isUpdating && (u.isUpdating = false, u.clearAllSnapshots());
        }, this.updateProjection = function() {
          u.nodes.forEach(X9), u.nodes.forEach(Q9);
        }, this.hasProjected = false, this.isVisible = true, this.animationProgress = 0, this.sharedNodes = /* @__PURE__ */ new Map(), this.id = a, this.latestValues = l, this.root = c ? c.root || c : this, this.path = c ? jr(jr([], wt(c.path), false), [
          c
        ], false) : [], this.parent = c, this.depth = c ? c.depth + 1 : 0, a && this.root.registerPotentialNode(a, this);
        for (var h = 0; h < this.path.length; h++)
          this.path[h].shouldResetTransform = true;
        this.root === this && (this.nodes = new j9());
      }
      return s.prototype.addEventListener = function(a, l) {
        return this.eventHandlers.has(a) || this.eventHandlers.set(a, new Wc()), this.eventHandlers.get(a).add(l);
      }, s.prototype.notifyListeners = function(a) {
        for (var l = [], c = 1; c < arguments.length; c++)
          l[c - 1] = arguments[c];
        var u = this.eventHandlers.get(a);
        u == null ? void 0 : u.notify.apply(u, jr([], wt(l), false));
      }, s.prototype.hasListeners = function(a) {
        return this.eventHandlers.has(a);
      }, s.prototype.registerPotentialNode = function(a, l) {
        this.potentialNodes.set(a, l);
      }, s.prototype.mount = function(a, l) {
        var c = this, u;
        if (l === void 0 && (l = false), !this.instance) {
          this.isSVG = a instanceof SVGElement && a.tagName !== "svg", this.instance = a;
          var h = this.options, p = h.layoutId, v = h.layout, y = h.visualElement;
          if (y && !y.getInstance() && y.mount(a), this.root.nodes.add(this), (u = this.parent) === null || u === void 0 || u.children.add(this), this.id && this.root.potentialNodes.delete(this.id), l && (v || p) && (this.isLayoutDirty = true), e) {
            var S, T = function() {
              return c.root.updateBlockedByResize = false;
            };
            e(a, function() {
              c.root.updateBlockedByResize = true, clearTimeout(S), S = window.setTimeout(T, 250), zc.hasAnimatedSinceResize && (zc.hasAnimatedSinceResize = false, c.nodes.forEach(Y9));
            });
          }
          p && this.root.registerSharedNode(p, this), this.options.animate !== false && y && (p || v) && this.addEventListener("didUpdate", function(w) {
            var k, C, O, L, D, R = w.delta, F = w.hasLayoutChanged, K = w.hasRelativeTargetChanged, Y = w.layout;
            if (c.isTreeAnimationBlocked()) {
              c.target = void 0, c.relativeTarget = void 0;
              return;
            }
            var te = (C = (k = c.options.transition) !== null && k !== void 0 ? k : y.getDefaultTransition()) !== null && C !== void 0 ? C : nH, ne = y.getProps(), ae = ne.onLayoutAnimationStart, ye = ne.onLayoutAnimationComplete, Ce = !c.targetLayout || !zP(c.targetLayout, Y) || K, Le = !F && K;
            if (((O = c.resumeFrom) === null || O === void 0 ? void 0 : O.instance) || Le || F && (Ce || !c.currentAnimation)) {
              c.resumeFrom && (c.resumingFrom = c.resumeFrom, c.resumingFrom.resumingFrom = void 0), c.setAnimationOrigin(R, Le);
              var ee = ie(ie({}, vx(te, "layout")), {
                onPlay: ae,
                onComplete: ye
              });
              y.shouldReduceMotion && (ee.delay = 0, ee.type = false), c.startAnimation(ee);
            } else
              !F && c.animationProgress === 0 && c.finishAnimation(), c.isLead() && ((D = (L = c.options).onExitComplete) === null || D === void 0 || D.call(L));
            c.targetLayout = Y;
          });
        }
      }, s.prototype.unmount = function() {
        var a, l;
        this.options.layoutId && this.willUpdate(), this.root.nodes.remove(this), (a = this.getStack()) === null || a === void 0 || a.remove(this), (l = this.parent) === null || l === void 0 || l.children.delete(this), this.instance = void 0, hl.preRender(this.updateProjection);
      }, s.prototype.blockUpdate = function() {
        this.updateManuallyBlocked = true;
      }, s.prototype.unblockUpdate = function() {
        this.updateManuallyBlocked = false;
      }, s.prototype.isUpdateBlocked = function() {
        return this.updateManuallyBlocked || this.updateBlockedByResize;
      }, s.prototype.isTreeAnimationBlocked = function() {
        var a;
        return this.isAnimationBlocked || ((a = this.parent) === null || a === void 0 ? void 0 : a.isTreeAnimationBlocked()) || false;
      }, s.prototype.startUpdate = function() {
        var a;
        this.isUpdateBlocked() || (this.isUpdating = true, (a = this.nodes) === null || a === void 0 || a.forEach(J9));
      }, s.prototype.willUpdate = function(a) {
        var l, c, u;
        if (a === void 0 && (a = true), this.root.isUpdateBlocked()) {
          (c = (l = this.options).onExitComplete) === null || c === void 0 || c.call(l);
          return;
        }
        if (!this.root.isUpdating && this.root.startUpdate(), !this.isLayoutDirty) {
          this.isLayoutDirty = true;
          for (var h = 0; h < this.path.length; h++) {
            var p = this.path[h];
            p.shouldResetTransform = true, p.updateScroll();
          }
          var v = this.options, y = v.layoutId, S = v.layout;
          if (!(y === void 0 && !S)) {
            var T = (u = this.options.visualElement) === null || u === void 0 ? void 0 : u.getProps().transformTemplate;
            this.prevTransformTemplateValue = T == null ? void 0 : T(this.latestValues, ""), this.updateSnapshot(), a && this.notifyListeners("willUpdate");
          }
        }
      }, s.prototype.didUpdate = function() {
        var a = this.isUpdateBlocked();
        if (a) {
          this.unblockUpdate(), this.clearAllSnapshots(), this.nodes.forEach(nC);
          return;
        }
        !this.isUpdating || (this.isUpdating = false, this.potentialNodes.size && (this.potentialNodes.forEach(rH), this.potentialNodes.clear()), this.nodes.forEach(G9), this.nodes.forEach(U9), this.nodes.forEach(K9), this.clearAllSnapshots(), x0.update(), x0.preRender(), x0.render());
      }, s.prototype.clearAllSnapshots = function() {
        this.nodes.forEach(q9), this.sharedNodes.forEach(Z9);
      }, s.prototype.scheduleUpdateProjection = function() {
        Ur.preRender(this.updateProjection, false, true);
      }, s.prototype.scheduleCheckAfterUnmount = function() {
        var a = this;
        Ur.postRender(function() {
          a.isLayoutDirty ? a.root.didUpdate() : a.root.checkUpdateFailed();
        });
      }, s.prototype.updateSnapshot = function() {
        if (!(this.snapshot || !this.instance)) {
          var a = this.measure(), l = this.removeTransform(this.removeElementScroll(a));
          sC(l), this.snapshot = {
            measured: a,
            layout: l,
            latestValues: {}
          };
        }
      }, s.prototype.updateLayout = function() {
        var a;
        if (!!this.instance && (this.updateScroll(), !(!(this.options.alwaysMeasureLayout && this.isLead()) && !this.isLayoutDirty))) {
          if (this.resumeFrom && !this.resumeFrom.instance)
            for (var l = 0; l < this.path.length; l++) {
              var c = this.path[l];
              c.updateScroll();
            }
          var u = this.measure();
          sC(u);
          var h = this.layout;
          this.layout = {
            measured: u,
            actual: this.removeElementScroll(u)
          }, this.layoutCorrected = un(), this.isLayoutDirty = false, this.projectionDelta = void 0, this.notifyListeners("measure", this.layout.actual), (a = this.options.visualElement) === null || a === void 0 || a.notifyLayoutMeasure(this.layout.actual, h == null ? void 0 : h.actual);
        }
      }, s.prototype.updateScroll = function() {
        this.options.layoutScroll && this.instance && (this.isScrollRoot = i(this.instance), this.scroll = r(this.instance));
      }, s.prototype.resetTransform = function() {
        var a;
        if (!!o) {
          var l = this.isLayoutDirty || this.shouldResetTransform, c = this.projectionDelta && !$P(this.projectionDelta), u = (a = this.options.visualElement) === null || a === void 0 ? void 0 : a.getProps().transformTemplate, h = u == null ? void 0 : u(this.latestValues, ""), p = h !== this.prevTransformTemplateValue;
          l && (c || vo(this.latestValues) || p) && (o(this.instance, h), this.shouldResetTransform = false, this.scheduleRender());
        }
      }, s.prototype.measure = function() {
        var a = this.options.visualElement;
        if (!a)
          return un();
        var l = a.measureViewportBox(), c = this.root.scroll;
        return c && (xo(l.x, c.x), xo(l.y, c.y)), l;
      }, s.prototype.removeElementScroll = function(a) {
        var l = un();
        Rr(l, a);
        for (var c = 0; c < this.path.length; c++) {
          var u = this.path[c], h = u.scroll, p = u.options, v = u.isScrollRoot;
          if (u !== this.root && h && p.layoutScroll) {
            if (v) {
              Rr(l, a);
              var y = this.root.scroll;
              y && (xo(l.x, -y.x), xo(l.y, -y.y));
            }
            xo(l.x, h.x), xo(l.y, h.y);
          }
        }
        return l;
      }, s.prototype.applyTransform = function(a, l) {
        l === void 0 && (l = false);
        var c = un();
        Rr(c, a);
        for (var u = 0; u < this.path.length; u++) {
          var h = this.path[u];
          !l && h.options.layoutScroll && h.scroll && h !== h.root && Ra(c, {
            x: -h.scroll.x,
            y: -h.scroll.y
          }), vo(h.latestValues) && Ra(c, h.latestValues);
        }
        return vo(this.latestValues) && Ra(c, this.latestValues), c;
      }, s.prototype.removeTransform = function(a) {
        var l, c = un();
        Rr(c, a);
        for (var u = 0; u < this.path.length; u++) {
          var h = this.path[u];
          if (!!h.instance && !!vo(h.latestValues)) {
            AP(h.latestValues) && h.updateSnapshot();
            var p = un(), v = h.measure();
            Rr(p, v), Jk(c, h.latestValues, (l = h.snapshot) === null || l === void 0 ? void 0 : l.layout, p);
          }
        }
        return vo(this.latestValues) && Jk(c, this.latestValues), c;
      }, s.prototype.setTargetDelta = function(a) {
        this.targetDelta = a, this.root.scheduleUpdateProjection();
      }, s.prototype.setOptions = function(a) {
        var l;
        this.options = ie(ie(ie({}, this.options), a), {
          crossfade: (l = a.crossfade) !== null && l !== void 0 ? l : true
        });
      }, s.prototype.clearMeasurements = function() {
        this.scroll = void 0, this.layout = void 0, this.snapshot = void 0, this.prevTransformTemplateValue = void 0, this.targetDelta = void 0, this.target = void 0, this.isLayoutDirty = false;
      }, s.prototype.resolveTargetDelta = function() {
        var a, l = this.options, c = l.layout, u = l.layoutId;
        !this.layout || !(c || u) || (!this.targetDelta && !this.relativeTarget && (this.relativeParent = this.getClosestProjectingParent(), this.relativeParent && this.relativeParent.layout && (this.relativeTarget = un(), this.relativeTargetOrigin = un(), jc(this.relativeTargetOrigin, this.layout.actual, this.relativeParent.layout.actual), Rr(this.relativeTarget, this.relativeTargetOrigin))), !(!this.relativeTarget && !this.targetDelta) && (this.target || (this.target = un(), this.targetWithTransforms = un()), this.relativeTarget && this.relativeTargetOrigin && ((a = this.relativeParent) === null || a === void 0 ? void 0 : a.target) ? UW(this.target, this.relativeTarget, this.relativeParent.target) : this.targetDelta ? (Boolean(this.resumingFrom) ? this.target = this.applyTransform(this.layout.actual) : Rr(this.target, this.layout.actual), EP(this.target, this.targetDelta)) : Rr(this.target, this.layout.actual), this.attemptToResolveRelativeTarget && (this.attemptToResolveRelativeTarget = false, this.relativeParent = this.getClosestProjectingParent(), this.relativeParent && Boolean(this.relativeParent.resumingFrom) === Boolean(this.resumingFrom) && !this.relativeParent.options.layoutScroll && this.relativeParent.target && (this.relativeTarget = un(), this.relativeTargetOrigin = un(), jc(this.relativeTargetOrigin, this.target, this.relativeParent.target), Rr(this.relativeTarget, this.relativeTargetOrigin)))));
      }, s.prototype.getClosestProjectingParent = function() {
        if (!(!this.parent || vo(this.parent.latestValues)))
          return (this.parent.relativeTarget || this.parent.targetDelta) && this.parent.layout ? this.parent : this.parent.getClosestProjectingParent();
      }, s.prototype.calcProjection = function() {
        var a, l = this.options, c = l.layout, u = l.layoutId;
        if (this.isTreeAnimating = Boolean(((a = this.parent) === null || a === void 0 ? void 0 : a.isTreeAnimating) || this.currentAnimation || this.pendingAnimation), this.isTreeAnimating || (this.targetDelta = this.relativeTarget = void 0), !(!this.layout || !(c || u))) {
          var h = this.getLead();
          Rr(this.layoutCorrected, this.layout.actual), e9(this.layoutCorrected, this.treeScale, this.path, Boolean(this.resumingFrom) || this !== h);
          var p = h.target;
          if (!!p) {
            this.projectionDelta || (this.projectionDelta = Uc(), this.projectionDeltaWithTransform = Uc());
            var v = this.treeScale.x, y = this.treeScale.y, S = this.projectionTransform;
            Hc(this.projectionDelta, this.layoutCorrected, p, this.latestValues), this.projectionTransform = eC(this.projectionDelta, this.treeScale), (this.projectionTransform !== S || this.treeScale.x !== v || this.treeScale.y !== y) && (this.hasProjected = true, this.scheduleRender(), this.notifyListeners("projectionUpdate", p));
          }
        }
      }, s.prototype.hide = function() {
        this.isVisible = false;
      }, s.prototype.show = function() {
        this.isVisible = true;
      }, s.prototype.scheduleRender = function(a) {
        var l, c, u;
        a === void 0 && (a = true), (c = (l = this.options).scheduleRender) === null || c === void 0 || c.call(l), a && ((u = this.getStack()) === null || u === void 0 || u.scheduleRender()), this.resumingFrom && !this.resumingFrom.instance && (this.resumingFrom = void 0);
      }, s.prototype.setAnimationOrigin = function(a, l) {
        var c = this, u;
        l === void 0 && (l = false);
        var h = this.snapshot, p = (h == null ? void 0 : h.latestValues) || {}, v = ie({}, this.latestValues), y = Uc();
        this.relativeTarget = this.relativeTargetOrigin = void 0, this.attemptToResolveRelativeTarget = !l;
        var S = un(), T = h == null ? void 0 : h.isShared, w = (((u = this.getStack()) === null || u === void 0 ? void 0 : u.members.length) || 0) <= 1, k = Boolean(T && !w && this.options.crossfade === true && !this.path.some(tH));
        this.animationProgress = 0, this.mixTargetDelta = function(C) {
          var O, L = C / 1e3;
          rC(y.x, a.x, L), rC(y.y, a.y, L), c.setTargetDelta(y), c.relativeTarget && c.relativeTargetOrigin && c.layout && ((O = c.relativeParent) === null || O === void 0 ? void 0 : O.layout) && (jc(S, c.layout.actual, c.relativeParent.layout.actual), eH(c.relativeTarget, c.relativeTargetOrigin, S, L)), T && (c.animationValues = v, I9(v, p, c.latestValues, L, k, w)), c.root.scheduleUpdateProjection(), c.scheduleRender(), c.animationProgress = L;
        }, this.mixTargetDelta(0);
      }, s.prototype.startAnimation = function(a) {
        var l = this, c, u;
        this.notifyListeners("animationStart"), (c = this.currentAnimation) === null || c === void 0 || c.stop(), this.resumingFrom && ((u = this.resumingFrom.currentAnimation) === null || u === void 0 || u.stop()), this.pendingAnimation && (hl.update(this.pendingAnimation), this.pendingAnimation = void 0), this.pendingAnimation = Ur.update(function() {
          zc.hasAnimatedSinceResize = true, l.currentAnimation = _9(0, tC, ie(ie({}, a), {
            onUpdate: function(h) {
              var p;
              l.mixTargetDelta(h), (p = a.onUpdate) === null || p === void 0 || p.call(a, h);
            },
            onComplete: function() {
              var h;
              (h = a.onComplete) === null || h === void 0 || h.call(a), l.completeAnimation();
            }
          })), l.resumingFrom && (l.resumingFrom.currentAnimation = l.currentAnimation), l.pendingAnimation = void 0;
        });
      }, s.prototype.completeAnimation = function() {
        var a;
        this.resumingFrom && (this.resumingFrom.currentAnimation = void 0, this.resumingFrom.preserveOpacity = void 0), (a = this.getStack()) === null || a === void 0 || a.exitAnimationComplete(), this.resumingFrom = this.currentAnimation = this.animationValues = void 0, this.notifyListeners("animationComplete");
      }, s.prototype.finishAnimation = function() {
        var a;
        this.currentAnimation && ((a = this.mixTargetDelta) === null || a === void 0 || a.call(this, tC), this.currentAnimation.stop()), this.completeAnimation();
      }, s.prototype.applyTransformsToTarget = function() {
        var a = this.getLead(), l = a.targetWithTransforms, c = a.target, u = a.layout, h = a.latestValues;
        !l || !c || !u || (Rr(l, c), Ra(l, h), Hc(this.projectionDeltaWithTransform, this.layoutCorrected, l, h));
      }, s.prototype.registerSharedNode = function(a, l) {
        var c, u, h;
        this.sharedNodes.has(a) || this.sharedNodes.set(a, new V9());
        var p = this.sharedNodes.get(a);
        p.add(l), l.promote({
          transition: (c = l.options.initialPromotionConfig) === null || c === void 0 ? void 0 : c.transition,
          preserveFollowOpacity: (h = (u = l.options.initialPromotionConfig) === null || u === void 0 ? void 0 : u.shouldPreserveFollowOpacity) === null || h === void 0 ? void 0 : h.call(u, l)
        });
      }, s.prototype.isLead = function() {
        var a = this.getStack();
        return a ? a.lead === this : true;
      }, s.prototype.getLead = function() {
        var a, l = this.options.layoutId;
        return l ? ((a = this.getStack()) === null || a === void 0 ? void 0 : a.lead) || this : this;
      }, s.prototype.getPrevLead = function() {
        var a, l = this.options.layoutId;
        return l ? (a = this.getStack()) === null || a === void 0 ? void 0 : a.prevLead : void 0;
      }, s.prototype.getStack = function() {
        var a = this.options.layoutId;
        if (a)
          return this.root.sharedNodes.get(a);
      }, s.prototype.promote = function(a) {
        var l = a === void 0 ? {} : a, c = l.needsReset, u = l.transition, h = l.preserveFollowOpacity, p = this.getStack();
        p && p.promote(this, h), c && (this.projectionDelta = void 0, this.needsReset = true), u && this.setOptions({
          transition: u
        });
      }, s.prototype.relegate = function() {
        var a = this.getStack();
        return a ? a.relegate(this) : false;
      }, s.prototype.resetRotation = function() {
        var a = this.options.visualElement;
        if (!!a) {
          for (var l = false, c = {}, u = 0; u < Sy.length; u++) {
            var h = Sy[u], p = "rotate" + h;
            !a.getStaticValue(p) || (l = true, c[p] = a.getStaticValue(p), a.setStaticValue(p, 0));
          }
          if (!!l) {
            a == null ? void 0 : a.syncRender();
            for (var p in c)
              a.setStaticValue(p, c[p]);
            a.scheduleRender();
          }
        }
      }, s.prototype.getProjectionStyles = function(a) {
        var l, c, u, h, p, v;
        a === void 0 && (a = {});
        var y = {};
        if (!this.instance || this.isSVG)
          return y;
        if (this.isVisible)
          y.visibility = "";
        else
          return {
            visibility: "hidden"
          };
        var S = (l = this.options.visualElement) === null || l === void 0 ? void 0 : l.getProps().transformTemplate;
        if (this.needsReset)
          return this.needsReset = false, y.opacity = "", y.pointerEvents = md(a.pointerEvents) || "", y.transform = S ? S(this.latestValues, "") : "none", y;
        var T = this.getLead();
        if (!this.projectionDelta || !this.layout || !T.target) {
          var w = {};
          return this.options.layoutId && (w.opacity = (c = this.latestValues.opacity) !== null && c !== void 0 ? c : 1, w.pointerEvents = md(a.pointerEvents) || ""), this.hasProjected && !vo(this.latestValues) && (w.transform = S ? S({}, "") : "none", this.hasProjected = false), w;
        }
        var k = T.animationValues || T.latestValues;
        this.applyTransformsToTarget(), y.transform = eC(this.projectionDeltaWithTransform, this.treeScale, k), S && (y.transform = S(k, y.transform));
        var C = this.projectionDelta, O = C.x, L = C.y;
        y.transformOrigin = "".concat(O.origin * 100, "% ").concat(L.origin * 100, "% 0"), T.animationValues ? y.opacity = T === this ? (h = (u = k.opacity) !== null && u !== void 0 ? u : this.latestValues.opacity) !== null && h !== void 0 ? h : 1 : this.preserveOpacity ? this.latestValues.opacity : k.opacityExit : y.opacity = T === this ? (p = k.opacity) !== null && p !== void 0 ? p : "" : (v = k.opacityExit) !== null && v !== void 0 ? v : 0;
        for (var D in ap)
          if (k[D] !== void 0) {
            var R = ap[D], F = R.correct, K = R.applyTo, Y = F(k[D], T);
            if (K)
              for (var te = K.length, ne = 0; ne < te; ne++)
                y[K[ne]] = Y;
            else
              y[D] = Y;
          }
        return this.options.layoutId && (y.pointerEvents = T === this ? md(a.pointerEvents) || "" : "none"), y;
      }, s.prototype.clearSnapshot = function() {
        this.resumeFrom = this.snapshot = void 0;
      }, s.prototype.resetTree = function() {
        this.root.nodes.forEach(function(a) {
          var l;
          return (l = a.currentAnimation) === null || l === void 0 ? void 0 : l.stop();
        }), this.root.nodes.forEach(nC), this.root.sharedNodes.clear();
      }, s;
    }();
  }
  function U9(t) {
    t.updateLayout();
  }
  function K9(t) {
    var e, n, r, i, o = (n = (e = t.resumeFrom) === null || e === void 0 ? void 0 : e.snapshot) !== null && n !== void 0 ? n : t.snapshot;
    if (t.isLead() && t.layout && o && t.hasListeners("didUpdate")) {
      var s = t.layout, a = s.actual, l = s.measured;
      t.options.animationType === "size" ? li(function(k) {
        var C = o.isShared ? o.measured[k] : o.layout[k], O = no(C);
        C.min = a[k].min, C.max = C.min + O;
      }) : t.options.animationType === "position" && li(function(k) {
        var C = o.isShared ? o.measured[k] : o.layout[k], O = no(a[k]);
        C.max = C.min + O;
      });
      var c = Uc();
      Hc(c, a, o.layout);
      var u = Uc();
      o.isShared ? Hc(u, t.applyTransform(l, true), o.measured) : Hc(u, a, o.layout);
      var h = !$P(c), p = false;
      if (!t.resumeFrom && (t.relativeParent = t.getClosestProjectingParent(), t.relativeParent && !t.relativeParent.resumeFrom)) {
        var v = t.relativeParent, y = v.snapshot, S = v.layout;
        if (y && S) {
          var T = un();
          jc(T, o.layout, y.layout);
          var w = un();
          jc(w, a, S.actual), zP(T, w) || (p = true);
        }
      }
      t.notifyListeners("didUpdate", {
        layout: a,
        snapshot: o,
        delta: u,
        layoutDelta: c,
        hasLayoutChanged: h,
        hasRelativeTargetChanged: p
      });
    } else
      t.isLead() && ((i = (r = t.options).onExitComplete) === null || i === void 0 || i.call(r));
    t.options.transition = void 0;
  }
  function q9(t) {
    t.clearSnapshot();
  }
  function nC(t) {
    t.clearMeasurements();
  }
  function G9(t) {
    var e = t.options.visualElement;
    (e == null ? void 0 : e.getProps().onBeforeLayoutMeasure) && e.notifyBeforeLayoutMeasure(), t.resetTransform();
  }
  function Y9(t) {
    t.finishAnimation(), t.targetDelta = t.relativeTarget = t.target = void 0;
  }
  function X9(t) {
    t.resolveTargetDelta();
  }
  function Q9(t) {
    t.calcProjection();
  }
  function J9(t) {
    t.resetRotation();
  }
  function Z9(t) {
    t.removeLeadSnapshot();
  }
  function rC(t, e, n) {
    t.translate = St(e.translate, 0, n), t.scale = St(e.scale, 1, n), t.origin = e.origin, t.originPoint = e.originPoint;
  }
  function iC(t, e, n, r) {
    t.min = St(e.min, n.min, r), t.max = St(e.max, n.max, r);
  }
  function eH(t, e, n, r) {
    iC(t.x, e.x, n.x, r), iC(t.y, e.y, n.y, r);
  }
  function tH(t) {
    return t.animationValues && t.animationValues.opacityExit !== void 0;
  }
  var nH = {
    duration: 0.45,
    ease: [
      0.4,
      0,
      0.1,
      1
    ]
  };
  function rH(t, e) {
    for (var n = t.root, r = t.path.length - 1; r >= 0; r--)
      if (Boolean(t.path[r].instance)) {
        n = t.path[r];
        break;
      }
    var i = n && n !== t.root ? n.instance : document, o = i.querySelector('[data-projection-id="'.concat(e, '"]'));
    o && t.mount(o, true);
  }
  function oC(t) {
    t.min = Math.round(t.min), t.max = Math.round(t.max);
  }
  function sC(t) {
    oC(t.x), oC(t.y);
  }
  var iH = FP({
    attachResizeListener: function(t, e) {
      return Om(t, "resize", e);
    },
    measureScroll: function() {
      return {
        x: document.documentElement.scrollLeft || document.body.scrollLeft,
        y: document.documentElement.scrollTop || document.body.scrollTop
      };
    },
    checkIsScrollRoot: function() {
      return true;
    }
  }), M0 = {
    current: void 0
  }, oH = FP({
    measureScroll: function(t) {
      return {
        x: t.scrollLeft,
        y: t.scrollTop
      };
    },
    defaultParent: function() {
      if (!M0.current) {
        var t = new iH(0, {});
        t.mount(window), t.setOptions({
          layoutScroll: true
        }), M0.current = t;
      }
      return M0.current;
    },
    resetTransform: function(t, e) {
      t.style.transform = e ?? "none";
    },
    checkIsScrollRoot: function(t) {
      return Boolean(window.getComputedStyle(t).position === "fixed");
    }
  }), sH = ie(ie(ie(ie({}, WW), rW), c9), R9), aH = YV(function(t, e) {
    return I6(t, e, sH, A9, oH);
  });
  function VP() {
    var t = z.exports.useRef(false);
    return sp(function() {
      return t.current = true, function() {
        t.current = false;
      };
    }, []), t;
  }
  function lH() {
    var t = VP(), e = wt(z.exports.useState(0), 2), n = e[0], r = e[1], i = z.exports.useCallback(function() {
      t.current && r(n + 1);
    }, [
      n
    ]), o = z.exports.useCallback(function() {
      return Ur.postRender(i);
    }, [
      i
    ]);
    return [
      o,
      n
    ];
  }
  var A0 = function(t) {
    var e = t.children, n = t.initial, r = t.isPresent, i = t.onExitComplete, o = t.custom, s = t.presenceAffectsLayout, a = ef(cH), l = yP(), c = z.exports.useMemo(function() {
      return {
        id: l,
        initial: n,
        isPresent: r,
        custom: o,
        onExitComplete: function(u) {
          var h, p;
          a.set(u, true);
          try {
            for (var v = AV(a.values()), y = v.next(); !y.done; y = v.next()) {
              var S = y.value;
              if (!S)
                return;
            }
          } catch (T) {
            h = {
              error: T
            };
          } finally {
            try {
              y && !y.done && (p = v.return) && p.call(v);
            } finally {
              if (h)
                throw h.error;
            }
          }
          i == null ? void 0 : i();
        },
        register: function(u) {
          return a.set(u, false), function() {
            return a.delete(u);
          };
        }
      };
    }, s ? void 0 : [
      r
    ]);
    return z.exports.useMemo(function() {
      a.forEach(function(u, h) {
        return a.set(h, false);
      });
    }, [
      r
    ]), z.exports.useEffect(function() {
      !r && !a.size && (i == null ? void 0 : i());
    }, [
      r
    ]), J(Ml.Provider, {
      value: c,
      children: e
    });
  };
  function cH() {
    return /* @__PURE__ */ new Map();
  }
  var ua = function(t) {
    return t.key || "";
  };
  function uH(t, e) {
    t.forEach(function(n) {
      var r = ua(n);
      e.set(r, n);
    });
  }
  function fH(t) {
    var e = [];
    return z.exports.Children.forEach(t, function(n) {
      z.exports.isValidElement(n) && e.push(n);
    }), e;
  }
  var hH = function(t) {
    var e = t.children, n = t.custom, r = t.initial, i = r === void 0 ? true : r, o = t.onExitComplete, s = t.exitBeforeEnter, a = t.presenceAffectsLayout, l = a === void 0 ? true : a, c = wt(lH(), 1), u = c[0], h = z.exports.useContext(Zb).forceRender;
    h && (u = h);
    var p = VP(), v = fH(e), y = v, S = /* @__PURE__ */ new Set(), T = z.exports.useRef(y), w = z.exports.useRef(/* @__PURE__ */ new Map()).current, k = z.exports.useRef(true);
    if (sp(function() {
      k.current = false, uH(v, w), T.current = y;
    }), lx(function() {
      k.current = true, w.clear(), S.clear();
    }), k.current)
      return J(rp, {
        children: y.map(function(F) {
          return J(A0, {
            isPresent: true,
            initial: i ? void 0 : false,
            presenceAffectsLayout: l,
            children: F
          }, ua(F));
        })
      });
    y = jr([], wt(y), false);
    for (var C = T.current.map(ua), O = v.map(ua), L = C.length, D = 0; D < L; D++) {
      var R = C[D];
      O.indexOf(R) === -1 && S.add(R);
    }
    return s && S.size && (y = []), S.forEach(function(F) {
      if (O.indexOf(F) === -1) {
        var K = w.get(F);
        if (!!K) {
          var Y = C.indexOf(F), te = function() {
            w.delete(F), S.delete(F);
            var ne = T.current.findIndex(function(ae) {
              return ae.key === F;
            });
            if (T.current.splice(ne, 1), !S.size) {
              if (T.current = v, p.current === false)
                return;
              u(), o && o();
            }
          };
          y.splice(Y, 0, J(A0, {
            isPresent: false,
            onExitComplete: te,
            custom: n,
            presenceAffectsLayout: l,
            children: K
          }, ua(K)));
        }
      }
    }), y = y.map(function(F) {
      var K = F.key;
      return S.has(K) ? F : J(A0, {
        isPresent: true,
        presenceAffectsLayout: l,
        children: F
      }, ua(F));
    }), Qb !== "production" && s && y.length > 1 && console.warn("You're attempting to animate multiple children within AnimatePresence, but its exitBeforeEnter prop is set to true. This will lead to odd visual behaviour."), J(rp, {
      children: S.size ? y : y.map(function(F) {
        return z.exports.cloneElement(F);
      })
    });
  };
  const dH = (t, e) => t.find((n) => n.id === e);
  function aC(t, e) {
    const n = WP(t, e), r = n ? t[n].findIndex((i) => i.id === e) : -1;
    return {
      position: n,
      index: r
    };
  }
  function WP(t, e) {
    for (const [n, r] of Object.entries(t))
      if (dH(r, e))
        return n;
  }
  function pH(t) {
    const e = t.includes("right"), n = t.includes("left");
    let r = "center";
    return e && (r = "flex-end"), n && (r = "flex-start"), {
      display: "flex",
      flexDirection: "column",
      alignItems: r
    };
  }
  function mH(t) {
    const n = t === "top" || t === "bottom" ? "0 auto" : void 0, r = t.includes("top") ? "env(safe-area-inset-top, 0px)" : void 0, i = t.includes("bottom") ? "env(safe-area-inset-bottom, 0px)" : void 0, o = t.includes("left") ? void 0 : "env(safe-area-inset-right, 0px)", s = t.includes("right") ? void 0 : "env(safe-area-inset-left, 0px)";
    return {
      position: "fixed",
      zIndex: "var(--toast-z-index, 5500)",
      pointerEvents: "none",
      display: "flex",
      flexDirection: "column",
      margin: n,
      top: r,
      bottom: i,
      right: o,
      left: s
    };
  }
  var gH = /^((children|dangerouslySetInnerHTML|key|ref|autoFocus|defaultValue|defaultChecked|innerHTML|suppressContentEditableWarning|suppressHydrationWarning|valueLink|abbr|accept|acceptCharset|accessKey|action|allow|allowUserMedia|allowPaymentRequest|allowFullScreen|allowTransparency|alt|async|autoComplete|autoPlay|capture|cellPadding|cellSpacing|challenge|charSet|checked|cite|classID|className|cols|colSpan|content|contentEditable|contextMenu|controls|controlsList|coords|crossOrigin|data|dateTime|decoding|default|defer|dir|disabled|disablePictureInPicture|disableRemotePlayback|download|draggable|encType|enterKeyHint|fetchpriority|fetchPriority|form|formAction|formEncType|formMethod|formNoValidate|formTarget|frameBorder|headers|height|hidden|high|href|hrefLang|htmlFor|httpEquiv|id|inputMode|integrity|is|keyParams|keyType|kind|label|lang|list|loading|loop|low|marginHeight|marginWidth|max|maxLength|media|mediaGroup|method|min|minLength|multiple|muted|name|nonce|noValidate|open|optimum|pattern|placeholder|playsInline|popover|popoverTarget|popoverTargetAction|poster|preload|profile|radioGroup|readOnly|referrerPolicy|rel|required|reversed|role|rows|rowSpan|sandbox|scope|scoped|scrolling|seamless|selected|shape|size|sizes|slot|span|spellCheck|src|srcDoc|srcLang|srcSet|start|step|style|summary|tabIndex|target|title|translate|type|useMap|value|width|wmode|wrap|about|datatype|inlist|prefix|property|resource|typeof|vocab|autoCapitalize|autoCorrect|autoSave|color|incremental|fallback|inert|itemProp|itemScope|itemType|itemID|itemRef|on|option|results|security|unselectable|accentHeight|accumulate|additive|alignmentBaseline|allowReorder|alphabetic|amplitude|arabicForm|ascent|attributeName|attributeType|autoReverse|azimuth|baseFrequency|baselineShift|baseProfile|bbox|begin|bias|by|calcMode|capHeight|clip|clipPathUnits|clipPath|clipRule|colorInterpolation|colorInterpolationFilters|colorProfile|colorRendering|contentScriptType|contentStyleType|cursor|cx|cy|d|decelerate|descent|diffuseConstant|direction|display|divisor|dominantBaseline|dur|dx|dy|edgeMode|elevation|enableBackground|end|exponent|externalResourcesRequired|fill|fillOpacity|fillRule|filter|filterRes|filterUnits|floodColor|floodOpacity|focusable|fontFamily|fontSize|fontSizeAdjust|fontStretch|fontStyle|fontVariant|fontWeight|format|from|fr|fx|fy|g1|g2|glyphName|glyphOrientationHorizontal|glyphOrientationVertical|glyphRef|gradientTransform|gradientUnits|hanging|horizAdvX|horizOriginX|ideographic|imageRendering|in|in2|intercept|k|k1|k2|k3|k4|kernelMatrix|kernelUnitLength|kerning|keyPoints|keySplines|keyTimes|lengthAdjust|letterSpacing|lightingColor|limitingConeAngle|local|markerEnd|markerMid|markerStart|markerHeight|markerUnits|markerWidth|mask|maskContentUnits|maskUnits|mathematical|mode|numOctaves|offset|opacity|operator|order|orient|orientation|origin|overflow|overlinePosition|overlineThickness|panose1|paintOrder|pathLength|patternContentUnits|patternTransform|patternUnits|pointerEvents|points|pointsAtX|pointsAtY|pointsAtZ|preserveAlpha|preserveAspectRatio|primitiveUnits|r|radius|refX|refY|renderingIntent|repeatCount|repeatDur|requiredExtensions|requiredFeatures|restart|result|rotate|rx|ry|scale|seed|shapeRendering|slope|spacing|specularConstant|specularExponent|speed|spreadMethod|startOffset|stdDeviation|stemh|stemv|stitchTiles|stopColor|stopOpacity|strikethroughPosition|strikethroughThickness|string|stroke|strokeDasharray|strokeDashoffset|strokeLinecap|strokeLinejoin|strokeMiterlimit|strokeOpacity|strokeWidth|surfaceScale|systemLanguage|tableValues|targetX|targetY|textAnchor|textDecoration|textRendering|textLength|to|transform|u1|u2|underlinePosition|underlineThickness|unicode|unicodeBidi|unicodeRange|unitsPerEm|vAlphabetic|vHanging|vIdeographic|vMathematical|values|vectorEffect|version|vertAdvY|vertOriginX|vertOriginY|viewBox|viewTarget|visibility|widths|wordSpacing|writingMode|x|xHeight|x1|x2|xChannelSelector|xlinkActuate|xlinkArcrole|xlinkHref|xlinkRole|xlinkShow|xlinkTitle|xlinkType|xmlBase|xmlns|xmlnsXlink|xmlLang|xmlSpace|y|y1|y2|yChannelSelector|z|zoomAndPan|for|class|autofocus)|(([Dd][Aa][Tt][Aa]|[Aa][Rr][Ii][Aa]|x)-.*))$/, vH = ZA(function(t) {
    return gH.test(t) || t.charCodeAt(0) === 111 && t.charCodeAt(1) === 110 && t.charCodeAt(2) < 91;
  }), yH = false, bH = vH, xH = function(e) {
    return e !== "theme";
  }, lC = function(e) {
    return typeof e == "string" && e.charCodeAt(0) > 96 ? bH : xH;
  }, cC = function(e, n, r) {
    var i;
    if (n) {
      var o = n.shouldForwardProp;
      i = e.__emotion_forwardProp && o ? function(s) {
        return e.__emotion_forwardProp(s) && o(s);
      } : o;
    }
    return typeof i != "function" && r && (i = e.__emotion_forwardProp), i;
  }, SH = function(e) {
    var n = e.cache, r = e.serialized, i = e.isStringTag;
    return jb(n, r, i), lE(function() {
      return Ub(n, r, i);
    }), null;
  }, wH = function t(e, n) {
    var r = e.__emotion_real === e, i = r && e.__emotion_base || e, o, s;
    n !== void 0 && (o = n.label, s = n.target);
    var a = cC(e, n, r), l = a || lC(i), c = !l("as");
    return function() {
      var u = arguments, h = r && e.__emotion_styles !== void 0 ? e.__emotion_styles.slice(0) : [];
      if (o !== void 0 && h.push("label:" + o + ";"), u[0] == null || u[0].raw === void 0)
        h.push.apply(h, u);
      else {
        var p = u[0];
        h.push(p[0]);
        for (var v = u.length, y = 1; y < v; y++)
          h.push(u[y], p[y]);
      }
      var S = qb(function(T, w, k) {
        var C = c && T.as || i, O = "", L = [], D = T;
        if (T.theme == null) {
          D = {};
          for (var R in T)
            D[R] = T[R];
          D.theme = z.exports.useContext(fl);
        }
        typeof T.className == "string" ? O = oE(w.registered, L, T.className) : T.className != null && (O = T.className + " ");
        var F = Tm(h.concat(L), w.registered, D);
        O += w.key + "-" + F.name, s !== void 0 && (O += " " + s);
        var K = c && a === void 0 ? lC(C) : l, Y = {};
        for (var te in T)
          c && te === "as" || K(te) && (Y[te] = T[te]);
        return Y.className = O, k && (Y.ref = k), Yn(rp, {
          children: [
            J(SH, {
              cache: w,
              serialized: F,
              isStringTag: typeof C == "string"
            }),
            J(C, {
              ...Y
            })
          ]
        });
      });
      return S.displayName = o !== void 0 ? o : "Styled(" + (typeof i == "string" ? i : i.displayName || i.name || "Component") + ")", S.defaultProps = e.defaultProps, S.__emotion_real = S, S.__emotion_base = i, S.__emotion_styles = h, S.__emotion_forwardProp = a, Object.defineProperty(S, "toString", {
        value: function() {
          return s === void 0 && yH ? "NO_COMPONENT_SELECTOR" : "." + s;
        }
      }), S.withComponent = function(T, w) {
        var k = t(T, Cu({}, n, w, {
          shouldForwardProp: cC(S, w, true)
        }));
        return k.apply(void 0, h);
      }, S;
    };
  }, kH = [
    "a",
    "abbr",
    "address",
    "area",
    "article",
    "aside",
    "audio",
    "b",
    "base",
    "bdi",
    "bdo",
    "big",
    "blockquote",
    "body",
    "br",
    "button",
    "canvas",
    "caption",
    "cite",
    "code",
    "col",
    "colgroup",
    "data",
    "datalist",
    "dd",
    "del",
    "details",
    "dfn",
    "dialog",
    "div",
    "dl",
    "dt",
    "em",
    "embed",
    "fieldset",
    "figcaption",
    "figure",
    "footer",
    "form",
    "h1",
    "h2",
    "h3",
    "h4",
    "h5",
    "h6",
    "head",
    "header",
    "hgroup",
    "hr",
    "html",
    "i",
    "iframe",
    "img",
    "input",
    "ins",
    "kbd",
    "keygen",
    "label",
    "legend",
    "li",
    "link",
    "main",
    "map",
    "mark",
    "marquee",
    "menu",
    "menuitem",
    "meta",
    "meter",
    "nav",
    "noscript",
    "object",
    "ol",
    "optgroup",
    "option",
    "output",
    "p",
    "param",
    "picture",
    "pre",
    "progress",
    "q",
    "rp",
    "rt",
    "ruby",
    "s",
    "samp",
    "script",
    "section",
    "select",
    "small",
    "source",
    "span",
    "strong",
    "style",
    "sub",
    "summary",
    "sup",
    "table",
    "tbody",
    "td",
    "textarea",
    "tfoot",
    "th",
    "thead",
    "time",
    "title",
    "tr",
    "track",
    "u",
    "ul",
    "var",
    "video",
    "wbr",
    "circle",
    "clipPath",
    "defs",
    "ellipse",
    "foreignObject",
    "g",
    "image",
    "line",
    "linearGradient",
    "mask",
    "path",
    "pattern",
    "polygon",
    "polyline",
    "radialGradient",
    "rect",
    "stop",
    "svg",
    "text",
    "tspan"
  ], Ny = wH.bind(null);
  kH.forEach(function(t) {
    Ny[t] = Ny(t);
  });
  const CH = /* @__PURE__ */ new Set([
    ...TB,
    "textStyle",
    "layerStyle",
    "apply",
    "noOfLines",
    "focusBorderColor",
    "errorBorderColor",
    "as",
    "__css",
    "css",
    "sx"
  ]), TH = /* @__PURE__ */ new Set([
    "htmlWidth",
    "htmlHeight",
    "htmlSize",
    "htmlTranslate"
  ]);
  function MH(t) {
    return (TH.has(t) || !CH.has(t)) && t[0] !== "_";
  }
  const AH = $I(Ny), EH = ({ baseStyle: t }) => (e) => {
    const { theme: n, css: r, __css: i, sx: o, ...s } = e, [a] = HI(s, AB), l = vi(t, e), c = MI({}, i, l, DI(a), o), u = MA(c)(e.theme);
    return r ? [
      u,
      r
    ] : u;
  };
  function E0(t, e) {
    const { baseStyle: n, ...r } = e ?? {};
    r.shouldForwardProp || (r.shouldForwardProp = MH);
    const i = EH({
      baseStyle: n
    }), o = AH(t, r)(i);
    return z.exports.forwardRef(function(l, c) {
      const { children: u, ...h } = l, { colorMode: p, forced: v } = Xb(), y = v ? p : void 0;
      return z.exports.createElement(o, {
        ref: c,
        "data-theme": y,
        ...h
      }, u);
    });
  }
  function PH() {
    const t = /* @__PURE__ */ new Map();
    return new Proxy(E0, {
      apply(e, n, r) {
        return E0(...r);
      },
      get(e, n) {
        return t.has(n) || t.set(n, E0(n)), t.get(n);
      }
    });
  }
  const on = PH(), OH = {
    initial: (t) => {
      const { position: e } = t, n = [
        "top",
        "bottom"
      ].includes(e) ? "y" : "x";
      let r = [
        "top-right",
        "bottom-right"
      ].includes(e) ? 1 : -1;
      return e === "bottom" && (r = 1), {
        opacity: 0,
        [n]: r * 24
      };
    },
    animate: {
      opacity: 1,
      y: 0,
      x: 0,
      scale: 1,
      transition: {
        duration: 0.4,
        ease: [
          0.4,
          0,
          0.2,
          1
        ]
      }
    },
    exit: {
      opacity: 0,
      scale: 0.85,
      transition: {
        duration: 0.2,
        ease: [
          0.4,
          0,
          1,
          1
        ]
      }
    }
  }, HP = z.exports.memo((t) => {
    const { id: e, message: n, onCloseComplete: r, onRequestRemove: i, requestClose: o = false, position: s = "bottom", duration: a = 5e3, containerStyle: l, motionVariants: c = OH, toastSpacing: u = "0.5rem" } = t, [h, p] = z.exports.useState(a), v = sW();
    Pw(() => {
      v || (r == null ? void 0 : r());
    }, [
      v
    ]), Pw(() => {
      p(a);
    }, [
      a
    ]);
    const y = () => p(null), S = () => p(a), T = () => {
      v && i();
    };
    z.exports.useEffect(() => {
      v && o && i();
    }, [
      v,
      o,
      i
    ]), KI(T, h);
    const w = z.exports.useMemo(() => ({
      pointerEvents: "auto",
      maxWidth: 560,
      minWidth: 300,
      margin: u,
      ...l
    }), [
      l,
      u
    ]), k = z.exports.useMemo(() => pH(s), [
      s
    ]);
    return J(aH.div, {
      layout: true,
      className: "chakra-toast",
      variants: c,
      initial: "initial",
      animate: "animate",
      exit: "exit",
      onHoverStart: y,
      onHoverEnd: S,
      custom: {
        position: s
      },
      style: k,
      children: J(on.div, {
        role: "status",
        "aria-atomic": "true",
        className: "chakra-toast__inner",
        __css: w,
        children: vi(n, {
          id: e,
          onClose: T
        })
      })
    });
  });
  HP.displayName = "ToastComponent";
  function Mr(t) {
    return z.exports.forwardRef(t);
  }
  var LH = typeof Element < "u", RH = typeof Map == "function", _H = typeof Set == "function", DH = typeof ArrayBuffer == "function" && !!ArrayBuffer.isView;
  function yd(t, e) {
    if (t === e)
      return true;
    if (t && e && typeof t == "object" && typeof e == "object") {
      if (t.constructor !== e.constructor)
        return false;
      var n, r, i;
      if (Array.isArray(t)) {
        if (n = t.length, n != e.length)
          return false;
        for (r = n; r-- !== 0; )
          if (!yd(t[r], e[r]))
            return false;
        return true;
      }
      var o;
      if (RH && t instanceof Map && e instanceof Map) {
        if (t.size !== e.size)
          return false;
        for (o = t.entries(); !(r = o.next()).done; )
          if (!e.has(r.value[0]))
            return false;
        for (o = t.entries(); !(r = o.next()).done; )
          if (!yd(r.value[1], e.get(r.value[0])))
            return false;
        return true;
      }
      if (_H && t instanceof Set && e instanceof Set) {
        if (t.size !== e.size)
          return false;
        for (o = t.entries(); !(r = o.next()).done; )
          if (!e.has(r.value[0]))
            return false;
        return true;
      }
      if (DH && ArrayBuffer.isView(t) && ArrayBuffer.isView(e)) {
        if (n = t.length, n != e.length)
          return false;
        for (r = n; r-- !== 0; )
          if (t[r] !== e[r])
            return false;
        return true;
      }
      if (t.constructor === RegExp)
        return t.source === e.source && t.flags === e.flags;
      if (t.valueOf !== Object.prototype.valueOf && typeof t.valueOf == "function" && typeof e.valueOf == "function")
        return t.valueOf() === e.valueOf();
      if (t.toString !== Object.prototype.toString && typeof t.toString == "function" && typeof e.toString == "function")
        return t.toString() === e.toString();
      if (i = Object.keys(t), n = i.length, n !== Object.keys(e).length)
        return false;
      for (r = n; r-- !== 0; )
        if (!Object.prototype.hasOwnProperty.call(e, i[r]))
          return false;
      if (LH && t instanceof Element)
        return false;
      for (r = n; r-- !== 0; )
        if (!((i[r] === "_owner" || i[r] === "__v" || i[r] === "__o") && t.$$typeof) && !yd(t[i[r]], e[i[r]]))
          return false;
      return true;
    }
    return t !== t && e !== e;
  }
  var IH = function(e, n) {
    try {
      return yd(e, n);
    } catch (r) {
      if ((r.message || "").match(/stack|recursion/i))
        return console.warn("react-fast-compare cannot handle circular refs"), false;
      throw r;
    }
  };
  function BH() {
    const t = z.exports.useContext(fl);
    if (!t)
      throw Error("useTheme: `theme` is undefined. Seems you forgot to wrap your app in `<ChakraProvider />` or `<ThemeProvider />`");
    return t;
  }
  function NH() {
    const t = Xb(), e = BH();
    return {
      ...t,
      theme: e
    };
  }
  function $H(t) {
    return Object.fromEntries(Object.entries(t).filter(([e, n]) => n !== void 0 && e !== "children" && !z.exports.isValidElement(n)));
  }
  function jP(t, e = {}) {
    const { styleConfig: n, ...r } = e, { theme: i, colorMode: o } = NH(), s = t ? SA(i, `components.${t}`) : void 0, a = n || s, l = yi({
      theme: i,
      colorMode: o
    }, (a == null ? void 0 : a.defaultProps) ?? {}, $H(r), (u, h) => u ? void 0 : h), c = z.exports.useRef({});
    if (a) {
      const h = NB(a)(l);
      IH(c.current, h) || (c.current = h);
    }
    return c.current;
  }
  function wx(t, e = {}) {
    return jP(t, e);
  }
  function UP(t, e = {}) {
    return jP(t, e);
  }
  const uC = {
    path: Yn("g", {
      stroke: "currentColor",
      strokeWidth: "1.5",
      children: [
        J("path", {
          strokeLinecap: "round",
          fill: "none",
          d: "M9,9a3,3,0,1,1,4,2.829,1.5,1.5,0,0,0-1,1.415V14.25"
        }),
        J("path", {
          fill: "currentColor",
          strokeLinecap: "round",
          d: "M12,17.25a.375.375,0,1,0,.375.375A.375.375,0,0,0,12,17.25h0"
        }),
        J("circle", {
          fill: "none",
          strokeMiterlimit: "10",
          cx: "12",
          cy: "12",
          r: "11.25"
        })
      ]
    }),
    viewBox: "0 0 24 24"
  }, sf = Mr((t, e) => {
    const { as: n, viewBox: r, color: i = "currentColor", focusable: o = false, children: s, className: a, __css: l, ...c } = t, u = Gr("chakra-icon", a), h = wx("Icon", t), p = {
      w: "1em",
      h: "1em",
      display: "inline-block",
      lineHeight: "1em",
      flexShrink: 0,
      color: i,
      ...l,
      ...h
    }, v = {
      ref: e,
      focusable: o,
      className: u,
      __css: p
    }, y = r ?? uC.viewBox;
    if (n && typeof n != "string")
      return J(on.svg, {
        as: n,
        ...v,
        ...c
      });
    const S = s ?? uC.path;
    return J(on.svg, {
      verticalAlign: "middle",
      viewBox: y,
      ...v,
      ...c,
      children: S
    });
  });
  sf.displayName = "Icon";
  function zH(t) {
    return J(sf, {
      viewBox: "0 0 24 24",
      ...t,
      children: J("path", {
        fill: "currentColor",
        d: "M12,0A12,12,0,1,0,24,12,12.014,12.014,0,0,0,12,0Zm6.927,8.2-6.845,9.289a1.011,1.011,0,0,1-1.43.188L5.764,13.769a1,1,0,1,1,1.25-1.562l4.076,3.261,6.227-8.451A1,1,0,1,1,18.927,8.2Z"
      })
    });
  }
  function FH(t) {
    return J(sf, {
      viewBox: "0 0 24 24",
      ...t,
      children: J("path", {
        fill: "currentColor",
        d: "M12,0A12,12,0,1,0,24,12,12.013,12.013,0,0,0,12,0Zm.25,5a1.5,1.5,0,1,1-1.5,1.5A1.5,1.5,0,0,1,12.25,5ZM14.5,18.5h-4a1,1,0,0,1,0-2h.75a.25.25,0,0,0,.25-.25v-4.5a.25.25,0,0,0-.25-.25H10.5a1,1,0,0,1,0-2h1a2,2,0,0,1,2,2v4.75a.25.25,0,0,0,.25.25h.75a1,1,0,1,1,0,2Z"
      })
    });
  }
  function fC(t) {
    return J(sf, {
      viewBox: "0 0 24 24",
      ...t,
      children: J("path", {
        fill: "currentColor",
        d: "M11.983,0a12.206,12.206,0,0,0-8.51,3.653A11.8,11.8,0,0,0,0,12.207,11.779,11.779,0,0,0,11.8,24h.214A12.111,12.111,0,0,0,24,11.791h0A11.766,11.766,0,0,0,11.983,0ZM10.5,16.542a1.476,1.476,0,0,1,1.449-1.53h.027a1.527,1.527,0,0,1,1.523,1.47,1.475,1.475,0,0,1-1.449,1.53h-.027A1.529,1.529,0,0,1,10.5,16.542ZM11,12.5v-6a1,1,0,0,1,2,0v6a1,1,0,1,1-2,0Z"
      })
    });
  }
  const VH = dV({
    "0%": {
      transform: "rotate(0deg)"
    },
    "100%": {
      transform: "rotate(360deg)"
    }
  }), KP = Mr((t, e) => {
    const n = wx("Spinner", t), { label: r = "Loading...", thickness: i = "2px", speed: o = "0.45s", emptyColor: s = "transparent", className: a, ...l } = sm(t), c = Gr("chakra-spinner", a), u = {
      display: "inline-block",
      borderColor: "currentColor",
      borderStyle: "solid",
      borderRadius: "99999px",
      borderWidth: i,
      borderBottomColor: s,
      borderLeftColor: s,
      animation: `${VH} ${o} linear infinite`,
      ...n
    };
    return J(on.div, {
      ref: e,
      __css: u,
      className: c,
      ...l,
      children: r && J(on.span, {
        srOnly: true,
        children: r
      })
    });
  });
  KP.displayName = "Spinner";
  const [WH, kx] = Ei({
    name: "AlertContext",
    hookName: "useAlertContext",
    providerName: "<Alert />"
  }), [HH, Cx] = Ei({
    name: "AlertStylesContext",
    hookName: "useAlertStyles",
    providerName: "<Alert />"
  }), qP = {
    info: {
      icon: FH,
      colorScheme: "blue"
    },
    warning: {
      icon: fC,
      colorScheme: "orange"
    },
    success: {
      icon: zH,
      colorScheme: "green"
    },
    error: {
      icon: fC,
      colorScheme: "red"
    },
    loading: {
      icon: KP,
      colorScheme: "blue"
    }
  };
  function jH(t) {
    return qP[t].colorScheme;
  }
  function UH(t) {
    return qP[t].icon;
  }
  const GP = Mr(function(e, n) {
    const { status: r = "info", addRole: i = true, ...o } = sm(e), s = e.colorScheme ?? jH(r), a = UP("Alert", {
      ...e,
      colorScheme: s
    }), l = {
      width: "100%",
      display: "flex",
      alignItems: "center",
      position: "relative",
      overflow: "hidden",
      ...a.container
    };
    return J(WH, {
      value: {
        status: r
      },
      children: J(HH, {
        value: a,
        children: J(on.div, {
          "data-status": r,
          role: i ? "alert" : void 0,
          ref: n,
          ...o,
          className: Gr("chakra-alert", e.className),
          __css: l
        })
      })
    });
  });
  GP.displayName = "Alert";
  function YP(t) {
    const { status: e } = kx(), n = UH(e), r = Cx(), i = e === "loading" ? r.spinner : r.icon;
    return J(on.span, {
      display: "inherit",
      "data-status": e,
      ...t,
      className: Gr("chakra-alert__icon", t.className),
      __css: i,
      children: t.children || J(n, {
        h: "100%",
        w: "100%"
      })
    });
  }
  YP.displayName = "AlertIcon";
  const XP = Mr(function(e, n) {
    const r = Cx(), { status: i } = kx();
    return J(on.div, {
      ref: n,
      "data-status": i,
      ...e,
      className: Gr("chakra-alert__title", e.className),
      __css: r.title
    });
  });
  XP.displayName = "AlertTitle";
  const QP = Mr(function(e, n) {
    const { status: r } = kx(), i = Cx(), o = {
      display: "inline",
      ...i.description
    };
    return J(on.div, {
      ref: n,
      "data-status": r,
      ...e,
      className: Gr("chakra-alert__desc", e.className),
      __css: o
    });
  });
  QP.displayName = "AlertDescription";
  function KH(t) {
    return J(sf, {
      focusable: "false",
      "aria-hidden": true,
      ...t,
      children: J("path", {
        fill: "currentColor",
        d: "M.439,21.44a1.5,1.5,0,0,0,2.122,2.121L11.823,14.3a.25.25,0,0,1,.354,0l9.262,9.263a1.5,1.5,0,1,0,2.122-2.121L14.3,12.177a.25.25,0,0,1,0-.354l9.263-9.262A1.5,1.5,0,0,0,21.439.44L12.177,9.7a.25.25,0,0,1-.354,0L2.561.44A1.5,1.5,0,0,0,.439,2.561L9.7,11.823a.25.25,0,0,1,0,.354Z"
      })
    });
  }
  const JP = Mr(function(e, n) {
    const r = wx("CloseButton", e), { children: i, isDisabled: o, __css: s, ...a } = sm(e), l = {
      outline: 0,
      display: "flex",
      alignItems: "center",
      justifyContent: "center",
      flexShrink: 0
    };
    return J(on.button, {
      type: "button",
      "aria-label": "Close",
      ref: n,
      disabled: o,
      __css: {
        ...l,
        ...r,
        ...s
      },
      ...a,
      children: i || J(KH, {
        width: "1em",
        height: "1em"
      })
    });
  });
  JP.displayName = "CloseButton";
  const qH = (t) => {
    const { status: e, variant: n = "solid", id: r, title: i, isClosable: o, onClose: s, description: a, colorScheme: l, icon: c } = t, u = r ? {
      root: `toast-${r}`,
      title: `toast-${r}-title`,
      description: `toast-${r}-description`
    } : void 0;
    return Yn(GP, {
      addRole: false,
      status: e,
      variant: n,
      id: u == null ? void 0 : u.root,
      alignItems: "start",
      borderRadius: "md",
      boxShadow: "lg",
      paddingEnd: 8,
      textAlign: "start",
      width: "auto",
      colorScheme: l,
      children: [
        J(YP, {
          children: c
        }),
        Yn(on.div, {
          flex: "1",
          maxWidth: "100%",
          children: [
            i && J(XP, {
              id: u == null ? void 0 : u.title,
              children: i
            }),
            a && J(QP, {
              id: u == null ? void 0 : u.description,
              display: "block",
              children: a
            })
          ]
        }),
        o && J(JP, {
          size: "sm",
          onClick: s,
          position: "absolute",
          insetEnd: 1,
          top: 1
        })
      ]
    });
  };
  function GH(t = {}) {
    const { render: e, toastComponent: n = qH } = t;
    return (i) => typeof e == "function" ? e({
      ...i,
      ...t
    }) : J(n, {
      ...i,
      ...t
    });
  }
  const YH = {
    top: [],
    "top-left": [],
    "top-right": [],
    "bottom-left": [],
    bottom: [],
    "bottom-right": []
  }, Kc = XH(YH);
  function XH(t) {
    let e = t;
    const n = /* @__PURE__ */ new Set(), r = (i) => {
      e = i(e), n.forEach((o) => o());
    };
    return {
      getState: () => e,
      subscribe: (i) => (n.add(i), () => {
        r(() => t), n.delete(i);
      }),
      removeToast: (i, o) => {
        r((s) => ({
          ...s,
          [o]: s[o].filter((a) => a.id != i)
        }));
      },
      notify: (i, o) => {
        const s = QH(i, o), { position: a, id: l } = s;
        return r((c) => {
          const h = a.includes("top") ? [
            s,
            ...c[a] ?? []
          ] : [
            ...c[a] ?? [],
            s
          ];
          return {
            ...c,
            [a]: h
          };
        }), l;
      },
      update: (i, o) => {
        !i || r((s) => {
          const a = {
            ...s
          }, { position: l, index: c } = aC(a, i);
          return l && c !== -1 && (a[l][c] = {
            ...a[l][c],
            ...o,
            message: GH(o)
          }), a;
        });
      },
      closeAll: ({ positions: i } = {}) => {
        r((o) => (i ?? [
          "bottom",
          "bottom-right",
          "bottom-left",
          "top",
          "top-left",
          "top-right"
        ]).reduce((l, c) => (l[c] = o[c].map((u) => ({
          ...u,
          requestClose: true
        })), l), {
          ...o
        }));
      },
      close: (i) => {
        r((o) => {
          const s = WP(o, i);
          return s ? {
            ...o,
            [s]: o[s].map((a) => a.id == i ? {
              ...a,
              requestClose: true
            } : a)
          } : o;
        });
      },
      isActive: (i) => Boolean(aC(Kc.getState(), i).position)
    };
  }
  let hC = 0;
  function QH(t, e = {}) {
    hC += 1;
    const n = e.id ?? hC, r = e.position ?? "bottom";
    return {
      id: n,
      message: t,
      position: r,
      duration: e.duration,
      onCloseComplete: e.onCloseComplete,
      onRequestRemove: () => Kc.removeToast(String(n), r),
      status: e.status,
      requestClose: false,
      containerStyle: e.containerStyle
    };
  }
  const [ZP, JH] = Ei({
    strict: false,
    name: "PortalContext"
  }), Tx = "chakra-portal", ZH = ".chakra-portal", ej = (t) => J("div", {
    className: "chakra-portal-zIndex",
    style: {
      position: "absolute",
      zIndex: t.zIndex,
      top: 0,
      left: 0,
      right: 0
    },
    children: t.children
  }), tj = (t) => {
    const { appendToParentPortal: e, children: n } = t, [r, i] = z.exports.useState(null), o = z.exports.useRef(null), [, s] = z.exports.useState({});
    z.exports.useEffect(() => s({}), []);
    const a = JH(), l = TV();
    sy(() => {
      if (!r)
        return;
      const u = r.ownerDocument, h = e ? a ?? u.body : u.body;
      if (!h)
        return;
      o.current = u.createElement("div"), o.current.className = Tx, h.appendChild(o.current), s({});
      const p = o.current;
      return () => {
        h.contains(p) && h.removeChild(p);
      };
    }, [
      r
    ]);
    const c = (l == null ? void 0 : l.zIndex) ? J(ej, {
      zIndex: l == null ? void 0 : l.zIndex,
      children: n
    }) : n;
    return o.current ? Hp.exports.createPortal(J(ZP, {
      value: o.current,
      children: c
    }), o.current) : J("span", {
      ref: (u) => {
        u && i(u);
      }
    });
  }, nj = (t) => {
    const { children: e, containerRef: n, appendToParentPortal: r } = t, i = n.current, o = i ?? (typeof window < "u" ? document.body : void 0), s = z.exports.useMemo(() => {
      const l = i == null ? void 0 : i.ownerDocument.createElement("div");
      return l && (l.className = Tx), l;
    }, [
      i
    ]), [, a] = z.exports.useState({});
    return sy(() => a({}), []), sy(() => {
      if (!(!s || !o))
        return o.appendChild(s), () => {
          o.removeChild(s);
        };
    }, [
      s,
      o
    ]), o && s ? Hp.exports.createPortal(J(ZP, {
      value: r ? s : null,
      children: e
    }), s) : null;
  };
  function Dm(t) {
    const e = {
      appendToParentPortal: true,
      ...t
    }, { containerRef: n, ...r } = e;
    return n ? J(nj, {
      containerRef: n,
      ...r
    }) : J(tj, {
      ...r
    });
  }
  Dm.className = Tx;
  Dm.selector = ZH;
  Dm.displayName = "Portal";
  const [rj, hJ] = Ei({
    name: "ToastOptionsContext",
    strict: false
  }), ij = (t) => {
    const e = z.exports.useSyncExternalStore(Kc.subscribe, Kc.getState, Kc.getState), { motionVariants: n, component: r = HP, portalProps: i, animatePresenceProps: o } = t, a = Object.keys(e).map((l) => {
      const c = e[l];
      return J("div", {
        role: "region",
        "aria-live": "polite",
        "aria-label": `Notifications-${l}`,
        id: `chakra-toast-manager-${l}`,
        style: mH(l),
        children: J(hH, {
          ...o,
          initial: false,
          children: c.map((u) => J(r, {
            motionVariants: n,
            ...u
          }, u.id))
        })
      }, l);
    });
    return J(Dm, {
      ...i,
      children: a
    });
  }, oj = (t) => function({ children: n, theme: r = t, toastOptions: i, ...o }) {
    return Yn(MV, {
      theme: r,
      ...o,
      children: [
        J(rj, {
          value: i == null ? void 0 : i.defaultOptions,
          children: n
        }),
        J(ij, {
          ...i
        })
      ]
    });
  }, sj = oj(iF);
  function dC(t) {
    return t.sort((e, n) => {
      const r = e.compareDocumentPosition(n);
      if (r & Node.DOCUMENT_POSITION_FOLLOWING || r & Node.DOCUMENT_POSITION_CONTAINED_BY)
        return -1;
      if (r & Node.DOCUMENT_POSITION_PRECEDING || r & Node.DOCUMENT_POSITION_CONTAINS)
        return 1;
      if (r & Node.DOCUMENT_POSITION_DISCONNECTED || r & Node.DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC)
        throw Error("Cannot sort the given nodes.");
      return 0;
    });
  }
  const aj = (t) => typeof t == "object" && "nodeType" in t && t.nodeType === Node.ELEMENT_NODE;
  function pC(t, e, n) {
    let r = t + 1;
    return n && r >= e && (r = 0), r;
  }
  function mC(t, e, n) {
    let r = t - 1;
    return n && r < 0 && (r = e), r;
  }
  const P0 = typeof window < "u" ? z.exports.useLayoutEffect : z.exports.useEffect, gC = (t) => t;
  var lj = Object.defineProperty, cj = (t, e, n) => e in t ? lj(t, e, {
    enumerable: true,
    configurable: true,
    writable: true,
    value: n
  }) : t[e] = n, bt = (t, e, n) => (cj(t, typeof e != "symbol" ? e + "" : e, n), n);
  class uj {
    constructor() {
      bt(this, "descendants", /* @__PURE__ */ new Map()), bt(this, "register", (e) => {
        if (e != null)
          return aj(e) ? this.registerNode(e) : (n) => {
            this.registerNode(n, e);
          };
      }), bt(this, "unregister", (e) => {
        this.descendants.delete(e);
        const n = dC(Array.from(this.descendants.keys()));
        this.assignIndex(n);
      }), bt(this, "destroy", () => {
        this.descendants.clear();
      }), bt(this, "assignIndex", (e) => {
        this.descendants.forEach((n) => {
          const r = e.indexOf(n.node);
          n.index = r, n.node.dataset.index = n.index.toString();
        });
      }), bt(this, "count", () => this.descendants.size), bt(this, "enabledCount", () => this.enabledValues().length), bt(this, "values", () => Array.from(this.descendants.values()).sort((n, r) => n.index - r.index)), bt(this, "enabledValues", () => this.values().filter((e) => !e.disabled)), bt(this, "item", (e) => {
        if (this.count() !== 0)
          return this.values()[e];
      }), bt(this, "enabledItem", (e) => {
        if (this.enabledCount() !== 0)
          return this.enabledValues()[e];
      }), bt(this, "first", () => this.item(0)), bt(this, "firstEnabled", () => this.enabledItem(0)), bt(this, "last", () => this.item(this.descendants.size - 1)), bt(this, "lastEnabled", () => {
        const e = this.enabledValues().length - 1;
        return this.enabledItem(e);
      }), bt(this, "indexOf", (e) => {
        var _a3;
        return e ? ((_a3 = this.descendants.get(e)) == null ? void 0 : _a3.index) ?? -1 : -1;
      }), bt(this, "enabledIndexOf", (e) => e == null ? -1 : this.enabledValues().findIndex((n) => n.node.isSameNode(e))), bt(this, "next", (e, n = true) => {
        const r = pC(e, this.count(), n);
        return this.item(r);
      }), bt(this, "nextEnabled", (e, n = true) => {
        const r = this.item(e);
        if (!r)
          return;
        const i = this.enabledIndexOf(r.node), o = pC(i, this.enabledCount(), n);
        return this.enabledItem(o);
      }), bt(this, "prev", (e, n = true) => {
        const r = mC(e, this.count() - 1, n);
        return this.item(r);
      }), bt(this, "prevEnabled", (e, n = true) => {
        const r = this.item(e);
        if (!r)
          return;
        const i = this.enabledIndexOf(r.node), o = mC(i, this.enabledCount() - 1, n);
        return this.enabledItem(o);
      }), bt(this, "registerNode", (e, n) => {
        if (!e || this.descendants.has(e))
          return;
        const r = Array.from(this.descendants.keys()).concat(e), i = dC(r);
        (n == null ? void 0 : n.disabled) && (n.disabled = !!n.disabled);
        const o = {
          node: e,
          index: -1,
          ...n
        };
        this.descendants.set(e, o), this.assignIndex(i);
      });
    }
  }
  function fj() {
    const [t, e] = Ei({
      name: "DescendantsProvider",
      errorMessage: "useDescendantsContext must be used within DescendantsProvider"
    });
    return [
      t,
      e,
      () => {
        const i = z.exports.useRef(new uj());
        return P0(() => () => i.current.destroy()), i.current;
      },
      (i) => {
        const o = e(), [s, a] = z.exports.useState(-1), l = z.exports.useRef(null);
        P0(() => () => {
          !l.current || o.unregister(l.current);
        }, []), P0(() => {
          if (!l.current)
            return;
          const u = Number(l.current.dataset.index);
          s != u && !Number.isNaN(u) && a(u);
        });
        const c = gC(i ? o.register(i) : o.register);
        return {
          descendants: o,
          index: s,
          enabledIndex: o.enabledIndexOf(l.current),
          register: Ob(c, l)
        };
      }
    ];
  }
  function hj(t, e) {
    if (t == null)
      return {};
    var n = {};
    for (var r in t)
      if ({}.hasOwnProperty.call(t, r)) {
        if (e.indexOf(r) !== -1)
          continue;
        n[r] = t[r];
      }
    return n;
  }
  const eO = Mr(function(e, n) {
    const { templateAreas: r, gap: i, rowGap: o, columnGap: s, column: a, row: l, autoFlow: c, autoRows: u, templateRows: h, autoColumns: p, templateColumns: v, ...y } = e, S = {
      display: "grid",
      gridTemplateAreas: r,
      gridGap: i,
      gridRowGap: o,
      gridColumnGap: s,
      gridAutoColumns: p,
      gridColumn: a,
      gridRow: l,
      gridAutoFlow: c,
      gridAutoRows: u,
      gridTemplateRows: h,
      gridTemplateColumns: v
    };
    return J(on.div, {
      ref: n,
      __css: S,
      ...y
    });
  });
  eO.displayName = "Grid";
  function dj() {
    const t = z.exports.useRef(/* @__PURE__ */ new Map()), e = t.current, n = z.exports.useCallback((i, o, s, a) => {
      t.current.set(s, {
        type: o,
        el: i,
        options: a
      }), i.addEventListener(o, s, a);
    }, []), r = z.exports.useCallback((i, o, s, a) => {
      i.removeEventListener(o, s, a), t.current.delete(s);
    }, []);
    return z.exports.useEffect(() => () => {
      e.forEach((i, o) => {
        r(i.el, i.type, o, i.options);
      });
    }, [
      r,
      e
    ]), {
      add: n,
      remove: r
    };
  }
  function O0(t) {
    var _a3, _b3;
    const e = ((_b3 = (_a3 = t.composedPath) == null ? void 0 : _a3.call(t)) == null ? void 0 : _b3[0]) ?? t.target, { tagName: n, isContentEditable: r } = e;
    return n !== "INPUT" && n !== "TEXTAREA" && r !== true;
  }
  function pj(t = {}) {
    const { ref: e, isDisabled: n, isFocusable: r, clickOnEnter: i = true, clickOnSpace: o = true, onMouseDown: s, onMouseUp: a, onClick: l, onKeyDown: c, onKeyUp: u, tabIndex: h, onMouseOver: p, onMouseLeave: v, ...y } = t, [S, T] = z.exports.useState(true), [w, k] = z.exports.useState(false), C = dj(), O = (ee) => {
      !ee || ee.tagName !== "BUTTON" && T(false);
    }, L = S ? h : h || 0, D = n && !r, R = z.exports.useCallback((ee) => {
      if (n) {
        ee.stopPropagation(), ee.preventDefault();
        return;
      }
      ee.currentTarget.focus(), l == null ? void 0 : l(ee);
    }, [
      n,
      l
    ]), F = z.exports.useCallback((ee) => {
      w && O0(ee) && (ee.preventDefault(), ee.stopPropagation(), k(false), C.remove(document, "keyup", F, false));
    }, [
      w,
      C
    ]), K = z.exports.useCallback((ee) => {
      if (c == null ? void 0 : c(ee), n || ee.defaultPrevented || ee.metaKey || !O0(ee.nativeEvent) || S)
        return;
      const V = i && ee.key === "Enter";
      o && ee.key === " " && (ee.preventDefault(), k(true)), V && (ee.preventDefault(), ee.currentTarget.click()), C.add(document, "keyup", F, false);
    }, [
      n,
      S,
      c,
      i,
      o,
      C,
      F
    ]), Y = z.exports.useCallback((ee) => {
      if (u == null ? void 0 : u(ee), n || ee.defaultPrevented || ee.metaKey || !O0(ee.nativeEvent) || S)
        return;
      o && ee.key === " " && (ee.preventDefault(), k(false), ee.currentTarget.click());
    }, [
      o,
      S,
      n,
      u
    ]), te = z.exports.useCallback((ee) => {
      ee.button === 0 && (k(false), C.remove(document, "mouseup", te, false));
    }, [
      C
    ]), ne = z.exports.useCallback((ee) => {
      if (ee.button !== 0)
        return;
      if (n) {
        ee.stopPropagation(), ee.preventDefault();
        return;
      }
      S || k(true), ee.currentTarget.focus({
        preventScroll: true
      }), C.add(document, "mouseup", te, false), s == null ? void 0 : s(ee);
    }, [
      n,
      S,
      s,
      C,
      te
    ]), ae = z.exports.useCallback((ee) => {
      ee.button === 0 && (S || k(false), a == null ? void 0 : a(ee));
    }, [
      a,
      S
    ]), ye = z.exports.useCallback((ee) => {
      if (n) {
        ee.preventDefault();
        return;
      }
      p == null ? void 0 : p(ee);
    }, [
      n,
      p
    ]), Ce = z.exports.useCallback((ee) => {
      w && (ee.preventDefault(), k(false)), v == null ? void 0 : v(ee);
    }, [
      w,
      v
    ]), Le = Ob(e, O);
    return S ? {
      ...y,
      ref: Le,
      type: "button",
      "aria-disabled": D ? void 0 : n,
      disabled: D,
      onClick: R,
      onMouseDown: s,
      onMouseUp: a,
      onKeyUp: u,
      onKeyDown: c,
      onMouseOver: p,
      onMouseLeave: v
    } : {
      ...y,
      ref: Le,
      role: "button",
      "data-active": AI(w),
      "aria-disabled": n ? "true" : void 0,
      tabIndex: D ? void 0 : L,
      onClick: R,
      onMouseDown: ne,
      onMouseUp: ae,
      onKeyUp: Y,
      onKeyDown: K,
      onMouseOver: ye,
      onMouseLeave: Ce
    };
  }
  const [mj, gj, vj, yj] = fj();
  function bj(t) {
    const { defaultIndex: e, onChange: n, index: r, isManual: i, isLazy: o, lazyBehavior: s = "unmount", orientation: a = "horizontal", direction: l = "ltr", ...c } = t, [u, h] = z.exports.useState(e ?? 0), [p, v] = jI({
      defaultValue: e ?? 0,
      value: r,
      onChange: n
    });
    z.exports.useEffect(() => {
      r != null && h(r);
    }, [
      r
    ]);
    const y = vj(), S = z.exports.useId();
    return {
      id: `tabs-${t.id ?? S}`,
      selectedIndex: p,
      focusedIndex: u,
      setSelectedIndex: v,
      setFocusedIndex: h,
      isManual: i,
      isLazy: o,
      lazyBehavior: s,
      orientation: a,
      descendants: y,
      direction: l,
      htmlProps: c
    };
  }
  const [xj, Im] = Ei({
    name: "TabsContext",
    errorMessage: "useTabsContext: `context` is undefined. Seems you forgot to wrap all tabs components within <Tabs />"
  });
  function Sj(t) {
    const { focusedIndex: e, orientation: n, direction: r } = Im(), i = gj(), o = z.exports.useCallback((s) => {
      const a = () => {
        var _a3;
        const k = i.nextEnabled(e);
        k && ((_a3 = k.node) == null ? void 0 : _a3.focus());
      }, l = () => {
        var _a3;
        const k = i.prevEnabled(e);
        k && ((_a3 = k.node) == null ? void 0 : _a3.focus());
      }, c = () => {
        var _a3;
        const k = i.firstEnabled();
        k && ((_a3 = k.node) == null ? void 0 : _a3.focus());
      }, u = () => {
        var _a3;
        const k = i.lastEnabled();
        k && ((_a3 = k.node) == null ? void 0 : _a3.focus());
      }, h = n === "horizontal", p = n === "vertical", v = s.key, y = r === "ltr" ? "ArrowLeft" : "ArrowRight", S = r === "ltr" ? "ArrowRight" : "ArrowLeft", w = {
        [y]: () => h && l(),
        [S]: () => h && a(),
        ArrowDown: () => p && a(),
        ArrowUp: () => p && l(),
        Home: c,
        End: u
      }[v];
      w && (s.preventDefault(), w(s));
    }, [
      i,
      e,
      n,
      r
    ]);
    return {
      ...t,
      role: "tablist",
      "aria-orientation": n,
      onKeyDown: iy(t.onKeyDown, o)
    };
  }
  function wj(t) {
    const { isDisabled: e = false, isFocusable: n = false, ...r } = t, { setSelectedIndex: i, isManual: o, id: s, setFocusedIndex: a, selectedIndex: l } = Im(), { index: c, register: u } = yj({
      disabled: e && !n
    }), h = c === l, p = () => {
      i(c);
    }, v = () => {
      a(c), !o && !(e && n) && i(c);
    }, y = pj({
      ...r,
      ref: Ob(u, t.ref),
      isDisabled: e,
      isFocusable: n,
      onClick: iy(t.onClick, p)
    }), S = "button";
    return {
      ...y,
      id: tO(s, c),
      role: "tab",
      tabIndex: h ? 0 : -1,
      type: S,
      "aria-selected": h,
      "aria-controls": nO(s, c),
      onFocus: e ? void 0 : iy(t.onFocus, v)
    };
  }
  const [kj, Cj] = Ei({});
  function Tj(t) {
    const e = Im(), { id: n, selectedIndex: r } = e, o = _I(t.children).map((s, a) => z.exports.createElement(kj, {
      key: s.key ?? a,
      value: {
        isSelected: a === r,
        id: nO(n, a),
        tabId: tO(n, a),
        selectedIndex: r
      }
    }, s));
    return {
      ...t,
      children: o
    };
  }
  function Mj(t) {
    const { children: e, ...n } = t, { isLazy: r, lazyBehavior: i } = Im(), { isSelected: o, id: s, tabId: a } = Cj(), l = z.exports.useRef(false);
    o && (l.current = true);
    const c = zI({
      wasSelected: l.current,
      isSelected: o,
      enabled: r,
      mode: i
    });
    return {
      tabIndex: 0,
      ...n,
      children: c ? e : null,
      role: "tabpanel",
      "aria-labelledby": a,
      hidden: !o,
      id: s
    };
  }
  function tO(t, e) {
    return `${t}--tab-${e}`;
  }
  function nO(t, e) {
    return `${t}--tabpanel-${e}`;
  }
  const [Aj, Bm] = Ei({
    name: "TabsStylesContext",
    errorMessage: `useTabsStyles returned is 'undefined'. Seems you forgot to wrap the components in "<Tabs />" `
  }), rO = Mr(function(e, n) {
    const r = UP("Tabs", e), { children: i, className: o, ...s } = sm(e), { htmlProps: a, descendants: l, ...c } = bj(s), u = z.exports.useMemo(() => c, [
      c
    ]), { isFitted: h, ...p } = a, v = {
      position: "relative",
      ...r.root
    };
    return J(mj, {
      value: l,
      children: J(xj, {
        value: u,
        children: J(Aj, {
          value: r,
          children: J(on.div, {
            className: Gr("chakra-tabs", o),
            ref: n,
            ...p,
            __css: v,
            children: i
          })
        })
      })
    });
  });
  rO.displayName = "Tabs";
  const iO = Mr(function(e, n) {
    const r = Bm(), i = wj({
      ...e,
      ref: n
    }), o = {
      outline: "0",
      display: "flex",
      alignItems: "center",
      justifyContent: "center",
      ...r.tab
    };
    return J(on.button, {
      ...i,
      className: Gr("chakra-tabs__tab", e.className),
      __css: o
    });
  });
  iO.displayName = "Tab";
  const oO = Mr(function(e, n) {
    const r = Sj({
      ...e,
      ref: n
    }), i = Bm(), o = {
      display: "flex",
      ...i.tablist
    };
    return J(on.div, {
      ...r,
      className: Gr("chakra-tabs__tablist", e.className),
      __css: o
    });
  });
  oO.displayName = "TabList";
  const $y = Mr(function(e, n) {
    const r = Mj({
      ...e,
      ref: n
    }), i = Bm();
    return J(on.div, {
      outline: "0",
      ...r,
      className: Gr("chakra-tabs__tab-panel", e.className),
      __css: i.tabpanel
    });
  });
  $y.displayName = "TabPanel";
  const sO = Mr(function(e, n) {
    const r = Tj(e), i = Bm();
    return J(on.div, {
      ...r,
      width: "100%",
      ref: n,
      className: Gr("chakra-tabs__tab-panels", e.className),
      __css: i.tabpanels
    });
  });
  sO.displayName = "TabPanels";
  let zy = [], aO = [];
  (() => {
    let t = "lc,34,7n,7,7b,19,,,,2,,2,,,20,b,1c,l,g,,2t,7,2,6,2,2,,4,z,,u,r,2j,b,1m,9,9,,o,4,,9,,3,,5,17,3,3b,f,,w,1j,,,,4,8,4,,3,7,a,2,t,,1m,,,,2,4,8,,9,,a,2,q,,2,2,1l,,4,2,4,2,2,3,3,,u,2,3,,b,2,1l,,4,5,,2,4,,k,2,m,6,,,1m,,,2,,4,8,,7,3,a,2,u,,1n,,,,c,,9,,14,,3,,1l,3,5,3,,4,7,2,b,2,t,,1m,,2,,2,,3,,5,2,7,2,b,2,s,2,1l,2,,,2,4,8,,9,,a,2,t,,20,,4,,2,3,,,8,,29,,2,7,c,8,2q,,2,9,b,6,22,2,r,,,,,,1j,e,,5,,2,5,b,,10,9,,2u,4,,6,,2,2,2,p,2,4,3,g,4,d,,2,2,6,,f,,jj,3,qa,3,t,3,t,2,u,2,1s,2,,7,8,,2,b,9,,19,3,3b,2,y,,3a,3,4,2,9,,6,3,63,2,2,,1m,,,7,,,,,2,8,6,a,2,,1c,h,1r,4,1c,7,,,5,,14,9,c,2,w,4,2,2,,3,1k,,,2,3,,,3,1m,8,2,2,48,3,,d,,7,4,,6,,3,2,5i,1m,,5,ek,,5f,x,2da,3,3x,,2o,w,fe,6,2x,2,n9w,4,,a,w,2,28,2,7k,,3,,4,,p,2,5,,47,2,q,i,d,,12,8,p,b,1a,3,1c,,2,4,2,2,13,,1v,6,2,2,2,2,c,,8,,1b,,1f,,,3,2,2,5,2,,,16,2,8,,6m,,2,,4,,fn4,,kh,g,g,g,a6,2,gt,,6a,,45,5,1ae,3,,2,5,4,14,3,4,,4l,2,fx,4,ar,2,49,b,4w,,1i,f,1k,3,1d,4,2,2,1x,3,10,5,,8,1q,,c,2,1g,9,a,4,2,,2n,3,2,,,2,6,,4g,,3,8,l,2,1l,2,,,,,m,,e,7,3,5,5f,8,2,3,,,n,,29,,2,6,,,2,,,2,,2,6j,,2,4,6,2,,2,r,2,2d,8,2,,,2,2y,,,,2,6,,,2t,3,2,4,,5,77,9,,2,6t,,a,2,,,4,,40,4,2,2,4,,w,a,14,6,2,4,8,,9,6,2,3,1a,d,,2,ba,7,,6,,,2a,m,2,7,,2,,2,3e,6,3,,,2,,7,,,20,2,3,,,,9n,2,f0b,5,1n,7,t4,,1r,4,29,,f5k,2,43q,,,3,4,5,8,8,2,7,u,4,44,3,1iz,1j,4,1e,8,,e,,m,5,,f,11s,7,,h,2,7,,2,,5,79,7,c5,4,15s,7,31,7,240,5,gx7k,2o,3k,6o".split(",").map((e) => e ? parseInt(e, 36) : 1);
    for (let e = 0, n = 0; e < t.length; e++)
      (e % 2 ? aO : zy).push(n = n + t[e]);
  })();
  function Ej(t) {
    if (t < 768)
      return false;
    for (let e = 0, n = zy.length; ; ) {
      let r = e + n >> 1;
      if (t < zy[r])
        n = r;
      else if (t >= aO[r])
        e = r + 1;
      else
        return true;
      if (e == n)
        return false;
    }
  }
  function vC(t) {
    return t >= 127462 && t <= 127487;
  }
  const yC = 8205;
  function Pj(t, e, n = true, r = true) {
    return (n ? lO : Oj)(t, e, r);
  }
  function lO(t, e, n) {
    if (e == t.length)
      return e;
    e && cO(t.charCodeAt(e)) && uO(t.charCodeAt(e - 1)) && e--;
    let r = L0(t, e);
    for (e += bC(r); e < t.length; ) {
      let i = L0(t, e);
      if (r == yC || i == yC || n && Ej(i))
        e += bC(i), r = i;
      else if (vC(i)) {
        let o = 0, s = e - 2;
        for (; s >= 0 && vC(L0(t, s)); )
          o++, s -= 2;
        if (o % 2 == 0)
          break;
        e += 2;
      } else
        break;
    }
    return e;
  }
  function Oj(t, e, n) {
    for (; e > 0; ) {
      let r = lO(t, e - 2, n);
      if (r < e)
        return r;
      e--;
    }
    return 0;
  }
  function L0(t, e) {
    let n = t.charCodeAt(e);
    if (!uO(n) || e + 1 == t.length)
      return n;
    let r = t.charCodeAt(e + 1);
    return cO(r) ? (n - 55296 << 10) + (r - 56320) + 65536 : n;
  }
  function cO(t) {
    return t >= 56320 && t < 57344;
  }
  function uO(t) {
    return t >= 55296 && t < 56320;
  }
  function bC(t) {
    return t < 65536 ? 1 : 2;
  }
  class He {
    lineAt(e) {
      if (e < 0 || e > this.length)
        throw new RangeError(`Invalid position ${e} in document of length ${this.length}`);
      return this.lineInner(e, false, 1, 0);
    }
    line(e) {
      if (e < 1 || e > this.lines)
        throw new RangeError(`Invalid line number ${e} in ${this.lines}-line document`);
      return this.lineInner(e, true, 1, 0);
    }
    replace(e, n, r) {
      [e, n] = pl(this, e, n);
      let i = [];
      return this.decompose(0, e, i, 2), r.length && r.decompose(0, r.length, i, 3), this.decompose(n, this.length, i, 1), pi.from(i, this.length - (n - e) + r.length);
    }
    append(e) {
      return this.replace(this.length, this.length, e);
    }
    slice(e, n = this.length) {
      [e, n] = pl(this, e, n);
      let r = [];
      return this.decompose(e, n, r, 0), pi.from(r, n - e);
    }
    eq(e) {
      if (e == this)
        return true;
      if (e.length != this.length || e.lines != this.lines)
        return false;
      let n = this.scanIdentical(e, 1), r = this.length - this.scanIdentical(e, -1), i = new qc(this), o = new qc(e);
      for (let s = n, a = n; ; ) {
        if (i.next(s), o.next(s), s = 0, i.lineBreak != o.lineBreak || i.done != o.done || i.value != o.value)
          return false;
        if (a += i.value.length, i.done || a >= r)
          return true;
      }
    }
    iter(e = 1) {
      return new qc(this, e);
    }
    iterRange(e, n = this.length) {
      return new fO(this, e, n);
    }
    iterLines(e, n) {
      let r;
      if (e == null)
        r = this.iter();
      else {
        n == null && (n = this.lines + 1);
        let i = this.line(e).from;
        r = this.iterRange(i, Math.max(i, n == this.lines + 1 ? this.length : n <= 1 ? 0 : this.line(n - 1).to));
      }
      return new hO(r);
    }
    toString() {
      return this.sliceString(0);
    }
    toJSON() {
      let e = [];
      return this.flatten(e), e;
    }
    constructor() {
    }
    static of(e) {
      if (e.length == 0)
        throw new RangeError("A document must have at least one line");
      return e.length == 1 && !e[0] ? He.empty : e.length <= 32 ? new Ct(e) : pi.from(Ct.split(e, []));
    }
  }
  class Ct extends He {
    constructor(e, n = Lj(e)) {
      super(), this.text = e, this.length = n;
    }
    get lines() {
      return this.text.length;
    }
    get children() {
      return null;
    }
    lineInner(e, n, r, i) {
      for (let o = 0; ; o++) {
        let s = this.text[o], a = i + s.length;
        if ((n ? r : a) >= e)
          return new Rj(i, a, r, s);
        i = a + 1, r++;
      }
    }
    decompose(e, n, r, i) {
      let o = e <= 0 && n >= this.length ? this : new Ct(xC(this.text, e, n), Math.min(n, this.length) - Math.max(0, e));
      if (i & 1) {
        let s = r.pop(), a = bd(o.text, s.text.slice(), 0, o.length);
        if (a.length <= 32)
          r.push(new Ct(a, s.length + o.length));
        else {
          let l = a.length >> 1;
          r.push(new Ct(a.slice(0, l)), new Ct(a.slice(l)));
        }
      } else
        r.push(o);
    }
    replace(e, n, r) {
      if (!(r instanceof Ct))
        return super.replace(e, n, r);
      [e, n] = pl(this, e, n);
      let i = bd(this.text, bd(r.text, xC(this.text, 0, e)), n), o = this.length + r.length - (n - e);
      return i.length <= 32 ? new Ct(i, o) : pi.from(Ct.split(i, []), o);
    }
    sliceString(e, n = this.length, r = `
`) {
      [e, n] = pl(this, e, n);
      let i = "";
      for (let o = 0, s = 0; o <= n && s < this.text.length; s++) {
        let a = this.text[s], l = o + a.length;
        o > e && s && (i += r), e < l && n > o && (i += a.slice(Math.max(0, e - o), n - o)), o = l + 1;
      }
      return i;
    }
    flatten(e) {
      for (let n of this.text)
        e.push(n);
    }
    scanIdentical() {
      return 0;
    }
    static split(e, n) {
      let r = [], i = -1;
      for (let o of e)
        r.push(o), i += o.length + 1, r.length == 32 && (n.push(new Ct(r, i)), r = [], i = -1);
      return i > -1 && n.push(new Ct(r, i)), n;
    }
  }
  class pi extends He {
    constructor(e, n) {
      super(), this.children = e, this.length = n, this.lines = 0;
      for (let r of e)
        this.lines += r.lines;
    }
    lineInner(e, n, r, i) {
      for (let o = 0; ; o++) {
        let s = this.children[o], a = i + s.length, l = r + s.lines - 1;
        if ((n ? l : a) >= e)
          return s.lineInner(e, n, r, i);
        i = a + 1, r = l + 1;
      }
    }
    decompose(e, n, r, i) {
      for (let o = 0, s = 0; s <= n && o < this.children.length; o++) {
        let a = this.children[o], l = s + a.length;
        if (e <= l && n >= s) {
          let c = i & ((s <= e ? 1 : 0) | (l >= n ? 2 : 0));
          s >= e && l <= n && !c ? r.push(a) : a.decompose(e - s, n - s, r, c);
        }
        s = l + 1;
      }
    }
    replace(e, n, r) {
      if ([e, n] = pl(this, e, n), r.lines < this.lines)
        for (let i = 0, o = 0; i < this.children.length; i++) {
          let s = this.children[i], a = o + s.length;
          if (e >= o && n <= a) {
            let l = s.replace(e - o, n - o, r), c = this.lines - s.lines + l.lines;
            if (l.lines < c >> 5 - 1 && l.lines > c >> 5 + 1) {
              let u = this.children.slice();
              return u[i] = l, new pi(u, this.length - (n - e) + r.length);
            }
            return super.replace(o, a, l);
          }
          o = a + 1;
        }
      return super.replace(e, n, r);
    }
    sliceString(e, n = this.length, r = `
`) {
      [e, n] = pl(this, e, n);
      let i = "";
      for (let o = 0, s = 0; o < this.children.length && s <= n; o++) {
        let a = this.children[o], l = s + a.length;
        s > e && o && (i += r), e < l && n > s && (i += a.sliceString(e - s, n - s, r)), s = l + 1;
      }
      return i;
    }
    flatten(e) {
      for (let n of this.children)
        n.flatten(e);
    }
    scanIdentical(e, n) {
      if (!(e instanceof pi))
        return 0;
      let r = 0, [i, o, s, a] = n > 0 ? [
        0,
        0,
        this.children.length,
        e.children.length
      ] : [
        this.children.length - 1,
        e.children.length - 1,
        -1,
        -1
      ];
      for (; ; i += n, o += n) {
        if (i == s || o == a)
          return r;
        let l = this.children[i], c = e.children[o];
        if (l != c)
          return r + l.scanIdentical(c, n);
        r += l.length + 1;
      }
    }
    static from(e, n = e.reduce((r, i) => r + i.length + 1, -1)) {
      let r = 0;
      for (let v of e)
        r += v.lines;
      if (r < 32) {
        let v = [];
        for (let y of e)
          y.flatten(v);
        return new Ct(v, n);
      }
      let i = Math.max(32, r >> 5), o = i << 1, s = i >> 1, a = [], l = 0, c = -1, u = [];
      function h(v) {
        let y;
        if (v.lines > o && v instanceof pi)
          for (let S of v.children)
            h(S);
        else
          v.lines > s && (l > s || !l) ? (p(), a.push(v)) : v instanceof Ct && l && (y = u[u.length - 1]) instanceof Ct && v.lines + y.lines <= 32 ? (l += v.lines, c += v.length + 1, u[u.length - 1] = new Ct(y.text.concat(v.text), y.length + 1 + v.length)) : (l + v.lines > i && p(), l += v.lines, c += v.length + 1, u.push(v));
      }
      function p() {
        l != 0 && (a.push(u.length == 1 ? u[0] : pi.from(u, c)), c = -1, l = u.length = 0);
      }
      for (let v of e)
        h(v);
      return p(), a.length == 1 ? a[0] : new pi(a, n);
    }
  }
  He.empty = new Ct([
    ""
  ], 0);
  function Lj(t) {
    let e = -1;
    for (let n of t)
      e += n.length + 1;
    return e;
  }
  function bd(t, e, n = 0, r = 1e9) {
    for (let i = 0, o = 0, s = true; o < t.length && i <= r; o++) {
      let a = t[o], l = i + a.length;
      l >= n && (l > r && (a = a.slice(0, r - i)), i < n && (a = a.slice(n - i)), s ? (e[e.length - 1] += a, s = false) : e.push(a)), i = l + 1;
    }
    return e;
  }
  function xC(t, e, n) {
    return bd(t, [
      ""
    ], e, n);
  }
  class qc {
    constructor(e, n = 1) {
      this.dir = n, this.done = false, this.lineBreak = false, this.value = "", this.nodes = [
        e
      ], this.offsets = [
        n > 0 ? 1 : (e instanceof Ct ? e.text.length : e.children.length) << 1
      ];
    }
    nextInner(e, n) {
      for (this.done = this.lineBreak = false; ; ) {
        let r = this.nodes.length - 1, i = this.nodes[r], o = this.offsets[r], s = o >> 1, a = i instanceof Ct ? i.text.length : i.children.length;
        if (s == (n > 0 ? a : 0)) {
          if (r == 0)
            return this.done = true, this.value = "", this;
          n > 0 && this.offsets[r - 1]++, this.nodes.pop(), this.offsets.pop();
        } else if ((o & 1) == (n > 0 ? 0 : 1)) {
          if (this.offsets[r] += n, e == 0)
            return this.lineBreak = true, this.value = `
`, this;
          e--;
        } else if (i instanceof Ct) {
          let l = i.text[s + (n < 0 ? -1 : 0)];
          if (this.offsets[r] += n, l.length > Math.max(0, e))
            return this.value = e == 0 ? l : n > 0 ? l.slice(e) : l.slice(0, l.length - e), this;
          e -= l.length;
        } else {
          let l = i.children[s + (n < 0 ? -1 : 0)];
          e > l.length ? (e -= l.length, this.offsets[r] += n) : (n < 0 && this.offsets[r]--, this.nodes.push(l), this.offsets.push(n > 0 ? 1 : (l instanceof Ct ? l.text.length : l.children.length) << 1));
        }
      }
    }
    next(e = 0) {
      return e < 0 && (this.nextInner(-e, -this.dir), e = this.value.length), this.nextInner(e, this.dir);
    }
  }
  class fO {
    constructor(e, n, r) {
      this.value = "", this.done = false, this.cursor = new qc(e, n > r ? -1 : 1), this.pos = n > r ? e.length : 0, this.from = Math.min(n, r), this.to = Math.max(n, r);
    }
    nextInner(e, n) {
      if (n < 0 ? this.pos <= this.from : this.pos >= this.to)
        return this.value = "", this.done = true, this;
      e += Math.max(0, n < 0 ? this.pos - this.to : this.from - this.pos);
      let r = n < 0 ? this.pos - this.from : this.to - this.pos;
      e > r && (e = r), r -= e;
      let { value: i } = this.cursor.next(e);
      return this.pos += (i.length + e) * n, this.value = i.length <= r ? i : n < 0 ? i.slice(i.length - r) : i.slice(0, r), this.done = !this.value, this;
    }
    next(e = 0) {
      return e < 0 ? e = Math.max(e, this.from - this.pos) : e > 0 && (e = Math.min(e, this.to - this.pos)), this.nextInner(e, this.cursor.dir);
    }
    get lineBreak() {
      return this.cursor.lineBreak && this.value != "";
    }
  }
  class hO {
    constructor(e) {
      this.inner = e, this.afterBreak = true, this.value = "", this.done = false;
    }
    next(e = 0) {
      let { done: n, lineBreak: r, value: i } = this.inner.next(e);
      return n && this.afterBreak ? (this.value = "", this.afterBreak = false) : n ? (this.done = true, this.value = "") : r ? this.afterBreak ? this.value = "" : (this.afterBreak = true, this.next()) : (this.value = i, this.afterBreak = false), this;
    }
    get lineBreak() {
      return false;
    }
  }
  typeof Symbol < "u" && (He.prototype[Symbol.iterator] = function() {
    return this.iter();
  }, qc.prototype[Symbol.iterator] = fO.prototype[Symbol.iterator] = hO.prototype[Symbol.iterator] = function() {
    return this;
  });
  class Rj {
    constructor(e, n, r, i) {
      this.from = e, this.to = n, this.number = r, this.text = i;
    }
    get length() {
      return this.to - this.from;
    }
  }
  function pl(t, e, n) {
    return e = Math.max(0, Math.min(t.length, e)), [
      e,
      Math.max(e, Math.min(t.length, n))
    ];
  }
  function Ht(t, e, n = true, r = true) {
    return Pj(t, e, n, r);
  }
  function _j(t) {
    return t >= 56320 && t < 57344;
  }
  function Dj(t) {
    return t >= 55296 && t < 56320;
  }
  function On(t, e) {
    let n = t.charCodeAt(e);
    if (!Dj(n) || e + 1 == t.length)
      return n;
    let r = t.charCodeAt(e + 1);
    return _j(r) ? (n - 55296 << 10) + (r - 56320) + 65536 : n;
  }
  function Mx(t) {
    return t <= 65535 ? String.fromCharCode(t) : (t -= 65536, String.fromCharCode((t >> 10) + 55296, (t & 1023) + 56320));
  }
  function mi(t) {
    return t < 65536 ? 1 : 2;
  }
  const Fy = /\r\n?|\n/;
  var Zt = function(t) {
    return t[t.Simple = 0] = "Simple", t[t.TrackDel = 1] = "TrackDel", t[t.TrackBefore = 2] = "TrackBefore", t[t.TrackAfter = 3] = "TrackAfter", t;
  }(Zt || (Zt = {}));
  class Mi {
    constructor(e) {
      this.sections = e;
    }
    get length() {
      let e = 0;
      for (let n = 0; n < this.sections.length; n += 2)
        e += this.sections[n];
      return e;
    }
    get newLength() {
      let e = 0;
      for (let n = 0; n < this.sections.length; n += 2) {
        let r = this.sections[n + 1];
        e += r < 0 ? this.sections[n] : r;
      }
      return e;
    }
    get empty() {
      return this.sections.length == 0 || this.sections.length == 2 && this.sections[1] < 0;
    }
    iterGaps(e) {
      for (let n = 0, r = 0, i = 0; n < this.sections.length; ) {
        let o = this.sections[n++], s = this.sections[n++];
        s < 0 ? (e(r, i, o), i += o) : i += s, r += o;
      }
    }
    iterChangedRanges(e, n = false) {
      Vy(this, e, n);
    }
    get invertedDesc() {
      let e = [];
      for (let n = 0; n < this.sections.length; ) {
        let r = this.sections[n++], i = this.sections[n++];
        i < 0 ? e.push(r, i) : e.push(i, r);
      }
      return new Mi(e);
    }
    composeDesc(e) {
      return this.empty ? e : e.empty ? this : dO(this, e);
    }
    mapDesc(e, n = false) {
      return e.empty ? this : Wy(this, e, n);
    }
    mapPos(e, n = -1, r = Zt.Simple) {
      let i = 0, o = 0;
      for (let s = 0; s < this.sections.length; ) {
        let a = this.sections[s++], l = this.sections[s++], c = i + a;
        if (l < 0) {
          if (c > e)
            return o + (e - i);
          o += a;
        } else {
          if (r != Zt.Simple && c >= e && (r == Zt.TrackDel && i < e && c > e || r == Zt.TrackBefore && i < e || r == Zt.TrackAfter && c > e))
            return null;
          if (c > e || c == e && n < 0 && !a)
            return e == i || n < 0 ? o : o + l;
          o += l;
        }
        i = c;
      }
      if (e > i)
        throw new RangeError(`Position ${e} is out of range for changeset of length ${i}`);
      return o;
    }
    touchesRange(e, n = e) {
      for (let r = 0, i = 0; r < this.sections.length && i <= n; ) {
        let o = this.sections[r++], s = this.sections[r++], a = i + o;
        if (s >= 0 && i <= n && a >= e)
          return i < e && a > n ? "cover" : true;
        i = a;
      }
      return false;
    }
    toString() {
      let e = "";
      for (let n = 0; n < this.sections.length; ) {
        let r = this.sections[n++], i = this.sections[n++];
        e += (e ? " " : "") + r + (i >= 0 ? ":" + i : "");
      }
      return e;
    }
    toJSON() {
      return this.sections;
    }
    static fromJSON(e) {
      if (!Array.isArray(e) || e.length % 2 || e.some((n) => typeof n != "number"))
        throw new RangeError("Invalid JSON representation of ChangeDesc");
      return new Mi(e);
    }
    static create(e) {
      return new Mi(e);
    }
  }
  class Dt extends Mi {
    constructor(e, n) {
      super(e), this.inserted = n;
    }
    apply(e) {
      if (this.length != e.length)
        throw new RangeError("Applying change set to a document with the wrong length");
      return Vy(this, (n, r, i, o, s) => e = e.replace(i, i + (r - n), s), false), e;
    }
    mapDesc(e, n = false) {
      return Wy(this, e, n, true);
    }
    invert(e) {
      let n = this.sections.slice(), r = [];
      for (let i = 0, o = 0; i < n.length; i += 2) {
        let s = n[i], a = n[i + 1];
        if (a >= 0) {
          n[i] = a, n[i + 1] = s;
          let l = i >> 1;
          for (; r.length < l; )
            r.push(He.empty);
          r.push(s ? e.slice(o, o + s) : He.empty);
        }
        o += s;
      }
      return new Dt(n, r);
    }
    compose(e) {
      return this.empty ? e : e.empty ? this : dO(this, e, true);
    }
    map(e, n = false) {
      return e.empty ? this : Wy(this, e, n, true);
    }
    iterChanges(e, n = false) {
      Vy(this, e, n);
    }
    get desc() {
      return Mi.create(this.sections);
    }
    filter(e) {
      let n = [], r = [], i = [], o = new Ru(this);
      e:
        for (let s = 0, a = 0; ; ) {
          let l = s == e.length ? 1e9 : e[s++];
          for (; a < l || a == l && o.len == 0; ) {
            if (o.done)
              break e;
            let u = Math.min(o.len, l - a);
            fn(i, u, -1);
            let h = o.ins == -1 ? -1 : o.off == 0 ? o.ins : 0;
            fn(n, u, h), h > 0 && Ro(r, n, o.text), o.forward(u), a += u;
          }
          let c = e[s++];
          for (; a < c; ) {
            if (o.done)
              break e;
            let u = Math.min(o.len, c - a);
            fn(n, u, -1), fn(i, u, o.ins == -1 ? -1 : o.off == 0 ? o.ins : 0), o.forward(u), a += u;
          }
        }
      return {
        changes: new Dt(n, r),
        filtered: Mi.create(i)
      };
    }
    toJSON() {
      let e = [];
      for (let n = 0; n < this.sections.length; n += 2) {
        let r = this.sections[n], i = this.sections[n + 1];
        i < 0 ? e.push(r) : i == 0 ? e.push([
          r
        ]) : e.push([
          r
        ].concat(this.inserted[n >> 1].toJSON()));
      }
      return e;
    }
    static of(e, n, r) {
      let i = [], o = [], s = 0, a = null;
      function l(u = false) {
        if (!u && !i.length)
          return;
        s < n && fn(i, n - s, -1);
        let h = new Dt(i, o);
        a = a ? a.compose(h.map(a)) : h, i = [], o = [], s = 0;
      }
      function c(u) {
        if (Array.isArray(u))
          for (let h of u)
            c(h);
        else if (u instanceof Dt) {
          if (u.length != n)
            throw new RangeError(`Mismatched change set length (got ${u.length}, expected ${n})`);
          l(), a = a ? a.compose(u.map(a)) : u;
        } else {
          let { from: h, to: p = h, insert: v } = u;
          if (h > p || h < 0 || p > n)
            throw new RangeError(`Invalid change range ${h} to ${p} (in doc of length ${n})`);
          let y = v ? typeof v == "string" ? He.of(v.split(r || Fy)) : v : He.empty, S = y.length;
          if (h == p && S == 0)
            return;
          h < s && l(), h > s && fn(i, h - s, -1), fn(i, p - h, S), Ro(o, i, y), s = p;
        }
      }
      return c(e), l(!a), a;
    }
    static empty(e) {
      return new Dt(e ? [
        e,
        -1
      ] : [], []);
    }
    static fromJSON(e) {
      if (!Array.isArray(e))
        throw new RangeError("Invalid JSON representation of ChangeSet");
      let n = [], r = [];
      for (let i = 0; i < e.length; i++) {
        let o = e[i];
        if (typeof o == "number")
          n.push(o, -1);
        else {
          if (!Array.isArray(o) || typeof o[0] != "number" || o.some((s, a) => a && typeof s != "string"))
            throw new RangeError("Invalid JSON representation of ChangeSet");
          if (o.length == 1)
            n.push(o[0], 0);
          else {
            for (; r.length < i; )
              r.push(He.empty);
            r[i] = He.of(o.slice(1)), n.push(o[0], r[i].length);
          }
        }
      }
      return new Dt(n, r);
    }
    static createSet(e, n) {
      return new Dt(e, n);
    }
  }
  function fn(t, e, n, r = false) {
    if (e == 0 && n <= 0)
      return;
    let i = t.length - 2;
    i >= 0 && n <= 0 && n == t[i + 1] ? t[i] += e : i >= 0 && e == 0 && t[i] == 0 ? t[i + 1] += n : r ? (t[i] += e, t[i + 1] += n) : t.push(e, n);
  }
  function Ro(t, e, n) {
    if (n.length == 0)
      return;
    let r = e.length - 2 >> 1;
    if (r < t.length)
      t[t.length - 1] = t[t.length - 1].append(n);
    else {
      for (; t.length < r; )
        t.push(He.empty);
      t.push(n);
    }
  }
  function Vy(t, e, n) {
    let r = t.inserted;
    for (let i = 0, o = 0, s = 0; s < t.sections.length; ) {
      let a = t.sections[s++], l = t.sections[s++];
      if (l < 0)
        i += a, o += a;
      else {
        let c = i, u = o, h = He.empty;
        for (; c += a, u += l, l && r && (h = h.append(r[s - 2 >> 1])), !(n || s == t.sections.length || t.sections[s + 1] < 0); )
          a = t.sections[s++], l = t.sections[s++];
        e(i, c, o, u, h), i = c, o = u;
      }
    }
  }
  function Wy(t, e, n, r = false) {
    let i = [], o = r ? [] : null, s = new Ru(t), a = new Ru(e);
    for (let l = -1; ; ) {
      if (s.done && a.len || a.done && s.len)
        throw new Error("Mismatched change set lengths");
      if (s.ins == -1 && a.ins == -1) {
        let c = Math.min(s.len, a.len);
        fn(i, c, -1), s.forward(c), a.forward(c);
      } else if (a.ins >= 0 && (s.ins < 0 || l == s.i || s.off == 0 && (a.len < s.len || a.len == s.len && !n))) {
        let c = a.len;
        for (fn(i, a.ins, -1); c; ) {
          let u = Math.min(s.len, c);
          s.ins >= 0 && l < s.i && s.len <= u && (fn(i, 0, s.ins), o && Ro(o, i, s.text), l = s.i), s.forward(u), c -= u;
        }
        a.next();
      } else if (s.ins >= 0) {
        let c = 0, u = s.len;
        for (; u; )
          if (a.ins == -1) {
            let h = Math.min(u, a.len);
            c += h, u -= h, a.forward(h);
          } else if (a.ins == 0 && a.len < u)
            u -= a.len, a.next();
          else
            break;
        fn(i, c, l < s.i ? s.ins : 0), o && l < s.i && Ro(o, i, s.text), l = s.i, s.forward(s.len - u);
      } else {
        if (s.done && a.done)
          return o ? Dt.createSet(i, o) : Mi.create(i);
        throw new Error("Mismatched change set lengths");
      }
    }
  }
  function dO(t, e, n = false) {
    let r = [], i = n ? [] : null, o = new Ru(t), s = new Ru(e);
    for (let a = false; ; ) {
      if (o.done && s.done)
        return i ? Dt.createSet(r, i) : Mi.create(r);
      if (o.ins == 0)
        fn(r, o.len, 0, a), o.next();
      else if (s.len == 0 && !s.done)
        fn(r, 0, s.ins, a), i && Ro(i, r, s.text), s.next();
      else {
        if (o.done || s.done)
          throw new Error("Mismatched change set lengths");
        {
          let l = Math.min(o.len2, s.len), c = r.length;
          if (o.ins == -1) {
            let u = s.ins == -1 ? -1 : s.off ? 0 : s.ins;
            fn(r, l, u, a), i && u && Ro(i, r, s.text);
          } else
            s.ins == -1 ? (fn(r, o.off ? 0 : o.len, l, a), i && Ro(i, r, o.textBit(l))) : (fn(r, o.off ? 0 : o.len, s.off ? 0 : s.ins, a), i && !s.off && Ro(i, r, s.text));
          a = (o.ins > l || s.ins >= 0 && s.len > l) && (a || r.length > c), o.forward2(l), s.forward(l);
        }
      }
    }
  }
  class Ru {
    constructor(e) {
      this.set = e, this.i = 0, this.next();
    }
    next() {
      let { sections: e } = this.set;
      this.i < e.length ? (this.len = e[this.i++], this.ins = e[this.i++]) : (this.len = 0, this.ins = -2), this.off = 0;
    }
    get done() {
      return this.ins == -2;
    }
    get len2() {
      return this.ins < 0 ? this.len : this.ins;
    }
    get text() {
      let { inserted: e } = this.set, n = this.i - 2 >> 1;
      return n >= e.length ? He.empty : e[n];
    }
    textBit(e) {
      let { inserted: n } = this.set, r = this.i - 2 >> 1;
      return r >= n.length && !e ? He.empty : n[r].slice(this.off, e == null ? void 0 : this.off + e);
    }
    forward(e) {
      e == this.len ? this.next() : (this.len -= e, this.off += e);
    }
    forward2(e) {
      this.ins == -1 ? this.forward(e) : e == this.ins ? this.next() : (this.ins -= e, this.off += e);
    }
  }
  class Ps {
    constructor(e, n, r) {
      this.from = e, this.to = n, this.flags = r;
    }
    get anchor() {
      return this.flags & 32 ? this.to : this.from;
    }
    get head() {
      return this.flags & 32 ? this.from : this.to;
    }
    get empty() {
      return this.from == this.to;
    }
    get assoc() {
      return this.flags & 8 ? -1 : this.flags & 16 ? 1 : 0;
    }
    get bidiLevel() {
      let e = this.flags & 7;
      return e == 7 ? null : e;
    }
    get goalColumn() {
      let e = this.flags >> 6;
      return e == 16777215 ? void 0 : e;
    }
    map(e, n = -1) {
      let r, i;
      return this.empty ? r = i = e.mapPos(this.from, n) : (r = e.mapPos(this.from, 1), i = e.mapPos(this.to, -1)), r == this.from && i == this.to ? this : new Ps(r, i, this.flags);
    }
    extend(e, n = e) {
      if (e <= this.anchor && n >= this.anchor)
        return q.range(e, n);
      let r = Math.abs(e - this.anchor) > Math.abs(n - this.anchor) ? e : n;
      return q.range(this.anchor, r);
    }
    eq(e, n = false) {
      return this.anchor == e.anchor && this.head == e.head && this.goalColumn == e.goalColumn && (!n || !this.empty || this.assoc == e.assoc);
    }
    toJSON() {
      return {
        anchor: this.anchor,
        head: this.head
      };
    }
    static fromJSON(e) {
      if (!e || typeof e.anchor != "number" || typeof e.head != "number")
        throw new RangeError("Invalid JSON representation for SelectionRange");
      return q.range(e.anchor, e.head);
    }
    static create(e, n, r) {
      return new Ps(e, n, r);
    }
  }
  class q {
    constructor(e, n) {
      this.ranges = e, this.mainIndex = n;
    }
    map(e, n = -1) {
      return e.empty ? this : q.create(this.ranges.map((r) => r.map(e, n)), this.mainIndex);
    }
    eq(e, n = false) {
      if (this.ranges.length != e.ranges.length || this.mainIndex != e.mainIndex)
        return false;
      for (let r = 0; r < this.ranges.length; r++)
        if (!this.ranges[r].eq(e.ranges[r], n))
          return false;
      return true;
    }
    get main() {
      return this.ranges[this.mainIndex];
    }
    asSingle() {
      return this.ranges.length == 1 ? this : new q([
        this.main
      ], 0);
    }
    addRange(e, n = true) {
      return q.create([
        e
      ].concat(this.ranges), n ? 0 : this.mainIndex + 1);
    }
    replaceRange(e, n = this.mainIndex) {
      let r = this.ranges.slice();
      return r[n] = e, q.create(r, this.mainIndex);
    }
    toJSON() {
      return {
        ranges: this.ranges.map((e) => e.toJSON()),
        main: this.mainIndex
      };
    }
    static fromJSON(e) {
      if (!e || !Array.isArray(e.ranges) || typeof e.main != "number" || e.main >= e.ranges.length)
        throw new RangeError("Invalid JSON representation for EditorSelection");
      return new q(e.ranges.map((n) => Ps.fromJSON(n)), e.main);
    }
    static single(e, n = e) {
      return new q([
        q.range(e, n)
      ], 0);
    }
    static create(e, n = 0) {
      if (e.length == 0)
        throw new RangeError("A selection needs at least one range");
      for (let r = 0, i = 0; i < e.length; i++) {
        let o = e[i];
        if (o.empty ? o.from <= r : o.from < r)
          return q.normalized(e.slice(), n);
        r = o.to;
      }
      return new q(e, n);
    }
    static cursor(e, n = 0, r, i) {
      return Ps.create(e, e, (n == 0 ? 0 : n < 0 ? 8 : 16) | (r == null ? 7 : Math.min(6, r)) | (i ?? 16777215) << 6);
    }
    static range(e, n, r, i) {
      let o = (r ?? 16777215) << 6 | (i == null ? 7 : Math.min(6, i));
      return n < e ? Ps.create(n, e, 48 | o) : Ps.create(e, n, (n > e ? 8 : 0) | o);
    }
    static normalized(e, n = 0) {
      let r = e[n];
      e.sort((i, o) => i.from - o.from), n = e.indexOf(r);
      for (let i = 1; i < e.length; i++) {
        let o = e[i], s = e[i - 1];
        if (o.empty ? o.from <= s.to : o.from < s.to) {
          let a = s.from, l = Math.max(o.to, s.to);
          i <= n && n--, e.splice(--i, 2, o.anchor > o.head ? q.range(l, a) : q.range(a, l));
        }
      }
      return new q(e, n);
    }
  }
  function pO(t, e) {
    for (let n of t.ranges)
      if (n.to > e)
        throw new RangeError("Selection points outside of document");
  }
  let Ax = 0;
  class me {
    constructor(e, n, r, i, o) {
      this.combine = e, this.compareInput = n, this.compare = r, this.isStatic = i, this.id = Ax++, this.default = e([]), this.extensions = typeof o == "function" ? o(this) : o;
    }
    get reader() {
      return this;
    }
    static define(e = {}) {
      return new me(e.combine || ((n) => n), e.compareInput || ((n, r) => n === r), e.compare || (e.combine ? (n, r) => n === r : Ex), !!e.static, e.enables);
    }
    of(e) {
      return new xd([], this, 0, e);
    }
    compute(e, n) {
      if (this.isStatic)
        throw new Error("Can't compute a static facet");
      return new xd(e, this, 1, n);
    }
    computeN(e, n) {
      if (this.isStatic)
        throw new Error("Can't compute a static facet");
      return new xd(e, this, 2, n);
    }
    from(e, n) {
      return n || (n = (r) => r), this.compute([
        e
      ], (r) => n(r.field(e)));
    }
  }
  function Ex(t, e) {
    return t == e || t.length == e.length && t.every((n, r) => n === e[r]);
  }
  class xd {
    constructor(e, n, r, i) {
      this.dependencies = e, this.facet = n, this.type = r, this.value = i, this.id = Ax++;
    }
    dynamicSlot(e) {
      var n;
      let r = this.value, i = this.facet.compareInput, o = this.id, s = e[o] >> 1, a = this.type == 2, l = false, c = false, u = [];
      for (let h of this.dependencies)
        h == "doc" ? l = true : h == "selection" ? c = true : (((n = e[h.id]) !== null && n !== void 0 ? n : 1) & 1) == 0 && u.push(e[h.id]);
      return {
        create(h) {
          return h.values[s] = r(h), 1;
        },
        update(h, p) {
          if (l && p.docChanged || c && (p.docChanged || p.selection) || Hy(h, u)) {
            let v = r(h);
            if (a ? !SC(v, h.values[s], i) : !i(v, h.values[s]))
              return h.values[s] = v, 1;
          }
          return 0;
        },
        reconfigure: (h, p) => {
          let v, y = p.config.address[o];
          if (y != null) {
            let S = vp(p, y);
            if (this.dependencies.every((T) => T instanceof me ? p.facet(T) === h.facet(T) : T instanceof Kt ? p.field(T, false) == h.field(T, false) : true) || (a ? SC(v = r(h), S, i) : i(v = r(h), S)))
              return h.values[s] = S, 0;
          } else
            v = r(h);
          return h.values[s] = v, 1;
        }
      };
    }
  }
  function SC(t, e, n) {
    if (t.length != e.length)
      return false;
    for (let r = 0; r < t.length; r++)
      if (!n(t[r], e[r]))
        return false;
    return true;
  }
  function Hy(t, e) {
    let n = false;
    for (let r of e)
      Gc(t, r) & 1 && (n = true);
    return n;
  }
  function Ij(t, e, n) {
    let r = n.map((l) => t[l.id]), i = n.map((l) => l.type), o = r.filter((l) => !(l & 1)), s = t[e.id] >> 1;
    function a(l) {
      let c = [];
      for (let u = 0; u < r.length; u++) {
        let h = vp(l, r[u]);
        if (i[u] == 2)
          for (let p of h)
            c.push(p);
        else
          c.push(h);
      }
      return e.combine(c);
    }
    return {
      create(l) {
        for (let c of r)
          Gc(l, c);
        return l.values[s] = a(l), 1;
      },
      update(l, c) {
        if (!Hy(l, o))
          return 0;
        let u = a(l);
        return e.compare(u, l.values[s]) ? 0 : (l.values[s] = u, 1);
      },
      reconfigure(l, c) {
        let u = Hy(l, r), h = c.config.facets[e.id], p = c.facet(e);
        if (h && !u && Ex(n, h))
          return l.values[s] = p, 0;
        let v = a(l);
        return e.compare(v, p) ? (l.values[s] = p, 0) : (l.values[s] = v, 1);
      }
    };
  }
  const xh = me.define({
    static: true
  });
  class Kt {
    constructor(e, n, r, i, o) {
      this.id = e, this.createF = n, this.updateF = r, this.compareF = i, this.spec = o, this.provides = void 0;
    }
    static define(e) {
      let n = new Kt(Ax++, e.create, e.update, e.compare || ((r, i) => r === i), e);
      return e.provide && (n.provides = e.provide(n)), n;
    }
    create(e) {
      let n = e.facet(xh).find((r) => r.field == this);
      return ((n == null ? void 0 : n.create) || this.createF)(e);
    }
    slot(e) {
      let n = e[this.id] >> 1;
      return {
        create: (r) => (r.values[n] = this.create(r), 1),
        update: (r, i) => {
          let o = r.values[n], s = this.updateF(o, i);
          return this.compareF(o, s) ? 0 : (r.values[n] = s, 1);
        },
        reconfigure: (r, i) => {
          let o = r.facet(xh), s = i.facet(xh), a;
          return (a = o.find((l) => l.field == this)) && a != s.find((l) => l.field == this) ? (r.values[n] = a.create(r), 1) : i.config.address[this.id] != null ? (r.values[n] = i.field(this), 0) : (r.values[n] = this.create(r), 1);
        }
      };
    }
    init(e) {
      return [
        this,
        xh.of({
          field: this,
          create: e
        })
      ];
    }
    get extension() {
      return this;
    }
  }
  const ws = {
    lowest: 4,
    low: 3,
    default: 2,
    high: 1,
    highest: 0
  };
  function ic(t) {
    return (e) => new mO(e, t);
  }
  const ns = {
    highest: ic(ws.highest),
    high: ic(ws.high),
    default: ic(ws.default),
    low: ic(ws.low),
    lowest: ic(ws.lowest)
  };
  class mO {
    constructor(e, n) {
      this.inner = e, this.prec = n;
    }
  }
  class Nm {
    of(e) {
      return new jy(this, e);
    }
    reconfigure(e) {
      return Nm.reconfigure.of({
        compartment: this,
        extension: e
      });
    }
    get(e) {
      return e.config.compartments.get(this);
    }
  }
  class jy {
    constructor(e, n) {
      this.compartment = e, this.inner = n;
    }
  }
  class gp {
    constructor(e, n, r, i, o, s) {
      for (this.base = e, this.compartments = n, this.dynamicSlots = r, this.address = i, this.staticValues = o, this.facets = s, this.statusTemplate = []; this.statusTemplate.length < r.length; )
        this.statusTemplate.push(0);
    }
    staticFacet(e) {
      let n = this.address[e.id];
      return n == null ? e.default : this.staticValues[n >> 1];
    }
    static resolve(e, n, r) {
      let i = [], o = /* @__PURE__ */ Object.create(null), s = /* @__PURE__ */ new Map();
      for (let p of Bj(e, n, s))
        p instanceof Kt ? i.push(p) : (o[p.facet.id] || (o[p.facet.id] = [])).push(p);
      let a = /* @__PURE__ */ Object.create(null), l = [], c = [];
      for (let p of i)
        a[p.id] = c.length << 1, c.push((v) => p.slot(v));
      let u = r == null ? void 0 : r.config.facets;
      for (let p in o) {
        let v = o[p], y = v[0].facet, S = u && u[p] || [];
        if (v.every((T) => T.type == 0))
          if (a[y.id] = l.length << 1 | 1, Ex(S, v))
            l.push(r.facet(y));
          else {
            let T = y.combine(v.map((w) => w.value));
            l.push(r && y.compare(T, r.facet(y)) ? r.facet(y) : T);
          }
        else {
          for (let T of v)
            T.type == 0 ? (a[T.id] = l.length << 1 | 1, l.push(T.value)) : (a[T.id] = c.length << 1, c.push((w) => T.dynamicSlot(w)));
          a[y.id] = c.length << 1, c.push((T) => Ij(T, y, v));
        }
      }
      let h = c.map((p) => p(a));
      return new gp(e, s, h, a, l, o);
    }
  }
  function Bj(t, e, n) {
    let r = [
      [],
      [],
      [],
      [],
      []
    ], i = /* @__PURE__ */ new Map();
    function o(s, a) {
      let l = i.get(s);
      if (l != null) {
        if (l <= a)
          return;
        let c = r[l].indexOf(s);
        c > -1 && r[l].splice(c, 1), s instanceof jy && n.delete(s.compartment);
      }
      if (i.set(s, a), Array.isArray(s))
        for (let c of s)
          o(c, a);
      else if (s instanceof jy) {
        if (n.has(s.compartment))
          throw new RangeError("Duplicate use of compartment in extensions");
        let c = e.get(s.compartment) || s.inner;
        n.set(s.compartment, c), o(c, a);
      } else if (s instanceof mO)
        o(s.inner, s.prec);
      else if (s instanceof Kt)
        r[a].push(s), s.provides && o(s.provides, a);
      else if (s instanceof xd)
        r[a].push(s), s.facet.extensions && o(s.facet.extensions, ws.default);
      else {
        let c = s.extension;
        if (!c)
          throw new Error(`Unrecognized extension value in extension set (${s}). This sometimes happens because multiple instances of @codemirror/state are loaded, breaking instanceof checks.`);
        o(c, a);
      }
    }
    return o(t, ws.default), r.reduce((s, a) => s.concat(a));
  }
  function Gc(t, e) {
    if (e & 1)
      return 2;
    let n = e >> 1, r = t.status[n];
    if (r == 4)
      throw new Error("Cyclic dependency between fields and/or facets");
    if (r & 2)
      return r;
    t.status[n] = 4;
    let i = t.computeSlot(t, t.config.dynamicSlots[n]);
    return t.status[n] = 2 | i;
  }
  function vp(t, e) {
    return e & 1 ? t.config.staticValues[e >> 1] : t.values[e >> 1];
  }
  const gO = me.define(), Uy = me.define({
    combine: (t) => t.some((e) => e),
    static: true
  }), vO = me.define({
    combine: (t) => t.length ? t[0] : void 0,
    static: true
  }), yO = me.define(), bO = me.define(), xO = me.define(), SO = me.define({
    combine: (t) => t.length ? t[0] : false
  });
  class Pi {
    constructor(e, n) {
      this.type = e, this.value = n;
    }
    static define() {
      return new Nj();
    }
  }
  class Nj {
    of(e) {
      return new Pi(this, e);
    }
  }
  class $j {
    constructor(e) {
      this.map = e;
    }
    of(e) {
      return new Ee(this, e);
    }
  }
  class Ee {
    constructor(e, n) {
      this.type = e, this.value = n;
    }
    map(e) {
      let n = this.type.map(this.value, e);
      return n === void 0 ? void 0 : n == this.value ? this : new Ee(this.type, n);
    }
    is(e) {
      return this.type == e;
    }
    static define(e = {}) {
      return new $j(e.map || ((n) => n));
    }
    static mapEffects(e, n) {
      if (!e.length)
        return e;
      let r = [];
      for (let i of e) {
        let o = i.map(n);
        o && r.push(o);
      }
      return r;
    }
  }
  Ee.reconfigure = Ee.define();
  Ee.appendConfig = Ee.define();
  class Bt {
    constructor(e, n, r, i, o, s) {
      this.startState = e, this.changes = n, this.selection = r, this.effects = i, this.annotations = o, this.scrollIntoView = s, this._doc = null, this._state = null, r && pO(r, n.newLength), o.some((a) => a.type == Bt.time) || (this.annotations = o.concat(Bt.time.of(Date.now())));
    }
    static create(e, n, r, i, o, s) {
      return new Bt(e, n, r, i, o, s);
    }
    get newDoc() {
      return this._doc || (this._doc = this.changes.apply(this.startState.doc));
    }
    get newSelection() {
      return this.selection || this.startState.selection.map(this.changes);
    }
    get state() {
      return this._state || this.startState.applyTransaction(this), this._state;
    }
    annotation(e) {
      for (let n of this.annotations)
        if (n.type == e)
          return n.value;
    }
    get docChanged() {
      return !this.changes.empty;
    }
    get reconfigured() {
      return this.startState.config != this.state.config;
    }
    isUserEvent(e) {
      let n = this.annotation(Bt.userEvent);
      return !!(n && (n == e || n.length > e.length && n.slice(0, e.length) == e && n[e.length] == "."));
    }
  }
  Bt.time = Pi.define();
  Bt.userEvent = Pi.define();
  Bt.addToHistory = Pi.define();
  Bt.remote = Pi.define();
  function zj(t, e) {
    let n = [];
    for (let r = 0, i = 0; ; ) {
      let o, s;
      if (r < t.length && (i == e.length || e[i] >= t[r]))
        o = t[r++], s = t[r++];
      else if (i < e.length)
        o = e[i++], s = e[i++];
      else
        return n;
      !n.length || n[n.length - 1] < o ? n.push(o, s) : n[n.length - 1] < s && (n[n.length - 1] = s);
    }
  }
  function wO(t, e, n) {
    var r;
    let i, o, s;
    return n ? (i = e.changes, o = Dt.empty(e.changes.length), s = t.changes.compose(e.changes)) : (i = e.changes.map(t.changes), o = t.changes.mapDesc(e.changes, true), s = t.changes.compose(i)), {
      changes: s,
      selection: e.selection ? e.selection.map(o) : (r = t.selection) === null || r === void 0 ? void 0 : r.map(i),
      effects: Ee.mapEffects(t.effects, i).concat(Ee.mapEffects(e.effects, o)),
      annotations: t.annotations.length ? t.annotations.concat(e.annotations) : e.annotations,
      scrollIntoView: t.scrollIntoView || e.scrollIntoView
    };
  }
  function Ky(t, e, n) {
    let r = e.selection, i = Ya(e.annotations);
    return e.userEvent && (i = i.concat(Bt.userEvent.of(e.userEvent))), {
      changes: e.changes instanceof Dt ? e.changes : Dt.of(e.changes || [], n, t.facet(vO)),
      selection: r && (r instanceof q ? r : q.single(r.anchor, r.head)),
      effects: Ya(e.effects),
      annotations: i,
      scrollIntoView: !!e.scrollIntoView
    };
  }
  function kO(t, e, n) {
    let r = Ky(t, e.length ? e[0] : {}, t.doc.length);
    e.length && e[0].filter === false && (n = false);
    for (let o = 1; o < e.length; o++) {
      e[o].filter === false && (n = false);
      let s = !!e[o].sequential;
      r = wO(r, Ky(t, e[o], s ? r.changes.newLength : t.doc.length), s);
    }
    let i = Bt.create(t, r.changes, r.selection, r.effects, r.annotations, r.scrollIntoView);
    return Vj(n ? Fj(i) : i);
  }
  function Fj(t) {
    let e = t.startState, n = true;
    for (let i of e.facet(yO)) {
      let o = i(t);
      if (o === false) {
        n = false;
        break;
      }
      Array.isArray(o) && (n = n === true ? o : zj(n, o));
    }
    if (n !== true) {
      let i, o;
      if (n === false)
        o = t.changes.invertedDesc, i = Dt.empty(e.doc.length);
      else {
        let s = t.changes.filter(n);
        i = s.changes, o = s.filtered.mapDesc(s.changes).invertedDesc;
      }
      t = Bt.create(e, i, t.selection && t.selection.map(o), Ee.mapEffects(t.effects, o), t.annotations, t.scrollIntoView);
    }
    let r = e.facet(bO);
    for (let i = r.length - 1; i >= 0; i--) {
      let o = r[i](t);
      o instanceof Bt ? t = o : Array.isArray(o) && o.length == 1 && o[0] instanceof Bt ? t = o[0] : t = kO(e, Ya(o), false);
    }
    return t;
  }
  function Vj(t) {
    let e = t.startState, n = e.facet(xO), r = t;
    for (let i = n.length - 1; i >= 0; i--) {
      let o = n[i](t);
      o && Object.keys(o).length && (r = wO(r, Ky(e, o, t.changes.newLength), true));
    }
    return r == t ? t : Bt.create(e, t.changes, t.selection, r.effects, r.annotations, r.scrollIntoView);
  }
  const Wj = [];
  function Ya(t) {
    return t == null ? Wj : Array.isArray(t) ? t : [
      t
    ];
  }
  var ft = function(t) {
    return t[t.Word = 0] = "Word", t[t.Space = 1] = "Space", t[t.Other = 2] = "Other", t;
  }(ft || (ft = {}));
  const Hj = /[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/;
  let qy;
  try {
    qy = new RegExp("[\\p{Alphabetic}\\p{Number}_]", "u");
  } catch {
  }
  function jj(t) {
    if (qy)
      return qy.test(t);
    for (let e = 0; e < t.length; e++) {
      let n = t[e];
      if (/\w/.test(n) || n > "\x80" && (n.toUpperCase() != n.toLowerCase() || Hj.test(n)))
        return true;
    }
    return false;
  }
  function Uj(t) {
    return (e) => {
      if (!/\S/.test(e))
        return ft.Space;
      if (jj(e))
        return ft.Word;
      for (let n = 0; n < t.length; n++)
        if (e.indexOf(t[n]) > -1)
          return ft.Word;
      return ft.Other;
    };
  }
  class $e {
    constructor(e, n, r, i, o, s) {
      this.config = e, this.doc = n, this.selection = r, this.values = i, this.status = e.statusTemplate.slice(), this.computeSlot = o, s && (s._state = this);
      for (let a = 0; a < this.config.dynamicSlots.length; a++)
        Gc(this, a << 1);
      this.computeSlot = null;
    }
    field(e, n = true) {
      let r = this.config.address[e.id];
      if (r == null) {
        if (n)
          throw new RangeError("Field is not present in this state");
        return;
      }
      return Gc(this, r), vp(this, r);
    }
    update(...e) {
      return kO(this, e, true);
    }
    applyTransaction(e) {
      let n = this.config, { base: r, compartments: i } = n;
      for (let a of e.effects)
        a.is(Nm.reconfigure) ? (n && (i = /* @__PURE__ */ new Map(), n.compartments.forEach((l, c) => i.set(c, l)), n = null), i.set(a.value.compartment, a.value.extension)) : a.is(Ee.reconfigure) ? (n = null, r = a.value) : a.is(Ee.appendConfig) && (n = null, r = Ya(r).concat(a.value));
      let o;
      n ? o = e.startState.values.slice() : (n = gp.resolve(r, i, this), o = new $e(n, this.doc, this.selection, n.dynamicSlots.map(() => null), (l, c) => c.reconfigure(l, this), null).values);
      let s = e.startState.facet(Uy) ? e.newSelection : e.newSelection.asSingle();
      new $e(n, e.newDoc, s, o, (a, l) => l.update(a, e), e);
    }
    replaceSelection(e) {
      return typeof e == "string" && (e = this.toText(e)), this.changeByRange((n) => ({
        changes: {
          from: n.from,
          to: n.to,
          insert: e
        },
        range: q.cursor(n.from + e.length)
      }));
    }
    changeByRange(e) {
      let n = this.selection, r = e(n.ranges[0]), i = this.changes(r.changes), o = [
        r.range
      ], s = Ya(r.effects);
      for (let a = 1; a < n.ranges.length; a++) {
        let l = e(n.ranges[a]), c = this.changes(l.changes), u = c.map(i);
        for (let p = 0; p < a; p++)
          o[p] = o[p].map(u);
        let h = i.mapDesc(c, true);
        o.push(l.range.map(h)), i = i.compose(u), s = Ee.mapEffects(s, u).concat(Ee.mapEffects(Ya(l.effects), h));
      }
      return {
        changes: i,
        selection: q.create(o, n.mainIndex),
        effects: s
      };
    }
    changes(e = []) {
      return e instanceof Dt ? e : Dt.of(e, this.doc.length, this.facet($e.lineSeparator));
    }
    toText(e) {
      return He.of(e.split(this.facet($e.lineSeparator) || Fy));
    }
    sliceDoc(e = 0, n = this.doc.length) {
      return this.doc.sliceString(e, n, this.lineBreak);
    }
    facet(e) {
      let n = this.config.address[e.id];
      return n == null ? e.default : (Gc(this, n), vp(this, n));
    }
    toJSON(e) {
      let n = {
        doc: this.sliceDoc(),
        selection: this.selection.toJSON()
      };
      if (e)
        for (let r in e) {
          let i = e[r];
          i instanceof Kt && this.config.address[i.id] != null && (n[r] = i.spec.toJSON(this.field(e[r]), this));
        }
      return n;
    }
    static fromJSON(e, n = {}, r) {
      if (!e || typeof e.doc != "string")
        throw new RangeError("Invalid JSON representation for EditorState");
      let i = [];
      if (r) {
        for (let o in r)
          if (Object.prototype.hasOwnProperty.call(e, o)) {
            let s = r[o], a = e[o];
            i.push(s.init((l) => s.spec.fromJSON(a, l)));
          }
      }
      return $e.create({
        doc: e.doc,
        selection: q.fromJSON(e.selection),
        extensions: n.extensions ? i.concat([
          n.extensions
        ]) : i
      });
    }
    static create(e = {}) {
      let n = gp.resolve(e.extensions || [], /* @__PURE__ */ new Map()), r = e.doc instanceof He ? e.doc : He.of((e.doc || "").split(n.staticFacet($e.lineSeparator) || Fy)), i = e.selection ? e.selection instanceof q ? e.selection : q.single(e.selection.anchor, e.selection.head) : q.single(0);
      return pO(i, r.length), n.staticFacet(Uy) || (i = i.asSingle()), new $e(n, r, i, n.dynamicSlots.map(() => null), (o, s) => s.create(o), null);
    }
    get tabSize() {
      return this.facet($e.tabSize);
    }
    get lineBreak() {
      return this.facet($e.lineSeparator) || `
`;
    }
    get readOnly() {
      return this.facet(SO);
    }
    phrase(e, ...n) {
      for (let r of this.facet($e.phrases))
        if (Object.prototype.hasOwnProperty.call(r, e)) {
          e = r[e];
          break;
        }
      return n.length && (e = e.replace(/\$(\$|\d*)/g, (r, i) => {
        if (i == "$")
          return "$";
        let o = +(i || 1);
        return !o || o > n.length ? r : n[o - 1];
      })), e;
    }
    languageDataAt(e, n, r = -1) {
      let i = [];
      for (let o of this.facet(gO))
        for (let s of o(this, n, r))
          Object.prototype.hasOwnProperty.call(s, e) && i.push(s[e]);
      return i;
    }
    charCategorizer(e) {
      let n = this.languageDataAt("wordChars", e);
      return Uj(n.length ? n[0] : "");
    }
    wordAt(e) {
      let { text: n, from: r, length: i } = this.doc.lineAt(e), o = this.charCategorizer(e), s = e - r, a = e - r;
      for (; s > 0; ) {
        let l = Ht(n, s, false);
        if (o(n.slice(l, s)) != ft.Word)
          break;
        s = l;
      }
      for (; a < i; ) {
        let l = Ht(n, a);
        if (o(n.slice(a, l)) != ft.Word)
          break;
        a = l;
      }
      return s == a ? null : q.range(s + r, a + r);
    }
  }
  $e.allowMultipleSelections = Uy;
  $e.tabSize = me.define({
    combine: (t) => t.length ? t[0] : 4
  });
  $e.lineSeparator = vO;
  $e.readOnly = SO;
  $e.phrases = me.define({
    compare(t, e) {
      let n = Object.keys(t), r = Object.keys(e);
      return n.length == r.length && n.every((i) => t[i] == e[i]);
    }
  });
  $e.languageData = gO;
  $e.changeFilter = yO;
  $e.transactionFilter = bO;
  $e.transactionExtender = xO;
  Nm.reconfigure = Ee.define();
  function Oi(t, e, n = {}) {
    let r = {};
    for (let i of t)
      for (let o of Object.keys(i)) {
        let s = i[o], a = r[o];
        if (a === void 0)
          r[o] = s;
        else if (!(a === s || s === void 0))
          if (Object.hasOwnProperty.call(n, o))
            r[o] = n[o](a, s);
          else
            throw new Error("Config merge conflict for field " + o);
      }
    for (let i in e)
      r[i] === void 0 && (r[i] = e[i]);
    return r;
  }
  class Uo {
    eq(e) {
      return this == e;
    }
    range(e, n = e) {
      return _u.create(e, n, this);
    }
  }
  Uo.prototype.startSide = Uo.prototype.endSide = 0;
  Uo.prototype.point = false;
  Uo.prototype.mapMode = Zt.TrackDel;
  function Px(t, e) {
    return t == e || t.constructor == e.constructor && t.eq(e);
  }
  class _u {
    constructor(e, n, r) {
      this.from = e, this.to = n, this.value = r;
    }
    static create(e, n, r) {
      return new _u(e, n, r);
    }
  }
  function Gy(t, e) {
    return t.from - e.from || t.value.startSide - e.value.startSide;
  }
  class Ox {
    constructor(e, n, r, i) {
      this.from = e, this.to = n, this.value = r, this.maxPoint = i;
    }
    get length() {
      return this.to[this.to.length - 1];
    }
    findIndex(e, n, r, i = 0) {
      let o = r ? this.to : this.from;
      for (let s = i, a = o.length; ; ) {
        if (s == a)
          return s;
        let l = s + a >> 1, c = o[l] - e || (r ? this.value[l].endSide : this.value[l].startSide) - n;
        if (l == s)
          return c >= 0 ? s : a;
        c >= 0 ? a = l : s = l + 1;
      }
    }
    between(e, n, r, i) {
      for (let o = this.findIndex(n, -1e9, true), s = this.findIndex(r, 1e9, false, o); o < s; o++)
        if (i(this.from[o] + e, this.to[o] + e, this.value[o]) === false)
          return false;
    }
    map(e, n) {
      let r = [], i = [], o = [], s = -1, a = -1;
      for (let l = 0; l < this.value.length; l++) {
        let c = this.value[l], u = this.from[l] + e, h = this.to[l] + e, p, v;
        if (u == h) {
          let y = n.mapPos(u, c.startSide, c.mapMode);
          if (y == null || (p = v = y, c.startSide != c.endSide && (v = n.mapPos(u, c.endSide), v < p)))
            continue;
        } else if (p = n.mapPos(u, c.startSide), v = n.mapPos(h, c.endSide), p > v || p == v && c.startSide > 0 && c.endSide <= 0)
          continue;
        (v - p || c.endSide - c.startSide) < 0 || (s < 0 && (s = p), c.point && (a = Math.max(a, v - p)), r.push(c), i.push(p - s), o.push(v - s));
      }
      return {
        mapped: r.length ? new Ox(i, o, r, a) : null,
        pos: s
      };
    }
  }
  class _e {
    constructor(e, n, r, i) {
      this.chunkPos = e, this.chunk = n, this.nextLayer = r, this.maxPoint = i;
    }
    static create(e, n, r, i) {
      return new _e(e, n, r, i);
    }
    get length() {
      let e = this.chunk.length - 1;
      return e < 0 ? 0 : Math.max(this.chunkEnd(e), this.nextLayer.length);
    }
    get size() {
      if (this.isEmpty)
        return 0;
      let e = this.nextLayer.size;
      for (let n of this.chunk)
        e += n.value.length;
      return e;
    }
    chunkEnd(e) {
      return this.chunkPos[e] + this.chunk[e].length;
    }
    update(e) {
      let { add: n = [], sort: r = false, filterFrom: i = 0, filterTo: o = this.length } = e, s = e.filter;
      if (n.length == 0 && !s)
        return this;
      if (r && (n = n.slice().sort(Gy)), this.isEmpty)
        return n.length ? _e.of(n) : this;
      let a = new CO(this, null, -1).goto(0), l = 0, c = [], u = new Ai();
      for (; a.value || l < n.length; )
        if (l < n.length && (a.from - n[l].from || a.startSide - n[l].value.startSide) >= 0) {
          let h = n[l++];
          u.addInner(h.from, h.to, h.value) || c.push(h);
        } else
          a.rangeIndex == 1 && a.chunkIndex < this.chunk.length && (l == n.length || this.chunkEnd(a.chunkIndex) < n[l].from) && (!s || i > this.chunkEnd(a.chunkIndex) || o < this.chunkPos[a.chunkIndex]) && u.addChunk(this.chunkPos[a.chunkIndex], this.chunk[a.chunkIndex]) ? a.nextChunk() : ((!s || i > a.to || o < a.from || s(a.from, a.to, a.value)) && (u.addInner(a.from, a.to, a.value) || c.push(_u.create(a.from, a.to, a.value))), a.next());
      return u.finishInner(this.nextLayer.isEmpty && !c.length ? _e.empty : this.nextLayer.update({
        add: c,
        filter: s,
        filterFrom: i,
        filterTo: o
      }));
    }
    map(e) {
      if (e.empty || this.isEmpty)
        return this;
      let n = [], r = [], i = -1;
      for (let s = 0; s < this.chunk.length; s++) {
        let a = this.chunkPos[s], l = this.chunk[s], c = e.touchesRange(a, a + l.length);
        if (c === false)
          i = Math.max(i, l.maxPoint), n.push(l), r.push(e.mapPos(a));
        else if (c === true) {
          let { mapped: u, pos: h } = l.map(a, e);
          u && (i = Math.max(i, u.maxPoint), n.push(u), r.push(h));
        }
      }
      let o = this.nextLayer.map(e);
      return n.length == 0 ? o : new _e(r, n, o || _e.empty, i);
    }
    between(e, n, r) {
      if (!this.isEmpty) {
        for (let i = 0; i < this.chunk.length; i++) {
          let o = this.chunkPos[i], s = this.chunk[i];
          if (n >= o && e <= o + s.length && s.between(o, e - o, n - o, r) === false)
            return;
        }
        this.nextLayer.between(e, n, r);
      }
    }
    iter(e = 0) {
      return Du.from([
        this
      ]).goto(e);
    }
    get isEmpty() {
      return this.nextLayer == this;
    }
    static iter(e, n = 0) {
      return Du.from(e).goto(n);
    }
    static compare(e, n, r, i, o = -1) {
      let s = e.filter((h) => h.maxPoint > 0 || !h.isEmpty && h.maxPoint >= o), a = n.filter((h) => h.maxPoint > 0 || !h.isEmpty && h.maxPoint >= o), l = wC(s, a, r), c = new oc(s, l, o), u = new oc(a, l, o);
      r.iterGaps((h, p, v) => kC(c, h, u, p, v, i)), r.empty && r.length == 0 && kC(c, 0, u, 0, 0, i);
    }
    static eq(e, n, r = 0, i) {
      i == null && (i = 1e9 - 1);
      let o = e.filter((u) => !u.isEmpty && n.indexOf(u) < 0), s = n.filter((u) => !u.isEmpty && e.indexOf(u) < 0);
      if (o.length != s.length)
        return false;
      if (!o.length)
        return true;
      let a = wC(o, s), l = new oc(o, a, 0).goto(r), c = new oc(s, a, 0).goto(r);
      for (; ; ) {
        if (l.to != c.to || !Yy(l.active, c.active) || l.point && (!c.point || !Px(l.point, c.point)))
          return false;
        if (l.to > i)
          return true;
        l.next(), c.next();
      }
    }
    static spans(e, n, r, i, o = -1) {
      let s = new oc(e, null, o).goto(n), a = n, l = s.openStart;
      for (; ; ) {
        let c = Math.min(s.to, r);
        if (s.point) {
          let u = s.activeForPoint(s.to), h = s.pointFrom < n ? u.length + 1 : s.point.startSide < 0 ? u.length : Math.min(u.length, l);
          i.point(a, c, s.point, u, h, s.pointRank), l = Math.min(s.openEnd(c), u.length);
        } else
          c > a && (i.span(a, c, s.active, l), l = s.openEnd(c));
        if (s.to > r)
          return l + (s.point && s.to > r ? 1 : 0);
        a = s.to, s.next();
      }
    }
    static of(e, n = false) {
      let r = new Ai();
      for (let i of e instanceof _u ? [
        e
      ] : n ? Kj(e) : e)
        r.add(i.from, i.to, i.value);
      return r.finish();
    }
    static join(e) {
      if (!e.length)
        return _e.empty;
      let n = e[e.length - 1];
      for (let r = e.length - 2; r >= 0; r--)
        for (let i = e[r]; i != _e.empty; i = i.nextLayer)
          n = new _e(i.chunkPos, i.chunk, n, Math.max(i.maxPoint, n.maxPoint));
      return n;
    }
  }
  _e.empty = new _e([], [], null, -1);
  function Kj(t) {
    if (t.length > 1)
      for (let e = t[0], n = 1; n < t.length; n++) {
        let r = t[n];
        if (Gy(e, r) > 0)
          return t.slice().sort(Gy);
        e = r;
      }
    return t;
  }
  _e.empty.nextLayer = _e.empty;
  class Ai {
    finishChunk(e) {
      this.chunks.push(new Ox(this.from, this.to, this.value, this.maxPoint)), this.chunkPos.push(this.chunkStart), this.chunkStart = -1, this.setMaxPoint = Math.max(this.setMaxPoint, this.maxPoint), this.maxPoint = -1, e && (this.from = [], this.to = [], this.value = []);
    }
    constructor() {
      this.chunks = [], this.chunkPos = [], this.chunkStart = -1, this.last = null, this.lastFrom = -1e9, this.lastTo = -1e9, this.from = [], this.to = [], this.value = [], this.maxPoint = -1, this.setMaxPoint = -1, this.nextLayer = null;
    }
    add(e, n, r) {
      this.addInner(e, n, r) || (this.nextLayer || (this.nextLayer = new Ai())).add(e, n, r);
    }
    addInner(e, n, r) {
      let i = e - this.lastTo || r.startSide - this.last.endSide;
      if (i <= 0 && (e - this.lastFrom || r.startSide - this.last.startSide) < 0)
        throw new Error("Ranges must be added sorted by `from` position and `startSide`");
      return i < 0 ? false : (this.from.length == 250 && this.finishChunk(true), this.chunkStart < 0 && (this.chunkStart = e), this.from.push(e - this.chunkStart), this.to.push(n - this.chunkStart), this.last = r, this.lastFrom = e, this.lastTo = n, this.value.push(r), r.point && (this.maxPoint = Math.max(this.maxPoint, n - e)), true);
    }
    addChunk(e, n) {
      if ((e - this.lastTo || n.value[0].startSide - this.last.endSide) < 0)
        return false;
      this.from.length && this.finishChunk(true), this.setMaxPoint = Math.max(this.setMaxPoint, n.maxPoint), this.chunks.push(n), this.chunkPos.push(e);
      let r = n.value.length - 1;
      return this.last = n.value[r], this.lastFrom = n.from[r] + e, this.lastTo = n.to[r] + e, true;
    }
    finish() {
      return this.finishInner(_e.empty);
    }
    finishInner(e) {
      if (this.from.length && this.finishChunk(false), this.chunks.length == 0)
        return e;
      let n = _e.create(this.chunkPos, this.chunks, this.nextLayer ? this.nextLayer.finishInner(e) : e, this.setMaxPoint);
      return this.from = null, n;
    }
  }
  function wC(t, e, n) {
    let r = /* @__PURE__ */ new Map();
    for (let o of t)
      for (let s = 0; s < o.chunk.length; s++)
        o.chunk[s].maxPoint <= 0 && r.set(o.chunk[s], o.chunkPos[s]);
    let i = /* @__PURE__ */ new Set();
    for (let o of e)
      for (let s = 0; s < o.chunk.length; s++) {
        let a = r.get(o.chunk[s]);
        a != null && (n ? n.mapPos(a) : a) == o.chunkPos[s] && !(n == null ? void 0 : n.touchesRange(a, a + o.chunk[s].length)) && i.add(o.chunk[s]);
      }
    return i;
  }
  class CO {
    constructor(e, n, r, i = 0) {
      this.layer = e, this.skip = n, this.minPoint = r, this.rank = i;
    }
    get startSide() {
      return this.value ? this.value.startSide : 0;
    }
    get endSide() {
      return this.value ? this.value.endSide : 0;
    }
    goto(e, n = -1e9) {
      return this.chunkIndex = this.rangeIndex = 0, this.gotoInner(e, n, false), this;
    }
    gotoInner(e, n, r) {
      for (; this.chunkIndex < this.layer.chunk.length; ) {
        let i = this.layer.chunk[this.chunkIndex];
        if (!(this.skip && this.skip.has(i) || this.layer.chunkEnd(this.chunkIndex) < e || i.maxPoint < this.minPoint))
          break;
        this.chunkIndex++, r = false;
      }
      if (this.chunkIndex < this.layer.chunk.length) {
        let i = this.layer.chunk[this.chunkIndex].findIndex(e - this.layer.chunkPos[this.chunkIndex], n, true);
        (!r || this.rangeIndex < i) && this.setRangeIndex(i);
      }
      this.next();
    }
    forward(e, n) {
      (this.to - e || this.endSide - n) < 0 && this.gotoInner(e, n, true);
    }
    next() {
      for (; ; )
        if (this.chunkIndex == this.layer.chunk.length) {
          this.from = this.to = 1e9, this.value = null;
          break;
        } else {
          let e = this.layer.chunkPos[this.chunkIndex], n = this.layer.chunk[this.chunkIndex], r = e + n.from[this.rangeIndex];
          if (this.from = r, this.to = e + n.to[this.rangeIndex], this.value = n.value[this.rangeIndex], this.setRangeIndex(this.rangeIndex + 1), this.minPoint < 0 || this.value.point && this.to - this.from >= this.minPoint)
            break;
        }
    }
    setRangeIndex(e) {
      if (e == this.layer.chunk[this.chunkIndex].value.length) {
        if (this.chunkIndex++, this.skip)
          for (; this.chunkIndex < this.layer.chunk.length && this.skip.has(this.layer.chunk[this.chunkIndex]); )
            this.chunkIndex++;
        this.rangeIndex = 0;
      } else
        this.rangeIndex = e;
    }
    nextChunk() {
      this.chunkIndex++, this.rangeIndex = 0, this.next();
    }
    compare(e) {
      return this.from - e.from || this.startSide - e.startSide || this.rank - e.rank || this.to - e.to || this.endSide - e.endSide;
    }
  }
  class Du {
    constructor(e) {
      this.heap = e;
    }
    static from(e, n = null, r = -1) {
      let i = [];
      for (let o = 0; o < e.length; o++)
        for (let s = e[o]; !s.isEmpty; s = s.nextLayer)
          s.maxPoint >= r && i.push(new CO(s, n, r, o));
      return i.length == 1 ? i[0] : new Du(i);
    }
    get startSide() {
      return this.value ? this.value.startSide : 0;
    }
    goto(e, n = -1e9) {
      for (let r of this.heap)
        r.goto(e, n);
      for (let r = this.heap.length >> 1; r >= 0; r--)
        R0(this.heap, r);
      return this.next(), this;
    }
    forward(e, n) {
      for (let r of this.heap)
        r.forward(e, n);
      for (let r = this.heap.length >> 1; r >= 0; r--)
        R0(this.heap, r);
      (this.to - e || this.value.endSide - n) < 0 && this.next();
    }
    next() {
      if (this.heap.length == 0)
        this.from = this.to = 1e9, this.value = null, this.rank = -1;
      else {
        let e = this.heap[0];
        this.from = e.from, this.to = e.to, this.value = e.value, this.rank = e.rank, e.value && e.next(), R0(this.heap, 0);
      }
    }
  }
  function R0(t, e) {
    for (let n = t[e]; ; ) {
      let r = (e << 1) + 1;
      if (r >= t.length)
        break;
      let i = t[r];
      if (r + 1 < t.length && i.compare(t[r + 1]) >= 0 && (i = t[r + 1], r++), n.compare(i) < 0)
        break;
      t[r] = n, t[e] = i, e = r;
    }
  }
  class oc {
    constructor(e, n, r) {
      this.minPoint = r, this.active = [], this.activeTo = [], this.activeRank = [], this.minActive = -1, this.point = null, this.pointFrom = 0, this.pointRank = 0, this.to = -1e9, this.endSide = 0, this.openStart = -1, this.cursor = Du.from(e, n, r);
    }
    goto(e, n = -1e9) {
      return this.cursor.goto(e, n), this.active.length = this.activeTo.length = this.activeRank.length = 0, this.minActive = -1, this.to = e, this.endSide = n, this.openStart = -1, this.next(), this;
    }
    forward(e, n) {
      for (; this.minActive > -1 && (this.activeTo[this.minActive] - e || this.active[this.minActive].endSide - n) < 0; )
        this.removeActive(this.minActive);
      this.cursor.forward(e, n);
    }
    removeActive(e) {
      Sh(this.active, e), Sh(this.activeTo, e), Sh(this.activeRank, e), this.minActive = CC(this.active, this.activeTo);
    }
    addActive(e) {
      let n = 0, { value: r, to: i, rank: o } = this.cursor;
      for (; n < this.activeRank.length && (o - this.activeRank[n] || i - this.activeTo[n]) > 0; )
        n++;
      wh(this.active, n, r), wh(this.activeTo, n, i), wh(this.activeRank, n, o), e && wh(e, n, this.cursor.from), this.minActive = CC(this.active, this.activeTo);
    }
    next() {
      let e = this.to, n = this.point;
      this.point = null;
      let r = this.openStart < 0 ? [] : null;
      for (; ; ) {
        let i = this.minActive;
        if (i > -1 && (this.activeTo[i] - this.cursor.from || this.active[i].endSide - this.cursor.startSide) < 0) {
          if (this.activeTo[i] > e) {
            this.to = this.activeTo[i], this.endSide = this.active[i].endSide;
            break;
          }
          this.removeActive(i), r && Sh(r, i);
        } else if (this.cursor.value)
          if (this.cursor.from > e) {
            this.to = this.cursor.from, this.endSide = this.cursor.startSide;
            break;
          } else {
            let o = this.cursor.value;
            if (!o.point)
              this.addActive(r), this.cursor.next();
            else if (n && this.cursor.to == this.to && this.cursor.from < this.cursor.to)
              this.cursor.next();
            else {
              this.point = o, this.pointFrom = this.cursor.from, this.pointRank = this.cursor.rank, this.to = this.cursor.to, this.endSide = o.endSide, this.cursor.next(), this.forward(this.to, this.endSide);
              break;
            }
          }
        else {
          this.to = this.endSide = 1e9;
          break;
        }
      }
      if (r) {
        this.openStart = 0;
        for (let i = r.length - 1; i >= 0 && r[i] < e; i--)
          this.openStart++;
      }
    }
    activeForPoint(e) {
      if (!this.active.length)
        return this.active;
      let n = [];
      for (let r = this.active.length - 1; r >= 0 && !(this.activeRank[r] < this.pointRank); r--)
        (this.activeTo[r] > e || this.activeTo[r] == e && this.active[r].endSide >= this.point.endSide) && n.push(this.active[r]);
      return n.reverse();
    }
    openEnd(e) {
      let n = 0;
      for (let r = this.activeTo.length - 1; r >= 0 && this.activeTo[r] > e; r--)
        n++;
      return n;
    }
  }
  function kC(t, e, n, r, i, o) {
    t.goto(e), n.goto(r);
    let s = r + i, a = r, l = r - e, c = !!o.boundChange;
    for (let u = false; ; ) {
      let h = t.to + l - n.to, p = h || t.endSide - n.endSide, v = p < 0 ? t.to + l : n.to, y = Math.min(v, s);
      if (t.point || n.point ? (t.point && n.point && Px(t.point, n.point) && Yy(t.activeForPoint(t.to), n.activeForPoint(n.to)) || o.comparePoint(a, y, t.point, n.point), u = false) : (u && o.boundChange(a), y > a && !Yy(t.active, n.active) && o.compareRange(a, y, t.active, n.active), c && y < s && (h || t.openEnd(v) != n.openEnd(v)) && (u = true)), v > s)
        break;
      a = v, p <= 0 && t.next(), p >= 0 && n.next();
    }
  }
  function Yy(t, e) {
    if (t.length != e.length)
      return false;
    for (let n = 0; n < t.length; n++)
      if (t[n] != e[n] && !Px(t[n], e[n]))
        return false;
    return true;
  }
  function Sh(t, e) {
    for (let n = e, r = t.length - 1; n < r; n++)
      t[n] = t[n + 1];
    t.pop();
  }
  function wh(t, e, n) {
    for (let r = t.length - 1; r >= e; r--)
      t[r + 1] = t[r];
    t[e] = n;
  }
  function CC(t, e) {
    let n = -1, r = 1e9;
    for (let i = 0; i < e.length; i++)
      (e[i] - r || t[i].endSide - t[n].endSide) < 0 && (n = i, r = e[i]);
    return n;
  }
  function El(t, e, n = t.length) {
    let r = 0;
    for (let i = 0; i < n && i < t.length; )
      t.charCodeAt(i) == 9 ? (r += e - r % e, i++) : (r++, i = Ht(t, i));
    return r;
  }
  function Xy(t, e, n, r) {
    for (let i = 0, o = 0; ; ) {
      if (o >= e)
        return i;
      if (i == t.length)
        break;
      o += t.charCodeAt(i) == 9 ? n - o % n : 1, i = Ht(t, i);
    }
    return r === true ? -1 : t.length;
  }
  const Qy = "\u037C", TC = typeof Symbol > "u" ? "__" + Qy : Symbol.for(Qy), Jy = typeof Symbol > "u" ? "__styleSet" + Math.floor(Math.random() * 1e8) : Symbol("styleSet"), MC = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : {};
  class Ko {
    constructor(e, n) {
      this.rules = [];
      let { finish: r } = n || {};
      function i(s) {
        return /^@/.test(s) ? [
          s
        ] : s.split(/,\s*/);
      }
      function o(s, a, l, c) {
        let u = [], h = /^@(\w+)\b/.exec(s[0]), p = h && h[1] == "keyframes";
        if (h && a == null)
          return l.push(s[0] + ";");
        for (let v in a) {
          let y = a[v];
          if (/&/.test(v))
            o(v.split(/,\s*/).map((S) => s.map((T) => S.replace(/&/, T))).reduce((S, T) => S.concat(T)), y, l);
          else if (y && typeof y == "object") {
            if (!h)
              throw new RangeError("The value of a property (" + v + ") should be a primitive value.");
            o(i(v), y, u, p);
          } else
            y != null && u.push(v.replace(/_.*/, "").replace(/[A-Z]/g, (S) => "-" + S.toLowerCase()) + ": " + y + ";");
        }
        (u.length || p) && l.push((r && !h && !c ? s.map(r) : s).join(", ") + " {" + u.join(" ") + "}");
      }
      for (let s in e)
        o(i(s), e[s], this.rules);
    }
    getRules() {
      return this.rules.join(`
`);
    }
    static newName() {
      let e = MC[TC] || 1;
      return MC[TC] = e + 1, Qy + e.toString(36);
    }
    static mount(e, n, r) {
      let i = e[Jy], o = r && r.nonce;
      i ? o && i.setNonce(o) : i = new qj(e, o), i.mount(Array.isArray(n) ? n : [
        n
      ], e);
    }
  }
  let AC = /* @__PURE__ */ new Map();
  class qj {
    constructor(e, n) {
      let r = e.ownerDocument || e, i = r.defaultView;
      if (!e.head && e.adoptedStyleSheets && i.CSSStyleSheet) {
        let o = AC.get(r);
        if (o)
          return e[Jy] = o;
        this.sheet = new i.CSSStyleSheet(), AC.set(r, this);
      } else
        this.styleTag = r.createElement("style"), n && this.styleTag.setAttribute("nonce", n);
      this.modules = [], e[Jy] = this;
    }
    mount(e, n) {
      let r = this.sheet, i = 0, o = 0;
      for (let s = 0; s < e.length; s++) {
        let a = e[s], l = this.modules.indexOf(a);
        if (l < o && l > -1 && (this.modules.splice(l, 1), o--, l = -1), l == -1) {
          if (this.modules.splice(o++, 0, a), r)
            for (let c = 0; c < a.rules.length; c++)
              r.insertRule(a.rules[c], i++);
        } else {
          for (; o < l; )
            i += this.modules[o++].rules.length;
          i += a.rules.length, o++;
        }
      }
      if (r)
        n.adoptedStyleSheets.indexOf(this.sheet) < 0 && (n.adoptedStyleSheets = [
          this.sheet,
          ...n.adoptedStyleSheets
        ]);
      else {
        let s = "";
        for (let l = 0; l < this.modules.length; l++)
          s += this.modules[l].getRules() + `
`;
        this.styleTag.textContent = s;
        let a = n.head || n;
        this.styleTag.parentNode != a && a.insertBefore(this.styleTag, a.firstChild);
      }
    }
    setNonce(e) {
      this.styleTag && this.styleTag.getAttribute("nonce") != e && this.styleTag.setAttribute("nonce", e);
    }
  }
  var qo = {
    8: "Backspace",
    9: "Tab",
    10: "Enter",
    12: "NumLock",
    13: "Enter",
    16: "Shift",
    17: "Control",
    18: "Alt",
    20: "CapsLock",
    27: "Escape",
    32: " ",
    33: "PageUp",
    34: "PageDown",
    35: "End",
    36: "Home",
    37: "ArrowLeft",
    38: "ArrowUp",
    39: "ArrowRight",
    40: "ArrowDown",
    44: "PrintScreen",
    45: "Insert",
    46: "Delete",
    59: ";",
    61: "=",
    91: "Meta",
    92: "Meta",
    106: "*",
    107: "+",
    108: ",",
    109: "-",
    110: ".",
    111: "/",
    144: "NumLock",
    145: "ScrollLock",
    160: "Shift",
    161: "Shift",
    162: "Control",
    163: "Control",
    164: "Alt",
    165: "Alt",
    173: "-",
    186: ";",
    187: "=",
    188: ",",
    189: "-",
    190: ".",
    191: "/",
    192: "`",
    219: "[",
    220: "\\",
    221: "]",
    222: "'"
  }, Iu = {
    48: ")",
    49: "!",
    50: "@",
    51: "#",
    52: "$",
    53: "%",
    54: "^",
    55: "&",
    56: "*",
    57: "(",
    59: ":",
    61: "+",
    173: "_",
    186: ":",
    187: "+",
    188: "<",
    189: "_",
    190: ">",
    191: "?",
    192: "~",
    219: "{",
    220: "|",
    221: "}",
    222: '"'
  }, Gj = typeof navigator < "u" && /Mac/.test(navigator.platform), Yj = typeof navigator < "u" && /MSIE \d|Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(navigator.userAgent);
  for (var Jt = 0; Jt < 10; Jt++)
    qo[48 + Jt] = qo[96 + Jt] = String(Jt);
  for (var Jt = 1; Jt <= 24; Jt++)
    qo[Jt + 111] = "F" + Jt;
  for (var Jt = 65; Jt <= 90; Jt++)
    qo[Jt] = String.fromCharCode(Jt + 32), Iu[Jt] = String.fromCharCode(Jt);
  for (var _0 in qo)
    Iu.hasOwnProperty(_0) || (Iu[_0] = qo[_0]);
  function Xj(t) {
    var e = Gj && t.metaKey && t.shiftKey && !t.ctrlKey && !t.altKey || Yj && t.shiftKey && t.key && t.key.length == 1 || t.key == "Unidentified", n = !e && t.key || (t.shiftKey ? Iu : qo)[t.keyCode] || t.key || "Unidentified";
    return n == "Esc" && (n = "Escape"), n == "Del" && (n = "Delete"), n == "Left" && (n = "ArrowLeft"), n == "Up" && (n = "ArrowUp"), n == "Right" && (n = "ArrowRight"), n == "Down" && (n = "ArrowDown"), n;
  }
  function Qe() {
    var t = arguments[0];
    typeof t == "string" && (t = document.createElement(t));
    var e = 1, n = arguments[1];
    if (n && typeof n == "object" && n.nodeType == null && !Array.isArray(n)) {
      for (var r in n)
        if (Object.prototype.hasOwnProperty.call(n, r)) {
          var i = n[r];
          typeof i == "string" ? t.setAttribute(r, i) : i != null && (t[r] = i);
        }
      e++;
    }
    for (; e < arguments.length; e++)
      TO(t, arguments[e]);
    return t;
  }
  function TO(t, e) {
    if (typeof e == "string")
      t.appendChild(document.createTextNode(e));
    else if (e != null)
      if (e.nodeType != null)
        t.appendChild(e);
      else if (Array.isArray(e))
        for (var n = 0; n < e.length; n++)
          TO(t, e[n]);
      else
        throw new RangeError("Unsupported child node: " + e);
  }
  let bn = typeof navigator < "u" ? navigator : {
    userAgent: "",
    vendor: "",
    platform: ""
  }, Zy = typeof document < "u" ? document : {
    documentElement: {
      style: {}
    }
  };
  const e1 = /Edge\/(\d+)/.exec(bn.userAgent), MO = /MSIE \d/.test(bn.userAgent), t1 = /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(bn.userAgent), $m = !!(MO || t1 || e1), EC = !$m && /gecko\/(\d+)/i.test(bn.userAgent), D0 = !$m && /Chrome\/(\d+)/.exec(bn.userAgent), PC = "webkitFontSmoothing" in Zy.documentElement.style, n1 = !$m && /Apple Computer/.test(bn.vendor), OC = n1 && (/Mobile\/\w+/.test(bn.userAgent) || bn.maxTouchPoints > 2);
  var de = {
    mac: OC || /Mac/.test(bn.platform),
    windows: /Win/.test(bn.platform),
    linux: /Linux|X11/.test(bn.platform),
    ie: $m,
    ie_version: MO ? Zy.documentMode || 6 : t1 ? +t1[1] : e1 ? +e1[1] : 0,
    gecko: EC,
    gecko_version: EC ? +(/Firefox\/(\d+)/.exec(bn.userAgent) || [
      0,
      0
    ])[1] : 0,
    chrome: !!D0,
    chrome_version: D0 ? +D0[1] : 0,
    ios: OC,
    android: /Android\b/.test(bn.userAgent),
    webkit: PC,
    webkit_version: PC ? +(/\bAppleWebKit\/(\d+)/.exec(bn.userAgent) || [
      0,
      0
    ])[1] : 0,
    safari: n1,
    safari_version: n1 ? +(/\bVersion\/(\d+(\.\d+)?)/.exec(bn.userAgent) || [
      0,
      0
    ])[1] : 0,
    tabSize: Zy.documentElement.style.tabSize != null ? "tab-size" : "-moz-tab-size"
  };
  function Lx(t, e) {
    for (let n in t)
      n == "class" && e.class ? e.class += " " + t.class : n == "style" && e.style ? e.style += ";" + t.style : e[n] = t[n];
    return e;
  }
  const yp = /* @__PURE__ */ Object.create(null);
  function Rx(t, e, n) {
    if (t == e)
      return true;
    t || (t = yp), e || (e = yp);
    let r = Object.keys(t), i = Object.keys(e);
    if (r.length - (n && r.indexOf(n) > -1 ? 1 : 0) != i.length - (n && i.indexOf(n) > -1 ? 1 : 0))
      return false;
    for (let o of r)
      if (o != n && (i.indexOf(o) == -1 || t[o] !== e[o]))
        return false;
    return true;
  }
  function Qj(t, e) {
    for (let n = t.attributes.length - 1; n >= 0; n--) {
      let r = t.attributes[n].name;
      e[r] == null && t.removeAttribute(r);
    }
    for (let n in e) {
      let r = e[n];
      n == "style" ? t.style.cssText = r : t.getAttribute(n) != r && t.setAttribute(n, r);
    }
  }
  function LC(t, e, n) {
    let r = false;
    if (e)
      for (let i in e)
        n && i in n || (r = true, i == "style" ? t.style.cssText = "" : t.removeAttribute(i));
    if (n)
      for (let i in n)
        e && e[i] == n[i] || (r = true, i == "style" ? t.style.cssText = n[i] : t.setAttribute(i, n[i]));
    return r;
  }
  function Jj(t) {
    let e = /* @__PURE__ */ Object.create(null);
    for (let n = 0; n < t.attributes.length; n++) {
      let r = t.attributes[n];
      e[r.name] = r.value;
    }
    return e;
  }
  class Li {
    eq(e) {
      return false;
    }
    updateDOM(e, n) {
      return false;
    }
    compare(e) {
      return this == e || this.constructor == e.constructor && this.eq(e);
    }
    get estimatedHeight() {
      return -1;
    }
    get lineBreaks() {
      return 0;
    }
    ignoreEvent(e) {
      return true;
    }
    coordsAt(e, n, r) {
      return null;
    }
    get isHidden() {
      return false;
    }
    get editable() {
      return false;
    }
    destroy(e) {
    }
  }
  var nn = function(t) {
    return t[t.Text = 0] = "Text", t[t.WidgetBefore = 1] = "WidgetBefore", t[t.WidgetAfter = 2] = "WidgetAfter", t[t.WidgetRange = 3] = "WidgetRange", t;
  }(nn || (nn = {}));
  class be extends Uo {
    constructor(e, n, r, i) {
      super(), this.startSide = e, this.endSide = n, this.widget = r, this.spec = i;
    }
    get heightRelevant() {
      return false;
    }
    static mark(e) {
      return new af(e);
    }
    static widget(e) {
      let n = Math.max(-1e4, Math.min(1e4, e.side || 0)), r = !!e.block;
      return n += r && !e.inlineOrder ? n > 0 ? 3e8 : -4e8 : n > 0 ? 1e8 : -1e8, new Us(e, n, n, r, e.widget || null, false);
    }
    static replace(e) {
      let n = !!e.block, r, i;
      if (e.isBlockGap)
        r = -5e8, i = 4e8;
      else {
        let { start: o, end: s } = AO(e, n);
        r = (o ? n ? -3e8 : -1 : 5e8) - 1, i = (s ? n ? 2e8 : 1 : -6e8) + 1;
      }
      return new Us(e, r, i, n, e.widget || null, true);
    }
    static line(e) {
      return new lf(e);
    }
    static set(e, n = false) {
      return _e.of(e, n);
    }
    hasHeight() {
      return this.widget ? this.widget.estimatedHeight > -1 : false;
    }
  }
  be.none = _e.empty;
  class af extends be {
    constructor(e) {
      let { start: n, end: r } = AO(e);
      super(n ? -1 : 5e8, r ? 1 : -6e8, null, e), this.tagName = e.tagName || "span", this.attrs = e.class && e.attributes ? Lx(e.attributes, {
        class: e.class
      }) : e.class ? {
        class: e.class
      } : e.attributes || yp;
    }
    eq(e) {
      return this == e || e instanceof af && this.tagName == e.tagName && Rx(this.attrs, e.attrs);
    }
    range(e, n = e) {
      if (e >= n)
        throw new RangeError("Mark decorations may not be empty");
      return super.range(e, n);
    }
  }
  af.prototype.point = false;
  class lf extends be {
    constructor(e) {
      super(-2e8, -2e8, null, e);
    }
    eq(e) {
      return e instanceof lf && this.spec.class == e.spec.class && Rx(this.spec.attributes, e.spec.attributes);
    }
    range(e, n = e) {
      if (n != e)
        throw new RangeError("Line decoration ranges must be zero-length");
      return super.range(e, n);
    }
  }
  lf.prototype.mapMode = Zt.TrackBefore;
  lf.prototype.point = true;
  class Us extends be {
    constructor(e, n, r, i, o, s) {
      super(n, r, o, e), this.block = i, this.isReplace = s, this.mapMode = i ? n <= 0 ? Zt.TrackBefore : Zt.TrackAfter : Zt.TrackDel;
    }
    get type() {
      return this.startSide != this.endSide ? nn.WidgetRange : this.startSide <= 0 ? nn.WidgetBefore : nn.WidgetAfter;
    }
    get heightRelevant() {
      return this.block || !!this.widget && (this.widget.estimatedHeight >= 5 || this.widget.lineBreaks > 0);
    }
    eq(e) {
      return e instanceof Us && Zj(this.widget, e.widget) && this.block == e.block && this.startSide == e.startSide && this.endSide == e.endSide;
    }
    range(e, n = e) {
      if (this.isReplace && (e > n || e == n && this.startSide > 0 && this.endSide <= 0))
        throw new RangeError("Invalid range for replacement decoration");
      if (!this.isReplace && n != e)
        throw new RangeError("Widget decorations can only have zero-length ranges");
      return super.range(e, n);
    }
  }
  Us.prototype.point = true;
  function AO(t, e = false) {
    let { inclusiveStart: n, inclusiveEnd: r } = t;
    return n == null && (n = t.inclusive), r == null && (r = t.inclusive), {
      start: n ?? e,
      end: r ?? e
    };
  }
  function Zj(t, e) {
    return t == e || !!(t && e && t.compare(e));
  }
  function Xa(t, e, n, r = 0) {
    let i = n.length - 1;
    i >= 0 && n[i] + r >= t ? n[i] = Math.max(n[i], e) : n.push(t, e);
  }
  class Bu extends Uo {
    constructor(e, n) {
      super(), this.tagName = e, this.attributes = n;
    }
    eq(e) {
      return e == this || e instanceof Bu && this.tagName == e.tagName && Rx(this.attributes, e.attributes);
    }
    static create(e) {
      return new Bu(e.tagName, e.attributes || yp);
    }
    static set(e, n = false) {
      return _e.of(e, n);
    }
  }
  Bu.prototype.startSide = Bu.prototype.endSide = -1;
  function Nu(t) {
    let e;
    return t.nodeType == 11 ? e = t.getSelection ? t : t.ownerDocument : e = t, e.getSelection();
  }
  function r1(t, e) {
    return e ? t == e || t.contains(e.nodeType != 1 ? e.parentNode : e) : false;
  }
  function Yc(t, e) {
    if (!e.anchorNode)
      return false;
    try {
      return r1(t, e.anchorNode);
    } catch {
      return false;
    }
  }
  function Xc(t) {
    return t.nodeType == 3 ? zu(t, 0, t.nodeValue.length).getClientRects() : t.nodeType == 1 ? t.getClientRects() : [];
  }
  function Qc(t, e, n, r) {
    return n ? RC(t, e, n, r, -1) || RC(t, e, n, r, 1) : false;
  }
  function Go(t) {
    for (var e = 0; ; e++)
      if (t = t.previousSibling, !t)
        return e;
  }
  function bp(t) {
    return t.nodeType == 1 && /^(DIV|P|LI|UL|OL|BLOCKQUOTE|DD|DT|H\d|SECTION|PRE)$/.test(t.nodeName);
  }
  function RC(t, e, n, r, i) {
    for (; ; ) {
      if (t == n && e == r)
        return true;
      if (e == (i < 0 ? 0 : ro(t))) {
        if (t.nodeName == "DIV")
          return false;
        let o = t.parentNode;
        if (!o || o.nodeType != 1)
          return false;
        e = Go(t) + (i < 0 ? 0 : 1), t = o;
      } else if (t.nodeType == 1) {
        if (t = t.childNodes[e + (i < 0 ? -1 : 0)], t.nodeType == 1 && t.contentEditable == "false")
          return false;
        e = i < 0 ? ro(t) : 0;
      } else
        return false;
    }
  }
  function ro(t) {
    return t.nodeType == 3 ? t.nodeValue.length : t.childNodes.length;
  }
  function $u(t, e) {
    let n = e ? t.left : t.right;
    return {
      left: n,
      right: n,
      top: t.top,
      bottom: t.bottom
    };
  }
  function e7(t) {
    let e = t.visualViewport;
    return e ? {
      left: 0,
      right: e.width,
      top: 0,
      bottom: e.height
    } : {
      left: 0,
      right: t.innerWidth,
      top: 0,
      bottom: t.innerHeight
    };
  }
  function EO(t, e) {
    let n = e.width / t.offsetWidth, r = e.height / t.offsetHeight;
    return (n > 0.995 && n < 1.005 || !isFinite(n) || Math.abs(e.width - t.offsetWidth) < 1) && (n = 1), (r > 0.995 && r < 1.005 || !isFinite(r) || Math.abs(e.height - t.offsetHeight) < 1) && (r = 1), {
      scaleX: n,
      scaleY: r
    };
  }
  function t7(t, e, n, r, i, o, s, a) {
    let l = t.ownerDocument, c = l.defaultView || window;
    for (let u = t, h = false; u && !h; )
      if (u.nodeType == 1) {
        let p, v = u == l.body, y = 1, S = 1;
        if (v)
          p = e7(c);
        else {
          if (/^(fixed|sticky)$/.test(getComputedStyle(u).position) && (h = true), u.scrollHeight <= u.clientHeight && u.scrollWidth <= u.clientWidth) {
            u = u.assignedSlot || u.parentNode;
            continue;
          }
          let k = u.getBoundingClientRect();
          ({ scaleX: y, scaleY: S } = EO(u, k)), p = {
            left: k.left,
            right: k.left + u.clientWidth * y,
            top: k.top,
            bottom: k.top + u.clientHeight * S
          };
        }
        let T = 0, w = 0;
        if (i == "nearest")
          e.top < p.top ? (w = e.top - (p.top + s), n > 0 && e.bottom > p.bottom + w && (w = e.bottom - p.bottom + s)) : e.bottom > p.bottom && (w = e.bottom - p.bottom + s, n < 0 && e.top - w < p.top && (w = e.top - (p.top + s)));
        else {
          let k = e.bottom - e.top, C = p.bottom - p.top;
          w = (i == "center" && k <= C ? e.top + k / 2 - C / 2 : i == "start" || i == "center" && n < 0 ? e.top - s : e.bottom - C + s) - p.top;
        }
        if (r == "nearest" ? e.left < p.left ? (T = e.left - (p.left + o), n > 0 && e.right > p.right + T && (T = e.right - p.right + o)) : e.right > p.right && (T = e.right - p.right + o, n < 0 && e.left < p.left + T && (T = e.left - (p.left + o))) : T = (r == "center" ? e.left + (e.right - e.left) / 2 - (p.right - p.left) / 2 : r == "start" == a ? e.left - o : e.right - (p.right - p.left) + o) - p.left, T || w)
          if (v)
            c.scrollBy(T, w);
          else {
            let k = 0, C = 0;
            if (w) {
              let O = u.scrollTop;
              u.scrollTop += w / S, C = (u.scrollTop - O) * S;
            }
            if (T) {
              let O = u.scrollLeft;
              u.scrollLeft += T / y, k = (u.scrollLeft - O) * y;
            }
            e = {
              left: e.left - k,
              top: e.top - C,
              right: e.right - k,
              bottom: e.bottom - C
            }, k && Math.abs(k - T) < 1 && (r = "nearest"), C && Math.abs(C - w) < 1 && (i = "nearest");
          }
        if (v)
          break;
        (e.top < p.top || e.bottom > p.bottom || e.left < p.left || e.right > p.right) && (e = {
          left: Math.max(e.left, p.left),
          right: Math.min(e.right, p.right),
          top: Math.max(e.top, p.top),
          bottom: Math.min(e.bottom, p.bottom)
        }), u = u.assignedSlot || u.parentNode;
      } else if (u.nodeType == 11)
        u = u.host;
      else
        break;
  }
  function n7(t) {
    let e = t.ownerDocument, n, r;
    for (let i = t.parentNode; i && !(i == e.body || n && r); )
      if (i.nodeType == 1)
        !r && i.scrollHeight > i.clientHeight && (r = i), !n && i.scrollWidth > i.clientWidth && (n = i), i = i.assignedSlot || i.parentNode;
      else if (i.nodeType == 11)
        i = i.host;
      else
        break;
    return {
      x: n,
      y: r
    };
  }
  class r7 {
    constructor() {
      this.anchorNode = null, this.anchorOffset = 0, this.focusNode = null, this.focusOffset = 0;
    }
    eq(e) {
      return this.anchorNode == e.anchorNode && this.anchorOffset == e.anchorOffset && this.focusNode == e.focusNode && this.focusOffset == e.focusOffset;
    }
    setRange(e) {
      let { anchorNode: n, focusNode: r } = e;
      this.set(n, Math.min(e.anchorOffset, n ? ro(n) : 0), r, Math.min(e.focusOffset, r ? ro(r) : 0));
    }
    set(e, n, r, i) {
      this.anchorNode = e, this.anchorOffset = n, this.focusNode = r, this.focusOffset = i;
    }
  }
  let bs = null;
  de.safari && de.safari_version >= 26 && (bs = false);
  function PO(t) {
    if (t.setActive)
      return t.setActive();
    if (bs)
      return t.focus(bs);
    let e = [];
    for (let n = t; n && (e.push(n, n.scrollTop, n.scrollLeft), n != n.ownerDocument); n = n.parentNode)
      ;
    if (t.focus(bs == null ? {
      get preventScroll() {
        return bs = {
          preventScroll: true
        }, true;
      }
    } : void 0), !bs) {
      bs = false;
      for (let n = 0; n < e.length; ) {
        let r = e[n++], i = e[n++], o = e[n++];
        r.scrollTop != i && (r.scrollTop = i), r.scrollLeft != o && (r.scrollLeft = o);
      }
    }
  }
  let _C;
  function zu(t, e, n = e) {
    let r = _C || (_C = document.createRange());
    return r.setEnd(t, n), r.setStart(t, e), r;
  }
  function Qa(t, e, n, r) {
    let i = {
      key: e,
      code: e,
      keyCode: n,
      which: n,
      cancelable: true
    };
    r && ({ altKey: i.altKey, ctrlKey: i.ctrlKey, shiftKey: i.shiftKey, metaKey: i.metaKey } = r);
    let o = new KeyboardEvent("keydown", i);
    o.synthetic = true, t.dispatchEvent(o);
    let s = new KeyboardEvent("keyup", i);
    return s.synthetic = true, t.dispatchEvent(s), o.defaultPrevented || s.defaultPrevented;
  }
  function i7(t) {
    for (; t; ) {
      if (t && (t.nodeType == 9 || t.nodeType == 11 && t.host))
        return t;
      t = t.assignedSlot || t.parentNode;
    }
    return null;
  }
  function o7(t, e) {
    let n = e.focusNode, r = e.focusOffset;
    if (!n || e.anchorNode != n || e.anchorOffset != r)
      return false;
    for (r = Math.min(r, ro(n)); ; )
      if (r) {
        if (n.nodeType != 1)
          return false;
        let i = n.childNodes[r - 1];
        i.contentEditable == "false" ? r-- : (n = i, r = ro(n));
      } else {
        if (n == t)
          return true;
        r = Go(n), n = n.parentNode;
      }
  }
  function OO(t) {
    return t.scrollTop > Math.max(1, t.scrollHeight - t.clientHeight - 4);
  }
  function LO(t, e) {
    for (let n = t, r = e; ; ) {
      if (n.nodeType == 3 && r > 0)
        return {
          node: n,
          offset: r
        };
      if (n.nodeType == 1 && r > 0) {
        if (n.contentEditable == "false")
          return null;
        n = n.childNodes[r - 1], r = ro(n);
      } else if (n.parentNode && !bp(n))
        r = Go(n), n = n.parentNode;
      else
        return null;
    }
  }
  function RO(t, e) {
    for (let n = t, r = e; ; ) {
      if (n.nodeType == 3 && r < n.nodeValue.length)
        return {
          node: n,
          offset: r
        };
      if (n.nodeType == 1 && r < n.childNodes.length) {
        if (n.contentEditable == "false")
          return null;
        n = n.childNodes[r], r = 0;
      } else if (n.parentNode && !bp(n))
        r = Go(n) + 1, n = n.parentNode;
      else
        return null;
    }
  }
  class zr {
    constructor(e, n, r = true) {
      this.node = e, this.offset = n, this.precise = r;
    }
    static before(e, n) {
      return new zr(e.parentNode, Go(e), n);
    }
    static after(e, n) {
      return new zr(e.parentNode, Go(e) + 1, n);
    }
  }
  var Je = function(t) {
    return t[t.LTR = 0] = "LTR", t[t.RTL = 1] = "RTL", t;
  }(Je || (Je = {}));
  const Ks = Je.LTR, _x = Je.RTL;
  function _O(t) {
    let e = [];
    for (let n = 0; n < t.length; n++)
      e.push(1 << +t[n]);
    return e;
  }
  const s7 = _O("88888888888888888888888888888888888666888888787833333333337888888000000000000000000000000008888880000000000000000000000000088888888888888888888888888888888888887866668888088888663380888308888800000000000000000000000800000000000000000000000000000008"), a7 = _O("4444448826627288999999999992222222222222222222222222222222222222222222222229999999999999999999994444444444644222822222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222999999949999999229989999223333333333"), i1 = /* @__PURE__ */ Object.create(null), ri = [];
  for (let t of [
    "()",
    "[]",
    "{}"
  ]) {
    let e = t.charCodeAt(0), n = t.charCodeAt(1);
    i1[e] = n, i1[n] = -e;
  }
  function DO(t) {
    return t <= 247 ? s7[t] : 1424 <= t && t <= 1524 ? 2 : 1536 <= t && t <= 1785 ? a7[t - 1536] : 1774 <= t && t <= 2220 ? 4 : 8192 <= t && t <= 8204 ? 256 : 64336 <= t && t <= 65023 ? 4 : 1;
  }
  const l7 = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac\ufb50-\ufdff]/;
  class bi {
    get dir() {
      return this.level % 2 ? _x : Ks;
    }
    constructor(e, n, r) {
      this.from = e, this.to = n, this.level = r;
    }
    side(e, n) {
      return this.dir == n == e ? this.to : this.from;
    }
    forward(e, n) {
      return e == (this.dir == n);
    }
    static find(e, n, r, i) {
      let o = -1;
      for (let s = 0; s < e.length; s++) {
        let a = e[s];
        if (a.from <= n && a.to >= n) {
          if (a.level == r)
            return s;
          (o < 0 || (i != 0 ? i < 0 ? a.from < n : a.to > n : e[o].level > a.level)) && (o = s);
        }
      }
      if (o < 0)
        throw new RangeError("Index out of range");
      return o;
    }
  }
  function IO(t, e) {
    if (t.length != e.length)
      return false;
    for (let n = 0; n < t.length; n++) {
      let r = t[n], i = e[n];
      if (r.from != i.from || r.to != i.to || r.direction != i.direction || !IO(r.inner, i.inner))
        return false;
    }
    return true;
  }
  const Ze = [];
  function c7(t, e, n, r, i) {
    for (let o = 0; o <= r.length; o++) {
      let s = o ? r[o - 1].to : e, a = o < r.length ? r[o].from : n, l = o ? 256 : i;
      for (let c = s, u = l, h = l; c < a; c++) {
        let p = DO(t.charCodeAt(c));
        p == 512 ? p = u : p == 8 && h == 4 && (p = 16), Ze[c] = p == 4 ? 2 : p, p & 7 && (h = p), u = p;
      }
      for (let c = s, u = l, h = l; c < a; c++) {
        let p = Ze[c];
        if (p == 128)
          c < a - 1 && u == Ze[c + 1] && u & 24 ? p = Ze[c] = u : Ze[c] = 256;
        else if (p == 64) {
          let v = c + 1;
          for (; v < a && Ze[v] == 64; )
            v++;
          let y = c && u == 8 || v < n && Ze[v] == 8 ? h == 1 ? 1 : 8 : 256;
          for (let S = c; S < v; S++)
            Ze[S] = y;
          c = v - 1;
        } else
          p == 8 && h == 1 && (Ze[c] = 1);
        u = p, p & 7 && (h = p);
      }
    }
  }
  function u7(t, e, n, r, i) {
    let o = i == 1 ? 2 : 1;
    for (let s = 0, a = 0, l = 0; s <= r.length; s++) {
      let c = s ? r[s - 1].to : e, u = s < r.length ? r[s].from : n;
      for (let h = c, p, v, y; h < u; h++)
        if (v = i1[p = t.charCodeAt(h)])
          if (v < 0) {
            for (let S = a - 3; S >= 0; S -= 3)
              if (ri[S + 1] == -v) {
                let T = ri[S + 2], w = T & 2 ? i : T & 4 ? T & 1 ? o : i : 0;
                w && (Ze[h] = Ze[ri[S]] = w), a = S;
                break;
              }
          } else {
            if (ri.length == 189)
              break;
            ri[a++] = h, ri[a++] = p, ri[a++] = l;
          }
        else if ((y = Ze[h]) == 2 || y == 1) {
          let S = y == i;
          l = S ? 0 : 1;
          for (let T = a - 3; T >= 0; T -= 3) {
            let w = ri[T + 2];
            if (w & 2)
              break;
            if (S)
              ri[T + 2] |= 2;
            else {
              if (w & 4)
                break;
              ri[T + 2] |= 4;
            }
          }
        }
    }
  }
  function f7(t, e, n, r) {
    for (let i = 0, o = r; i <= n.length; i++) {
      let s = i ? n[i - 1].to : t, a = i < n.length ? n[i].from : e;
      for (let l = s; l < a; ) {
        let c = Ze[l];
        if (c == 256) {
          let u = l + 1;
          for (; ; )
            if (u == a) {
              if (i == n.length)
                break;
              u = n[i++].to, a = i < n.length ? n[i].from : e;
            } else if (Ze[u] == 256)
              u++;
            else
              break;
          let h = o == 1, p = (u < e ? Ze[u] : r) == 1, v = h == p ? h ? 1 : 2 : r;
          for (let y = u, S = i, T = S ? n[S - 1].to : t; y > l; )
            y == T && (y = n[--S].from, T = S ? n[S - 1].to : t), Ze[--y] = v;
          l = u;
        } else
          o = c, l++;
      }
    }
  }
  function o1(t, e, n, r, i, o, s) {
    let a = r % 2 ? 2 : 1;
    if (r % 2 == i % 2)
      for (let l = e, c = 0; l < n; ) {
        let u = true, h = false;
        if (c == o.length || l < o[c].from) {
          let S = Ze[l];
          S != a && (u = false, h = S == 16);
        }
        let p = !u && a == 1 ? [] : null, v = u ? r : r + 1, y = l;
        e:
          for (; ; )
            if (c < o.length && y == o[c].from) {
              if (h)
                break e;
              let S = o[c];
              if (!u)
                for (let T = S.to, w = c + 1; ; ) {
                  if (T == n)
                    break e;
                  if (w < o.length && o[w].from == T)
                    T = o[w++].to;
                  else {
                    if (Ze[T] == a)
                      break e;
                    break;
                  }
                }
              if (c++, p)
                p.push(S);
              else {
                S.from > l && s.push(new bi(l, S.from, v));
                let T = S.direction == Ks != !(v % 2);
                s1(t, T ? r + 1 : r, i, S.inner, S.from, S.to, s), l = S.to;
              }
              y = S.to;
            } else {
              if (y == n || (u ? Ze[y] != a : Ze[y] == a))
                break;
              y++;
            }
        p ? o1(t, l, y, r + 1, i, p, s) : l < y && s.push(new bi(l, y, v)), l = y;
      }
    else
      for (let l = n, c = o.length; l > e; ) {
        let u = true, h = false;
        if (!c || l > o[c - 1].to) {
          let S = Ze[l - 1];
          S != a && (u = false, h = S == 16);
        }
        let p = !u && a == 1 ? [] : null, v = u ? r : r + 1, y = l;
        e:
          for (; ; )
            if (c && y == o[c - 1].to) {
              if (h)
                break e;
              let S = o[--c];
              if (!u)
                for (let T = S.from, w = c; ; ) {
                  if (T == e)
                    break e;
                  if (w && o[w - 1].to == T)
                    T = o[--w].from;
                  else {
                    if (Ze[T - 1] == a)
                      break e;
                    break;
                  }
                }
              if (p)
                p.push(S);
              else {
                S.to < l && s.push(new bi(S.to, l, v));
                let T = S.direction == Ks != !(v % 2);
                s1(t, T ? r + 1 : r, i, S.inner, S.from, S.to, s), l = S.from;
              }
              y = S.from;
            } else {
              if (y == e || (u ? Ze[y - 1] != a : Ze[y - 1] == a))
                break;
              y--;
            }
        p ? o1(t, y, l, r + 1, i, p, s) : y < l && s.push(new bi(y, l, v)), l = y;
      }
  }
  function s1(t, e, n, r, i, o, s) {
    let a = e % 2 ? 2 : 1;
    c7(t, i, o, r, a), u7(t, i, o, r, a), f7(i, o, r, a), o1(t, i, o, e, n, r, s);
  }
  function h7(t, e, n) {
    if (!t)
      return [
        new bi(0, 0, e == _x ? 1 : 0)
      ];
    if (e == Ks && !n.length && !l7.test(t))
      return BO(t.length);
    if (n.length)
      for (; t.length > Ze.length; )
        Ze[Ze.length] = 256;
    let r = [], i = e == Ks ? 0 : 1;
    return s1(t, i, i, n, 0, t.length, r), r;
  }
  function BO(t) {
    return [
      new bi(0, t, 0)
    ];
  }
  let NO = "";
  function d7(t, e, n, r, i) {
    var o;
    let s = r.head - t.from, a = bi.find(e, s, (o = r.bidiLevel) !== null && o !== void 0 ? o : -1, r.assoc), l = e[a], c = l.side(i, n);
    if (s == c) {
      let p = a += i ? 1 : -1;
      if (p < 0 || p >= e.length)
        return null;
      l = e[a = p], s = l.side(!i, n), c = l.side(i, n);
    }
    let u = Ht(t.text, s, l.forward(i, n));
    (u < l.from || u > l.to) && (u = c), NO = t.text.slice(Math.min(s, u), Math.max(s, u));
    let h = a == (i ? e.length - 1 : 0) ? null : e[a + (i ? 1 : -1)];
    return h && u == c && h.level + (i ? 0 : 1) < l.level ? q.cursor(h.side(!i, n) + t.from, h.forward(i, n) ? 1 : -1, h.level) : q.cursor(u + t.from, l.forward(i, n) ? -1 : 1, l.level);
  }
  function p7(t, e, n) {
    for (let r = e; r < n; r++) {
      let i = DO(t.charCodeAt(r));
      if (i == 1)
        return Ks;
      if (i == 2 || i == 4)
        return _x;
    }
    return Ks;
  }
  const $O = me.define(), zO = me.define(), FO = me.define(), VO = me.define(), a1 = me.define(), WO = me.define(), HO = me.define(), Dx = me.define(), Ix = me.define(), jO = me.define({
    combine: (t) => t.some((e) => e)
  }), UO = me.define({
    combine: (t) => t.some((e) => e)
  }), KO = me.define();
  class Ja {
    constructor(e, n = "nearest", r = "nearest", i = 5, o = 5, s = false) {
      this.range = e, this.y = n, this.x = r, this.yMargin = i, this.xMargin = o, this.isSnapshot = s;
    }
    map(e) {
      return e.empty ? this : new Ja(this.range.map(e), this.y, this.x, this.yMargin, this.xMargin, this.isSnapshot);
    }
    clip(e) {
      return this.range.to <= e.doc.length ? this : new Ja(q.cursor(e.doc.length), this.y, this.x, this.yMargin, this.xMargin, this.isSnapshot);
    }
  }
  const kh = Ee.define({
    map: (t, e) => t.map(e)
  }), qO = Ee.define();
  function In(t, e, n) {
    let r = t.facet(VO);
    r.length ? r[0](e) : window.onerror && window.onerror(String(e), n, void 0, void 0, e) || (n ? console.error(n + ":", e) : console.error(e));
  }
  const Wi = me.define({
    combine: (t) => t.length ? t[0] : true
  });
  let m7 = 0;
  const _a = me.define({
    combine(t) {
      return t.filter((e, n) => {
        for (let r = 0; r < n; r++)
          if (t[r].plugin == e.plugin)
            return false;
        return true;
      });
    }
  });
  class kt {
    constructor(e, n, r, i, o) {
      this.id = e, this.create = n, this.domEventHandlers = r, this.domEventObservers = i, this.baseExtensions = o(this), this.extension = this.baseExtensions.concat(_a.of({
        plugin: this,
        arg: void 0
      }));
    }
    of(e) {
      return this.baseExtensions.concat(_a.of({
        plugin: this,
        arg: e
      }));
    }
    static define(e, n) {
      const { eventHandlers: r, eventObservers: i, provide: o, decorations: s } = n || {};
      return new kt(m7++, e, r, i, (a) => {
        let l = [];
        return s && l.push(zm.of((c) => {
          let u = c.plugin(a);
          return u ? s(u) : be.none;
        })), o && l.push(o(a)), l;
      });
    }
    static fromClass(e, n) {
      return kt.define((r, i) => new e(r, i), n);
    }
  }
  class I0 {
    constructor(e) {
      this.spec = e, this.mustUpdate = null, this.value = null;
    }
    get plugin() {
      return this.spec && this.spec.plugin;
    }
    update(e) {
      if (this.value) {
        if (this.mustUpdate) {
          let n = this.mustUpdate;
          if (this.mustUpdate = null, this.value.update)
            try {
              this.value.update(n);
            } catch (r) {
              if (In(n.state, r, "CodeMirror plugin crashed"), this.value.destroy)
                try {
                  this.value.destroy();
                } catch {
                }
              this.deactivate();
            }
        }
      } else if (this.spec)
        try {
          this.value = this.spec.plugin.create(e, this.spec.arg);
        } catch (n) {
          In(e.state, n, "CodeMirror plugin crashed"), this.deactivate();
        }
      return this;
    }
    destroy(e) {
      var n;
      if (!((n = this.value) === null || n === void 0) && n.destroy)
        try {
          this.value.destroy();
        } catch (r) {
          In(e.state, r, "CodeMirror plugin crashed");
        }
    }
    deactivate() {
      this.spec = this.value = null;
    }
  }
  const GO = me.define(), Bx = me.define(), zm = me.define(), YO = me.define(), Nx = me.define(), cf = me.define(), XO = me.define();
  function DC(t, e) {
    let n = t.state.facet(XO);
    if (!n.length)
      return n;
    let r = n.map((o) => o instanceof Function ? o(t) : o), i = [];
    return _e.spans(r, e.from, e.to, {
      point() {
      },
      span(o, s, a, l) {
        let c = o - e.from, u = s - e.from, h = i;
        for (let p = a.length - 1; p >= 0; p--, l--) {
          let v = a[p].spec.bidiIsolate, y;
          if (v == null && (v = p7(e.text, c, u)), l > 0 && h.length && (y = h[h.length - 1]).to == c && y.direction == v)
            y.to = u, h = y.inner;
          else {
            let S = {
              from: c,
              to: u,
              direction: v,
              inner: []
            };
            h.push(S), h = S.inner;
          }
        }
      }
    }), i;
  }
  const QO = me.define();
  function $x(t) {
    let e = 0, n = 0, r = 0, i = 0;
    for (let o of t.state.facet(QO)) {
      let s = o(t);
      s && (s.left != null && (e = Math.max(e, s.left)), s.right != null && (n = Math.max(n, s.right)), s.top != null && (r = Math.max(r, s.top)), s.bottom != null && (i = Math.max(i, s.bottom)));
    }
    return {
      left: e,
      right: n,
      top: r,
      bottom: i
    };
  }
  const yc = me.define();
  class pr {
    constructor(e, n, r, i) {
      this.fromA = e, this.toA = n, this.fromB = r, this.toB = i;
    }
    join(e) {
      return new pr(Math.min(this.fromA, e.fromA), Math.max(this.toA, e.toA), Math.min(this.fromB, e.fromB), Math.max(this.toB, e.toB));
    }
    addToSet(e) {
      let n = e.length, r = this;
      for (; n > 0; n--) {
        let i = e[n - 1];
        if (!(i.fromA > r.toA)) {
          if (i.toA < r.fromA)
            break;
          r = r.join(i), e.splice(n - 1, 1);
        }
      }
      return e.splice(n, 0, r), e;
    }
    static extendWithRanges(e, n) {
      if (n.length == 0)
        return e;
      let r = [];
      for (let i = 0, o = 0, s = 0; ; ) {
        let a = i < e.length ? e[i].fromB : 1e9, l = o < n.length ? n[o] : 1e9, c = Math.min(a, l);
        if (c == 1e9)
          break;
        let u = c + s, h = c, p = u;
        for (; ; )
          if (o < n.length && n[o] <= h) {
            let v = n[o + 1];
            o += 2, h = Math.max(h, v);
            for (let y = i; y < e.length && e[y].fromB <= h; y++)
              s = e[y].toA - e[y].toB;
            p = Math.max(p, v + s);
          } else if (i < e.length && e[i].fromB <= h) {
            let v = e[i++];
            h = Math.max(h, v.toB), p = Math.max(p, v.toA), s = v.toA - v.toB;
          } else
            break;
        r.push(new pr(u, p, c, h));
      }
      return r;
    }
  }
  class xp {
    constructor(e, n, r) {
      this.view = e, this.state = n, this.transactions = r, this.flags = 0, this.startState = e.state, this.changes = Dt.empty(this.startState.doc.length);
      for (let o of r)
        this.changes = this.changes.compose(o.changes);
      let i = [];
      this.changes.iterChangedRanges((o, s, a, l) => i.push(new pr(o, s, a, l))), this.changedRanges = i;
    }
    static create(e, n, r) {
      return new xp(e, n, r);
    }
    get viewportChanged() {
      return (this.flags & 4) > 0;
    }
    get viewportMoved() {
      return (this.flags & 8) > 0;
    }
    get heightChanged() {
      return (this.flags & 2) > 0;
    }
    get geometryChanged() {
      return this.docChanged || (this.flags & 18) > 0;
    }
    get focusChanged() {
      return (this.flags & 1) > 0;
    }
    get docChanged() {
      return !this.changes.empty;
    }
    get selectionSet() {
      return this.transactions.some((e) => e.selection);
    }
    get empty() {
      return this.flags == 0 && this.transactions.length == 0;
    }
  }
  const g7 = [];
  class Lt {
    constructor(e, n, r = 0) {
      this.dom = e, this.length = n, this.flags = r, this.parent = null, e.cmTile = this;
    }
    get breakAfter() {
      return this.flags & 1;
    }
    get children() {
      return g7;
    }
    isWidget() {
      return false;
    }
    get isHidden() {
      return false;
    }
    isComposite() {
      return false;
    }
    isLine() {
      return false;
    }
    isText() {
      return false;
    }
    isBlock() {
      return false;
    }
    get domAttrs() {
      return null;
    }
    sync(e) {
      if (this.flags |= 2, this.flags & 4) {
        this.flags &= -5;
        let n = this.domAttrs;
        n && Qj(this.dom, n);
      }
    }
    toString() {
      return this.constructor.name + (this.children.length ? `(${this.children})` : "") + (this.breakAfter ? "#" : "");
    }
    destroy() {
      this.parent = null;
    }
    setDOM(e) {
      this.dom = e, e.cmTile = this;
    }
    get posAtStart() {
      return this.parent ? this.parent.posBefore(this) : 0;
    }
    get posAtEnd() {
      return this.posAtStart + this.length;
    }
    posBefore(e, n = this.posAtStart) {
      let r = n;
      for (let i of this.children) {
        if (i == e)
          return r;
        r += i.length + i.breakAfter;
      }
      throw new RangeError("Invalid child in posBefore");
    }
    posAfter(e) {
      return this.posBefore(e) + e.length;
    }
    covers(e) {
      return true;
    }
    coordsIn(e, n) {
      return null;
    }
    domPosFor(e, n) {
      let r = Go(this.dom), i = this.length ? e > 0 : n > 0;
      return new zr(this.parent.dom, r + (i ? 1 : 0), e == 0 || e == this.length);
    }
    markDirty(e) {
      this.flags &= -3, e && (this.flags |= 4), this.parent && this.parent.flags & 2 && this.parent.markDirty(false);
    }
    get overrideDOMText() {
      return null;
    }
    get root() {
      for (let e = this; e; e = e.parent)
        if (e instanceof Vm)
          return e;
      return null;
    }
    static get(e) {
      return e.cmTile;
    }
  }
  class Fm extends Lt {
    constructor(e) {
      super(e, 0), this._children = [];
    }
    isComposite() {
      return true;
    }
    get children() {
      return this._children;
    }
    get lastChild() {
      return this.children.length ? this.children[this.children.length - 1] : null;
    }
    append(e) {
      this.children.push(e), e.parent = this;
    }
    sync(e) {
      if (this.flags & 2)
        return;
      super.sync(e);
      let n = this.dom, r = null, i, o = (e == null ? void 0 : e.node) == n ? e : null, s = 0;
      for (let a of this.children) {
        if (a.sync(e), s += a.length + a.breakAfter, i = r ? r.nextSibling : n.firstChild, o && i != a.dom && (o.written = true), a.dom.parentNode == n)
          for (; i && i != a.dom; )
            i = IC(i);
        else
          n.insertBefore(a.dom, i);
        r = a.dom;
      }
      for (i = r ? r.nextSibling : n.firstChild, o && i && (o.written = true); i; )
        i = IC(i);
      this.length = s;
    }
  }
  function IC(t) {
    let e = t.nextSibling;
    return t.parentNode.removeChild(t), e;
  }
  class Vm extends Fm {
    constructor(e, n) {
      super(n), this.view = e;
    }
    owns(e) {
      for (; e; e = e.parent)
        if (e == this)
          return true;
      return false;
    }
    isBlock() {
      return true;
    }
    nearest(e) {
      for (; ; ) {
        if (!e)
          return null;
        let n = Lt.get(e);
        if (n && this.owns(n))
          return n;
        e = e.parentNode;
      }
    }
    blockTiles(e) {
      for (let n = [], r = this, i = 0, o = 0; ; )
        if (i == r.children.length) {
          if (!n.length)
            return;
          r = r.parent, r.breakAfter && o++, i = n.pop();
        } else {
          let s = r.children[i++];
          if (s instanceof Gi)
            n.push(i), r = s, i = 0;
          else {
            let a = o + s.length, l = e(s, o);
            if (l !== void 0)
              return l;
            o = a + s.breakAfter;
          }
        }
    }
    resolveBlock(e, n) {
      let r, i = -1, o, s = -1;
      if (this.blockTiles((a, l) => {
        let c = l + a.length;
        if (e >= l && e <= c) {
          if (a.isWidget() && n >= -1 && n <= 1) {
            if (a.flags & 32)
              return true;
            a.flags & 16 && (r = void 0);
          }
          (l < e || e == c && (n < -1 ? a.length : a.covers(1))) && (!r || !a.isWidget() && r.isWidget()) && (r = a, i = e - l), (c > e || e == l && (n > 1 ? a.length : a.covers(-1))) && (!o || !a.isWidget() && o.isWidget()) && (o = a, s = e - l);
        }
      }), !r && !o)
        throw new Error("No tile at position " + e);
      return r && n < 0 || !o ? {
        tile: r,
        offset: i
      } : {
        tile: o,
        offset: s
      };
    }
  }
  class Gi extends Fm {
    constructor(e, n) {
      super(e), this.wrapper = n;
    }
    isBlock() {
      return true;
    }
    covers(e) {
      return this.children.length ? e < 0 ? this.children[0].covers(-1) : this.lastChild.covers(1) : false;
    }
    get domAttrs() {
      return this.wrapper.attributes;
    }
    static of(e, n) {
      let r = new Gi(n || document.createElement(e.tagName), e);
      return n || (r.flags |= 4), r;
    }
  }
  class ml extends Fm {
    constructor(e, n) {
      super(e), this.attrs = n;
    }
    isLine() {
      return true;
    }
    static start(e, n, r) {
      let i = new ml(n || document.createElement("div"), e);
      return (!n || !r) && (i.flags |= 4), i;
    }
    get domAttrs() {
      return this.attrs;
    }
    resolveInline(e, n, r) {
      let i = null, o = -1, s = null, a = -1;
      function l(u, h) {
        for (let p = 0, v = 0; p < u.children.length && v <= h; p++) {
          let y = u.children[p], S = v + y.length;
          S >= h && (y.isComposite() ? l(y, h - v) : (!s || s.isHidden && (n > 0 || r && y7(s, y))) && (S > h || y.flags & 32) ? (s = y, a = h - v) : (v < h || y.flags & 16 && !y.isHidden) && (i = y, o = h - v)), v = S;
        }
      }
      l(this, e);
      let c = (n < 0 ? i : s) || i || s;
      return c ? {
        tile: c,
        offset: c == i ? o : a
      } : null;
    }
    coordsIn(e, n) {
      let r = this.resolveInline(e, n, true);
      return r ? r.tile.coordsIn(Math.max(0, r.offset), n) : v7(this);
    }
    domIn(e, n) {
      let r = this.resolveInline(e, n);
      if (r) {
        let { tile: i, offset: o } = r;
        if (this.dom.contains(i.dom))
          return i.isText() ? new zr(i.dom, Math.min(i.dom.nodeValue.length, o)) : i.domPosFor(o, i.flags & 16 ? 1 : i.flags & 32 ? -1 : n);
        let s = r.tile.parent, a = false;
        for (let l of s.children) {
          if (a)
            return new zr(l.dom, 0);
          l == r.tile && (a = true);
        }
      }
      return new zr(this.dom, 0);
    }
  }
  function v7(t) {
    let e = t.dom.lastChild;
    if (!e)
      return t.dom.getBoundingClientRect();
    let n = Xc(e);
    return n[n.length - 1] || null;
  }
  function y7(t, e) {
    let n = t.coordsIn(0, 1), r = e.coordsIn(0, 1);
    return n && r && r.top < n.bottom;
  }
  class _n extends Fm {
    constructor(e, n) {
      super(e), this.mark = n;
    }
    get domAttrs() {
      return this.mark.attrs;
    }
    static of(e, n) {
      let r = new _n(n || document.createElement(e.tagName), e);
      return n || (r.flags |= 4), r;
    }
  }
  class Os extends Lt {
    constructor(e, n) {
      super(e, n.length), this.text = n;
    }
    sync(e) {
      this.flags & 2 || (super.sync(e), this.dom.nodeValue != this.text && (e && e.node == this.dom && (e.written = true), this.dom.nodeValue = this.text));
    }
    isText() {
      return true;
    }
    toString() {
      return JSON.stringify(this.text);
    }
    coordsIn(e, n) {
      let r = this.dom.nodeValue.length;
      e > r && (e = r);
      let i = e, o = e, s = 0;
      e == 0 && n < 0 || e == r && n >= 0 ? de.chrome || de.gecko || (e ? (i--, s = 1) : o < r && (o++, s = -1)) : n < 0 ? i-- : o < r && o++;
      let a = zu(this.dom, i, o).getClientRects();
      if (!a.length)
        return null;
      let l = a[(s ? s < 0 : n >= 0) ? 0 : a.length - 1];
      return de.safari && !s && l.width == 0 && (l = Array.prototype.find.call(a, (c) => c.width) || l), s ? $u(l, s < 0) : l || null;
    }
    static of(e, n) {
      let r = new Os(n || document.createTextNode(e), e);
      return n || (r.flags |= 2), r;
    }
  }
  class qs extends Lt {
    constructor(e, n, r, i) {
      super(e, n, i), this.widget = r;
    }
    isWidget() {
      return true;
    }
    get isHidden() {
      return this.widget.isHidden;
    }
    covers(e) {
      return this.flags & 48 ? false : (this.flags & (e < 0 ? 64 : 128)) > 0;
    }
    coordsIn(e, n) {
      return this.coordsInWidget(e, n, false);
    }
    coordsInWidget(e, n, r) {
      let i = this.widget.coordsAt(this.dom, e, n);
      if (i)
        return i;
      if (r)
        return $u(this.dom.getBoundingClientRect(), this.length ? e == 0 : n <= 0);
      {
        let o = this.dom.getClientRects(), s = null;
        if (!o.length)
          return null;
        let a = this.flags & 16 ? true : this.flags & 32 ? false : e > 0;
        for (let l = a ? o.length - 1 : 0; s = o[l], !(e > 0 ? l == 0 : l == o.length - 1 || s.top < s.bottom); l += a ? -1 : 1)
          ;
        return $u(s, !a);
      }
    }
    get overrideDOMText() {
      if (!this.length)
        return He.empty;
      let { root: e } = this;
      if (!e)
        return He.empty;
      let n = this.posAtStart;
      return e.view.state.doc.slice(n, n + this.length);
    }
    destroy() {
      super.destroy(), this.widget.destroy(this.dom);
    }
    static of(e, n, r, i, o) {
      return o || (o = e.toDOM(n), e.editable || (o.contentEditable = "false")), new qs(o, r, e, i);
    }
  }
  class Sp extends Lt {
    constructor(e) {
      let n = document.createElement("img");
      n.className = "cm-widgetBuffer", n.setAttribute("aria-hidden", "true"), super(n, 0, e);
    }
    get isHidden() {
      return true;
    }
    get overrideDOMText() {
      return He.empty;
    }
    coordsIn(e) {
      return this.dom.getBoundingClientRect();
    }
  }
  class b7 {
    constructor(e) {
      this.index = 0, this.beforeBreak = false, this.parents = [], this.tile = e;
    }
    advance(e, n, r) {
      let { tile: i, index: o, beforeBreak: s, parents: a } = this;
      for (; e || n > 0; )
        if (i.isComposite())
          if (s) {
            if (!e)
              break;
            r && r.break(), e--, s = false;
          } else if (o == i.children.length) {
            if (!e && !a.length)
              break;
            r && r.leave(i), s = !!i.breakAfter, { tile: i, index: o } = a.pop(), o++;
          } else {
            let l = i.children[o], c = l.breakAfter;
            (n > 0 ? l.length <= e : l.length < e) && (!r || r.skip(l, 0, l.length) !== false || !l.isComposite) ? (s = !!c, o++, e -= l.length) : (a.push({
              tile: i,
              index: o
            }), i = l, o = 0, r && l.isComposite() && r.enter(l));
          }
        else if (o == i.length)
          s = !!i.breakAfter, { tile: i, index: o } = a.pop(), o++;
        else if (e) {
          let l = Math.min(e, i.length - o);
          r && r.skip(i, o, o + l), e -= l, o += l;
        } else
          break;
      return this.tile = i, this.index = o, this.beforeBreak = s, this;
    }
    get root() {
      return this.parents.length ? this.parents[0].tile : this.tile;
    }
  }
  class x7 {
    constructor(e, n, r, i) {
      this.from = e, this.to = n, this.wrapper = r, this.rank = i;
    }
  }
  class S7 {
    constructor(e, n, r) {
      this.cache = e, this.root = n, this.blockWrappers = r, this.curLine = null, this.lastBlock = null, this.afterWidget = null, this.pos = 0, this.wrappers = [], this.wrapperPos = 0;
    }
    addText(e, n, r, i) {
      var o;
      this.flushBuffer();
      let s = this.ensureMarks(n, r), a = s.lastChild;
      if (a && a.isText() && !(a.flags & 8) && a.length + e.length < 512) {
        this.cache.reused.set(a, 2);
        let l = s.children[s.children.length - 1] = new Os(a.dom, a.text + e);
        l.parent = s;
      } else
        s.append(i || Os.of(e, (o = this.cache.find(Os)) === null || o === void 0 ? void 0 : o.dom));
      this.pos += e.length, this.afterWidget = null;
    }
    addComposition(e, n) {
      let r = this.curLine;
      r.dom != n.line.dom && (r.setDOM(this.cache.reused.has(n.line) ? B0(n.line.dom) : n.line.dom), this.cache.reused.set(n.line, 2));
      let i = r;
      for (let a = n.marks.length - 1; a >= 0; a--) {
        let l = n.marks[a], c = i.lastChild;
        if (c instanceof _n && c.mark.eq(l.mark))
          c.dom != l.dom && c.setDOM(B0(l.dom)), i = c;
        else {
          if (this.cache.reused.get(l)) {
            let h = Lt.get(l.dom);
            h && h.setDOM(B0(l.dom));
          }
          let u = _n.of(l.mark, l.dom);
          i.append(u), i = u;
        }
        this.cache.reused.set(l, 2);
      }
      let o = Lt.get(e.text);
      o && this.cache.reused.set(o, 2);
      let s = new Os(e.text, e.text.nodeValue);
      s.flags |= 8, i.append(s);
    }
    addInlineWidget(e, n, r) {
      let i = this.afterWidget && e.flags & 48 && (this.afterWidget.flags & 48) == (e.flags & 48);
      i || this.flushBuffer();
      let o = this.ensureMarks(n, r);
      !i && !(e.flags & 16) && o.append(this.getBuffer(1)), o.append(e), this.pos += e.length, this.afterWidget = e;
    }
    addMark(e, n, r) {
      this.flushBuffer(), this.ensureMarks(n, r).append(e), this.pos += e.length, this.afterWidget = null;
    }
    addBlockWidget(e) {
      this.getBlockPos().append(e), this.pos += e.length, this.lastBlock = e, this.endLine();
    }
    continueWidget(e) {
      let n = this.afterWidget || this.lastBlock;
      n.length += e, this.pos += e;
    }
    addLineStart(e, n) {
      var r;
      e || (e = JO);
      let i = ml.start(e, n || ((r = this.cache.find(ml)) === null || r === void 0 ? void 0 : r.dom), !!n);
      this.getBlockPos().append(this.lastBlock = this.curLine = i);
    }
    addLine(e) {
      this.getBlockPos().append(e), this.pos += e.length, this.lastBlock = e, this.endLine();
    }
    addBreak() {
      this.lastBlock.flags |= 1, this.endLine(), this.pos++;
    }
    addLineStartIfNotCovered(e) {
      this.blockPosCovered() || this.addLineStart(e);
    }
    ensureLine(e) {
      this.curLine || this.addLineStart(e);
    }
    ensureMarks(e, n) {
      var r;
      let i = this.curLine;
      for (let o = e.length - 1; o >= 0; o--) {
        let s = e[o], a;
        if (n > 0 && (a = i.lastChild) && a instanceof _n && a.mark.eq(s))
          i = a, n--;
        else {
          let l = _n.of(s, (r = this.cache.find(_n, (c) => c.mark.eq(s))) === null || r === void 0 ? void 0 : r.dom);
          i.append(l), i = l, n = 0;
        }
      }
      return i;
    }
    endLine() {
      if (this.curLine) {
        this.flushBuffer();
        let e = this.curLine.lastChild;
        (!e || !BC(this.curLine, false) || e.dom.nodeName != "BR" && e.isWidget() && !(de.ios && BC(this.curLine, true))) && this.curLine.append(this.cache.findWidget(N0, 0, 32) || new qs(N0.toDOM(), 0, N0, 32)), this.curLine = this.afterWidget = null;
      }
    }
    updateBlockWrappers() {
      this.wrapperPos > this.pos + 1e4 && (this.blockWrappers.goto(this.pos), this.wrappers.length = 0);
      for (let e = this.wrappers.length - 1; e >= 0; e--)
        this.wrappers[e].to < this.pos && this.wrappers.splice(e, 1);
      for (let e = this.blockWrappers; e.value && e.from <= this.pos; e.next())
        if (e.to >= this.pos) {
          let n = new x7(e.from, e.to, e.value, e.rank), r = this.wrappers.length;
          for (; r > 0 && (this.wrappers[r - 1].rank - n.rank || this.wrappers[r - 1].to - n.to) < 0; )
            r--;
          this.wrappers.splice(r, 0, n);
        }
      this.wrapperPos = this.pos;
    }
    getBlockPos() {
      var e;
      this.updateBlockWrappers();
      let n = this.root;
      for (let r of this.wrappers) {
        let i = n.lastChild;
        if (r.from < this.pos && i instanceof Gi && i.wrapper.eq(r.wrapper))
          n = i;
        else {
          let o = Gi.of(r.wrapper, (e = this.cache.find(Gi, (s) => s.wrapper.eq(r.wrapper))) === null || e === void 0 ? void 0 : e.dom);
          n.append(o), n = o;
        }
      }
      return n;
    }
    blockPosCovered() {
      let e = this.lastBlock;
      return e != null && !e.breakAfter && (!e.isWidget() || (e.flags & 160) > 0);
    }
    getBuffer(e) {
      let n = 2 | (e < 0 ? 16 : 32), r = this.cache.find(Sp, void 0, 1);
      return r && (r.flags = n), r || new Sp(n);
    }
    flushBuffer() {
      this.afterWidget && !(this.afterWidget.flags & 32) && (this.afterWidget.parent.append(this.getBuffer(-1)), this.afterWidget = null);
    }
  }
  class w7 {
    constructor(e) {
      this.skipCount = 0, this.text = "", this.textOff = 0, this.cursor = e.iter();
    }
    skip(e) {
      this.textOff + e <= this.text.length ? this.textOff += e : (this.skipCount += e - (this.text.length - this.textOff), this.text = "", this.textOff = 0);
    }
    next(e) {
      if (this.textOff == this.text.length) {
        let { value: i, lineBreak: o, done: s } = this.cursor.next(this.skipCount);
        if (this.skipCount = 0, s)
          throw new Error("Ran out of text content when drawing inline views");
        this.text = i;
        let a = this.textOff = Math.min(e, i.length);
        return o ? null : i.slice(0, a);
      }
      let n = Math.min(this.text.length, this.textOff + e), r = this.text.slice(this.textOff, n);
      return this.textOff = n, r;
    }
  }
  const wp = [
    qs,
    ml,
    Os,
    _n,
    Sp,
    Gi,
    Vm
  ];
  for (let t = 0; t < wp.length; t++)
    wp[t].bucket = t;
  class k7 {
    constructor(e) {
      this.view = e, this.buckets = wp.map(() => []), this.index = wp.map(() => 0), this.reused = /* @__PURE__ */ new Map();
    }
    add(e) {
      let n = e.constructor.bucket, r = this.buckets[n];
      r.length < 6 ? r.push(e) : r[this.index[n] = (this.index[n] + 1) % 6] = e;
    }
    find(e, n, r = 2) {
      let i = e.bucket, o = this.buckets[i], s = this.index[i];
      for (let a = o.length - 1; a >= 0; a--) {
        let l = (a + s) % o.length, c = o[l];
        if ((!n || n(c)) && !this.reused.has(c))
          return o.splice(l, 1), l < s && this.index[i]--, this.reused.set(c, r), c;
      }
      return null;
    }
    findWidget(e, n, r) {
      let i = this.buckets[0];
      if (i.length)
        for (let o = 0, s = 0; ; o++) {
          if (o == i.length) {
            if (s)
              return null;
            s = 1, o = 0;
          }
          let a = i[o];
          if (!this.reused.has(a) && (s == 0 ? a.widget.compare(e) : a.widget.constructor == e.constructor && e.updateDOM(a.dom, this.view)))
            return i.splice(o, 1), o < this.index[0] && this.index[0]--, a.widget == e && a.length == n && (a.flags & 497) == r ? (this.reused.set(a, 1), a) : (this.reused.set(a, 2), new qs(a.dom, n, e, a.flags & -498 | r));
        }
    }
    reuse(e) {
      return this.reused.set(e, 1), e;
    }
    maybeReuse(e, n = 2) {
      if (!this.reused.has(e))
        return this.reused.set(e, n), e.dom;
    }
    clear() {
      for (let e = 0; e < this.buckets.length; e++)
        this.buckets[e].length = this.index[e] = 0;
    }
  }
  class C7 {
    constructor(e, n, r, i, o) {
      this.view = e, this.decorations = i, this.disallowBlockEffectsFor = o, this.openWidget = false, this.openMarks = 0, this.cache = new k7(e), this.text = new w7(e.state.doc), this.builder = new S7(this.cache, new Vm(e, e.contentDOM), _e.iter(r)), this.cache.reused.set(n, 2), this.old = new b7(n), this.reuseWalker = {
        skip: (s, a, l) => {
          if (this.cache.add(s), s.isComposite())
            return false;
        },
        enter: (s) => this.cache.add(s),
        leave: () => {
        },
        break: () => {
        }
      };
    }
    run(e, n) {
      let r = n && this.getCompositionContext(n.text);
      for (let i = 0, o = 0, s = 0; ; ) {
        let a = s < e.length ? e[s++] : null, l = a ? a.fromA : this.old.root.length;
        if (l > i) {
          let c = l - i;
          this.preserve(c, !s, !a), i = l, o += c;
        }
        if (!a)
          break;
        n && a.fromA <= n.range.fromA && a.toA >= n.range.toA ? (this.forward(a.fromA, n.range.fromA, n.range.fromA < n.range.toA ? 1 : -1), this.emit(o, n.range.fromB), this.cache.clear(), this.builder.addComposition(n, r), this.text.skip(n.range.toB - n.range.fromB), this.forward(n.range.fromA, a.toA), this.emit(n.range.toB, a.toB)) : (this.forward(a.fromA, a.toA), this.emit(o, a.toB)), o = a.toB, i = a.toA;
      }
      return this.builder.curLine && this.builder.endLine(), this.builder.root;
    }
    preserve(e, n, r) {
      let i = A7(this.old), o = this.openMarks;
      this.old.advance(e, r ? 1 : -1, {
        skip: (s, a, l) => {
          if (s.isWidget())
            if (this.openWidget)
              this.builder.continueWidget(l - a);
            else {
              let c = l > 0 || a < s.length ? qs.of(s.widget, this.view, l - a, s.flags & 496, this.cache.maybeReuse(s)) : this.cache.reuse(s);
              c.flags & 256 ? (c.flags &= -2, this.builder.addBlockWidget(c)) : (this.builder.ensureLine(null), this.builder.addInlineWidget(c, i, o), o = i.length);
            }
          else if (s.isText())
            this.builder.ensureLine(null), !a && l == s.length ? this.builder.addText(s.text, i, o, this.cache.reuse(s)) : (this.cache.add(s), this.builder.addText(s.text.slice(a, l), i, o)), o = i.length;
          else if (s.isLine())
            s.flags &= -2, this.cache.reused.set(s, 1), this.builder.addLine(s);
          else if (s instanceof Sp)
            this.cache.add(s);
          else if (s instanceof _n)
            this.builder.ensureLine(null), this.builder.addMark(s, i, o), this.cache.reused.set(s, 1), o = i.length;
          else
            return false;
          this.openWidget = false;
        },
        enter: (s) => {
          s.isLine() ? this.builder.addLineStart(s.attrs, this.cache.maybeReuse(s)) : (this.cache.add(s), s instanceof _n && i.unshift(s.mark)), this.openWidget = false;
        },
        leave: (s) => {
          s.isLine() ? i.length && (i.length = o = 0) : s instanceof _n && (i.shift(), o = Math.min(o, i.length));
        },
        break: () => {
          this.builder.addBreak(), this.openWidget = false;
        }
      }), this.text.skip(e);
    }
    emit(e, n) {
      let r = null, i = this.builder, o = 0, s = _e.spans(this.decorations, e, n, {
        point: (a, l, c, u, h, p) => {
          if (c instanceof Us) {
            if (this.disallowBlockEffectsFor[p]) {
              if (c.block)
                throw new RangeError("Block decorations may not be specified via plugins");
              if (l > this.view.state.doc.lineAt(a).to)
                throw new RangeError("Decorations that replace line breaks may not be specified via plugins");
            }
            if (o = u.length, h > u.length)
              i.continueWidget(l - a);
            else {
              let v = c.widget || (c.block ? gl.block : gl.inline), y = T7(c), S = this.cache.findWidget(v, l - a, y) || qs.of(v, this.view, l - a, y);
              c.block ? (c.startSide > 0 && i.addLineStartIfNotCovered(r), i.addBlockWidget(S)) : (i.ensureLine(r), i.addInlineWidget(S, u, h));
            }
            r = null;
          } else
            r = M7(r, c);
          l > a && this.text.skip(l - a);
        },
        span: (a, l, c, u) => {
          for (let h = a; h < l; ) {
            let p = this.text.next(Math.min(512, l - h));
            p == null ? (i.addLineStartIfNotCovered(r), i.addBreak(), h++) : (i.ensureLine(r), i.addText(p, c, h == a ? u : c.length), h += p.length), r = null;
          }
        }
      });
      i.addLineStartIfNotCovered(r), this.openWidget = s > o, this.openMarks = s;
    }
    forward(e, n, r = 1) {
      n - e <= 10 ? this.old.advance(n - e, r, this.reuseWalker) : (this.old.advance(5, -1, this.reuseWalker), this.old.advance(n - e - 10, -1), this.old.advance(5, r, this.reuseWalker));
    }
    getCompositionContext(e) {
      let n = [], r = null;
      for (let i = e.parentNode; ; i = i.parentNode) {
        let o = Lt.get(i);
        if (i == this.view.contentDOM)
          break;
        o instanceof _n ? n.push(o) : (o == null ? void 0 : o.isLine()) ? r = o : o instanceof Gi || (i.nodeName == "DIV" && !r && i != this.view.contentDOM ? r = new ml(i, JO) : r || n.push(_n.of(new af({
          tagName: i.nodeName.toLowerCase(),
          attributes: Jj(i)
        }), i)));
      }
      return {
        line: r,
        marks: n
      };
    }
  }
  function BC(t, e) {
    let n = (r) => {
      for (let i of r.children)
        if ((e ? i.isText() : i.length) || n(i))
          return true;
      return false;
    };
    return n(t);
  }
  function T7(t) {
    let e = t.isReplace ? (t.startSide < 0 ? 64 : 0) | (t.endSide > 0 ? 128 : 0) : t.startSide > 0 ? 32 : 16;
    return t.block && (e |= 256), e;
  }
  const JO = {
    class: "cm-line"
  };
  function M7(t, e) {
    let n = e.spec.attributes, r = e.spec.class;
    return !n && !r || (t || (t = {
      class: "cm-line"
    }), n && Lx(n, t), r && (t.class += " " + r)), t;
  }
  function A7(t) {
    let e = [];
    for (let n = t.parents.length; n > 1; n--) {
      let r = n == t.parents.length ? t.tile : t.parents[n].tile;
      r instanceof _n && e.push(r.mark);
    }
    return e;
  }
  function B0(t) {
    let e = Lt.get(t);
    return e && e.setDOM(t.cloneNode()), t;
  }
  class gl extends Li {
    constructor(e) {
      super(), this.tag = e;
    }
    eq(e) {
      return e.tag == this.tag;
    }
    toDOM() {
      return document.createElement(this.tag);
    }
    updateDOM(e) {
      return e.nodeName.toLowerCase() == this.tag;
    }
    get isHidden() {
      return true;
    }
  }
  gl.inline = new gl("span");
  gl.block = new gl("div");
  const N0 = new class extends Li {
    toDOM() {
      return document.createElement("br");
    }
    get isHidden() {
      return true;
    }
    get editable() {
      return true;
    }
  }();
  class NC {
    constructor(e) {
      this.view = e, this.decorations = [], this.blockWrappers = [], this.dynamicDecorationMap = [
        false
      ], this.domChanged = null, this.hasComposition = null, this.editContextFormatting = be.none, this.lastCompositionAfterCursor = false, this.minWidth = 0, this.minWidthFrom = 0, this.minWidthTo = 0, this.impreciseAnchor = null, this.impreciseHead = null, this.forceSelection = false, this.lastUpdate = Date.now(), this.updateDeco(), this.tile = new Vm(e, e.contentDOM), this.updateInner([
        new pr(0, 0, 0, e.state.doc.length)
      ], null);
    }
    update(e) {
      var n;
      let r = e.changedRanges;
      this.minWidth > 0 && r.length && (r.every(({ fromA: u, toA: h }) => h < this.minWidthFrom || u > this.minWidthTo) ? (this.minWidthFrom = e.changes.mapPos(this.minWidthFrom, 1), this.minWidthTo = e.changes.mapPos(this.minWidthTo, 1)) : this.minWidth = this.minWidthFrom = this.minWidthTo = 0), this.updateEditContextFormatting(e);
      let i = -1;
      this.view.inputState.composing >= 0 && !this.view.observer.editContext && (!((n = this.domChanged) === null || n === void 0) && n.newSel ? i = this.domChanged.newSel.head : !B7(e.changes, this.hasComposition) && !e.selectionSet && (i = e.state.selection.main.head));
      let o = i > -1 ? P7(this.view, e.changes, i) : null;
      if (this.domChanged = null, this.hasComposition) {
        let { from: u, to: h } = this.hasComposition;
        r = new pr(u, h, e.changes.mapPos(u, -1), e.changes.mapPos(h, 1)).addToSet(r.slice());
      }
      this.hasComposition = o ? {
        from: o.range.fromB,
        to: o.range.toB
      } : null, (de.ie || de.chrome) && !o && e && e.state.doc.lines != e.startState.doc.lines && (this.forceSelection = true);
      let s = this.decorations, a = this.blockWrappers;
      this.updateDeco();
      let l = R7(s, this.decorations, e.changes);
      l.length && (r = pr.extendWithRanges(r, l));
      let c = D7(a, this.blockWrappers, e.changes);
      return c.length && (r = pr.extendWithRanges(r, c)), o && !r.some((u) => u.fromA <= o.range.fromA && u.toA >= o.range.toA) && (r = o.range.addToSet(r.slice())), this.tile.flags & 2 && r.length == 0 ? false : (this.updateInner(r, o), e.transactions.length && (this.lastUpdate = Date.now()), true);
    }
    updateInner(e, n) {
      this.view.viewState.mustMeasureContent = true;
      let { observer: r } = this.view;
      r.ignore(() => {
        if (n || e.length) {
          let s = this.tile, a = new C7(this.view, s, this.blockWrappers, this.decorations, this.dynamicDecorationMap);
          this.tile = a.run(e, n), l1(s, a.cache.reused);
        }
        this.tile.dom.style.height = this.view.viewState.contentHeight / this.view.scaleY + "px", this.tile.dom.style.flexBasis = this.minWidth ? this.minWidth + "px" : "";
        let o = de.chrome || de.ios ? {
          node: r.selectionRange.focusNode,
          written: false
        } : void 0;
        this.tile.sync(o), o && (o.written || r.selectionRange.focusNode != o.node || !this.tile.dom.contains(o.node)) && (this.forceSelection = true), this.tile.dom.style.height = "";
      });
      let i = [];
      if (this.view.viewport.from || this.view.viewport.to < this.view.state.doc.length)
        for (let o of this.tile.children)
          o.isWidget() && o.widget instanceof $0 && i.push(o.dom);
      r.updateGaps(i);
    }
    updateEditContextFormatting(e) {
      this.editContextFormatting = this.editContextFormatting.map(e.changes);
      for (let n of e.transactions)
        for (let r of n.effects)
          r.is(qO) && (this.editContextFormatting = r.value);
    }
    updateSelection(e = false, n = false) {
      (e || !this.view.observer.selectionRange.focusNode) && this.view.observer.readSelectionRange();
      let { dom: r } = this.tile, i = this.view.root.activeElement, o = i == r, s = !o && !(this.view.state.facet(Wi) || r.tabIndex > -1) && Yc(r, this.view.observer.selectionRange) && !(i && r.contains(i));
      if (!(o || n || s))
        return;
      let a = this.forceSelection;
      this.forceSelection = false;
      let l = this.view.state.selection.main, c, u;
      if (l.empty ? u = c = this.inlineDOMNearPos(l.anchor, l.assoc || 1) : (u = this.inlineDOMNearPos(l.head, l.head == l.from ? 1 : -1), c = this.inlineDOMNearPos(l.anchor, l.anchor == l.from ? 1 : -1)), de.gecko && l.empty && !this.hasComposition && E7(c)) {
        let p = document.createTextNode("");
        this.view.observer.ignore(() => c.node.insertBefore(p, c.node.childNodes[c.offset] || null)), c = u = new zr(p, 0), a = true;
      }
      let h = this.view.observer.selectionRange;
      (a || !h.focusNode || (!Qc(c.node, c.offset, h.anchorNode, h.anchorOffset) || !Qc(u.node, u.offset, h.focusNode, h.focusOffset)) && !this.suppressWidgetCursorChange(h, l)) && (this.view.observer.ignore(() => {
        de.android && de.chrome && r.contains(h.focusNode) && I7(h.focusNode, r) && (r.blur(), r.focus({
          preventScroll: true
        }));
        let p = Nu(this.view.root);
        if (p)
          if (l.empty) {
            if (de.gecko) {
              let v = O7(c.node, c.offset);
              if (v && v != 3) {
                let y = (v == 1 ? LO : RO)(c.node, c.offset);
                y && (c = new zr(y.node, y.offset));
              }
            }
            p.collapse(c.node, c.offset), l.bidiLevel != null && p.caretBidiLevel !== void 0 && (p.caretBidiLevel = l.bidiLevel);
          } else if (p.extend) {
            p.collapse(c.node, c.offset);
            try {
              p.extend(u.node, u.offset);
            } catch {
            }
          } else {
            let v = document.createRange();
            l.anchor > l.head && ([c, u] = [
              u,
              c
            ]), v.setEnd(u.node, u.offset), v.setStart(c.node, c.offset), p.removeAllRanges(), p.addRange(v);
          }
        s && this.view.root.activeElement == r && (r.blur(), i && i.focus());
      }), this.view.observer.setSelectionRange(c, u)), this.impreciseAnchor = c.precise ? null : new zr(h.anchorNode, h.anchorOffset), this.impreciseHead = u.precise ? null : new zr(h.focusNode, h.focusOffset);
    }
    suppressWidgetCursorChange(e, n) {
      return this.hasComposition && n.empty && Qc(e.focusNode, e.focusOffset, e.anchorNode, e.anchorOffset) && this.posFromDOM(e.focusNode, e.focusOffset) == n.head;
    }
    enforceCursorAssoc() {
      if (this.hasComposition)
        return;
      let { view: e } = this, n = e.state.selection.main, r = Nu(e.root), { anchorNode: i, anchorOffset: o } = e.observer.selectionRange;
      if (!r || !n.empty || !n.assoc || !r.modify)
        return;
      let s = this.lineAt(n.head, n.assoc);
      if (!s)
        return;
      let a = s.posAtStart;
      if (n.head == a || n.head == a + s.length)
        return;
      let l = this.coordsAt(n.head, -1), c = this.coordsAt(n.head, 1);
      if (!l || !c || l.bottom > c.top)
        return;
      let u = this.domAtPos(n.head + n.assoc, n.assoc);
      r.collapse(u.node, u.offset), r.modify("move", n.assoc < 0 ? "forward" : "backward", "lineboundary"), e.observer.readSelectionRange();
      let h = e.observer.selectionRange;
      e.docView.posFromDOM(h.anchorNode, h.anchorOffset) != n.from && r.collapse(i, o);
    }
    posFromDOM(e, n) {
      let r = this.tile.nearest(e);
      if (!r)
        return this.tile.dom.compareDocumentPosition(e) & 2 ? 0 : this.view.state.doc.length;
      let i = r.posAtStart;
      if (r.isComposite()) {
        let o;
        if (e == r.dom)
          o = r.dom.childNodes[n];
        else {
          let s = ro(e) == 0 ? 0 : n == 0 ? -1 : 1;
          for (; ; ) {
            let a = e.parentNode;
            if (a == r.dom)
              break;
            s == 0 && a.firstChild != a.lastChild && (e == a.firstChild ? s = -1 : s = 1), e = a;
          }
          s < 0 ? o = e : o = e.nextSibling;
        }
        if (o == r.dom.firstChild)
          return i;
        for (; o && !Lt.get(o); )
          o = o.nextSibling;
        if (!o)
          return i + r.length;
        for (let s = 0, a = i; ; s++) {
          let l = r.children[s];
          if (l.dom == o)
            return a;
          a += l.length + l.breakAfter;
        }
      } else
        return r.isText() ? e == r.dom ? i + n : i + (n ? r.length : 0) : i;
    }
    domAtPos(e, n) {
      let { tile: r, offset: i } = this.tile.resolveBlock(e, n);
      return r.isWidget() ? r.domPosFor(e, n) : r.domIn(i, n);
    }
    inlineDOMNearPos(e, n) {
      let r, i = -1, o = false, s, a = -1, l = false;
      return this.tile.blockTiles((c, u) => {
        if (c.isWidget()) {
          if (c.flags & 32 && u >= e)
            return true;
          c.flags & 16 && (o = true);
        } else {
          let h = u + c.length;
          if (u <= e && (r = c, i = e - u, o = h < e), h >= e && !s && (s = c, a = e - u, l = u > e), u > e && s)
            return true;
        }
      }), !r && !s ? this.domAtPos(e, n) : (o && s ? r = null : l && r && (s = null), r && n < 0 || !s ? r.domIn(i, n) : s.domIn(a, n));
    }
    coordsAt(e, n) {
      let { tile: r, offset: i } = this.tile.resolveBlock(e, n);
      return r.isWidget() ? r.widget instanceof $0 ? null : r.coordsInWidget(i, n, true) : r.coordsIn(i, n);
    }
    lineAt(e, n) {
      let { tile: r } = this.tile.resolveBlock(e, n);
      return r.isLine() ? r : null;
    }
    coordsForChar(e) {
      let { tile: n, offset: r } = this.tile.resolveBlock(e, 1);
      if (!n.isLine())
        return null;
      function i(o, s) {
        if (o.isComposite())
          for (let a of o.children) {
            if (a.length >= s) {
              let l = i(a, s);
              if (l)
                return l;
            }
            if (s -= a.length, s < 0)
              break;
          }
        else if (o.isText() && s < o.length) {
          let a = Ht(o.text, s);
          if (a == s)
            return null;
          let l = zu(o.dom, s, a).getClientRects();
          for (let c = 0; c < l.length; c++) {
            let u = l[c];
            if (c == l.length - 1 || u.top < u.bottom && u.left < u.right)
              return u;
          }
        }
        return null;
      }
      return i(n, r);
    }
    measureVisibleLineHeights(e) {
      let n = [], { from: r, to: i } = e, o = this.view.contentDOM.clientWidth, s = o > Math.max(this.view.scrollDOM.clientWidth, this.minWidth) + 1, a = -1, l = this.view.textDirection == Je.LTR, c = 0, u = (h, p, v) => {
        for (let y = 0; y < h.children.length && !(p > i); y++) {
          let S = h.children[y], T = p + S.length, w = S.dom.getBoundingClientRect(), { height: k } = w;
          if (v && !y && (c += w.top - v.top), S instanceof Gi)
            T > r && u(S, p, w);
          else if (p >= r && (c > 0 && n.push(-c), n.push(k + c), c = 0, s)) {
            let C = S.dom.lastChild, O = C ? Xc(C) : [];
            if (O.length) {
              let L = O[O.length - 1], D = l ? L.right - w.left : w.right - L.left;
              D > a && (a = D, this.minWidth = o, this.minWidthFrom = p, this.minWidthTo = T);
            }
          }
          v && y == h.children.length - 1 && (c += v.bottom - w.bottom), p = T + S.breakAfter;
        }
      };
      return u(this.tile, 0, null), n;
    }
    textDirectionAt(e) {
      let { tile: n } = this.tile.resolveBlock(e, 1);
      return getComputedStyle(n.dom).direction == "rtl" ? Je.RTL : Je.LTR;
    }
    measureTextSize() {
      let e = this.tile.blockTiles((s) => {
        if (s.isLine() && s.children.length && s.length <= 20) {
          let a = 0, l;
          for (let c of s.children) {
            if (!c.isText() || /[^ -~]/.test(c.text))
              return;
            let u = Xc(c.dom);
            if (u.length != 1)
              return;
            a += u[0].width, l = u[0].height;
          }
          if (a)
            return {
              lineHeight: s.dom.getBoundingClientRect().height,
              charWidth: a / s.length,
              textHeight: l
            };
        }
      });
      if (e)
        return e;
      let n = document.createElement("div"), r, i, o;
      return n.className = "cm-line", n.style.width = "99999px", n.style.position = "absolute", n.textContent = "abc def ghi jkl mno pqr stu", this.view.observer.ignore(() => {
        this.tile.dom.appendChild(n);
        let s = Xc(n.firstChild)[0];
        r = n.getBoundingClientRect().height, i = s && s.width ? s.width / 27 : 7, o = s && s.height ? s.height : r, n.remove();
      }), {
        lineHeight: r,
        charWidth: i,
        textHeight: o
      };
    }
    computeBlockGapDeco() {
      let e = [], n = this.view.viewState;
      for (let r = 0, i = 0; ; i++) {
        let o = i == n.viewports.length ? null : n.viewports[i], s = o ? o.from - 1 : this.view.state.doc.length;
        if (s > r) {
          let a = (n.lineBlockAt(s).bottom - n.lineBlockAt(r).top) / this.view.scaleY;
          e.push(be.replace({
            widget: new $0(a),
            block: true,
            inclusive: true,
            isBlockGap: true
          }).range(r, s));
        }
        if (!o)
          break;
        r = o.to + 1;
      }
      return be.set(e);
    }
    updateDeco() {
      let e = 1, n = this.view.state.facet(zm).map((o) => (this.dynamicDecorationMap[e++] = typeof o == "function") ? o(this.view) : o), r = false, i = this.view.state.facet(Nx).map((o, s) => {
        let a = typeof o == "function";
        return a && (r = true), a ? o(this.view) : o;
      });
      for (i.length && (this.dynamicDecorationMap[e++] = r, n.push(_e.join(i))), this.decorations = [
        this.editContextFormatting,
        ...n,
        this.computeBlockGapDeco(),
        this.view.viewState.lineGapDeco
      ]; e < this.decorations.length; )
        this.dynamicDecorationMap[e++] = false;
      this.blockWrappers = this.view.state.facet(YO).map((o) => typeof o == "function" ? o(this.view) : o);
    }
    scrollIntoView(e) {
      if (e.isSnapshot) {
        let c = this.view.viewState.lineBlockAt(e.range.head);
        this.view.scrollDOM.scrollTop = c.top - e.yMargin, this.view.scrollDOM.scrollLeft = e.xMargin;
        return;
      }
      for (let c of this.view.state.facet(KO))
        try {
          if (c(this.view, e.range, e))
            return true;
        } catch (u) {
          In(this.view.state, u, "scroll handler");
        }
      let { range: n } = e, r = this.coordsAt(n.head, n.empty ? n.assoc : n.head > n.anchor ? -1 : 1), i;
      if (!r)
        return;
      !n.empty && (i = this.coordsAt(n.anchor, n.anchor > n.head ? -1 : 1)) && (r = {
        left: Math.min(r.left, i.left),
        top: Math.min(r.top, i.top),
        right: Math.max(r.right, i.right),
        bottom: Math.max(r.bottom, i.bottom)
      });
      let o = $x(this.view), s = {
        left: r.left - o.left,
        top: r.top - o.top,
        right: r.right + o.right,
        bottom: r.bottom + o.bottom
      }, { offsetWidth: a, offsetHeight: l } = this.view.scrollDOM;
      if (t7(this.view.scrollDOM, s, n.head < n.anchor ? -1 : 1, e.x, e.y, Math.max(Math.min(e.xMargin, a), -a), Math.max(Math.min(e.yMargin, l), -l), this.view.textDirection == Je.LTR), window.visualViewport && window.innerHeight - window.visualViewport.height > 1 && (r.top > window.pageYOffset + window.visualViewport.offsetTop + window.visualViewport.height || r.bottom < window.pageYOffset + window.visualViewport.offsetTop)) {
        let c = this.view.docView.lineAt(n.head, 1);
        c && c.dom.scrollIntoView({
          block: "nearest"
        });
      }
    }
    lineHasWidget(e) {
      let n = (r) => r.isWidget() || r.children.some(n);
      return n(this.tile.resolveBlock(e, 1).tile);
    }
    destroy() {
      l1(this.tile);
    }
  }
  function l1(t, e) {
    let n = e == null ? void 0 : e.get(t);
    if (n != 1) {
      n == null && t.destroy();
      for (let r of t.children)
        l1(r, e);
    }
  }
  function E7(t) {
    return t.node.nodeType == 1 && t.node.firstChild && (t.offset == 0 || t.node.childNodes[t.offset - 1].contentEditable == "false") && (t.offset == t.node.childNodes.length || t.node.childNodes[t.offset].contentEditable == "false");
  }
  function ZO(t, e) {
    let n = t.observer.selectionRange;
    if (!n.focusNode)
      return null;
    let r = LO(n.focusNode, n.focusOffset), i = RO(n.focusNode, n.focusOffset), o = r || i;
    if (i && r && i.node != r.node) {
      let a = Lt.get(i.node);
      if (!a || a.isText() && a.text != i.node.nodeValue)
        o = i;
      else if (t.docView.lastCompositionAfterCursor) {
        let l = Lt.get(r.node);
        !l || l.isText() && l.text != r.node.nodeValue || (o = i);
      }
    }
    if (t.docView.lastCompositionAfterCursor = o != r, !o)
      return null;
    let s = e - o.offset;
    return {
      from: s,
      to: s + o.node.nodeValue.length,
      node: o.node
    };
  }
  function P7(t, e, n) {
    let r = ZO(t, n);
    if (!r)
      return null;
    let { node: i, from: o, to: s } = r, a = i.nodeValue;
    if (/[\n\r]/.test(a) || t.state.doc.sliceString(r.from, r.to) != a)
      return null;
    let l = e.invertedDesc;
    return {
      range: new pr(l.mapPos(o), l.mapPos(s), o, s),
      text: i
    };
  }
  function O7(t, e) {
    return t.nodeType != 1 ? 0 : (e && t.childNodes[e - 1].contentEditable == "false" ? 1 : 0) | (e < t.childNodes.length && t.childNodes[e].contentEditable == "false" ? 2 : 0);
  }
  let L7 = class {
    constructor() {
      this.changes = [];
    }
    compareRange(e, n) {
      Xa(e, n, this.changes);
    }
    comparePoint(e, n) {
      Xa(e, n, this.changes);
    }
    boundChange(e) {
      Xa(e, e, this.changes);
    }
  };
  function R7(t, e, n) {
    let r = new L7();
    return _e.compare(t, e, n, r), r.changes;
  }
  class _7 {
    constructor() {
      this.changes = [];
    }
    compareRange(e, n) {
      Xa(e, n, this.changes);
    }
    comparePoint() {
    }
    boundChange(e) {
      Xa(e, e, this.changes);
    }
  }
  function D7(t, e, n) {
    let r = new _7();
    return _e.compare(t, e, n, r), r.changes;
  }
  function I7(t, e) {
    for (let n = t; n && n != e; n = n.assignedSlot || n.parentNode)
      if (n.nodeType == 1 && n.contentEditable == "false")
        return true;
    return false;
  }
  function B7(t, e) {
    let n = false;
    return e && t.iterChangedRanges((r, i) => {
      r < e.to && i > e.from && (n = true);
    }), n;
  }
  class $0 extends Li {
    constructor(e) {
      super(), this.height = e;
    }
    toDOM() {
      let e = document.createElement("div");
      return e.className = "cm-gap", this.updateDOM(e), e;
    }
    eq(e) {
      return e.height == this.height;
    }
    updateDOM(e) {
      return e.style.height = this.height + "px", true;
    }
    get editable() {
      return true;
    }
    get estimatedHeight() {
      return this.height;
    }
    ignoreEvent() {
      return false;
    }
  }
  function N7(t, e, n = 1) {
    let r = t.charCategorizer(e), i = t.doc.lineAt(e), o = e - i.from;
    if (i.length == 0)
      return q.cursor(e);
    o == 0 ? n = 1 : o == i.length && (n = -1);
    let s = o, a = o;
    n < 0 ? s = Ht(i.text, o, false) : a = Ht(i.text, o);
    let l = r(i.text.slice(s, a));
    for (; s > 0; ) {
      let c = Ht(i.text, s, false);
      if (r(i.text.slice(c, s)) != l)
        break;
      s = c;
    }
    for (; a < i.length; ) {
      let c = Ht(i.text, a);
      if (r(i.text.slice(a, c)) != l)
        break;
      a = c;
    }
    return q.range(s + i.from, a + i.from);
  }
  function $7(t, e, n, r, i) {
    let o = Math.round((r - e.left) * t.defaultCharacterWidth);
    if (t.lineWrapping && n.height > t.defaultLineHeight * 1.5) {
      let a = t.viewState.heightOracle.textHeight, l = Math.floor((i - n.top - (t.defaultLineHeight - a) * 0.5) / a);
      o += l * t.viewState.heightOracle.lineLength;
    }
    let s = t.state.sliceDoc(n.from, n.to);
    return n.from + Xy(s, o, t.state.tabSize);
  }
  function c1(t, e, n) {
    let r = t.lineBlockAt(e);
    if (Array.isArray(r.type)) {
      let i;
      for (let o of r.type) {
        if (o.from > e)
          break;
        if (!(o.to < e)) {
          if (o.from < e && o.to > e)
            return o;
          (!i || o.type == nn.Text && (i.type != o.type || (n < 0 ? o.from < e : o.to > e))) && (i = o);
        }
      }
      return i || r;
    }
    return r;
  }
  function z7(t, e, n, r) {
    let i = c1(t, e.head, e.assoc || -1), o = !r || i.type != nn.Text || !(t.lineWrapping || i.widgetLineBreaks) ? null : t.coordsAtPos(e.assoc < 0 && e.head > i.from ? e.head - 1 : e.head);
    if (o) {
      let s = t.dom.getBoundingClientRect(), a = t.textDirectionAt(i.from), l = t.posAtCoords({
        x: n == (a == Je.LTR) ? s.right - 1 : s.left + 1,
        y: (o.top + o.bottom) / 2
      });
      if (l != null)
        return q.cursor(l, n ? -1 : 1);
    }
    return q.cursor(n ? i.to : i.from, n ? -1 : 1);
  }
  function $C(t, e, n, r) {
    let i = t.state.doc.lineAt(e.head), o = t.bidiSpans(i), s = t.textDirectionAt(i.from);
    for (let a = e, l = null; ; ) {
      let c = d7(i, o, s, a, n), u = NO;
      if (!c) {
        if (i.number == (n ? t.state.doc.lines : 1))
          return a;
        u = `
`, i = t.state.doc.line(i.number + (n ? 1 : -1)), o = t.bidiSpans(i), c = t.visualLineSide(i, !n);
      }
      if (l) {
        if (!l(u))
          return a;
      } else {
        if (!r)
          return c;
        l = r(u);
      }
      a = c;
    }
  }
  function F7(t, e, n) {
    let r = t.state.charCategorizer(e), i = r(n);
    return (o) => {
      let s = r(o);
      return i == ft.Space && (i = s), i == s;
    };
  }
  function V7(t, e, n, r) {
    let i = e.head, o = n ? 1 : -1;
    if (i == (n ? t.state.doc.length : 0))
      return q.cursor(i, e.assoc);
    let s = e.goalColumn, a, l = t.contentDOM.getBoundingClientRect(), c = t.coordsAtPos(i, (e.empty ? e.assoc : 0) || (n ? 1 : -1)), u = t.documentTop;
    if (c)
      s == null && (s = c.left - l.left), a = o < 0 ? c.top : c.bottom;
    else {
      let y = t.viewState.lineBlockAt(i);
      s == null && (s = Math.min(l.right - l.left, t.defaultCharacterWidth * (i - y.from))), a = (o < 0 ? y.top : y.bottom) + u;
    }
    let h = l.left + s, p = r ?? t.viewState.heightOracle.textHeight >> 1, v = u1(t, {
      x: h,
      y: a + p * o
    }, false, o);
    return q.cursor(v.pos, v.assoc, void 0, s);
  }
  function Jc(t, e, n) {
    for (; ; ) {
      let r = 0;
      for (let i of t)
        i.between(e - 1, e + 1, (o, s, a) => {
          if (e > o && e < s) {
            let l = r || n || (e - o < s - e ? -1 : 1);
            e = l < 0 ? o : s, r = l;
          }
        });
      if (!r)
        return e;
    }
  }
  function eL(t, e) {
    let n = null;
    for (let r = 0; r < e.ranges.length; r++) {
      let i = e.ranges[r], o = null;
      if (i.empty) {
        let s = Jc(t, i.from, 0);
        s != i.from && (o = q.cursor(s, -1));
      } else {
        let s = Jc(t, i.from, -1), a = Jc(t, i.to, 1);
        (s != i.from || a != i.to) && (o = q.range(i.from == i.anchor ? s : a, i.from == i.head ? s : a));
      }
      o && (n || (n = e.ranges.slice()), n[r] = o);
    }
    return n ? q.create(n, e.mainIndex) : e;
  }
  function z0(t, e, n) {
    let r = Jc(t.state.facet(cf).map((i) => i(t)), n.from, e.head > n.from ? -1 : 1);
    return r == n.from ? n : q.cursor(r, r < n.from ? 1 : -1);
  }
  class gi {
    constructor(e, n) {
      this.pos = e, this.assoc = n;
    }
  }
  function u1(t, e, n, r) {
    let i = t.contentDOM.getBoundingClientRect(), o = i.top + t.viewState.paddingTop, { x: s, y: a } = e, l = a - o, c;
    for (; ; ) {
      if (l < 0)
        return new gi(0, 1);
      if (l > t.viewState.docHeight)
        return new gi(t.state.doc.length, -1);
      if (c = t.elementAtHeight(l), r == null)
        break;
      if (c.type == nn.Text) {
        if (r < 0 ? c.to < t.viewport.from : c.from > t.viewport.to)
          break;
        let p = t.docView.coordsAt(r < 0 ? c.from : c.to, r > 0 ? -1 : 1);
        if (p && (r < 0 ? p.top <= l + o : p.bottom >= l + o))
          break;
      }
      let h = t.viewState.heightOracle.textHeight / 2;
      l = r > 0 ? c.bottom + h : c.top - h;
    }
    if (t.viewport.from >= c.to || t.viewport.to <= c.from) {
      if (n)
        return null;
      if (c.type == nn.Text) {
        let h = $7(t, i, c, s, a);
        return new gi(h, h == c.from ? 1 : -1);
      }
    }
    if (c.type != nn.Text)
      return l < (c.top + c.bottom) / 2 ? new gi(c.from, 1) : new gi(c.to, -1);
    let u = t.docView.lineAt(c.from, 2);
    return (!u || u.length != c.length) && (u = t.docView.lineAt(c.from, -2)), new W7(t, s, a, t.textDirectionAt(c.from)).scanTile(u, c.from);
  }
  class W7 {
    constructor(e, n, r, i) {
      this.view = e, this.x = n, this.y = r, this.baseDir = i, this.line = null, this.spans = null;
    }
    bidiSpansAt(e) {
      return (!this.line || this.line.from > e || this.line.to < e) && (this.line = this.view.state.doc.lineAt(e), this.spans = this.view.bidiSpans(this.line)), this;
    }
    baseDirAt(e, n) {
      let { line: r, spans: i } = this.bidiSpansAt(e);
      return i[bi.find(i, e - r.from, -1, n)].level == this.baseDir;
    }
    dirAt(e, n) {
      let { line: r, spans: i } = this.bidiSpansAt(e);
      return i[bi.find(i, e - r.from, -1, n)].dir;
    }
    bidiIn(e, n) {
      let { spans: r, line: i } = this.bidiSpansAt(e);
      return r.length > 1 || r.length && (r[0].level != this.baseDir || r[0].to + i.from < n);
    }
    scan(e, n) {
      let r = 0, i = e.length - 1, o = /* @__PURE__ */ new Set(), s = this.bidiIn(e[0], e[i]), a, l, c = -1, u = 1e9, h;
      e:
        for (; r < i; ) {
          let v = i - r, y = r + i >> 1;
          t:
            if (o.has(y)) {
              let T = r + Math.floor(Math.random() * v);
              for (let w = 0; w < v; w++) {
                if (!o.has(T)) {
                  y = T;
                  break t;
                }
                T++, T == i && (T = r);
              }
              break e;
            }
          o.add(y);
          let S = n(y);
          if (S)
            for (let T = 0; T < S.length; T++) {
              let w = S[T], k = 0;
              if (w.bottom < this.y)
                (!a || a.bottom < w.bottom) && (a = w), k = 1;
              else if (w.top > this.y)
                (!l || l.top > w.top) && (l = w), k = -1;
              else {
                let C = w.left > this.x ? this.x - w.left : w.right < this.x ? this.x - w.right : 0, O = Math.abs(C);
                O < u && (c = y, u = O, h = w), C && (k = C < 0 == (this.baseDir == Je.LTR) ? -1 : 1);
              }
              k == -1 && (!s || this.baseDirAt(e[y], 1)) ? i = y : k == 1 && (!s || this.baseDirAt(e[y + 1], -1)) && (r = y + 1);
            }
        }
      if (!h) {
        let v = a && (!l || this.y - a.bottom < l.top - this.y) ? a : l;
        return this.y = (v.top + v.bottom) / 2, this.scan(e, n);
      }
      let p = (s ? this.dirAt(e[c], 1) : this.baseDir) == Je.LTR;
      return {
        i: c,
        after: this.x > (h.left + h.right) / 2 == p
      };
    }
    scanText(e, n) {
      let r = [];
      for (let o = 0; o < e.length; o = Ht(e.text, o))
        r.push(n + o);
      r.push(n + e.length);
      let i = this.scan(r, (o) => {
        let s = r[o] - n, a = r[o + 1] - n;
        return zu(e.dom, s, a).getClientRects();
      });
      return i.after ? new gi(r[i.i + 1], -1) : new gi(r[i.i], 1);
    }
    scanTile(e, n) {
      if (!e.length)
        return new gi(n, 1);
      if (e.children.length == 1) {
        let a = e.children[0];
        if (a.isText())
          return this.scanText(a, n);
        if (a.isComposite())
          return this.scanTile(a, n);
      }
      let r = [
        n
      ];
      for (let a = 0, l = n; a < e.children.length; a++)
        r.push(l += e.children[a].length);
      let i = this.scan(r, (a) => {
        let l = e.children[a];
        return l.flags & 48 ? null : (l.dom.nodeType == 1 ? l.dom : zu(l.dom, 0, l.length)).getClientRects();
      }), o = e.children[i.i], s = r[i.i];
      return o.isText() ? this.scanText(o, s) : o.isComposite() ? this.scanTile(o, s) : i.after ? new gi(r[i.i + 1], -1) : new gi(s, 1);
    }
  }
  const bc = "\uFFFF";
  class H7 {
    constructor(e, n) {
      this.points = e, this.view = n, this.text = "", this.lineSeparator = n.state.facet($e.lineSeparator);
    }
    append(e) {
      this.text += e;
    }
    lineBreak() {
      this.text += bc;
    }
    readRange(e, n) {
      if (!e)
        return this;
      let r = e.parentNode;
      for (let i = e; ; ) {
        this.findPointBefore(r, i);
        let o = this.text.length;
        this.readNode(i);
        let s = Lt.get(i), a = i.nextSibling;
        if (a == n) {
          (s == null ? void 0 : s.breakAfter) && !a && r != this.view.contentDOM && this.lineBreak();
          break;
        }
        let l = Lt.get(a);
        (s && l ? s.breakAfter : (s ? s.breakAfter : bp(i)) || bp(a) && (i.nodeName != "BR" || (s == null ? void 0 : s.isWidget())) && this.text.length > o) && !U7(a, n) && this.lineBreak(), i = a;
      }
      return this.findPointBefore(r, n), this;
    }
    readTextNode(e) {
      let n = e.nodeValue;
      for (let r of this.points)
        r.node == e && (r.pos = this.text.length + Math.min(r.offset, n.length));
      for (let r = 0, i = this.lineSeparator ? null : /\r\n?|\n/g; ; ) {
        let o = -1, s = 1, a;
        if (this.lineSeparator ? (o = n.indexOf(this.lineSeparator, r), s = this.lineSeparator.length) : (a = i.exec(n)) && (o = a.index, s = a[0].length), this.append(n.slice(r, o < 0 ? n.length : o)), o < 0)
          break;
        if (this.lineBreak(), s > 1)
          for (let l of this.points)
            l.node == e && l.pos > this.text.length && (l.pos -= s - 1);
        r = o + s;
      }
    }
    readNode(e) {
      let n = Lt.get(e), r = n && n.overrideDOMText;
      if (r != null) {
        this.findPointInside(e, r.length);
        for (let i = r.iter(); !i.next().done; )
          i.lineBreak ? this.lineBreak() : this.append(i.value);
      } else
        e.nodeType == 3 ? this.readTextNode(e) : e.nodeName == "BR" ? e.nextSibling && this.lineBreak() : e.nodeType == 1 && this.readRange(e.firstChild, null);
    }
    findPointBefore(e, n) {
      for (let r of this.points)
        r.node == e && e.childNodes[r.offset] == n && (r.pos = this.text.length);
    }
    findPointInside(e, n) {
      for (let r of this.points)
        (e.nodeType == 3 ? r.node == e : e.contains(r.node)) && (r.pos = this.text.length + (j7(e, r.node, r.offset) ? n : 0));
    }
  }
  function j7(t, e, n) {
    for (; ; ) {
      if (!e || n < ro(e))
        return false;
      if (e == t)
        return true;
      n = Go(e) + 1, e = e.parentNode;
    }
  }
  function U7(t, e) {
    let n;
    for (; !(t == e || !t); t = t.nextSibling) {
      let r = Lt.get(t);
      if (!(r == null ? void 0 : r.isWidget()))
        return false;
      r && (n || (n = [])).push(r);
    }
    if (n)
      for (let r of n) {
        let i = r.overrideDOMText;
        if (i == null ? void 0 : i.length)
          return false;
      }
    return true;
  }
  class zC {
    constructor(e, n) {
      this.node = e, this.offset = n, this.pos = -1;
    }
  }
  class K7 {
    constructor(e, n, r, i) {
      this.typeOver = i, this.bounds = null, this.text = "", this.domChanged = n > -1;
      let { impreciseHead: o, impreciseAnchor: s } = e.docView;
      if (e.state.readOnly && n > -1)
        this.newSel = null;
      else if (n > -1 && (this.bounds = tL(e.docView.tile, n, r, 0))) {
        let a = o || s ? [] : G7(e), l = new H7(a, e);
        l.readRange(this.bounds.startDOM, this.bounds.endDOM), this.text = l.text, this.newSel = Y7(a, this.bounds.from);
      } else {
        let a = e.observer.selectionRange, l = o && o.node == a.focusNode && o.offset == a.focusOffset || !r1(e.contentDOM, a.focusNode) ? e.state.selection.main.head : e.docView.posFromDOM(a.focusNode, a.focusOffset), c = s && s.node == a.anchorNode && s.offset == a.anchorOffset || !r1(e.contentDOM, a.anchorNode) ? e.state.selection.main.anchor : e.docView.posFromDOM(a.anchorNode, a.anchorOffset), u = e.viewport;
        if ((de.ios || de.chrome) && e.state.selection.main.empty && l != c && (u.from > 0 || u.to < e.state.doc.length)) {
          let h = Math.min(l, c), p = Math.max(l, c), v = u.from - h, y = u.to - p;
          (v == 0 || v == 1 || h == 0) && (y == 0 || y == -1 || p == e.state.doc.length) && (l = 0, c = e.state.doc.length);
        }
        e.inputState.composing > -1 && e.state.selection.ranges.length > 1 ? this.newSel = e.state.selection.replaceRange(q.range(c, l)) : this.newSel = q.single(c, l);
      }
    }
  }
  function tL(t, e, n, r) {
    if (t.isComposite()) {
      let i = -1, o = -1, s = -1, a = -1;
      for (let l = 0, c = r, u = r; l < t.children.length; l++) {
        let h = t.children[l], p = c + h.length;
        if (c < e && p > n)
          return tL(h, e, n, c);
        if (p >= e && i == -1 && (i = l, o = c), c > n && h.dom.parentNode == t.dom) {
          s = l, a = u;
          break;
        }
        u = p, c = p + h.breakAfter;
      }
      return {
        from: o,
        to: a < 0 ? r + t.length : a,
        startDOM: (i ? t.children[i - 1].dom.nextSibling : null) || t.dom.firstChild,
        endDOM: s < t.children.length && s >= 0 ? t.children[s].dom : null
      };
    } else
      return t.isText() ? {
        from: r,
        to: r + t.length,
        startDOM: t.dom,
        endDOM: t.dom.nextSibling
      } : null;
  }
  function nL(t, e) {
    let n, { newSel: r } = e, i = t.state.selection.main, o = t.inputState.lastKeyTime > Date.now() - 100 ? t.inputState.lastKeyCode : -1;
    if (e.bounds) {
      let { from: s, to: a } = e.bounds, l = i.from, c = null;
      (o === 8 || de.android && e.text.length < a - s) && (l = i.to, c = "end");
      let u = rL(t.state.doc.sliceString(s, a, bc), e.text, l - s, c);
      u && (de.chrome && o == 13 && u.toB == u.from + 2 && e.text.slice(u.from, u.toB) == bc + bc && u.toB--, n = {
        from: s + u.from,
        to: s + u.toA,
        insert: He.of(e.text.slice(u.from, u.toB).split(bc))
      });
    } else
      r && (!t.hasFocus && t.state.facet(Wi) || kp(r, i)) && (r = null);
    if (!n && !r)
      return false;
    if (!n && e.typeOver && !i.empty && r && r.main.empty ? n = {
      from: i.from,
      to: i.to,
      insert: t.state.doc.slice(i.from, i.to)
    } : (de.mac || de.android) && n && n.from == n.to && n.from == i.head - 1 && /^\. ?$/.test(n.insert.toString()) && t.contentDOM.getAttribute("autocorrect") == "off" ? (r && n.insert.length == 2 && (r = q.single(r.main.anchor - 1, r.main.head - 1)), n = {
      from: n.from,
      to: n.to,
      insert: He.of([
        n.insert.toString().replace(".", " ")
      ])
    }) : n && n.from >= i.from && n.to <= i.to && (n.from != i.from || n.to != i.to) && i.to - i.from - (n.to - n.from) <= 4 ? n = {
      from: i.from,
      to: i.to,
      insert: t.state.doc.slice(i.from, n.from).append(n.insert).append(t.state.doc.slice(n.to, i.to))
    } : t.state.doc.lineAt(i.from).to < i.to && t.docView.lineHasWidget(i.to) && t.inputState.insertingTextAt > Date.now() - 50 ? n = {
      from: i.from,
      to: i.to,
      insert: t.state.toText(t.inputState.insertingText)
    } : de.chrome && n && n.from == n.to && n.from == i.head && n.insert.toString() == `
 ` && t.lineWrapping && (r && (r = q.single(r.main.anchor - 1, r.main.head - 1)), n = {
      from: i.from,
      to: i.to,
      insert: He.of([
        " "
      ])
    }), n)
      return zx(t, n, r, o);
    if (r && !kp(r, i)) {
      let s = false, a = "select";
      return t.inputState.lastSelectionTime > Date.now() - 50 && (t.inputState.lastSelectionOrigin == "select" && (s = true), a = t.inputState.lastSelectionOrigin, a == "select.pointer" && (r = eL(t.state.facet(cf).map((l) => l(t)), r))), t.dispatch({
        selection: r,
        scrollIntoView: s,
        userEvent: a
      }), true;
    } else
      return false;
  }
  function zx(t, e, n, r = -1) {
    if (de.ios && t.inputState.flushIOSKey(e))
      return true;
    let i = t.state.selection.main;
    if (de.android && (e.to == i.to && (e.from == i.from || e.from == i.from - 1 && t.state.sliceDoc(e.from, i.from) == " ") && e.insert.length == 1 && e.insert.lines == 2 && Qa(t.contentDOM, "Enter", 13) || (e.from == i.from - 1 && e.to == i.to && e.insert.length == 0 || r == 8 && e.insert.length < e.to - e.from && e.to > i.head) && Qa(t.contentDOM, "Backspace", 8) || e.from == i.from && e.to == i.to + 1 && e.insert.length == 0 && Qa(t.contentDOM, "Delete", 46)))
      return true;
    let o = e.insert.toString();
    t.inputState.composing >= 0 && t.inputState.composing++;
    let s, a = () => s || (s = q7(t, e, n));
    return t.state.facet(WO).some((l) => l(t, e.from, e.to, o, a)) || t.dispatch(a()), true;
  }
  function q7(t, e, n) {
    let r, i = t.state, o = i.selection.main, s = -1;
    if (e.from == e.to && e.from < o.from || e.from > o.to) {
      let l = e.from < o.from ? -1 : 1, c = l < 0 ? o.from : o.to, u = Jc(i.facet(cf).map((h) => h(t)), c, l);
      e.from == u && (s = u);
    }
    if (s > -1)
      r = {
        changes: e,
        selection: q.cursor(e.from + e.insert.length, -1)
      };
    else if (e.from >= o.from && e.to <= o.to && e.to - e.from >= (o.to - o.from) / 3 && (!n || n.main.empty && n.main.from == e.from + e.insert.length) && t.inputState.composing < 0) {
      let l = o.from < e.from ? i.sliceDoc(o.from, e.from) : "", c = o.to > e.to ? i.sliceDoc(e.to, o.to) : "";
      r = i.replaceSelection(t.state.toText(l + e.insert.sliceString(0, void 0, t.state.lineBreak) + c));
    } else {
      let l = i.changes(e), c = n && n.main.to <= l.newLength ? n.main : void 0;
      if (i.selection.ranges.length > 1 && (t.inputState.composing >= 0 || t.inputState.compositionPendingChange) && e.to <= o.to + 10 && e.to >= o.to - 10) {
        let u = t.state.sliceDoc(e.from, e.to), h, p = n && ZO(t, n.main.head);
        if (p) {
          let y = e.insert.length - (e.to - e.from);
          h = {
            from: p.from,
            to: p.to - y
          };
        } else
          h = t.state.doc.lineAt(o.head);
        let v = o.to - e.to;
        r = i.changeByRange((y) => {
          if (y.from == o.from && y.to == o.to)
            return {
              changes: l,
              range: c || y.map(l)
            };
          let S = y.to - v, T = S - u.length;
          if (t.state.sliceDoc(T, S) != u || S >= h.from && T <= h.to)
            return {
              range: y
            };
          let w = i.changes({
            from: T,
            to: S,
            insert: e.insert
          }), k = y.to - o.to;
          return {
            changes: w,
            range: c ? q.range(Math.max(0, c.anchor + k), Math.max(0, c.head + k)) : y.map(w)
          };
        });
      } else
        r = {
          changes: l,
          selection: c && i.selection.replaceRange(c)
        };
    }
    let a = "input.type";
    return (t.composing || t.inputState.compositionPendingChange && t.inputState.compositionEndedAt > Date.now() - 50) && (t.inputState.compositionPendingChange = false, a += ".compose", t.inputState.compositionFirstChange && (a += ".start", t.inputState.compositionFirstChange = false)), i.update(r, {
      userEvent: a,
      scrollIntoView: true
    });
  }
  function rL(t, e, n, r) {
    let i = Math.min(t.length, e.length), o = 0;
    for (; o < i && t.charCodeAt(o) == e.charCodeAt(o); )
      o++;
    if (o == i && t.length == e.length)
      return null;
    let s = t.length, a = e.length;
    for (; s > 0 && a > 0 && t.charCodeAt(s - 1) == e.charCodeAt(a - 1); )
      s--, a--;
    if (r == "end") {
      let l = Math.max(0, o - Math.min(s, a));
      n -= s + l - o;
    }
    if (s < o && t.length < e.length) {
      let l = n <= o && n >= s ? o - n : 0;
      o -= l, a = o + (a - s), s = o;
    } else if (a < o) {
      let l = n <= o && n >= a ? o - n : 0;
      o -= l, s = o + (s - a), a = o;
    }
    return {
      from: o,
      toA: s,
      toB: a
    };
  }
  function G7(t) {
    let e = [];
    if (t.root.activeElement != t.contentDOM)
      return e;
    let { anchorNode: n, anchorOffset: r, focusNode: i, focusOffset: o } = t.observer.selectionRange;
    return n && (e.push(new zC(n, r)), (i != n || o != r) && e.push(new zC(i, o))), e;
  }
  function Y7(t, e) {
    if (t.length == 0)
      return null;
    let n = t[0].pos, r = t.length == 2 ? t[1].pos : n;
    return n > -1 && r > -1 ? q.single(n + e, r + e) : null;
  }
  function kp(t, e) {
    return e.head == t.main.head && e.anchor == t.main.anchor;
  }
  class X7 {
    setSelectionOrigin(e) {
      this.lastSelectionOrigin = e, this.lastSelectionTime = Date.now();
    }
    constructor(e) {
      this.view = e, this.lastKeyCode = 0, this.lastKeyTime = 0, this.lastTouchTime = 0, this.lastFocusTime = 0, this.lastScrollTop = 0, this.lastScrollLeft = 0, this.pendingIOSKey = void 0, this.tabFocusMode = -1, this.lastSelectionOrigin = null, this.lastSelectionTime = 0, this.lastContextMenu = 0, this.scrollHandlers = [], this.handlers = /* @__PURE__ */ Object.create(null), this.composing = -1, this.compositionFirstChange = null, this.compositionEndedAt = 0, this.compositionPendingKey = false, this.compositionPendingChange = false, this.insertingText = "", this.insertingTextAt = 0, this.mouseSelection = null, this.draggedContent = null, this.handleEvent = this.handleEvent.bind(this), this.notifiedFocused = e.hasFocus, de.safari && e.contentDOM.addEventListener("input", () => null), de.gecko && fU(e.contentDOM.ownerDocument);
    }
    handleEvent(e) {
      !iU(this.view, e) || this.ignoreDuringComposition(e) || e.type == "keydown" && this.keydown(e) || (this.view.updateState != 0 ? Promise.resolve().then(() => this.runHandlers(e.type, e)) : this.runHandlers(e.type, e));
    }
    runHandlers(e, n) {
      let r = this.handlers[e];
      if (r) {
        for (let i of r.observers)
          i(this.view, n);
        for (let i of r.handlers) {
          if (n.defaultPrevented)
            break;
          if (i(this.view, n)) {
            n.preventDefault();
            break;
          }
        }
      }
    }
    ensureHandlers(e) {
      let n = Q7(e), r = this.handlers, i = this.view.contentDOM;
      for (let o in n)
        if (o != "scroll") {
          let s = !n[o].handlers.length, a = r[o];
          a && s != !a.handlers.length && (i.removeEventListener(o, this.handleEvent), a = null), a || i.addEventListener(o, this.handleEvent, {
            passive: s
          });
        }
      for (let o in r)
        o != "scroll" && !n[o] && i.removeEventListener(o, this.handleEvent);
      this.handlers = n;
    }
    keydown(e) {
      if (this.lastKeyCode = e.keyCode, this.lastKeyTime = Date.now(), e.keyCode == 9 && this.tabFocusMode > -1 && (!this.tabFocusMode || Date.now() <= this.tabFocusMode))
        return true;
      if (this.tabFocusMode > 0 && e.keyCode != 27 && oL.indexOf(e.keyCode) < 0 && (this.tabFocusMode = -1), de.android && de.chrome && !e.synthetic && (e.keyCode == 13 || e.keyCode == 8))
        return this.view.observer.delayAndroidKey(e.key, e.keyCode), true;
      let n;
      return de.ios && !e.synthetic && !e.altKey && !e.metaKey && ((n = iL.find((r) => r.keyCode == e.keyCode)) && !e.ctrlKey || J7.indexOf(e.key) > -1 && e.ctrlKey && !e.shiftKey) ? (this.pendingIOSKey = n || e, setTimeout(() => this.flushIOSKey(), 250), true) : (e.keyCode != 229 && this.view.observer.forceFlush(), false);
    }
    flushIOSKey(e) {
      let n = this.pendingIOSKey;
      return !n || n.key == "Enter" && e && e.from < e.to && /^\S+$/.test(e.insert.toString()) ? false : (this.pendingIOSKey = void 0, Qa(this.view.contentDOM, n.key, n.keyCode, n instanceof KeyboardEvent ? n : void 0));
    }
    ignoreDuringComposition(e) {
      return !/^key/.test(e.type) || e.synthetic ? false : this.composing > 0 ? true : de.safari && !de.ios && this.compositionPendingKey && Date.now() - this.compositionEndedAt < 100 ? (this.compositionPendingKey = false, true) : false;
    }
    startMouseSelection(e) {
      this.mouseSelection && this.mouseSelection.destroy(), this.mouseSelection = e;
    }
    update(e) {
      this.view.observer.update(e), this.mouseSelection && this.mouseSelection.update(e), this.draggedContent && e.docChanged && (this.draggedContent = this.draggedContent.map(e.changes)), e.transactions.length && (this.lastKeyCode = this.lastSelectionTime = 0);
    }
    destroy() {
      this.mouseSelection && this.mouseSelection.destroy();
    }
  }
  function FC(t, e) {
    return (n, r) => {
      try {
        return e.call(t, r, n);
      } catch (i) {
        In(n.state, i);
      }
    };
  }
  function Q7(t) {
    let e = /* @__PURE__ */ Object.create(null);
    function n(r) {
      return e[r] || (e[r] = {
        observers: [],
        handlers: []
      });
    }
    for (let r of t) {
      let i = r.spec, o = i && i.plugin.domEventHandlers, s = i && i.plugin.domEventObservers;
      if (o)
        for (let a in o) {
          let l = o[a];
          l && n(a).handlers.push(FC(r.value, l));
        }
      if (s)
        for (let a in s) {
          let l = s[a];
          l && n(a).observers.push(FC(r.value, l));
        }
    }
    for (let r in qr)
      n(r).handlers.push(qr[r]);
    for (let r in kr)
      n(r).observers.push(kr[r]);
    return e;
  }
  const iL = [
    {
      key: "Backspace",
      keyCode: 8,
      inputType: "deleteContentBackward"
    },
    {
      key: "Enter",
      keyCode: 13,
      inputType: "insertParagraph"
    },
    {
      key: "Enter",
      keyCode: 13,
      inputType: "insertLineBreak"
    },
    {
      key: "Delete",
      keyCode: 46,
      inputType: "deleteContentForward"
    }
  ], J7 = "dthko", oL = [
    16,
    17,
    18,
    20,
    91,
    92,
    224,
    225
  ], Ch = 6;
  function Th(t) {
    return Math.max(0, t) * 0.7 + 8;
  }
  function Z7(t, e) {
    return Math.max(Math.abs(t.clientX - e.clientX), Math.abs(t.clientY - e.clientY));
  }
  class eU {
    constructor(e, n, r, i) {
      this.view = e, this.startEvent = n, this.style = r, this.mustSelect = i, this.scrollSpeed = {
        x: 0,
        y: 0
      }, this.scrolling = -1, this.lastEvent = n, this.scrollParents = n7(e.contentDOM), this.atoms = e.state.facet(cf).map((s) => s(e));
      let o = e.contentDOM.ownerDocument;
      o.addEventListener("mousemove", this.move = this.move.bind(this)), o.addEventListener("mouseup", this.up = this.up.bind(this)), this.extend = n.shiftKey, this.multiple = e.state.facet($e.allowMultipleSelections) && tU(e, n), this.dragging = rU(e, n) && lL(n) == 1 ? null : false;
    }
    start(e) {
      this.dragging === false && this.select(e);
    }
    move(e) {
      if (e.buttons == 0)
        return this.destroy();
      if (this.dragging || this.dragging == null && Z7(this.startEvent, e) < 10)
        return;
      this.select(this.lastEvent = e);
      let n = 0, r = 0, i = 0, o = 0, s = this.view.win.innerWidth, a = this.view.win.innerHeight;
      this.scrollParents.x && ({ left: i, right: s } = this.scrollParents.x.getBoundingClientRect()), this.scrollParents.y && ({ top: o, bottom: a } = this.scrollParents.y.getBoundingClientRect());
      let l = $x(this.view);
      e.clientX - l.left <= i + Ch ? n = -Th(i - e.clientX) : e.clientX + l.right >= s - Ch && (n = Th(e.clientX - s)), e.clientY - l.top <= o + Ch ? r = -Th(o - e.clientY) : e.clientY + l.bottom >= a - Ch && (r = Th(e.clientY - a)), this.setScrollSpeed(n, r);
    }
    up(e) {
      this.dragging == null && this.select(this.lastEvent), this.dragging || e.preventDefault(), this.destroy();
    }
    destroy() {
      this.setScrollSpeed(0, 0);
      let e = this.view.contentDOM.ownerDocument;
      e.removeEventListener("mousemove", this.move), e.removeEventListener("mouseup", this.up), this.view.inputState.mouseSelection = this.view.inputState.draggedContent = null;
    }
    setScrollSpeed(e, n) {
      this.scrollSpeed = {
        x: e,
        y: n
      }, e || n ? this.scrolling < 0 && (this.scrolling = setInterval(() => this.scroll(), 50)) : this.scrolling > -1 && (clearInterval(this.scrolling), this.scrolling = -1);
    }
    scroll() {
      let { x: e, y: n } = this.scrollSpeed;
      e && this.scrollParents.x && (this.scrollParents.x.scrollLeft += e, e = 0), n && this.scrollParents.y && (this.scrollParents.y.scrollTop += n, n = 0), (e || n) && this.view.win.scrollBy(e, n), this.dragging === false && this.select(this.lastEvent);
    }
    select(e) {
      let { view: n } = this, r = eL(this.atoms, this.style.get(e, this.extend, this.multiple));
      (this.mustSelect || !r.eq(n.state.selection, this.dragging === false)) && this.view.dispatch({
        selection: r,
        userEvent: "select.pointer"
      }), this.mustSelect = false;
    }
    update(e) {
      e.transactions.some((n) => n.isUserEvent("input.type")) ? this.destroy() : this.style.update(e) && setTimeout(() => this.select(this.lastEvent), 20);
    }
  }
  function tU(t, e) {
    let n = t.state.facet($O);
    return n.length ? n[0](e) : de.mac ? e.metaKey : e.ctrlKey;
  }
  function nU(t, e) {
    let n = t.state.facet(zO);
    return n.length ? n[0](e) : de.mac ? !e.altKey : !e.ctrlKey;
  }
  function rU(t, e) {
    let { main: n } = t.state.selection;
    if (n.empty)
      return false;
    let r = Nu(t.root);
    if (!r || r.rangeCount == 0)
      return true;
    let i = r.getRangeAt(0).getClientRects();
    for (let o = 0; o < i.length; o++) {
      let s = i[o];
      if (s.left <= e.clientX && s.right >= e.clientX && s.top <= e.clientY && s.bottom >= e.clientY)
        return true;
    }
    return false;
  }
  function iU(t, e) {
    if (!e.bubbles)
      return true;
    if (e.defaultPrevented)
      return false;
    for (let n = e.target, r; n != t.contentDOM; n = n.parentNode)
      if (!n || n.nodeType == 11 || (r = Lt.get(n)) && r.isWidget() && !r.isHidden && r.widget.ignoreEvent(e))
        return false;
    return true;
  }
  const qr = /* @__PURE__ */ Object.create(null), kr = /* @__PURE__ */ Object.create(null), sL = de.ie && de.ie_version < 15 || de.ios && de.webkit_version < 604;
  function oU(t) {
    let e = t.dom.parentNode;
    if (!e)
      return;
    let n = e.appendChild(document.createElement("textarea"));
    n.style.cssText = "position: fixed; left: -10000px; top: 10px", n.focus(), setTimeout(() => {
      t.focus(), n.remove(), aL(t, n.value);
    }, 50);
  }
  function Wm(t, e, n) {
    for (let r of t.facet(e))
      n = r(n, t);
    return n;
  }
  function aL(t, e) {
    e = Wm(t.state, Dx, e);
    let { state: n } = t, r, i = 1, o = n.toText(e), s = o.lines == n.selection.ranges.length;
    if (f1 != null && n.selection.ranges.every((l) => l.empty) && f1 == o.toString()) {
      let l = -1;
      r = n.changeByRange((c) => {
        let u = n.doc.lineAt(c.from);
        if (u.from == l)
          return {
            range: c
          };
        l = u.from;
        let h = n.toText((s ? o.line(i++).text : e) + n.lineBreak);
        return {
          changes: {
            from: u.from,
            insert: h
          },
          range: q.cursor(c.from + h.length)
        };
      });
    } else
      s ? r = n.changeByRange((l) => {
        let c = o.line(i++);
        return {
          changes: {
            from: l.from,
            to: l.to,
            insert: c.text
          },
          range: q.cursor(l.from + c.length)
        };
      }) : r = n.replaceSelection(o);
    t.dispatch(r, {
      userEvent: "input.paste",
      scrollIntoView: true
    });
  }
  kr.scroll = (t) => {
    t.inputState.lastScrollTop = t.scrollDOM.scrollTop, t.inputState.lastScrollLeft = t.scrollDOM.scrollLeft;
  };
  qr.keydown = (t, e) => (t.inputState.setSelectionOrigin("select"), e.keyCode == 27 && t.inputState.tabFocusMode != 0 && (t.inputState.tabFocusMode = Date.now() + 2e3), false);
  kr.touchstart = (t, e) => {
    t.inputState.lastTouchTime = Date.now(), t.inputState.setSelectionOrigin("select.pointer");
  };
  kr.touchmove = (t) => {
    t.inputState.setSelectionOrigin("select.pointer");
  };
  qr.mousedown = (t, e) => {
    if (t.observer.flush(), t.inputState.lastTouchTime > Date.now() - 2e3)
      return false;
    let n = null;
    for (let r of t.state.facet(FO))
      if (n = r(t, e), n)
        break;
    if (!n && e.button == 0 && (n = aU(t, e)), n) {
      let r = !t.hasFocus;
      t.inputState.startMouseSelection(new eU(t, e, n, r)), r && t.observer.ignore(() => {
        PO(t.contentDOM);
        let o = t.root.activeElement;
        o && !o.contains(t.contentDOM) && o.blur();
      });
      let i = t.inputState.mouseSelection;
      if (i)
        return i.start(e), i.dragging === false;
    } else
      t.inputState.setSelectionOrigin("select.pointer");
    return false;
  };
  function VC(t, e, n, r) {
    if (r == 1)
      return q.cursor(e, n);
    if (r == 2)
      return N7(t.state, e, n);
    {
      let i = t.docView.lineAt(e, n), o = t.state.doc.lineAt(i ? i.posAtEnd : e), s = i ? i.posAtStart : o.from, a = i ? i.posAtEnd : o.to;
      return a < t.state.doc.length && a == o.to && a++, q.range(s, a);
    }
  }
  const sU = de.ie && de.ie_version <= 11;
  let WC = null, HC = 0, jC = 0;
  function lL(t) {
    if (!sU)
      return t.detail;
    let e = WC, n = jC;
    return WC = t, jC = Date.now(), HC = !e || n > Date.now() - 400 && Math.abs(e.clientX - t.clientX) < 2 && Math.abs(e.clientY - t.clientY) < 2 ? (HC + 1) % 3 : 1;
  }
  function aU(t, e) {
    let n = t.posAndSideAtCoords({
      x: e.clientX,
      y: e.clientY
    }, false), r = lL(e), i = t.state.selection;
    return {
      update(o) {
        o.docChanged && (n.pos = o.changes.mapPos(n.pos), i = i.map(o.changes));
      },
      get(o, s, a) {
        let l = t.posAndSideAtCoords({
          x: o.clientX,
          y: o.clientY
        }, false), c, u = VC(t, l.pos, l.assoc, r);
        if (n.pos != l.pos && !s) {
          let h = VC(t, n.pos, n.assoc, r), p = Math.min(h.from, u.from), v = Math.max(h.to, u.to);
          u = p < u.from ? q.range(p, v) : q.range(v, p);
        }
        return s ? i.replaceRange(i.main.extend(u.from, u.to)) : a && r == 1 && i.ranges.length > 1 && (c = lU(i, l.pos)) ? c : a ? i.addRange(u) : q.create([
          u
        ]);
      }
    };
  }
  function lU(t, e) {
    for (let n = 0; n < t.ranges.length; n++) {
      let { from: r, to: i } = t.ranges[n];
      if (r <= e && i >= e)
        return q.create(t.ranges.slice(0, n).concat(t.ranges.slice(n + 1)), t.mainIndex == n ? 0 : t.mainIndex - (t.mainIndex > n ? 1 : 0));
    }
    return null;
  }
  qr.dragstart = (t, e) => {
    let { selection: { main: n } } = t.state;
    if (e.target.draggable) {
      let i = t.docView.tile.nearest(e.target);
      if (i && i.isWidget()) {
        let o = i.posAtStart, s = o + i.length;
        (o >= n.to || s <= n.from) && (n = q.range(o, s));
      }
    }
    let { inputState: r } = t;
    return r.mouseSelection && (r.mouseSelection.dragging = true), r.draggedContent = n, e.dataTransfer && (e.dataTransfer.setData("Text", Wm(t.state, Ix, t.state.sliceDoc(n.from, n.to))), e.dataTransfer.effectAllowed = "copyMove"), false;
  };
  qr.dragend = (t) => (t.inputState.draggedContent = null, false);
  function UC(t, e, n, r) {
    if (n = Wm(t.state, Dx, n), !n)
      return;
    let i = t.posAtCoords({
      x: e.clientX,
      y: e.clientY
    }, false), { draggedContent: o } = t.inputState, s = r && o && nU(t, e) ? {
      from: o.from,
      to: o.to
    } : null, a = {
      from: i,
      insert: n
    }, l = t.state.changes(s ? [
      s,
      a
    ] : a);
    t.focus(), t.dispatch({
      changes: l,
      selection: {
        anchor: l.mapPos(i, -1),
        head: l.mapPos(i, 1)
      },
      userEvent: s ? "move.drop" : "input.drop"
    }), t.inputState.draggedContent = null;
  }
  qr.drop = (t, e) => {
    if (!e.dataTransfer)
      return false;
    if (t.state.readOnly)
      return true;
    let n = e.dataTransfer.files;
    if (n && n.length) {
      let r = Array(n.length), i = 0, o = () => {
        ++i == n.length && UC(t, e, r.filter((s) => s != null).join(t.state.lineBreak), false);
      };
      for (let s = 0; s < n.length; s++) {
        let a = new FileReader();
        a.onerror = o, a.onload = () => {
          /[\x00-\x08\x0e-\x1f]{2}/.test(a.result) || (r[s] = a.result), o();
        }, a.readAsText(n[s]);
      }
      return true;
    } else {
      let r = e.dataTransfer.getData("Text");
      if (r)
        return UC(t, e, r, true), true;
    }
    return false;
  };
  qr.paste = (t, e) => {
    if (t.state.readOnly)
      return true;
    t.observer.flush();
    let n = sL ? null : e.clipboardData;
    return n ? (aL(t, n.getData("text/plain") || n.getData("text/uri-list")), true) : (oU(t), false);
  };
  function cU(t, e) {
    let n = t.dom.parentNode;
    if (!n)
      return;
    let r = n.appendChild(document.createElement("textarea"));
    r.style.cssText = "position: fixed; left: -10000px; top: 10px", r.value = e, r.focus(), r.selectionEnd = e.length, r.selectionStart = 0, setTimeout(() => {
      r.remove(), t.focus();
    }, 50);
  }
  function uU(t) {
    let e = [], n = [], r = false;
    for (let i of t.selection.ranges)
      i.empty || (e.push(t.sliceDoc(i.from, i.to)), n.push(i));
    if (!e.length) {
      let i = -1;
      for (let { from: o } of t.selection.ranges) {
        let s = t.doc.lineAt(o);
        s.number > i && (e.push(s.text), n.push({
          from: s.from,
          to: Math.min(t.doc.length, s.to + 1)
        })), i = s.number;
      }
      r = true;
    }
    return {
      text: Wm(t, Ix, e.join(t.lineBreak)),
      ranges: n,
      linewise: r
    };
  }
  let f1 = null;
  qr.copy = qr.cut = (t, e) => {
    if (!Yc(t.contentDOM, t.observer.selectionRange))
      return false;
    let { text: n, ranges: r, linewise: i } = uU(t.state);
    if (!n && !i)
      return false;
    f1 = i ? n : null, e.type == "cut" && !t.state.readOnly && t.dispatch({
      changes: r,
      scrollIntoView: true,
      userEvent: "delete.cut"
    });
    let o = sL ? null : e.clipboardData;
    return o ? (o.clearData(), o.setData("text/plain", n), true) : (cU(t, n), false);
  };
  const cL = Pi.define();
  function uL(t, e) {
    let n = [];
    for (let r of t.facet(HO)) {
      let i = r(t, e);
      i && n.push(i);
    }
    return n.length ? t.update({
      effects: n,
      annotations: cL.of(true)
    }) : null;
  }
  function fL(t) {
    setTimeout(() => {
      let e = t.hasFocus;
      if (e != t.inputState.notifiedFocused) {
        let n = uL(t.state, e);
        n ? t.dispatch(n) : t.update([]);
      }
    }, 10);
  }
  kr.focus = (t) => {
    t.inputState.lastFocusTime = Date.now(), !t.scrollDOM.scrollTop && (t.inputState.lastScrollTop || t.inputState.lastScrollLeft) && (t.scrollDOM.scrollTop = t.inputState.lastScrollTop, t.scrollDOM.scrollLeft = t.inputState.lastScrollLeft), fL(t);
  };
  kr.blur = (t) => {
    t.observer.clearSelectionRange(), fL(t);
  };
  kr.compositionstart = kr.compositionupdate = (t) => {
    t.observer.editContext || (t.inputState.compositionFirstChange == null && (t.inputState.compositionFirstChange = true), t.inputState.composing < 0 && (t.inputState.composing = 0));
  };
  kr.compositionend = (t) => {
    t.observer.editContext || (t.inputState.composing = -1, t.inputState.compositionEndedAt = Date.now(), t.inputState.compositionPendingKey = true, t.inputState.compositionPendingChange = t.observer.pendingRecords().length > 0, t.inputState.compositionFirstChange = null, de.chrome && de.android ? t.observer.flushSoon() : t.inputState.compositionPendingChange ? Promise.resolve().then(() => t.observer.flush()) : setTimeout(() => {
      t.inputState.composing < 0 && t.docView.hasComposition && t.update([]);
    }, 50));
  };
  kr.contextmenu = (t) => {
    t.inputState.lastContextMenu = Date.now();
  };
  qr.beforeinput = (t, e) => {
    var n, r;
    if ((e.inputType == "insertText" || e.inputType == "insertCompositionText") && (t.inputState.insertingText = e.data, t.inputState.insertingTextAt = Date.now()), e.inputType == "insertReplacementText" && t.observer.editContext) {
      let o = (n = e.dataTransfer) === null || n === void 0 ? void 0 : n.getData("text/plain"), s = e.getTargetRanges();
      if (o && s.length) {
        let a = s[0], l = t.posAtDOM(a.startContainer, a.startOffset), c = t.posAtDOM(a.endContainer, a.endOffset);
        return zx(t, {
          from: l,
          to: c,
          insert: t.state.toText(o)
        }, null), true;
      }
    }
    let i;
    if (de.chrome && de.android && (i = iL.find((o) => o.inputType == e.inputType)) && (t.observer.delayAndroidKey(i.key, i.keyCode), i.key == "Backspace" || i.key == "Delete")) {
      let o = ((r = window.visualViewport) === null || r === void 0 ? void 0 : r.height) || 0;
      setTimeout(() => {
        var s;
        (((s = window.visualViewport) === null || s === void 0 ? void 0 : s.height) || 0) > o + 10 && t.hasFocus && (t.contentDOM.blur(), t.focus());
      }, 100);
    }
    return de.ios && e.inputType == "deleteContentForward" && t.observer.flushSoon(), de.safari && e.inputType == "insertText" && t.inputState.composing >= 0 && setTimeout(() => kr.compositionend(t, e), 20), false;
  };
  const KC = /* @__PURE__ */ new Set();
  function fU(t) {
    KC.has(t) || (KC.add(t), t.addEventListener("copy", () => {
    }), t.addEventListener("cut", () => {
    }));
  }
  const qC = [
    "pre-wrap",
    "normal",
    "pre-line",
    "break-spaces"
  ];
  let vl = false;
  function GC() {
    vl = false;
  }
  class hU {
    constructor(e) {
      this.lineWrapping = e, this.doc = He.empty, this.heightSamples = {}, this.lineHeight = 14, this.charWidth = 7, this.textHeight = 14, this.lineLength = 30;
    }
    heightForGap(e, n) {
      let r = this.doc.lineAt(n).number - this.doc.lineAt(e).number + 1;
      return this.lineWrapping && (r += Math.max(0, Math.ceil((n - e - r * this.lineLength * 0.5) / this.lineLength))), this.lineHeight * r;
    }
    heightForLine(e) {
      return this.lineWrapping ? (1 + Math.max(0, Math.ceil((e - this.lineLength) / Math.max(1, this.lineLength - 5)))) * this.lineHeight : this.lineHeight;
    }
    setDoc(e) {
      return this.doc = e, this;
    }
    mustRefreshForWrapping(e) {
      return qC.indexOf(e) > -1 != this.lineWrapping;
    }
    mustRefreshForHeights(e) {
      let n = false;
      for (let r = 0; r < e.length; r++) {
        let i = e[r];
        i < 0 ? r++ : this.heightSamples[Math.floor(i * 10)] || (n = true, this.heightSamples[Math.floor(i * 10)] = true);
      }
      return n;
    }
    refresh(e, n, r, i, o, s) {
      let a = qC.indexOf(e) > -1, l = Math.abs(n - this.lineHeight) > 0.3 || this.lineWrapping != a || Math.abs(r - this.charWidth) > 0.1;
      if (this.lineWrapping = a, this.lineHeight = n, this.charWidth = r, this.textHeight = i, this.lineLength = o, l) {
        this.heightSamples = {};
        for (let c = 0; c < s.length; c++) {
          let u = s[c];
          u < 0 ? c++ : this.heightSamples[Math.floor(u * 10)] = true;
        }
      }
      return l;
    }
  }
  class dU {
    constructor(e, n) {
      this.from = e, this.heights = n, this.index = 0;
    }
    get more() {
      return this.index < this.heights.length;
    }
  }
  class $r {
    constructor(e, n, r, i, o) {
      this.from = e, this.length = n, this.top = r, this.height = i, this._content = o;
    }
    get type() {
      return typeof this._content == "number" ? nn.Text : Array.isArray(this._content) ? this._content : this._content.type;
    }
    get to() {
      return this.from + this.length;
    }
    get bottom() {
      return this.top + this.height;
    }
    get widget() {
      return this._content instanceof Us ? this._content.widget : null;
    }
    get widgetLineBreaks() {
      return typeof this._content == "number" ? this._content : 0;
    }
    join(e) {
      let n = (Array.isArray(this._content) ? this._content : [
        this
      ]).concat(Array.isArray(e._content) ? e._content : [
        e
      ]);
      return new $r(this.from, this.length + e.length, this.top, this.height + e.height, n);
    }
  }
  var tt = function(t) {
    return t[t.ByPos = 0] = "ByPos", t[t.ByHeight = 1] = "ByHeight", t[t.ByPosNoHeight = 2] = "ByPosNoHeight", t;
  }(tt || (tt = {}));
  const Sd = 1e-3;
  class kn {
    constructor(e, n, r = 2) {
      this.length = e, this.height = n, this.flags = r;
    }
    get outdated() {
      return (this.flags & 2) > 0;
    }
    set outdated(e) {
      this.flags = (e ? 2 : 0) | this.flags & -3;
    }
    setHeight(e) {
      this.height != e && (Math.abs(this.height - e) > Sd && (vl = true), this.height = e);
    }
    replace(e, n, r) {
      return kn.of(r);
    }
    decomposeLeft(e, n) {
      n.push(this);
    }
    decomposeRight(e, n) {
      n.push(this);
    }
    applyChanges(e, n, r, i) {
      let o = this, s = r.doc;
      for (let a = i.length - 1; a >= 0; a--) {
        let { fromA: l, toA: c, fromB: u, toB: h } = i[a], p = o.lineAt(l, tt.ByPosNoHeight, r.setDoc(n), 0, 0), v = p.to >= c ? p : o.lineAt(c, tt.ByPosNoHeight, r, 0, 0);
        for (h += v.to - c, c = v.to; a > 0 && p.from <= i[a - 1].toA; )
          l = i[a - 1].fromA, u = i[a - 1].fromB, a--, l < p.from && (p = o.lineAt(l, tt.ByPosNoHeight, r, 0, 0));
        u += p.from - l, l = p.from;
        let y = Fx.build(r.setDoc(s), e, u, h);
        o = Cp(o, o.replace(l, c, y));
      }
      return o.updateHeight(r, 0);
    }
    static empty() {
      return new jn(0, 0, 0);
    }
    static of(e) {
      if (e.length == 1)
        return e[0];
      let n = 0, r = e.length, i = 0, o = 0;
      for (; ; )
        if (n == r)
          if (i > o * 2) {
            let a = e[n - 1];
            a.break ? e.splice(--n, 1, a.left, null, a.right) : e.splice(--n, 1, a.left, a.right), r += 1 + a.break, i -= a.size;
          } else if (o > i * 2) {
            let a = e[r];
            a.break ? e.splice(r, 1, a.left, null, a.right) : e.splice(r, 1, a.left, a.right), r += 2 + a.break, o -= a.size;
          } else
            break;
        else if (i < o) {
          let a = e[n++];
          a && (i += a.size);
        } else {
          let a = e[--r];
          a && (o += a.size);
        }
      let s = 0;
      return e[n - 1] == null ? (s = 1, n--) : e[n] == null && (s = 1, r++), new mU(kn.of(e.slice(0, n)), s, kn.of(e.slice(r)));
    }
  }
  function Cp(t, e) {
    return t == e ? t : (t.constructor != e.constructor && (vl = true), e);
  }
  kn.prototype.size = 1;
  const pU = be.replace({});
  class hL extends kn {
    constructor(e, n, r) {
      super(e, n), this.deco = r, this.spaceAbove = 0;
    }
    mainBlock(e, n) {
      return new $r(n, this.length, e + this.spaceAbove, this.height - this.spaceAbove, this.deco || 0);
    }
    blockAt(e, n, r, i) {
      return this.spaceAbove && e < r + this.spaceAbove ? new $r(i, 0, r, this.spaceAbove, pU) : this.mainBlock(r, i);
    }
    lineAt(e, n, r, i, o) {
      let s = this.mainBlock(i, o);
      return this.spaceAbove ? this.blockAt(0, r, i, o).join(s) : s;
    }
    forEachLine(e, n, r, i, o, s) {
      e <= o + this.length && n >= o && s(this.lineAt(0, tt.ByPos, r, i, o));
    }
    setMeasuredHeight(e) {
      let n = e.heights[e.index++];
      n < 0 ? (this.spaceAbove = -n, n = e.heights[e.index++]) : this.spaceAbove = 0, this.setHeight(n);
    }
    updateHeight(e, n = 0, r = false, i) {
      return i && i.from <= n && i.more && this.setMeasuredHeight(i), this.outdated = false, this;
    }
    toString() {
      return `block(${this.length})`;
    }
  }
  class jn extends hL {
    constructor(e, n, r) {
      super(e, n, null), this.collapsed = 0, this.widgetHeight = 0, this.breaks = 0, this.spaceAbove = r;
    }
    mainBlock(e, n) {
      return new $r(n, this.length, e + this.spaceAbove, this.height - this.spaceAbove, this.breaks);
    }
    replace(e, n, r) {
      let i = r[0];
      return r.length == 1 && (i instanceof jn || i instanceof Xt && i.flags & 4) && Math.abs(this.length - i.length) < 10 ? (i instanceof Xt ? i = new jn(i.length, this.height, this.spaceAbove) : i.height = this.height, this.outdated || (i.outdated = false), i) : kn.of(r);
    }
    updateHeight(e, n = 0, r = false, i) {
      return i && i.from <= n && i.more ? this.setMeasuredHeight(i) : (r || this.outdated) && (this.spaceAbove = 0, this.setHeight(Math.max(this.widgetHeight, e.heightForLine(this.length - this.collapsed)) + this.breaks * e.lineHeight)), this.outdated = false, this;
    }
    toString() {
      return `line(${this.length}${this.collapsed ? -this.collapsed : ""}${this.widgetHeight ? ":" + this.widgetHeight : ""})`;
    }
  }
  class Xt extends kn {
    constructor(e) {
      super(e, 0);
    }
    heightMetrics(e, n) {
      let r = e.doc.lineAt(n).number, i = e.doc.lineAt(n + this.length).number, o = i - r + 1, s, a = 0;
      if (e.lineWrapping) {
        let l = Math.min(this.height, e.lineHeight * o);
        s = l / o, this.length > o + 1 && (a = (this.height - l) / (this.length - o - 1));
      } else
        s = this.height / o;
      return {
        firstLine: r,
        lastLine: i,
        perLine: s,
        perChar: a
      };
    }
    blockAt(e, n, r, i) {
      let { firstLine: o, lastLine: s, perLine: a, perChar: l } = this.heightMetrics(n, i);
      if (n.lineWrapping) {
        let c = i + (e < n.lineHeight ? 0 : Math.round(Math.max(0, Math.min(1, (e - r) / this.height)) * this.length)), u = n.doc.lineAt(c), h = a + u.length * l, p = Math.max(r, e - h / 2);
        return new $r(u.from, u.length, p, h, 0);
      } else {
        let c = Math.max(0, Math.min(s - o, Math.floor((e - r) / a))), { from: u, length: h } = n.doc.line(o + c);
        return new $r(u, h, r + a * c, a, 0);
      }
    }
    lineAt(e, n, r, i, o) {
      if (n == tt.ByHeight)
        return this.blockAt(e, r, i, o);
      if (n == tt.ByPosNoHeight) {
        let { from: v, to: y } = r.doc.lineAt(e);
        return new $r(v, y - v, 0, 0, 0);
      }
      let { firstLine: s, perLine: a, perChar: l } = this.heightMetrics(r, o), c = r.doc.lineAt(e), u = a + c.length * l, h = c.number - s, p = i + a * h + l * (c.from - o - h);
      return new $r(c.from, c.length, Math.max(i, Math.min(p, i + this.height - u)), u, 0);
    }
    forEachLine(e, n, r, i, o, s) {
      e = Math.max(e, o), n = Math.min(n, o + this.length);
      let { firstLine: a, perLine: l, perChar: c } = this.heightMetrics(r, o);
      for (let u = e, h = i; u <= n; ) {
        let p = r.doc.lineAt(u);
        if (u == e) {
          let y = p.number - a;
          h += l * y + c * (e - o - y);
        }
        let v = l + c * p.length;
        s(new $r(p.from, p.length, h, v, 0)), h += v, u = p.to + 1;
      }
    }
    replace(e, n, r) {
      let i = this.length - n;
      if (i > 0) {
        let o = r[r.length - 1];
        o instanceof Xt ? r[r.length - 1] = new Xt(o.length + i) : r.push(null, new Xt(i - 1));
      }
      if (e > 0) {
        let o = r[0];
        o instanceof Xt ? r[0] = new Xt(e + o.length) : r.unshift(new Xt(e - 1), null);
      }
      return kn.of(r);
    }
    decomposeLeft(e, n) {
      n.push(new Xt(e - 1), null);
    }
    decomposeRight(e, n) {
      n.push(null, new Xt(this.length - e - 1));
    }
    updateHeight(e, n = 0, r = false, i) {
      let o = n + this.length;
      if (i && i.from <= n + this.length && i.more) {
        let s = [], a = Math.max(n, i.from), l = -1;
        for (i.from > n && s.push(new Xt(i.from - n - 1).updateHeight(e, n)); a <= o && i.more; ) {
          let u = e.doc.lineAt(a).length;
          s.length && s.push(null);
          let h = i.heights[i.index++], p = 0;
          h < 0 && (p = -h, h = i.heights[i.index++]), l == -1 ? l = h : Math.abs(h - l) >= Sd && (l = -2);
          let v = new jn(u, h, p);
          v.outdated = false, s.push(v), a += u + 1;
        }
        a <= o && s.push(null, new Xt(o - a).updateHeight(e, a));
        let c = kn.of(s);
        return (l < 0 || Math.abs(c.height - this.height) >= Sd || Math.abs(l - this.heightMetrics(e, n).perLine) >= Sd) && (vl = true), Cp(this, c);
      } else
        (r || this.outdated) && (this.setHeight(e.heightForGap(n, n + this.length)), this.outdated = false);
      return this;
    }
    toString() {
      return `gap(${this.length})`;
    }
  }
  class mU extends kn {
    constructor(e, n, r) {
      super(e.length + n + r.length, e.height + r.height, n | (e.outdated || r.outdated ? 2 : 0)), this.left = e, this.right = r, this.size = e.size + r.size;
    }
    get break() {
      return this.flags & 1;
    }
    blockAt(e, n, r, i) {
      let o = r + this.left.height;
      return e < o ? this.left.blockAt(e, n, r, i) : this.right.blockAt(e, n, o, i + this.left.length + this.break);
    }
    lineAt(e, n, r, i, o) {
      let s = i + this.left.height, a = o + this.left.length + this.break, l = n == tt.ByHeight ? e < s : e < a, c = l ? this.left.lineAt(e, n, r, i, o) : this.right.lineAt(e, n, r, s, a);
      if (this.break || (l ? c.to < a : c.from > a))
        return c;
      let u = n == tt.ByPosNoHeight ? tt.ByPosNoHeight : tt.ByPos;
      return l ? c.join(this.right.lineAt(a, u, r, s, a)) : this.left.lineAt(a, u, r, i, o).join(c);
    }
    forEachLine(e, n, r, i, o, s) {
      let a = i + this.left.height, l = o + this.left.length + this.break;
      if (this.break)
        e < l && this.left.forEachLine(e, n, r, i, o, s), n >= l && this.right.forEachLine(e, n, r, a, l, s);
      else {
        let c = this.lineAt(l, tt.ByPos, r, i, o);
        e < c.from && this.left.forEachLine(e, c.from - 1, r, i, o, s), c.to >= e && c.from <= n && s(c), n > c.to && this.right.forEachLine(c.to + 1, n, r, a, l, s);
      }
    }
    replace(e, n, r) {
      let i = this.left.length + this.break;
      if (n < i)
        return this.balanced(this.left.replace(e, n, r), this.right);
      if (e > this.left.length)
        return this.balanced(this.left, this.right.replace(e - i, n - i, r));
      let o = [];
      e > 0 && this.decomposeLeft(e, o);
      let s = o.length;
      for (let a of r)
        o.push(a);
      if (e > 0 && YC(o, s - 1), n < this.length) {
        let a = o.length;
        this.decomposeRight(n, o), YC(o, a);
      }
      return kn.of(o);
    }
    decomposeLeft(e, n) {
      let r = this.left.length;
      if (e <= r)
        return this.left.decomposeLeft(e, n);
      n.push(this.left), this.break && (r++, e >= r && n.push(null)), e > r && this.right.decomposeLeft(e - r, n);
    }
    decomposeRight(e, n) {
      let r = this.left.length, i = r + this.break;
      if (e >= i)
        return this.right.decomposeRight(e - i, n);
      e < r && this.left.decomposeRight(e, n), this.break && e < i && n.push(null), n.push(this.right);
    }
    balanced(e, n) {
      return e.size > 2 * n.size || n.size > 2 * e.size ? kn.of(this.break ? [
        e,
        null,
        n
      ] : [
        e,
        n
      ]) : (this.left = Cp(this.left, e), this.right = Cp(this.right, n), this.setHeight(e.height + n.height), this.outdated = e.outdated || n.outdated, this.size = e.size + n.size, this.length = e.length + this.break + n.length, this);
    }
    updateHeight(e, n = 0, r = false, i) {
      let { left: o, right: s } = this, a = n + o.length + this.break, l = null;
      return i && i.from <= n + o.length && i.more ? l = o = o.updateHeight(e, n, r, i) : o.updateHeight(e, n, r), i && i.from <= a + s.length && i.more ? l = s = s.updateHeight(e, a, r, i) : s.updateHeight(e, a, r), l ? this.balanced(o, s) : (this.height = this.left.height + this.right.height, this.outdated = false, this);
    }
    toString() {
      return this.left + (this.break ? " " : "-") + this.right;
    }
  }
  function YC(t, e) {
    let n, r;
    t[e] == null && (n = t[e - 1]) instanceof Xt && (r = t[e + 1]) instanceof Xt && t.splice(e - 1, 3, new Xt(n.length + 1 + r.length));
  }
  const gU = 5;
  class Fx {
    constructor(e, n) {
      this.pos = e, this.oracle = n, this.nodes = [], this.lineStart = -1, this.lineEnd = -1, this.covering = null, this.writtenTo = e;
    }
    get isCovered() {
      return this.covering && this.nodes[this.nodes.length - 1] == this.covering;
    }
    span(e, n) {
      if (this.lineStart > -1) {
        let r = Math.min(n, this.lineEnd), i = this.nodes[this.nodes.length - 1];
        i instanceof jn ? i.length += r - this.pos : (r > this.pos || !this.isCovered) && this.nodes.push(new jn(r - this.pos, -1, 0)), this.writtenTo = r, n > r && (this.nodes.push(null), this.writtenTo++, this.lineStart = -1);
      }
      this.pos = n;
    }
    point(e, n, r) {
      if (e < n || r.heightRelevant) {
        let i = r.widget ? r.widget.estimatedHeight : 0, o = r.widget ? r.widget.lineBreaks : 0;
        i < 0 && (i = this.oracle.lineHeight);
        let s = n - e;
        r.block ? this.addBlock(new hL(s, i, r)) : (s || o || i >= gU) && this.addLineDeco(i, o, s);
      } else
        n > e && this.span(e, n);
      this.lineEnd > -1 && this.lineEnd < this.pos && (this.lineEnd = this.oracle.doc.lineAt(this.pos).to);
    }
    enterLine() {
      if (this.lineStart > -1)
        return;
      let { from: e, to: n } = this.oracle.doc.lineAt(this.pos);
      this.lineStart = e, this.lineEnd = n, this.writtenTo < e && ((this.writtenTo < e - 1 || this.nodes[this.nodes.length - 1] == null) && this.nodes.push(this.blankContent(this.writtenTo, e - 1)), this.nodes.push(null)), this.pos > e && this.nodes.push(new jn(this.pos - e, -1, 0)), this.writtenTo = this.pos;
    }
    blankContent(e, n) {
      let r = new Xt(n - e);
      return this.oracle.doc.lineAt(e).to == n && (r.flags |= 4), r;
    }
    ensureLine() {
      this.enterLine();
      let e = this.nodes.length ? this.nodes[this.nodes.length - 1] : null;
      if (e instanceof jn)
        return e;
      let n = new jn(0, -1, 0);
      return this.nodes.push(n), n;
    }
    addBlock(e) {
      this.enterLine();
      let n = e.deco;
      n && n.startSide > 0 && !this.isCovered && this.ensureLine(), this.nodes.push(e), this.writtenTo = this.pos = this.pos + e.length, n && n.endSide > 0 && (this.covering = e);
    }
    addLineDeco(e, n, r) {
      let i = this.ensureLine();
      i.length += r, i.collapsed += r, i.widgetHeight = Math.max(i.widgetHeight, e), i.breaks += n, this.writtenTo = this.pos = this.pos + r;
    }
    finish(e) {
      let n = this.nodes.length == 0 ? null : this.nodes[this.nodes.length - 1];
      this.lineStart > -1 && !(n instanceof jn) && !this.isCovered ? this.nodes.push(new jn(0, -1, 0)) : (this.writtenTo < this.pos || n == null) && this.nodes.push(this.blankContent(this.writtenTo, this.pos));
      let r = e;
      for (let i of this.nodes)
        i instanceof jn && i.updateHeight(this.oracle, r), r += i ? i.length : 1;
      return this.nodes;
    }
    static build(e, n, r, i) {
      let o = new Fx(r, e);
      return _e.spans(n, r, i, o, 0), o.finish(r);
    }
  }
  function vU(t, e, n) {
    let r = new yU();
    return _e.compare(t, e, n, r, 0), r.changes;
  }
  class yU {
    constructor() {
      this.changes = [];
    }
    compareRange() {
    }
    comparePoint(e, n, r, i) {
      (e < n || r && r.heightRelevant || i && i.heightRelevant) && Xa(e, n, this.changes, 5);
    }
  }
  function bU(t, e) {
    let n = t.getBoundingClientRect(), r = t.ownerDocument, i = r.defaultView || window, o = Math.max(0, n.left), s = Math.min(i.innerWidth, n.right), a = Math.max(0, n.top), l = Math.min(i.innerHeight, n.bottom);
    for (let c = t.parentNode; c && c != r.body; )
      if (c.nodeType == 1) {
        let u = c, h = window.getComputedStyle(u);
        if ((u.scrollHeight > u.clientHeight || u.scrollWidth > u.clientWidth) && h.overflow != "visible") {
          let p = u.getBoundingClientRect();
          o = Math.max(o, p.left), s = Math.min(s, p.right), a = Math.max(a, p.top), l = Math.min(c == t.parentNode ? i.innerHeight : l, p.bottom);
        }
        c = h.position == "absolute" || h.position == "fixed" ? u.offsetParent : u.parentNode;
      } else if (c.nodeType == 11)
        c = c.host;
      else
        break;
    return {
      left: o - n.left,
      right: Math.max(o, s) - n.left,
      top: a - (n.top + e),
      bottom: Math.max(a, l) - (n.top + e)
    };
  }
  function xU(t) {
    let e = t.getBoundingClientRect(), n = t.ownerDocument.defaultView || window;
    return e.left < n.innerWidth && e.right > 0 && e.top < n.innerHeight && e.bottom > 0;
  }
  function SU(t, e) {
    let n = t.getBoundingClientRect();
    return {
      left: 0,
      right: n.right - n.left,
      top: e,
      bottom: n.bottom - (n.top + e)
    };
  }
  class F0 {
    constructor(e, n, r, i) {
      this.from = e, this.to = n, this.size = r, this.displaySize = i;
    }
    static same(e, n) {
      if (e.length != n.length)
        return false;
      for (let r = 0; r < e.length; r++) {
        let i = e[r], o = n[r];
        if (i.from != o.from || i.to != o.to || i.size != o.size)
          return false;
      }
      return true;
    }
    draw(e, n) {
      return be.replace({
        widget: new wU(this.displaySize * (n ? e.scaleY : e.scaleX), n)
      }).range(this.from, this.to);
    }
  }
  class wU extends Li {
    constructor(e, n) {
      super(), this.size = e, this.vertical = n;
    }
    eq(e) {
      return e.size == this.size && e.vertical == this.vertical;
    }
    toDOM() {
      let e = document.createElement("div");
      return this.vertical ? e.style.height = this.size + "px" : (e.style.width = this.size + "px", e.style.height = "2px", e.style.display = "inline-block"), e;
    }
    get estimatedHeight() {
      return this.vertical ? this.size : -1;
    }
  }
  class XC {
    constructor(e) {
      this.state = e, this.pixelViewport = {
        left: 0,
        right: window.innerWidth,
        top: 0,
        bottom: 0
      }, this.inView = true, this.paddingTop = 0, this.paddingBottom = 0, this.contentDOMWidth = 0, this.contentDOMHeight = 0, this.editorHeight = 0, this.editorWidth = 0, this.scrollTop = 0, this.scrolledToBottom = false, this.scaleX = 1, this.scaleY = 1, this.scrollAnchorPos = 0, this.scrollAnchorHeight = -1, this.scaler = QC, this.scrollTarget = null, this.printing = false, this.mustMeasureContent = true, this.defaultTextDirection = Je.LTR, this.visibleRanges = [], this.mustEnforceCursorAssoc = false;
      let n = e.facet(Bx).some((r) => typeof r != "function" && r.class == "cm-lineWrapping");
      this.heightOracle = new hU(n), this.stateDeco = JC(e), this.heightMap = kn.empty().applyChanges(this.stateDeco, He.empty, this.heightOracle.setDoc(e.doc), [
        new pr(0, 0, 0, e.doc.length)
      ]);
      for (let r = 0; r < 2 && (this.viewport = this.getViewport(0, null), !!this.updateForViewport()); r++)
        ;
      this.updateViewportLines(), this.lineGaps = this.ensureLineGaps([]), this.lineGapDeco = be.set(this.lineGaps.map((r) => r.draw(this, false))), this.computeVisibleRanges();
    }
    updateForViewport() {
      let e = [
        this.viewport
      ], { main: n } = this.state.selection;
      for (let r = 0; r <= 1; r++) {
        let i = r ? n.head : n.anchor;
        if (!e.some(({ from: o, to: s }) => i >= o && i <= s)) {
          let { from: o, to: s } = this.lineBlockAt(i);
          e.push(new Mh(o, s));
        }
      }
      return this.viewports = e.sort((r, i) => r.from - i.from), this.updateScaler();
    }
    updateScaler() {
      let e = this.scaler;
      return this.scaler = this.heightMap.height <= 7e6 ? QC : new Vx(this.heightOracle, this.heightMap, this.viewports), e.eq(this.scaler) ? 0 : 2;
    }
    updateViewportLines() {
      this.viewportLines = [], this.heightMap.forEachLine(this.viewport.from, this.viewport.to, this.heightOracle.setDoc(this.state.doc), 0, 0, (e) => {
        this.viewportLines.push(xc(e, this.scaler));
      });
    }
    update(e, n = null) {
      this.state = e.state;
      let r = this.stateDeco;
      this.stateDeco = JC(this.state);
      let i = e.changedRanges, o = pr.extendWithRanges(i, vU(r, this.stateDeco, e ? e.changes : Dt.empty(this.state.doc.length))), s = this.heightMap.height, a = this.scrolledToBottom ? null : this.scrollAnchorAt(this.scrollTop);
      GC(), this.heightMap = this.heightMap.applyChanges(this.stateDeco, e.startState.doc, this.heightOracle.setDoc(this.state.doc), o), (this.heightMap.height != s || vl) && (e.flags |= 2), a ? (this.scrollAnchorPos = e.changes.mapPos(a.from, -1), this.scrollAnchorHeight = a.top) : (this.scrollAnchorPos = -1, this.scrollAnchorHeight = s);
      let l = o.length ? this.mapViewport(this.viewport, e.changes) : this.viewport;
      (n && (n.range.head < l.from || n.range.head > l.to) || !this.viewportIsAppropriate(l)) && (l = this.getViewport(0, n));
      let c = l.from != this.viewport.from || l.to != this.viewport.to;
      this.viewport = l, e.flags |= this.updateForViewport(), (c || !e.changes.empty || e.flags & 2) && this.updateViewportLines(), (this.lineGaps.length || this.viewport.to - this.viewport.from > 2e3 << 1) && this.updateLineGaps(this.ensureLineGaps(this.mapLineGaps(this.lineGaps, e.changes))), e.flags |= this.computeVisibleRanges(e.changes), n && (this.scrollTarget = n), !this.mustEnforceCursorAssoc && (e.selectionSet || e.focusChanged) && e.view.lineWrapping && e.state.selection.main.empty && e.state.selection.main.assoc && !e.state.facet(UO) && (this.mustEnforceCursorAssoc = true);
    }
    measure(e) {
      let n = e.contentDOM, r = window.getComputedStyle(n), i = this.heightOracle, o = r.whiteSpace;
      this.defaultTextDirection = r.direction == "rtl" ? Je.RTL : Je.LTR;
      let s = this.heightOracle.mustRefreshForWrapping(o) || this.mustMeasureContent === "refresh", a = n.getBoundingClientRect(), l = s || this.mustMeasureContent || this.contentDOMHeight != a.height;
      this.contentDOMHeight = a.height, this.mustMeasureContent = false;
      let c = 0, u = 0;
      if (a.width && a.height) {
        let { scaleX: O, scaleY: L } = EO(n, a);
        (O > 5e-3 && Math.abs(this.scaleX - O) > 5e-3 || L > 5e-3 && Math.abs(this.scaleY - L) > 5e-3) && (this.scaleX = O, this.scaleY = L, c |= 16, s = l = true);
      }
      let h = (parseInt(r.paddingTop) || 0) * this.scaleY, p = (parseInt(r.paddingBottom) || 0) * this.scaleY;
      (this.paddingTop != h || this.paddingBottom != p) && (this.paddingTop = h, this.paddingBottom = p, c |= 18), this.editorWidth != e.scrollDOM.clientWidth && (i.lineWrapping && (l = true), this.editorWidth = e.scrollDOM.clientWidth, c |= 16);
      let v = e.scrollDOM.scrollTop * this.scaleY;
      this.scrollTop != v && (this.scrollAnchorHeight = -1, this.scrollTop = v), this.scrolledToBottom = OO(e.scrollDOM);
      let y = (this.printing ? SU : bU)(n, this.paddingTop), S = y.top - this.pixelViewport.top, T = y.bottom - this.pixelViewport.bottom;
      this.pixelViewport = y;
      let w = this.pixelViewport.bottom > this.pixelViewport.top && this.pixelViewport.right > this.pixelViewport.left;
      if (w != this.inView && (this.inView = w, w && (l = true)), !this.inView && !this.scrollTarget && !xU(e.dom))
        return 0;
      let k = a.width;
      if ((this.contentDOMWidth != k || this.editorHeight != e.scrollDOM.clientHeight) && (this.contentDOMWidth = a.width, this.editorHeight = e.scrollDOM.clientHeight, c |= 16), l) {
        let O = e.docView.measureVisibleLineHeights(this.viewport);
        if (i.mustRefreshForHeights(O) && (s = true), s || i.lineWrapping && Math.abs(k - this.contentDOMWidth) > i.charWidth) {
          let { lineHeight: L, charWidth: D, textHeight: R } = e.docView.measureTextSize();
          s = L > 0 && i.refresh(o, L, D, R, Math.max(5, k / D), O), s && (e.docView.minWidth = 0, c |= 16);
        }
        S > 0 && T > 0 ? u = Math.max(S, T) : S < 0 && T < 0 && (u = Math.min(S, T)), GC();
        for (let L of this.viewports) {
          let D = L.from == this.viewport.from ? O : e.docView.measureVisibleLineHeights(L);
          this.heightMap = (s ? kn.empty().applyChanges(this.stateDeco, He.empty, this.heightOracle, [
            new pr(0, 0, 0, e.state.doc.length)
          ]) : this.heightMap).updateHeight(i, 0, s, new dU(L.from, D));
        }
        vl && (c |= 2);
      }
      let C = !this.viewportIsAppropriate(this.viewport, u) || this.scrollTarget && (this.scrollTarget.range.head < this.viewport.from || this.scrollTarget.range.head > this.viewport.to);
      return C && (c & 2 && (c |= this.updateScaler()), this.viewport = this.getViewport(u, this.scrollTarget), c |= this.updateForViewport()), (c & 2 || C) && this.updateViewportLines(), (this.lineGaps.length || this.viewport.to - this.viewport.from > 2e3 << 1) && this.updateLineGaps(this.ensureLineGaps(s ? [] : this.lineGaps, e)), c |= this.computeVisibleRanges(), this.mustEnforceCursorAssoc && (this.mustEnforceCursorAssoc = false, e.docView.enforceCursorAssoc()), c;
    }
    get visibleTop() {
      return this.scaler.fromDOM(this.pixelViewport.top);
    }
    get visibleBottom() {
      return this.scaler.fromDOM(this.pixelViewport.bottom);
    }
    getViewport(e, n) {
      let r = 0.5 - Math.max(-0.5, Math.min(0.5, e / 1e3 / 2)), i = this.heightMap, o = this.heightOracle, { visibleTop: s, visibleBottom: a } = this, l = new Mh(i.lineAt(s - r * 1e3, tt.ByHeight, o, 0, 0).from, i.lineAt(a + (1 - r) * 1e3, tt.ByHeight, o, 0, 0).to);
      if (n) {
        let { head: c } = n.range;
        if (c < l.from || c > l.to) {
          let u = Math.min(this.editorHeight, this.pixelViewport.bottom - this.pixelViewport.top), h = i.lineAt(c, tt.ByPos, o, 0, 0), p;
          n.y == "center" ? p = (h.top + h.bottom) / 2 - u / 2 : n.y == "start" || n.y == "nearest" && c < l.from ? p = h.top : p = h.bottom - u, l = new Mh(i.lineAt(p - 1e3 / 2, tt.ByHeight, o, 0, 0).from, i.lineAt(p + u + 1e3 / 2, tt.ByHeight, o, 0, 0).to);
        }
      }
      return l;
    }
    mapViewport(e, n) {
      let r = n.mapPos(e.from, -1), i = n.mapPos(e.to, 1);
      return new Mh(this.heightMap.lineAt(r, tt.ByPos, this.heightOracle, 0, 0).from, this.heightMap.lineAt(i, tt.ByPos, this.heightOracle, 0, 0).to);
    }
    viewportIsAppropriate({ from: e, to: n }, r = 0) {
      if (!this.inView)
        return true;
      let { top: i } = this.heightMap.lineAt(e, tt.ByPos, this.heightOracle, 0, 0), { bottom: o } = this.heightMap.lineAt(n, tt.ByPos, this.heightOracle, 0, 0), { visibleTop: s, visibleBottom: a } = this;
      return (e == 0 || i <= s - Math.max(10, Math.min(-r, 250))) && (n == this.state.doc.length || o >= a + Math.max(10, Math.min(r, 250))) && i > s - 2 * 1e3 && o < a + 2 * 1e3;
    }
    mapLineGaps(e, n) {
      if (!e.length || n.empty)
        return e;
      let r = [];
      for (let i of e)
        n.touchesRange(i.from, i.to) || r.push(new F0(n.mapPos(i.from), n.mapPos(i.to), i.size, i.displaySize));
      return r;
    }
    ensureLineGaps(e, n) {
      let r = this.heightOracle.lineWrapping, i = r ? 1e4 : 2e3, o = i >> 1, s = i << 1;
      if (this.defaultTextDirection != Je.LTR && !r)
        return [];
      let a = [], l = (u, h, p, v) => {
        if (h - u < o)
          return;
        let y = this.state.selection.main, S = [
          y.from
        ];
        y.empty || S.push(y.to);
        for (let w of S)
          if (w > u && w < h) {
            l(u, w - 10, p, v), l(w + 10, h, p, v);
            return;
          }
        let T = CU(e, (w) => w.from >= p.from && w.to <= p.to && Math.abs(w.from - u) < o && Math.abs(w.to - h) < o && !S.some((k) => w.from < k && w.to > k));
        if (!T) {
          if (h < p.to && n && r && n.visibleRanges.some((C) => C.from <= h && C.to >= h)) {
            let C = n.moveToLineBoundary(q.cursor(h), false, true).head;
            C > u && (h = C);
          }
          let w = this.gapSize(p, u, h, v), k = r || w < 2e6 ? w : 2e6;
          T = new F0(u, h, w, k);
        }
        a.push(T);
      }, c = (u) => {
        if (u.length < s || u.type != nn.Text)
          return;
        let h = kU(u.from, u.to, this.stateDeco);
        if (h.total < s)
          return;
        let p = this.scrollTarget ? this.scrollTarget.range.head : null, v, y;
        if (r) {
          let S = i / this.heightOracle.lineLength * this.heightOracle.lineHeight, T, w;
          if (p != null) {
            let k = Eh(h, p), C = ((this.visibleBottom - this.visibleTop) / 2 + S) / u.height;
            T = k - C, w = k + C;
          } else
            T = (this.visibleTop - u.top - S) / u.height, w = (this.visibleBottom - u.top + S) / u.height;
          v = Ah(h, T), y = Ah(h, w);
        } else {
          let S = h.total * this.heightOracle.charWidth, T = i * this.heightOracle.charWidth, w = 0;
          if (S > 2e6)
            for (let D of e)
              D.from >= u.from && D.from < u.to && D.size != D.displaySize && D.from * this.heightOracle.charWidth + w < this.pixelViewport.left && (w = D.size - D.displaySize);
          let k = this.pixelViewport.left + w, C = this.pixelViewport.right + w, O, L;
          if (p != null) {
            let D = Eh(h, p), R = ((C - k) / 2 + T) / S;
            O = D - R, L = D + R;
          } else
            O = (k - T) / S, L = (C + T) / S;
          v = Ah(h, O), y = Ah(h, L);
        }
        v > u.from && l(u.from, v, u, h), y < u.to && l(y, u.to, u, h);
      };
      for (let u of this.viewportLines)
        Array.isArray(u.type) ? u.type.forEach(c) : c(u);
      return a;
    }
    gapSize(e, n, r, i) {
      let o = Eh(i, r) - Eh(i, n);
      return this.heightOracle.lineWrapping ? e.height * o : i.total * this.heightOracle.charWidth * o;
    }
    updateLineGaps(e) {
      F0.same(e, this.lineGaps) || (this.lineGaps = e, this.lineGapDeco = be.set(e.map((n) => n.draw(this, this.heightOracle.lineWrapping))));
    }
    computeVisibleRanges(e) {
      let n = this.stateDeco;
      this.lineGaps.length && (n = n.concat(this.lineGapDeco));
      let r = [];
      _e.spans(n, this.viewport.from, this.viewport.to, {
        span(o, s) {
          r.push({
            from: o,
            to: s
          });
        },
        point() {
        }
      }, 20);
      let i = 0;
      if (r.length != this.visibleRanges.length)
        i = 12;
      else
        for (let o = 0; o < r.length && !(i & 8); o++) {
          let s = this.visibleRanges[o], a = r[o];
          (s.from != a.from || s.to != a.to) && (i |= 4, e && e.mapPos(s.from, -1) == a.from && e.mapPos(s.to, 1) == a.to || (i |= 8));
        }
      return this.visibleRanges = r, i;
    }
    lineBlockAt(e) {
      return e >= this.viewport.from && e <= this.viewport.to && this.viewportLines.find((n) => n.from <= e && n.to >= e) || xc(this.heightMap.lineAt(e, tt.ByPos, this.heightOracle, 0, 0), this.scaler);
    }
    lineBlockAtHeight(e) {
      return e >= this.viewportLines[0].top && e <= this.viewportLines[this.viewportLines.length - 1].bottom && this.viewportLines.find((n) => n.top <= e && n.bottom >= e) || xc(this.heightMap.lineAt(this.scaler.fromDOM(e), tt.ByHeight, this.heightOracle, 0, 0), this.scaler);
    }
    scrollAnchorAt(e) {
      let n = this.lineBlockAtHeight(e + 8);
      return n.from >= this.viewport.from || this.viewportLines[0].top - e > 200 ? n : this.viewportLines[0];
    }
    elementAtHeight(e) {
      return xc(this.heightMap.blockAt(this.scaler.fromDOM(e), this.heightOracle, 0, 0), this.scaler);
    }
    get docHeight() {
      return this.scaler.toDOM(this.heightMap.height);
    }
    get contentHeight() {
      return this.docHeight + this.paddingTop + this.paddingBottom;
    }
  }
  class Mh {
    constructor(e, n) {
      this.from = e, this.to = n;
    }
  }
  function kU(t, e, n) {
    let r = [], i = t, o = 0;
    return _e.spans(n, t, e, {
      span() {
      },
      point(s, a) {
        s > i && (r.push({
          from: i,
          to: s
        }), o += s - i), i = a;
      }
    }, 20), i < e && (r.push({
      from: i,
      to: e
    }), o += e - i), {
      total: o,
      ranges: r
    };
  }
  function Ah({ total: t, ranges: e }, n) {
    if (n <= 0)
      return e[0].from;
    if (n >= 1)
      return e[e.length - 1].to;
    let r = Math.floor(t * n);
    for (let i = 0; ; i++) {
      let { from: o, to: s } = e[i], a = s - o;
      if (r <= a)
        return o + r;
      r -= a;
    }
  }
  function Eh(t, e) {
    let n = 0;
    for (let { from: r, to: i } of t.ranges) {
      if (e <= i) {
        n += e - r;
        break;
      }
      n += i - r;
    }
    return n / t.total;
  }
  function CU(t, e) {
    for (let n of t)
      if (e(n))
        return n;
  }
  const QC = {
    toDOM(t) {
      return t;
    },
    fromDOM(t) {
      return t;
    },
    scale: 1,
    eq(t) {
      return t == this;
    }
  };
  function JC(t) {
    let e = t.facet(zm).filter((r) => typeof r != "function"), n = t.facet(Nx).filter((r) => typeof r != "function");
    return n.length && e.push(_e.join(n)), e;
  }
  class Vx {
    constructor(e, n, r) {
      let i = 0, o = 0, s = 0;
      this.viewports = r.map(({ from: a, to: l }) => {
        let c = n.lineAt(a, tt.ByPos, e, 0, 0).top, u = n.lineAt(l, tt.ByPos, e, 0, 0).bottom;
        return i += u - c, {
          from: a,
          to: l,
          top: c,
          bottom: u,
          domTop: 0,
          domBottom: 0
        };
      }), this.scale = (7e6 - i) / (n.height - i);
      for (let a of this.viewports)
        a.domTop = s + (a.top - o) * this.scale, s = a.domBottom = a.domTop + (a.bottom - a.top), o = a.bottom;
    }
    toDOM(e) {
      for (let n = 0, r = 0, i = 0; ; n++) {
        let o = n < this.viewports.length ? this.viewports[n] : null;
        if (!o || e < o.top)
          return i + (e - r) * this.scale;
        if (e <= o.bottom)
          return o.domTop + (e - o.top);
        r = o.bottom, i = o.domBottom;
      }
    }
    fromDOM(e) {
      for (let n = 0, r = 0, i = 0; ; n++) {
        let o = n < this.viewports.length ? this.viewports[n] : null;
        if (!o || e < o.domTop)
          return r + (e - i) / this.scale;
        if (e <= o.domBottom)
          return o.top + (e - o.domTop);
        r = o.bottom, i = o.domBottom;
      }
    }
    eq(e) {
      return e instanceof Vx ? this.scale == e.scale && this.viewports.length == e.viewports.length && this.viewports.every((n, r) => n.from == e.viewports[r].from && n.to == e.viewports[r].to) : false;
    }
  }
  function xc(t, e) {
    if (e.scale == 1)
      return t;
    let n = e.toDOM(t.top), r = e.toDOM(t.bottom);
    return new $r(t.from, t.length, n, r - n, Array.isArray(t._content) ? t._content.map((i) => xc(i, e)) : t._content);
  }
  const Ph = me.define({
    combine: (t) => t.join(" ")
  }), h1 = me.define({
    combine: (t) => t.indexOf(true) > -1
  }), d1 = Ko.newName(), dL = Ko.newName(), pL = Ko.newName(), mL = {
    "&light": "." + dL,
    "&dark": "." + pL
  };
  function p1(t, e, n) {
    return new Ko(e, {
      finish(r) {
        return /&/.test(r) ? r.replace(/&\w*/, (i) => {
          if (i == "&")
            return t;
          if (!n || !n[i])
            throw new RangeError(`Unsupported selector: ${i}`);
          return n[i];
        }) : t + " " + r;
      }
    });
  }
  const TU = p1("." + d1, {
    "&": {
      position: "relative !important",
      boxSizing: "border-box",
      "&.cm-focused": {
        outline: "1px dotted #212121"
      },
      display: "flex !important",
      flexDirection: "column"
    },
    ".cm-scroller": {
      display: "flex !important",
      alignItems: "flex-start !important",
      fontFamily: "monospace",
      lineHeight: 1.4,
      height: "100%",
      overflowX: "auto",
      position: "relative",
      zIndex: 0,
      overflowAnchor: "none"
    },
    ".cm-content": {
      margin: 0,
      flexGrow: 2,
      flexShrink: 0,
      display: "block",
      whiteSpace: "pre",
      wordWrap: "normal",
      boxSizing: "border-box",
      minHeight: "100%",
      padding: "4px 0",
      outline: "none",
      "&[contenteditable=true]": {
        WebkitUserModify: "read-write-plaintext-only"
      }
    },
    ".cm-lineWrapping": {
      whiteSpace_fallback: "pre-wrap",
      whiteSpace: "break-spaces",
      wordBreak: "break-word",
      overflowWrap: "anywhere",
      flexShrink: 1
    },
    "&light .cm-content": {
      caretColor: "black"
    },
    "&dark .cm-content": {
      caretColor: "white"
    },
    ".cm-line": {
      display: "block",
      padding: "0 2px 0 6px"
    },
    ".cm-layer": {
      position: "absolute",
      left: 0,
      top: 0,
      contain: "size style",
      "& > *": {
        position: "absolute"
      }
    },
    "&light .cm-selectionBackground": {
      background: "#d9d9d9"
    },
    "&dark .cm-selectionBackground": {
      background: "#222"
    },
    "&light.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground": {
      background: "#d7d4f0"
    },
    "&dark.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground": {
      background: "#233"
    },
    ".cm-cursorLayer": {
      pointerEvents: "none"
    },
    "&.cm-focused > .cm-scroller > .cm-cursorLayer": {
      animation: "steps(1) cm-blink 1.2s infinite"
    },
    "@keyframes cm-blink": {
      "0%": {},
      "50%": {
        opacity: 0
      },
      "100%": {}
    },
    "@keyframes cm-blink2": {
      "0%": {},
      "50%": {
        opacity: 0
      },
      "100%": {}
    },
    ".cm-cursor, .cm-dropCursor": {
      borderLeft: "1.2px solid black",
      marginLeft: "-0.6px",
      pointerEvents: "none"
    },
    ".cm-cursor": {
      display: "none"
    },
    "&dark .cm-cursor": {
      borderLeftColor: "#ddd"
    },
    ".cm-dropCursor": {
      position: "absolute"
    },
    "&.cm-focused > .cm-scroller > .cm-cursorLayer .cm-cursor": {
      display: "block"
    },
    ".cm-iso": {
      unicodeBidi: "isolate"
    },
    ".cm-announced": {
      position: "fixed",
      top: "-10000px"
    },
    "@media print": {
      ".cm-announced": {
        display: "none"
      }
    },
    "&light .cm-activeLine": {
      backgroundColor: "#cceeff44"
    },
    "&dark .cm-activeLine": {
      backgroundColor: "#99eeff33"
    },
    "&light .cm-specialChar": {
      color: "red"
    },
    "&dark .cm-specialChar": {
      color: "#f78"
    },
    ".cm-gutters": {
      flexShrink: 0,
      display: "flex",
      height: "100%",
      boxSizing: "border-box",
      zIndex: 200
    },
    ".cm-gutters-before": {
      insetInlineStart: 0
    },
    ".cm-gutters-after": {
      insetInlineEnd: 0
    },
    "&light .cm-gutters": {
      backgroundColor: "#f5f5f5",
      color: "#6c6c6c",
      border: "0px solid #ddd",
      "&.cm-gutters-before": {
        borderRightWidth: "1px"
      },
      "&.cm-gutters-after": {
        borderLeftWidth: "1px"
      }
    },
    "&dark .cm-gutters": {
      backgroundColor: "#333338",
      color: "#ccc"
    },
    ".cm-gutter": {
      display: "flex !important",
      flexDirection: "column",
      flexShrink: 0,
      boxSizing: "border-box",
      minHeight: "100%",
      overflow: "hidden"
    },
    ".cm-gutterElement": {
      boxSizing: "border-box"
    },
    ".cm-lineNumbers .cm-gutterElement": {
      padding: "0 3px 0 5px",
      minWidth: "20px",
      textAlign: "right",
      whiteSpace: "nowrap"
    },
    "&light .cm-activeLineGutter": {
      backgroundColor: "#e2f2ff"
    },
    "&dark .cm-activeLineGutter": {
      backgroundColor: "#222227"
    },
    ".cm-panels": {
      boxSizing: "border-box",
      position: "sticky",
      left: 0,
      right: 0,
      zIndex: 300
    },
    "&light .cm-panels": {
      backgroundColor: "#f5f5f5",
      color: "black"
    },
    "&light .cm-panels-top": {
      borderBottom: "1px solid #ddd"
    },
    "&light .cm-panels-bottom": {
      borderTop: "1px solid #ddd"
    },
    "&dark .cm-panels": {
      backgroundColor: "#333338",
      color: "white"
    },
    ".cm-dialog": {
      padding: "2px 19px 4px 6px",
      position: "relative",
      "& label": {
        fontSize: "80%"
      }
    },
    ".cm-dialog-close": {
      position: "absolute",
      top: "3px",
      right: "4px",
      backgroundColor: "inherit",
      border: "none",
      font: "inherit",
      fontSize: "14px",
      padding: "0"
    },
    ".cm-tab": {
      display: "inline-block",
      overflow: "hidden",
      verticalAlign: "bottom"
    },
    ".cm-widgetBuffer": {
      verticalAlign: "text-top",
      height: "1em",
      width: 0,
      display: "inline"
    },
    ".cm-placeholder": {
      color: "#888",
      display: "inline-block",
      verticalAlign: "top",
      userSelect: "none"
    },
    ".cm-highlightSpace": {
      backgroundImage: "radial-gradient(circle at 50% 55%, #aaa 20%, transparent 5%)",
      backgroundPosition: "center"
    },
    ".cm-highlightTab": {
      backgroundImage: `url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="200" height="20"><path stroke="%23888" stroke-width="1" fill="none" d="M1 10H196L190 5M190 15L196 10M197 4L197 16"/></svg>')`,
      backgroundSize: "auto 100%",
      backgroundPosition: "right 90%",
      backgroundRepeat: "no-repeat"
    },
    ".cm-trailingSpace": {
      backgroundColor: "#ff332255"
    },
    ".cm-button": {
      verticalAlign: "middle",
      color: "inherit",
      fontSize: "70%",
      padding: ".2em 1em",
      borderRadius: "1px"
    },
    "&light .cm-button": {
      backgroundImage: "linear-gradient(#eff1f5, #d9d9df)",
      border: "1px solid #888",
      "&:active": {
        backgroundImage: "linear-gradient(#b4b4b4, #d0d3d6)"
      }
    },
    "&dark .cm-button": {
      backgroundImage: "linear-gradient(#393939, #111)",
      border: "1px solid #888",
      "&:active": {
        backgroundImage: "linear-gradient(#111, #333)"
      }
    },
    ".cm-textfield": {
      verticalAlign: "middle",
      color: "inherit",
      fontSize: "70%",
      border: "1px solid silver",
      padding: ".2em .5em"
    },
    "&light .cm-textfield": {
      backgroundColor: "white"
    },
    "&dark .cm-textfield": {
      border: "1px solid #555",
      backgroundColor: "inherit"
    }
  }, mL), MU = {
    childList: true,
    characterData: true,
    subtree: true,
    attributes: true,
    characterDataOldValue: true
  }, V0 = de.ie && de.ie_version <= 11;
  class AU {
    constructor(e) {
      this.view = e, this.active = false, this.editContext = null, this.selectionRange = new r7(), this.selectionChanged = false, this.delayedFlush = -1, this.resizeTimeout = -1, this.queue = [], this.delayedAndroidKey = null, this.flushingAndroidKey = -1, this.lastChange = 0, this.scrollTargets = [], this.intersection = null, this.resizeScroll = null, this.intersecting = false, this.gapIntersection = null, this.gaps = [], this.printQuery = null, this.parentCheck = -1, this.dom = e.contentDOM, this.observer = new MutationObserver((n) => {
        for (let r of n)
          this.queue.push(r);
        (de.ie && de.ie_version <= 11 || de.ios && e.composing) && n.some((r) => r.type == "childList" && r.removedNodes.length || r.type == "characterData" && r.oldValue.length > r.target.nodeValue.length) ? this.flushSoon() : this.flush();
      }), window.EditContext && de.android && e.constructor.EDIT_CONTEXT !== false && !(de.chrome && de.chrome_version < 126) && (this.editContext = new PU(e), e.state.facet(Wi) && (e.contentDOM.editContext = this.editContext.editContext)), V0 && (this.onCharData = (n) => {
        this.queue.push({
          target: n.target,
          type: "characterData",
          oldValue: n.prevValue
        }), this.flushSoon();
      }), this.onSelectionChange = this.onSelectionChange.bind(this), this.onResize = this.onResize.bind(this), this.onPrint = this.onPrint.bind(this), this.onScroll = this.onScroll.bind(this), window.matchMedia && (this.printQuery = window.matchMedia("print")), typeof ResizeObserver == "function" && (this.resizeScroll = new ResizeObserver(() => {
        var n;
        ((n = this.view.docView) === null || n === void 0 ? void 0 : n.lastUpdate) < Date.now() - 75 && this.onResize();
      }), this.resizeScroll.observe(e.scrollDOM)), this.addWindowListeners(this.win = e.win), this.start(), typeof IntersectionObserver == "function" && (this.intersection = new IntersectionObserver((n) => {
        this.parentCheck < 0 && (this.parentCheck = setTimeout(this.listenForScroll.bind(this), 1e3)), n.length > 0 && n[n.length - 1].intersectionRatio > 0 != this.intersecting && (this.intersecting = !this.intersecting, this.intersecting != this.view.inView && this.onScrollChanged(document.createEvent("Event")));
      }, {
        threshold: [
          0,
          1e-3
        ]
      }), this.intersection.observe(this.dom), this.gapIntersection = new IntersectionObserver((n) => {
        n.length > 0 && n[n.length - 1].intersectionRatio > 0 && this.onScrollChanged(document.createEvent("Event"));
      }, {})), this.listenForScroll(), this.readSelectionRange();
    }
    onScrollChanged(e) {
      this.view.inputState.runHandlers("scroll", e), this.intersecting && this.view.measure();
    }
    onScroll(e) {
      this.intersecting && this.flush(false), this.editContext && this.view.requestMeasure(this.editContext.measureReq), this.onScrollChanged(e);
    }
    onResize() {
      this.resizeTimeout < 0 && (this.resizeTimeout = setTimeout(() => {
        this.resizeTimeout = -1, this.view.requestMeasure();
      }, 50));
    }
    onPrint(e) {
      (e.type == "change" || !e.type) && !e.matches || (this.view.viewState.printing = true, this.view.measure(), setTimeout(() => {
        this.view.viewState.printing = false, this.view.requestMeasure();
      }, 500));
    }
    updateGaps(e) {
      if (this.gapIntersection && (e.length != this.gaps.length || this.gaps.some((n, r) => n != e[r]))) {
        this.gapIntersection.disconnect();
        for (let n of e)
          this.gapIntersection.observe(n);
        this.gaps = e;
      }
    }
    onSelectionChange(e) {
      let n = this.selectionChanged;
      if (!this.readSelectionRange() || this.delayedAndroidKey)
        return;
      let { view: r } = this, i = this.selectionRange;
      if (r.state.facet(Wi) ? r.root.activeElement != this.dom : !Yc(this.dom, i))
        return;
      let o = i.anchorNode && r.docView.tile.nearest(i.anchorNode);
      if (o && o.isWidget() && o.widget.ignoreEvent(e)) {
        n || (this.selectionChanged = false);
        return;
      }
      (de.ie && de.ie_version <= 11 || de.android && de.chrome) && !r.state.selection.main.empty && i.focusNode && Qc(i.focusNode, i.focusOffset, i.anchorNode, i.anchorOffset) ? this.flushSoon() : this.flush(false);
    }
    readSelectionRange() {
      let { view: e } = this, n = Nu(e.root);
      if (!n)
        return false;
      let r = de.safari && e.root.nodeType == 11 && e.root.activeElement == this.dom && EU(this.view, n) || n;
      if (!r || this.selectionRange.eq(r))
        return false;
      let i = Yc(this.dom, r);
      return i && !this.selectionChanged && e.inputState.lastFocusTime > Date.now() - 200 && e.inputState.lastTouchTime < Date.now() - 300 && o7(this.dom, r) ? (this.view.inputState.lastFocusTime = 0, e.docView.updateSelection(), false) : (this.selectionRange.setRange(r), i && (this.selectionChanged = true), true);
    }
    setSelectionRange(e, n) {
      this.selectionRange.set(e.node, e.offset, n.node, n.offset), this.selectionChanged = false;
    }
    clearSelectionRange() {
      this.selectionRange.set(null, 0, null, 0);
    }
    listenForScroll() {
      this.parentCheck = -1;
      let e = 0, n = null;
      for (let r = this.dom; r; )
        if (r.nodeType == 1)
          !n && e < this.scrollTargets.length && this.scrollTargets[e] == r ? e++ : n || (n = this.scrollTargets.slice(0, e)), n && n.push(r), r = r.assignedSlot || r.parentNode;
        else if (r.nodeType == 11)
          r = r.host;
        else
          break;
      if (e < this.scrollTargets.length && !n && (n = this.scrollTargets.slice(0, e)), n) {
        for (let r of this.scrollTargets)
          r.removeEventListener("scroll", this.onScroll);
        for (let r of this.scrollTargets = n)
          r.addEventListener("scroll", this.onScroll);
      }
    }
    ignore(e) {
      if (!this.active)
        return e();
      try {
        return this.stop(), e();
      } finally {
        this.start(), this.clear();
      }
    }
    start() {
      this.active || (this.observer.observe(this.dom, MU), V0 && this.dom.addEventListener("DOMCharacterDataModified", this.onCharData), this.active = true);
    }
    stop() {
      !this.active || (this.active = false, this.observer.disconnect(), V0 && this.dom.removeEventListener("DOMCharacterDataModified", this.onCharData));
    }
    clear() {
      this.processRecords(), this.queue.length = 0, this.selectionChanged = false;
    }
    delayAndroidKey(e, n) {
      var r;
      if (!this.delayedAndroidKey) {
        let i = () => {
          let o = this.delayedAndroidKey;
          o && (this.clearDelayedAndroidKey(), this.view.inputState.lastKeyCode = o.keyCode, this.view.inputState.lastKeyTime = Date.now(), !this.flush() && o.force && Qa(this.dom, o.key, o.keyCode));
        };
        this.flushingAndroidKey = this.view.win.requestAnimationFrame(i);
      }
      (!this.delayedAndroidKey || e == "Enter") && (this.delayedAndroidKey = {
        key: e,
        keyCode: n,
        force: this.lastChange < Date.now() - 50 || !!(!((r = this.delayedAndroidKey) === null || r === void 0) && r.force)
      });
    }
    clearDelayedAndroidKey() {
      this.win.cancelAnimationFrame(this.flushingAndroidKey), this.delayedAndroidKey = null, this.flushingAndroidKey = -1;
    }
    flushSoon() {
      this.delayedFlush < 0 && (this.delayedFlush = this.view.win.requestAnimationFrame(() => {
        this.delayedFlush = -1, this.flush();
      }));
    }
    forceFlush() {
      this.delayedFlush >= 0 && (this.view.win.cancelAnimationFrame(this.delayedFlush), this.delayedFlush = -1), this.flush();
    }
    pendingRecords() {
      for (let e of this.observer.takeRecords())
        this.queue.push(e);
      return this.queue;
    }
    processRecords() {
      let e = this.pendingRecords();
      e.length && (this.queue = []);
      let n = -1, r = -1, i = false;
      for (let o of e) {
        let s = this.readMutation(o);
        !s || (s.typeOver && (i = true), n == -1 ? { from: n, to: r } = s : (n = Math.min(s.from, n), r = Math.max(s.to, r)));
      }
      return {
        from: n,
        to: r,
        typeOver: i
      };
    }
    readChange() {
      let { from: e, to: n, typeOver: r } = this.processRecords(), i = this.selectionChanged && Yc(this.dom, this.selectionRange);
      if (e < 0 && !i)
        return null;
      e > -1 && (this.lastChange = Date.now()), this.view.inputState.lastFocusTime = 0, this.selectionChanged = false;
      let o = new K7(this.view, e, n, r);
      return this.view.docView.domChanged = {
        newSel: o.newSel ? o.newSel.main : null
      }, o;
    }
    flush(e = true) {
      if (this.delayedFlush >= 0 || this.delayedAndroidKey)
        return false;
      e && this.readSelectionRange();
      let n = this.readChange();
      if (!n)
        return this.view.requestMeasure(), false;
      let r = this.view.state, i = nL(this.view, n);
      return this.view.state == r && (n.domChanged || n.newSel && !kp(this.view.state.selection, n.newSel.main)) && this.view.update([]), i;
    }
    readMutation(e) {
      let n = this.view.docView.tile.nearest(e.target);
      if (!n || n.isWidget())
        return null;
      if (n.markDirty(e.type == "attributes"), e.type == "childList") {
        let r = ZC(n, e.previousSibling || e.target.previousSibling, -1), i = ZC(n, e.nextSibling || e.target.nextSibling, 1);
        return {
          from: r ? n.posAfter(r) : n.posAtStart,
          to: i ? n.posBefore(i) : n.posAtEnd,
          typeOver: false
        };
      } else
        return e.type == "characterData" ? {
          from: n.posAtStart,
          to: n.posAtEnd,
          typeOver: e.target.nodeValue == e.oldValue
        } : null;
    }
    setWindow(e) {
      e != this.win && (this.removeWindowListeners(this.win), this.win = e, this.addWindowListeners(this.win));
    }
    addWindowListeners(e) {
      e.addEventListener("resize", this.onResize), this.printQuery ? this.printQuery.addEventListener ? this.printQuery.addEventListener("change", this.onPrint) : this.printQuery.addListener(this.onPrint) : e.addEventListener("beforeprint", this.onPrint), e.addEventListener("scroll", this.onScroll), e.document.addEventListener("selectionchange", this.onSelectionChange);
    }
    removeWindowListeners(e) {
      e.removeEventListener("scroll", this.onScroll), e.removeEventListener("resize", this.onResize), this.printQuery ? this.printQuery.removeEventListener ? this.printQuery.removeEventListener("change", this.onPrint) : this.printQuery.removeListener(this.onPrint) : e.removeEventListener("beforeprint", this.onPrint), e.document.removeEventListener("selectionchange", this.onSelectionChange);
    }
    update(e) {
      this.editContext && (this.editContext.update(e), e.startState.facet(Wi) != e.state.facet(Wi) && (e.view.contentDOM.editContext = e.state.facet(Wi) ? this.editContext.editContext : null));
    }
    destroy() {
      var e, n, r;
      this.stop(), (e = this.intersection) === null || e === void 0 || e.disconnect(), (n = this.gapIntersection) === null || n === void 0 || n.disconnect(), (r = this.resizeScroll) === null || r === void 0 || r.disconnect();
      for (let i of this.scrollTargets)
        i.removeEventListener("scroll", this.onScroll);
      this.removeWindowListeners(this.win), clearTimeout(this.parentCheck), clearTimeout(this.resizeTimeout), this.win.cancelAnimationFrame(this.delayedFlush), this.win.cancelAnimationFrame(this.flushingAndroidKey), this.editContext && (this.view.contentDOM.editContext = null, this.editContext.destroy());
    }
  }
  function ZC(t, e, n) {
    for (; e; ) {
      let r = Lt.get(e);
      if (r && r.parent == t)
        return r;
      let i = e.parentNode;
      e = i != t.dom ? i : n > 0 ? e.nextSibling : e.previousSibling;
    }
    return null;
  }
  function eT(t, e) {
    let n = e.startContainer, r = e.startOffset, i = e.endContainer, o = e.endOffset, s = t.docView.domAtPos(t.state.selection.main.anchor, 1);
    return Qc(s.node, s.offset, i, o) && ([n, r, i, o] = [
      i,
      o,
      n,
      r
    ]), {
      anchorNode: n,
      anchorOffset: r,
      focusNode: i,
      focusOffset: o
    };
  }
  function EU(t, e) {
    if (e.getComposedRanges) {
      let i = e.getComposedRanges(t.root)[0];
      if (i)
        return eT(t, i);
    }
    let n = null;
    function r(i) {
      i.preventDefault(), i.stopImmediatePropagation(), n = i.getTargetRanges()[0];
    }
    return t.contentDOM.addEventListener("beforeinput", r, true), t.dom.ownerDocument.execCommand("indent"), t.contentDOM.removeEventListener("beforeinput", r, true), n ? eT(t, n) : null;
  }
  class PU {
    constructor(e) {
      this.from = 0, this.to = 0, this.pendingContextChange = null, this.handlers = /* @__PURE__ */ Object.create(null), this.composing = null, this.resetRange(e.state);
      let n = this.editContext = new window.EditContext({
        text: e.state.doc.sliceString(this.from, this.to),
        selectionStart: this.toContextPos(Math.max(this.from, Math.min(this.to, e.state.selection.main.anchor))),
        selectionEnd: this.toContextPos(e.state.selection.main.head)
      });
      this.handlers.textupdate = (r) => {
        let i = e.state.selection.main, { anchor: o, head: s } = i, a = this.toEditorPos(r.updateRangeStart), l = this.toEditorPos(r.updateRangeEnd);
        e.inputState.composing >= 0 && !this.composing && (this.composing = {
          contextBase: r.updateRangeStart,
          editorBase: a,
          drifted: false
        });
        let c = l - a > r.text.length;
        a == this.from && o < this.from ? a = o : l == this.to && o > this.to && (l = o);
        let u = rL(e.state.sliceDoc(a, l), r.text, (c ? i.from : i.to) - a, c ? "end" : null);
        if (!u) {
          let p = q.single(this.toEditorPos(r.selectionStart), this.toEditorPos(r.selectionEnd));
          kp(p, i) || e.dispatch({
            selection: p,
            userEvent: "select"
          });
          return;
        }
        let h = {
          from: u.from + a,
          to: u.toA + a,
          insert: He.of(r.text.slice(u.from, u.toB).split(`
`))
        };
        if ((de.mac || de.android) && h.from == s - 1 && /^\. ?$/.test(r.text) && e.contentDOM.getAttribute("autocorrect") == "off" && (h = {
          from: a,
          to: l,
          insert: He.of([
            r.text.replace(".", " ")
          ])
        }), this.pendingContextChange = h, !e.state.readOnly) {
          let p = this.to - this.from + (h.to - h.from + h.insert.length);
          zx(e, h, q.single(this.toEditorPos(r.selectionStart, p), this.toEditorPos(r.selectionEnd, p)));
        }
        this.pendingContextChange && (this.revertPending(e.state), this.setSelection(e.state)), h.from < h.to && !h.insert.length && e.inputState.composing >= 0 && !/[\\p{Alphabetic}\\p{Number}_]/.test(n.text.slice(Math.max(0, r.updateRangeStart - 1), Math.min(n.text.length, r.updateRangeStart + 1))) && this.handlers.compositionend(r);
      }, this.handlers.characterboundsupdate = (r) => {
        let i = [], o = null;
        for (let s = this.toEditorPos(r.rangeStart), a = this.toEditorPos(r.rangeEnd); s < a; s++) {
          let l = e.coordsForChar(s);
          o = l && new DOMRect(l.left, l.top, l.right - l.left, l.bottom - l.top) || o || new DOMRect(), i.push(o);
        }
        n.updateCharacterBounds(r.rangeStart, i);
      }, this.handlers.textformatupdate = (r) => {
        let i = [];
        for (let o of r.getTextFormats()) {
          let s = o.underlineStyle, a = o.underlineThickness;
          if (!/none/i.test(s) && !/none/i.test(a)) {
            let l = this.toEditorPos(o.rangeStart), c = this.toEditorPos(o.rangeEnd);
            if (l < c) {
              let u = `text-decoration: underline ${/^[a-z]/.test(s) ? s + " " : s == "Dashed" ? "dashed " : s == "Squiggle" ? "wavy " : ""}${/thin/i.test(a) ? 1 : 2}px`;
              i.push(be.mark({
                attributes: {
                  style: u
                }
              }).range(l, c));
            }
          }
        }
        e.dispatch({
          effects: qO.of(be.set(i))
        });
      }, this.handlers.compositionstart = () => {
        e.inputState.composing < 0 && (e.inputState.composing = 0, e.inputState.compositionFirstChange = true);
      }, this.handlers.compositionend = () => {
        if (e.inputState.composing = -1, e.inputState.compositionFirstChange = null, this.composing) {
          let { drifted: r } = this.composing;
          this.composing = null, r && this.reset(e.state);
        }
      };
      for (let r in this.handlers)
        n.addEventListener(r, this.handlers[r]);
      this.measureReq = {
        read: (r) => {
          this.editContext.updateControlBounds(r.contentDOM.getBoundingClientRect());
          let i = Nu(r.root);
          i && i.rangeCount && this.editContext.updateSelectionBounds(i.getRangeAt(0).getBoundingClientRect());
        }
      };
    }
    applyEdits(e) {
      let n = 0, r = false, i = this.pendingContextChange;
      return e.changes.iterChanges((o, s, a, l, c) => {
        if (r)
          return;
        let u = c.length - (s - o);
        if (i && s >= i.to)
          if (i.from == o && i.to == s && i.insert.eq(c)) {
            i = this.pendingContextChange = null, n += u, this.to += u;
            return;
          } else
            i = null, this.revertPending(e.state);
        if (o += n, s += n, s <= this.from)
          this.from += u, this.to += u;
        else if (o < this.to) {
          if (o < this.from || s > this.to || this.to - this.from + c.length > 3e4) {
            r = true;
            return;
          }
          this.editContext.updateText(this.toContextPos(o), this.toContextPos(s), c.toString()), this.to += u;
        }
        n += u;
      }), i && !r && this.revertPending(e.state), !r;
    }
    update(e) {
      let n = this.pendingContextChange, r = e.startState.selection.main;
      this.composing && (this.composing.drifted || !e.changes.touchesRange(r.from, r.to) && e.transactions.some((i) => !i.isUserEvent("input.type") && i.changes.touchesRange(this.from, this.to))) ? (this.composing.drifted = true, this.composing.editorBase = e.changes.mapPos(this.composing.editorBase)) : !this.applyEdits(e) || !this.rangeIsValid(e.state) ? (this.pendingContextChange = null, this.reset(e.state)) : (e.docChanged || e.selectionSet || n) && this.setSelection(e.state), (e.geometryChanged || e.docChanged || e.selectionSet) && e.view.requestMeasure(this.measureReq);
    }
    resetRange(e) {
      let { head: n } = e.selection.main;
      this.from = Math.max(0, n - 1e4), this.to = Math.min(e.doc.length, n + 1e4);
    }
    reset(e) {
      this.resetRange(e), this.editContext.updateText(0, this.editContext.text.length, e.doc.sliceString(this.from, this.to)), this.setSelection(e);
    }
    revertPending(e) {
      let n = this.pendingContextChange;
      this.pendingContextChange = null, this.editContext.updateText(this.toContextPos(n.from), this.toContextPos(n.from + n.insert.length), e.doc.sliceString(n.from, n.to));
    }
    setSelection(e) {
      let { main: n } = e.selection, r = this.toContextPos(Math.max(this.from, Math.min(this.to, n.anchor))), i = this.toContextPos(n.head);
      (this.editContext.selectionStart != r || this.editContext.selectionEnd != i) && this.editContext.updateSelection(r, i);
    }
    rangeIsValid(e) {
      let { head: n } = e.selection.main;
      return !(this.from > 0 && n - this.from < 500 || this.to < e.doc.length && this.to - n < 500 || this.to - this.from > 1e4 * 3);
    }
    toEditorPos(e, n = this.to - this.from) {
      e = Math.min(e, n);
      let r = this.composing;
      return r && r.drifted ? r.editorBase + (e - r.contextBase) : e + this.from;
    }
    toContextPos(e) {
      let n = this.composing;
      return n && n.drifted ? n.contextBase + (e - n.editorBase) : e - this.from;
    }
    destroy() {
      for (let e in this.handlers)
        this.editContext.removeEventListener(e, this.handlers[e]);
    }
  }
  class ue {
    get state() {
      return this.viewState.state;
    }
    get viewport() {
      return this.viewState.viewport;
    }
    get visibleRanges() {
      return this.viewState.visibleRanges;
    }
    get inView() {
      return this.viewState.inView;
    }
    get composing() {
      return !!this.inputState && this.inputState.composing > 0;
    }
    get compositionStarted() {
      return !!this.inputState && this.inputState.composing >= 0;
    }
    get root() {
      return this._root;
    }
    get win() {
      return this.dom.ownerDocument.defaultView || window;
    }
    constructor(e = {}) {
      var n;
      this.plugins = [], this.pluginMap = /* @__PURE__ */ new Map(), this.editorAttrs = {}, this.contentAttrs = {}, this.bidiCache = [], this.destroyed = false, this.updateState = 2, this.measureScheduled = -1, this.measureRequests = [], this.contentDOM = document.createElement("div"), this.scrollDOM = document.createElement("div"), this.scrollDOM.tabIndex = -1, this.scrollDOM.className = "cm-scroller", this.scrollDOM.appendChild(this.contentDOM), this.announceDOM = document.createElement("div"), this.announceDOM.className = "cm-announced", this.announceDOM.setAttribute("aria-live", "polite"), this.dom = document.createElement("div"), this.dom.appendChild(this.announceDOM), this.dom.appendChild(this.scrollDOM), e.parent && e.parent.appendChild(this.dom);
      let { dispatch: r } = e;
      this.dispatchTransactions = e.dispatchTransactions || r && ((i) => i.forEach((o) => r(o, this))) || ((i) => this.update(i)), this.dispatch = this.dispatch.bind(this), this._root = e.root || i7(e.parent) || document, this.viewState = new XC(e.state || $e.create(e)), e.scrollTo && e.scrollTo.is(kh) && (this.viewState.scrollTarget = e.scrollTo.value.clip(this.viewState.state)), this.plugins = this.state.facet(_a).map((i) => new I0(i));
      for (let i of this.plugins)
        i.update(this);
      this.observer = new AU(this), this.inputState = new X7(this), this.inputState.ensureHandlers(this.plugins), this.docView = new NC(this), this.mountStyles(), this.updateAttrs(), this.updateState = 0, this.requestMeasure(), !((n = document.fonts) === null || n === void 0) && n.ready && document.fonts.ready.then(() => {
        this.viewState.mustMeasureContent = "refresh", this.requestMeasure();
      });
    }
    dispatch(...e) {
      let n = e.length == 1 && e[0] instanceof Bt ? e : e.length == 1 && Array.isArray(e[0]) ? e[0] : [
        this.state.update(...e)
      ];
      this.dispatchTransactions(n, this);
    }
    update(e) {
      if (this.updateState != 0)
        throw new Error("Calls to EditorView.update are not allowed while an update is in progress");
      let n = false, r = false, i, o = this.state;
      for (let p of e) {
        if (p.startState != o)
          throw new RangeError("Trying to update state with a transaction that doesn't start from the previous state.");
        o = p.state;
      }
      if (this.destroyed) {
        this.viewState.state = o;
        return;
      }
      let s = this.hasFocus, a = 0, l = null;
      e.some((p) => p.annotation(cL)) ? (this.inputState.notifiedFocused = s, a = 1) : s != this.inputState.notifiedFocused && (this.inputState.notifiedFocused = s, l = uL(o, s), l || (a = 1));
      let c = this.observer.delayedAndroidKey, u = null;
      if (c ? (this.observer.clearDelayedAndroidKey(), u = this.observer.readChange(), (u && !this.state.doc.eq(o.doc) || !this.state.selection.eq(o.selection)) && (u = null)) : this.observer.clear(), o.facet($e.phrases) != this.state.facet($e.phrases))
        return this.setState(o);
      i = xp.create(this, o, e), i.flags |= a;
      let h = this.viewState.scrollTarget;
      try {
        this.updateState = 2;
        for (let p of e) {
          if (h && (h = h.map(p.changes)), p.scrollIntoView) {
            let { main: v } = p.state.selection;
            h = new Ja(v.empty ? v : q.cursor(v.head, v.head > v.anchor ? -1 : 1));
          }
          for (let v of p.effects)
            v.is(kh) && (h = v.value.clip(this.state));
        }
        this.viewState.update(i, h), this.bidiCache = Tp.update(this.bidiCache, i.changes), i.empty || (this.updatePlugins(i), this.inputState.update(i)), n = this.docView.update(i), this.state.facet(yc) != this.styleModules && this.mountStyles(), r = this.updateAttrs(), this.showAnnouncements(e), this.docView.updateSelection(n, e.some((p) => p.isUserEvent("select.pointer")));
      } finally {
        this.updateState = 0;
      }
      if (i.startState.facet(Ph) != i.state.facet(Ph) && (this.viewState.mustMeasureContent = true), (n || r || h || this.viewState.mustEnforceCursorAssoc || this.viewState.mustMeasureContent) && this.requestMeasure(), n && this.docViewUpdate(), !i.empty)
        for (let p of this.state.facet(a1))
          try {
            p(i);
          } catch (v) {
            In(this.state, v, "update listener");
          }
      (l || u) && Promise.resolve().then(() => {
        l && this.state == l.startState && this.dispatch(l), u && !nL(this, u) && c.force && Qa(this.contentDOM, c.key, c.keyCode);
      });
    }
    setState(e) {
      if (this.updateState != 0)
        throw new Error("Calls to EditorView.setState are not allowed while an update is in progress");
      if (this.destroyed) {
        this.viewState.state = e;
        return;
      }
      this.updateState = 2;
      let n = this.hasFocus;
      try {
        for (let r of this.plugins)
          r.destroy(this);
        this.viewState = new XC(e), this.plugins = e.facet(_a).map((r) => new I0(r)), this.pluginMap.clear();
        for (let r of this.plugins)
          r.update(this);
        this.docView.destroy(), this.docView = new NC(this), this.inputState.ensureHandlers(this.plugins), this.mountStyles(), this.updateAttrs(), this.bidiCache = [];
      } finally {
        this.updateState = 0;
      }
      n && this.focus(), this.requestMeasure();
    }
    updatePlugins(e) {
      let n = e.startState.facet(_a), r = e.state.facet(_a);
      if (n != r) {
        let i = [];
        for (let o of r) {
          let s = n.indexOf(o);
          if (s < 0)
            i.push(new I0(o));
          else {
            let a = this.plugins[s];
            a.mustUpdate = e, i.push(a);
          }
        }
        for (let o of this.plugins)
          o.mustUpdate != e && o.destroy(this);
        this.plugins = i, this.pluginMap.clear();
      } else
        for (let i of this.plugins)
          i.mustUpdate = e;
      for (let i = 0; i < this.plugins.length; i++)
        this.plugins[i].update(this);
      n != r && this.inputState.ensureHandlers(this.plugins);
    }
    docViewUpdate() {
      for (let e of this.plugins) {
        let n = e.value;
        if (n && n.docViewUpdate)
          try {
            n.docViewUpdate(this);
          } catch (r) {
            In(this.state, r, "doc view update listener");
          }
      }
    }
    measure(e = true) {
      if (this.destroyed)
        return;
      if (this.measureScheduled > -1 && this.win.cancelAnimationFrame(this.measureScheduled), this.observer.delayedAndroidKey) {
        this.measureScheduled = -1, this.requestMeasure();
        return;
      }
      this.measureScheduled = 0, e && this.observer.forceFlush();
      let n = null, r = this.scrollDOM, i = r.scrollTop * this.scaleY, { scrollAnchorPos: o, scrollAnchorHeight: s } = this.viewState;
      Math.abs(i - this.viewState.scrollTop) > 1 && (s = -1), this.viewState.scrollAnchorHeight = -1;
      try {
        for (let a = 0; ; a++) {
          if (s < 0)
            if (OO(r))
              o = -1, s = this.viewState.heightMap.height;
            else {
              let v = this.viewState.scrollAnchorAt(i);
              o = v.from, s = v.top;
            }
          this.updateState = 1;
          let l = this.viewState.measure(this);
          if (!l && !this.measureRequests.length && this.viewState.scrollTarget == null)
            break;
          if (a > 5) {
            console.warn(this.measureRequests.length ? "Measure loop restarted more than 5 times" : "Viewport failed to stabilize");
            break;
          }
          let c = [];
          l & 4 || ([this.measureRequests, c] = [
            c,
            this.measureRequests
          ]);
          let u = c.map((v) => {
            try {
              return v.read(this);
            } catch (y) {
              return In(this.state, y), tT;
            }
          }), h = xp.create(this, this.state, []), p = false;
          h.flags |= l, n ? n.flags |= l : n = h, this.updateState = 2, h.empty || (this.updatePlugins(h), this.inputState.update(h), this.updateAttrs(), p = this.docView.update(h), p && this.docViewUpdate());
          for (let v = 0; v < c.length; v++)
            if (u[v] != tT)
              try {
                let y = c[v];
                y.write && y.write(u[v], this);
              } catch (y) {
                In(this.state, y);
              }
          if (p && this.docView.updateSelection(true), !h.viewportChanged && this.measureRequests.length == 0) {
            if (this.viewState.editorHeight)
              if (this.viewState.scrollTarget) {
                this.docView.scrollIntoView(this.viewState.scrollTarget), this.viewState.scrollTarget = null, s = -1;
                continue;
              } else {
                let y = (o < 0 ? this.viewState.heightMap.height : this.viewState.lineBlockAt(o).top) - s;
                if (y > 1 || y < -1) {
                  i = i + y, r.scrollTop = i / this.scaleY, s = -1;
                  continue;
                }
              }
            break;
          }
        }
      } finally {
        this.updateState = 0, this.measureScheduled = -1;
      }
      if (n && !n.empty)
        for (let a of this.state.facet(a1))
          a(n);
    }
    get themeClasses() {
      return d1 + " " + (this.state.facet(h1) ? pL : dL) + " " + this.state.facet(Ph);
    }
    updateAttrs() {
      let e = nT(this, GO, {
        class: "cm-editor" + (this.hasFocus ? " cm-focused " : " ") + this.themeClasses
      }), n = {
        spellcheck: "false",
        autocorrect: "off",
        autocapitalize: "off",
        writingsuggestions: "false",
        translate: "no",
        contenteditable: this.state.facet(Wi) ? "true" : "false",
        class: "cm-content",
        style: `${de.tabSize}: ${this.state.tabSize}`,
        role: "textbox",
        "aria-multiline": "true"
      };
      this.state.readOnly && (n["aria-readonly"] = "true"), nT(this, Bx, n);
      let r = this.observer.ignore(() => {
        let i = LC(this.contentDOM, this.contentAttrs, n), o = LC(this.dom, this.editorAttrs, e);
        return i || o;
      });
      return this.editorAttrs = e, this.contentAttrs = n, r;
    }
    showAnnouncements(e) {
      let n = true;
      for (let r of e)
        for (let i of r.effects)
          if (i.is(ue.announce)) {
            n && (this.announceDOM.textContent = ""), n = false;
            let o = this.announceDOM.appendChild(document.createElement("div"));
            o.textContent = i.value;
          }
    }
    mountStyles() {
      this.styleModules = this.state.facet(yc);
      let e = this.state.facet(ue.cspNonce);
      Ko.mount(this.root, this.styleModules.concat(TU).reverse(), e ? {
        nonce: e
      } : void 0);
    }
    readMeasured() {
      if (this.updateState == 2)
        throw new Error("Reading the editor layout isn't allowed during an update");
      this.updateState == 0 && this.measureScheduled > -1 && this.measure(false);
    }
    requestMeasure(e) {
      if (this.measureScheduled < 0 && (this.measureScheduled = this.win.requestAnimationFrame(() => this.measure())), e) {
        if (this.measureRequests.indexOf(e) > -1)
          return;
        if (e.key != null) {
          for (let n = 0; n < this.measureRequests.length; n++)
            if (this.measureRequests[n].key === e.key) {
              this.measureRequests[n] = e;
              return;
            }
        }
        this.measureRequests.push(e);
      }
    }
    plugin(e) {
      let n = this.pluginMap.get(e);
      return (n === void 0 || n && n.plugin != e) && this.pluginMap.set(e, n = this.plugins.find((r) => r.plugin == e) || null), n && n.update(this).value;
    }
    get documentTop() {
      return this.contentDOM.getBoundingClientRect().top + this.viewState.paddingTop;
    }
    get documentPadding() {
      return {
        top: this.viewState.paddingTop,
        bottom: this.viewState.paddingBottom
      };
    }
    get scaleX() {
      return this.viewState.scaleX;
    }
    get scaleY() {
      return this.viewState.scaleY;
    }
    elementAtHeight(e) {
      return this.readMeasured(), this.viewState.elementAtHeight(e);
    }
    lineBlockAtHeight(e) {
      return this.readMeasured(), this.viewState.lineBlockAtHeight(e);
    }
    get viewportLineBlocks() {
      return this.viewState.viewportLines;
    }
    lineBlockAt(e) {
      return this.viewState.lineBlockAt(e);
    }
    get contentHeight() {
      return this.viewState.contentHeight;
    }
    moveByChar(e, n, r) {
      return z0(this, e, $C(this, e, n, r));
    }
    moveByGroup(e, n) {
      return z0(this, e, $C(this, e, n, (r) => F7(this, e.head, r)));
    }
    visualLineSide(e, n) {
      let r = this.bidiSpans(e), i = this.textDirectionAt(e.from), o = r[n ? r.length - 1 : 0];
      return q.cursor(o.side(n, i) + e.from, o.forward(!n, i) ? 1 : -1);
    }
    moveToLineBoundary(e, n, r = true) {
      return z7(this, e, n, r);
    }
    moveVertically(e, n, r) {
      return z0(this, e, V7(this, e, n, r));
    }
    domAtPos(e, n = 1) {
      return this.docView.domAtPos(e, n);
    }
    posAtDOM(e, n = 0) {
      return this.docView.posFromDOM(e, n);
    }
    posAtCoords(e, n = true) {
      this.readMeasured();
      let r = u1(this, e, n);
      return r && r.pos;
    }
    posAndSideAtCoords(e, n = true) {
      return this.readMeasured(), u1(this, e, n);
    }
    coordsAtPos(e, n = 1) {
      this.readMeasured();
      let r = this.docView.coordsAt(e, n);
      if (!r || r.left == r.right)
        return r;
      let i = this.state.doc.lineAt(e), o = this.bidiSpans(i), s = o[bi.find(o, e - i.from, -1, n)];
      return $u(r, s.dir == Je.LTR == n > 0);
    }
    coordsForChar(e) {
      return this.readMeasured(), this.docView.coordsForChar(e);
    }
    get defaultCharacterWidth() {
      return this.viewState.heightOracle.charWidth;
    }
    get defaultLineHeight() {
      return this.viewState.heightOracle.lineHeight;
    }
    get textDirection() {
      return this.viewState.defaultTextDirection;
    }
    textDirectionAt(e) {
      return !this.state.facet(jO) || e < this.viewport.from || e > this.viewport.to ? this.textDirection : (this.readMeasured(), this.docView.textDirectionAt(e));
    }
    get lineWrapping() {
      return this.viewState.heightOracle.lineWrapping;
    }
    bidiSpans(e) {
      if (e.length > OU)
        return BO(e.length);
      let n = this.textDirectionAt(e.from), r;
      for (let o of this.bidiCache)
        if (o.from == e.from && o.dir == n && (o.fresh || IO(o.isolates, r = DC(this, e))))
          return o.order;
      r || (r = DC(this, e));
      let i = h7(e.text, n, r);
      return this.bidiCache.push(new Tp(e.from, e.to, n, r, true, i)), i;
    }
    get hasFocus() {
      var e;
      return (this.dom.ownerDocument.hasFocus() || de.safari && ((e = this.inputState) === null || e === void 0 ? void 0 : e.lastContextMenu) > Date.now() - 3e4) && this.root.activeElement == this.contentDOM;
    }
    focus() {
      this.observer.ignore(() => {
        PO(this.contentDOM), this.docView.updateSelection();
      });
    }
    setRoot(e) {
      this._root != e && (this._root = e, this.observer.setWindow((e.nodeType == 9 ? e : e.ownerDocument).defaultView || window), this.mountStyles());
    }
    destroy() {
      this.root.activeElement == this.contentDOM && this.contentDOM.blur();
      for (let e of this.plugins)
        e.destroy(this);
      this.plugins = [], this.inputState.destroy(), this.docView.destroy(), this.dom.remove(), this.observer.destroy(), this.measureScheduled > -1 && this.win.cancelAnimationFrame(this.measureScheduled), this.destroyed = true;
    }
    static scrollIntoView(e, n = {}) {
      return kh.of(new Ja(typeof e == "number" ? q.cursor(e) : e, n.y, n.x, n.yMargin, n.xMargin));
    }
    scrollSnapshot() {
      let { scrollTop: e, scrollLeft: n } = this.scrollDOM, r = this.viewState.scrollAnchorAt(e);
      return kh.of(new Ja(q.cursor(r.from), "start", "start", r.top - e, n, true));
    }
    setTabFocusMode(e) {
      e == null ? this.inputState.tabFocusMode = this.inputState.tabFocusMode < 0 ? 0 : -1 : typeof e == "boolean" ? this.inputState.tabFocusMode = e ? 0 : -1 : this.inputState.tabFocusMode != 0 && (this.inputState.tabFocusMode = Date.now() + e);
    }
    static domEventHandlers(e) {
      return kt.define(() => ({}), {
        eventHandlers: e
      });
    }
    static domEventObservers(e) {
      return kt.define(() => ({}), {
        eventObservers: e
      });
    }
    static theme(e, n) {
      let r = Ko.newName(), i = [
        Ph.of(r),
        yc.of(p1(`.${r}`, e))
      ];
      return n && n.dark && i.push(h1.of(true)), i;
    }
    static baseTheme(e) {
      return ns.lowest(yc.of(p1("." + d1, e, mL)));
    }
    static findFromDOM(e) {
      var n;
      let r = e.querySelector(".cm-content"), i = r && Lt.get(r) || Lt.get(e);
      return ((n = i == null ? void 0 : i.root) === null || n === void 0 ? void 0 : n.view) || null;
    }
  }
  ue.styleModule = yc;
  ue.inputHandler = WO;
  ue.clipboardInputFilter = Dx;
  ue.clipboardOutputFilter = Ix;
  ue.scrollHandler = KO;
  ue.focusChangeEffect = HO;
  ue.perLineTextDirection = jO;
  ue.exceptionSink = VO;
  ue.updateListener = a1;
  ue.editable = Wi;
  ue.mouseSelectionStyle = FO;
  ue.dragMovesSelection = zO;
  ue.clickAddsSelectionRange = $O;
  ue.decorations = zm;
  ue.blockWrappers = YO;
  ue.outerDecorations = Nx;
  ue.atomicRanges = cf;
  ue.bidiIsolatedRanges = XO;
  ue.scrollMargins = QO;
  ue.darkTheme = h1;
  ue.cspNonce = me.define({
    combine: (t) => t.length ? t[0] : ""
  });
  ue.contentAttributes = Bx;
  ue.editorAttributes = GO;
  ue.lineWrapping = ue.contentAttributes.of({
    class: "cm-lineWrapping"
  });
  ue.announce = Ee.define();
  const OU = 4096, tT = {};
  class Tp {
    constructor(e, n, r, i, o, s) {
      this.from = e, this.to = n, this.dir = r, this.isolates = i, this.fresh = o, this.order = s;
    }
    static update(e, n) {
      if (n.empty && !e.some((o) => o.fresh))
        return e;
      let r = [], i = e.length ? e[e.length - 1].dir : Je.LTR;
      for (let o = Math.max(0, e.length - 10); o < e.length; o++) {
        let s = e[o];
        s.dir == i && !n.touchesRange(s.from, s.to) && r.push(new Tp(n.mapPos(s.from, 1), n.mapPos(s.to, -1), s.dir, s.isolates, false, s.order));
      }
      return r;
    }
  }
  function nT(t, e, n) {
    for (let r = t.state.facet(e), i = r.length - 1; i >= 0; i--) {
      let o = r[i], s = typeof o == "function" ? o(t) : o;
      s && Lx(s, n);
    }
    return n;
  }
  const LU = de.mac ? "mac" : de.windows ? "win" : de.linux ? "linux" : "key";
  function RU(t, e) {
    const n = t.split(/-(?!$)/);
    let r = n[n.length - 1];
    r == "Space" && (r = " ");
    let i, o, s, a;
    for (let l = 0; l < n.length - 1; ++l) {
      const c = n[l];
      if (/^(cmd|meta|m)$/i.test(c))
        a = true;
      else if (/^a(lt)?$/i.test(c))
        i = true;
      else if (/^(c|ctrl|control)$/i.test(c))
        o = true;
      else if (/^s(hift)?$/i.test(c))
        s = true;
      else if (/^mod$/i.test(c))
        e == "mac" ? a = true : o = true;
      else
        throw new Error("Unrecognized modifier name: " + c);
    }
    return i && (r = "Alt-" + r), o && (r = "Ctrl-" + r), a && (r = "Meta-" + r), s && (r = "Shift-" + r), r;
  }
  function Oh(t, e, n) {
    return e.altKey && (t = "Alt-" + t), e.ctrlKey && (t = "Ctrl-" + t), e.metaKey && (t = "Meta-" + t), n !== false && e.shiftKey && (t = "Shift-" + t), t;
  }
  const _U = ns.default(ue.domEventHandlers({
    keydown(t, e) {
      return vL(gL(e.state), t, e, "editor");
    }
  })), Hm = me.define({
    enables: _U
  }), rT = /* @__PURE__ */ new WeakMap();
  function gL(t) {
    let e = t.facet(Hm), n = rT.get(e);
    return n || rT.set(e, n = IU(e.reduce((r, i) => r.concat(i), []))), n;
  }
  function xs(t, e, n) {
    return vL(gL(t.state), e, t, n);
  }
  let Mo = null;
  const DU = 4e3;
  function IU(t, e = LU) {
    let n = /* @__PURE__ */ Object.create(null), r = /* @__PURE__ */ Object.create(null), i = (s, a) => {
      let l = r[s];
      if (l == null)
        r[s] = a;
      else if (l != a)
        throw new Error("Key binding " + s + " is used both as a regular binding and as a multi-stroke prefix");
    }, o = (s, a, l, c, u) => {
      var h, p;
      let v = n[s] || (n[s] = /* @__PURE__ */ Object.create(null)), y = a.split(/ (?!$)/).map((w) => RU(w, e));
      for (let w = 1; w < y.length; w++) {
        let k = y.slice(0, w).join(" ");
        i(k, true), v[k] || (v[k] = {
          preventDefault: true,
          stopPropagation: false,
          run: [
            (C) => {
              let O = Mo = {
                view: C,
                prefix: k,
                scope: s
              };
              return setTimeout(() => {
                Mo == O && (Mo = null);
              }, DU), true;
            }
          ]
        });
      }
      let S = y.join(" ");
      i(S, false);
      let T = v[S] || (v[S] = {
        preventDefault: false,
        stopPropagation: false,
        run: ((p = (h = v._any) === null || h === void 0 ? void 0 : h.run) === null || p === void 0 ? void 0 : p.slice()) || []
      });
      l && T.run.push(l), c && (T.preventDefault = true), u && (T.stopPropagation = true);
    };
    for (let s of t) {
      let a = s.scope ? s.scope.split(" ") : [
        "editor"
      ];
      if (s.any)
        for (let c of a) {
          let u = n[c] || (n[c] = /* @__PURE__ */ Object.create(null));
          u._any || (u._any = {
            preventDefault: false,
            stopPropagation: false,
            run: []
          });
          let { any: h } = s;
          for (let p in u)
            u[p].run.push((v) => h(v, m1));
        }
      let l = s[e] || s.key;
      if (!!l)
        for (let c of a)
          o(c, l, s.run, s.preventDefault, s.stopPropagation), s.shift && o(c, "Shift-" + l, s.shift, s.preventDefault, s.stopPropagation);
    }
    return n;
  }
  let m1 = null;
  function vL(t, e, n, r) {
    m1 = e;
    let i = Xj(e), o = On(i, 0), s = mi(o) == i.length && i != " ", a = "", l = false, c = false, u = false;
    Mo && Mo.view == n && Mo.scope == r && (a = Mo.prefix + " ", oL.indexOf(e.keyCode) < 0 && (c = true, Mo = null));
    let h = /* @__PURE__ */ new Set(), p = (T) => {
      if (T) {
        for (let w of T.run)
          if (!h.has(w) && (h.add(w), w(n)))
            return T.stopPropagation && (u = true), true;
        T.preventDefault && (T.stopPropagation && (u = true), c = true);
      }
      return false;
    }, v = t[r], y, S;
    return v && (p(v[a + Oh(i, e, !s)]) ? l = true : s && (e.altKey || e.metaKey || e.ctrlKey) && !(de.windows && e.ctrlKey && e.altKey) && !(de.mac && e.altKey && !(e.ctrlKey || e.metaKey)) && (y = qo[e.keyCode]) && y != i ? (p(v[a + Oh(y, e, true)]) || e.shiftKey && (S = Iu[e.keyCode]) != i && S != y && p(v[a + Oh(S, e, false)])) && (l = true) : s && e.shiftKey && p(v[a + Oh(i, e, true)]) && (l = true), !l && p(v._any) && (l = true)), c && (l = true), l && u && e.stopPropagation(), m1 = null, l;
  }
  class uf {
    constructor(e, n, r, i, o) {
      this.className = e, this.left = n, this.top = r, this.width = i, this.height = o;
    }
    draw() {
      let e = document.createElement("div");
      return e.className = this.className, this.adjust(e), e;
    }
    update(e, n) {
      return n.className != this.className ? false : (this.adjust(e), true);
    }
    adjust(e) {
      e.style.left = this.left + "px", e.style.top = this.top + "px", this.width != null && (e.style.width = this.width + "px"), e.style.height = this.height + "px";
    }
    eq(e) {
      return this.left == e.left && this.top == e.top && this.width == e.width && this.height == e.height && this.className == e.className;
    }
    static forRange(e, n, r) {
      if (r.empty) {
        let i = e.coordsAtPos(r.head, r.assoc || 1);
        if (!i)
          return [];
        let o = yL(e);
        return [
          new uf(n, i.left - o.left, i.top - o.top, null, i.bottom - i.top)
        ];
      } else
        return BU(e, n, r);
    }
  }
  function yL(t) {
    let e = t.scrollDOM.getBoundingClientRect();
    return {
      left: (t.textDirection == Je.LTR ? e.left : e.right - t.scrollDOM.clientWidth * t.scaleX) - t.scrollDOM.scrollLeft * t.scaleX,
      top: e.top - t.scrollDOM.scrollTop * t.scaleY
    };
  }
  function iT(t, e, n, r) {
    let i = t.coordsAtPos(e, n * 2);
    if (!i)
      return r;
    let o = t.dom.getBoundingClientRect(), s = (i.top + i.bottom) / 2, a = t.posAtCoords({
      x: o.left + 1,
      y: s
    }), l = t.posAtCoords({
      x: o.right - 1,
      y: s
    });
    return a == null || l == null ? r : {
      from: Math.max(r.from, Math.min(a, l)),
      to: Math.min(r.to, Math.max(a, l))
    };
  }
  function BU(t, e, n) {
    if (n.to <= t.viewport.from || n.from >= t.viewport.to)
      return [];
    let r = Math.max(n.from, t.viewport.from), i = Math.min(n.to, t.viewport.to), o = t.textDirection == Je.LTR, s = t.contentDOM, a = s.getBoundingClientRect(), l = yL(t), c = s.querySelector(".cm-line"), u = c && window.getComputedStyle(c), h = a.left + (u ? parseInt(u.paddingLeft) + Math.min(0, parseInt(u.textIndent)) : 0), p = a.right - (u ? parseInt(u.paddingRight) : 0), v = c1(t, r, 1), y = c1(t, i, -1), S = v.type == nn.Text ? v : null, T = y.type == nn.Text ? y : null;
    if (S && (t.lineWrapping || v.widgetLineBreaks) && (S = iT(t, r, 1, S)), T && (t.lineWrapping || y.widgetLineBreaks) && (T = iT(t, i, -1, T)), S && T && S.from == T.from && S.to == T.to)
      return k(C(n.from, n.to, S));
    {
      let L = S ? C(n.from, null, S) : O(v, false), D = T ? C(null, n.to, T) : O(y, true), R = [];
      return (S || v).to < (T || y).from - (S && T ? 1 : 0) || v.widgetLineBreaks > 1 && L.bottom + t.defaultLineHeight / 2 < D.top ? R.push(w(h, L.bottom, p, D.top)) : L.bottom < D.top && t.elementAtHeight((L.bottom + D.top) / 2).type == nn.Text && (L.bottom = D.top = (L.bottom + D.top) / 2), k(L).concat(R).concat(k(D));
    }
    function w(L, D, R, F) {
      return new uf(e, L - l.left, D - l.top, Math.max(0, R - L), F - D);
    }
    function k({ top: L, bottom: D, horizontal: R }) {
      let F = [];
      for (let K = 0; K < R.length; K += 2)
        F.push(w(R[K], L, R[K + 1], D));
      return F;
    }
    function C(L, D, R) {
      let F = 1e9, K = -1e9, Y = [];
      function te(ye, Ce, Le, ee, V) {
        let oe = t.coordsAtPos(ye, ye == R.to ? -2 : 2), he = t.coordsAtPos(Le, Le == R.from ? 2 : -2);
        !oe || !he || (F = Math.min(oe.top, he.top, F), K = Math.max(oe.bottom, he.bottom, K), V == Je.LTR ? Y.push(o && Ce ? h : oe.left, o && ee ? p : he.right) : Y.push(!o && ee ? h : he.left, !o && Ce ? p : oe.right));
      }
      let ne = L ?? R.from, ae = D ?? R.to;
      for (let ye of t.visibleRanges)
        if (ye.to > ne && ye.from < ae)
          for (let Ce = Math.max(ye.from, ne), Le = Math.min(ye.to, ae); ; ) {
            let ee = t.state.doc.lineAt(Ce);
            for (let V of t.bidiSpans(ee)) {
              let oe = V.from + ee.from, he = V.to + ee.from;
              if (oe >= Le)
                break;
              he > Ce && te(Math.max(oe, Ce), L == null && oe <= ne, Math.min(he, Le), D == null && he >= ae, V.dir);
            }
            if (Ce = ee.to + 1, Ce >= Le)
              break;
          }
      return Y.length == 0 && te(ne, L == null, ae, D == null, t.textDirection), {
        top: F,
        bottom: K,
        horizontal: Y
      };
    }
    function O(L, D) {
      let R = a.top + (D ? L.top : L.bottom);
      return {
        top: R,
        bottom: R,
        horizontal: []
      };
    }
  }
  function NU(t, e) {
    return t.constructor == e.constructor && t.eq(e);
  }
  class $U {
    constructor(e, n) {
      this.view = e, this.layer = n, this.drawn = [], this.scaleX = 1, this.scaleY = 1, this.measureReq = {
        read: this.measure.bind(this),
        write: this.draw.bind(this)
      }, this.dom = e.scrollDOM.appendChild(document.createElement("div")), this.dom.classList.add("cm-layer"), n.above && this.dom.classList.add("cm-layer-above"), n.class && this.dom.classList.add(n.class), this.scale(), this.dom.setAttribute("aria-hidden", "true"), this.setOrder(e.state), e.requestMeasure(this.measureReq), n.mount && n.mount(this.dom, e);
    }
    update(e) {
      e.startState.facet(wd) != e.state.facet(wd) && this.setOrder(e.state), (this.layer.update(e, this.dom) || e.geometryChanged) && (this.scale(), e.view.requestMeasure(this.measureReq));
    }
    docViewUpdate(e) {
      this.layer.updateOnDocViewUpdate !== false && e.requestMeasure(this.measureReq);
    }
    setOrder(e) {
      let n = 0, r = e.facet(wd);
      for (; n < r.length && r[n] != this.layer; )
        n++;
      this.dom.style.zIndex = String((this.layer.above ? 150 : -1) - n);
    }
    measure() {
      return this.layer.markers(this.view);
    }
    scale() {
      let { scaleX: e, scaleY: n } = this.view;
      (e != this.scaleX || n != this.scaleY) && (this.scaleX = e, this.scaleY = n, this.dom.style.transform = `scale(${1 / e}, ${1 / n})`);
    }
    draw(e) {
      if (e.length != this.drawn.length || e.some((n, r) => !NU(n, this.drawn[r]))) {
        let n = this.dom.firstChild, r = 0;
        for (let i of e)
          i.update && n && i.constructor && this.drawn[r].constructor && i.update(n, this.drawn[r]) ? (n = n.nextSibling, r++) : this.dom.insertBefore(i.draw(), n);
        for (; n; ) {
          let i = n.nextSibling;
          n.remove(), n = i;
        }
        this.drawn = e, de.safari && de.safari_version >= 26 && (this.dom.style.display = this.dom.firstChild ? "" : "none");
      }
    }
    destroy() {
      this.layer.destroy && this.layer.destroy(this.dom, this.view), this.dom.remove();
    }
  }
  const wd = me.define();
  function bL(t) {
    return [
      kt.define((e) => new $U(e, t)),
      wd.of(t)
    ];
  }
  const yl = me.define({
    combine(t) {
      return Oi(t, {
        cursorBlinkRate: 1200,
        drawRangeCursor: true
      }, {
        cursorBlinkRate: (e, n) => Math.min(e, n),
        drawRangeCursor: (e, n) => e || n
      });
    }
  });
  function zU(t = {}) {
    return [
      yl.of(t),
      VU,
      WU,
      HU,
      UO.of(true)
    ];
  }
  function FU(t) {
    return t.facet(yl);
  }
  function xL(t) {
    return t.startState.facet(yl) != t.state.facet(yl);
  }
  const VU = bL({
    above: true,
    markers(t) {
      let { state: e } = t, n = e.facet(yl), r = [];
      for (let i of e.selection.ranges) {
        let o = i == e.selection.main;
        if (i.empty || n.drawRangeCursor) {
          let s = o ? "cm-cursor cm-cursor-primary" : "cm-cursor cm-cursor-secondary", a = i.empty ? i : q.cursor(i.head, i.head > i.anchor ? -1 : 1);
          for (let l of uf.forRange(t, s, a))
            r.push(l);
        }
      }
      return r;
    },
    update(t, e) {
      t.transactions.some((r) => r.selection) && (e.style.animationName = e.style.animationName == "cm-blink" ? "cm-blink2" : "cm-blink");
      let n = xL(t);
      return n && oT(t.state, e), t.docChanged || t.selectionSet || n;
    },
    mount(t, e) {
      oT(e.state, t);
    },
    class: "cm-cursorLayer"
  });
  function oT(t, e) {
    e.style.animationDuration = t.facet(yl).cursorBlinkRate + "ms";
  }
  const WU = bL({
    above: false,
    markers(t) {
      return t.state.selection.ranges.map((e) => e.empty ? [] : uf.forRange(t, "cm-selectionBackground", e)).reduce((e, n) => e.concat(n));
    },
    update(t, e) {
      return t.docChanged || t.selectionSet || t.viewportChanged || xL(t);
    },
    class: "cm-selectionLayer"
  }), HU = ns.highest(ue.theme({
    ".cm-line": {
      "& ::selection, &::selection": {
        backgroundColor: "transparent !important"
      },
      caretColor: "transparent !important"
    },
    ".cm-content": {
      caretColor: "transparent !important",
      "& :focus": {
        caretColor: "initial !important",
        "&::selection, & ::selection": {
          backgroundColor: "Highlight !important"
        }
      }
    }
  })), SL = Ee.define({
    map(t, e) {
      return t == null ? null : e.mapPos(t);
    }
  }), Sc = Kt.define({
    create() {
      return null;
    },
    update(t, e) {
      return t != null && (t = e.changes.mapPos(t)), e.effects.reduce((n, r) => r.is(SL) ? r.value : n, t);
    }
  }), jU = kt.fromClass(class {
    constructor(t) {
      this.view = t, this.cursor = null, this.measureReq = {
        read: this.readPos.bind(this),
        write: this.drawCursor.bind(this)
      };
    }
    update(t) {
      var e;
      let n = t.state.field(Sc);
      n == null ? this.cursor != null && ((e = this.cursor) === null || e === void 0 || e.remove(), this.cursor = null) : (this.cursor || (this.cursor = this.view.scrollDOM.appendChild(document.createElement("div")), this.cursor.className = "cm-dropCursor"), (t.startState.field(Sc) != n || t.docChanged || t.geometryChanged) && this.view.requestMeasure(this.measureReq));
    }
    readPos() {
      let { view: t } = this, e = t.state.field(Sc), n = e != null && t.coordsAtPos(e);
      if (!n)
        return null;
      let r = t.scrollDOM.getBoundingClientRect();
      return {
        left: n.left - r.left + t.scrollDOM.scrollLeft * t.scaleX,
        top: n.top - r.top + t.scrollDOM.scrollTop * t.scaleY,
        height: n.bottom - n.top
      };
    }
    drawCursor(t) {
      if (this.cursor) {
        let { scaleX: e, scaleY: n } = this.view;
        t ? (this.cursor.style.left = t.left / e + "px", this.cursor.style.top = t.top / n + "px", this.cursor.style.height = t.height / n + "px") : this.cursor.style.left = "-100000px";
      }
    }
    destroy() {
      this.cursor && this.cursor.remove();
    }
    setDropPos(t) {
      this.view.state.field(Sc) != t && this.view.dispatch({
        effects: SL.of(t)
      });
    }
  }, {
    eventObservers: {
      dragover(t) {
        this.setDropPos(this.view.posAtCoords({
          x: t.clientX,
          y: t.clientY
        }));
      },
      dragleave(t) {
        (t.target == this.view.contentDOM || !this.view.contentDOM.contains(t.relatedTarget)) && this.setDropPos(null);
      },
      dragend() {
        this.setDropPos(null);
      },
      drop() {
        this.setDropPos(null);
      }
    }
  });
  function UU() {
    return [
      Sc,
      jU
    ];
  }
  function sT(t, e, n, r, i) {
    e.lastIndex = 0;
    for (let o = t.iterRange(n, r), s = n, a; !o.next().done; s += o.value.length)
      if (!o.lineBreak)
        for (; a = e.exec(o.value); )
          i(s + a.index, a);
  }
  function KU(t, e) {
    let n = t.visibleRanges;
    if (n.length == 1 && n[0].from == t.viewport.from && n[0].to == t.viewport.to)
      return n;
    let r = [];
    for (let { from: i, to: o } of n)
      i = Math.max(t.state.doc.lineAt(i).from, i - e), o = Math.min(t.state.doc.lineAt(o).to, o + e), r.length && r[r.length - 1].to >= i ? r[r.length - 1].to = o : r.push({
        from: i,
        to: o
      });
    return r;
  }
  class qU {
    constructor(e) {
      const { regexp: n, decoration: r, decorate: i, boundary: o, maxLength: s = 1e3 } = e;
      if (!n.global)
        throw new RangeError("The regular expression given to MatchDecorator should have its 'g' flag set");
      if (this.regexp = n, i)
        this.addMatch = (a, l, c, u) => i(u, c, c + a[0].length, a, l);
      else if (typeof r == "function")
        this.addMatch = (a, l, c, u) => {
          let h = r(a, l, c);
          h && u(c, c + a[0].length, h);
        };
      else if (r)
        this.addMatch = (a, l, c, u) => u(c, c + a[0].length, r);
      else
        throw new RangeError("Either 'decorate' or 'decoration' should be provided to MatchDecorator");
      this.boundary = o, this.maxLength = s;
    }
    createDeco(e) {
      let n = new Ai(), r = n.add.bind(n);
      for (let { from: i, to: o } of KU(e, this.maxLength))
        sT(e.state.doc, this.regexp, i, o, (s, a) => this.addMatch(a, e, s, r));
      return n.finish();
    }
    updateDeco(e, n) {
      let r = 1e9, i = -1;
      return e.docChanged && e.changes.iterChanges((o, s, a, l) => {
        l >= e.view.viewport.from && a <= e.view.viewport.to && (r = Math.min(a, r), i = Math.max(l, i));
      }), e.viewportMoved || i - r > 1e3 ? this.createDeco(e.view) : i > -1 ? this.updateRange(e.view, n.map(e.changes), r, i) : n;
    }
    updateRange(e, n, r, i) {
      for (let o of e.visibleRanges) {
        let s = Math.max(o.from, r), a = Math.min(o.to, i);
        if (a >= s) {
          let l = e.state.doc.lineAt(s), c = l.to < a ? e.state.doc.lineAt(a) : l, u = Math.max(o.from, l.from), h = Math.min(o.to, c.to);
          if (this.boundary) {
            for (; s > l.from; s--)
              if (this.boundary.test(l.text[s - 1 - l.from])) {
                u = s;
                break;
              }
            for (; a < c.to; a++)
              if (this.boundary.test(c.text[a - c.from])) {
                h = a;
                break;
              }
          }
          let p = [], v, y = (S, T, w) => p.push(w.range(S, T));
          if (l == c)
            for (this.regexp.lastIndex = u - l.from; (v = this.regexp.exec(l.text)) && v.index < h - l.from; )
              this.addMatch(v, e, v.index + l.from, y);
          else
            sT(e.state.doc, this.regexp, u, h, (S, T) => this.addMatch(T, e, S, y));
          n = n.update({
            filterFrom: u,
            filterTo: h,
            filter: (S, T) => S < u || T > h,
            add: p
          });
        }
      }
      return n;
    }
  }
  const g1 = /x/.unicode != null ? "gu" : "g", GU = new RegExp(`[\0-\b
-\x7F-\x9F\xAD\u061C\u200B\u200E\u200F\u2028\u2029\u202D\u202E\u2066\u2067\u2069\uFEFF\uFFF9-\uFFFC]`, g1), YU = {
    0: "null",
    7: "bell",
    8: "backspace",
    10: "newline",
    11: "vertical tab",
    13: "carriage return",
    27: "escape",
    8203: "zero width space",
    8204: "zero width non-joiner",
    8205: "zero width joiner",
    8206: "left-to-right mark",
    8207: "right-to-left mark",
    8232: "line separator",
    8237: "left-to-right override",
    8238: "right-to-left override",
    8294: "left-to-right isolate",
    8295: "right-to-left isolate",
    8297: "pop directional isolate",
    8233: "paragraph separator",
    65279: "zero width no-break space",
    65532: "object replacement"
  };
  let W0 = null;
  function XU() {
    var t;
    if (W0 == null && typeof document < "u" && document.body) {
      let e = document.body.style;
      W0 = ((t = e.tabSize) !== null && t !== void 0 ? t : e.MozTabSize) != null;
    }
    return W0 || false;
  }
  const kd = me.define({
    combine(t) {
      let e = Oi(t, {
        render: null,
        specialChars: GU,
        addSpecialChars: null
      });
      return (e.replaceTabs = !XU()) && (e.specialChars = new RegExp("	|" + e.specialChars.source, g1)), e.addSpecialChars && (e.specialChars = new RegExp(e.specialChars.source + "|" + e.addSpecialChars.source, g1)), e;
    }
  });
  function QU(t = {}) {
    return [
      kd.of(t),
      JU()
    ];
  }
  let aT = null;
  function JU() {
    return aT || (aT = kt.fromClass(class {
      constructor(t) {
        this.view = t, this.decorations = be.none, this.decorationCache = /* @__PURE__ */ Object.create(null), this.decorator = this.makeDecorator(t.state.facet(kd)), this.decorations = this.decorator.createDeco(t);
      }
      makeDecorator(t) {
        return new qU({
          regexp: t.specialChars,
          decoration: (e, n, r) => {
            let { doc: i } = n.state, o = On(e[0], 0);
            if (o == 9) {
              let s = i.lineAt(r), a = n.state.tabSize, l = El(s.text, a, r - s.from);
              return be.replace({
                widget: new nK((a - l % a) * this.view.defaultCharacterWidth / this.view.scaleX)
              });
            }
            return this.decorationCache[o] || (this.decorationCache[o] = be.replace({
              widget: new tK(t, o)
            }));
          },
          boundary: t.replaceTabs ? void 0 : /[^]/
        });
      }
      update(t) {
        let e = t.state.facet(kd);
        t.startState.facet(kd) != e ? (this.decorator = this.makeDecorator(e), this.decorations = this.decorator.createDeco(t.view)) : this.decorations = this.decorator.updateDeco(t, this.decorations);
      }
    }, {
      decorations: (t) => t.decorations
    }));
  }
  const ZU = "\u2022";
  function eK(t) {
    return t >= 32 ? ZU : t == 10 ? "\u2424" : String.fromCharCode(9216 + t);
  }
  class tK extends Li {
    constructor(e, n) {
      super(), this.options = e, this.code = n;
    }
    eq(e) {
      return e.code == this.code;
    }
    toDOM(e) {
      let n = eK(this.code), r = e.state.phrase("Control character") + " " + (YU[this.code] || "0x" + this.code.toString(16)), i = this.options.render && this.options.render(this.code, r, n);
      if (i)
        return i;
      let o = document.createElement("span");
      return o.textContent = n, o.title = r, o.setAttribute("aria-label", r), o.className = "cm-specialChar", o;
    }
    ignoreEvent() {
      return false;
    }
  }
  class nK extends Li {
    constructor(e) {
      super(), this.width = e;
    }
    eq(e) {
      return e.width == this.width;
    }
    toDOM() {
      let e = document.createElement("span");
      return e.textContent = "	", e.className = "cm-tab", e.style.width = this.width + "px", e;
    }
    ignoreEvent() {
      return false;
    }
  }
  function rK() {
    return oK;
  }
  const iK = be.line({
    class: "cm-activeLine"
  }), oK = kt.fromClass(class {
    constructor(t) {
      this.decorations = this.getDeco(t);
    }
    update(t) {
      (t.docChanged || t.selectionSet) && (this.decorations = this.getDeco(t.view));
    }
    getDeco(t) {
      let e = -1, n = [];
      for (let r of t.state.selection.ranges) {
        let i = t.lineBlockAt(r.head);
        i.from > e && (n.push(iK.range(i.from)), e = i.from);
      }
      return be.set(n);
    }
  }, {
    decorations: (t) => t.decorations
  });
  class sK extends Li {
    constructor(e) {
      super(), this.content = e;
    }
    toDOM(e) {
      let n = document.createElement("span");
      return n.className = "cm-placeholder", n.style.pointerEvents = "none", n.appendChild(typeof this.content == "string" ? document.createTextNode(this.content) : typeof this.content == "function" ? this.content(e) : this.content.cloneNode(true)), n.setAttribute("aria-hidden", "true"), n;
    }
    coordsAt(e) {
      let n = e.firstChild ? Xc(e.firstChild) : [];
      if (!n.length)
        return null;
      let r = window.getComputedStyle(e.parentNode), i = $u(n[0], r.direction != "rtl"), o = parseInt(r.lineHeight);
      return i.bottom - i.top > o * 1.5 ? {
        left: i.left,
        right: i.right,
        top: i.top,
        bottom: i.top + o
      } : i;
    }
    ignoreEvent() {
      return false;
    }
  }
  function aK(t) {
    let e = kt.fromClass(class {
      constructor(n) {
        this.view = n, this.placeholder = t ? be.set([
          be.widget({
            widget: new sK(t),
            side: 1
          }).range(0)
        ]) : be.none;
      }
      get decorations() {
        return this.view.state.doc.length ? be.none : this.placeholder;
      }
    }, {
      decorations: (n) => n.decorations
    });
    return typeof t == "string" ? [
      e,
      ue.contentAttributes.of({
        "aria-placeholder": t
      })
    ] : e;
  }
  const v1 = 2e3;
  function lK(t, e, n) {
    let r = Math.min(e.line, n.line), i = Math.max(e.line, n.line), o = [];
    if (e.off > v1 || n.off > v1 || e.col < 0 || n.col < 0) {
      let s = Math.min(e.off, n.off), a = Math.max(e.off, n.off);
      for (let l = r; l <= i; l++) {
        let c = t.doc.line(l);
        c.length <= a && o.push(q.range(c.from + s, c.to + a));
      }
    } else {
      let s = Math.min(e.col, n.col), a = Math.max(e.col, n.col);
      for (let l = r; l <= i; l++) {
        let c = t.doc.line(l), u = Xy(c.text, s, t.tabSize, true);
        if (u < 0)
          o.push(q.cursor(c.to));
        else {
          let h = Xy(c.text, a, t.tabSize);
          o.push(q.range(c.from + u, c.from + h));
        }
      }
    }
    return o;
  }
  function cK(t, e) {
    let n = t.coordsAtPos(t.viewport.from);
    return n ? Math.round(Math.abs((n.left - e) / t.defaultCharacterWidth)) : -1;
  }
  function lT(t, e) {
    let n = t.posAtCoords({
      x: e.clientX,
      y: e.clientY
    }, false), r = t.state.doc.lineAt(n), i = n - r.from, o = i > v1 ? -1 : i == r.length ? cK(t, e.clientX) : El(r.text, t.state.tabSize, n - r.from);
    return {
      line: r.number,
      col: o,
      off: i
    };
  }
  function uK(t, e) {
    let n = lT(t, e), r = t.state.selection;
    return n ? {
      update(i) {
        if (i.docChanged) {
          let o = i.changes.mapPos(i.startState.doc.line(n.line).from), s = i.state.doc.lineAt(o);
          n = {
            line: s.number,
            col: n.col,
            off: Math.min(n.off, s.length)
          }, r = r.map(i.changes);
        }
      },
      get(i, o, s) {
        let a = lT(t, i);
        if (!a)
          return r;
        let l = lK(t.state, n, a);
        return l.length ? s ? q.create(l.concat(r.ranges)) : q.create(l) : r;
      }
    } : null;
  }
  function fK(t) {
    let e = (t == null ? void 0 : t.eventFilter) || ((n) => n.altKey && n.button == 0);
    return ue.mouseSelectionStyle.of((n, r) => e(r) ? uK(n, r) : null);
  }
  const hK = {
    Alt: [
      18,
      (t) => !!t.altKey
    ],
    Control: [
      17,
      (t) => !!t.ctrlKey
    ],
    Shift: [
      16,
      (t) => !!t.shiftKey
    ],
    Meta: [
      91,
      (t) => !!t.metaKey
    ]
  }, dK = {
    style: "cursor: crosshair"
  };
  function pK(t = {}) {
    let [e, n] = hK[t.key || "Alt"], r = kt.fromClass(class {
      constructor(i) {
        this.view = i, this.isDown = false;
      }
      set(i) {
        this.isDown != i && (this.isDown = i, this.view.update([]));
      }
    }, {
      eventObservers: {
        keydown(i) {
          this.set(i.keyCode == e || n(i));
        },
        keyup(i) {
          (i.keyCode == e || !n(i)) && this.set(false);
        },
        mousemove(i) {
          this.set(n(i));
        }
      }
    });
    return [
      r,
      ue.contentAttributes.of((i) => {
        var o;
        return !((o = i.plugin(r)) === null || o === void 0) && o.isDown ? dK : null;
      })
    ];
  }
  const Lh = "-10000px";
  class wL {
    constructor(e, n, r, i) {
      this.facet = n, this.createTooltipView = r, this.removeTooltipView = i, this.input = e.state.facet(n), this.tooltips = this.input.filter((s) => s);
      let o = null;
      this.tooltipViews = this.tooltips.map((s) => o = r(s, o));
    }
    update(e, n) {
      var r;
      let i = e.state.facet(this.facet), o = i.filter((l) => l);
      if (i === this.input) {
        for (let l of this.tooltipViews)
          l.update && l.update(e);
        return false;
      }
      let s = [], a = n ? [] : null;
      for (let l = 0; l < o.length; l++) {
        let c = o[l], u = -1;
        if (!!c) {
          for (let h = 0; h < this.tooltips.length; h++) {
            let p = this.tooltips[h];
            p && p.create == c.create && (u = h);
          }
          if (u < 0)
            s[l] = this.createTooltipView(c, l ? s[l - 1] : null), a && (a[l] = !!c.above);
          else {
            let h = s[l] = this.tooltipViews[u];
            a && (a[l] = n[u]), h.update && h.update(e);
          }
        }
      }
      for (let l of this.tooltipViews)
        s.indexOf(l) < 0 && (this.removeTooltipView(l), (r = l.destroy) === null || r === void 0 || r.call(l));
      return n && (a.forEach((l, c) => n[c] = l), n.length = a.length), this.input = i, this.tooltips = o, this.tooltipViews = s, true;
    }
  }
  function mK(t) {
    let e = t.dom.ownerDocument.documentElement;
    return {
      top: 0,
      left: 0,
      bottom: e.clientHeight,
      right: e.clientWidth
    };
  }
  const H0 = me.define({
    combine: (t) => {
      var e, n, r;
      return {
        position: de.ios ? "absolute" : ((e = t.find((i) => i.position)) === null || e === void 0 ? void 0 : e.position) || "fixed",
        parent: ((n = t.find((i) => i.parent)) === null || n === void 0 ? void 0 : n.parent) || null,
        tooltipSpace: ((r = t.find((i) => i.tooltipSpace)) === null || r === void 0 ? void 0 : r.tooltipSpace) || mK
      };
    }
  }), cT = /* @__PURE__ */ new WeakMap(), Wx = kt.fromClass(class {
    constructor(t) {
      this.view = t, this.above = [], this.inView = true, this.madeAbsolute = false, this.lastTransaction = 0, this.measureTimeout = -1;
      let e = t.state.facet(H0);
      this.position = e.position, this.parent = e.parent, this.classes = t.themeClasses, this.createContainer(), this.measureReq = {
        read: this.readMeasure.bind(this),
        write: this.writeMeasure.bind(this),
        key: this
      }, this.resizeObserver = typeof ResizeObserver == "function" ? new ResizeObserver(() => this.measureSoon()) : null, this.manager = new wL(t, Hx, (n, r) => this.createTooltip(n, r), (n) => {
        this.resizeObserver && this.resizeObserver.unobserve(n.dom), n.dom.remove();
      }), this.above = this.manager.tooltips.map((n) => !!n.above), this.intersectionObserver = typeof IntersectionObserver == "function" ? new IntersectionObserver((n) => {
        Date.now() > this.lastTransaction - 50 && n.length > 0 && n[n.length - 1].intersectionRatio < 1 && this.measureSoon();
      }, {
        threshold: [
          1
        ]
      }) : null, this.observeIntersection(), t.win.addEventListener("resize", this.measureSoon = this.measureSoon.bind(this)), this.maybeMeasure();
    }
    createContainer() {
      this.parent ? (this.container = document.createElement("div"), this.container.style.position = "relative", this.container.className = this.view.themeClasses, this.parent.appendChild(this.container)) : this.container = this.view.dom;
    }
    observeIntersection() {
      if (this.intersectionObserver) {
        this.intersectionObserver.disconnect();
        for (let t of this.manager.tooltipViews)
          this.intersectionObserver.observe(t.dom);
      }
    }
    measureSoon() {
      this.measureTimeout < 0 && (this.measureTimeout = setTimeout(() => {
        this.measureTimeout = -1, this.maybeMeasure();
      }, 50));
    }
    update(t) {
      t.transactions.length && (this.lastTransaction = Date.now());
      let e = this.manager.update(t, this.above);
      e && this.observeIntersection();
      let n = e || t.geometryChanged, r = t.state.facet(H0);
      if (r.position != this.position && !this.madeAbsolute) {
        this.position = r.position;
        for (let i of this.manager.tooltipViews)
          i.dom.style.position = this.position;
        n = true;
      }
      if (r.parent != this.parent) {
        this.parent && this.container.remove(), this.parent = r.parent, this.createContainer();
        for (let i of this.manager.tooltipViews)
          this.container.appendChild(i.dom);
        n = true;
      } else
        this.parent && this.view.themeClasses != this.classes && (this.classes = this.container.className = this.view.themeClasses);
      n && this.maybeMeasure();
    }
    createTooltip(t, e) {
      let n = t.create(this.view), r = e ? e.dom : null;
      if (n.dom.classList.add("cm-tooltip"), t.arrow && !n.dom.querySelector(".cm-tooltip > .cm-tooltip-arrow")) {
        let i = document.createElement("div");
        i.className = "cm-tooltip-arrow", n.dom.appendChild(i);
      }
      return n.dom.style.position = this.position, n.dom.style.top = Lh, n.dom.style.left = "0px", this.container.insertBefore(n.dom, r), n.mount && n.mount(this.view), this.resizeObserver && this.resizeObserver.observe(n.dom), n;
    }
    destroy() {
      var t, e, n;
      this.view.win.removeEventListener("resize", this.measureSoon);
      for (let r of this.manager.tooltipViews)
        r.dom.remove(), (t = r.destroy) === null || t === void 0 || t.call(r);
      this.parent && this.container.remove(), (e = this.resizeObserver) === null || e === void 0 || e.disconnect(), (n = this.intersectionObserver) === null || n === void 0 || n.disconnect(), clearTimeout(this.measureTimeout);
    }
    readMeasure() {
      let t = 1, e = 1, n = false;
      if (this.position == "fixed" && this.manager.tooltipViews.length) {
        let { dom: o } = this.manager.tooltipViews[0];
        if (de.safari) {
          let s = o.getBoundingClientRect();
          n = Math.abs(s.top + 1e4) > 1 || Math.abs(s.left) > 1;
        } else
          n = !!o.offsetParent && o.offsetParent != this.container.ownerDocument.body;
      }
      if (n || this.position == "absolute")
        if (this.parent) {
          let o = this.parent.getBoundingClientRect();
          o.width && o.height && (t = o.width / this.parent.offsetWidth, e = o.height / this.parent.offsetHeight);
        } else
          ({ scaleX: t, scaleY: e } = this.view.viewState);
      let r = this.view.scrollDOM.getBoundingClientRect(), i = $x(this.view);
      return {
        visible: {
          left: r.left + i.left,
          top: r.top + i.top,
          right: r.right - i.right,
          bottom: r.bottom - i.bottom
        },
        parent: this.parent ? this.container.getBoundingClientRect() : this.view.dom.getBoundingClientRect(),
        pos: this.manager.tooltips.map((o, s) => {
          let a = this.manager.tooltipViews[s];
          return a.getCoords ? a.getCoords(o.pos) : this.view.coordsAtPos(o.pos);
        }),
        size: this.manager.tooltipViews.map(({ dom: o }) => o.getBoundingClientRect()),
        space: this.view.state.facet(H0).tooltipSpace(this.view),
        scaleX: t,
        scaleY: e,
        makeAbsolute: n
      };
    }
    writeMeasure(t) {
      var e;
      if (t.makeAbsolute) {
        this.madeAbsolute = true, this.position = "absolute";
        for (let a of this.manager.tooltipViews)
          a.dom.style.position = "absolute";
      }
      let { visible: n, space: r, scaleX: i, scaleY: o } = t, s = [];
      for (let a = 0; a < this.manager.tooltips.length; a++) {
        let l = this.manager.tooltips[a], c = this.manager.tooltipViews[a], { dom: u } = c, h = t.pos[a], p = t.size[a];
        if (!h || l.clip !== false && (h.bottom <= Math.max(n.top, r.top) || h.top >= Math.min(n.bottom, r.bottom) || h.right < Math.max(n.left, r.left) - 0.1 || h.left > Math.min(n.right, r.right) + 0.1)) {
          u.style.top = Lh;
          continue;
        }
        let v = l.arrow ? c.dom.querySelector(".cm-tooltip-arrow") : null, y = v ? 7 : 0, S = p.right - p.left, T = (e = cT.get(c)) !== null && e !== void 0 ? e : p.bottom - p.top, w = c.offset || vK, k = this.view.textDirection == Je.LTR, C = p.width > r.right - r.left ? k ? r.left : r.right - p.width : k ? Math.max(r.left, Math.min(h.left - (v ? 14 : 0) + w.x, r.right - S)) : Math.min(Math.max(r.left, h.left - S + (v ? 14 : 0) - w.x), r.right - S), O = this.above[a];
        !l.strictSide && (O ? h.top - T - y - w.y < r.top : h.bottom + T + y + w.y > r.bottom) && O == r.bottom - h.bottom > h.top - r.top && (O = this.above[a] = !O);
        let L = (O ? h.top - r.top : r.bottom - h.bottom) - y;
        if (L < T && c.resize !== false) {
          if (L < this.view.defaultLineHeight) {
            u.style.top = Lh;
            continue;
          }
          cT.set(c, T), u.style.height = (T = L) / o + "px";
        } else
          u.style.height && (u.style.height = "");
        let D = O ? h.top - T - y - w.y : h.bottom + y + w.y, R = C + S;
        if (c.overlap !== true)
          for (let F of s)
            F.left < R && F.right > C && F.top < D + T && F.bottom > D && (D = O ? F.top - T - 2 - y : F.bottom + y + 2);
        if (this.position == "absolute" ? (u.style.top = (D - t.parent.top) / o + "px", uT(u, (C - t.parent.left) / i)) : (u.style.top = D / o + "px", uT(u, C / i)), v) {
          let F = h.left + (k ? w.x : -w.x) - (C + 14 - 7);
          v.style.left = F / i + "px";
        }
        c.overlap !== true && s.push({
          left: C,
          top: D,
          right: R,
          bottom: D + T
        }), u.classList.toggle("cm-tooltip-above", O), u.classList.toggle("cm-tooltip-below", !O), c.positioned && c.positioned(t.space);
      }
    }
    maybeMeasure() {
      if (this.manager.tooltips.length && (this.view.inView && this.view.requestMeasure(this.measureReq), this.inView != this.view.inView && (this.inView = this.view.inView, !this.inView)))
        for (let t of this.manager.tooltipViews)
          t.dom.style.top = Lh;
    }
  }, {
    eventObservers: {
      scroll() {
        this.maybeMeasure();
      }
    }
  });
  function uT(t, e) {
    let n = parseInt(t.style.left, 10);
    (isNaN(n) || Math.abs(e - n) > 1) && (t.style.left = e + "px");
  }
  const gK = ue.baseTheme({
    ".cm-tooltip": {
      zIndex: 500,
      boxSizing: "border-box"
    },
    "&light .cm-tooltip": {
      border: "1px solid #bbb",
      backgroundColor: "#f5f5f5"
    },
    "&light .cm-tooltip-section:not(:first-child)": {
      borderTop: "1px solid #bbb"
    },
    "&dark .cm-tooltip": {
      backgroundColor: "#333338",
      color: "white"
    },
    ".cm-tooltip-arrow": {
      height: `${7}px`,
      width: `${7 * 2}px`,
      position: "absolute",
      zIndex: -1,
      overflow: "hidden",
      "&:before, &:after": {
        content: "''",
        position: "absolute",
        width: 0,
        height: 0,
        borderLeft: `${7}px solid transparent`,
        borderRight: `${7}px solid transparent`
      },
      ".cm-tooltip-above &": {
        bottom: `-${7}px`,
        "&:before": {
          borderTop: `${7}px solid #bbb`
        },
        "&:after": {
          borderTop: `${7}px solid #f5f5f5`,
          bottom: "1px"
        }
      },
      ".cm-tooltip-below &": {
        top: `-${7}px`,
        "&:before": {
          borderBottom: `${7}px solid #bbb`
        },
        "&:after": {
          borderBottom: `${7}px solid #f5f5f5`,
          top: "1px"
        }
      }
    },
    "&dark .cm-tooltip .cm-tooltip-arrow": {
      "&:before": {
        borderTopColor: "#333338",
        borderBottomColor: "#333338"
      },
      "&:after": {
        borderTopColor: "transparent",
        borderBottomColor: "transparent"
      }
    }
  }), vK = {
    x: 0,
    y: 0
  }, Hx = me.define({
    enables: [
      Wx,
      gK
    ]
  }), Mp = me.define({
    combine: (t) => t.reduce((e, n) => e.concat(n), [])
  });
  class jm {
    static create(e) {
      return new jm(e);
    }
    constructor(e) {
      this.view = e, this.mounted = false, this.dom = document.createElement("div"), this.dom.classList.add("cm-tooltip-hover"), this.manager = new wL(e, Mp, (n, r) => this.createHostedView(n, r), (n) => n.dom.remove());
    }
    createHostedView(e, n) {
      let r = e.create(this.view);
      return r.dom.classList.add("cm-tooltip-section"), this.dom.insertBefore(r.dom, n ? n.dom.nextSibling : this.dom.firstChild), this.mounted && r.mount && r.mount(this.view), r;
    }
    mount(e) {
      for (let n of this.manager.tooltipViews)
        n.mount && n.mount(e);
      this.mounted = true;
    }
    positioned(e) {
      for (let n of this.manager.tooltipViews)
        n.positioned && n.positioned(e);
    }
    update(e) {
      this.manager.update(e);
    }
    destroy() {
      var e;
      for (let n of this.manager.tooltipViews)
        (e = n.destroy) === null || e === void 0 || e.call(n);
    }
    passProp(e) {
      let n;
      for (let r of this.manager.tooltipViews) {
        let i = r[e];
        if (i !== void 0) {
          if (n === void 0)
            n = i;
          else if (n !== i)
            return;
        }
      }
      return n;
    }
    get offset() {
      return this.passProp("offset");
    }
    get getCoords() {
      return this.passProp("getCoords");
    }
    get overlap() {
      return this.passProp("overlap");
    }
    get resize() {
      return this.passProp("resize");
    }
  }
  const yK = Hx.compute([
    Mp
  ], (t) => {
    let e = t.facet(Mp);
    return e.length === 0 ? null : {
      pos: Math.min(...e.map((n) => n.pos)),
      end: Math.max(...e.map((n) => {
        var r;
        return (r = n.end) !== null && r !== void 0 ? r : n.pos;
      })),
      create: jm.create,
      above: e[0].above,
      arrow: e.some((n) => n.arrow)
    };
  });
  class bK {
    constructor(e, n, r, i, o) {
      this.view = e, this.source = n, this.field = r, this.setHover = i, this.hoverTime = o, this.hoverTimeout = -1, this.restartTimeout = -1, this.pending = null, this.lastMove = {
        x: 0,
        y: 0,
        target: e.dom,
        time: 0
      }, this.checkHover = this.checkHover.bind(this), e.dom.addEventListener("mouseleave", this.mouseleave = this.mouseleave.bind(this)), e.dom.addEventListener("mousemove", this.mousemove = this.mousemove.bind(this));
    }
    update() {
      this.pending && (this.pending = null, clearTimeout(this.restartTimeout), this.restartTimeout = setTimeout(() => this.startHover(), 20));
    }
    get active() {
      return this.view.state.field(this.field);
    }
    checkHover() {
      if (this.hoverTimeout = -1, this.active.length)
        return;
      let e = Date.now() - this.lastMove.time;
      e < this.hoverTime ? this.hoverTimeout = setTimeout(this.checkHover, this.hoverTime - e) : this.startHover();
    }
    startHover() {
      clearTimeout(this.restartTimeout);
      let { view: e, lastMove: n } = this, r = e.docView.tile.nearest(n.target);
      if (!r)
        return;
      let i, o = 1;
      if (r.isWidget())
        i = r.posAtStart;
      else {
        if (i = e.posAtCoords(n), i == null)
          return;
        let a = e.coordsAtPos(i);
        if (!a || n.y < a.top || n.y > a.bottom || n.x < a.left - e.defaultCharacterWidth || n.x > a.right + e.defaultCharacterWidth)
          return;
        let l = e.bidiSpans(e.state.doc.lineAt(i)).find((u) => u.from <= i && u.to >= i), c = l && l.dir == Je.RTL ? -1 : 1;
        o = n.x < a.left ? -c : c;
      }
      let s = this.source(e, i, o);
      if (s == null ? void 0 : s.then) {
        let a = this.pending = {
          pos: i
        };
        s.then((l) => {
          this.pending == a && (this.pending = null, l && !(Array.isArray(l) && !l.length) && e.dispatch({
            effects: this.setHover.of(Array.isArray(l) ? l : [
              l
            ])
          }));
        }, (l) => In(e.state, l, "hover tooltip"));
      } else
        s && !(Array.isArray(s) && !s.length) && e.dispatch({
          effects: this.setHover.of(Array.isArray(s) ? s : [
            s
          ])
        });
    }
    get tooltip() {
      let e = this.view.plugin(Wx), n = e ? e.manager.tooltips.findIndex((r) => r.create == jm.create) : -1;
      return n > -1 ? e.manager.tooltipViews[n] : null;
    }
    mousemove(e) {
      var n, r;
      this.lastMove = {
        x: e.clientX,
        y: e.clientY,
        target: e.target,
        time: Date.now()
      }, this.hoverTimeout < 0 && (this.hoverTimeout = setTimeout(this.checkHover, this.hoverTime));
      let { active: i, tooltip: o } = this;
      if (i.length && o && !xK(o.dom, e) || this.pending) {
        let { pos: s } = i[0] || this.pending, a = (r = (n = i[0]) === null || n === void 0 ? void 0 : n.end) !== null && r !== void 0 ? r : s;
        (s == a ? this.view.posAtCoords(this.lastMove) != s : !SK(this.view, s, a, e.clientX, e.clientY)) && (this.view.dispatch({
          effects: this.setHover.of([])
        }), this.pending = null);
      }
    }
    mouseleave(e) {
      clearTimeout(this.hoverTimeout), this.hoverTimeout = -1;
      let { active: n } = this;
      if (n.length) {
        let { tooltip: r } = this;
        r && r.dom.contains(e.relatedTarget) ? this.watchTooltipLeave(r.dom) : this.view.dispatch({
          effects: this.setHover.of([])
        });
      }
    }
    watchTooltipLeave(e) {
      let n = (r) => {
        e.removeEventListener("mouseleave", n), this.active.length && !this.view.dom.contains(r.relatedTarget) && this.view.dispatch({
          effects: this.setHover.of([])
        });
      };
      e.addEventListener("mouseleave", n);
    }
    destroy() {
      clearTimeout(this.hoverTimeout), clearTimeout(this.restartTimeout), this.view.dom.removeEventListener("mouseleave", this.mouseleave), this.view.dom.removeEventListener("mousemove", this.mousemove);
    }
  }
  const Rh = 4;
  function xK(t, e) {
    let { left: n, right: r, top: i, bottom: o } = t.getBoundingClientRect(), s;
    if (s = t.querySelector(".cm-tooltip-arrow")) {
      let a = s.getBoundingClientRect();
      i = Math.min(a.top, i), o = Math.max(a.bottom, o);
    }
    return e.clientX >= n - Rh && e.clientX <= r + Rh && e.clientY >= i - Rh && e.clientY <= o + Rh;
  }
  function SK(t, e, n, r, i, o) {
    let s = t.scrollDOM.getBoundingClientRect(), a = t.documentTop + t.documentPadding.top + t.contentHeight;
    if (s.left > r || s.right < r || s.top > i || Math.min(s.bottom, a) < i)
      return false;
    let l = t.posAtCoords({
      x: r,
      y: i
    }, false);
    return l >= e && l <= n;
  }
  function wK(t, e = {}) {
    let n = Ee.define(), r = Kt.define({
      create() {
        return [];
      },
      update(i, o) {
        if (i.length && (e.hideOnChange && (o.docChanged || o.selection) ? i = [] : e.hideOn && (i = i.filter((s) => !e.hideOn(o, s))), o.docChanged)) {
          let s = [];
          for (let a of i) {
            let l = o.changes.mapPos(a.pos, -1, Zt.TrackDel);
            if (l != null) {
              let c = Object.assign(/* @__PURE__ */ Object.create(null), a);
              c.pos = l, c.end != null && (c.end = o.changes.mapPos(c.end)), s.push(c);
            }
          }
          i = s;
        }
        for (let s of o.effects)
          s.is(n) && (i = s.value), s.is(kK) && (i = []);
        return i;
      },
      provide: (i) => Mp.from(i)
    });
    return {
      active: r,
      extension: [
        r,
        kt.define((i) => new bK(i, t, r, n, e.hoverTime || 300)),
        yK
      ]
    };
  }
  function kL(t, e) {
    let n = t.plugin(Wx);
    if (!n)
      return null;
    let r = n.manager.tooltips.indexOf(e);
    return r < 0 ? null : n.manager.tooltipViews[r];
  }
  const kK = Ee.define(), fT = me.define({
    combine(t) {
      let e, n;
      for (let r of t)
        e = e || r.topContainer, n = n || r.bottomContainer;
      return {
        topContainer: e,
        bottomContainer: n
      };
    }
  });
  function jx(t, e) {
    let n = t.plugin(CL), r = n ? n.specs.indexOf(e) : -1;
    return r > -1 ? n.panels[r] : null;
  }
  const CL = kt.fromClass(class {
    constructor(t) {
      this.input = t.state.facet(Gs), this.specs = this.input.filter((n) => n), this.panels = this.specs.map((n) => n(t));
      let e = t.state.facet(fT);
      this.top = new _h(t, true, e.topContainer), this.bottom = new _h(t, false, e.bottomContainer), this.top.sync(this.panels.filter((n) => n.top)), this.bottom.sync(this.panels.filter((n) => !n.top));
      for (let n of this.panels)
        n.dom.classList.add("cm-panel"), n.mount && n.mount();
    }
    update(t) {
      let e = t.state.facet(fT);
      this.top.container != e.topContainer && (this.top.sync([]), this.top = new _h(t.view, true, e.topContainer)), this.bottom.container != e.bottomContainer && (this.bottom.sync([]), this.bottom = new _h(t.view, false, e.bottomContainer)), this.top.syncClasses(), this.bottom.syncClasses();
      let n = t.state.facet(Gs);
      if (n != this.input) {
        let r = n.filter((l) => l), i = [], o = [], s = [], a = [];
        for (let l of r) {
          let c = this.specs.indexOf(l), u;
          c < 0 ? (u = l(t.view), a.push(u)) : (u = this.panels[c], u.update && u.update(t)), i.push(u), (u.top ? o : s).push(u);
        }
        this.specs = r, this.panels = i, this.top.sync(o), this.bottom.sync(s);
        for (let l of a)
          l.dom.classList.add("cm-panel"), l.mount && l.mount();
      } else
        for (let r of this.panels)
          r.update && r.update(t);
    }
    destroy() {
      this.top.sync([]), this.bottom.sync([]);
    }
  }, {
    provide: (t) => ue.scrollMargins.of((e) => {
      let n = e.plugin(t);
      return n && {
        top: n.top.scrollMargin(),
        bottom: n.bottom.scrollMargin()
      };
    })
  });
  class _h {
    constructor(e, n, r) {
      this.view = e, this.top = n, this.container = r, this.dom = void 0, this.classes = "", this.panels = [], this.syncClasses();
    }
    sync(e) {
      for (let n of this.panels)
        n.destroy && e.indexOf(n) < 0 && n.destroy();
      this.panels = e, this.syncDOM();
    }
    syncDOM() {
      if (this.panels.length == 0) {
        this.dom && (this.dom.remove(), this.dom = void 0);
        return;
      }
      if (!this.dom) {
        this.dom = document.createElement("div"), this.dom.className = this.top ? "cm-panels cm-panels-top" : "cm-panels cm-panels-bottom", this.dom.style[this.top ? "top" : "bottom"] = "0";
        let n = this.container || this.view.dom;
        n.insertBefore(this.dom, this.top ? n.firstChild : null);
      }
      let e = this.dom.firstChild;
      for (let n of this.panels)
        if (n.dom.parentNode == this.dom) {
          for (; e != n.dom; )
            e = hT(e);
          e = e.nextSibling;
        } else
          this.dom.insertBefore(n.dom, e);
      for (; e; )
        e = hT(e);
    }
    scrollMargin() {
      return !this.dom || this.container ? 0 : Math.max(0, this.top ? this.dom.getBoundingClientRect().bottom - Math.max(0, this.view.scrollDOM.getBoundingClientRect().top) : Math.min(innerHeight, this.view.scrollDOM.getBoundingClientRect().bottom) - this.dom.getBoundingClientRect().top);
    }
    syncClasses() {
      if (!(!this.container || this.classes == this.view.themeClasses)) {
        for (let e of this.classes.split(" "))
          e && this.container.classList.remove(e);
        for (let e of (this.classes = this.view.themeClasses).split(" "))
          e && this.container.classList.add(e);
      }
    }
  }
  function hT(t) {
    let e = t.nextSibling;
    return t.remove(), e;
  }
  const Gs = me.define({
    enables: CL
  });
  function CK(t, e) {
    let n, r = new Promise((s) => n = s), i = (s) => TK(s, e, n);
    t.state.field(j0, false) ? t.dispatch({
      effects: TL.of(i)
    }) : t.dispatch({
      effects: Ee.appendConfig.of(j0.init(() => [
        i
      ]))
    });
    let o = ML.of(i);
    return {
      close: o,
      result: r.then((s) => ((t.win.queueMicrotask || ((l) => t.win.setTimeout(l, 10)))(() => {
        t.state.field(j0).indexOf(i) > -1 && t.dispatch({
          effects: o
        });
      }), s))
    };
  }
  const j0 = Kt.define({
    create() {
      return [];
    },
    update(t, e) {
      for (let n of e.effects)
        n.is(TL) ? t = [
          n.value
        ].concat(t) : n.is(ML) && (t = t.filter((r) => r != n.value));
      return t;
    },
    provide: (t) => Gs.computeN([
      t
    ], (e) => e.field(t))
  }), TL = Ee.define(), ML = Ee.define();
  function TK(t, e, n) {
    let r = e.content ? e.content(t, () => s(null)) : null;
    if (!r) {
      if (r = Qe("form"), e.input) {
        let a = Qe("input", e.input);
        /^(text|password|number|email|tel|url)$/.test(a.type) && a.classList.add("cm-textfield"), a.name || (a.name = "input"), r.appendChild(Qe("label", (e.label || "") + ": ", a));
      } else
        r.appendChild(document.createTextNode(e.label || ""));
      r.appendChild(document.createTextNode(" ")), r.appendChild(Qe("button", {
        class: "cm-button",
        type: "submit"
      }, e.submitLabel || "OK"));
    }
    let i = r.nodeName == "FORM" ? [
      r
    ] : r.querySelectorAll("form");
    for (let a = 0; a < i.length; a++) {
      let l = i[a];
      l.addEventListener("keydown", (c) => {
        c.keyCode == 27 ? (c.preventDefault(), s(null)) : c.keyCode == 13 && (c.preventDefault(), s(l));
      }), l.addEventListener("submit", (c) => {
        c.preventDefault(), s(l);
      });
    }
    let o = Qe("div", r, Qe("button", {
      onclick: () => s(null),
      "aria-label": t.state.phrase("close"),
      class: "cm-dialog-close",
      type: "button"
    }, [
      "\xD7"
    ]));
    e.class && (o.className = e.class), o.classList.add("cm-dialog");
    function s(a) {
      o.contains(o.ownerDocument.activeElement) && t.focus(), n(a);
    }
    return {
      dom: o,
      top: e.top,
      mount: () => {
        if (e.focus) {
          let a;
          typeof e.focus == "string" ? a = r.querySelector(e.focus) : a = r.querySelector("input") || r.querySelector("button"), a && "select" in a ? a.select() : a && "focus" in a && a.focus();
        }
      }
    };
  }
  class io extends Uo {
    compare(e) {
      return this == e || this.constructor == e.constructor && this.eq(e);
    }
    eq(e) {
      return false;
    }
    destroy(e) {
    }
  }
  io.prototype.elementClass = "";
  io.prototype.toDOM = void 0;
  io.prototype.mapMode = Zt.TrackBefore;
  io.prototype.startSide = io.prototype.endSide = -1;
  io.prototype.point = true;
  const Cd = me.define(), MK = me.define(), AK = {
    class: "",
    renderEmptyElements: false,
    elementStyle: "",
    markers: () => _e.empty,
    lineMarker: () => null,
    widgetMarker: () => null,
    lineMarkerChange: null,
    initialSpacer: null,
    updateSpacer: null,
    domEventHandlers: {},
    side: "before"
  }, Zc = me.define();
  function EK(t) {
    return [
      AL(),
      Zc.of({
        ...AK,
        ...t
      })
    ];
  }
  const y1 = me.define({
    combine: (t) => t.some((e) => e)
  });
  function AL(t) {
    let e = [
      PK
    ];
    return t && t.fixed === false && e.push(y1.of(true)), e;
  }
  const PK = kt.fromClass(class {
    constructor(t) {
      this.view = t, this.domAfter = null, this.prevViewport = t.viewport, this.dom = document.createElement("div"), this.dom.className = "cm-gutters cm-gutters-before", this.dom.setAttribute("aria-hidden", "true"), this.dom.style.minHeight = this.view.contentHeight / this.view.scaleY + "px", this.gutters = t.state.facet(Zc).map((e) => new pT(t, e)), this.fixed = !t.state.facet(y1);
      for (let e of this.gutters)
        e.config.side == "after" ? this.getDOMAfter().appendChild(e.dom) : this.dom.appendChild(e.dom);
      this.fixed && (this.dom.style.position = "sticky"), this.syncGutters(false), t.scrollDOM.insertBefore(this.dom, t.contentDOM);
    }
    getDOMAfter() {
      return this.domAfter || (this.domAfter = document.createElement("div"), this.domAfter.className = "cm-gutters cm-gutters-after", this.domAfter.setAttribute("aria-hidden", "true"), this.domAfter.style.minHeight = this.view.contentHeight / this.view.scaleY + "px", this.domAfter.style.position = this.fixed ? "sticky" : "", this.view.scrollDOM.appendChild(this.domAfter)), this.domAfter;
    }
    update(t) {
      if (this.updateGutters(t)) {
        let e = this.prevViewport, n = t.view.viewport, r = Math.min(e.to, n.to) - Math.max(e.from, n.from);
        this.syncGutters(r < (n.to - n.from) * 0.8);
      }
      if (t.geometryChanged) {
        let e = this.view.contentHeight / this.view.scaleY + "px";
        this.dom.style.minHeight = e, this.domAfter && (this.domAfter.style.minHeight = e);
      }
      this.view.state.facet(y1) != !this.fixed && (this.fixed = !this.fixed, this.dom.style.position = this.fixed ? "sticky" : "", this.domAfter && (this.domAfter.style.position = this.fixed ? "sticky" : "")), this.prevViewport = t.view.viewport;
    }
    syncGutters(t) {
      let e = this.dom.nextSibling;
      t && (this.dom.remove(), this.domAfter && this.domAfter.remove());
      let n = _e.iter(this.view.state.facet(Cd), this.view.viewport.from), r = [], i = this.gutters.map((o) => new OK(o, this.view.viewport, -this.view.documentPadding.top));
      for (let o of this.view.viewportLineBlocks)
        if (r.length && (r = []), Array.isArray(o.type)) {
          let s = true;
          for (let a of o.type)
            if (a.type == nn.Text && s) {
              b1(n, r, a.from);
              for (let l of i)
                l.line(this.view, a, r);
              s = false;
            } else if (a.widget)
              for (let l of i)
                l.widget(this.view, a);
        } else if (o.type == nn.Text) {
          b1(n, r, o.from);
          for (let s of i)
            s.line(this.view, o, r);
        } else if (o.widget)
          for (let s of i)
            s.widget(this.view, o);
      for (let o of i)
        o.finish();
      t && (this.view.scrollDOM.insertBefore(this.dom, e), this.domAfter && this.view.scrollDOM.appendChild(this.domAfter));
    }
    updateGutters(t) {
      let e = t.startState.facet(Zc), n = t.state.facet(Zc), r = t.docChanged || t.heightChanged || t.viewportChanged || !_e.eq(t.startState.facet(Cd), t.state.facet(Cd), t.view.viewport.from, t.view.viewport.to);
      if (e == n)
        for (let i of this.gutters)
          i.update(t) && (r = true);
      else {
        r = true;
        let i = [];
        for (let o of n) {
          let s = e.indexOf(o);
          s < 0 ? i.push(new pT(this.view, o)) : (this.gutters[s].update(t), i.push(this.gutters[s]));
        }
        for (let o of this.gutters)
          o.dom.remove(), i.indexOf(o) < 0 && o.destroy();
        for (let o of i)
          o.config.side == "after" ? this.getDOMAfter().appendChild(o.dom) : this.dom.appendChild(o.dom);
        this.gutters = i;
      }
      return r;
    }
    destroy() {
      for (let t of this.gutters)
        t.destroy();
      this.dom.remove(), this.domAfter && this.domAfter.remove();
    }
  }, {
    provide: (t) => ue.scrollMargins.of((e) => {
      let n = e.plugin(t);
      if (!n || n.gutters.length == 0 || !n.fixed)
        return null;
      let r = n.dom.offsetWidth * e.scaleX, i = n.domAfter ? n.domAfter.offsetWidth * e.scaleX : 0;
      return e.textDirection == Je.LTR ? {
        left: r,
        right: i
      } : {
        right: r,
        left: i
      };
    })
  });
  function dT(t) {
    return Array.isArray(t) ? t : [
      t
    ];
  }
  function b1(t, e, n) {
    for (; t.value && t.from <= n; )
      t.from == n && e.push(t.value), t.next();
  }
  class OK {
    constructor(e, n, r) {
      this.gutter = e, this.height = r, this.i = 0, this.cursor = _e.iter(e.markers, n.from);
    }
    addElement(e, n, r) {
      let { gutter: i } = this, o = (n.top - this.height) / e.scaleY, s = n.height / e.scaleY;
      if (this.i == i.elements.length) {
        let a = new EL(e, s, o, r);
        i.elements.push(a), i.dom.appendChild(a.dom);
      } else
        i.elements[this.i].update(e, s, o, r);
      this.height = n.bottom, this.i++;
    }
    line(e, n, r) {
      let i = [];
      b1(this.cursor, i, n.from), r.length && (i = i.concat(r));
      let o = this.gutter.config.lineMarker(e, n, i);
      o && i.unshift(o);
      let s = this.gutter;
      i.length == 0 && !s.config.renderEmptyElements || this.addElement(e, n, i);
    }
    widget(e, n) {
      let r = this.gutter.config.widgetMarker(e, n.widget, n), i = r ? [
        r
      ] : null;
      for (let o of e.state.facet(MK)) {
        let s = o(e, n.widget, n);
        s && (i || (i = [])).push(s);
      }
      i && this.addElement(e, n, i);
    }
    finish() {
      let e = this.gutter;
      for (; e.elements.length > this.i; ) {
        let n = e.elements.pop();
        e.dom.removeChild(n.dom), n.destroy();
      }
    }
  }
  class pT {
    constructor(e, n) {
      this.view = e, this.config = n, this.elements = [], this.spacer = null, this.dom = document.createElement("div"), this.dom.className = "cm-gutter" + (this.config.class ? " " + this.config.class : "");
      for (let r in n.domEventHandlers)
        this.dom.addEventListener(r, (i) => {
          let o = i.target, s;
          if (o != this.dom && this.dom.contains(o)) {
            for (; o.parentNode != this.dom; )
              o = o.parentNode;
            let l = o.getBoundingClientRect();
            s = (l.top + l.bottom) / 2;
          } else
            s = i.clientY;
          let a = e.lineBlockAtHeight(s - e.documentTop);
          n.domEventHandlers[r](e, a, i) && i.preventDefault();
        });
      this.markers = dT(n.markers(e)), n.initialSpacer && (this.spacer = new EL(e, 0, 0, [
        n.initialSpacer(e)
      ]), this.dom.appendChild(this.spacer.dom), this.spacer.dom.style.cssText += "visibility: hidden; pointer-events: none");
    }
    update(e) {
      let n = this.markers;
      if (this.markers = dT(this.config.markers(e.view)), this.spacer && this.config.updateSpacer) {
        let i = this.config.updateSpacer(this.spacer.markers[0], e);
        i != this.spacer.markers[0] && this.spacer.update(e.view, 0, 0, [
          i
        ]);
      }
      let r = e.view.viewport;
      return !_e.eq(this.markers, n, r.from, r.to) || (this.config.lineMarkerChange ? this.config.lineMarkerChange(e) : false);
    }
    destroy() {
      for (let e of this.elements)
        e.destroy();
    }
  }
  class EL {
    constructor(e, n, r, i) {
      this.height = -1, this.above = 0, this.markers = [], this.dom = document.createElement("div"), this.dom.className = "cm-gutterElement", this.update(e, n, r, i);
    }
    update(e, n, r, i) {
      this.height != n && (this.height = n, this.dom.style.height = n + "px"), this.above != r && (this.dom.style.marginTop = (this.above = r) ? r + "px" : ""), LK(this.markers, i) || this.setMarkers(e, i);
    }
    setMarkers(e, n) {
      let r = "cm-gutterElement", i = this.dom.firstChild;
      for (let o = 0, s = 0; ; ) {
        let a = s, l = o < n.length ? n[o++] : null, c = false;
        if (l) {
          let u = l.elementClass;
          u && (r += " " + u);
          for (let h = s; h < this.markers.length; h++)
            if (this.markers[h].compare(l)) {
              a = h, c = true;
              break;
            }
        } else
          a = this.markers.length;
        for (; s < a; ) {
          let u = this.markers[s++];
          if (u.toDOM) {
            u.destroy(i);
            let h = i.nextSibling;
            i.remove(), i = h;
          }
        }
        if (!l)
          break;
        l.toDOM && (c ? i = i.nextSibling : this.dom.insertBefore(l.toDOM(e), i)), c && s++;
      }
      this.dom.className = r, this.markers = n;
    }
    destroy() {
      this.setMarkers(null, []);
    }
  }
  function LK(t, e) {
    if (t.length != e.length)
      return false;
    for (let n = 0; n < t.length; n++)
      if (!t[n].compare(e[n]))
        return false;
    return true;
  }
  const RK = me.define(), _K = me.define(), Da = me.define({
    combine(t) {
      return Oi(t, {
        formatNumber: String,
        domEventHandlers: {}
      }, {
        domEventHandlers(e, n) {
          let r = Object.assign({}, e);
          for (let i in n) {
            let o = r[i], s = n[i];
            r[i] = o ? (a, l, c) => o(a, l, c) || s(a, l, c) : s;
          }
          return r;
        }
      });
    }
  });
  class U0 extends io {
    constructor(e) {
      super(), this.number = e;
    }
    eq(e) {
      return this.number == e.number;
    }
    toDOM() {
      return document.createTextNode(this.number);
    }
  }
  function K0(t, e) {
    return t.state.facet(Da).formatNumber(e, t.state);
  }
  const DK = Zc.compute([
    Da
  ], (t) => ({
    class: "cm-lineNumbers",
    renderEmptyElements: false,
    markers(e) {
      return e.state.facet(RK);
    },
    lineMarker(e, n, r) {
      return r.some((i) => i.toDOM) ? null : new U0(K0(e, e.state.doc.lineAt(n.from).number));
    },
    widgetMarker: (e, n, r) => {
      for (let i of e.state.facet(_K)) {
        let o = i(e, n, r);
        if (o)
          return o;
      }
      return null;
    },
    lineMarkerChange: (e) => e.startState.facet(Da) != e.state.facet(Da),
    initialSpacer(e) {
      return new U0(K0(e, mT(e.state.doc.lines)));
    },
    updateSpacer(e, n) {
      let r = K0(n.view, mT(n.view.state.doc.lines));
      return r == e.number ? e : new U0(r);
    },
    domEventHandlers: t.facet(Da).domEventHandlers,
    side: "before"
  }));
  function IK(t = {}) {
    return [
      Da.of(t),
      AL(),
      DK
    ];
  }
  function mT(t) {
    let e = 9;
    for (; e < t; )
      e = e * 10 + 9;
    return e;
  }
  const BK = new class extends io {
    constructor() {
      super(...arguments), this.elementClass = "cm-activeLineGutter";
    }
  }(), NK = Cd.compute([
    "selection"
  ], (t) => {
    let e = [], n = -1;
    for (let r of t.selection.ranges) {
      let i = t.doc.lineAt(r.head).from;
      i > n && (n = i, e.push(BK.range(i)));
    }
    return _e.of(e);
  });
  function $K() {
    return NK;
  }
  const zK = 1024;
  let FK = 0;
  class q0 {
    constructor(e, n) {
      this.from = e, this.to = n;
    }
  }
  class ze {
    constructor(e = {}) {
      this.id = FK++, this.perNode = !!e.perNode, this.deserialize = e.deserialize || (() => {
        throw new Error("This node type doesn't define a deserialize function");
      }), this.combine = e.combine || null;
    }
    add(e) {
      if (this.perNode)
        throw new RangeError("Can't add per-node props to node types");
      return typeof e != "function" && (e = Cr.match(e)), (n) => {
        let r = e(n);
        return r === void 0 ? null : [
          this,
          r
        ];
      };
    }
  }
  ze.closedBy = new ze({
    deserialize: (t) => t.split(" ")
  });
  ze.openedBy = new ze({
    deserialize: (t) => t.split(" ")
  });
  ze.group = new ze({
    deserialize: (t) => t.split(" ")
  });
  ze.isolate = new ze({
    deserialize: (t) => {
      if (t && t != "rtl" && t != "ltr" && t != "auto")
        throw new RangeError("Invalid value for isolate: " + t);
      return t || "auto";
    }
  });
  ze.contextHash = new ze({
    perNode: true
  });
  ze.lookAhead = new ze({
    perNode: true
  });
  ze.mounted = new ze({
    perNode: true
  });
  class eu {
    constructor(e, n, r, i = false) {
      this.tree = e, this.overlay = n, this.parser = r, this.bracketed = i;
    }
    static get(e) {
      return e && e.props && e.props[ze.mounted.id];
    }
  }
  const VK = /* @__PURE__ */ Object.create(null);
  class Cr {
    constructor(e, n, r, i = 0) {
      this.name = e, this.props = n, this.id = r, this.flags = i;
    }
    static define(e) {
      let n = e.props && e.props.length ? /* @__PURE__ */ Object.create(null) : VK, r = (e.top ? 1 : 0) | (e.skipped ? 2 : 0) | (e.error ? 4 : 0) | (e.name == null ? 8 : 0), i = new Cr(e.name || "", n, e.id, r);
      if (e.props) {
        for (let o of e.props)
          if (Array.isArray(o) || (o = o(i)), o) {
            if (o[0].perNode)
              throw new RangeError("Can't store a per-node prop on a node type");
            n[o[0].id] = o[1];
          }
      }
      return i;
    }
    prop(e) {
      return this.props[e.id];
    }
    get isTop() {
      return (this.flags & 1) > 0;
    }
    get isSkipped() {
      return (this.flags & 2) > 0;
    }
    get isError() {
      return (this.flags & 4) > 0;
    }
    get isAnonymous() {
      return (this.flags & 8) > 0;
    }
    is(e) {
      if (typeof e == "string") {
        if (this.name == e)
          return true;
        let n = this.prop(ze.group);
        return n ? n.indexOf(e) > -1 : false;
      }
      return this.id == e;
    }
    static match(e) {
      let n = /* @__PURE__ */ Object.create(null);
      for (let r in e)
        for (let i of r.split(" "))
          n[i] = e[r];
      return (r) => {
        for (let i = r.prop(ze.group), o = -1; o < (i ? i.length : 0); o++) {
          let s = n[o < 0 ? r.name : i[o]];
          if (s)
            return s;
        }
      };
    }
  }
  Cr.none = new Cr("", /* @__PURE__ */ Object.create(null), 0, 8);
  const Dh = /* @__PURE__ */ new WeakMap(), gT = /* @__PURE__ */ new WeakMap();
  var Tt;
  (function(t) {
    t[t.ExcludeBuffers = 1] = "ExcludeBuffers", t[t.IncludeAnonymous = 2] = "IncludeAnonymous", t[t.IgnoreMounts = 4] = "IgnoreMounts", t[t.IgnoreOverlays = 8] = "IgnoreOverlays", t[t.EnterBracketed = 16] = "EnterBracketed";
  })(Tt || (Tt = {}));
  class en {
    constructor(e, n, r, i, o) {
      if (this.type = e, this.children = n, this.positions = r, this.length = i, this.props = null, o && o.length) {
        this.props = /* @__PURE__ */ Object.create(null);
        for (let [s, a] of o)
          this.props[typeof s == "number" ? s : s.id] = a;
      }
    }
    toString() {
      let e = eu.get(this);
      if (e && !e.overlay)
        return e.tree.toString();
      let n = "";
      for (let r of this.children) {
        let i = r.toString();
        i && (n && (n += ","), n += i);
      }
      return this.type.name ? (/\W/.test(this.type.name) && !this.type.isError ? JSON.stringify(this.type.name) : this.type.name) + (n.length ? "(" + n + ")" : "") : n;
    }
    cursor(e = 0) {
      return new S1(this.topNode, e);
    }
    cursorAt(e, n = 0, r = 0) {
      let i = Dh.get(this) || this.topNode, o = new S1(i);
      return o.moveTo(e, n), Dh.set(this, o._tree), o;
    }
    get topNode() {
      return new xr(this, 0, 0, null);
    }
    resolve(e, n = 0) {
      let r = Fu(Dh.get(this) || this.topNode, e, n, false);
      return Dh.set(this, r), r;
    }
    resolveInner(e, n = 0) {
      let r = Fu(gT.get(this) || this.topNode, e, n, true);
      return gT.set(this, r), r;
    }
    resolveStack(e, n = 0) {
      return jK(this, e, n);
    }
    iterate(e) {
      let { enter: n, leave: r, from: i = 0, to: o = this.length } = e, s = e.mode || 0, a = (s & Tt.IncludeAnonymous) > 0;
      for (let l = this.cursor(s | Tt.IncludeAnonymous); ; ) {
        let c = false;
        if (l.from <= o && l.to >= i && (!a && l.type.isAnonymous || n(l) !== false)) {
          if (l.firstChild())
            continue;
          c = true;
        }
        for (; c && r && (a || !l.type.isAnonymous) && r(l), !l.nextSibling(); ) {
          if (!l.parent())
            return;
          c = true;
        }
      }
    }
    prop(e) {
      return e.perNode ? this.props ? this.props[e.id] : void 0 : this.type.prop(e);
    }
    get propValues() {
      let e = [];
      if (this.props)
        for (let n in this.props)
          e.push([
            +n,
            this.props[n]
          ]);
      return e;
    }
    balance(e = {}) {
      return this.children.length <= 8 ? this : qx(Cr.none, this.children, this.positions, 0, this.children.length, 0, this.length, (n, r, i) => new en(this.type, n, r, i, this.propValues), e.makeTree || ((n, r, i) => new en(Cr.none, n, r, i)));
    }
    static build(e) {
      return UK(e);
    }
  }
  en.empty = new en(Cr.none, [], [], 0);
  class Ux {
    constructor(e, n) {
      this.buffer = e, this.index = n;
    }
    get id() {
      return this.buffer[this.index - 4];
    }
    get start() {
      return this.buffer[this.index - 3];
    }
    get end() {
      return this.buffer[this.index - 2];
    }
    get size() {
      return this.buffer[this.index - 1];
    }
    get pos() {
      return this.index;
    }
    next() {
      this.index -= 4;
    }
    fork() {
      return new Ux(this.buffer, this.index);
    }
  }
  class Yo {
    constructor(e, n, r) {
      this.buffer = e, this.length = n, this.set = r;
    }
    get type() {
      return Cr.none;
    }
    toString() {
      let e = [];
      for (let n = 0; n < this.buffer.length; )
        e.push(this.childString(n)), n = this.buffer[n + 3];
      return e.join(",");
    }
    childString(e) {
      let n = this.buffer[e], r = this.buffer[e + 3], i = this.set.types[n], o = i.name;
      if (/\W/.test(o) && !i.isError && (o = JSON.stringify(o)), e += 4, r == e)
        return o;
      let s = [];
      for (; e < r; )
        s.push(this.childString(e)), e = this.buffer[e + 3];
      return o + "(" + s.join(",") + ")";
    }
    findChild(e, n, r, i, o) {
      let { buffer: s } = this, a = -1;
      for (let l = e; l != n && !(PL(o, i, s[l + 1], s[l + 2]) && (a = l, r > 0)); l = s[l + 3])
        ;
      return a;
    }
    slice(e, n, r) {
      let i = this.buffer, o = new Uint16Array(n - e), s = 0;
      for (let a = e, l = 0; a < n; ) {
        o[l++] = i[a++], o[l++] = i[a++] - r;
        let c = o[l++] = i[a++] - r;
        o[l++] = i[a++] - e, s = Math.max(s, c);
      }
      return new Yo(o, s, this.set);
    }
  }
  function PL(t, e, n, r) {
    switch (t) {
      case -2:
        return n < e;
      case -1:
        return r >= e && n < e;
      case 0:
        return n < e && r > e;
      case 1:
        return n <= e && r > e;
      case 2:
        return r > e;
      case 4:
        return true;
    }
  }
  function Fu(t, e, n, r) {
    for (var i; t.from == t.to || (n < 1 ? t.from >= e : t.from > e) || (n > -1 ? t.to <= e : t.to < e); ) {
      let s = !r && t instanceof xr && t.index < 0 ? null : t.parent;
      if (!s)
        return t;
      t = s;
    }
    let o = r ? 0 : Tt.IgnoreOverlays;
    if (r)
      for (let s = t, a = s.parent; a; s = a, a = s.parent)
        s instanceof xr && s.index < 0 && ((i = a.enter(e, n, o)) === null || i === void 0 ? void 0 : i.from) != s.from && (t = a);
    for (; ; ) {
      let s = t.enter(e, n, o);
      if (!s)
        return t;
      t = s;
    }
  }
  class OL {
    cursor(e = 0) {
      return new S1(this, e);
    }
    getChild(e, n = null, r = null) {
      let i = vT(this, e, n, r);
      return i.length ? i[0] : null;
    }
    getChildren(e, n = null, r = null) {
      return vT(this, e, n, r);
    }
    resolve(e, n = 0) {
      return Fu(this, e, n, false);
    }
    resolveInner(e, n = 0) {
      return Fu(this, e, n, true);
    }
    matchContext(e) {
      return x1(this.parent, e);
    }
    enterUnfinishedNodesBefore(e) {
      let n = this.childBefore(e), r = this;
      for (; n; ) {
        let i = n.lastChild;
        if (!i || i.to != n.to)
          break;
        i.type.isError && i.from == i.to ? (r = n, n = i.prevSibling) : n = i;
      }
      return r;
    }
    get node() {
      return this;
    }
    get next() {
      return this.parent;
    }
  }
  class xr extends OL {
    constructor(e, n, r, i) {
      super(), this._tree = e, this.from = n, this.index = r, this._parent = i;
    }
    get type() {
      return this._tree.type;
    }
    get name() {
      return this._tree.type.name;
    }
    get to() {
      return this.from + this._tree.length;
    }
    nextChild(e, n, r, i, o = 0) {
      for (let s = this; ; ) {
        for (let { children: a, positions: l } = s._tree, c = n > 0 ? a.length : -1; e != c; e += n) {
          let u = a[e], h = l[e] + s.from, p;
          if (!(!(o & Tt.EnterBracketed && u instanceof en && (p = eu.get(u)) && !p.overlay && p.bracketed && r >= h && r <= h + u.length) && !PL(i, r, h, h + u.length))) {
            if (u instanceof Yo) {
              if (o & Tt.ExcludeBuffers)
                continue;
              let v = u.findChild(0, u.buffer.length, n, r - h, i);
              if (v > -1)
                return new _o(new WK(s, u, e, h), null, v);
            } else if (o & Tt.IncludeAnonymous || !u.type.isAnonymous || Kx(u)) {
              let v;
              if (!(o & Tt.IgnoreMounts) && (v = eu.get(u)) && !v.overlay)
                return new xr(v.tree, h, e, s);
              let y = new xr(u, h, e, s);
              return o & Tt.IncludeAnonymous || !y.type.isAnonymous ? y : y.nextChild(n < 0 ? u.children.length - 1 : 0, n, r, i, o);
            }
          }
        }
        if (o & Tt.IncludeAnonymous || !s.type.isAnonymous || (s.index >= 0 ? e = s.index + n : e = n < 0 ? -1 : s._parent._tree.children.length, s = s._parent, !s))
          return null;
      }
    }
    get firstChild() {
      return this.nextChild(0, 1, 0, 4);
    }
    get lastChild() {
      return this.nextChild(this._tree.children.length - 1, -1, 0, 4);
    }
    childAfter(e) {
      return this.nextChild(0, 1, e, 2);
    }
    childBefore(e) {
      return this.nextChild(this._tree.children.length - 1, -1, e, -2);
    }
    prop(e) {
      return this._tree.prop(e);
    }
    enter(e, n, r = 0) {
      let i;
      if (!(r & Tt.IgnoreOverlays) && (i = eu.get(this._tree)) && i.overlay) {
        let o = e - this.from, s = r & Tt.EnterBracketed && i.bracketed;
        for (let { from: a, to: l } of i.overlay)
          if ((n > 0 || s ? a <= o : a < o) && (n < 0 || s ? l >= o : l > o))
            return new xr(i.tree, i.overlay[0].from + this.from, -1, this);
      }
      return this.nextChild(0, 1, e, n, r);
    }
    nextSignificantParent() {
      let e = this;
      for (; e.type.isAnonymous && e._parent; )
        e = e._parent;
      return e;
    }
    get parent() {
      return this._parent ? this._parent.nextSignificantParent() : null;
    }
    get nextSibling() {
      return this._parent && this.index >= 0 ? this._parent.nextChild(this.index + 1, 1, 0, 4) : null;
    }
    get prevSibling() {
      return this._parent && this.index >= 0 ? this._parent.nextChild(this.index - 1, -1, 0, 4) : null;
    }
    get tree() {
      return this._tree;
    }
    toTree() {
      return this._tree;
    }
    toString() {
      return this._tree.toString();
    }
  }
  function vT(t, e, n, r) {
    let i = t.cursor(), o = [];
    if (!i.firstChild())
      return o;
    if (n != null) {
      for (let s = false; !s; )
        if (s = i.type.is(n), !i.nextSibling())
          return o;
    }
    for (; ; ) {
      if (r != null && i.type.is(r))
        return o;
      if (i.type.is(e) && o.push(i.node), !i.nextSibling())
        return r == null ? o : [];
    }
  }
  function x1(t, e, n = e.length - 1) {
    for (let r = t; n >= 0; r = r.parent) {
      if (!r)
        return false;
      if (!r.type.isAnonymous) {
        if (e[n] && e[n] != r.name)
          return false;
        n--;
      }
    }
    return true;
  }
  class WK {
    constructor(e, n, r, i) {
      this.parent = e, this.buffer = n, this.index = r, this.start = i;
    }
  }
  class _o extends OL {
    get name() {
      return this.type.name;
    }
    get from() {
      return this.context.start + this.context.buffer.buffer[this.index + 1];
    }
    get to() {
      return this.context.start + this.context.buffer.buffer[this.index + 2];
    }
    constructor(e, n, r) {
      super(), this.context = e, this._parent = n, this.index = r, this.type = e.buffer.set.types[e.buffer.buffer[r]];
    }
    child(e, n, r) {
      let { buffer: i } = this.context, o = i.findChild(this.index + 4, i.buffer[this.index + 3], e, n - this.context.start, r);
      return o < 0 ? null : new _o(this.context, this, o);
    }
    get firstChild() {
      return this.child(1, 0, 4);
    }
    get lastChild() {
      return this.child(-1, 0, 4);
    }
    childAfter(e) {
      return this.child(1, e, 2);
    }
    childBefore(e) {
      return this.child(-1, e, -2);
    }
    prop(e) {
      return this.type.prop(e);
    }
    enter(e, n, r = 0) {
      if (r & Tt.ExcludeBuffers)
        return null;
      let { buffer: i } = this.context, o = i.findChild(this.index + 4, i.buffer[this.index + 3], n > 0 ? 1 : -1, e - this.context.start, n);
      return o < 0 ? null : new _o(this.context, this, o);
    }
    get parent() {
      return this._parent || this.context.parent.nextSignificantParent();
    }
    externalSibling(e) {
      return this._parent ? null : this.context.parent.nextChild(this.context.index + e, e, 0, 4);
    }
    get nextSibling() {
      let { buffer: e } = this.context, n = e.buffer[this.index + 3];
      return n < (this._parent ? e.buffer[this._parent.index + 3] : e.buffer.length) ? new _o(this.context, this._parent, n) : this.externalSibling(1);
    }
    get prevSibling() {
      let { buffer: e } = this.context, n = this._parent ? this._parent.index + 4 : 0;
      return this.index == n ? this.externalSibling(-1) : new _o(this.context, this._parent, e.findChild(n, this.index, -1, 0, 4));
    }
    get tree() {
      return null;
    }
    toTree() {
      let e = [], n = [], { buffer: r } = this.context, i = this.index + 4, o = r.buffer[this.index + 3];
      if (o > i) {
        let s = r.buffer[this.index + 1];
        e.push(r.slice(i, o, s)), n.push(0);
      }
      return new en(this.type, e, n, this.to - this.from);
    }
    toString() {
      return this.context.buffer.childString(this.index);
    }
  }
  function LL(t) {
    if (!t.length)
      return null;
    let e = 0, n = t[0];
    for (let o = 1; o < t.length; o++) {
      let s = t[o];
      (s.from > n.from || s.to < n.to) && (n = s, e = o);
    }
    let r = n instanceof xr && n.index < 0 ? null : n.parent, i = t.slice();
    return r ? i[e] = r : i.splice(e, 1), new HK(i, n);
  }
  class HK {
    constructor(e, n) {
      this.heads = e, this.node = n;
    }
    get next() {
      return LL(this.heads);
    }
  }
  function jK(t, e, n) {
    let r = t.resolveInner(e, n), i = null;
    for (let o = r instanceof xr ? r : r.context.parent; o; o = o.parent)
      if (o.index < 0) {
        let s = o.parent;
        (i || (i = [
          r
        ])).push(s.resolve(e, n)), o = s;
      } else {
        let s = eu.get(o.tree);
        if (s && s.overlay && s.overlay[0].from <= e && s.overlay[s.overlay.length - 1].to >= e) {
          let a = new xr(s.tree, s.overlay[0].from + o.from, -1, o);
          (i || (i = [
            r
          ])).push(Fu(a, e, n, false));
        }
      }
    return i ? LL(i) : r;
  }
  class S1 {
    get name() {
      return this.type.name;
    }
    constructor(e, n = 0) {
      if (this.buffer = null, this.stack = [], this.index = 0, this.bufferNode = null, this.mode = n & ~Tt.EnterBracketed, e instanceof xr)
        this.yieldNode(e);
      else {
        this._tree = e.context.parent, this.buffer = e.context;
        for (let r = e._parent; r; r = r._parent)
          this.stack.unshift(r.index);
        this.bufferNode = e, this.yieldBuf(e.index);
      }
    }
    yieldNode(e) {
      return e ? (this._tree = e, this.type = e.type, this.from = e.from, this.to = e.to, true) : false;
    }
    yieldBuf(e, n) {
      this.index = e;
      let { start: r, buffer: i } = this.buffer;
      return this.type = n || i.set.types[i.buffer[e]], this.from = r + i.buffer[e + 1], this.to = r + i.buffer[e + 2], true;
    }
    yield(e) {
      return e ? e instanceof xr ? (this.buffer = null, this.yieldNode(e)) : (this.buffer = e.context, this.yieldBuf(e.index, e.type)) : false;
    }
    toString() {
      return this.buffer ? this.buffer.buffer.childString(this.index) : this._tree.toString();
    }
    enterChild(e, n, r) {
      if (!this.buffer)
        return this.yield(this._tree.nextChild(e < 0 ? this._tree._tree.children.length - 1 : 0, e, n, r, this.mode));
      let { buffer: i } = this.buffer, o = i.findChild(this.index + 4, i.buffer[this.index + 3], e, n - this.buffer.start, r);
      return o < 0 ? false : (this.stack.push(this.index), this.yieldBuf(o));
    }
    firstChild() {
      return this.enterChild(1, 0, 4);
    }
    lastChild() {
      return this.enterChild(-1, 0, 4);
    }
    childAfter(e) {
      return this.enterChild(1, e, 2);
    }
    childBefore(e) {
      return this.enterChild(-1, e, -2);
    }
    enter(e, n, r = this.mode) {
      return this.buffer ? r & Tt.ExcludeBuffers ? false : this.enterChild(1, e, n) : this.yield(this._tree.enter(e, n, r));
    }
    parent() {
      if (!this.buffer)
        return this.yieldNode(this.mode & Tt.IncludeAnonymous ? this._tree._parent : this._tree.parent);
      if (this.stack.length)
        return this.yieldBuf(this.stack.pop());
      let e = this.mode & Tt.IncludeAnonymous ? this.buffer.parent : this.buffer.parent.nextSignificantParent();
      return this.buffer = null, this.yieldNode(e);
    }
    sibling(e) {
      if (!this.buffer)
        return this._tree._parent ? this.yield(this._tree.index < 0 ? null : this._tree._parent.nextChild(this._tree.index + e, e, 0, 4, this.mode)) : false;
      let { buffer: n } = this.buffer, r = this.stack.length - 1;
      if (e < 0) {
        let i = r < 0 ? 0 : this.stack[r] + 4;
        if (this.index != i)
          return this.yieldBuf(n.findChild(i, this.index, -1, 0, 4));
      } else {
        let i = n.buffer[this.index + 3];
        if (i < (r < 0 ? n.buffer.length : n.buffer[this.stack[r] + 3]))
          return this.yieldBuf(i);
      }
      return r < 0 ? this.yield(this.buffer.parent.nextChild(this.buffer.index + e, e, 0, 4, this.mode)) : false;
    }
    nextSibling() {
      return this.sibling(1);
    }
    prevSibling() {
      return this.sibling(-1);
    }
    atLastNode(e) {
      let n, r, { buffer: i } = this;
      if (i) {
        if (e > 0) {
          if (this.index < i.buffer.buffer.length)
            return false;
        } else
          for (let o = 0; o < this.index; o++)
            if (i.buffer.buffer[o + 3] < this.index)
              return false;
        ({ index: n, parent: r } = i);
      } else
        ({ index: n, _parent: r } = this._tree);
      for (; r; { index: n, _parent: r } = r)
        if (n > -1)
          for (let o = n + e, s = e < 0 ? -1 : r._tree.children.length; o != s; o += e) {
            let a = r._tree.children[o];
            if (this.mode & Tt.IncludeAnonymous || a instanceof Yo || !a.type.isAnonymous || Kx(a))
              return false;
          }
      return true;
    }
    move(e, n) {
      if (n && this.enterChild(e, 0, 4))
        return true;
      for (; ; ) {
        if (this.sibling(e))
          return true;
        if (this.atLastNode(e) || !this.parent())
          return false;
      }
    }
    next(e = true) {
      return this.move(1, e);
    }
    prev(e = true) {
      return this.move(-1, e);
    }
    moveTo(e, n = 0) {
      for (; (this.from == this.to || (n < 1 ? this.from >= e : this.from > e) || (n > -1 ? this.to <= e : this.to < e)) && this.parent(); )
        ;
      for (; this.enterChild(1, e, n); )
        ;
      return this;
    }
    get node() {
      if (!this.buffer)
        return this._tree;
      let e = this.bufferNode, n = null, r = 0;
      if (e && e.context == this.buffer) {
        e:
          for (let i = this.index, o = this.stack.length; o >= 0; ) {
            for (let s = e; s; s = s._parent)
              if (s.index == i) {
                if (i == this.index)
                  return s;
                n = s, r = o + 1;
                break e;
              }
            i = this.stack[--o];
          }
      }
      for (let i = r; i < this.stack.length; i++)
        n = new _o(this.buffer, n, this.stack[i]);
      return this.bufferNode = new _o(this.buffer, n, this.index);
    }
    get tree() {
      return this.buffer ? null : this._tree._tree;
    }
    iterate(e, n) {
      for (let r = 0; ; ) {
        let i = false;
        if (this.type.isAnonymous || e(this) !== false) {
          if (this.firstChild()) {
            r++;
            continue;
          }
          this.type.isAnonymous || (i = true);
        }
        for (; ; ) {
          if (i && n && n(this), i = this.type.isAnonymous, !r)
            return;
          if (this.nextSibling())
            break;
          this.parent(), r--, i = true;
        }
      }
    }
    matchContext(e) {
      if (!this.buffer)
        return x1(this.node.parent, e);
      let { buffer: n } = this.buffer, { types: r } = n.set;
      for (let i = e.length - 1, o = this.stack.length - 1; i >= 0; o--) {
        if (o < 0)
          return x1(this._tree, e, i);
        let s = r[n.buffer[this.stack[o]]];
        if (!s.isAnonymous) {
          if (e[i] && e[i] != s.name)
            return false;
          i--;
        }
      }
      return true;
    }
  }
  function Kx(t) {
    return t.children.some((e) => e instanceof Yo || !e.type.isAnonymous || Kx(e));
  }
  function UK(t) {
    var e;
    let { buffer: n, nodeSet: r, maxBufferLength: i = zK, reused: o = [], minRepeatType: s = r.types.length } = t, a = Array.isArray(n) ? new Ux(n, n.length) : n, l = r.types, c = 0, u = 0;
    function h(L, D, R, F, K, Y) {
      let { id: te, start: ne, end: ae, size: ye } = a, Ce = u, Le = c;
      if (ye < 0)
        if (a.next(), ye == -1) {
          let Se = o[te];
          R.push(Se), F.push(ne - L);
          return;
        } else if (ye == -3) {
          c = te;
          return;
        } else if (ye == -4) {
          u = te;
          return;
        } else
          throw new RangeError(`Unrecognized record size: ${ye}`);
      let ee = l[te], V, oe, he = ne - L;
      if (ae - ne <= i && (oe = T(a.pos - D, K))) {
        let Se = new Uint16Array(oe.size - oe.skip), ve = a.pos - oe.size, le = Se.length;
        for (; a.pos > ve; )
          le = w(oe.start, Se, le);
        V = new Yo(Se, ae - oe.start, r), he = oe.start - L;
      } else {
        let Se = a.pos - ye;
        a.next();
        let ve = [], le = [], re = te >= s ? te : -1, se = 0, De = ae;
        for (; a.pos > Se; )
          re >= 0 && a.id == re && a.size >= 0 ? (a.end <= De - i && (y(ve, le, ne, se, a.end, De, re, Ce, Le), se = ve.length, De = a.end), a.next()) : Y > 2500 ? p(ne, Se, ve, le) : h(ne, Se, ve, le, re, Y + 1);
        if (re >= 0 && se > 0 && se < ve.length && y(ve, le, ne, se, ne, De, re, Ce, Le), ve.reverse(), le.reverse(), re > -1 && se > 0) {
          let vt = v(ee, Le);
          V = qx(ee, ve, le, 0, ve.length, 0, ae - ne, vt, vt);
        } else
          V = S(ee, ve, le, ae - ne, Ce - ae, Le);
      }
      R.push(V), F.push(he);
    }
    function p(L, D, R, F) {
      let K = [], Y = 0, te = -1;
      for (; a.pos > D; ) {
        let { id: ne, start: ae, end: ye, size: Ce } = a;
        if (Ce > 4)
          a.next();
        else {
          if (te > -1 && ae < te)
            break;
          te < 0 && (te = ye - i), K.push(ne, ae, ye), Y++, a.next();
        }
      }
      if (Y) {
        let ne = new Uint16Array(Y * 4), ae = K[K.length - 2];
        for (let ye = K.length - 3, Ce = 0; ye >= 0; ye -= 3)
          ne[Ce++] = K[ye], ne[Ce++] = K[ye + 1] - ae, ne[Ce++] = K[ye + 2] - ae, ne[Ce++] = Ce;
        R.push(new Yo(ne, K[2] - ae, r)), F.push(ae - L);
      }
    }
    function v(L, D) {
      return (R, F, K) => {
        let Y = 0, te = R.length - 1, ne, ae;
        if (te >= 0 && (ne = R[te]) instanceof en) {
          if (!te && ne.type == L && ne.length == K)
            return ne;
          (ae = ne.prop(ze.lookAhead)) && (Y = F[te] + ne.length + ae);
        }
        return S(L, R, F, K, Y, D);
      };
    }
    function y(L, D, R, F, K, Y, te, ne, ae) {
      let ye = [], Ce = [];
      for (; L.length > F; )
        ye.push(L.pop()), Ce.push(D.pop() + R - K);
      L.push(S(r.types[te], ye, Ce, Y - K, ne - Y, ae)), D.push(K - R);
    }
    function S(L, D, R, F, K, Y, te) {
      if (Y) {
        let ne = [
          ze.contextHash,
          Y
        ];
        te = te ? [
          ne
        ].concat(te) : [
          ne
        ];
      }
      if (K > 25) {
        let ne = [
          ze.lookAhead,
          K
        ];
        te = te ? [
          ne
        ].concat(te) : [
          ne
        ];
      }
      return new en(L, D, R, F, te);
    }
    function T(L, D) {
      let R = a.fork(), F = 0, K = 0, Y = 0, te = R.end - i, ne = {
        size: 0,
        start: 0,
        skip: 0
      };
      e:
        for (let ae = R.pos - L; R.pos > ae; ) {
          let ye = R.size;
          if (R.id == D && ye >= 0) {
            ne.size = F, ne.start = K, ne.skip = Y, Y += 4, F += 4, R.next();
            continue;
          }
          let Ce = R.pos - ye;
          if (ye < 0 || Ce < ae || R.start < te)
            break;
          let Le = R.id >= s ? 4 : 0, ee = R.start;
          for (R.next(); R.pos > Ce; ) {
            if (R.size < 0)
              if (R.size == -3 || R.size == -4)
                Le += 4;
              else
                break e;
            else
              R.id >= s && (Le += 4);
            R.next();
          }
          K = ee, F += ye, Y += Le;
        }
      return (D < 0 || F == L) && (ne.size = F, ne.start = K, ne.skip = Y), ne.size > 4 ? ne : void 0;
    }
    function w(L, D, R) {
      let { id: F, start: K, end: Y, size: te } = a;
      if (a.next(), te >= 0 && F < s) {
        let ne = R;
        if (te > 4) {
          let ae = a.pos - (te - 4);
          for (; a.pos > ae; )
            R = w(L, D, R);
        }
        D[--R] = ne, D[--R] = Y - L, D[--R] = K - L, D[--R] = F;
      } else
        te == -3 ? c = F : te == -4 && (u = F);
      return R;
    }
    let k = [], C = [];
    for (; a.pos > 0; )
      h(t.start || 0, t.bufferStart || 0, k, C, -1, 0);
    let O = (e = t.length) !== null && e !== void 0 ? e : k.length ? C[0] + k[0].length : 0;
    return new en(l[t.topID], k.reverse(), C.reverse(), O);
  }
  const yT = /* @__PURE__ */ new WeakMap();
  function Td(t, e) {
    if (!t.isAnonymous || e instanceof Yo || e.type != t)
      return 1;
    let n = yT.get(e);
    if (n == null) {
      n = 1;
      for (let r of e.children) {
        if (r.type != t || !(r instanceof en)) {
          n = 1;
          break;
        }
        n += Td(t, r);
      }
      yT.set(e, n);
    }
    return n;
  }
  function qx(t, e, n, r, i, o, s, a, l) {
    let c = 0;
    for (let y = r; y < i; y++)
      c += Td(t, e[y]);
    let u = Math.ceil(c * 1.5 / 8), h = [], p = [];
    function v(y, S, T, w, k) {
      for (let C = T; C < w; ) {
        let O = C, L = S[C], D = Td(t, y[C]);
        for (C++; C < w; C++) {
          let R = Td(t, y[C]);
          if (D + R >= u)
            break;
          D += R;
        }
        if (C == O + 1) {
          if (D > u) {
            let R = y[O];
            v(R.children, R.positions, 0, R.children.length, S[O] + k);
            continue;
          }
          h.push(y[O]);
        } else {
          let R = S[C - 1] + y[C - 1].length - L;
          h.push(qx(t, y, S, O, C, L, R, null, l));
        }
        p.push(L + k - o);
      }
    }
    return v(e, n, r, i, 0), (a || l)(h, p, s);
  }
  class Ns {
    constructor(e, n, r, i, o = false, s = false) {
      this.from = e, this.to = n, this.tree = r, this.offset = i, this.open = (o ? 1 : 0) | (s ? 2 : 0);
    }
    get openStart() {
      return (this.open & 1) > 0;
    }
    get openEnd() {
      return (this.open & 2) > 0;
    }
    static addTree(e, n = [], r = false) {
      let i = [
        new Ns(0, e.length, e, 0, false, r)
      ];
      for (let o of n)
        o.to > e.length && i.push(o);
      return i;
    }
    static applyChanges(e, n, r = 128) {
      if (!n.length)
        return e;
      let i = [], o = 1, s = e.length ? e[0] : null;
      for (let a = 0, l = 0, c = 0; ; a++) {
        let u = a < n.length ? n[a] : null, h = u ? u.fromA : 1e9;
        if (h - l >= r)
          for (; s && s.from < h; ) {
            let p = s;
            if (l >= p.from || h <= p.to || c) {
              let v = Math.max(p.from, l) - c, y = Math.min(p.to, h) - c;
              p = v >= y ? null : new Ns(v, y, p.tree, p.offset + c, a > 0, !!u);
            }
            if (p && i.push(p), s.to > h)
              break;
            s = o < e.length ? e[o++] : null;
          }
        if (!u)
          break;
        l = u.toA, c = u.toA - u.toB;
      }
      return i;
    }
  }
  class KK {
    startParse(e, n, r) {
      return typeof e == "string" && (e = new qK(e)), r = r ? r.length ? r.map((i) => new q0(i.from, i.to)) : [
        new q0(0, 0)
      ] : [
        new q0(0, e.length)
      ], this.createParse(e, n || [], r);
    }
    parse(e, n, r) {
      let i = this.startParse(e, n, r);
      for (; ; ) {
        let o = i.advance();
        if (o)
          return o;
      }
    }
  }
  class qK {
    constructor(e) {
      this.string = e;
    }
    get length() {
      return this.string.length;
    }
    chunk(e) {
      return this.string.slice(e);
    }
    get lineChunks() {
      return false;
    }
    read(e, n) {
      return this.string.slice(e, n);
    }
  }
  new ze({
    perNode: true
  });
  let GK = 0;
  class hr {
    constructor(e, n, r, i) {
      this.name = e, this.set = n, this.base = r, this.modified = i, this.id = GK++;
    }
    toString() {
      let { name: e } = this;
      for (let n of this.modified)
        n.name && (e = `${n.name}(${e})`);
      return e;
    }
    static define(e, n) {
      let r = typeof e == "string" ? e : "?";
      if (e instanceof hr && (n = e), n == null ? void 0 : n.base)
        throw new Error("Can not derive from a modified tag");
      let i = new hr(r, [], null, []);
      if (i.set.push(i), n)
        for (let o of n.set)
          i.set.push(o);
      return i;
    }
    static defineModifier(e) {
      let n = new Ap(e);
      return (r) => r.modified.indexOf(n) > -1 ? r : Ap.get(r.base || r, r.modified.concat(n).sort((i, o) => i.id - o.id));
    }
  }
  let YK = 0;
  class Ap {
    constructor(e) {
      this.name = e, this.instances = [], this.id = YK++;
    }
    static get(e, n) {
      if (!n.length)
        return e;
      let r = n[0].instances.find((a) => a.base == e && XK(n, a.modified));
      if (r)
        return r;
      let i = [], o = new hr(e.name, i, e, n);
      for (let a of n)
        a.instances.push(o);
      let s = QK(n);
      for (let a of e.set)
        if (!a.modified.length)
          for (let l of s)
            i.push(Ap.get(a, l));
      return o;
    }
  }
  function XK(t, e) {
    return t.length == e.length && t.every((n, r) => n == e[r]);
  }
  function QK(t) {
    let e = [
      []
    ];
    for (let n = 0; n < t.length; n++)
      for (let r = 0, i = e.length; r < i; r++)
        e.push(e[r].concat(t[n]));
    return e.sort((n, r) => r.length - n.length);
  }
  function JK(t) {
    let e = /* @__PURE__ */ Object.create(null);
    for (let n in t) {
      let r = t[n];
      Array.isArray(r) || (r = [
        r
      ]);
      for (let i of n.split(" "))
        if (i) {
          let o = [], s = 2, a = i;
          for (let h = 0; ; ) {
            if (a == "..." && h > 0 && h + 3 == i.length) {
              s = 1;
              break;
            }
            let p = /^"(?:[^"\\]|\\.)*?"|[^\/!]+/.exec(a);
            if (!p)
              throw new RangeError("Invalid path: " + i);
            if (o.push(p[0] == "*" ? "" : p[0][0] == '"' ? JSON.parse(p[0]) : p[0]), h += p[0].length, h == i.length)
              break;
            let v = i[h++];
            if (h == i.length && v == "!") {
              s = 0;
              break;
            }
            if (v != "/")
              throw new RangeError("Invalid path: " + i);
            a = i.slice(h);
          }
          let l = o.length - 1, c = o[l];
          if (!c)
            throw new RangeError("Invalid path: " + i);
          let u = new Vu(r, s, l > 0 ? o.slice(0, l) : null);
          e[c] = u.sort(e[c]);
        }
    }
    return RL.add(e);
  }
  const RL = new ze({
    combine(t, e) {
      let n, r, i;
      for (; t || e; ) {
        if (!t || e && t.depth >= e.depth ? (i = e, e = e.next) : (i = t, t = t.next), n && n.mode == i.mode && !i.context && !n.context)
          continue;
        let o = new Vu(i.tags, i.mode, i.context);
        n ? n.next = o : r = o, n = o;
      }
      return r;
    }
  });
  class Vu {
    constructor(e, n, r, i) {
      this.tags = e, this.mode = n, this.context = r, this.next = i;
    }
    get opaque() {
      return this.mode == 0;
    }
    get inherit() {
      return this.mode == 1;
    }
    sort(e) {
      return !e || e.depth < this.depth ? (this.next = e, this) : (e.next = this.sort(e.next), e);
    }
    get depth() {
      return this.context ? this.context.length : 0;
    }
  }
  Vu.empty = new Vu([], 2, null);
  function _L(t, e) {
    let n = /* @__PURE__ */ Object.create(null);
    for (let o of t)
      if (!Array.isArray(o.tag))
        n[o.tag.id] = o.class;
      else
        for (let s of o.tag)
          n[s.id] = o.class;
    let { scope: r, all: i = null } = e || {};
    return {
      style: (o) => {
        let s = i;
        for (let a of o)
          for (let l of a.set) {
            let c = n[l.id];
            if (c) {
              s = s ? s + " " + c : c;
              break;
            }
          }
        return s;
      },
      scope: r
    };
  }
  function ZK(t, e) {
    let n = null;
    for (let r of t) {
      let i = r.style(e);
      i && (n = n ? n + " " + i : i);
    }
    return n;
  }
  function eq(t, e, n, r = 0, i = t.length) {
    let o = new tq(r, Array.isArray(e) ? e : [
      e
    ], n);
    o.highlightRange(t.cursor(), r, i, "", o.highlighters), o.flush(i);
  }
  class tq {
    constructor(e, n, r) {
      this.at = e, this.highlighters = n, this.span = r, this.class = "";
    }
    startSpan(e, n) {
      n != this.class && (this.flush(e), e > this.at && (this.at = e), this.class = n);
    }
    flush(e) {
      e > this.at && this.class && this.span(this.at, e, this.class);
    }
    highlightRange(e, n, r, i, o) {
      let { type: s, from: a, to: l } = e;
      if (a >= r || l <= n)
        return;
      s.isTop && (o = this.highlighters.filter((v) => !v.scope || v.scope(s)));
      let c = i, u = nq(e) || Vu.empty, h = ZK(o, u.tags);
      if (h && (c && (c += " "), c += h, u.mode == 1 && (i += (i ? " " : "") + h)), this.startSpan(Math.max(n, a), c), u.opaque)
        return;
      let p = e.tree && e.tree.prop(ze.mounted);
      if (p && p.overlay) {
        let v = e.node.enter(p.overlay[0].from + a, 1), y = this.highlighters.filter((T) => !T.scope || T.scope(p.tree.type)), S = e.firstChild();
        for (let T = 0, w = a; ; T++) {
          let k = T < p.overlay.length ? p.overlay[T] : null, C = k ? k.from + a : l, O = Math.max(n, w), L = Math.min(r, C);
          if (O < L && S)
            for (; e.from < L && (this.highlightRange(e, O, L, i, o), this.startSpan(Math.min(L, e.to), c), !(e.to >= C || !e.nextSibling())); )
              ;
          if (!k || C > r)
            break;
          w = k.to + a, w > n && (this.highlightRange(v.cursor(), Math.max(n, k.from + a), Math.min(r, w), "", y), this.startSpan(Math.min(r, w), c));
        }
        S && e.parent();
      } else if (e.firstChild()) {
        p && (i = "");
        do
          if (!(e.to <= n)) {
            if (e.from >= r)
              break;
            this.highlightRange(e, n, r, i, o), this.startSpan(Math.min(r, e.to), c);
          }
        while (e.nextSibling());
        e.parent();
      }
    }
  }
  function nq(t) {
    let e = t.type.prop(RL);
    for (; e && e.context && !t.matchContext(e.context); )
      e = e.next;
    return e || null;
  }
  const ce = hr.define, Ih = ce(), So = ce(), bT = ce(So), xT = ce(So), wo = ce(), Bh = ce(wo), G0 = ce(wo), si = ce(), ms = ce(si), ii = ce(), oi = ce(), w1 = ce(), sc = ce(w1), Nh = ce(), G = {
    comment: Ih,
    lineComment: ce(Ih),
    blockComment: ce(Ih),
    docComment: ce(Ih),
    name: So,
    variableName: ce(So),
    typeName: bT,
    tagName: ce(bT),
    propertyName: xT,
    attributeName: ce(xT),
    className: ce(So),
    labelName: ce(So),
    namespace: ce(So),
    macroName: ce(So),
    literal: wo,
    string: Bh,
    docString: ce(Bh),
    character: ce(Bh),
    attributeValue: ce(Bh),
    number: G0,
    integer: ce(G0),
    float: ce(G0),
    bool: ce(wo),
    regexp: ce(wo),
    escape: ce(wo),
    color: ce(wo),
    url: ce(wo),
    keyword: ii,
    self: ce(ii),
    null: ce(ii),
    atom: ce(ii),
    unit: ce(ii),
    modifier: ce(ii),
    operatorKeyword: ce(ii),
    controlKeyword: ce(ii),
    definitionKeyword: ce(ii),
    moduleKeyword: ce(ii),
    operator: oi,
    derefOperator: ce(oi),
    arithmeticOperator: ce(oi),
    logicOperator: ce(oi),
    bitwiseOperator: ce(oi),
    compareOperator: ce(oi),
    updateOperator: ce(oi),
    definitionOperator: ce(oi),
    typeOperator: ce(oi),
    controlOperator: ce(oi),
    punctuation: w1,
    separator: ce(w1),
    bracket: sc,
    angleBracket: ce(sc),
    squareBracket: ce(sc),
    paren: ce(sc),
    brace: ce(sc),
    content: si,
    heading: ms,
    heading1: ce(ms),
    heading2: ce(ms),
    heading3: ce(ms),
    heading4: ce(ms),
    heading5: ce(ms),
    heading6: ce(ms),
    contentSeparator: ce(si),
    list: ce(si),
    quote: ce(si),
    emphasis: ce(si),
    strong: ce(si),
    link: ce(si),
    monospace: ce(si),
    strikethrough: ce(si),
    inserted: ce(),
    deleted: ce(),
    changed: ce(),
    invalid: ce(),
    meta: Nh,
    documentMeta: ce(Nh),
    annotation: ce(Nh),
    processingInstruction: ce(Nh),
    definition: hr.defineModifier("definition"),
    constant: hr.defineModifier("constant"),
    function: hr.defineModifier("function"),
    standard: hr.defineModifier("standard"),
    local: hr.defineModifier("local"),
    special: hr.defineModifier("special")
  };
  for (let t in G) {
    let e = G[t];
    e instanceof hr && (e.name = t);
  }
  _L([
    {
      tag: G.link,
      class: "tok-link"
    },
    {
      tag: G.heading,
      class: "tok-heading"
    },
    {
      tag: G.emphasis,
      class: "tok-emphasis"
    },
    {
      tag: G.strong,
      class: "tok-strong"
    },
    {
      tag: G.keyword,
      class: "tok-keyword"
    },
    {
      tag: G.atom,
      class: "tok-atom"
    },
    {
      tag: G.bool,
      class: "tok-bool"
    },
    {
      tag: G.url,
      class: "tok-url"
    },
    {
      tag: G.labelName,
      class: "tok-labelName"
    },
    {
      tag: G.inserted,
      class: "tok-inserted"
    },
    {
      tag: G.deleted,
      class: "tok-deleted"
    },
    {
      tag: G.literal,
      class: "tok-literal"
    },
    {
      tag: G.string,
      class: "tok-string"
    },
    {
      tag: G.number,
      class: "tok-number"
    },
    {
      tag: [
        G.regexp,
        G.escape,
        G.special(G.string)
      ],
      class: "tok-string2"
    },
    {
      tag: G.variableName,
      class: "tok-variableName"
    },
    {
      tag: G.local(G.variableName),
      class: "tok-variableName tok-local"
    },
    {
      tag: G.definition(G.variableName),
      class: "tok-variableName tok-definition"
    },
    {
      tag: G.special(G.variableName),
      class: "tok-variableName2"
    },
    {
      tag: G.definition(G.propertyName),
      class: "tok-propertyName tok-definition"
    },
    {
      tag: G.typeName,
      class: "tok-typeName"
    },
    {
      tag: G.namespace,
      class: "tok-namespace"
    },
    {
      tag: G.className,
      class: "tok-className"
    },
    {
      tag: G.macroName,
      class: "tok-macroName"
    },
    {
      tag: G.propertyName,
      class: "tok-propertyName"
    },
    {
      tag: G.operator,
      class: "tok-operator"
    },
    {
      tag: G.comment,
      class: "tok-comment"
    },
    {
      tag: G.meta,
      class: "tok-meta"
    },
    {
      tag: G.invalid,
      class: "tok-invalid"
    },
    {
      tag: G.punctuation,
      class: "tok-punctuation"
    }
  ]);
  var Y0;
  const wc = new ze(), rq = new ze();
  class Fr {
    constructor(e, n, r = [], i = "") {
      this.data = e, this.name = i, $e.prototype.hasOwnProperty("tree") || Object.defineProperty($e.prototype, "tree", {
        get() {
          return pn(this);
        }
      }), this.parser = n, this.extension = [
        Xo.of(this),
        $e.languageData.of((o, s, a) => {
          let l = ST(o, s, a), c = l.type.prop(wc);
          if (!c)
            return [];
          let u = o.facet(c), h = l.type.prop(rq);
          if (h) {
            let p = l.resolve(s - l.from, a);
            for (let v of h)
              if (v.test(p, o)) {
                let y = o.facet(v.facet);
                return v.type == "replace" ? y : y.concat(u);
              }
          }
          return u;
        })
      ].concat(r);
    }
    isActiveAt(e, n, r = -1) {
      return ST(e, n, r).type.prop(wc) == this.data;
    }
    findRegions(e) {
      let n = e.facet(Xo);
      if ((n == null ? void 0 : n.data) == this.data)
        return [
          {
            from: 0,
            to: e.doc.length
          }
        ];
      if (!n || !n.allowsNesting)
        return [];
      let r = [], i = (o, s) => {
        if (o.prop(wc) == this.data) {
          r.push({
            from: s,
            to: s + o.length
          });
          return;
        }
        let a = o.prop(ze.mounted);
        if (a) {
          if (a.tree.prop(wc) == this.data) {
            if (a.overlay)
              for (let l of a.overlay)
                r.push({
                  from: l.from + s,
                  to: l.to + s
                });
            else
              r.push({
                from: s,
                to: s + o.length
              });
            return;
          } else if (a.overlay) {
            let l = r.length;
            if (i(a.tree, a.overlay[0].from + s), r.length > l)
              return;
          }
        }
        for (let l = 0; l < o.children.length; l++) {
          let c = o.children[l];
          c instanceof en && i(c, o.positions[l] + s);
        }
      };
      return i(pn(e), 0), r;
    }
    get allowsNesting() {
      return true;
    }
  }
  Fr.setState = Ee.define();
  function ST(t, e, n) {
    let r = t.facet(Xo), i = pn(t).topNode;
    if (!r || r.allowsNesting)
      for (let o = i; o; o = o.enter(e, n, Tt.ExcludeBuffers | Tt.EnterBracketed))
        o.type.isTop && (i = o);
    return i;
  }
  function pn(t) {
    let e = t.field(Fr.state, false);
    return e ? e.tree : en.empty;
  }
  function DL(t, e, n = 50) {
    var r;
    let i = (r = t.field(Fr.state, false)) === null || r === void 0 ? void 0 : r.context;
    if (!i)
      return null;
    let o = i.viewport;
    i.updateViewport({
      from: 0,
      to: e
    });
    let s = i.isDone(e) || i.work(n, e) ? i.tree : null;
    return i.updateViewport(o), s;
  }
  class iq {
    constructor(e) {
      this.doc = e, this.cursorPos = 0, this.string = "", this.cursor = e.iter();
    }
    get length() {
      return this.doc.length;
    }
    syncTo(e) {
      return this.string = this.cursor.next(e - this.cursorPos).value, this.cursorPos = e + this.string.length, this.cursorPos - this.string.length;
    }
    chunk(e) {
      return this.syncTo(e), this.string;
    }
    get lineChunks() {
      return true;
    }
    read(e, n) {
      let r = this.cursorPos - this.string.length;
      return e < r || n >= this.cursorPos ? this.doc.sliceString(e, n) : this.string.slice(e - r, n - r);
    }
  }
  let ac = null;
  class Ep {
    constructor(e, n, r = [], i, o, s, a, l) {
      this.parser = e, this.state = n, this.fragments = r, this.tree = i, this.treeLen = o, this.viewport = s, this.skipped = a, this.scheduleOn = l, this.parse = null, this.tempSkipped = [];
    }
    static create(e, n, r) {
      return new Ep(e, n, [], en.empty, 0, r, [], null);
    }
    startParse() {
      return this.parser.startParse(new iq(this.state.doc), this.fragments);
    }
    work(e, n) {
      return n != null && n >= this.state.doc.length && (n = void 0), this.tree != en.empty && this.isDone(n ?? this.state.doc.length) ? (this.takeTree(), true) : this.withContext(() => {
        var r;
        if (typeof e == "number") {
          let i = Date.now() + e;
          e = () => Date.now() > i;
        }
        for (this.parse || (this.parse = this.startParse()), n != null && (this.parse.stoppedAt == null || this.parse.stoppedAt > n) && n < this.state.doc.length && this.parse.stopAt(n); ; ) {
          let i = this.parse.advance();
          if (i)
            if (this.fragments = this.withoutTempSkipped(Ns.addTree(i, this.fragments, this.parse.stoppedAt != null)), this.treeLen = (r = this.parse.stoppedAt) !== null && r !== void 0 ? r : this.state.doc.length, this.tree = i, this.parse = null, this.treeLen < (n ?? this.state.doc.length))
              this.parse = this.startParse();
            else
              return true;
          if (e())
            return false;
        }
      });
    }
    takeTree() {
      let e, n;
      this.parse && (e = this.parse.parsedPos) >= this.treeLen && ((this.parse.stoppedAt == null || this.parse.stoppedAt > e) && this.parse.stopAt(e), this.withContext(() => {
        for (; !(n = this.parse.advance()); )
          ;
      }), this.treeLen = e, this.tree = n, this.fragments = this.withoutTempSkipped(Ns.addTree(this.tree, this.fragments, true)), this.parse = null);
    }
    withContext(e) {
      let n = ac;
      ac = this;
      try {
        return e();
      } finally {
        ac = n;
      }
    }
    withoutTempSkipped(e) {
      for (let n; n = this.tempSkipped.pop(); )
        e = wT(e, n.from, n.to);
      return e;
    }
    changes(e, n) {
      let { fragments: r, tree: i, treeLen: o, viewport: s, skipped: a } = this;
      if (this.takeTree(), !e.empty) {
        let l = [];
        if (e.iterChangedRanges((c, u, h, p) => l.push({
          fromA: c,
          toA: u,
          fromB: h,
          toB: p
        })), r = Ns.applyChanges(r, l), i = en.empty, o = 0, s = {
          from: e.mapPos(s.from, -1),
          to: e.mapPos(s.to, 1)
        }, this.skipped.length) {
          a = [];
          for (let c of this.skipped) {
            let u = e.mapPos(c.from, 1), h = e.mapPos(c.to, -1);
            u < h && a.push({
              from: u,
              to: h
            });
          }
        }
      }
      return new Ep(this.parser, n, r, i, o, s, a, this.scheduleOn);
    }
    updateViewport(e) {
      if (this.viewport.from == e.from && this.viewport.to == e.to)
        return false;
      this.viewport = e;
      let n = this.skipped.length;
      for (let r = 0; r < this.skipped.length; r++) {
        let { from: i, to: o } = this.skipped[r];
        i < e.to && o > e.from && (this.fragments = wT(this.fragments, i, o), this.skipped.splice(r--, 1));
      }
      return this.skipped.length >= n ? false : (this.reset(), true);
    }
    reset() {
      this.parse && (this.takeTree(), this.parse = null);
    }
    skipUntilInView(e, n) {
      this.skipped.push({
        from: e,
        to: n
      });
    }
    static getSkippingParser(e) {
      return new class extends KK {
        createParse(n, r, i) {
          let o = i[0].from, s = i[i.length - 1].to;
          return {
            parsedPos: o,
            advance() {
              let l = ac;
              if (l) {
                for (let c of i)
                  l.tempSkipped.push(c);
                e && (l.scheduleOn = l.scheduleOn ? Promise.all([
                  l.scheduleOn,
                  e
                ]) : e);
              }
              return this.parsedPos = s, new en(Cr.none, [], [], s - o);
            },
            stoppedAt: null,
            stopAt() {
            }
          };
        }
      }();
    }
    isDone(e) {
      e = Math.min(e, this.state.doc.length);
      let n = this.fragments;
      return this.treeLen >= e && n.length && n[0].from == 0 && n[0].to >= e;
    }
    static get() {
      return ac;
    }
  }
  function wT(t, e, n) {
    return Ns.applyChanges(t, [
      {
        fromA: e,
        toA: n,
        fromB: e,
        toB: n
      }
    ]);
  }
  class bl {
    constructor(e) {
      this.context = e, this.tree = e.tree;
    }
    apply(e) {
      if (!e.docChanged && this.tree == this.context.tree)
        return this;
      let n = this.context.changes(e.changes, e.state), r = this.context.treeLen == e.startState.doc.length ? void 0 : Math.max(e.changes.mapPos(this.context.treeLen), n.viewport.to);
      return n.work(20, r) || n.takeTree(), new bl(n);
    }
    static init(e) {
      let n = Math.min(3e3, e.doc.length), r = Ep.create(e.facet(Xo).parser, e, {
        from: 0,
        to: n
      });
      return r.work(20, n) || r.takeTree(), new bl(r);
    }
  }
  Fr.state = Kt.define({
    create: bl.init,
    update(t, e) {
      for (let n of e.effects)
        if (n.is(Fr.setState))
          return n.value;
      return e.startState.facet(Xo) != e.state.facet(Xo) ? bl.init(e.state) : t.apply(e);
    }
  });
  let IL = (t) => {
    let e = setTimeout(() => t(), 500);
    return () => clearTimeout(e);
  };
  typeof requestIdleCallback < "u" && (IL = (t) => {
    let e = -1, n = setTimeout(() => {
      e = requestIdleCallback(t, {
        timeout: 500 - 100
      });
    }, 100);
    return () => e < 0 ? clearTimeout(n) : cancelIdleCallback(e);
  });
  const X0 = typeof navigator < "u" && ((Y0 = navigator.scheduling) === null || Y0 === void 0 ? void 0 : Y0.isInputPending) ? () => navigator.scheduling.isInputPending() : null, oq = kt.fromClass(class {
    constructor(e) {
      this.view = e, this.working = null, this.workScheduled = 0, this.chunkEnd = -1, this.chunkBudget = -1, this.work = this.work.bind(this), this.scheduleWork();
    }
    update(e) {
      let n = this.view.state.field(Fr.state).context;
      (n.updateViewport(e.view.viewport) || this.view.viewport.to > n.treeLen) && this.scheduleWork(), (e.docChanged || e.selectionSet) && (this.view.hasFocus && (this.chunkBudget += 50), this.scheduleWork()), this.checkAsyncSchedule(n);
    }
    scheduleWork() {
      if (this.working)
        return;
      let { state: e } = this.view, n = e.field(Fr.state);
      (n.tree != n.context.tree || !n.context.isDone(e.doc.length)) && (this.working = IL(this.work));
    }
    work(e) {
      this.working = null;
      let n = Date.now();
      if (this.chunkEnd < n && (this.chunkEnd < 0 || this.view.hasFocus) && (this.chunkEnd = n + 3e4, this.chunkBudget = 3e3), this.chunkBudget <= 0)
        return;
      let { state: r, viewport: { to: i } } = this.view, o = r.field(Fr.state);
      if (o.tree == o.context.tree && o.context.isDone(i + 1e5))
        return;
      let s = Date.now() + Math.min(this.chunkBudget, 100, e && !X0 ? Math.max(25, e.timeRemaining() - 5) : 1e9), a = o.context.treeLen < i && r.doc.length > i + 1e3, l = o.context.work(() => X0 && X0() || Date.now() > s, i + (a ? 0 : 1e5));
      this.chunkBudget -= Date.now() - n, (l || this.chunkBudget <= 0) && (o.context.takeTree(), this.view.dispatch({
        effects: Fr.setState.of(new bl(o.context))
      })), this.chunkBudget > 0 && !(l && !a) && this.scheduleWork(), this.checkAsyncSchedule(o.context);
    }
    checkAsyncSchedule(e) {
      e.scheduleOn && (this.workScheduled++, e.scheduleOn.then(() => this.scheduleWork()).catch((n) => In(this.view.state, n)).then(() => this.workScheduled--), e.scheduleOn = null);
    }
    destroy() {
      this.working && this.working();
    }
    isWorking() {
      return !!(this.working || this.workScheduled > 0);
    }
  }, {
    eventHandlers: {
      focus() {
        this.scheduleWork();
      }
    }
  }), Xo = me.define({
    combine(t) {
      return t.length ? t[0] : null;
    },
    enables: (t) => [
      Fr.state,
      oq,
      ue.contentAttributes.compute([
        t
      ], (e) => {
        let n = e.facet(t);
        return n && n.name ? {
          "data-language": n.name
        } : {};
      })
    ]
  }), sq = me.define(), xl = me.define({
    combine: (t) => {
      if (!t.length)
        return "  ";
      let e = t[0];
      if (!e || /\S/.test(e) || Array.from(e).some((n) => n != e[0]))
        throw new Error("Invalid indent unit: " + JSON.stringify(t[0]));
      return e;
    }
  });
  function Pp(t) {
    let e = t.facet(xl);
    return e.charCodeAt(0) == 9 ? t.tabSize * e.length : e.length;
  }
  function Wu(t, e) {
    let n = "", r = t.tabSize, i = t.facet(xl)[0];
    if (i == "	") {
      for (; e >= r; )
        n += "	", e -= r;
      i = " ";
    }
    for (let o = 0; o < e; o++)
      n += i;
    return n;
  }
  function Gx(t, e) {
    t instanceof $e && (t = new Um(t));
    for (let r of t.state.facet(sq)) {
      let i = r(t, e);
      if (i !== void 0)
        return i;
    }
    let n = pn(t.state);
    return n.length >= e ? lq(t, n, e) : null;
  }
  class Um {
    constructor(e, n = {}) {
      this.state = e, this.options = n, this.unit = Pp(e);
    }
    lineAt(e, n = 1) {
      let r = this.state.doc.lineAt(e), { simulateBreak: i, simulateDoubleBreak: o } = this.options;
      return i != null && i >= r.from && i <= r.to ? o && i == e ? {
        text: "",
        from: e
      } : (n < 0 ? i < e : i <= e) ? {
        text: r.text.slice(i - r.from),
        from: i
      } : {
        text: r.text.slice(0, i - r.from),
        from: r.from
      } : r;
    }
    textAfterPos(e, n = 1) {
      if (this.options.simulateDoubleBreak && e == this.options.simulateBreak)
        return "";
      let { text: r, from: i } = this.lineAt(e, n);
      return r.slice(e - i, Math.min(r.length, e + 100 - i));
    }
    column(e, n = 1) {
      let { text: r, from: i } = this.lineAt(e, n), o = this.countColumn(r, e - i), s = this.options.overrideIndentation ? this.options.overrideIndentation(i) : -1;
      return s > -1 && (o += s - this.countColumn(r, r.search(/\S|$/))), o;
    }
    countColumn(e, n = e.length) {
      return El(e, this.state.tabSize, n);
    }
    lineIndent(e, n = 1) {
      let { text: r, from: i } = this.lineAt(e, n), o = this.options.overrideIndentation;
      if (o) {
        let s = o(i);
        if (s > -1)
          return s;
      }
      return this.countColumn(r, r.search(/\S|$/));
    }
    get simulatedBreak() {
      return this.options.simulateBreak || null;
    }
  }
  const aq = new ze();
  function lq(t, e, n) {
    let r = e.resolveStack(n), i = e.resolveInner(n, -1).resolve(n, 0).enterUnfinishedNodesBefore(n);
    if (i != r.node) {
      let o = [];
      for (let s = i; s && !(s.from < r.node.from || s.to > r.node.to || s.from == r.node.from && s.type == r.node.type); s = s.parent)
        o.push(s);
      for (let s = o.length - 1; s >= 0; s--)
        r = {
          node: o[s],
          next: r
        };
    }
    return BL(r, t, n);
  }
  function BL(t, e, n) {
    for (let r = t; r; r = r.next) {
      let i = uq(r.node);
      if (i)
        return i(Yx.create(e, n, r));
    }
    return 0;
  }
  function cq(t) {
    return t.pos == t.options.simulateBreak && t.options.simulateDoubleBreak;
  }
  function uq(t) {
    let e = t.type.prop(aq);
    if (e)
      return e;
    let n = t.firstChild, r;
    if (n && (r = n.type.prop(ze.closedBy))) {
      let i = t.lastChild, o = i && r.indexOf(i.name) > -1;
      return (s) => pq(s, true, 1, void 0, o && !cq(s) ? i.from : void 0);
    }
    return t.parent == null ? fq : null;
  }
  function fq() {
    return 0;
  }
  class Yx extends Um {
    constructor(e, n, r) {
      super(e.state, e.options), this.base = e, this.pos = n, this.context = r;
    }
    get node() {
      return this.context.node;
    }
    static create(e, n, r) {
      return new Yx(e, n, r);
    }
    get textAfter() {
      return this.textAfterPos(this.pos);
    }
    get baseIndent() {
      return this.baseIndentFor(this.node);
    }
    baseIndentFor(e) {
      let n = this.state.doc.lineAt(e.from);
      for (; ; ) {
        let r = e.resolve(n.from);
        for (; r.parent && r.parent.from == r.from; )
          r = r.parent;
        if (hq(r, e))
          break;
        n = this.state.doc.lineAt(r.from);
      }
      return this.lineIndent(n.from);
    }
    continue() {
      return BL(this.context.next, this.base, this.pos);
    }
  }
  function hq(t, e) {
    for (let n = e; n; n = n.parent)
      if (t == n)
        return true;
    return false;
  }
  function dq(t) {
    let e = t.node, n = e.childAfter(e.from), r = e.lastChild;
    if (!n)
      return null;
    let i = t.options.simulateBreak, o = t.state.doc.lineAt(n.from), s = i == null || i <= o.from ? o.to : Math.min(o.to, i);
    for (let a = n.to; ; ) {
      let l = e.childAfter(a);
      if (!l || l == r)
        return null;
      if (!l.type.isSkipped) {
        if (l.from >= s)
          return null;
        let c = /^ */.exec(o.text.slice(n.to - o.from))[0].length;
        return {
          from: n.from,
          to: n.to + c
        };
      }
      a = l.to;
    }
  }
  function pq(t, e, n, r, i) {
    let o = t.textAfter, s = o.match(/^\s*/)[0].length, a = r && o.slice(s, s + r.length) == r || i == t.pos + s, l = e ? dq(t) : null;
    return l ? a ? t.column(l.from) : t.column(l.to) : t.baseIndent + (a ? 0 : t.unit * n);
  }
  const mq = 200;
  function gq() {
    return $e.transactionFilter.of((t) => {
      if (!t.docChanged || !t.isUserEvent("input.type") && !t.isUserEvent("input.complete"))
        return t;
      let e = t.startState.languageDataAt("indentOnInput", t.startState.selection.main.head);
      if (!e.length)
        return t;
      let n = t.newDoc, { head: r } = t.newSelection.main, i = n.lineAt(r);
      if (r > i.from + mq)
        return t;
      let o = n.sliceString(i.from, r);
      if (!e.some((c) => c.test(o)))
        return t;
      let { state: s } = t, a = -1, l = [];
      for (let { head: c } of s.selection.ranges) {
        let u = s.doc.lineAt(c);
        if (u.from == a)
          continue;
        a = u.from;
        let h = Gx(s, u.from);
        if (h == null)
          continue;
        let p = /^\s*/.exec(u.text)[0], v = Wu(s, h);
        p != v && l.push({
          from: u.from,
          to: u.from + p.length,
          insert: v
        });
      }
      return l.length ? [
        t,
        {
          changes: l,
          sequential: true
        }
      ] : t;
    });
  }
  const vq = me.define(), yq = new ze();
  function bq(t, e, n) {
    let r = pn(t);
    if (r.length < n)
      return null;
    let i = r.resolveStack(n, 1), o = null;
    for (let s = i; s; s = s.next) {
      let a = s.node;
      if (a.to <= n || a.from > n)
        continue;
      if (o && a.from < e)
        break;
      let l = a.type.prop(yq);
      if (l && (a.to < r.length - 50 || r.length == t.doc.length || !xq(a))) {
        let c = l(a, t);
        c && c.from <= n && c.from >= e && c.to > n && (o = c);
      }
    }
    return o;
  }
  function xq(t) {
    let e = t.lastChild;
    return e && e.to == t.to && e.type.isError;
  }
  function Op(t, e, n) {
    for (let r of t.facet(vq)) {
      let i = r(t, e, n);
      if (i)
        return i;
    }
    return bq(t, e, n);
  }
  function NL(t, e) {
    let n = e.mapPos(t.from, 1), r = e.mapPos(t.to, -1);
    return n >= r ? void 0 : {
      from: n,
      to: r
    };
  }
  const Km = Ee.define({
    map: NL
  }), ff = Ee.define({
    map: NL
  });
  function $L(t) {
    let e = [];
    for (let { head: n } of t.state.selection.ranges)
      e.some((r) => r.from <= n && r.to >= n) || e.push(t.lineBlockAt(n));
    return e;
  }
  const Ys = Kt.define({
    create() {
      return be.none;
    },
    update(t, e) {
      e.isUserEvent("delete") && e.changes.iterChangedRanges((n, r) => t = kT(t, n, r)), t = t.map(e.changes);
      for (let n of e.effects)
        if (n.is(Km) && !Sq(t, n.value.from, n.value.to)) {
          let { preparePlaceholder: r } = e.state.facet(Xx), i = r ? be.replace({
            widget: new Aq(r(e.state, n.value))
          }) : CT;
          t = t.update({
            add: [
              i.range(n.value.from, n.value.to)
            ]
          });
        } else
          n.is(ff) && (t = t.update({
            filter: (r, i) => n.value.from != r || n.value.to != i,
            filterFrom: n.value.from,
            filterTo: n.value.to
          }));
      return e.selection && (t = kT(t, e.selection.main.head)), t;
    },
    provide: (t) => ue.decorations.from(t),
    toJSON(t, e) {
      let n = [];
      return t.between(0, e.doc.length, (r, i) => {
        n.push(r, i);
      }), n;
    },
    fromJSON(t) {
      if (!Array.isArray(t) || t.length % 2)
        throw new RangeError("Invalid JSON for fold state");
      let e = [];
      for (let n = 0; n < t.length; ) {
        let r = t[n++], i = t[n++];
        if (typeof r != "number" || typeof i != "number")
          throw new RangeError("Invalid JSON for fold state");
        e.push(CT.range(r, i));
      }
      return be.set(e, true);
    }
  });
  function kT(t, e, n = e) {
    let r = false;
    return t.between(e, n, (i, o) => {
      i < n && o > e && (r = true);
    }), r ? t.update({
      filterFrom: e,
      filterTo: n,
      filter: (i, o) => i >= n || o <= e
    }) : t;
  }
  function Lp(t, e, n) {
    var r;
    let i = null;
    return (r = t.field(Ys, false)) === null || r === void 0 || r.between(e, n, (o, s) => {
      (!i || i.from > o) && (i = {
        from: o,
        to: s
      });
    }), i;
  }
  function Sq(t, e, n) {
    let r = false;
    return t.between(e, e, (i, o) => {
      i == e && o == n && (r = true);
    }), r;
  }
  function zL(t, e) {
    return t.field(Ys, false) ? e : e.concat(Ee.appendConfig.of(WL()));
  }
  const FL = (t) => {
    for (let e of $L(t)) {
      let n = Op(t.state, e.from, e.to);
      if (n)
        return t.dispatch({
          effects: zL(t.state, [
            Km.of(n),
            VL(t, n)
          ])
        }), true;
    }
    return false;
  }, wq = (t) => {
    if (!t.state.field(Ys, false))
      return false;
    let e = [];
    for (let n of $L(t)) {
      let r = Lp(t.state, n.from, n.to);
      r && e.push(ff.of(r), VL(t, r, false));
    }
    return e.length && t.dispatch({
      effects: e
    }), e.length > 0;
  };
  function VL(t, e, n = true) {
    let r = t.state.doc.lineAt(e.from).number, i = t.state.doc.lineAt(e.to).number;
    return ue.announce.of(`${t.state.phrase(n ? "Folded lines" : "Unfolded lines")} ${r} ${t.state.phrase("to")} ${i}.`);
  }
  const kq = (t) => {
    let { state: e } = t, n = [];
    for (let r = 0; r < e.doc.length; ) {
      let i = t.lineBlockAt(r), o = Op(e, i.from, i.to);
      o && n.push(Km.of(o)), r = (o ? t.lineBlockAt(o.to) : i).to + 1;
    }
    return n.length && t.dispatch({
      effects: zL(t.state, n)
    }), !!n.length;
  }, Cq = (t) => {
    let e = t.state.field(Ys, false);
    if (!e || !e.size)
      return false;
    let n = [];
    return e.between(0, t.state.doc.length, (r, i) => {
      n.push(ff.of({
        from: r,
        to: i
      }));
    }), t.dispatch({
      effects: n
    }), true;
  }, Tq = [
    {
      key: "Ctrl-Shift-[",
      mac: "Cmd-Alt-[",
      run: FL
    },
    {
      key: "Ctrl-Shift-]",
      mac: "Cmd-Alt-]",
      run: wq
    },
    {
      key: "Ctrl-Alt-[",
      run: kq
    },
    {
      key: "Ctrl-Alt-]",
      run: Cq
    }
  ], Mq = {
    placeholderDOM: null,
    preparePlaceholder: null,
    placeholderText: "\u2026"
  }, Xx = me.define({
    combine(t) {
      return Oi(t, Mq);
    }
  });
  function WL(t) {
    let e = [
      Ys,
      Oq
    ];
    return t && e.push(Xx.of(t)), e;
  }
  function HL(t, e) {
    let { state: n } = t, r = n.facet(Xx), i = (s) => {
      let a = t.lineBlockAt(t.posAtDOM(s.target)), l = Lp(t.state, a.from, a.to);
      l && t.dispatch({
        effects: ff.of(l)
      }), s.preventDefault();
    };
    if (r.placeholderDOM)
      return r.placeholderDOM(t, i, e);
    let o = document.createElement("span");
    return o.textContent = r.placeholderText, o.setAttribute("aria-label", n.phrase("folded code")), o.title = n.phrase("unfold"), o.className = "cm-foldPlaceholder", o.onclick = i, o;
  }
  const CT = be.replace({
    widget: new class extends Li {
      toDOM(t) {
        return HL(t, null);
      }
    }()
  });
  class Aq extends Li {
    constructor(e) {
      super(), this.value = e;
    }
    eq(e) {
      return this.value == e.value;
    }
    toDOM(e) {
      return HL(e, this.value);
    }
  }
  const Eq = {
    openText: "\u2304",
    closedText: "\u203A",
    markerDOM: null,
    domEventHandlers: {},
    foldingChanged: () => false
  };
  class Q0 extends io {
    constructor(e, n) {
      super(), this.config = e, this.open = n;
    }
    eq(e) {
      return this.config == e.config && this.open == e.open;
    }
    toDOM(e) {
      if (this.config.markerDOM)
        return this.config.markerDOM(this.open);
      let n = document.createElement("span");
      return n.textContent = this.open ? this.config.openText : this.config.closedText, n.title = e.state.phrase(this.open ? "Fold line" : "Unfold line"), n;
    }
  }
  function Pq(t = {}) {
    let e = {
      ...Eq,
      ...t
    }, n = new Q0(e, true), r = new Q0(e, false), i = kt.fromClass(class {
      constructor(s) {
        this.from = s.viewport.from, this.markers = this.buildMarkers(s);
      }
      update(s) {
        (s.docChanged || s.viewportChanged || s.startState.facet(Xo) != s.state.facet(Xo) || s.startState.field(Ys, false) != s.state.field(Ys, false) || pn(s.startState) != pn(s.state) || e.foldingChanged(s)) && (this.markers = this.buildMarkers(s.view));
      }
      buildMarkers(s) {
        let a = new Ai();
        for (let l of s.viewportLineBlocks) {
          let c = Lp(s.state, l.from, l.to) ? r : Op(s.state, l.from, l.to) ? n : null;
          c && a.add(l.from, l.from, c);
        }
        return a.finish();
      }
    }), { domEventHandlers: o } = e;
    return [
      i,
      EK({
        class: "cm-foldGutter",
        markers(s) {
          var a;
          return ((a = s.plugin(i)) === null || a === void 0 ? void 0 : a.markers) || _e.empty;
        },
        initialSpacer() {
          return new Q0(e, false);
        },
        domEventHandlers: {
          ...o,
          click: (s, a, l) => {
            if (o.click && o.click(s, a, l))
              return true;
            let c = Lp(s.state, a.from, a.to);
            if (c)
              return s.dispatch({
                effects: ff.of(c)
              }), true;
            let u = Op(s.state, a.from, a.to);
            return u ? (s.dispatch({
              effects: Km.of(u)
            }), true) : false;
          }
        }
      }),
      WL()
    ];
  }
  const Oq = ue.baseTheme({
    ".cm-foldPlaceholder": {
      backgroundColor: "#eee",
      border: "1px solid #ddd",
      color: "#888",
      borderRadius: ".2em",
      margin: "0 1px",
      padding: "0 1px",
      cursor: "pointer"
    },
    ".cm-foldGutter span": {
      padding: "0 1px",
      cursor: "pointer"
    }
  });
  class hf {
    constructor(e, n) {
      this.specs = e;
      let r;
      function i(a) {
        let l = Ko.newName();
        return (r || (r = /* @__PURE__ */ Object.create(null)))["." + l] = a, l;
      }
      const o = typeof n.all == "string" ? n.all : n.all ? i(n.all) : void 0, s = n.scope;
      this.scope = s instanceof Fr ? (a) => a.prop(wc) == s.data : s ? (a) => a == s : void 0, this.style = _L(e.map((a) => ({
        tag: a.tag,
        class: a.class || i(Object.assign({}, a, {
          tag: null
        }))
      })), {
        all: o
      }).style, this.module = r ? new Ko(r) : null, this.themeType = n.themeType;
    }
    static define(e, n) {
      return new hf(e, n || {});
    }
  }
  const k1 = me.define(), jL = me.define({
    combine(t) {
      return t.length ? [
        t[0]
      ] : null;
    }
  });
  function J0(t) {
    let e = t.facet(k1);
    return e.length ? e : t.facet(jL);
  }
  function UL(t, e) {
    let n = [
      Rq
    ], r;
    return t instanceof hf && (t.module && n.push(ue.styleModule.of(t.module)), r = t.themeType), (e == null ? void 0 : e.fallback) ? n.push(jL.of(t)) : r ? n.push(k1.computeN([
      ue.darkTheme
    ], (i) => i.facet(ue.darkTheme) == (r == "dark") ? [
      t
    ] : [])) : n.push(k1.of(t)), n;
  }
  class Lq {
    constructor(e) {
      this.markCache = /* @__PURE__ */ Object.create(null), this.tree = pn(e.state), this.decorations = this.buildDeco(e, J0(e.state)), this.decoratedTo = e.viewport.to;
    }
    update(e) {
      let n = pn(e.state), r = J0(e.state), i = r != J0(e.startState), { viewport: o } = e.view, s = e.changes.mapPos(this.decoratedTo, 1);
      n.length < o.to && !i && n.type == this.tree.type && s >= o.to ? (this.decorations = this.decorations.map(e.changes), this.decoratedTo = s) : (n != this.tree || e.viewportChanged || i) && (this.tree = n, this.decorations = this.buildDeco(e.view, r), this.decoratedTo = o.to);
    }
    buildDeco(e, n) {
      if (!n || !this.tree.length)
        return be.none;
      let r = new Ai();
      for (let { from: i, to: o } of e.visibleRanges)
        eq(this.tree, n, (s, a, l) => {
          r.add(s, a, this.markCache[l] || (this.markCache[l] = be.mark({
            class: l
          })));
        }, i, o);
      return r.finish();
    }
  }
  const Rq = ns.high(kt.fromClass(Lq, {
    decorations: (t) => t.decorations
  })), _q = hf.define([
    {
      tag: G.meta,
      color: "#404740"
    },
    {
      tag: G.link,
      textDecoration: "underline"
    },
    {
      tag: G.heading,
      textDecoration: "underline",
      fontWeight: "bold"
    },
    {
      tag: G.emphasis,
      fontStyle: "italic"
    },
    {
      tag: G.strong,
      fontWeight: "bold"
    },
    {
      tag: G.strikethrough,
      textDecoration: "line-through"
    },
    {
      tag: G.keyword,
      color: "#708"
    },
    {
      tag: [
        G.atom,
        G.bool,
        G.url,
        G.contentSeparator,
        G.labelName
      ],
      color: "#219"
    },
    {
      tag: [
        G.literal,
        G.inserted
      ],
      color: "#164"
    },
    {
      tag: [
        G.string,
        G.deleted
      ],
      color: "#a11"
    },
    {
      tag: [
        G.regexp,
        G.escape,
        G.special(G.string)
      ],
      color: "#e40"
    },
    {
      tag: G.definition(G.variableName),
      color: "#00f"
    },
    {
      tag: G.local(G.variableName),
      color: "#30a"
    },
    {
      tag: [
        G.typeName,
        G.namespace
      ],
      color: "#085"
    },
    {
      tag: G.className,
      color: "#167"
    },
    {
      tag: [
        G.special(G.variableName),
        G.macroName
      ],
      color: "#256"
    },
    {
      tag: G.definition(G.propertyName),
      color: "#00c"
    },
    {
      tag: G.comment,
      color: "#940"
    },
    {
      tag: G.invalid,
      color: "#f00"
    }
  ]), Dq = ue.baseTheme({
    "&.cm-focused .cm-matchingBracket": {
      backgroundColor: "#328c8252"
    },
    "&.cm-focused .cm-nonmatchingBracket": {
      backgroundColor: "#bb555544"
    }
  }), KL = 1e4, qL = "()[]{}", GL = me.define({
    combine(t) {
      return Oi(t, {
        afterCursor: true,
        brackets: qL,
        maxScanDistance: KL,
        renderMatch: Nq
      });
    }
  }), Iq = be.mark({
    class: "cm-matchingBracket"
  }), Bq = be.mark({
    class: "cm-nonmatchingBracket"
  });
  function Nq(t) {
    let e = [], n = t.matched ? Iq : Bq;
    return e.push(n.range(t.start.from, t.start.to)), t.end && e.push(n.range(t.end.from, t.end.to)), e;
  }
  const $q = Kt.define({
    create() {
      return be.none;
    },
    update(t, e) {
      if (!e.docChanged && !e.selection)
        return t;
      let n = [], r = e.state.facet(GL);
      for (let i of e.state.selection.ranges) {
        if (!i.empty)
          continue;
        let o = mr(e.state, i.head, -1, r) || i.head > 0 && mr(e.state, i.head - 1, 1, r) || r.afterCursor && (mr(e.state, i.head, 1, r) || i.head < e.state.doc.length && mr(e.state, i.head + 1, -1, r));
        o && (n = n.concat(r.renderMatch(o, e.state)));
      }
      return be.set(n, true);
    },
    provide: (t) => ue.decorations.from(t)
  }), zq = [
    $q,
    Dq
  ];
  function Fq(t = {}) {
    return [
      GL.of(t),
      zq
    ];
  }
  const Vq = new ze();
  function C1(t, e, n) {
    let r = t.prop(e < 0 ? ze.openedBy : ze.closedBy);
    if (r)
      return r;
    if (t.name.length == 1) {
      let i = n.indexOf(t.name);
      if (i > -1 && i % 2 == (e < 0 ? 1 : 0))
        return [
          n[i + e]
        ];
    }
    return null;
  }
  function T1(t) {
    let e = t.type.prop(Vq);
    return e ? e(t.node) : t;
  }
  function mr(t, e, n, r = {}) {
    let i = r.maxScanDistance || KL, o = r.brackets || qL, s = pn(t), a = s.resolveInner(e, n);
    for (let l = a; l; l = l.parent) {
      let c = C1(l.type, n, o);
      if (c && l.from < l.to) {
        let u = T1(l);
        if (u && (n > 0 ? e >= u.from && e < u.to : e > u.from && e <= u.to))
          return Wq(t, e, n, l, u, c, o);
      }
    }
    return Hq(t, e, n, s, a.type, i, o);
  }
  function Wq(t, e, n, r, i, o, s) {
    let a = r.parent, l = {
      from: i.from,
      to: i.to
    }, c = 0, u = a == null ? void 0 : a.cursor();
    if (u && (n < 0 ? u.childBefore(r.from) : u.childAfter(r.to)))
      do
        if (n < 0 ? u.to <= r.from : u.from >= r.to) {
          if (c == 0 && o.indexOf(u.type.name) > -1 && u.from < u.to) {
            let h = T1(u);
            return {
              start: l,
              end: h ? {
                from: h.from,
                to: h.to
              } : void 0,
              matched: true
            };
          } else if (C1(u.type, n, s))
            c++;
          else if (C1(u.type, -n, s)) {
            if (c == 0) {
              let h = T1(u);
              return {
                start: l,
                end: h && h.from < h.to ? {
                  from: h.from,
                  to: h.to
                } : void 0,
                matched: false
              };
            }
            c--;
          }
        }
      while (n < 0 ? u.prevSibling() : u.nextSibling());
    return {
      start: l,
      matched: false
    };
  }
  function Hq(t, e, n, r, i, o, s) {
    let a = n < 0 ? t.sliceDoc(e - 1, e) : t.sliceDoc(e, e + 1), l = s.indexOf(a);
    if (l < 0 || l % 2 == 0 != n > 0)
      return null;
    let c = {
      from: n < 0 ? e - 1 : e,
      to: n > 0 ? e + 1 : e
    }, u = t.doc.iterRange(e, n > 0 ? t.doc.length : 0), h = 0;
    for (let p = 0; !u.next().done && p <= o; ) {
      let v = u.value;
      n < 0 && (p += v.length);
      let y = e + p * n;
      for (let S = n > 0 ? 0 : v.length - 1, T = n > 0 ? v.length : -1; S != T; S += n) {
        let w = s.indexOf(v[S]);
        if (!(w < 0 || r.resolveInner(y + S, 1).type != i))
          if (w % 2 == 0 == n > 0)
            h++;
          else {
            if (h == 1)
              return {
                start: c,
                end: {
                  from: y + S,
                  to: y + S + 1
                },
                matched: w >> 1 == l >> 1
              };
            h--;
          }
      }
      n > 0 && (p += v.length);
    }
    return u.done ? {
      start: c,
      matched: false
    } : null;
  }
  function TT(t, e, n, r = 0, i = 0) {
    e == null && (e = t.search(/[^\s\u00a0]/), e == -1 && (e = t.length));
    let o = i;
    for (let s = r; s < e; s++)
      t.charCodeAt(s) == 9 ? o += n - o % n : o++;
    return o;
  }
  class jq {
    constructor(e, n, r, i) {
      this.string = e, this.tabSize = n, this.indentUnit = r, this.overrideIndent = i, this.pos = 0, this.start = 0, this.lastColumnPos = 0, this.lastColumnValue = 0;
    }
    eol() {
      return this.pos >= this.string.length;
    }
    sol() {
      return this.pos == 0;
    }
    peek() {
      return this.string.charAt(this.pos) || void 0;
    }
    next() {
      if (this.pos < this.string.length)
        return this.string.charAt(this.pos++);
    }
    eat(e) {
      let n = this.string.charAt(this.pos), r;
      if (typeof e == "string" ? r = n == e : r = n && (e instanceof RegExp ? e.test(n) : e(n)), r)
        return ++this.pos, n;
    }
    eatWhile(e) {
      let n = this.pos;
      for (; this.eat(e); )
        ;
      return this.pos > n;
    }
    eatSpace() {
      let e = this.pos;
      for (; /[\s\u00a0]/.test(this.string.charAt(this.pos)); )
        ++this.pos;
      return this.pos > e;
    }
    skipToEnd() {
      this.pos = this.string.length;
    }
    skipTo(e) {
      let n = this.string.indexOf(e, this.pos);
      if (n > -1)
        return this.pos = n, true;
    }
    backUp(e) {
      this.pos -= e;
    }
    column() {
      return this.lastColumnPos < this.start && (this.lastColumnValue = TT(this.string, this.start, this.tabSize, this.lastColumnPos, this.lastColumnValue), this.lastColumnPos = this.start), this.lastColumnValue;
    }
    indentation() {
      var e;
      return (e = this.overrideIndent) !== null && e !== void 0 ? e : TT(this.string, null, this.tabSize);
    }
    match(e, n, r) {
      if (typeof e == "string") {
        let i = (s) => r ? s.toLowerCase() : s, o = this.string.substr(this.pos, e.length);
        return i(o) == i(e) ? (n !== false && (this.pos += e.length), true) : null;
      } else {
        let i = this.string.slice(this.pos).match(e);
        return i && i.index > 0 ? null : (i && n !== false && (this.pos += i[0].length), i);
      }
    }
    current() {
      return this.string.slice(this.start, this.pos);
    }
  }
  const Uq = /* @__PURE__ */ Object.create(null), MT = [
    Cr.none
  ], AT = [], ET = /* @__PURE__ */ Object.create(null), Kq = /* @__PURE__ */ Object.create(null);
  for (let [t, e] of [
    [
      "variable",
      "variableName"
    ],
    [
      "variable-2",
      "variableName.special"
    ],
    [
      "string-2",
      "string.special"
    ],
    [
      "def",
      "variableName.definition"
    ],
    [
      "tag",
      "tagName"
    ],
    [
      "attribute",
      "attributeName"
    ],
    [
      "type",
      "typeName"
    ],
    [
      "builtin",
      "variableName.standard"
    ],
    [
      "qualifier",
      "modifier"
    ],
    [
      "error",
      "invalid"
    ],
    [
      "header",
      "heading"
    ],
    [
      "property",
      "propertyName"
    ]
  ])
    Kq[t] = qq(Uq, e);
  function Z0(t, e) {
    AT.indexOf(t) > -1 || (AT.push(t), console.warn(e));
  }
  function qq(t, e) {
    let n = [];
    for (let a of e.split(" ")) {
      let l = [];
      for (let c of a.split(".")) {
        let u = t[c] || G[c];
        u ? typeof u == "function" ? l.length ? l = l.map(u) : Z0(c, `Modifier ${c} used at start of tag`) : l.length ? Z0(c, `Tag ${c} used as modifier`) : l = Array.isArray(u) ? u : [
          u
        ] : Z0(c, `Unknown highlighting tag ${c}`);
      }
      for (let c of l)
        n.push(c);
    }
    if (!n.length)
      return 0;
    let r = e.replace(/ /g, "_"), i = r + " " + n.map((a) => a.id), o = ET[i];
    if (o)
      return o.id;
    let s = ET[i] = Cr.define({
      id: MT.length,
      name: r,
      props: [
        JK({
          [r]: n
        })
      ]
    });
    return MT.push(s), s.id;
  }
  Je.RTL, Je.LTR;
  const Gq = (t) => {
    let { state: e } = t, n = e.doc.lineAt(e.selection.main.from), r = Jx(t.state, n.from);
    return r.line ? Yq(t) : r.block ? Qq(t) : false;
  };
  function Qx(t, e) {
    return ({ state: n, dispatch: r }) => {
      if (n.readOnly)
        return false;
      let i = t(e, n);
      return i ? (r(n.update(i)), true) : false;
    };
  }
  const Yq = Qx(eG, 0), Xq = Qx(YL, 0), Qq = Qx((t, e) => YL(t, e, Zq(e)), 0);
  function Jx(t, e) {
    let n = t.languageDataAt("commentTokens", e, 1);
    return n.length ? n[0] : {};
  }
  const lc = 50;
  function Jq(t, { open: e, close: n }, r, i) {
    let o = t.sliceDoc(r - lc, r), s = t.sliceDoc(i, i + lc), a = /\s*$/.exec(o)[0].length, l = /^\s*/.exec(s)[0].length, c = o.length - a;
    if (o.slice(c - e.length, c) == e && s.slice(l, l + n.length) == n)
      return {
        open: {
          pos: r - a,
          margin: a && 1
        },
        close: {
          pos: i + l,
          margin: l && 1
        }
      };
    let u, h;
    i - r <= 2 * lc ? u = h = t.sliceDoc(r, i) : (u = t.sliceDoc(r, r + lc), h = t.sliceDoc(i - lc, i));
    let p = /^\s*/.exec(u)[0].length, v = /\s*$/.exec(h)[0].length, y = h.length - v - n.length;
    return u.slice(p, p + e.length) == e && h.slice(y, y + n.length) == n ? {
      open: {
        pos: r + p + e.length,
        margin: /\s/.test(u.charAt(p + e.length)) ? 1 : 0
      },
      close: {
        pos: i - v - n.length,
        margin: /\s/.test(h.charAt(y - 1)) ? 1 : 0
      }
    } : null;
  }
  function Zq(t) {
    let e = [];
    for (let n of t.selection.ranges) {
      let r = t.doc.lineAt(n.from), i = n.to <= r.to ? r : t.doc.lineAt(n.to);
      i.from > r.from && i.from == n.to && (i = n.to == r.to + 1 ? r : t.doc.lineAt(n.to - 1));
      let o = e.length - 1;
      o >= 0 && e[o].to > r.from ? e[o].to = i.to : e.push({
        from: r.from + /^\s*/.exec(r.text)[0].length,
        to: i.to
      });
    }
    return e;
  }
  function YL(t, e, n = e.selection.ranges) {
    let r = n.map((o) => Jx(e, o.from).block);
    if (!r.every((o) => o))
      return null;
    let i = n.map((o, s) => Jq(e, r[s], o.from, o.to));
    if (t != 2 && !i.every((o) => o))
      return {
        changes: e.changes(n.map((o, s) => i[s] ? [] : [
          {
            from: o.from,
            insert: r[s].open + " "
          },
          {
            from: o.to,
            insert: " " + r[s].close
          }
        ]))
      };
    if (t != 1 && i.some((o) => o)) {
      let o = [];
      for (let s = 0, a; s < i.length; s++)
        if (a = i[s]) {
          let l = r[s], { open: c, close: u } = a;
          o.push({
            from: c.pos - l.open.length,
            to: c.pos + c.margin
          }, {
            from: u.pos - u.margin,
            to: u.pos + l.close.length
          });
        }
      return {
        changes: o
      };
    }
    return null;
  }
  function eG(t, e, n = e.selection.ranges) {
    let r = [], i = -1;
    e:
      for (let { from: o, to: s } of n) {
        let a = r.length, l = 1e9, c;
        for (let u = o; u <= s; ) {
          let h = e.doc.lineAt(u);
          if (c == null && (c = Jx(e, h.from).line, !c))
            continue e;
          if (h.from > i && (o == s || s > h.from)) {
            i = h.from;
            let p = /^\s*/.exec(h.text)[0].length, v = p == h.length, y = h.text.slice(p, p + c.length) == c ? p : -1;
            p < h.text.length && p < l && (l = p), r.push({
              line: h,
              comment: y,
              token: c,
              indent: p,
              empty: v,
              single: false
            });
          }
          u = h.to + 1;
        }
        if (l < 1e9)
          for (let u = a; u < r.length; u++)
            r[u].indent < r[u].line.text.length && (r[u].indent = l);
        r.length == a + 1 && (r[a].single = true);
      }
    if (t != 2 && r.some((o) => o.comment < 0 && (!o.empty || o.single))) {
      let o = [];
      for (let { line: a, token: l, indent: c, empty: u, single: h } of r)
        (h || !u) && o.push({
          from: a.from + c,
          insert: l + " "
        });
      let s = e.changes(o);
      return {
        changes: s,
        selection: e.selection.map(s, 1)
      };
    } else if (t != 1 && r.some((o) => o.comment >= 0)) {
      let o = [];
      for (let { line: s, comment: a, token: l } of r)
        if (a >= 0) {
          let c = s.from + a, u = c + l.length;
          s.text[u - s.from] == " " && u++, o.push({
            from: c,
            to: u
          });
        }
      return {
        changes: o
      };
    }
    return null;
  }
  const M1 = Pi.define(), tG = Pi.define(), nG = me.define(), XL = me.define({
    combine(t) {
      return Oi(t, {
        minDepth: 100,
        newGroupDelay: 500,
        joinToEvent: (e, n) => n
      }, {
        minDepth: Math.max,
        newGroupDelay: Math.min,
        joinToEvent: (e, n) => (r, i) => e(r, i) || n(r, i)
      });
    }
  }), QL = Kt.define({
    create() {
      return xi.empty;
    },
    update(t, e) {
      let n = e.state.facet(XL), r = e.annotation(M1);
      if (r) {
        let l = Bn.fromTransaction(e, r.selection), c = r.side, u = c == 0 ? t.undone : t.done;
        return l ? u = _p(u, u.length, n.minDepth, l) : u = ZL(u, e.startState.selection), new xi(c == 0 ? r.rest : u, c == 0 ? u : r.rest);
      }
      let i = e.annotation(tG);
      if ((i == "full" || i == "before") && (t = t.isolate()), e.annotation(Bt.addToHistory) === false)
        return e.changes.empty ? t : t.addMapping(e.changes.desc);
      let o = Bn.fromTransaction(e), s = e.annotation(Bt.time), a = e.annotation(Bt.userEvent);
      return o ? t = t.addChanges(o, s, a, n, e) : e.selection && (t = t.addSelection(e.startState.selection, s, a, n.newGroupDelay)), (i == "full" || i == "after") && (t = t.isolate()), t;
    },
    toJSON(t) {
      return {
        done: t.done.map((e) => e.toJSON()),
        undone: t.undone.map((e) => e.toJSON())
      };
    },
    fromJSON(t) {
      return new xi(t.done.map(Bn.fromJSON), t.undone.map(Bn.fromJSON));
    }
  });
  function rG(t = {}) {
    return [
      QL,
      XL.of(t),
      ue.domEventHandlers({
        beforeinput(e, n) {
          let r = e.inputType == "historyUndo" ? Zx : e.inputType == "historyRedo" ? Rp : null;
          return r ? (e.preventDefault(), r(n)) : false;
        }
      })
    ];
  }
  function qm(t, e) {
    return function({ state: n, dispatch: r }) {
      if (!e && n.readOnly)
        return false;
      let i = n.field(QL, false);
      if (!i)
        return false;
      let o = i.pop(t, n, e);
      return o ? (r(o), true) : false;
    };
  }
  const Zx = qm(0, false), Rp = qm(1, false), iG = qm(0, true), oG = qm(1, true);
  class Bn {
    constructor(e, n, r, i, o) {
      this.changes = e, this.effects = n, this.mapped = r, this.startSelection = i, this.selectionsAfter = o;
    }
    setSelAfter(e) {
      return new Bn(this.changes, this.effects, this.mapped, this.startSelection, e);
    }
    toJSON() {
      var e, n, r;
      return {
        changes: (e = this.changes) === null || e === void 0 ? void 0 : e.toJSON(),
        mapped: (n = this.mapped) === null || n === void 0 ? void 0 : n.toJSON(),
        startSelection: (r = this.startSelection) === null || r === void 0 ? void 0 : r.toJSON(),
        selectionsAfter: this.selectionsAfter.map((i) => i.toJSON())
      };
    }
    static fromJSON(e) {
      return new Bn(e.changes && Dt.fromJSON(e.changes), [], e.mapped && Mi.fromJSON(e.mapped), e.startSelection && q.fromJSON(e.startSelection), e.selectionsAfter.map(q.fromJSON));
    }
    static fromTransaction(e, n) {
      let r = gr;
      for (let i of e.startState.facet(nG)) {
        let o = i(e);
        o.length && (r = r.concat(o));
      }
      return !r.length && e.changes.empty ? null : new Bn(e.changes.invert(e.startState.doc), r, void 0, n || e.startState.selection, gr);
    }
    static selection(e) {
      return new Bn(void 0, gr, void 0, void 0, e);
    }
  }
  function _p(t, e, n, r) {
    let i = e + 1 > n + 20 ? e - n - 1 : 0, o = t.slice(i, e);
    return o.push(r), o;
  }
  function sG(t, e) {
    let n = [], r = false;
    return t.iterChangedRanges((i, o) => n.push(i, o)), e.iterChangedRanges((i, o, s, a) => {
      for (let l = 0; l < n.length; ) {
        let c = n[l++], u = n[l++];
        a >= c && s <= u && (r = true);
      }
    }), r;
  }
  function aG(t, e) {
    return t.ranges.length == e.ranges.length && t.ranges.filter((n, r) => n.empty != e.ranges[r].empty).length === 0;
  }
  function JL(t, e) {
    return t.length ? e.length ? t.concat(e) : t : e;
  }
  const gr = [], lG = 200;
  function ZL(t, e) {
    if (t.length) {
      let n = t[t.length - 1], r = n.selectionsAfter.slice(Math.max(0, n.selectionsAfter.length - lG));
      return r.length && r[r.length - 1].eq(e) ? t : (r.push(e), _p(t, t.length - 1, 1e9, n.setSelAfter(r)));
    } else
      return [
        Bn.selection([
          e
        ])
      ];
  }
  function cG(t) {
    let e = t[t.length - 1], n = t.slice();
    return n[t.length - 1] = e.setSelAfter(e.selectionsAfter.slice(0, e.selectionsAfter.length - 1)), n;
  }
  function ev(t, e) {
    if (!t.length)
      return t;
    let n = t.length, r = gr;
    for (; n; ) {
      let i = uG(t[n - 1], e, r);
      if (i.changes && !i.changes.empty || i.effects.length) {
        let o = t.slice(0, n);
        return o[n - 1] = i, o;
      } else
        e = i.mapped, n--, r = i.selectionsAfter;
    }
    return r.length ? [
      Bn.selection(r)
    ] : gr;
  }
  function uG(t, e, n) {
    let r = JL(t.selectionsAfter.length ? t.selectionsAfter.map((a) => a.map(e)) : gr, n);
    if (!t.changes)
      return Bn.selection(r);
    let i = t.changes.map(e), o = e.mapDesc(t.changes, true), s = t.mapped ? t.mapped.composeDesc(o) : o;
    return new Bn(i, Ee.mapEffects(t.effects, e), s, t.startSelection.map(o), r);
  }
  const fG = /^(input\.type|delete)($|\.)/;
  class xi {
    constructor(e, n, r = 0, i = void 0) {
      this.done = e, this.undone = n, this.prevTime = r, this.prevUserEvent = i;
    }
    isolate() {
      return this.prevTime ? new xi(this.done, this.undone) : this;
    }
    addChanges(e, n, r, i, o) {
      let s = this.done, a = s[s.length - 1];
      return a && a.changes && !a.changes.empty && e.changes && (!r || fG.test(r)) && (!a.selectionsAfter.length && n - this.prevTime < i.newGroupDelay && i.joinToEvent(o, sG(a.changes, e.changes)) || r == "input.type.compose") ? s = _p(s, s.length - 1, i.minDepth, new Bn(e.changes.compose(a.changes), JL(Ee.mapEffects(e.effects, a.changes), a.effects), a.mapped, a.startSelection, gr)) : s = _p(s, s.length, i.minDepth, e), new xi(s, gr, n, r);
    }
    addSelection(e, n, r, i) {
      let o = this.done.length ? this.done[this.done.length - 1].selectionsAfter : gr;
      return o.length > 0 && n - this.prevTime < i && r == this.prevUserEvent && r && /^select($|\.)/.test(r) && aG(o[o.length - 1], e) ? this : new xi(ZL(this.done, e), this.undone, n, r);
    }
    addMapping(e) {
      return new xi(ev(this.done, e), ev(this.undone, e), this.prevTime, this.prevUserEvent);
    }
    pop(e, n, r) {
      let i = e == 0 ? this.done : this.undone;
      if (i.length == 0)
        return null;
      let o = i[i.length - 1], s = o.selectionsAfter[0] || (o.startSelection ? o.startSelection.map(o.changes.invertedDesc, 1) : n.selection);
      if (r && o.selectionsAfter.length)
        return n.update({
          selection: o.selectionsAfter[o.selectionsAfter.length - 1],
          annotations: M1.of({
            side: e,
            rest: cG(i),
            selection: s
          }),
          userEvent: e == 0 ? "select.undo" : "select.redo",
          scrollIntoView: true
        });
      if (o.changes) {
        let a = i.length == 1 ? gr : i.slice(0, i.length - 1);
        return o.mapped && (a = ev(a, o.mapped)), n.update({
          changes: o.changes,
          selection: o.startSelection,
          effects: o.effects,
          annotations: M1.of({
            side: e,
            rest: a,
            selection: s
          }),
          filter: false,
          userEvent: e == 0 ? "undo" : "redo",
          scrollIntoView: true
        });
      } else
        return null;
    }
  }
  xi.empty = new xi(gr, gr);
  const hG = [
    {
      key: "Mod-z",
      run: Zx,
      preventDefault: true
    },
    {
      key: "Mod-y",
      mac: "Mod-Shift-z",
      run: Rp,
      preventDefault: true
    },
    {
      linux: "Ctrl-Shift-z",
      run: Rp,
      preventDefault: true
    },
    {
      key: "Mod-u",
      run: iG,
      preventDefault: true
    },
    {
      key: "Alt-u",
      mac: "Mod-Shift-u",
      run: oG,
      preventDefault: true
    }
  ];
  function Pl(t, e) {
    return q.create(t.ranges.map(e), t.mainIndex);
  }
  function Yr(t, e) {
    return t.update({
      selection: e,
      scrollIntoView: true,
      userEvent: "select"
    });
  }
  function Xr({ state: t, dispatch: e }, n) {
    let r = Pl(t.selection, n);
    return r.eq(t.selection, true) ? false : (e(Yr(t, r)), true);
  }
  function Gm(t, e) {
    return q.cursor(e ? t.to : t.from);
  }
  function eS(t, e) {
    return Xr(t, (n) => n.empty ? t.moveByChar(n, e) : Gm(n, e));
  }
  function mn(t) {
    return t.textDirectionAt(t.state.selection.main.head) == Je.LTR;
  }
  const tS = (t) => eS(t, !mn(t)), eR = (t) => eS(t, mn(t)), dG = (t) => eS(t, false);
  function tR(t, e) {
    return Xr(t, (n) => n.empty ? t.moveByGroup(n, e) : Gm(n, e));
  }
  const pG = (t) => tR(t, !mn(t)), mG = (t) => tR(t, mn(t));
  function gG(t, e, n) {
    if (e.type.prop(n))
      return true;
    let r = e.to - e.from;
    return r && (r > 2 || /[^\s,.;:]/.test(t.sliceDoc(e.from, e.to))) || e.firstChild;
  }
  function Ym(t, e, n) {
    let r = pn(t).resolveInner(e.head), i = n ? ze.closedBy : ze.openedBy;
    for (let l = e.head; ; ) {
      let c = n ? r.childAfter(l) : r.childBefore(l);
      if (!c)
        break;
      gG(t, c, i) ? r = c : l = n ? c.to : c.from;
    }
    let o = r.type.prop(i), s, a;
    return o && (s = n ? mr(t, r.from, 1) : mr(t, r.to, -1)) && s.matched ? a = n ? s.end.to : s.end.from : a = n ? r.to : r.from, q.cursor(a, n ? -1 : 1);
  }
  const vG = (t) => Xr(t, (e) => Ym(t.state, e, !mn(t))), yG = (t) => Xr(t, (e) => Ym(t.state, e, mn(t)));
  function nR(t, e) {
    return Xr(t, (n) => {
      if (!n.empty)
        return Gm(n, e);
      let r = t.moveVertically(n, e);
      return r.head != n.head ? r : t.moveToLineBoundary(n, e);
    });
  }
  const rR = (t) => nR(t, false), iR = (t) => nR(t, true);
  function oR(t) {
    let e = t.scrollDOM.clientHeight < t.scrollDOM.scrollHeight - 2, n = 0, r = 0, i;
    if (e) {
      for (let o of t.state.facet(ue.scrollMargins)) {
        let s = o(t);
        (s == null ? void 0 : s.top) && (n = Math.max(s == null ? void 0 : s.top, n)), (s == null ? void 0 : s.bottom) && (r = Math.max(s == null ? void 0 : s.bottom, r));
      }
      i = t.scrollDOM.clientHeight - n - r;
    } else
      i = (t.dom.ownerDocument.defaultView || window).innerHeight;
    return {
      marginTop: n,
      marginBottom: r,
      selfScroll: e,
      height: Math.max(t.defaultLineHeight, i - 5)
    };
  }
  function sR(t, e) {
    let n = oR(t), { state: r } = t, i = Pl(r.selection, (s) => s.empty ? t.moveVertically(s, e, n.height) : Gm(s, e));
    if (i.eq(r.selection))
      return false;
    let o;
    if (n.selfScroll) {
      let s = t.coordsAtPos(r.selection.main.head), a = t.scrollDOM.getBoundingClientRect(), l = a.top + n.marginTop, c = a.bottom - n.marginBottom;
      s && s.top > l && s.bottom < c && (o = ue.scrollIntoView(i.main.head, {
        y: "start",
        yMargin: s.top - l
      }));
    }
    return t.dispatch(Yr(r, i), {
      effects: o
    }), true;
  }
  const PT = (t) => sR(t, false), A1 = (t) => sR(t, true);
  function rs(t, e, n) {
    let r = t.lineBlockAt(e.head), i = t.moveToLineBoundary(e, n);
    if (i.head == e.head && i.head != (n ? r.to : r.from) && (i = t.moveToLineBoundary(e, n, false)), !n && i.head == r.from && r.length) {
      let o = /^\s*/.exec(t.state.sliceDoc(r.from, Math.min(r.from + 100, r.to)))[0].length;
      o && e.head != r.from + o && (i = q.cursor(r.from + o));
    }
    return i;
  }
  const aR = (t) => Xr(t, (e) => rs(t, e, true)), lR = (t) => Xr(t, (e) => rs(t, e, false)), bG = (t) => Xr(t, (e) => rs(t, e, !mn(t))), xG = (t) => Xr(t, (e) => rs(t, e, mn(t))), SG = (t) => Xr(t, (e) => q.cursor(t.lineBlockAt(e.head).from, 1)), wG = (t) => Xr(t, (e) => q.cursor(t.lineBlockAt(e.head).to, -1));
  function kG(t, e, n) {
    let r = false, i = Pl(t.selection, (o) => {
      let s = mr(t, o.head, -1) || mr(t, o.head, 1) || o.head > 0 && mr(t, o.head - 1, 1) || o.head < t.doc.length && mr(t, o.head + 1, -1);
      if (!s || !s.end)
        return o;
      r = true;
      let a = s.start.from == o.head ? s.end.to : s.end.from;
      return n ? q.range(o.anchor, a) : q.cursor(a);
    });
    return r ? (e(Yr(t, i)), true) : false;
  }
  const CG = ({ state: t, dispatch: e }) => kG(t, e, false);
  function Ar(t, e) {
    let n = Pl(t.state.selection, (r) => {
      let i = e(r);
      return q.range(r.anchor, i.head, i.goalColumn, i.bidiLevel || void 0);
    });
    return n.eq(t.state.selection) ? false : (t.dispatch(Yr(t.state, n)), true);
  }
  function cR(t, e) {
    return Ar(t, (n) => t.moveByChar(n, e));
  }
  const uR = (t) => cR(t, !mn(t)), fR = (t) => cR(t, mn(t));
  function hR(t, e) {
    return Ar(t, (n) => t.moveByGroup(n, e));
  }
  const TG = (t) => hR(t, !mn(t)), MG = (t) => hR(t, mn(t)), AG = (t) => Ar(t, (e) => Ym(t.state, e, !mn(t))), EG = (t) => Ar(t, (e) => Ym(t.state, e, mn(t)));
  function dR(t, e) {
    return Ar(t, (n) => t.moveVertically(n, e));
  }
  const pR = (t) => dR(t, false), mR = (t) => dR(t, true);
  function gR(t, e) {
    return Ar(t, (n) => t.moveVertically(n, e, oR(t).height));
  }
  const OT = (t) => gR(t, false), LT = (t) => gR(t, true), PG = (t) => Ar(t, (e) => rs(t, e, true)), OG = (t) => Ar(t, (e) => rs(t, e, false)), LG = (t) => Ar(t, (e) => rs(t, e, !mn(t))), RG = (t) => Ar(t, (e) => rs(t, e, mn(t))), _G = (t) => Ar(t, (e) => q.cursor(t.lineBlockAt(e.head).from)), DG = (t) => Ar(t, (e) => q.cursor(t.lineBlockAt(e.head).to)), RT = ({ state: t, dispatch: e }) => (e(Yr(t, {
    anchor: 0
  })), true), _T = ({ state: t, dispatch: e }) => (e(Yr(t, {
    anchor: t.doc.length
  })), true), DT = ({ state: t, dispatch: e }) => (e(Yr(t, {
    anchor: t.selection.main.anchor,
    head: 0
  })), true), IT = ({ state: t, dispatch: e }) => (e(Yr(t, {
    anchor: t.selection.main.anchor,
    head: t.doc.length
  })), true), IG = ({ state: t, dispatch: e }) => (e(t.update({
    selection: {
      anchor: 0,
      head: t.doc.length
    },
    userEvent: "select"
  })), true), BG = ({ state: t, dispatch: e }) => {
    let n = Xm(t).map(({ from: r, to: i }) => q.range(r, Math.min(i + 1, t.doc.length)));
    return e(t.update({
      selection: q.create(n),
      userEvent: "select"
    })), true;
  }, NG = ({ state: t, dispatch: e }) => {
    let n = Pl(t.selection, (r) => {
      let i = pn(t), o = i.resolveStack(r.from, 1);
      if (r.empty) {
        let s = i.resolveStack(r.from, -1);
        s.node.from >= o.node.from && s.node.to <= o.node.to && (o = s);
      }
      for (let s = o; s; s = s.next) {
        let { node: a } = s;
        if ((a.from < r.from && a.to >= r.to || a.to > r.to && a.from <= r.from) && s.next)
          return q.range(a.to, a.from);
      }
      return r;
    });
    return n.eq(t.selection) ? false : (e(Yr(t, n)), true);
  };
  function vR(t, e) {
    let { state: n } = t, r = n.selection, i = n.selection.ranges.slice();
    for (let o of n.selection.ranges) {
      let s = n.doc.lineAt(o.head);
      if (e ? s.to < t.state.doc.length : s.from > 0)
        for (let a = o; ; ) {
          let l = t.moveVertically(a, e);
          if (l.head < s.from || l.head > s.to) {
            i.some((c) => c.head == l.head) || i.push(l);
            break;
          } else {
            if (l.head == a.head)
              break;
            a = l;
          }
        }
    }
    return i.length == r.ranges.length ? false : (t.dispatch(Yr(n, q.create(i, i.length - 1))), true);
  }
  const $G = (t) => vR(t, false), zG = (t) => vR(t, true), FG = ({ state: t, dispatch: e }) => {
    let n = t.selection, r = null;
    return n.ranges.length > 1 ? r = q.create([
      n.main
    ]) : n.main.empty || (r = q.create([
      q.cursor(n.main.head)
    ])), r ? (e(Yr(t, r)), true) : false;
  };
  function df(t, e) {
    if (t.state.readOnly)
      return false;
    let n = "delete.selection", { state: r } = t, i = r.changeByRange((o) => {
      let { from: s, to: a } = o;
      if (s == a) {
        let l = e(o);
        l < s ? (n = "delete.backward", l = $h(t, l, false)) : l > s && (n = "delete.forward", l = $h(t, l, true)), s = Math.min(s, l), a = Math.max(a, l);
      } else
        s = $h(t, s, false), a = $h(t, a, true);
      return s == a ? {
        range: o
      } : {
        changes: {
          from: s,
          to: a
        },
        range: q.cursor(s, s < o.head ? -1 : 1)
      };
    });
    return i.changes.empty ? false : (t.dispatch(r.update(i, {
      scrollIntoView: true,
      userEvent: n,
      effects: n == "delete.selection" ? ue.announce.of(r.phrase("Selection deleted")) : void 0
    })), true);
  }
  function $h(t, e, n) {
    if (t instanceof ue)
      for (let r of t.state.facet(ue.atomicRanges).map((i) => i(t)))
        r.between(e, e, (i, o) => {
          i < e && o > e && (e = n ? o : i);
        });
    return e;
  }
  const yR = (t, e, n) => df(t, (r) => {
    let i = r.from, { state: o } = t, s = o.doc.lineAt(i), a, l;
    if (n && !e && i > s.from && i < s.from + 200 && !/[^ \t]/.test(a = s.text.slice(0, i - s.from))) {
      if (a[a.length - 1] == "	")
        return i - 1;
      let c = El(a, o.tabSize), u = c % Pp(o) || Pp(o);
      for (let h = 0; h < u && a[a.length - 1 - h] == " "; h++)
        i--;
      l = i;
    } else
      l = Ht(s.text, i - s.from, e, e) + s.from, l == i && s.number != (e ? o.doc.lines : 1) ? l += e ? 1 : -1 : !e && /[\ufe00-\ufe0f]/.test(s.text.slice(l - s.from, i - s.from)) && (l = Ht(s.text, l - s.from, false, false) + s.from);
    return l;
  }), E1 = (t) => yR(t, false, true), bR = (t) => yR(t, true, false), xR = (t, e) => df(t, (n) => {
    let r = n.head, { state: i } = t, o = i.doc.lineAt(r), s = i.charCategorizer(r);
    for (let a = null; ; ) {
      if (r == (e ? o.to : o.from)) {
        r == n.head && o.number != (e ? i.doc.lines : 1) && (r += e ? 1 : -1);
        break;
      }
      let l = Ht(o.text, r - o.from, e) + o.from, c = o.text.slice(Math.min(r, l) - o.from, Math.max(r, l) - o.from), u = s(c);
      if (a != null && u != a)
        break;
      (c != " " || r != n.head) && (a = u), r = l;
    }
    return r;
  }), SR = (t) => xR(t, false), VG = (t) => xR(t, true), WG = (t) => df(t, (e) => {
    let n = t.lineBlockAt(e.head).to;
    return e.head < n ? n : Math.min(t.state.doc.length, e.head + 1);
  }), HG = (t) => df(t, (e) => {
    let n = t.moveToLineBoundary(e, false).head;
    return e.head > n ? n : Math.max(0, e.head - 1);
  }), jG = (t) => df(t, (e) => {
    let n = t.moveToLineBoundary(e, true).head;
    return e.head < n ? n : Math.min(t.state.doc.length, e.head + 1);
  }), UG = ({ state: t, dispatch: e }) => {
    if (t.readOnly)
      return false;
    let n = t.changeByRange((r) => ({
      changes: {
        from: r.from,
        to: r.to,
        insert: He.of([
          "",
          ""
        ])
      },
      range: q.cursor(r.from)
    }));
    return e(t.update(n, {
      scrollIntoView: true,
      userEvent: "input"
    })), true;
  }, KG = ({ state: t, dispatch: e }) => {
    if (t.readOnly)
      return false;
    let n = t.changeByRange((r) => {
      if (!r.empty || r.from == 0 || r.from == t.doc.length)
        return {
          range: r
        };
      let i = r.from, o = t.doc.lineAt(i), s = i == o.from ? i - 1 : Ht(o.text, i - o.from, false) + o.from, a = i == o.to ? i + 1 : Ht(o.text, i - o.from, true) + o.from;
      return {
        changes: {
          from: s,
          to: a,
          insert: t.doc.slice(i, a).append(t.doc.slice(s, i))
        },
        range: q.cursor(a)
      };
    });
    return n.changes.empty ? false : (e(t.update(n, {
      scrollIntoView: true,
      userEvent: "move.character"
    })), true);
  };
  function Xm(t) {
    let e = [], n = -1;
    for (let r of t.selection.ranges) {
      let i = t.doc.lineAt(r.from), o = t.doc.lineAt(r.to);
      if (!r.empty && r.to == o.from && (o = t.doc.lineAt(r.to - 1)), n >= i.number) {
        let s = e[e.length - 1];
        s.to = o.to, s.ranges.push(r);
      } else
        e.push({
          from: i.from,
          to: o.to,
          ranges: [
            r
          ]
        });
      n = o.number + 1;
    }
    return e;
  }
  function wR(t, e, n) {
    if (t.readOnly)
      return false;
    let r = [], i = [];
    for (let o of Xm(t)) {
      if (n ? o.to == t.doc.length : o.from == 0)
        continue;
      let s = t.doc.lineAt(n ? o.to + 1 : o.from - 1), a = s.length + 1;
      if (n) {
        r.push({
          from: o.to,
          to: s.to
        }, {
          from: o.from,
          insert: s.text + t.lineBreak
        });
        for (let l of o.ranges)
          i.push(q.range(Math.min(t.doc.length, l.anchor + a), Math.min(t.doc.length, l.head + a)));
      } else {
        r.push({
          from: s.from,
          to: o.from
        }, {
          from: o.to,
          insert: t.lineBreak + s.text
        });
        for (let l of o.ranges)
          i.push(q.range(l.anchor - a, l.head - a));
      }
    }
    return r.length ? (e(t.update({
      changes: r,
      scrollIntoView: true,
      selection: q.create(i, t.selection.mainIndex),
      userEvent: "move.line"
    })), true) : false;
  }
  const qG = ({ state: t, dispatch: e }) => wR(t, e, false), GG = ({ state: t, dispatch: e }) => wR(t, e, true);
  function kR(t, e, n) {
    if (t.readOnly)
      return false;
    let r = [];
    for (let o of Xm(t))
      n ? r.push({
        from: o.from,
        insert: t.doc.slice(o.from, o.to) + t.lineBreak
      }) : r.push({
        from: o.to,
        insert: t.lineBreak + t.doc.slice(o.from, o.to)
      });
    let i = t.changes(r);
    return e(t.update({
      changes: i,
      selection: t.selection.map(i, n ? 1 : -1),
      scrollIntoView: true,
      userEvent: "input.copyline"
    })), true;
  }
  const YG = ({ state: t, dispatch: e }) => kR(t, e, false), XG = ({ state: t, dispatch: e }) => kR(t, e, true), QG = (t) => {
    if (t.state.readOnly)
      return false;
    let { state: e } = t, n = e.changes(Xm(e).map(({ from: i, to: o }) => (i > 0 ? i-- : o < e.doc.length && o++, {
      from: i,
      to: o
    }))), r = Pl(e.selection, (i) => {
      let o;
      if (t.lineWrapping) {
        let s = t.lineBlockAt(i.head), a = t.coordsAtPos(i.head, i.assoc || 1);
        a && (o = s.bottom + t.documentTop - a.bottom + t.defaultLineHeight / 2);
      }
      return t.moveVertically(i, true, o);
    }).map(n);
    return t.dispatch({
      changes: n,
      selection: r,
      scrollIntoView: true,
      userEvent: "delete.line"
    }), true;
  };
  function JG(t, e) {
    if (/\(\)|\[\]|\{\}/.test(t.sliceDoc(e - 1, e + 1)))
      return {
        from: e,
        to: e
      };
    let n = pn(t).resolveInner(e), r = n.childBefore(e), i = n.childAfter(e), o;
    return r && i && r.to <= e && i.from >= e && (o = r.type.prop(ze.closedBy)) && o.indexOf(i.name) > -1 && t.doc.lineAt(r.to).from == t.doc.lineAt(i.from).from && !/\S/.test(t.sliceDoc(r.to, i.from)) ? {
      from: r.to,
      to: i.from
    } : null;
  }
  const P1 = CR(false), ZG = CR(true);
  function CR(t) {
    return ({ state: e, dispatch: n }) => {
      if (e.readOnly)
        return false;
      let r = e.changeByRange((i) => {
        let { from: o, to: s } = i, a = e.doc.lineAt(o), l = !t && o == s && JG(e, o);
        t && (o = s = (s <= a.to ? a : e.doc.lineAt(s)).to);
        let c = new Um(e, {
          simulateBreak: o,
          simulateDoubleBreak: !!l
        }), u = Gx(c, o);
        for (u == null && (u = El(/^\s*/.exec(e.doc.lineAt(o).text)[0], e.tabSize)); s < a.to && /\s/.test(a.text[s - a.from]); )
          s++;
        l ? { from: o, to: s } = l : o > a.from && o < a.from + 100 && !/\S/.test(a.text.slice(0, o)) && (o = a.from);
        let h = [
          "",
          Wu(e, u)
        ];
        return l && h.push(Wu(e, c.lineIndent(a.from, -1))), {
          changes: {
            from: o,
            to: s,
            insert: He.of(h)
          },
          range: q.cursor(o + 1 + h[1].length)
        };
      });
      return n(e.update(r, {
        scrollIntoView: true,
        userEvent: "input"
      })), true;
    };
  }
  function nS(t, e) {
    let n = -1;
    return t.changeByRange((r) => {
      let i = [];
      for (let s = r.from; s <= r.to; ) {
        let a = t.doc.lineAt(s);
        a.number > n && (r.empty || r.to > a.from) && (e(a, i, r), n = a.number), s = a.to + 1;
      }
      let o = t.changes(i);
      return {
        changes: i,
        range: q.range(o.mapPos(r.anchor, 1), o.mapPos(r.head, 1))
      };
    });
  }
  const TR = ({ state: t, dispatch: e }) => {
    if (t.readOnly)
      return false;
    let n = /* @__PURE__ */ Object.create(null), r = new Um(t, {
      overrideIndentation: (o) => {
        let s = n[o];
        return s ?? -1;
      }
    }), i = nS(t, (o, s, a) => {
      let l = Gx(r, o.from);
      if (l == null)
        return;
      /\S/.test(o.text) || (l = 0);
      let c = /^\s*/.exec(o.text)[0], u = Wu(t, l);
      (c != u || a.from < o.from + c.length) && (n[o.from] = l, s.push({
        from: o.from,
        to: o.from + c.length,
        insert: u
      }));
    });
    return i.changes.empty || e(t.update(i, {
      userEvent: "indent"
    })), true;
  }, rS = ({ state: t, dispatch: e }) => t.readOnly ? false : (e(t.update(nS(t, (n, r) => {
    r.push({
      from: n.from,
      insert: t.facet(xl)
    });
  }), {
    userEvent: "input.indent"
  })), true), iS = ({ state: t, dispatch: e }) => t.readOnly ? false : (e(t.update(nS(t, (n, r) => {
    let i = /^\s*/.exec(n.text)[0];
    if (!i)
      return;
    let o = El(i, t.tabSize), s = 0, a = Wu(t, Math.max(0, o - Pp(t)));
    for (; s < i.length && s < a.length && i.charCodeAt(s) == a.charCodeAt(s); )
      s++;
    r.push({
      from: n.from + s,
      to: n.from + i.length,
      insert: a.slice(s)
    });
  }), {
    userEvent: "delete.dedent"
  })), true), eY = (t) => (t.setTabFocusMode(), true), tY = [
    {
      key: "Ctrl-b",
      run: tS,
      shift: uR,
      preventDefault: true
    },
    {
      key: "Ctrl-f",
      run: eR,
      shift: fR
    },
    {
      key: "Ctrl-p",
      run: rR,
      shift: pR
    },
    {
      key: "Ctrl-n",
      run: iR,
      shift: mR
    },
    {
      key: "Ctrl-a",
      run: SG,
      shift: _G
    },
    {
      key: "Ctrl-e",
      run: wG,
      shift: DG
    },
    {
      key: "Ctrl-d",
      run: bR
    },
    {
      key: "Ctrl-h",
      run: E1
    },
    {
      key: "Ctrl-k",
      run: WG
    },
    {
      key: "Ctrl-Alt-h",
      run: SR
    },
    {
      key: "Ctrl-o",
      run: UG
    },
    {
      key: "Ctrl-t",
      run: KG
    },
    {
      key: "Ctrl-v",
      run: A1
    }
  ], nY = [
    {
      key: "ArrowLeft",
      run: tS,
      shift: uR,
      preventDefault: true
    },
    {
      key: "Mod-ArrowLeft",
      mac: "Alt-ArrowLeft",
      run: pG,
      shift: TG,
      preventDefault: true
    },
    {
      mac: "Cmd-ArrowLeft",
      run: bG,
      shift: LG,
      preventDefault: true
    },
    {
      key: "ArrowRight",
      run: eR,
      shift: fR,
      preventDefault: true
    },
    {
      key: "Mod-ArrowRight",
      mac: "Alt-ArrowRight",
      run: mG,
      shift: MG,
      preventDefault: true
    },
    {
      mac: "Cmd-ArrowRight",
      run: xG,
      shift: RG,
      preventDefault: true
    },
    {
      key: "ArrowUp",
      run: rR,
      shift: pR,
      preventDefault: true
    },
    {
      mac: "Cmd-ArrowUp",
      run: RT,
      shift: DT
    },
    {
      mac: "Ctrl-ArrowUp",
      run: PT,
      shift: OT
    },
    {
      key: "ArrowDown",
      run: iR,
      shift: mR,
      preventDefault: true
    },
    {
      mac: "Cmd-ArrowDown",
      run: _T,
      shift: IT
    },
    {
      mac: "Ctrl-ArrowDown",
      run: A1,
      shift: LT
    },
    {
      key: "PageUp",
      run: PT,
      shift: OT
    },
    {
      key: "PageDown",
      run: A1,
      shift: LT
    },
    {
      key: "Home",
      run: lR,
      shift: OG,
      preventDefault: true
    },
    {
      key: "Mod-Home",
      run: RT,
      shift: DT
    },
    {
      key: "End",
      run: aR,
      shift: PG,
      preventDefault: true
    },
    {
      key: "Mod-End",
      run: _T,
      shift: IT
    },
    {
      key: "Enter",
      run: P1,
      shift: P1
    },
    {
      key: "Mod-a",
      run: IG
    },
    {
      key: "Backspace",
      run: E1,
      shift: E1,
      preventDefault: true
    },
    {
      key: "Delete",
      run: bR,
      preventDefault: true
    },
    {
      key: "Mod-Backspace",
      mac: "Alt-Backspace",
      run: SR,
      preventDefault: true
    },
    {
      key: "Mod-Delete",
      mac: "Alt-Delete",
      run: VG,
      preventDefault: true
    },
    {
      mac: "Mod-Backspace",
      run: HG,
      preventDefault: true
    },
    {
      mac: "Mod-Delete",
      run: jG,
      preventDefault: true
    }
  ].concat(tY.map((t) => ({
    mac: t.key,
    run: t.run,
    shift: t.shift
  }))), rY = [
    {
      key: "Alt-ArrowLeft",
      mac: "Ctrl-ArrowLeft",
      run: vG,
      shift: AG
    },
    {
      key: "Alt-ArrowRight",
      mac: "Ctrl-ArrowRight",
      run: yG,
      shift: EG
    },
    {
      key: "Alt-ArrowUp",
      run: qG
    },
    {
      key: "Shift-Alt-ArrowUp",
      run: YG
    },
    {
      key: "Alt-ArrowDown",
      run: GG
    },
    {
      key: "Shift-Alt-ArrowDown",
      run: XG
    },
    {
      key: "Mod-Alt-ArrowUp",
      run: $G
    },
    {
      key: "Mod-Alt-ArrowDown",
      run: zG
    },
    {
      key: "Escape",
      run: FG
    },
    {
      key: "Mod-Enter",
      run: ZG
    },
    {
      key: "Alt-l",
      mac: "Ctrl-l",
      run: BG
    },
    {
      key: "Mod-i",
      run: NG,
      preventDefault: true
    },
    {
      key: "Mod-[",
      run: iS
    },
    {
      key: "Mod-]",
      run: rS
    },
    {
      key: "Mod-Alt-\\",
      run: TR
    },
    {
      key: "Shift-Mod-k",
      run: QG
    },
    {
      key: "Shift-Mod-\\",
      run: CG
    },
    {
      key: "Mod-/",
      run: Gq
    },
    {
      key: "Alt-A",
      run: Xq
    },
    {
      key: "Ctrl-m",
      mac: "Shift-Alt-m",
      run: eY
    }
  ].concat(nY), iY = {
    key: "Tab",
    run: rS,
    shift: iS
  }, BT = typeof String.prototype.normalize == "function" ? (t) => t.normalize("NFKD") : (t) => t;
  class Sl {
    constructor(e, n, r = 0, i = e.length, o, s) {
      this.test = s, this.value = {
        from: 0,
        to: 0
      }, this.done = false, this.matches = [], this.buffer = "", this.bufferPos = 0, this.iter = e.iterRange(r, i), this.bufferStart = r, this.normalize = o ? (a) => o(BT(a)) : BT, this.query = this.normalize(n);
    }
    peek() {
      if (this.bufferPos == this.buffer.length) {
        if (this.bufferStart += this.buffer.length, this.iter.next(), this.iter.done)
          return -1;
        this.bufferPos = 0, this.buffer = this.iter.value;
      }
      return On(this.buffer, this.bufferPos);
    }
    next() {
      for (; this.matches.length; )
        this.matches.pop();
      return this.nextOverlapping();
    }
    nextOverlapping() {
      for (; ; ) {
        let e = this.peek();
        if (e < 0)
          return this.done = true, this;
        let n = Mx(e), r = this.bufferStart + this.bufferPos;
        this.bufferPos += mi(e);
        let i = this.normalize(n);
        if (i.length)
          for (let o = 0, s = r; ; o++) {
            let a = i.charCodeAt(o), l = this.match(a, s, this.bufferPos + this.bufferStart);
            if (o == i.length - 1) {
              if (l)
                return this.value = l, this;
              break;
            }
            s == r && o < n.length && n.charCodeAt(o) == a && s++;
          }
      }
    }
    match(e, n, r) {
      let i = null;
      for (let o = 0; o < this.matches.length; o += 2) {
        let s = this.matches[o], a = false;
        this.query.charCodeAt(s) == e && (s == this.query.length - 1 ? i = {
          from: this.matches[o + 1],
          to: r
        } : (this.matches[o]++, a = true)), a || (this.matches.splice(o, 2), o -= 2);
      }
      return this.query.charCodeAt(0) == e && (this.query.length == 1 ? i = {
        from: n,
        to: r
      } : this.matches.push(1, n)), i && this.test && !this.test(i.from, i.to, this.buffer, this.bufferStart) && (i = null), i;
    }
  }
  typeof Symbol < "u" && (Sl.prototype[Symbol.iterator] = function() {
    return this;
  });
  const MR = {
    from: -1,
    to: -1,
    match: /.*/.exec("")
  }, oS = "gm" + (/x/.unicode == null ? "" : "u");
  class sS {
    constructor(e, n, r, i = 0, o = e.length) {
      if (this.text = e, this.to = o, this.curLine = "", this.done = false, this.value = MR, /\\[sWDnr]|\n|\r|\[\^/.test(n))
        return new AR(e, n, r, i, o);
      this.re = new RegExp(n, oS + ((r == null ? void 0 : r.ignoreCase) ? "i" : "")), this.test = r == null ? void 0 : r.test, this.iter = e.iter();
      let s = e.lineAt(i);
      this.curLineStart = s.from, this.matchPos = Dp(e, i), this.getLine(this.curLineStart);
    }
    getLine(e) {
      this.iter.next(e), this.iter.lineBreak ? this.curLine = "" : (this.curLine = this.iter.value, this.curLineStart + this.curLine.length > this.to && (this.curLine = this.curLine.slice(0, this.to - this.curLineStart)), this.iter.next());
    }
    nextLine() {
      this.curLineStart = this.curLineStart + this.curLine.length + 1, this.curLineStart > this.to ? this.curLine = "" : this.getLine(0);
    }
    next() {
      for (let e = this.matchPos - this.curLineStart; ; ) {
        this.re.lastIndex = e;
        let n = this.matchPos <= this.to && this.re.exec(this.curLine);
        if (n) {
          let r = this.curLineStart + n.index, i = r + n[0].length;
          if (this.matchPos = Dp(this.text, i + (r == i ? 1 : 0)), r == this.curLineStart + this.curLine.length && this.nextLine(), (r < i || r > this.value.to) && (!this.test || this.test(r, i, n)))
            return this.value = {
              from: r,
              to: i,
              match: n
            }, this;
          e = this.matchPos - this.curLineStart;
        } else if (this.curLineStart + this.curLine.length < this.to)
          this.nextLine(), e = 0;
        else
          return this.done = true, this;
      }
    }
  }
  const tv = /* @__PURE__ */ new WeakMap();
  class Za {
    constructor(e, n) {
      this.from = e, this.text = n;
    }
    get to() {
      return this.from + this.text.length;
    }
    static get(e, n, r) {
      let i = tv.get(e);
      if (!i || i.from >= r || i.to <= n) {
        let a = new Za(n, e.sliceString(n, r));
        return tv.set(e, a), a;
      }
      if (i.from == n && i.to == r)
        return i;
      let { text: o, from: s } = i;
      return s > n && (o = e.sliceString(n, s) + o, s = n), i.to < r && (o += e.sliceString(i.to, r)), tv.set(e, new Za(s, o)), new Za(n, o.slice(n - s, r - s));
    }
  }
  class AR {
    constructor(e, n, r, i, o) {
      this.text = e, this.to = o, this.done = false, this.value = MR, this.matchPos = Dp(e, i), this.re = new RegExp(n, oS + ((r == null ? void 0 : r.ignoreCase) ? "i" : "")), this.test = r == null ? void 0 : r.test, this.flat = Za.get(e, i, this.chunkEnd(i + 5e3));
    }
    chunkEnd(e) {
      return e >= this.to ? this.to : this.text.lineAt(e).to;
    }
    next() {
      for (; ; ) {
        let e = this.re.lastIndex = this.matchPos - this.flat.from, n = this.re.exec(this.flat.text);
        if (n && !n[0] && n.index == e && (this.re.lastIndex = e + 1, n = this.re.exec(this.flat.text)), n) {
          let r = this.flat.from + n.index, i = r + n[0].length;
          if ((this.flat.to >= this.to || n.index + n[0].length <= this.flat.text.length - 10) && (!this.test || this.test(r, i, n)))
            return this.value = {
              from: r,
              to: i,
              match: n
            }, this.matchPos = Dp(this.text, i + (r == i ? 1 : 0)), this;
        }
        if (this.flat.to == this.to)
          return this.done = true, this;
        this.flat = Za.get(this.text, this.flat.from, this.chunkEnd(this.flat.from + this.flat.text.length * 2));
      }
    }
  }
  typeof Symbol < "u" && (sS.prototype[Symbol.iterator] = AR.prototype[Symbol.iterator] = function() {
    return this;
  });
  function oY(t) {
    try {
      return new RegExp(t, oS), true;
    } catch {
      return false;
    }
  }
  function Dp(t, e) {
    if (e >= t.length)
      return e;
    let n = t.lineAt(e), r;
    for (; e < n.to && (r = n.text.charCodeAt(e - n.from)) >= 56320 && r < 57344; )
      e++;
    return e;
  }
  const sY = (t) => {
    let { state: e } = t, n = String(e.doc.lineAt(t.state.selection.main.head).number), { close: r, result: i } = CK(t, {
      label: e.phrase("Go to line"),
      input: {
        type: "text",
        name: "line",
        value: n
      },
      focus: true,
      submitLabel: e.phrase("go")
    });
    return i.then((o) => {
      let s = o && /^([+-])?(\d+)?(:\d+)?(%)?$/.exec(o.elements.line.value);
      if (!s) {
        t.dispatch({
          effects: r
        });
        return;
      }
      let a = e.doc.lineAt(e.selection.main.head), [, l, c, u, h] = s, p = u ? +u.slice(1) : 0, v = c ? +c : a.number;
      if (c && h) {
        let T = v / 100;
        l && (T = T * (l == "-" ? -1 : 1) + a.number / e.doc.lines), v = Math.round(e.doc.lines * T);
      } else
        c && l && (v = v * (l == "-" ? -1 : 1) + a.number);
      let y = e.doc.line(Math.max(1, Math.min(e.doc.lines, v))), S = q.cursor(y.from + Math.max(0, Math.min(p, y.length)));
      t.dispatch({
        effects: [
          r,
          ue.scrollIntoView(S.from, {
            y: "center"
          })
        ],
        selection: S
      });
    }), true;
  }, aY = {
    highlightWordAroundCursor: false,
    minSelectionLength: 1,
    maxMatches: 100,
    wholeWords: false
  }, ER = me.define({
    combine(t) {
      return Oi(t, aY, {
        highlightWordAroundCursor: (e, n) => e || n,
        minSelectionLength: Math.min,
        maxMatches: Math.min
      });
    }
  });
  function lY(t) {
    let e = [
      dY,
      hY
    ];
    return t && e.push(ER.of(t)), e;
  }
  const cY = be.mark({
    class: "cm-selectionMatch"
  }), uY = be.mark({
    class: "cm-selectionMatch cm-selectionMatch-main"
  });
  function NT(t, e, n, r) {
    return (n == 0 || t(e.sliceDoc(n - 1, n)) != ft.Word) && (r == e.doc.length || t(e.sliceDoc(r, r + 1)) != ft.Word);
  }
  function fY(t, e, n, r) {
    return t(e.sliceDoc(n, n + 1)) == ft.Word && t(e.sliceDoc(r - 1, r)) == ft.Word;
  }
  const hY = kt.fromClass(class {
    constructor(t) {
      this.decorations = this.getDeco(t);
    }
    update(t) {
      (t.selectionSet || t.docChanged || t.viewportChanged) && (this.decorations = this.getDeco(t.view));
    }
    getDeco(t) {
      let e = t.state.facet(ER), { state: n } = t, r = n.selection;
      if (r.ranges.length > 1)
        return be.none;
      let i = r.main, o, s = null;
      if (i.empty) {
        if (!e.highlightWordAroundCursor)
          return be.none;
        let l = n.wordAt(i.head);
        if (!l)
          return be.none;
        s = n.charCategorizer(i.head), o = n.sliceDoc(l.from, l.to);
      } else {
        let l = i.to - i.from;
        if (l < e.minSelectionLength || l > 200)
          return be.none;
        if (e.wholeWords) {
          if (o = n.sliceDoc(i.from, i.to), s = n.charCategorizer(i.head), !(NT(s, n, i.from, i.to) && fY(s, n, i.from, i.to)))
            return be.none;
        } else if (o = n.sliceDoc(i.from, i.to), !o)
          return be.none;
      }
      let a = [];
      for (let l of t.visibleRanges) {
        let c = new Sl(n.doc, o, l.from, l.to);
        for (; !c.next().done; ) {
          let { from: u, to: h } = c.value;
          if ((!s || NT(s, n, u, h)) && (i.empty && u <= i.from && h >= i.to ? a.push(uY.range(u, h)) : (u >= i.to || h <= i.from) && a.push(cY.range(u, h)), a.length > e.maxMatches))
            return be.none;
        }
      }
      return be.set(a);
    }
  }, {
    decorations: (t) => t.decorations
  }), dY = ue.baseTheme({
    ".cm-selectionMatch": {
      backgroundColor: "#99ff7780"
    },
    ".cm-searchMatch .cm-selectionMatch": {
      backgroundColor: "transparent"
    }
  }), pY = ({ state: t, dispatch: e }) => {
    let { selection: n } = t, r = q.create(n.ranges.map((i) => t.wordAt(i.head) || q.cursor(i.head)), n.mainIndex);
    return r.eq(n) ? false : (e(t.update({
      selection: r
    })), true);
  };
  function mY(t, e) {
    let { main: n, ranges: r } = t.selection, i = t.wordAt(n.head), o = i && i.from == n.from && i.to == n.to;
    for (let s = false, a = new Sl(t.doc, e, r[r.length - 1].to); ; )
      if (a.next(), a.done) {
        if (s)
          return null;
        a = new Sl(t.doc, e, 0, Math.max(0, r[r.length - 1].from - 1)), s = true;
      } else {
        if (s && r.some((l) => l.from == a.value.from))
          continue;
        if (o) {
          let l = t.wordAt(a.value.from);
          if (!l || l.from != a.value.from || l.to != a.value.to)
            continue;
        }
        return a.value;
      }
  }
  const gY = ({ state: t, dispatch: e }) => {
    let { ranges: n } = t.selection;
    if (n.some((o) => o.from === o.to))
      return pY({
        state: t,
        dispatch: e
      });
    let r = t.sliceDoc(n[0].from, n[0].to);
    if (t.selection.ranges.some((o) => t.sliceDoc(o.from, o.to) != r))
      return false;
    let i = mY(t, r);
    return i ? (e(t.update({
      selection: t.selection.addRange(q.range(i.from, i.to), false),
      effects: ue.scrollIntoView(i.to)
    })), true) : false;
  }, Ol = me.define({
    combine(t) {
      return Oi(t, {
        top: false,
        caseSensitive: false,
        literal: false,
        regexp: false,
        wholeWord: false,
        createPanel: (e) => new OY(e),
        scrollToMatch: (e) => ue.scrollIntoView(e)
      });
    }
  });
  class aS {
    constructor(e) {
      this.search = e.search, this.caseSensitive = !!e.caseSensitive, this.literal = !!e.literal, this.regexp = !!e.regexp, this.replace = e.replace || "", this.valid = !!this.search && (!this.regexp || oY(this.search)), this.unquoted = this.unquote(this.search), this.wholeWord = !!e.wholeWord, this.test = e.test;
    }
    unquote(e) {
      return this.literal ? e : e.replace(/\\([nrt\\])/g, (n, r) => r == "n" ? `
` : r == "r" ? "\r" : r == "t" ? "	" : "\\");
    }
    eq(e) {
      return this.search == e.search && this.replace == e.replace && this.caseSensitive == e.caseSensitive && this.regexp == e.regexp && this.wholeWord == e.wholeWord && this.test == e.test;
    }
    create() {
      return this.regexp ? new wY(this) : new bY(this);
    }
    getCursor(e, n = 0, r) {
      let i = e.doc ? e : $e.create({
        doc: e
      });
      return r == null && (r = i.doc.length), this.regexp ? ha(this, i, n, r) : fa(this, i, n, r);
    }
  }
  class PR {
    constructor(e) {
      this.spec = e;
    }
  }
  function vY(t, e, n) {
    return (r, i, o, s) => {
      if (n && !n(r, i, o, s))
        return false;
      let a = r >= s && i <= s + o.length ? o.slice(r - s, i - s) : e.doc.sliceString(r, i);
      return t(a, e, r, i);
    };
  }
  function fa(t, e, n, r) {
    let i;
    return t.wholeWord && (i = yY(e.doc, e.charCategorizer(e.selection.main.head))), t.test && (i = vY(t.test, e, i)), new Sl(e.doc, t.unquoted, n, r, t.caseSensitive ? void 0 : (o) => o.toLowerCase(), i);
  }
  function yY(t, e) {
    return (n, r, i, o) => ((o > n || o + i.length < r) && (o = Math.max(0, n - 2), i = t.sliceString(o, Math.min(t.length, r + 2))), (e(Ip(i, n - o)) != ft.Word || e(Bp(i, n - o)) != ft.Word) && (e(Bp(i, r - o)) != ft.Word || e(Ip(i, r - o)) != ft.Word));
  }
  class bY extends PR {
    constructor(e) {
      super(e);
    }
    nextMatch(e, n, r) {
      let i = fa(this.spec, e, r, e.doc.length).nextOverlapping();
      if (i.done) {
        let o = Math.min(e.doc.length, n + this.spec.unquoted.length);
        i = fa(this.spec, e, 0, o).nextOverlapping();
      }
      return i.done || i.value.from == n && i.value.to == r ? null : i.value;
    }
    prevMatchInRange(e, n, r) {
      for (let i = r; ; ) {
        let o = Math.max(n, i - 1e4 - this.spec.unquoted.length), s = fa(this.spec, e, o, i), a = null;
        for (; !s.nextOverlapping().done; )
          a = s.value;
        if (a)
          return a;
        if (o == n)
          return null;
        i -= 1e4;
      }
    }
    prevMatch(e, n, r) {
      let i = this.prevMatchInRange(e, 0, n);
      return i || (i = this.prevMatchInRange(e, Math.max(0, r - this.spec.unquoted.length), e.doc.length)), i && (i.from != n || i.to != r) ? i : null;
    }
    getReplacement(e) {
      return this.spec.unquote(this.spec.replace);
    }
    matchAll(e, n) {
      let r = fa(this.spec, e, 0, e.doc.length), i = [];
      for (; !r.next().done; ) {
        if (i.length >= n)
          return null;
        i.push(r.value);
      }
      return i;
    }
    highlight(e, n, r, i) {
      let o = fa(this.spec, e, Math.max(0, n - this.spec.unquoted.length), Math.min(r + this.spec.unquoted.length, e.doc.length));
      for (; !o.next().done; )
        i(o.value.from, o.value.to);
    }
  }
  function xY(t, e, n) {
    return (r, i, o) => (!n || n(r, i, o)) && t(o[0], e, r, i);
  }
  function ha(t, e, n, r) {
    let i;
    return t.wholeWord && (i = SY(e.charCategorizer(e.selection.main.head))), t.test && (i = xY(t.test, e, i)), new sS(e.doc, t.search, {
      ignoreCase: !t.caseSensitive,
      test: i
    }, n, r);
  }
  function Ip(t, e) {
    return t.slice(Ht(t, e, false), e);
  }
  function Bp(t, e) {
    return t.slice(e, Ht(t, e));
  }
  function SY(t) {
    return (e, n, r) => !r[0].length || (t(Ip(r.input, r.index)) != ft.Word || t(Bp(r.input, r.index)) != ft.Word) && (t(Bp(r.input, r.index + r[0].length)) != ft.Word || t(Ip(r.input, r.index + r[0].length)) != ft.Word);
  }
  class wY extends PR {
    nextMatch(e, n, r) {
      let i = ha(this.spec, e, r, e.doc.length).next();
      return i.done && (i = ha(this.spec, e, 0, n).next()), i.done ? null : i.value;
    }
    prevMatchInRange(e, n, r) {
      for (let i = 1; ; i++) {
        let o = Math.max(n, r - i * 1e4), s = ha(this.spec, e, o, r), a = null;
        for (; !s.next().done; )
          a = s.value;
        if (a && (o == n || a.from > o + 10))
          return a;
        if (o == n)
          return null;
      }
    }
    prevMatch(e, n, r) {
      return this.prevMatchInRange(e, 0, n) || this.prevMatchInRange(e, r, e.doc.length);
    }
    getReplacement(e) {
      return this.spec.unquote(this.spec.replace).replace(/\$([$&]|\d+)/g, (n, r) => {
        if (r == "&")
          return e.match[0];
        if (r == "$")
          return "$";
        for (let i = r.length; i > 0; i--) {
          let o = +r.slice(0, i);
          if (o > 0 && o < e.match.length)
            return e.match[o] + r.slice(i);
        }
        return n;
      });
    }
    matchAll(e, n) {
      let r = ha(this.spec, e, 0, e.doc.length), i = [];
      for (; !r.next().done; ) {
        if (i.length >= n)
          return null;
        i.push(r.value);
      }
      return i;
    }
    highlight(e, n, r, i) {
      let o = ha(this.spec, e, Math.max(0, n - 250), Math.min(r + 250, e.doc.length));
      for (; !o.next().done; )
        i(o.value.from, o.value.to);
    }
  }
  const Qo = Ee.define(), lS = Ee.define(), Wo = Kt.define({
    create(t) {
      return new nv(O1(t).create(), null);
    },
    update(t, e) {
      for (let n of e.effects)
        n.is(Qo) ? t = new nv(n.value.create(), t.panel) : n.is(lS) && (t = new nv(t.query, n.value ? cS : null));
      return t;
    },
    provide: (t) => Gs.from(t, (e) => e.panel)
  });
  class nv {
    constructor(e, n) {
      this.query = e, this.panel = n;
    }
  }
  const kY = be.mark({
    class: "cm-searchMatch"
  }), CY = be.mark({
    class: "cm-searchMatch cm-searchMatch-selected"
  }), TY = kt.fromClass(class {
    constructor(t) {
      this.view = t, this.decorations = this.highlight(t.state.field(Wo));
    }
    update(t) {
      let e = t.state.field(Wo);
      (e != t.startState.field(Wo) || t.docChanged || t.selectionSet || t.viewportChanged) && (this.decorations = this.highlight(e));
    }
    highlight({ query: t, panel: e }) {
      if (!e || !t.spec.valid)
        return be.none;
      let { view: n } = this, r = new Ai();
      for (let i = 0, o = n.visibleRanges, s = o.length; i < s; i++) {
        let { from: a, to: l } = o[i];
        for (; i < s - 1 && l > o[i + 1].from - 2 * 250; )
          l = o[++i].to;
        t.highlight(n.state, a, l, (c, u) => {
          let h = n.state.selection.ranges.some((p) => p.from == c && p.to == u);
          r.add(c, u, h ? CY : kY);
        });
      }
      return r.finish();
    }
  }, {
    decorations: (t) => t.decorations
  });
  function pf(t) {
    return (e) => {
      let n = e.state.field(Wo, false);
      return n && n.query.spec.valid ? t(e, n) : RR(e);
    };
  }
  const Np = pf((t, { query: e }) => {
    let { to: n } = t.state.selection.main, r = e.nextMatch(t.state, n, n);
    if (!r)
      return false;
    let i = q.single(r.from, r.to), o = t.state.facet(Ol);
    return t.dispatch({
      selection: i,
      effects: [
        uS(t, r),
        o.scrollToMatch(i.main, t)
      ],
      userEvent: "select.search"
    }), LR(t), true;
  }), $p = pf((t, { query: e }) => {
    let { state: n } = t, { from: r } = n.selection.main, i = e.prevMatch(n, r, r);
    if (!i)
      return false;
    let o = q.single(i.from, i.to), s = t.state.facet(Ol);
    return t.dispatch({
      selection: o,
      effects: [
        uS(t, i),
        s.scrollToMatch(o.main, t)
      ],
      userEvent: "select.search"
    }), LR(t), true;
  }), MY = pf((t, { query: e }) => {
    let n = e.matchAll(t.state, 1e3);
    return !n || !n.length ? false : (t.dispatch({
      selection: q.create(n.map((r) => q.range(r.from, r.to))),
      userEvent: "select.search.matches"
    }), true);
  }), AY = ({ state: t, dispatch: e }) => {
    let n = t.selection;
    if (n.ranges.length > 1 || n.main.empty)
      return false;
    let { from: r, to: i } = n.main, o = [], s = 0;
    for (let a = new Sl(t.doc, t.sliceDoc(r, i)); !a.next().done; ) {
      if (o.length > 1e3)
        return false;
      a.value.from == r && (s = o.length), o.push(q.range(a.value.from, a.value.to));
    }
    return e(t.update({
      selection: q.create(o, s),
      userEvent: "select.search.matches"
    })), true;
  }, $T = pf((t, { query: e }) => {
    let { state: n } = t, { from: r, to: i } = n.selection.main;
    if (n.readOnly)
      return false;
    let o = e.nextMatch(n, r, r);
    if (!o)
      return false;
    let s = o, a = [], l, c, u = [];
    s.from == r && s.to == i && (c = n.toText(e.getReplacement(s)), a.push({
      from: s.from,
      to: s.to,
      insert: c
    }), s = e.nextMatch(n, s.from, s.to), u.push(ue.announce.of(n.phrase("replaced match on line $", n.doc.lineAt(r).number) + ".")));
    let h = t.state.changes(a);
    return s && (l = q.single(s.from, s.to).map(h), u.push(uS(t, s)), u.push(n.facet(Ol).scrollToMatch(l.main, t))), t.dispatch({
      changes: h,
      selection: l,
      effects: u,
      userEvent: "input.replace"
    }), true;
  }), EY = pf((t, { query: e }) => {
    if (t.state.readOnly)
      return false;
    let n = e.matchAll(t.state, 1e9).map((i) => {
      let { from: o, to: s } = i;
      return {
        from: o,
        to: s,
        insert: e.getReplacement(i)
      };
    });
    if (!n.length)
      return false;
    let r = t.state.phrase("replaced $ matches", n.length) + ".";
    return t.dispatch({
      changes: n,
      effects: ue.announce.of(r),
      userEvent: "input.replace.all"
    }), true;
  });
  function cS(t) {
    return t.state.facet(Ol).createPanel(t);
  }
  function O1(t, e) {
    var n, r, i, o, s;
    let a = t.selection.main, l = a.empty || a.to > a.from + 100 ? "" : t.sliceDoc(a.from, a.to);
    if (e && !l)
      return e;
    let c = t.facet(Ol);
    return new aS({
      search: ((n = e == null ? void 0 : e.literal) !== null && n !== void 0 ? n : c.literal) ? l : l.replace(/\n/g, "\\n"),
      caseSensitive: (r = e == null ? void 0 : e.caseSensitive) !== null && r !== void 0 ? r : c.caseSensitive,
      literal: (i = e == null ? void 0 : e.literal) !== null && i !== void 0 ? i : c.literal,
      regexp: (o = e == null ? void 0 : e.regexp) !== null && o !== void 0 ? o : c.regexp,
      wholeWord: (s = e == null ? void 0 : e.wholeWord) !== null && s !== void 0 ? s : c.wholeWord
    });
  }
  function OR(t) {
    let e = jx(t, cS);
    return e && e.dom.querySelector("[main-field]");
  }
  function LR(t) {
    let e = OR(t);
    e && e == t.root.activeElement && e.select();
  }
  const RR = (t) => {
    let e = t.state.field(Wo, false);
    if (e && e.panel) {
      let n = OR(t);
      if (n && n != t.root.activeElement) {
        let r = O1(t.state, e.query.spec);
        r.valid && t.dispatch({
          effects: Qo.of(r)
        }), n.focus(), n.select();
      }
    } else
      t.dispatch({
        effects: [
          lS.of(true),
          e ? Qo.of(O1(t.state, e.query.spec)) : Ee.appendConfig.of(RY)
        ]
      });
    return true;
  }, _R = (t) => {
    let e = t.state.field(Wo, false);
    if (!e || !e.panel)
      return false;
    let n = jx(t, cS);
    return n && n.dom.contains(t.root.activeElement) && t.focus(), t.dispatch({
      effects: lS.of(false)
    }), true;
  }, PY = [
    {
      key: "Mod-f",
      run: RR,
      scope: "editor search-panel"
    },
    {
      key: "F3",
      run: Np,
      shift: $p,
      scope: "editor search-panel",
      preventDefault: true
    },
    {
      key: "Mod-g",
      run: Np,
      shift: $p,
      scope: "editor search-panel",
      preventDefault: true
    },
    {
      key: "Escape",
      run: _R,
      scope: "editor search-panel"
    },
    {
      key: "Mod-Shift-l",
      run: AY
    },
    {
      key: "Mod-Alt-g",
      run: sY
    },
    {
      key: "Mod-d",
      run: gY,
      preventDefault: true
    }
  ];
  class OY {
    constructor(e) {
      this.view = e;
      let n = this.query = e.state.field(Wo).query.spec;
      this.commit = this.commit.bind(this), this.searchField = Qe("input", {
        value: n.search,
        placeholder: Vn(e, "Find"),
        "aria-label": Vn(e, "Find"),
        class: "cm-textfield",
        name: "search",
        form: "",
        "main-field": "true",
        onchange: this.commit,
        onkeyup: this.commit
      }), this.replaceField = Qe("input", {
        value: n.replace,
        placeholder: Vn(e, "Replace"),
        "aria-label": Vn(e, "Replace"),
        class: "cm-textfield",
        name: "replace",
        form: "",
        onchange: this.commit,
        onkeyup: this.commit
      }), this.caseField = Qe("input", {
        type: "checkbox",
        name: "case",
        form: "",
        checked: n.caseSensitive,
        onchange: this.commit
      }), this.reField = Qe("input", {
        type: "checkbox",
        name: "re",
        form: "",
        checked: n.regexp,
        onchange: this.commit
      }), this.wordField = Qe("input", {
        type: "checkbox",
        name: "word",
        form: "",
        checked: n.wholeWord,
        onchange: this.commit
      });
      function r(i, o, s) {
        return Qe("button", {
          class: "cm-button",
          name: i,
          onclick: o,
          type: "button"
        }, s);
      }
      this.dom = Qe("div", {
        onkeydown: (i) => this.keydown(i),
        class: "cm-search"
      }, [
        this.searchField,
        r("next", () => Np(e), [
          Vn(e, "next")
        ]),
        r("prev", () => $p(e), [
          Vn(e, "previous")
        ]),
        r("select", () => MY(e), [
          Vn(e, "all")
        ]),
        Qe("label", null, [
          this.caseField,
          Vn(e, "match case")
        ]),
        Qe("label", null, [
          this.reField,
          Vn(e, "regexp")
        ]),
        Qe("label", null, [
          this.wordField,
          Vn(e, "by word")
        ]),
        ...e.state.readOnly ? [] : [
          Qe("br"),
          this.replaceField,
          r("replace", () => $T(e), [
            Vn(e, "replace")
          ]),
          r("replaceAll", () => EY(e), [
            Vn(e, "replace all")
          ])
        ],
        Qe("button", {
          name: "close",
          onclick: () => _R(e),
          "aria-label": Vn(e, "close"),
          type: "button"
        }, [
          "\xD7"
        ])
      ]);
    }
    commit() {
      let e = new aS({
        search: this.searchField.value,
        caseSensitive: this.caseField.checked,
        regexp: this.reField.checked,
        wholeWord: this.wordField.checked,
        replace: this.replaceField.value
      });
      e.eq(this.query) || (this.query = e, this.view.dispatch({
        effects: Qo.of(e)
      }));
    }
    keydown(e) {
      xs(this.view, e, "search-panel") ? e.preventDefault() : e.keyCode == 13 && e.target == this.searchField ? (e.preventDefault(), (e.shiftKey ? $p : Np)(this.view)) : e.keyCode == 13 && e.target == this.replaceField && (e.preventDefault(), $T(this.view));
    }
    update(e) {
      for (let n of e.transactions)
        for (let r of n.effects)
          r.is(Qo) && !r.value.eq(this.query) && this.setQuery(r.value);
    }
    setQuery(e) {
      this.query = e, this.searchField.value = e.search, this.replaceField.value = e.replace, this.caseField.checked = e.caseSensitive, this.reField.checked = e.regexp, this.wordField.checked = e.wholeWord;
    }
    mount() {
      this.searchField.select();
    }
    get pos() {
      return 80;
    }
    get top() {
      return this.view.state.facet(Ol).top;
    }
  }
  function Vn(t, e) {
    return t.state.phrase(e);
  }
  const zh = 30, Fh = /[\s\.,:;?!]/;
  function uS(t, { from: e, to: n }) {
    let r = t.state.doc.lineAt(e), i = t.state.doc.lineAt(n).to, o = Math.max(r.from, e - zh), s = Math.min(i, n + zh), a = t.state.sliceDoc(o, s);
    if (o != r.from) {
      for (let l = 0; l < zh; l++)
        if (!Fh.test(a[l + 1]) && Fh.test(a[l])) {
          a = a.slice(l);
          break;
        }
    }
    if (s != i) {
      for (let l = a.length - 1; l > a.length - zh; l--)
        if (!Fh.test(a[l - 1]) && Fh.test(a[l])) {
          a = a.slice(0, l);
          break;
        }
    }
    return ue.announce.of(`${t.state.phrase("current match")}. ${a} ${t.state.phrase("on line")} ${r.number}.`);
  }
  const LY = ue.baseTheme({
    ".cm-panel.cm-search": {
      padding: "2px 6px 4px",
      position: "relative",
      "& [name=close]": {
        position: "absolute",
        top: "0",
        right: "4px",
        backgroundColor: "inherit",
        border: "none",
        font: "inherit",
        padding: 0,
        margin: 0
      },
      "& input, & button, & label": {
        margin: ".2em .6em .2em 0"
      },
      "& input[type=checkbox]": {
        marginRight: ".2em"
      },
      "& label": {
        fontSize: "80%",
        whiteSpace: "pre"
      }
    },
    "&light .cm-searchMatch": {
      backgroundColor: "#ffff0054"
    },
    "&dark .cm-searchMatch": {
      backgroundColor: "#00ffff8a"
    },
    "&light .cm-searchMatch-selected": {
      backgroundColor: "#ff6a0054"
    },
    "&dark .cm-searchMatch-selected": {
      backgroundColor: "#ff00ff8a"
    }
  }), RY = [
    Wo,
    ns.low(TY),
    LY
  ];
  class DR {
    constructor(e, n, r, i) {
      this.state = e, this.pos = n, this.explicit = r, this.view = i, this.abortListeners = [], this.abortOnDocChange = false;
    }
    tokenBefore(e) {
      let n = pn(this.state).resolveInner(this.pos, -1);
      for (; n && e.indexOf(n.name) < 0; )
        n = n.parent;
      return n ? {
        from: n.from,
        to: this.pos,
        text: this.state.sliceDoc(n.from, this.pos),
        type: n.type
      } : null;
    }
    matchBefore(e) {
      let n = this.state.doc.lineAt(this.pos), r = Math.max(n.from, this.pos - 250), i = n.text.slice(r - n.from, this.pos - n.from), o = i.search(IR(e, false));
      return o < 0 ? null : {
        from: r + o,
        to: this.pos,
        text: i.slice(o)
      };
    }
    get aborted() {
      return this.abortListeners == null;
    }
    addEventListener(e, n, r) {
      e == "abort" && this.abortListeners && (this.abortListeners.push(n), r && r.onDocChange && (this.abortOnDocChange = true));
    }
  }
  function zT(t) {
    let e = Object.keys(t).join(""), n = /\w/.test(e);
    return n && (e = e.replace(/\w/g, "")), `[${n ? "\\w" : ""}${e.replace(/[^\w\s]/g, "\\$&")}]`;
  }
  function _Y(t) {
    let e = /* @__PURE__ */ Object.create(null), n = /* @__PURE__ */ Object.create(null);
    for (let { label: i } of t) {
      e[i[0]] = true;
      for (let o = 1; o < i.length; o++)
        n[i[o]] = true;
    }
    let r = zT(e) + zT(n) + "*$";
    return [
      new RegExp("^" + r),
      new RegExp(r)
    ];
  }
  function DY(t) {
    let e = t.map((i) => typeof i == "string" ? {
      label: i
    } : i), [n, r] = e.every((i) => /^\w+$/.test(i.label)) ? [
      /\w*$/,
      /\w+$/
    ] : _Y(e);
    return (i) => {
      let o = i.matchBefore(r);
      return o || i.explicit ? {
        from: o ? o.from : i.pos,
        options: e,
        validFor: n
      } : null;
    };
  }
  class FT {
    constructor(e, n, r, i) {
      this.completion = e, this.source = n, this.match = r, this.score = i;
    }
  }
  function $s(t) {
    return t.selection.main.from;
  }
  function IR(t, e) {
    var n;
    let { source: r } = t, i = e && r[0] != "^", o = r[r.length - 1] != "$";
    return !i && !o ? t : new RegExp(`${i ? "^" : ""}(?:${r})${o ? "$" : ""}`, (n = t.flags) !== null && n !== void 0 ? n : t.ignoreCase ? "i" : "");
  }
  const BR = Pi.define();
  function IY(t, e, n, r) {
    let { main: i } = t.selection, o = n - i.from, s = r - i.from;
    return {
      ...t.changeByRange((a) => {
        if (a != i && n != r && t.sliceDoc(a.from + o, a.from + s) != t.sliceDoc(n, r))
          return {
            range: a
          };
        let l = t.toText(e);
        return {
          changes: {
            from: a.from + o,
            to: r == i.from ? a.to : a.from + s,
            insert: l
          },
          range: q.cursor(a.from + o + l.length)
        };
      }),
      scrollIntoView: true,
      userEvent: "input.complete"
    };
  }
  const VT = /* @__PURE__ */ new WeakMap();
  function BY(t) {
    if (!Array.isArray(t))
      return t;
    let e = VT.get(t);
    return e || VT.set(t, e = DY(t)), e;
  }
  const zp = Ee.define(), Hu = Ee.define();
  class NY {
    constructor(e) {
      this.pattern = e, this.chars = [], this.folded = [], this.any = [], this.precise = [], this.byWord = [], this.score = 0, this.matched = [];
      for (let n = 0; n < e.length; ) {
        let r = On(e, n), i = mi(r);
        this.chars.push(r);
        let o = e.slice(n, n + i), s = o.toUpperCase();
        this.folded.push(On(s == o ? o.toLowerCase() : s, 0)), n += i;
      }
      this.astral = e.length != this.chars.length;
    }
    ret(e, n) {
      return this.score = e, this.matched = n, this;
    }
    match(e) {
      if (this.pattern.length == 0)
        return this.ret(-100, []);
      if (e.length < this.pattern.length)
        return null;
      let { chars: n, folded: r, any: i, precise: o, byWord: s } = this;
      if (n.length == 1) {
        let k = On(e, 0), C = mi(k), O = C == e.length ? 0 : -100;
        if (k != n[0])
          if (k == r[0])
            O += -200;
          else
            return null;
        return this.ret(O, [
          0,
          C
        ]);
      }
      let a = e.indexOf(this.pattern);
      if (a == 0)
        return this.ret(e.length == this.pattern.length ? 0 : -100, [
          0,
          this.pattern.length
        ]);
      let l = n.length, c = 0;
      if (a < 0) {
        for (let k = 0, C = Math.min(e.length, 200); k < C && c < l; ) {
          let O = On(e, k);
          (O == n[c] || O == r[c]) && (i[c++] = k), k += mi(O);
        }
        if (c < l)
          return null;
      }
      let u = 0, h = 0, p = false, v = 0, y = -1, S = -1, T = /[a-z]/.test(e), w = true;
      for (let k = 0, C = Math.min(e.length, 200), O = 0; k < C && h < l; ) {
        let L = On(e, k);
        a < 0 && (u < l && L == n[u] && (o[u++] = k), v < l && (L == n[v] || L == r[v] ? (v == 0 && (y = k), S = k + 1, v++) : v = 0));
        let D, R = L < 255 ? L >= 48 && L <= 57 || L >= 97 && L <= 122 ? 2 : L >= 65 && L <= 90 ? 1 : 0 : (D = Mx(L)) != D.toLowerCase() ? 1 : D != D.toUpperCase() ? 2 : 0;
        (!k || R == 1 && T || O == 0 && R != 0) && (n[h] == L || r[h] == L && (p = true) ? s[h++] = k : s.length && (w = false)), O = R, k += mi(L);
      }
      return h == l && s[0] == 0 && w ? this.result(-100 + (p ? -200 : 0), s, e) : v == l && y == 0 ? this.ret(-200 - e.length + (S == e.length ? 0 : -100), [
        0,
        S
      ]) : a > -1 ? this.ret(-700 - e.length, [
        a,
        a + this.pattern.length
      ]) : v == l ? this.ret(-200 + -700 - e.length, [
        y,
        S
      ]) : h == l ? this.result(-100 + (p ? -200 : 0) + -700 + (w ? 0 : -1100), s, e) : n.length == 2 ? null : this.result((i[0] ? -700 : 0) + -200 + -1100, i, e);
    }
    result(e, n, r) {
      let i = [], o = 0;
      for (let s of n) {
        let a = s + (this.astral ? mi(On(r, s)) : 1);
        o && i[o - 1] == s ? i[o - 1] = a : (i[o++] = s, i[o++] = a);
      }
      return this.ret(e - r.length, i);
    }
  }
  class $Y {
    constructor(e) {
      this.pattern = e, this.matched = [], this.score = 0, this.folded = e.toLowerCase();
    }
    match(e) {
      if (e.length < this.pattern.length)
        return null;
      let n = e.slice(0, this.pattern.length), r = n == this.pattern ? 0 : n.toLowerCase() == this.folded ? -200 : null;
      return r == null ? null : (this.matched = [
        0,
        n.length
      ], this.score = r + (e.length == this.pattern.length ? 0 : -100), this);
    }
  }
  const Wt = me.define({
    combine(t) {
      return Oi(t, {
        activateOnTyping: true,
        activateOnCompletion: () => false,
        activateOnTypingDelay: 100,
        selectOnOpen: true,
        override: null,
        closeOnBlur: true,
        maxRenderedOptions: 100,
        defaultKeymap: true,
        tooltipClass: () => "",
        optionClass: () => "",
        aboveCursor: false,
        icons: true,
        addToOptions: [],
        positionInfo: zY,
        filterStrict: false,
        compareCompletions: (e, n) => (e.sortText || e.label).localeCompare(n.sortText || n.label),
        interactionDelay: 75,
        updateSyncTime: 100
      }, {
        defaultKeymap: (e, n) => e && n,
        closeOnBlur: (e, n) => e && n,
        icons: (e, n) => e && n,
        tooltipClass: (e, n) => (r) => WT(e(r), n(r)),
        optionClass: (e, n) => (r) => WT(e(r), n(r)),
        addToOptions: (e, n) => e.concat(n),
        filterStrict: (e, n) => e || n
      });
    }
  });
  function WT(t, e) {
    return t ? e ? t + " " + e : t : e;
  }
  function zY(t, e, n, r, i, o) {
    let s = t.textDirection == Je.RTL, a = s, l = false, c = "top", u, h, p = e.left - i.left, v = i.right - e.right, y = r.right - r.left, S = r.bottom - r.top;
    if (a && p < Math.min(y, v) ? a = false : !a && v < Math.min(y, p) && (a = true), y <= (a ? p : v))
      u = Math.max(i.top, Math.min(n.top, i.bottom - S)) - e.top, h = Math.min(400, a ? p : v);
    else {
      l = true, h = Math.min(400, (s ? e.right : i.right - e.left) - 30);
      let k = i.bottom - e.bottom;
      k >= S || k > e.top ? u = n.bottom - e.top : (c = "bottom", u = e.bottom - n.top);
    }
    let T = (e.bottom - e.top) / o.offsetHeight, w = (e.right - e.left) / o.offsetWidth;
    return {
      style: `${c}: ${u / T}px; max-width: ${h / w}px`,
      class: "cm-completionInfo-" + (l ? s ? "left-narrow" : "right-narrow" : a ? "left" : "right")
    };
  }
  function FY(t) {
    let e = t.addToOptions.slice();
    return t.icons && e.push({
      render(n) {
        let r = document.createElement("div");
        return r.classList.add("cm-completionIcon"), n.type && r.classList.add(...n.type.split(/\s+/g).map((i) => "cm-completionIcon-" + i)), r.setAttribute("aria-hidden", "true"), r;
      },
      position: 20
    }), e.push({
      render(n, r, i, o) {
        let s = document.createElement("span");
        s.className = "cm-completionLabel";
        let a = n.displayLabel || n.label, l = 0;
        for (let c = 0; c < o.length; ) {
          let u = o[c++], h = o[c++];
          u > l && s.appendChild(document.createTextNode(a.slice(l, u)));
          let p = s.appendChild(document.createElement("span"));
          p.appendChild(document.createTextNode(a.slice(u, h))), p.className = "cm-completionMatchedText", l = h;
        }
        return l < a.length && s.appendChild(document.createTextNode(a.slice(l))), s;
      },
      position: 50
    }, {
      render(n) {
        if (!n.detail)
          return null;
        let r = document.createElement("span");
        return r.className = "cm-completionDetail", r.textContent = n.detail, r;
      },
      position: 80
    }), e.sort((n, r) => n.position - r.position).map((n) => n.render);
  }
  function rv(t, e, n) {
    if (t <= n)
      return {
        from: 0,
        to: t
      };
    if (e < 0 && (e = 0), e <= t >> 1) {
      let i = Math.floor(e / n);
      return {
        from: i * n,
        to: (i + 1) * n
      };
    }
    let r = Math.floor((t - e) / n);
    return {
      from: t - (r + 1) * n,
      to: t - r * n
    };
  }
  class VY {
    constructor(e, n, r) {
      this.view = e, this.stateField = n, this.applyCompletion = r, this.info = null, this.infoDestroy = null, this.placeInfoReq = {
        read: () => this.measureInfo(),
        write: (l) => this.placeInfo(l),
        key: this
      }, this.space = null, this.currentClass = "";
      let i = e.state.field(n), { options: o, selected: s } = i.open, a = e.state.facet(Wt);
      this.optionContent = FY(a), this.optionClass = a.optionClass, this.tooltipClass = a.tooltipClass, this.range = rv(o.length, s, a.maxRenderedOptions), this.dom = document.createElement("div"), this.dom.className = "cm-tooltip-autocomplete", this.updateTooltipClass(e.state), this.dom.addEventListener("mousedown", (l) => {
        let { options: c } = e.state.field(n).open;
        for (let u = l.target, h; u && u != this.dom; u = u.parentNode)
          if (u.nodeName == "LI" && (h = /-(\d+)$/.exec(u.id)) && +h[1] < c.length) {
            this.applyCompletion(e, c[+h[1]]), l.preventDefault();
            return;
          }
      }), this.dom.addEventListener("focusout", (l) => {
        let c = e.state.field(this.stateField, false);
        c && c.tooltip && e.state.facet(Wt).closeOnBlur && l.relatedTarget != e.contentDOM && e.dispatch({
          effects: Hu.of(null)
        });
      }), this.showOptions(o, i.id);
    }
    mount() {
      this.updateSel();
    }
    showOptions(e, n) {
      this.list && this.list.remove(), this.list = this.dom.appendChild(this.createListBox(e, n, this.range)), this.list.addEventListener("scroll", () => {
        this.info && this.view.requestMeasure(this.placeInfoReq);
      });
    }
    update(e) {
      var n;
      let r = e.state.field(this.stateField), i = e.startState.field(this.stateField);
      if (this.updateTooltipClass(e.state), r != i) {
        let { options: o, selected: s, disabled: a } = r.open;
        (!i.open || i.open.options != o) && (this.range = rv(o.length, s, e.state.facet(Wt).maxRenderedOptions), this.showOptions(o, r.id)), this.updateSel(), a != ((n = i.open) === null || n === void 0 ? void 0 : n.disabled) && this.dom.classList.toggle("cm-tooltip-autocomplete-disabled", !!a);
      }
    }
    updateTooltipClass(e) {
      let n = this.tooltipClass(e);
      if (n != this.currentClass) {
        for (let r of this.currentClass.split(" "))
          r && this.dom.classList.remove(r);
        for (let r of n.split(" "))
          r && this.dom.classList.add(r);
        this.currentClass = n;
      }
    }
    positioned(e) {
      this.space = e, this.info && this.view.requestMeasure(this.placeInfoReq);
    }
    updateSel() {
      let e = this.view.state.field(this.stateField), n = e.open;
      (n.selected > -1 && n.selected < this.range.from || n.selected >= this.range.to) && (this.range = rv(n.options.length, n.selected, this.view.state.facet(Wt).maxRenderedOptions), this.showOptions(n.options, e.id));
      let r = this.updateSelectedOption(n.selected);
      if (r) {
        this.destroyInfo();
        let { completion: i } = n.options[n.selected], { info: o } = i;
        if (!o)
          return;
        let s = typeof o == "string" ? document.createTextNode(o) : o(i);
        if (!s)
          return;
        "then" in s ? s.then((a) => {
          a && this.view.state.field(this.stateField, false) == e && this.addInfoPane(a, i);
        }).catch((a) => In(this.view.state, a, "completion info")) : (this.addInfoPane(s, i), r.setAttribute("aria-describedby", this.info.id));
      }
    }
    addInfoPane(e, n) {
      this.destroyInfo();
      let r = this.info = document.createElement("div");
      if (r.className = "cm-tooltip cm-completionInfo", r.id = "cm-completionInfo-" + Math.floor(Math.random() * 65535).toString(16), e.nodeType != null)
        r.appendChild(e), this.infoDestroy = null;
      else {
        let { dom: i, destroy: o } = e;
        r.appendChild(i), this.infoDestroy = o || null;
      }
      this.dom.appendChild(r), this.view.requestMeasure(this.placeInfoReq);
    }
    updateSelectedOption(e) {
      let n = null;
      for (let r = this.list.firstChild, i = this.range.from; r; r = r.nextSibling, i++)
        r.nodeName != "LI" || !r.id ? i-- : i == e ? r.hasAttribute("aria-selected") || (r.setAttribute("aria-selected", "true"), n = r) : r.hasAttribute("aria-selected") && (r.removeAttribute("aria-selected"), r.removeAttribute("aria-describedby"));
      return n && HY(this.list, n), n;
    }
    measureInfo() {
      let e = this.dom.querySelector("[aria-selected]");
      if (!e || !this.info)
        return null;
      let n = this.dom.getBoundingClientRect(), r = this.info.getBoundingClientRect(), i = e.getBoundingClientRect(), o = this.space;
      if (!o) {
        let s = this.dom.ownerDocument.documentElement;
        o = {
          left: 0,
          top: 0,
          right: s.clientWidth,
          bottom: s.clientHeight
        };
      }
      return i.top > Math.min(o.bottom, n.bottom) - 10 || i.bottom < Math.max(o.top, n.top) + 10 ? null : this.view.state.facet(Wt).positionInfo(this.view, n, i, r, o, this.dom);
    }
    placeInfo(e) {
      this.info && (e ? (e.style && (this.info.style.cssText = e.style), this.info.className = "cm-tooltip cm-completionInfo " + (e.class || "")) : this.info.style.cssText = "top: -1e6px");
    }
    createListBox(e, n, r) {
      const i = document.createElement("ul");
      i.id = n, i.setAttribute("role", "listbox"), i.setAttribute("aria-expanded", "true"), i.setAttribute("aria-label", this.view.state.phrase("Completions")), i.addEventListener("mousedown", (s) => {
        s.target == i && s.preventDefault();
      });
      let o = null;
      for (let s = r.from; s < r.to; s++) {
        let { completion: a, match: l } = e[s], { section: c } = a;
        if (c) {
          let p = typeof c == "string" ? c : c.name;
          if (p != o && (s > r.from || r.from == 0))
            if (o = p, typeof c != "string" && c.header)
              i.appendChild(c.header(c));
            else {
              let v = i.appendChild(document.createElement("completion-section"));
              v.textContent = p;
            }
        }
        const u = i.appendChild(document.createElement("li"));
        u.id = n + "-" + s, u.setAttribute("role", "option");
        let h = this.optionClass(a);
        h && (u.className = h);
        for (let p of this.optionContent) {
          let v = p(a, this.view.state, this.view, l);
          v && u.appendChild(v);
        }
      }
      return r.from && i.classList.add("cm-completionListIncompleteTop"), r.to < e.length && i.classList.add("cm-completionListIncompleteBottom"), i;
    }
    destroyInfo() {
      this.info && (this.infoDestroy && this.infoDestroy(), this.info.remove(), this.info = null);
    }
    destroy() {
      this.destroyInfo();
    }
  }
  function WY(t, e) {
    return (n) => new VY(n, t, e);
  }
  function HY(t, e) {
    let n = t.getBoundingClientRect(), r = e.getBoundingClientRect(), i = n.height / t.offsetHeight;
    r.top < n.top ? t.scrollTop -= (n.top - r.top) / i : r.bottom > n.bottom && (t.scrollTop += (r.bottom - n.bottom) / i);
  }
  function HT(t) {
    return (t.boost || 0) * 100 + (t.apply ? 10 : 0) + (t.info ? 5 : 0) + (t.type ? 1 : 0);
  }
  function jY(t, e) {
    let n = [], r = null, i = null, o = (u) => {
      n.push(u);
      let { section: h } = u.completion;
      if (h) {
        r || (r = []);
        let p = typeof h == "string" ? h : h.name;
        r.some((v) => v.name == p) || r.push(typeof h == "string" ? {
          name: p
        } : h);
      }
    }, s = e.facet(Wt);
    for (let u of t)
      if (u.hasResult()) {
        let h = u.result.getMatch;
        if (u.result.filter === false)
          for (let p of u.result.options)
            o(new FT(p, u.source, h ? h(p) : [], 1e9 - n.length));
        else {
          let p = e.sliceDoc(u.from, u.to), v, y = s.filterStrict ? new $Y(p) : new NY(p);
          for (let S of u.result.options)
            if (v = y.match(S.label)) {
              let T = S.displayLabel ? h ? h(S, v.matched) : [] : v.matched, w = v.score + (S.boost || 0);
              if (o(new FT(S, u.source, T, w)), typeof S.section == "object" && S.section.rank === "dynamic") {
                let { name: k } = S.section;
                i || (i = /* @__PURE__ */ Object.create(null)), i[k] = Math.max(w, i[k] || -1e9);
              }
            }
        }
      }
    if (r) {
      let u = /* @__PURE__ */ Object.create(null), h = 0, p = (v, y) => (v.rank === "dynamic" && y.rank === "dynamic" ? i[y.name] - i[v.name] : 0) || (typeof v.rank == "number" ? v.rank : 1e9) - (typeof y.rank == "number" ? y.rank : 1e9) || (v.name < y.name ? -1 : 1);
      for (let v of r.sort(p))
        h -= 1e5, u[v.name] = h;
      for (let v of n) {
        let { section: y } = v.completion;
        y && (v.score += u[typeof y == "string" ? y : y.name]);
      }
    }
    let a = [], l = null, c = s.compareCompletions;
    for (let u of n.sort((h, p) => p.score - h.score || c(h.completion, p.completion))) {
      let h = u.completion;
      !l || l.label != h.label || l.detail != h.detail || l.type != null && h.type != null && l.type != h.type || l.apply != h.apply || l.boost != h.boost ? a.push(u) : HT(u.completion) > HT(l) && (a[a.length - 1] = u), l = u.completion;
    }
    return a;
  }
  class Ia {
    constructor(e, n, r, i, o, s) {
      this.options = e, this.attrs = n, this.tooltip = r, this.timestamp = i, this.selected = o, this.disabled = s;
    }
    setSelected(e, n) {
      return e == this.selected || e >= this.options.length ? this : new Ia(this.options, jT(n, e), this.tooltip, this.timestamp, e, this.disabled);
    }
    static build(e, n, r, i, o, s) {
      if (i && !s && e.some((c) => c.isPending))
        return i.setDisabled();
      let a = jY(e, n);
      if (!a.length)
        return i && e.some((c) => c.isPending) ? i.setDisabled() : null;
      let l = n.facet(Wt).selectOnOpen ? 0 : -1;
      if (i && i.selected != l && i.selected != -1) {
        let c = i.options[i.selected].completion;
        for (let u = 0; u < a.length; u++)
          if (a[u].completion == c) {
            l = u;
            break;
          }
      }
      return new Ia(a, jT(r, l), {
        pos: e.reduce((c, u) => u.hasResult() ? Math.min(c, u.from) : c, 1e8),
        create: XY,
        above: o.aboveCursor
      }, i ? i.timestamp : Date.now(), l, false);
    }
    map(e) {
      return new Ia(this.options, this.attrs, {
        ...this.tooltip,
        pos: e.mapPos(this.tooltip.pos)
      }, this.timestamp, this.selected, this.disabled);
    }
    setDisabled() {
      return new Ia(this.options, this.attrs, this.tooltip, this.timestamp, this.selected, true);
    }
  }
  class Fp {
    constructor(e, n, r) {
      this.active = e, this.id = n, this.open = r;
    }
    static start() {
      return new Fp(GY, "cm-ac-" + Math.floor(Math.random() * 2e6).toString(36), null);
    }
    update(e) {
      let { state: n } = e, r = n.facet(Wt), o = (r.override || n.languageDataAt("autocomplete", $s(n)).map(BY)).map((l) => (this.active.find((u) => u.source == l) || new vr(l, this.active.some((u) => u.state != 0) ? 1 : 0)).update(e, r));
      o.length == this.active.length && o.every((l, c) => l == this.active[c]) && (o = this.active);
      let s = this.open, a = e.effects.some((l) => l.is(fS));
      s && e.docChanged && (s = s.map(e.changes)), e.selection || o.some((l) => l.hasResult() && e.changes.touchesRange(l.from, l.to)) || !UY(o, this.active) || a ? s = Ia.build(o, n, this.id, s, r, a) : s && s.disabled && !o.some((l) => l.isPending) && (s = null), !s && o.every((l) => !l.isPending) && o.some((l) => l.hasResult()) && (o = o.map((l) => l.hasResult() ? new vr(l.source, 0) : l));
      for (let l of e.effects)
        l.is($R) && (s = s && s.setSelected(l.value, this.id));
      return o == this.active && s == this.open ? this : new Fp(o, this.id, s);
    }
    get tooltip() {
      return this.open ? this.open.tooltip : null;
    }
    get attrs() {
      return this.open ? this.open.attrs : this.active.length ? KY : qY;
    }
  }
  function UY(t, e) {
    if (t == e)
      return true;
    for (let n = 0, r = 0; ; ) {
      for (; n < t.length && !t[n].hasResult(); )
        n++;
      for (; r < e.length && !e[r].hasResult(); )
        r++;
      let i = n == t.length, o = r == e.length;
      if (i || o)
        return i == o;
      if (t[n++].result != e[r++].result)
        return false;
    }
  }
  const KY = {
    "aria-autocomplete": "list"
  }, qY = {};
  function jT(t, e) {
    let n = {
      "aria-autocomplete": "list",
      "aria-haspopup": "listbox",
      "aria-controls": t
    };
    return e > -1 && (n["aria-activedescendant"] = t + "-" + e), n;
  }
  const GY = [];
  function NR(t, e) {
    if (t.isUserEvent("input.complete")) {
      let r = t.annotation(BR);
      if (r && e.activateOnCompletion(r))
        return 12;
    }
    let n = t.isUserEvent("input.type");
    return n && e.activateOnTyping ? 5 : n ? 1 : t.isUserEvent("delete.backward") ? 2 : t.selection ? 8 : t.docChanged ? 16 : 0;
  }
  class vr {
    constructor(e, n, r = false) {
      this.source = e, this.state = n, this.explicit = r;
    }
    hasResult() {
      return false;
    }
    get isPending() {
      return this.state == 1;
    }
    update(e, n) {
      let r = NR(e, n), i = this;
      (r & 8 || r & 16 && this.touches(e)) && (i = new vr(i.source, 0)), r & 4 && i.state == 0 && (i = new vr(this.source, 1)), i = i.updateFor(e, r);
      for (let o of e.effects)
        if (o.is(zp))
          i = new vr(i.source, 1, o.value);
        else if (o.is(Hu))
          i = new vr(i.source, 0);
        else if (o.is(fS))
          for (let s of o.value)
            s.source == i.source && (i = s);
      return i;
    }
    updateFor(e, n) {
      return this.map(e.changes);
    }
    map(e) {
      return this;
    }
    touches(e) {
      return e.changes.touchesRange($s(e.state));
    }
  }
  class el extends vr {
    constructor(e, n, r, i, o, s) {
      super(e, 3, n), this.limit = r, this.result = i, this.from = o, this.to = s;
    }
    hasResult() {
      return true;
    }
    updateFor(e, n) {
      var r;
      if (!(n & 3))
        return this.map(e.changes);
      let i = this.result;
      i.map && !e.changes.empty && (i = i.map(i, e.changes));
      let o = e.changes.mapPos(this.from), s = e.changes.mapPos(this.to, 1), a = $s(e.state);
      if (a > s || !i || n & 2 && ($s(e.startState) == this.from || a < this.limit))
        return new vr(this.source, n & 4 ? 1 : 0);
      let l = e.changes.mapPos(this.limit);
      return YY(i.validFor, e.state, o, s) ? new el(this.source, this.explicit, l, i, o, s) : i.update && (i = i.update(i, o, s, new DR(e.state, a, false))) ? new el(this.source, this.explicit, l, i, i.from, (r = i.to) !== null && r !== void 0 ? r : $s(e.state)) : new vr(this.source, 1, this.explicit);
    }
    map(e) {
      return e.empty ? this : (this.result.map ? this.result.map(this.result, e) : this.result) ? new el(this.source, this.explicit, e.mapPos(this.limit), this.result, e.mapPos(this.from), e.mapPos(this.to, 1)) : new vr(this.source, 0);
    }
    touches(e) {
      return e.changes.touchesRange(this.from, this.to);
    }
  }
  function YY(t, e, n, r) {
    if (!t)
      return false;
    let i = e.sliceDoc(n, r);
    return typeof t == "function" ? t(i, n, r, e) : IR(t, true).test(i);
  }
  const fS = Ee.define({
    map(t, e) {
      return t.map((n) => n.map(e));
    }
  }), $R = Ee.define(), Ln = Kt.define({
    create() {
      return Fp.start();
    },
    update(t, e) {
      return t.update(e);
    },
    provide: (t) => [
      Hx.from(t, (e) => e.tooltip),
      ue.contentAttributes.from(t, (e) => e.attrs)
    ]
  });
  function hS(t, e) {
    const n = e.completion.apply || e.completion.label;
    let r = t.state.field(Ln).active.find((i) => i.source == e.source);
    return r instanceof el ? (typeof n == "string" ? t.dispatch({
      ...IY(t.state, n, r.from, r.to),
      annotations: BR.of(e.completion)
    }) : n(t, e.completion, r.from, r.to), true) : false;
  }
  const XY = WY(Ln, hS);
  function Vh(t, e = "option") {
    return (n) => {
      let r = n.state.field(Ln, false);
      if (!r || !r.open || r.open.disabled || Date.now() - r.open.timestamp < n.state.facet(Wt).interactionDelay)
        return false;
      let i = 1, o;
      e == "page" && (o = kL(n, r.open.tooltip)) && (i = Math.max(2, Math.floor(o.dom.offsetHeight / o.dom.querySelector("li").offsetHeight) - 1));
      let { length: s } = r.open.options, a = r.open.selected > -1 ? r.open.selected + i * (t ? 1 : -1) : t ? 0 : s - 1;
      return a < 0 ? a = e == "page" ? 0 : s - 1 : a >= s && (a = e == "page" ? s - 1 : 0), n.dispatch({
        effects: $R.of(a)
      }), true;
    };
  }
  const QY = (t) => {
    let e = t.state.field(Ln, false);
    return t.state.readOnly || !e || !e.open || e.open.selected < 0 || e.open.disabled || Date.now() - e.open.timestamp < t.state.facet(Wt).interactionDelay ? false : hS(t, e.open.options[e.open.selected]);
  }, iv = (t) => t.state.field(Ln, false) ? (t.dispatch({
    effects: zp.of(true)
  }), true) : false, JY = (t) => {
    let e = t.state.field(Ln, false);
    return !e || !e.active.some((n) => n.state != 0) ? false : (t.dispatch({
      effects: Hu.of(null)
    }), true);
  };
  class ZY {
    constructor(e, n) {
      this.active = e, this.context = n, this.time = Date.now(), this.updates = [], this.done = void 0;
    }
  }
  const eX = 50, tX = 1e3, nX = kt.fromClass(class {
    constructor(t) {
      this.view = t, this.debounceUpdate = -1, this.running = [], this.debounceAccept = -1, this.pendingStart = false, this.composing = 0;
      for (let e of t.state.field(Ln).active)
        e.isPending && this.startQuery(e);
    }
    update(t) {
      let e = t.state.field(Ln), n = t.state.facet(Wt);
      if (!t.selectionSet && !t.docChanged && t.startState.field(Ln) == e)
        return;
      let r = t.transactions.some((o) => {
        let s = NR(o, n);
        return s & 8 || (o.selection || o.docChanged) && !(s & 3);
      });
      for (let o = 0; o < this.running.length; o++) {
        let s = this.running[o];
        if (r || s.context.abortOnDocChange && t.docChanged || s.updates.length + t.transactions.length > eX && Date.now() - s.time > tX) {
          for (let a of s.context.abortListeners)
            try {
              a();
            } catch (l) {
              In(this.view.state, l);
            }
          s.context.abortListeners = null, this.running.splice(o--, 1);
        } else
          s.updates.push(...t.transactions);
      }
      this.debounceUpdate > -1 && clearTimeout(this.debounceUpdate), t.transactions.some((o) => o.effects.some((s) => s.is(zp))) && (this.pendingStart = true);
      let i = this.pendingStart ? 50 : n.activateOnTypingDelay;
      if (this.debounceUpdate = e.active.some((o) => o.isPending && !this.running.some((s) => s.active.source == o.source)) ? setTimeout(() => this.startUpdate(), i) : -1, this.composing != 0)
        for (let o of t.transactions)
          o.isUserEvent("input.type") ? this.composing = 2 : this.composing == 2 && o.selection && (this.composing = 3);
    }
    startUpdate() {
      this.debounceUpdate = -1, this.pendingStart = false;
      let { state: t } = this.view, e = t.field(Ln);
      for (let n of e.active)
        n.isPending && !this.running.some((r) => r.active.source == n.source) && this.startQuery(n);
      this.running.length && e.open && e.open.disabled && (this.debounceAccept = setTimeout(() => this.accept(), this.view.state.facet(Wt).updateSyncTime));
    }
    startQuery(t) {
      let { state: e } = this.view, n = $s(e), r = new DR(e, n, t.explicit, this.view), i = new ZY(t, r);
      this.running.push(i), Promise.resolve(t.source(r)).then((o) => {
        i.context.aborted || (i.done = o || null, this.scheduleAccept());
      }, (o) => {
        this.view.dispatch({
          effects: Hu.of(null)
        }), In(this.view.state, o);
      });
    }
    scheduleAccept() {
      this.running.every((t) => t.done !== void 0) ? this.accept() : this.debounceAccept < 0 && (this.debounceAccept = setTimeout(() => this.accept(), this.view.state.facet(Wt).updateSyncTime));
    }
    accept() {
      var t;
      this.debounceAccept > -1 && clearTimeout(this.debounceAccept), this.debounceAccept = -1;
      let e = [], n = this.view.state.facet(Wt), r = this.view.state.field(Ln);
      for (let i = 0; i < this.running.length; i++) {
        let o = this.running[i];
        if (o.done === void 0)
          continue;
        if (this.running.splice(i--, 1), o.done) {
          let a = $s(o.updates.length ? o.updates[0].startState : this.view.state), l = Math.min(a, o.done.from + (o.active.explicit ? 0 : 1)), c = new el(o.active.source, o.active.explicit, l, o.done, o.done.from, (t = o.done.to) !== null && t !== void 0 ? t : a);
          for (let u of o.updates)
            c = c.update(u, n);
          if (c.hasResult()) {
            e.push(c);
            continue;
          }
        }
        let s = r.active.find((a) => a.source == o.active.source);
        if (s && s.isPending)
          if (o.done == null) {
            let a = new vr(o.active.source, 0);
            for (let l of o.updates)
              a = a.update(l, n);
            a.isPending || e.push(a);
          } else
            this.startQuery(s);
      }
      (e.length || r.open && r.open.disabled) && this.view.dispatch({
        effects: fS.of(e)
      });
    }
  }, {
    eventHandlers: {
      blur(t) {
        let e = this.view.state.field(Ln, false);
        if (e && e.tooltip && this.view.state.facet(Wt).closeOnBlur) {
          let n = e.open && kL(this.view, e.open.tooltip);
          (!n || !n.dom.contains(t.relatedTarget)) && setTimeout(() => this.view.dispatch({
            effects: Hu.of(null)
          }), 10);
        }
      },
      compositionstart() {
        this.composing = 1;
      },
      compositionend() {
        this.composing == 3 && setTimeout(() => this.view.dispatch({
          effects: zp.of(false)
        }), 20), this.composing = 0;
      }
    }
  }), rX = typeof navigator == "object" && /Win/.test(navigator.platform), iX = ns.highest(ue.domEventHandlers({
    keydown(t, e) {
      let n = e.state.field(Ln, false);
      if (!n || !n.open || n.open.disabled || n.open.selected < 0 || t.key.length > 1 || t.ctrlKey && !(rX && t.altKey) || t.metaKey)
        return false;
      let r = n.open.options[n.open.selected], i = n.active.find((s) => s.source == r.source), o = r.completion.commitCharacters || i.result.commitCharacters;
      return o && o.indexOf(t.key) > -1 && hS(e, r), false;
    }
  })), oX = ue.baseTheme({
    ".cm-tooltip.cm-tooltip-autocomplete": {
      "& > ul": {
        fontFamily: "monospace",
        whiteSpace: "nowrap",
        overflow: "hidden auto",
        maxWidth_fallback: "700px",
        maxWidth: "min(700px, 95vw)",
        minWidth: "250px",
        maxHeight: "10em",
        height: "100%",
        listStyle: "none",
        margin: 0,
        padding: 0,
        "& > li, & > completion-section": {
          padding: "1px 3px",
          lineHeight: 1.2
        },
        "& > li": {
          overflowX: "hidden",
          textOverflow: "ellipsis",
          cursor: "pointer"
        },
        "& > completion-section": {
          display: "list-item",
          borderBottom: "1px solid silver",
          paddingLeft: "0.5em",
          opacity: 0.7
        }
      }
    },
    "&light .cm-tooltip-autocomplete ul li[aria-selected]": {
      background: "#17c",
      color: "white"
    },
    "&light .cm-tooltip-autocomplete-disabled ul li[aria-selected]": {
      background: "#777"
    },
    "&dark .cm-tooltip-autocomplete ul li[aria-selected]": {
      background: "#347",
      color: "white"
    },
    "&dark .cm-tooltip-autocomplete-disabled ul li[aria-selected]": {
      background: "#444"
    },
    ".cm-completionListIncompleteTop:before, .cm-completionListIncompleteBottom:after": {
      content: '"\xB7\xB7\xB7"',
      opacity: 0.5,
      display: "block",
      textAlign: "center"
    },
    ".cm-tooltip.cm-completionInfo": {
      position: "absolute",
      padding: "3px 9px",
      width: "max-content",
      maxWidth: `${400}px`,
      boxSizing: "border-box",
      whiteSpace: "pre-line"
    },
    ".cm-completionInfo.cm-completionInfo-left": {
      right: "100%"
    },
    ".cm-completionInfo.cm-completionInfo-right": {
      left: "100%"
    },
    ".cm-completionInfo.cm-completionInfo-left-narrow": {
      right: `${30}px`
    },
    ".cm-completionInfo.cm-completionInfo-right-narrow": {
      left: `${30}px`
    },
    "&light .cm-snippetField": {
      backgroundColor: "#00000022"
    },
    "&dark .cm-snippetField": {
      backgroundColor: "#ffffff22"
    },
    ".cm-snippetFieldPosition": {
      verticalAlign: "text-top",
      width: 0,
      height: "1.15em",
      display: "inline-block",
      margin: "0 -0.7px -.7em",
      borderLeft: "1.4px dotted #888"
    },
    ".cm-completionMatchedText": {
      textDecoration: "underline"
    },
    ".cm-completionDetail": {
      marginLeft: "0.5em",
      fontStyle: "italic"
    },
    ".cm-completionIcon": {
      fontSize: "90%",
      width: ".8em",
      display: "inline-block",
      textAlign: "center",
      paddingRight: ".6em",
      opacity: "0.6",
      boxSizing: "content-box"
    },
    ".cm-completionIcon-function, .cm-completionIcon-method": {
      "&:after": {
        content: "'\u0192'"
      }
    },
    ".cm-completionIcon-class": {
      "&:after": {
        content: "'\u25CB'"
      }
    },
    ".cm-completionIcon-interface": {
      "&:after": {
        content: "'\u25CC'"
      }
    },
    ".cm-completionIcon-variable": {
      "&:after": {
        content: "'\u{1D465}'"
      }
    },
    ".cm-completionIcon-constant": {
      "&:after": {
        content: "'\u{1D436}'"
      }
    },
    ".cm-completionIcon-type": {
      "&:after": {
        content: "'\u{1D461}'"
      }
    },
    ".cm-completionIcon-enum": {
      "&:after": {
        content: "'\u222A'"
      }
    },
    ".cm-completionIcon-property": {
      "&:after": {
        content: "'\u25A1'"
      }
    },
    ".cm-completionIcon-keyword": {
      "&:after": {
        content: "'\u{1F511}\uFE0E'"
      }
    },
    ".cm-completionIcon-namespace": {
      "&:after": {
        content: "'\u25A2'"
      }
    },
    ".cm-completionIcon-text": {
      "&:after": {
        content: "'abc'",
        fontSize: "50%",
        verticalAlign: "middle"
      }
    }
  }), ju = {
    brackets: [
      "(",
      "[",
      "{",
      "'",
      '"'
    ],
    before: ")]}:;>",
    stringPrefixes: []
  }, Ls = Ee.define({
    map(t, e) {
      let n = e.mapPos(t, -1, Zt.TrackAfter);
      return n ?? void 0;
    }
  }), dS = new class extends Uo {
  }();
  dS.startSide = 1;
  dS.endSide = -1;
  const zR = Kt.define({
    create() {
      return _e.empty;
    },
    update(t, e) {
      if (t = t.map(e.changes), e.selection) {
        let n = e.state.doc.lineAt(e.selection.main.head);
        t = t.update({
          filter: (r) => r >= n.from && r <= n.to
        });
      }
      for (let n of e.effects)
        n.is(Ls) && (t = t.update({
          add: [
            dS.range(n.value, n.value + 1)
          ]
        }));
      return t;
    }
  });
  function sX() {
    return [
      lX,
      zR
    ];
  }
  const ov = "()[]{}<>\xAB\xBB\xBB\xAB\uFF3B\uFF3D\uFF5B\uFF5D";
  function FR(t) {
    for (let e = 0; e < ov.length; e += 2)
      if (ov.charCodeAt(e) == t)
        return ov.charAt(e + 1);
    return Mx(t < 128 ? t : t + 1);
  }
  function VR(t, e) {
    return t.languageDataAt("closeBrackets", e)[0] || ju;
  }
  const aX = typeof navigator == "object" && /Android\b/.test(navigator.userAgent), lX = ue.inputHandler.of((t, e, n, r) => {
    if ((aX ? t.composing : t.compositionStarted) || t.state.readOnly)
      return false;
    let i = t.state.selection.main;
    if (r.length > 2 || r.length == 2 && mi(On(r, 0)) == 1 || e != i.from || n != i.to)
      return false;
    let o = fX(t.state, r);
    return o ? (t.dispatch(o), true) : false;
  }), cX = ({ state: t, dispatch: e }) => {
    if (t.readOnly)
      return false;
    let r = VR(t, t.selection.main.head).brackets || ju.brackets, i = null, o = t.changeByRange((s) => {
      if (s.empty) {
        let a = hX(t.doc, s.head);
        for (let l of r)
          if (l == a && Qm(t.doc, s.head) == FR(On(l, 0)))
            return {
              changes: {
                from: s.head - l.length,
                to: s.head + l.length
              },
              range: q.cursor(s.head - l.length)
            };
      }
      return {
        range: i = s
      };
    });
    return i || e(t.update(o, {
      scrollIntoView: true,
      userEvent: "delete.backward"
    })), !i;
  }, uX = [
    {
      key: "Backspace",
      run: cX
    }
  ];
  function fX(t, e) {
    let n = VR(t, t.selection.main.head), r = n.brackets || ju.brackets;
    for (let i of r) {
      let o = FR(On(i, 0));
      if (e == i)
        return o == i ? mX(t, i, r.indexOf(i + i + i) > -1, n) : dX(t, i, o, n.before || ju.before);
      if (e == o && WR(t, t.selection.main.from))
        return pX(t, i, o);
    }
    return null;
  }
  function WR(t, e) {
    let n = false;
    return t.field(zR).between(0, t.doc.length, (r) => {
      r == e && (n = true);
    }), n;
  }
  function Qm(t, e) {
    let n = t.sliceString(e, e + 2);
    return n.slice(0, mi(On(n, 0)));
  }
  function hX(t, e) {
    let n = t.sliceString(e - 2, e);
    return mi(On(n, 0)) == n.length ? n : n.slice(1);
  }
  function dX(t, e, n, r) {
    let i = null, o = t.changeByRange((s) => {
      if (!s.empty)
        return {
          changes: [
            {
              insert: e,
              from: s.from
            },
            {
              insert: n,
              from: s.to
            }
          ],
          effects: Ls.of(s.to + e.length),
          range: q.range(s.anchor + e.length, s.head + e.length)
        };
      let a = Qm(t.doc, s.head);
      return !a || /\s/.test(a) || r.indexOf(a) > -1 ? {
        changes: {
          insert: e + n,
          from: s.head
        },
        effects: Ls.of(s.head + e.length),
        range: q.cursor(s.head + e.length)
      } : {
        range: i = s
      };
    });
    return i ? null : t.update(o, {
      scrollIntoView: true,
      userEvent: "input.type"
    });
  }
  function pX(t, e, n) {
    let r = null, i = t.changeByRange((o) => o.empty && Qm(t.doc, o.head) == n ? {
      changes: {
        from: o.head,
        to: o.head + n.length,
        insert: n
      },
      range: q.cursor(o.head + n.length)
    } : r = {
      range: o
    });
    return r ? null : t.update(i, {
      scrollIntoView: true,
      userEvent: "input.type"
    });
  }
  function mX(t, e, n, r) {
    let i = r.stringPrefixes || ju.stringPrefixes, o = null, s = t.changeByRange((a) => {
      if (!a.empty)
        return {
          changes: [
            {
              insert: e,
              from: a.from
            },
            {
              insert: e,
              from: a.to
            }
          ],
          effects: Ls.of(a.to + e.length),
          range: q.range(a.anchor + e.length, a.head + e.length)
        };
      let l = a.head, c = Qm(t.doc, l), u;
      if (c == e) {
        if (UT(t, l))
          return {
            changes: {
              insert: e + e,
              from: l
            },
            effects: Ls.of(l + e.length),
            range: q.cursor(l + e.length)
          };
        if (WR(t, l)) {
          let p = n && t.sliceDoc(l, l + e.length * 3) == e + e + e ? e + e + e : e;
          return {
            changes: {
              from: l,
              to: l + p.length,
              insert: p
            },
            range: q.cursor(l + p.length)
          };
        }
      } else {
        if (n && t.sliceDoc(l - 2 * e.length, l) == e + e && (u = KT(t, l - 2 * e.length, i)) > -1 && UT(t, u))
          return {
            changes: {
              insert: e + e + e + e,
              from: l
            },
            effects: Ls.of(l + e.length),
            range: q.cursor(l + e.length)
          };
        if (t.charCategorizer(l)(c) != ft.Word && KT(t, l, i) > -1 && !gX(t, l, e, i))
          return {
            changes: {
              insert: e + e,
              from: l
            },
            effects: Ls.of(l + e.length),
            range: q.cursor(l + e.length)
          };
      }
      return {
        range: o = a
      };
    });
    return o ? null : t.update(s, {
      scrollIntoView: true,
      userEvent: "input.type"
    });
  }
  function UT(t, e) {
    let n = pn(t).resolveInner(e + 1);
    return n.parent && n.from == e;
  }
  function gX(t, e, n, r) {
    let i = pn(t).resolveInner(e, -1), o = r.reduce((s, a) => Math.max(s, a.length), 0);
    for (let s = 0; s < 5; s++) {
      let a = t.sliceDoc(i.from, Math.min(i.to, i.from + n.length + o)), l = a.indexOf(n);
      if (!l || l > -1 && r.indexOf(a.slice(0, l)) > -1) {
        let u = i.firstChild;
        for (; u && u.from == i.from && u.to - u.from > n.length + l; ) {
          if (t.sliceDoc(u.to - n.length, u.to) == n)
            return false;
          u = u.firstChild;
        }
        return true;
      }
      let c = i.to == e && i.parent;
      if (!c)
        break;
      i = c;
    }
    return false;
  }
  function KT(t, e, n) {
    let r = t.charCategorizer(e);
    if (r(t.sliceDoc(e - 1, e)) != ft.Word)
      return e;
    for (let i of n) {
      let o = e - i.length;
      if (t.sliceDoc(o, e) == i && r(t.sliceDoc(o - 1, o)) != ft.Word)
        return o;
    }
    return -1;
  }
  function vX(t = {}) {
    return [
      iX,
      Ln,
      Wt.of(t),
      nX,
      yX,
      oX
    ];
  }
  const HR = [
    {
      key: "Ctrl-Space",
      run: iv
    },
    {
      mac: "Alt-`",
      run: iv
    },
    {
      mac: "Alt-i",
      run: iv
    },
    {
      key: "Escape",
      run: JY
    },
    {
      key: "ArrowDown",
      run: Vh(true)
    },
    {
      key: "ArrowUp",
      run: Vh(false)
    },
    {
      key: "PageDown",
      run: Vh(true, "page")
    },
    {
      key: "PageUp",
      run: Vh(false, "page")
    },
    {
      key: "Enter",
      run: QY
    }
  ], yX = ns.highest(Hm.computeN([
    Wt
  ], (t) => t.facet(Wt).defaultKeymap ? [
    HR
  ] : []));
  class qT {
    constructor(e, n, r) {
      this.from = e, this.to = n, this.diagnostic = r;
    }
  }
  class ks {
    constructor(e, n, r) {
      this.diagnostics = e, this.panel = n, this.selected = r;
    }
    static init(e, n, r) {
      let i = r.facet(Uu).markerFilter;
      i && (e = i(e, r));
      let o = e.slice().sort((v, y) => v.from - y.from || v.to - y.to), s = new Ai(), a = [], l = 0, c = r.doc.iter(), u = 0, h = r.doc.length;
      for (let v = 0; ; ) {
        let y = v == o.length ? null : o[v];
        if (!y && !a.length)
          break;
        let S, T;
        if (a.length)
          S = l, T = a.reduce((C, O) => Math.min(C, O.to), y && y.from > S ? y.from : 1e8);
        else {
          if (S = y.from, S > h)
            break;
          T = y.to, a.push(y), v++;
        }
        for (; v < o.length; ) {
          let C = o[v];
          if (C.from == S && (C.to > C.from || C.to == S))
            a.push(C), v++, T = Math.min(C.to, T);
          else {
            T = Math.min(C.from, T);
            break;
          }
        }
        T = Math.min(T, h);
        let w = false;
        if (a.some((C) => C.from == S && (C.to == T || T == h)) && (w = S == T, !w && T - S < 10)) {
          let C = S - (u + c.value.length);
          C > 0 && (c.next(C), u = S);
          for (let O = S; ; ) {
            if (O >= T) {
              w = true;
              break;
            }
            if (!c.lineBreak && u + c.value.length > O)
              break;
            O = u + c.value.length, u += c.value.length, c.next();
          }
        }
        let k = LX(a);
        if (w)
          s.add(S, S, be.widget({
            widget: new AX(k),
            diagnostics: a.slice()
          }));
        else {
          let C = a.reduce((O, L) => L.markClass ? O + " " + L.markClass : O, "");
          s.add(S, T, be.mark({
            class: "cm-lintRange cm-lintRange-" + k + C,
            diagnostics: a.slice(),
            inclusiveEnd: a.some((O) => O.to > T)
          }));
        }
        if (l = T, l == h)
          break;
        for (let C = 0; C < a.length; C++)
          a[C].to <= l && a.splice(C--, 1);
      }
      let p = s.finish();
      return new ks(p, n, Jo(p));
    }
  }
  function Jo(t, e = null, n = 0) {
    let r = null;
    return t.between(n, 1e9, (i, o, { spec: s }) => {
      if (!(e && s.diagnostics.indexOf(e) < 0))
        if (!r)
          r = new qT(i, o, e || s.diagnostics[0]);
        else {
          if (s.diagnostics.indexOf(r.diagnostic) < 0)
            return false;
          r = new qT(r.from, o, r.diagnostic);
        }
    }), r;
  }
  function bX(t, e) {
    let n = e.pos, r = e.end || n, i = t.state.facet(Uu).hideOn(t, n, r);
    if (i != null)
      return i;
    let o = t.startState.doc.lineAt(e.pos);
    return !!(t.effects.some((s) => s.is(jR)) || t.changes.touchesRange(o.from, Math.max(o.to, r)));
  }
  function xX(t, e) {
    return t.field(Kn, false) ? e : e.concat(Ee.appendConfig.of(RX));
  }
  const jR = Ee.define(), pS = Ee.define(), UR = Ee.define(), Kn = Kt.define({
    create() {
      return new ks(be.none, null, null);
    },
    update(t, e) {
      if (e.docChanged && t.diagnostics.size) {
        let n = t.diagnostics.map(e.changes), r = null, i = t.panel;
        if (t.selected) {
          let o = e.changes.mapPos(t.selected.from, 1);
          r = Jo(n, t.selected.diagnostic, o) || Jo(n, null, o);
        }
        !n.size && i && e.state.facet(Uu).autoPanel && (i = null), t = new ks(n, i, r);
      }
      for (let n of e.effects)
        if (n.is(jR)) {
          let r = e.state.facet(Uu).autoPanel ? n.value.length ? Ku.open : null : t.panel;
          t = ks.init(n.value, r, e.state);
        } else
          n.is(pS) ? t = new ks(t.diagnostics, n.value ? Ku.open : null, t.selected) : n.is(UR) && (t = new ks(t.diagnostics, t.panel, n.value));
      return t;
    },
    provide: (t) => [
      Gs.from(t, (e) => e.panel),
      ue.decorations.from(t, (e) => e.diagnostics)
    ]
  }), SX = be.mark({
    class: "cm-lintRange cm-lintRange-active"
  });
  function wX(t, e, n) {
    let { diagnostics: r } = t.state.field(Kn), i, o = -1, s = -1;
    r.between(e - (n < 0 ? 1 : 0), e + (n > 0 ? 1 : 0), (l, c, { spec: u }) => {
      if (e >= l && e <= c && (l == c || (e > l || n > 0) && (e < c || n < 0)))
        return i = u.diagnostics, o = l, s = c, false;
    });
    let a = t.state.facet(Uu).tooltipFilter;
    return i && a && (i = a(i, t.state)), i ? {
      pos: o,
      end: s,
      above: t.state.doc.lineAt(o).to < s,
      create() {
        return {
          dom: kX(t, i)
        };
      }
    } : null;
  }
  function kX(t, e) {
    return Qe("ul", {
      class: "cm-tooltip-lint"
    }, e.map((n) => qR(t, n, false)));
  }
  const CX = (t) => {
    let e = t.state.field(Kn, false);
    (!e || !e.panel) && t.dispatch({
      effects: xX(t.state, [
        pS.of(true)
      ])
    });
    let n = jx(t, Ku.open);
    return n && n.dom.querySelector(".cm-panel-lint ul").focus(), true;
  }, GT = (t) => {
    let e = t.state.field(Kn, false);
    return !e || !e.panel ? false : (t.dispatch({
      effects: pS.of(false)
    }), true);
  }, TX = (t) => {
    let e = t.state.field(Kn, false);
    if (!e)
      return false;
    let n = t.state.selection.main, r = Jo(e.diagnostics, null, n.to + 1);
    return !r && (r = Jo(e.diagnostics, null, 0), !r || r.from == n.from && r.to == n.to) ? false : (t.dispatch({
      selection: {
        anchor: r.from,
        head: r.to
      },
      scrollIntoView: true
    }), true);
  }, MX = [
    {
      key: "Mod-Shift-m",
      run: CX,
      preventDefault: true
    },
    {
      key: "F8",
      run: TX
    }
  ], Uu = me.define({
    combine(t) {
      return {
        sources: t.map((e) => e.source).filter((e) => e != null),
        ...Oi(t.map((e) => e.config), {
          delay: 750,
          markerFilter: null,
          tooltipFilter: null,
          needsRefresh: null,
          hideOn: () => null
        }, {
          delay: Math.max,
          markerFilter: YT,
          tooltipFilter: YT,
          needsRefresh: (e, n) => e ? n ? (r) => e(r) || n(r) : e : n,
          hideOn: (e, n) => e ? n ? (r, i, o) => e(r, i, o) || n(r, i, o) : e : n,
          autoPanel: (e, n) => e || n
        })
      };
    }
  });
  function YT(t, e) {
    return t ? e ? (n, r) => e(t(n, r), r) : t : e;
  }
  function KR(t) {
    let e = [];
    if (t)
      e:
        for (let { name: n } of t) {
          for (let r = 0; r < n.length; r++) {
            let i = n[r];
            if (/[a-zA-Z]/.test(i) && !e.some((o) => o.toLowerCase() == i.toLowerCase())) {
              e.push(i);
              continue e;
            }
          }
          e.push("");
        }
    return e;
  }
  function qR(t, e, n) {
    var r;
    let i = n ? KR(e.actions) : [];
    return Qe("li", {
      class: "cm-diagnostic cm-diagnostic-" + e.severity
    }, Qe("span", {
      class: "cm-diagnosticText"
    }, e.renderMessage ? e.renderMessage(t) : e.message), (r = e.actions) === null || r === void 0 ? void 0 : r.map((o, s) => {
      let a = false, l = (v) => {
        if (v.preventDefault(), a)
          return;
        a = true;
        let y = Jo(t.state.field(Kn).diagnostics, e);
        y && o.apply(t, y.from, y.to);
      }, { name: c } = o, u = i[s] ? c.indexOf(i[s]) : -1, h = u < 0 ? c : [
        c.slice(0, u),
        Qe("u", c.slice(u, u + 1)),
        c.slice(u + 1)
      ], p = o.markClass ? " " + o.markClass : "";
      return Qe("button", {
        type: "button",
        class: "cm-diagnosticAction" + p,
        onclick: l,
        onmousedown: l,
        "aria-label": ` Action: ${c}${u < 0 ? "" : ` (access key "${i[s]})"`}.`
      }, h);
    }), e.source && Qe("div", {
      class: "cm-diagnosticSource"
    }, e.source));
  }
  class AX extends Li {
    constructor(e) {
      super(), this.sev = e;
    }
    eq(e) {
      return e.sev == this.sev;
    }
    toDOM() {
      return Qe("span", {
        class: "cm-lintPoint cm-lintPoint-" + this.sev
      });
    }
  }
  class XT {
    constructor(e, n) {
      this.diagnostic = n, this.id = "item_" + Math.floor(Math.random() * 4294967295).toString(16), this.dom = qR(e, n, true), this.dom.id = this.id, this.dom.setAttribute("role", "option");
    }
  }
  class Ku {
    constructor(e) {
      this.view = e, this.items = [];
      let n = (i) => {
        if (!(i.ctrlKey || i.altKey || i.metaKey)) {
          if (i.keyCode == 27)
            GT(this.view), this.view.focus();
          else if (i.keyCode == 38 || i.keyCode == 33)
            this.moveSelection((this.selectedIndex - 1 + this.items.length) % this.items.length);
          else if (i.keyCode == 40 || i.keyCode == 34)
            this.moveSelection((this.selectedIndex + 1) % this.items.length);
          else if (i.keyCode == 36)
            this.moveSelection(0);
          else if (i.keyCode == 35)
            this.moveSelection(this.items.length - 1);
          else if (i.keyCode == 13)
            this.view.focus();
          else if (i.keyCode >= 65 && i.keyCode <= 90 && this.selectedIndex >= 0) {
            let { diagnostic: o } = this.items[this.selectedIndex], s = KR(o.actions);
            for (let a = 0; a < s.length; a++)
              if (s[a].toUpperCase().charCodeAt(0) == i.keyCode) {
                let l = Jo(this.view.state.field(Kn).diagnostics, o);
                l && o.actions[a].apply(e, l.from, l.to);
              }
          } else
            return;
          i.preventDefault();
        }
      }, r = (i) => {
        for (let o = 0; o < this.items.length; o++)
          this.items[o].dom.contains(i.target) && this.moveSelection(o);
      };
      this.list = Qe("ul", {
        tabIndex: 0,
        role: "listbox",
        "aria-label": this.view.state.phrase("Diagnostics"),
        onkeydown: n,
        onclick: r
      }), this.dom = Qe("div", {
        class: "cm-panel-lint"
      }, this.list, Qe("button", {
        type: "button",
        name: "close",
        "aria-label": this.view.state.phrase("close"),
        onclick: () => GT(this.view)
      }, "\xD7")), this.update();
    }
    get selectedIndex() {
      let e = this.view.state.field(Kn).selected;
      if (!e)
        return -1;
      for (let n = 0; n < this.items.length; n++)
        if (this.items[n].diagnostic == e.diagnostic)
          return n;
      return -1;
    }
    update() {
      let { diagnostics: e, selected: n } = this.view.state.field(Kn), r = 0, i = false, o = null, s = /* @__PURE__ */ new Set();
      for (e.between(0, this.view.state.doc.length, (a, l, { spec: c }) => {
        for (let u of c.diagnostics) {
          if (s.has(u))
            continue;
          s.add(u);
          let h = -1, p;
          for (let v = r; v < this.items.length; v++)
            if (this.items[v].diagnostic == u) {
              h = v;
              break;
            }
          h < 0 ? (p = new XT(this.view, u), this.items.splice(r, 0, p), i = true) : (p = this.items[h], h > r && (this.items.splice(r, h - r), i = true)), n && p.diagnostic == n.diagnostic ? p.dom.hasAttribute("aria-selected") || (p.dom.setAttribute("aria-selected", "true"), o = p) : p.dom.hasAttribute("aria-selected") && p.dom.removeAttribute("aria-selected"), r++;
        }
      }); r < this.items.length && !(this.items.length == 1 && this.items[0].diagnostic.from < 0); )
        i = true, this.items.pop();
      this.items.length == 0 && (this.items.push(new XT(this.view, {
        from: -1,
        to: -1,
        severity: "info",
        message: this.view.state.phrase("No diagnostics")
      })), i = true), o ? (this.list.setAttribute("aria-activedescendant", o.id), this.view.requestMeasure({
        key: this,
        read: () => ({
          sel: o.dom.getBoundingClientRect(),
          panel: this.list.getBoundingClientRect()
        }),
        write: ({ sel: a, panel: l }) => {
          let c = l.height / this.list.offsetHeight;
          a.top < l.top ? this.list.scrollTop -= (l.top - a.top) / c : a.bottom > l.bottom && (this.list.scrollTop += (a.bottom - l.bottom) / c);
        }
      })) : this.selectedIndex < 0 && this.list.removeAttribute("aria-activedescendant"), i && this.sync();
    }
    sync() {
      let e = this.list.firstChild;
      function n() {
        let r = e;
        e = r.nextSibling, r.remove();
      }
      for (let r of this.items)
        if (r.dom.parentNode == this.list) {
          for (; e != r.dom; )
            n();
          e = r.dom.nextSibling;
        } else
          this.list.insertBefore(r.dom, e);
      for (; e; )
        n();
    }
    moveSelection(e) {
      if (this.selectedIndex < 0)
        return;
      let n = this.view.state.field(Kn), r = Jo(n.diagnostics, this.items[e].diagnostic);
      !r || this.view.dispatch({
        selection: {
          anchor: r.from,
          head: r.to
        },
        scrollIntoView: true,
        effects: UR.of(r)
      });
    }
    static open(e) {
      return new Ku(e);
    }
  }
  function EX(t, e = 'viewBox="0 0 40 40"') {
    return `url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" ${e}>${encodeURIComponent(t)}</svg>')`;
  }
  function Wh(t) {
    return EX(`<path d="m0 2.5 l2 -1.5 l1 0 l2 1.5 l1 0" stroke="${t}" fill="none" stroke-width=".7"/>`, 'width="6" height="3"');
  }
  const PX = ue.baseTheme({
    ".cm-diagnostic": {
      padding: "3px 6px 3px 8px",
      marginLeft: "-1px",
      display: "block",
      whiteSpace: "pre-wrap"
    },
    ".cm-diagnostic-error": {
      borderLeft: "5px solid #d11"
    },
    ".cm-diagnostic-warning": {
      borderLeft: "5px solid orange"
    },
    ".cm-diagnostic-info": {
      borderLeft: "5px solid #999"
    },
    ".cm-diagnostic-hint": {
      borderLeft: "5px solid #66d"
    },
    ".cm-diagnosticAction": {
      font: "inherit",
      border: "none",
      padding: "2px 4px",
      backgroundColor: "#444",
      color: "white",
      borderRadius: "3px",
      marginLeft: "8px",
      cursor: "pointer"
    },
    ".cm-diagnosticSource": {
      fontSize: "70%",
      opacity: 0.7
    },
    ".cm-lintRange": {
      backgroundPosition: "left bottom",
      backgroundRepeat: "repeat-x",
      paddingBottom: "0.7px"
    },
    ".cm-lintRange-error": {
      backgroundImage: Wh("#d11")
    },
    ".cm-lintRange-warning": {
      backgroundImage: Wh("orange")
    },
    ".cm-lintRange-info": {
      backgroundImage: Wh("#999")
    },
    ".cm-lintRange-hint": {
      backgroundImage: Wh("#66d")
    },
    ".cm-lintRange-active": {
      backgroundColor: "#ffdd9980"
    },
    ".cm-tooltip-lint": {
      padding: 0,
      margin: 0
    },
    ".cm-lintPoint": {
      position: "relative",
      "&:after": {
        content: '""',
        position: "absolute",
        bottom: 0,
        left: "-2px",
        borderLeft: "3px solid transparent",
        borderRight: "3px solid transparent",
        borderBottom: "4px solid #d11"
      }
    },
    ".cm-lintPoint-warning": {
      "&:after": {
        borderBottomColor: "orange"
      }
    },
    ".cm-lintPoint-info": {
      "&:after": {
        borderBottomColor: "#999"
      }
    },
    ".cm-lintPoint-hint": {
      "&:after": {
        borderBottomColor: "#66d"
      }
    },
    ".cm-panel.cm-panel-lint": {
      position: "relative",
      "& ul": {
        maxHeight: "100px",
        overflowY: "auto",
        "& [aria-selected]": {
          backgroundColor: "#ddd",
          "& u": {
            textDecoration: "underline"
          }
        },
        "&:focus [aria-selected]": {
          background_fallback: "#bdf",
          backgroundColor: "Highlight",
          color_fallback: "white",
          color: "HighlightText"
        },
        "& u": {
          textDecoration: "none"
        },
        padding: 0,
        margin: 0
      },
      "& [name=close]": {
        position: "absolute",
        top: "0",
        right: "2px",
        background: "inherit",
        border: "none",
        font: "inherit",
        padding: 0,
        margin: 0
      }
    }
  });
  function OX(t) {
    return t == "error" ? 4 : t == "warning" ? 3 : t == "info" ? 2 : 1;
  }
  function LX(t) {
    let e = "hint", n = 1;
    for (let r of t) {
      let i = OX(r.severity);
      i > n && (n = i, e = r.severity);
    }
    return e;
  }
  const RX = [
    Kn,
    ue.decorations.compute([
      Kn
    ], (t) => {
      let { selected: e, panel: n } = t.field(Kn);
      return !e || !n || e.from == e.to ? be.none : be.set([
        SX.range(e.from, e.to)
      ]);
    }),
    wK(wX, {
      hideOn: bX
    }),
    PX
  ];
  var QT = function(e) {
    e === void 0 && (e = {});
    var { crosshairCursor: n = false } = e, r = [];
    e.closeBracketsKeymap !== false && (r = r.concat(uX)), e.defaultKeymap !== false && (r = r.concat(rY)), e.searchKeymap !== false && (r = r.concat(PY)), e.historyKeymap !== false && (r = r.concat(hG)), e.foldKeymap !== false && (r = r.concat(Tq)), e.completionKeymap !== false && (r = r.concat(HR)), e.lintKeymap !== false && (r = r.concat(MX));
    var i = [];
    return e.lineNumbers !== false && i.push(IK()), e.highlightActiveLineGutter !== false && i.push($K()), e.highlightSpecialChars !== false && i.push(QU()), e.history !== false && i.push(rG()), e.foldGutter !== false && i.push(Pq()), e.drawSelection !== false && i.push(zU()), e.dropCursor !== false && i.push(UU()), e.allowMultipleSelections !== false && i.push($e.allowMultipleSelections.of(true)), e.indentOnInput !== false && i.push(gq()), e.syntaxHighlighting !== false && i.push(UL(_q, {
      fallback: true
    })), e.bracketMatching !== false && i.push(Fq()), e.closeBrackets !== false && i.push(sX()), e.autocompletion !== false && i.push(vX()), e.rectangularSelection !== false && i.push(fK()), n !== false && i.push(pK()), e.highlightActiveLine !== false && i.push(rK()), e.highlightSelectionMatches !== false && i.push(lY()), e.tabSize && typeof e.tabSize == "number" && i.push(xl.of(" ".repeat(e.tabSize))), i.concat([
      Hm.of(r.flat())
    ]).filter(Boolean);
  };
  const _X = "#e5c07b", JT = "#e06c75", DX = "#56b6c2", IX = "#ffffff", Md = "#abb2bf", L1 = "#7d8799", BX = "#61afef", NX = "#98c379", ZT = "#d19a66", $X = "#c678dd", zX = "#21252b", eM = "#2c313a", tM = "#282c34", sv = "#353a42", FX = "#3E4451", nM = "#528bff", VX = ue.theme({
    "&": {
      color: Md,
      backgroundColor: tM
    },
    ".cm-content": {
      caretColor: nM
    },
    ".cm-cursor, .cm-dropCursor": {
      borderLeftColor: nM
    },
    "&.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground, .cm-selectionBackground, .cm-content ::selection": {
      backgroundColor: FX
    },
    ".cm-panels": {
      backgroundColor: zX,
      color: Md
    },
    ".cm-panels.cm-panels-top": {
      borderBottom: "2px solid black"
    },
    ".cm-panels.cm-panels-bottom": {
      borderTop: "2px solid black"
    },
    ".cm-searchMatch": {
      backgroundColor: "#72a1ff59",
      outline: "1px solid #457dff"
    },
    ".cm-searchMatch.cm-searchMatch-selected": {
      backgroundColor: "#6199ff2f"
    },
    ".cm-activeLine": {
      backgroundColor: "#6699ff0b"
    },
    ".cm-selectionMatch": {
      backgroundColor: "#aafe661a"
    },
    "&.cm-focused .cm-matchingBracket, &.cm-focused .cm-nonmatchingBracket": {
      backgroundColor: "#bad0f847"
    },
    ".cm-gutters": {
      backgroundColor: tM,
      color: L1,
      border: "none"
    },
    ".cm-activeLineGutter": {
      backgroundColor: eM
    },
    ".cm-foldPlaceholder": {
      backgroundColor: "transparent",
      border: "none",
      color: "#ddd"
    },
    ".cm-tooltip": {
      border: "none",
      backgroundColor: sv
    },
    ".cm-tooltip .cm-tooltip-arrow:before": {
      borderTopColor: "transparent",
      borderBottomColor: "transparent"
    },
    ".cm-tooltip .cm-tooltip-arrow:after": {
      borderTopColor: sv,
      borderBottomColor: sv
    },
    ".cm-tooltip-autocomplete": {
      "& > ul > li[aria-selected]": {
        backgroundColor: eM,
        color: Md
      }
    }
  }, {
    dark: true
  }), WX = hf.define([
    {
      tag: G.keyword,
      color: $X
    },
    {
      tag: [
        G.name,
        G.deleted,
        G.character,
        G.propertyName,
        G.macroName
      ],
      color: JT
    },
    {
      tag: [
        G.function(G.variableName),
        G.labelName
      ],
      color: BX
    },
    {
      tag: [
        G.color,
        G.constant(G.name),
        G.standard(G.name)
      ],
      color: ZT
    },
    {
      tag: [
        G.definition(G.name),
        G.separator
      ],
      color: Md
    },
    {
      tag: [
        G.typeName,
        G.className,
        G.number,
        G.changed,
        G.annotation,
        G.modifier,
        G.self,
        G.namespace
      ],
      color: _X
    },
    {
      tag: [
        G.operator,
        G.operatorKeyword,
        G.url,
        G.escape,
        G.regexp,
        G.link,
        G.special(G.string)
      ],
      color: DX
    },
    {
      tag: [
        G.meta,
        G.comment
      ],
      color: L1
    },
    {
      tag: G.strong,
      fontWeight: "bold"
    },
    {
      tag: G.emphasis,
      fontStyle: "italic"
    },
    {
      tag: G.strikethrough,
      textDecoration: "line-through"
    },
    {
      tag: G.link,
      color: L1,
      textDecoration: "underline"
    },
    {
      tag: G.heading,
      fontWeight: "bold",
      color: JT
    },
    {
      tag: [
        G.atom,
        G.bool,
        G.special(G.variableName)
      ],
      color: ZT
    },
    {
      tag: [
        G.processingInstruction,
        G.string,
        G.inserted
      ],
      color: NX
    },
    {
      tag: G.invalid,
      color: IX
    }
  ]), HX = [
    VX,
    UL(WX)
  ];
  var jX = ue.theme({
    "&": {
      backgroundColor: "#fff"
    }
  }, {
    dark: false
  }), UX = function(e) {
    e === void 0 && (e = {});
    var { indentWithTab: n = true, editable: r = true, readOnly: i = false, theme: o = "light", placeholder: s = "", basicSetup: a = true } = e, l = [];
    switch (n && l.unshift(Hm.of([
      iY
    ])), a && (typeof a == "boolean" ? l.unshift(QT()) : l.unshift(QT(a))), s && l.unshift(aK(s)), o) {
      case "light":
        l.push(jX);
        break;
      case "dark":
        l.push(HX);
        break;
      case "none":
        break;
      default:
        l.push(o);
        break;
    }
    return r === false && l.push(ue.editable.of(false)), i && l.push($e.readOnly.of(true)), [
      ...l
    ];
  }, KX = (t) => ({
    line: t.state.doc.lineAt(t.state.selection.main.from),
    lineCount: t.state.doc.lines,
    lineBreak: t.state.lineBreak,
    length: t.state.doc.length,
    readOnly: t.state.readOnly,
    tabSize: t.state.tabSize,
    selection: t.state.selection,
    selectionAsSingle: t.state.selection.asSingle().main,
    ranges: t.state.selection.ranges,
    selectionCode: t.state.sliceDoc(t.state.selection.main.from, t.state.selection.main.to),
    selections: t.state.selection.ranges.map((e) => t.state.sliceDoc(e.from, e.to)),
    selectedText: t.state.selection.ranges.some((e) => !e.empty)
  });
  class qX {
    constructor(e, n) {
      this.timeLeftMS = void 0, this.timeoutMS = void 0, this.isCancelled = false, this.isTimeExhausted = false, this.callbacks = [], this.timeLeftMS = n, this.timeoutMS = n, this.callbacks.push(e);
    }
    tick() {
      if (!this.isCancelled && !this.isTimeExhausted && (this.timeLeftMS--, this.timeLeftMS <= 0)) {
        this.isTimeExhausted = true;
        var e = this.callbacks.slice();
        this.callbacks.length = 0, e.forEach((n) => {
          try {
            n();
          } catch (r) {
            console.error("TimeoutLatch callback error:", r);
          }
        });
      }
    }
    cancel() {
      this.isCancelled = true, this.callbacks.length = 0;
    }
    reset() {
      this.timeLeftMS = this.timeoutMS, this.isCancelled = false, this.isTimeExhausted = false;
    }
    get isDone() {
      return this.isCancelled || this.isTimeExhausted;
    }
  }
  class rM {
    constructor() {
      this.interval = null, this.latches = /* @__PURE__ */ new Set();
    }
    add(e) {
      this.latches.add(e), this.start();
    }
    remove(e) {
      this.latches.delete(e), this.latches.size === 0 && this.stop();
    }
    start() {
      this.interval === null && (this.interval = setInterval(() => {
        this.latches.forEach((e) => {
          e.tick(), e.isDone && this.remove(e);
        });
      }, 1));
    }
    stop() {
      this.interval !== null && (clearInterval(this.interval), this.interval = null);
    }
  }
  var av = null, GX = () => typeof window > "u" ? new rM() : (av || (av = new rM()), av), iM = Pi.define(), YX = 200, XX = [];
  function QX(t) {
    var { value: e, selection: n, onChange: r, onStatistics: i, onCreateEditor: o, onUpdate: s, extensions: a = XX, autoFocus: l, theme: c = "light", height: u = null, minHeight: h = null, maxHeight: p = null, width: v = null, minWidth: y = null, maxWidth: S = null, placeholder: T = "", editable: w = true, readOnly: k = false, indentWithTab: C = true, basicSetup: O = true, root: L, initialState: D } = t, [R, F] = z.exports.useState(), [K, Y] = z.exports.useState(), [te, ne] = z.exports.useState(), ae = z.exports.useState(() => ({
      current: null
    }))[0], ye = z.exports.useState(() => ({
      current: null
    }))[0], Ce = ue.theme({
      "&": {
        height: u,
        minHeight: h,
        maxHeight: p,
        width: v,
        minWidth: y,
        maxWidth: S
      },
      "& .cm-scroller": {
        height: "100% !important"
      }
    }), Le = ue.updateListener.of((oe) => {
      if (oe.docChanged && typeof r == "function" && !oe.transactions.some((ve) => ve.annotation(iM))) {
        ae.current ? ae.current.reset() : (ae.current = new qX(() => {
          if (ye.current) {
            var ve = ye.current;
            ye.current = null, ve();
          }
          ae.current = null;
        }, YX), GX().add(ae.current));
        var he = oe.state.doc, Se = he.toString();
        r(Se, oe);
      }
      i && i(KX(oe));
    }), ee = UX({
      theme: c,
      editable: w,
      readOnly: k,
      placeholder: T,
      indentWithTab: C,
      basicSetup: O
    }), V = [
      Le,
      Ce,
      ...ee
    ];
    return s && typeof s == "function" && V.push(ue.updateListener.of(s)), V = V.concat(a), z.exports.useLayoutEffect(() => {
      if (R && !te) {
        var oe = {
          doc: e,
          selection: n,
          extensions: V
        }, he = D ? $e.fromJSON(D.json, oe, D.fields) : $e.create(oe);
        if (ne(he), !K) {
          var Se = new ue({
            state: he,
            parent: R,
            root: L
          });
          Y(Se), o && o(Se, he);
        }
      }
      return () => {
        K && (ne(void 0), Y(void 0));
      };
    }, [
      R,
      te
    ]), z.exports.useEffect(() => {
      t.container && F(t.container);
    }, [
      t.container
    ]), z.exports.useEffect(() => () => {
      K && (K.destroy(), Y(void 0)), ae.current && (ae.current.cancel(), ae.current = null);
    }, [
      K
    ]), z.exports.useEffect(() => {
      l && K && K.focus();
    }, [
      l,
      K
    ]), z.exports.useEffect(() => {
      K && K.dispatch({
        effects: Ee.reconfigure.of(V)
      });
    }, [
      c,
      a,
      u,
      h,
      p,
      v,
      y,
      S,
      T,
      w,
      k,
      C,
      O,
      r,
      s
    ]), z.exports.useEffect(() => {
      if (e !== void 0) {
        var oe = K ? K.state.doc.toString() : "";
        if (K && e !== oe) {
          var he = ae.current && !ae.current.isDone, Se = () => {
            K && e !== K.state.doc.toString() && K.dispatch({
              changes: {
                from: 0,
                to: K.state.doc.toString().length,
                insert: e || ""
              },
              annotations: [
                iM.of(true)
              ]
            });
          };
          he ? ye.current = Se : Se();
        }
      }
    }, [
      e,
      K
    ]), {
      state: te,
      setState: ne,
      view: K,
      setView: Y,
      container: R,
      setContainer: F
    };
  }
  var JX = [
    "className",
    "value",
    "selection",
    "extensions",
    "onChange",
    "onStatistics",
    "onCreateEditor",
    "onUpdate",
    "autoFocus",
    "theme",
    "height",
    "minHeight",
    "maxHeight",
    "width",
    "minWidth",
    "maxWidth",
    "basicSetup",
    "placeholder",
    "indentWithTab",
    "editable",
    "readOnly",
    "root",
    "initialState"
  ], GR = z.exports.forwardRef((t, e) => {
    var { className: n, value: r = "", selection: i, extensions: o = [], onChange: s, onStatistics: a, onCreateEditor: l, onUpdate: c, autoFocus: u, theme: h = "light", height: p, minHeight: v, maxHeight: y, width: S, minWidth: T, maxWidth: w, basicSetup: k, placeholder: C, indentWithTab: O, editable: L, readOnly: D, root: R, initialState: F } = t, K = hj(t, JX), Y = z.exports.useRef(null), { state: te, view: ne, container: ae, setContainer: ye } = QX({
      root: R,
      value: r,
      autoFocus: u,
      theme: h,
      height: p,
      minHeight: v,
      maxHeight: y,
      width: S,
      minWidth: T,
      maxWidth: w,
      basicSetup: k,
      placeholder: C,
      indentWithTab: O,
      editable: L,
      readOnly: D,
      selection: i,
      onChange: s,
      onStatistics: a,
      onCreateEditor: l,
      onUpdate: c,
      extensions: o,
      initialState: F
    });
    z.exports.useImperativeHandle(e, () => ({
      editor: Y.current,
      state: te,
      view: ne
    }), [
      Y,
      ae,
      te,
      ne
    ]);
    var Ce = z.exports.useCallback((ee) => {
      Y.current = ee, ye(ee);
    }, [
      ye
    ]);
    if (typeof r != "string")
      throw new Error("value must be typeof string but got " + typeof r);
    var Le = typeof h == "string" ? "cm-theme-" + h : "cm-theme";
    return J("div", Cu({
      ref: Ce,
      className: "" + Le + (n ? " " + n : "")
    }, K));
  });
  GR.displayName = "CodeMirror";
  function ZX(t) {
    var e = t.Pos;
    function n(f, d, m) {
      if (d.line === m.line && d.ch >= m.ch - 1) {
        var g = f.getLine(d.line), b = g.charCodeAt(d.ch);
        55296 <= b && b <= 55551 && (m.ch += 1);
      }
      return {
        start: d,
        end: m
      };
    }
    var r = [
      {
        keys: "<Left>",
        type: "keyToKey",
        toKeys: "h"
      },
      {
        keys: "<Right>",
        type: "keyToKey",
        toKeys: "l"
      },
      {
        keys: "<Up>",
        type: "keyToKey",
        toKeys: "k"
      },
      {
        keys: "<Down>",
        type: "keyToKey",
        toKeys: "j"
      },
      {
        keys: "g<Up>",
        type: "keyToKey",
        toKeys: "gk"
      },
      {
        keys: "g<Down>",
        type: "keyToKey",
        toKeys: "gj"
      },
      {
        keys: "<Space>",
        type: "keyToKey",
        toKeys: "l"
      },
      {
        keys: "<BS>",
        type: "keyToKey",
        toKeys: "h"
      },
      {
        keys: "<Del>",
        type: "keyToKey",
        toKeys: "x"
      },
      {
        keys: "<C-Space>",
        type: "keyToKey",
        toKeys: "W"
      },
      {
        keys: "<C-BS>",
        type: "keyToKey",
        toKeys: "B"
      },
      {
        keys: "<S-Space>",
        type: "keyToKey",
        toKeys: "w"
      },
      {
        keys: "<S-BS>",
        type: "keyToKey",
        toKeys: "b"
      },
      {
        keys: "<C-n>",
        type: "keyToKey",
        toKeys: "j"
      },
      {
        keys: "<C-p>",
        type: "keyToKey",
        toKeys: "k"
      },
      {
        keys: "<C-[>",
        type: "keyToKey",
        toKeys: "<Esc>"
      },
      {
        keys: "<C-c>",
        type: "keyToKey",
        toKeys: "<Esc>"
      },
      {
        keys: "<C-[>",
        type: "keyToKey",
        toKeys: "<Esc>",
        context: "insert"
      },
      {
        keys: "<C-c>",
        type: "keyToKey",
        toKeys: "<Esc>",
        context: "insert"
      },
      {
        keys: "<C-Esc>",
        type: "keyToKey",
        toKeys: "<Esc>"
      },
      {
        keys: "<C-Esc>",
        type: "keyToKey",
        toKeys: "<Esc>",
        context: "insert"
      },
      {
        keys: "s",
        type: "keyToKey",
        toKeys: "cl",
        context: "normal"
      },
      {
        keys: "s",
        type: "keyToKey",
        toKeys: "c",
        context: "visual"
      },
      {
        keys: "S",
        type: "keyToKey",
        toKeys: "cc",
        context: "normal"
      },
      {
        keys: "S",
        type: "keyToKey",
        toKeys: "VdO",
        context: "visual"
      },
      {
        keys: "<Home>",
        type: "keyToKey",
        toKeys: "0"
      },
      {
        keys: "<End>",
        type: "keyToKey",
        toKeys: "$"
      },
      {
        keys: "<PageUp>",
        type: "keyToKey",
        toKeys: "<C-b>"
      },
      {
        keys: "<PageDown>",
        type: "keyToKey",
        toKeys: "<C-f>"
      },
      {
        keys: "<CR>",
        type: "keyToKey",
        toKeys: "j^",
        context: "normal"
      },
      {
        keys: "<Ins>",
        type: "keyToKey",
        toKeys: "i",
        context: "normal"
      },
      {
        keys: "<Ins>",
        type: "action",
        action: "toggleOverwrite",
        context: "insert"
      },
      {
        keys: "H",
        type: "motion",
        motion: "moveToTopLine",
        motionArgs: {
          linewise: true,
          toJumplist: true
        }
      },
      {
        keys: "M",
        type: "motion",
        motion: "moveToMiddleLine",
        motionArgs: {
          linewise: true,
          toJumplist: true
        }
      },
      {
        keys: "L",
        type: "motion",
        motion: "moveToBottomLine",
        motionArgs: {
          linewise: true,
          toJumplist: true
        }
      },
      {
        keys: "h",
        type: "motion",
        motion: "moveByCharacters",
        motionArgs: {
          forward: false
        }
      },
      {
        keys: "l",
        type: "motion",
        motion: "moveByCharacters",
        motionArgs: {
          forward: true
        }
      },
      {
        keys: "j",
        type: "motion",
        motion: "moveByLines",
        motionArgs: {
          forward: true,
          linewise: true
        }
      },
      {
        keys: "k",
        type: "motion",
        motion: "moveByLines",
        motionArgs: {
          forward: false,
          linewise: true
        }
      },
      {
        keys: "gj",
        type: "motion",
        motion: "moveByDisplayLines",
        motionArgs: {
          forward: true
        }
      },
      {
        keys: "gk",
        type: "motion",
        motion: "moveByDisplayLines",
        motionArgs: {
          forward: false
        }
      },
      {
        keys: "w",
        type: "motion",
        motion: "moveByWords",
        motionArgs: {
          forward: true,
          wordEnd: false
        }
      },
      {
        keys: "W",
        type: "motion",
        motion: "moveByWords",
        motionArgs: {
          forward: true,
          wordEnd: false,
          bigWord: true
        }
      },
      {
        keys: "e",
        type: "motion",
        motion: "moveByWords",
        motionArgs: {
          forward: true,
          wordEnd: true,
          inclusive: true
        }
      },
      {
        keys: "E",
        type: "motion",
        motion: "moveByWords",
        motionArgs: {
          forward: true,
          wordEnd: true,
          bigWord: true,
          inclusive: true
        }
      },
      {
        keys: "b",
        type: "motion",
        motion: "moveByWords",
        motionArgs: {
          forward: false,
          wordEnd: false
        }
      },
      {
        keys: "B",
        type: "motion",
        motion: "moveByWords",
        motionArgs: {
          forward: false,
          wordEnd: false,
          bigWord: true
        }
      },
      {
        keys: "ge",
        type: "motion",
        motion: "moveByWords",
        motionArgs: {
          forward: false,
          wordEnd: true,
          inclusive: true
        }
      },
      {
        keys: "gE",
        type: "motion",
        motion: "moveByWords",
        motionArgs: {
          forward: false,
          wordEnd: true,
          bigWord: true,
          inclusive: true
        }
      },
      {
        keys: "{",
        type: "motion",
        motion: "moveByParagraph",
        motionArgs: {
          forward: false,
          toJumplist: true
        }
      },
      {
        keys: "}",
        type: "motion",
        motion: "moveByParagraph",
        motionArgs: {
          forward: true,
          toJumplist: true
        }
      },
      {
        keys: "(",
        type: "motion",
        motion: "moveBySentence",
        motionArgs: {
          forward: false
        }
      },
      {
        keys: ")",
        type: "motion",
        motion: "moveBySentence",
        motionArgs: {
          forward: true
        }
      },
      {
        keys: "<C-f>",
        type: "motion",
        motion: "moveByPage",
        motionArgs: {
          forward: true
        }
      },
      {
        keys: "<C-b>",
        type: "motion",
        motion: "moveByPage",
        motionArgs: {
          forward: false
        }
      },
      {
        keys: "<C-d>",
        type: "motion",
        motion: "moveByScroll",
        motionArgs: {
          forward: true,
          explicitRepeat: true
        }
      },
      {
        keys: "<C-u>",
        type: "motion",
        motion: "moveByScroll",
        motionArgs: {
          forward: false,
          explicitRepeat: true
        }
      },
      {
        keys: "gg",
        type: "motion",
        motion: "moveToLineOrEdgeOfDocument",
        motionArgs: {
          forward: false,
          explicitRepeat: true,
          linewise: true,
          toJumplist: true
        }
      },
      {
        keys: "G",
        type: "motion",
        motion: "moveToLineOrEdgeOfDocument",
        motionArgs: {
          forward: true,
          explicitRepeat: true,
          linewise: true,
          toJumplist: true
        }
      },
      {
        keys: "g$",
        type: "motion",
        motion: "moveToEndOfDisplayLine"
      },
      {
        keys: "g^",
        type: "motion",
        motion: "moveToStartOfDisplayLine"
      },
      {
        keys: "g0",
        type: "motion",
        motion: "moveToStartOfDisplayLine"
      },
      {
        keys: "0",
        type: "motion",
        motion: "moveToStartOfLine"
      },
      {
        keys: "^",
        type: "motion",
        motion: "moveToFirstNonWhiteSpaceCharacter"
      },
      {
        keys: "+",
        type: "motion",
        motion: "moveByLines",
        motionArgs: {
          forward: true,
          toFirstChar: true
        }
      },
      {
        keys: "-",
        type: "motion",
        motion: "moveByLines",
        motionArgs: {
          forward: false,
          toFirstChar: true
        }
      },
      {
        keys: "_",
        type: "motion",
        motion: "moveByLines",
        motionArgs: {
          forward: true,
          toFirstChar: true,
          repeatOffset: -1
        }
      },
      {
        keys: "$",
        type: "motion",
        motion: "moveToEol",
        motionArgs: {
          inclusive: true
        }
      },
      {
        keys: "%",
        type: "motion",
        motion: "moveToMatchedSymbol",
        motionArgs: {
          inclusive: true,
          toJumplist: true
        }
      },
      {
        keys: "f<character>",
        type: "motion",
        motion: "moveToCharacter",
        motionArgs: {
          forward: true,
          inclusive: true
        }
      },
      {
        keys: "F<character>",
        type: "motion",
        motion: "moveToCharacter",
        motionArgs: {
          forward: false
        }
      },
      {
        keys: "t<character>",
        type: "motion",
        motion: "moveTillCharacter",
        motionArgs: {
          forward: true,
          inclusive: true
        }
      },
      {
        keys: "T<character>",
        type: "motion",
        motion: "moveTillCharacter",
        motionArgs: {
          forward: false
        }
      },
      {
        keys: ";",
        type: "motion",
        motion: "repeatLastCharacterSearch",
        motionArgs: {
          forward: true
        }
      },
      {
        keys: ",",
        type: "motion",
        motion: "repeatLastCharacterSearch",
        motionArgs: {
          forward: false
        }
      },
      {
        keys: "'<register>",
        type: "motion",
        motion: "goToMark",
        motionArgs: {
          toJumplist: true,
          linewise: true
        }
      },
      {
        keys: "`<register>",
        type: "motion",
        motion: "goToMark",
        motionArgs: {
          toJumplist: true
        }
      },
      {
        keys: "]`",
        type: "motion",
        motion: "jumpToMark",
        motionArgs: {
          forward: true
        }
      },
      {
        keys: "[`",
        type: "motion",
        motion: "jumpToMark",
        motionArgs: {
          forward: false
        }
      },
      {
        keys: "]'",
        type: "motion",
        motion: "jumpToMark",
        motionArgs: {
          forward: true,
          linewise: true
        }
      },
      {
        keys: "['",
        type: "motion",
        motion: "jumpToMark",
        motionArgs: {
          forward: false,
          linewise: true
        }
      },
      {
        keys: "]p",
        type: "action",
        action: "paste",
        isEdit: true,
        actionArgs: {
          after: true,
          isEdit: true,
          matchIndent: true
        }
      },
      {
        keys: "[p",
        type: "action",
        action: "paste",
        isEdit: true,
        actionArgs: {
          after: false,
          isEdit: true,
          matchIndent: true
        }
      },
      {
        keys: "]<character>",
        type: "motion",
        motion: "moveToSymbol",
        motionArgs: {
          forward: true,
          toJumplist: true
        }
      },
      {
        keys: "[<character>",
        type: "motion",
        motion: "moveToSymbol",
        motionArgs: {
          forward: false,
          toJumplist: true
        }
      },
      {
        keys: "|",
        type: "motion",
        motion: "moveToColumn"
      },
      {
        keys: "o",
        type: "motion",
        motion: "moveToOtherHighlightedEnd",
        context: "visual"
      },
      {
        keys: "O",
        type: "motion",
        motion: "moveToOtherHighlightedEnd",
        motionArgs: {
          sameLine: true
        },
        context: "visual"
      },
      {
        keys: "d",
        type: "operator",
        operator: "delete"
      },
      {
        keys: "y",
        type: "operator",
        operator: "yank"
      },
      {
        keys: "c",
        type: "operator",
        operator: "change"
      },
      {
        keys: "=",
        type: "operator",
        operator: "indentAuto"
      },
      {
        keys: ">",
        type: "operator",
        operator: "indent",
        operatorArgs: {
          indentRight: true
        }
      },
      {
        keys: "<",
        type: "operator",
        operator: "indent",
        operatorArgs: {
          indentRight: false
        }
      },
      {
        keys: "g~",
        type: "operator",
        operator: "changeCase"
      },
      {
        keys: "gu",
        type: "operator",
        operator: "changeCase",
        operatorArgs: {
          toLower: true
        },
        isEdit: true
      },
      {
        keys: "gU",
        type: "operator",
        operator: "changeCase",
        operatorArgs: {
          toLower: false
        },
        isEdit: true
      },
      {
        keys: "n",
        type: "motion",
        motion: "findNext",
        motionArgs: {
          forward: true,
          toJumplist: true
        }
      },
      {
        keys: "N",
        type: "motion",
        motion: "findNext",
        motionArgs: {
          forward: false,
          toJumplist: true
        }
      },
      {
        keys: "gn",
        type: "motion",
        motion: "findAndSelectNextInclusive",
        motionArgs: {
          forward: true
        }
      },
      {
        keys: "gN",
        type: "motion",
        motion: "findAndSelectNextInclusive",
        motionArgs: {
          forward: false
        }
      },
      {
        keys: "gq",
        type: "operator",
        operator: "hardWrap"
      },
      {
        keys: "gw",
        type: "operator",
        operator: "hardWrap",
        operatorArgs: {
          keepCursor: true
        }
      },
      {
        keys: "g?",
        type: "operator",
        operator: "rot13"
      },
      {
        keys: "x",
        type: "operatorMotion",
        operator: "delete",
        motion: "moveByCharacters",
        motionArgs: {
          forward: true
        },
        operatorMotionArgs: {
          visualLine: false
        }
      },
      {
        keys: "X",
        type: "operatorMotion",
        operator: "delete",
        motion: "moveByCharacters",
        motionArgs: {
          forward: false
        },
        operatorMotionArgs: {
          visualLine: true
        }
      },
      {
        keys: "D",
        type: "operatorMotion",
        operator: "delete",
        motion: "moveToEol",
        motionArgs: {
          inclusive: true
        },
        context: "normal"
      },
      {
        keys: "D",
        type: "operator",
        operator: "delete",
        operatorArgs: {
          linewise: true
        },
        context: "visual"
      },
      {
        keys: "Y",
        type: "operatorMotion",
        operator: "yank",
        motion: "expandToLine",
        motionArgs: {
          linewise: true
        },
        context: "normal"
      },
      {
        keys: "Y",
        type: "operator",
        operator: "yank",
        operatorArgs: {
          linewise: true
        },
        context: "visual"
      },
      {
        keys: "C",
        type: "operatorMotion",
        operator: "change",
        motion: "moveToEol",
        motionArgs: {
          inclusive: true
        },
        context: "normal"
      },
      {
        keys: "C",
        type: "operator",
        operator: "change",
        operatorArgs: {
          linewise: true
        },
        context: "visual"
      },
      {
        keys: "~",
        type: "operatorMotion",
        operator: "changeCase",
        motion: "moveByCharacters",
        motionArgs: {
          forward: true
        },
        operatorArgs: {
          shouldMoveCursor: true
        },
        context: "normal"
      },
      {
        keys: "~",
        type: "operator",
        operator: "changeCase",
        context: "visual"
      },
      {
        keys: "<C-u>",
        type: "operatorMotion",
        operator: "delete",
        motion: "moveToStartOfLine",
        context: "insert"
      },
      {
        keys: "<C-w>",
        type: "operatorMotion",
        operator: "delete",
        motion: "moveByWords",
        motionArgs: {
          forward: false,
          wordEnd: false
        },
        context: "insert"
      },
      {
        keys: "<C-w>",
        type: "idle",
        context: "normal"
      },
      {
        keys: "<C-i>",
        type: "action",
        action: "jumpListWalk",
        actionArgs: {
          forward: true
        }
      },
      {
        keys: "<C-o>",
        type: "action",
        action: "jumpListWalk",
        actionArgs: {
          forward: false
        }
      },
      {
        keys: "<C-e>",
        type: "action",
        action: "scroll",
        actionArgs: {
          forward: true,
          linewise: true
        }
      },
      {
        keys: "<C-y>",
        type: "action",
        action: "scroll",
        actionArgs: {
          forward: false,
          linewise: true
        }
      },
      {
        keys: "a",
        type: "action",
        action: "enterInsertMode",
        isEdit: true,
        actionArgs: {
          insertAt: "charAfter"
        },
        context: "normal"
      },
      {
        keys: "A",
        type: "action",
        action: "enterInsertMode",
        isEdit: true,
        actionArgs: {
          insertAt: "eol"
        },
        context: "normal"
      },
      {
        keys: "A",
        type: "action",
        action: "enterInsertMode",
        isEdit: true,
        actionArgs: {
          insertAt: "endOfSelectedArea"
        },
        context: "visual"
      },
      {
        keys: "i",
        type: "action",
        action: "enterInsertMode",
        isEdit: true,
        actionArgs: {
          insertAt: "inplace"
        },
        context: "normal"
      },
      {
        keys: "gi",
        type: "action",
        action: "enterInsertMode",
        isEdit: true,
        actionArgs: {
          insertAt: "lastEdit"
        },
        context: "normal"
      },
      {
        keys: "I",
        type: "action",
        action: "enterInsertMode",
        isEdit: true,
        actionArgs: {
          insertAt: "firstNonBlank"
        },
        context: "normal"
      },
      {
        keys: "gI",
        type: "action",
        action: "enterInsertMode",
        isEdit: true,
        actionArgs: {
          insertAt: "bol"
        },
        context: "normal"
      },
      {
        keys: "I",
        type: "action",
        action: "enterInsertMode",
        isEdit: true,
        actionArgs: {
          insertAt: "startOfSelectedArea"
        },
        context: "visual"
      },
      {
        keys: "o",
        type: "action",
        action: "newLineAndEnterInsertMode",
        isEdit: true,
        interlaceInsertRepeat: true,
        actionArgs: {
          after: true
        },
        context: "normal"
      },
      {
        keys: "O",
        type: "action",
        action: "newLineAndEnterInsertMode",
        isEdit: true,
        interlaceInsertRepeat: true,
        actionArgs: {
          after: false
        },
        context: "normal"
      },
      {
        keys: "v",
        type: "action",
        action: "toggleVisualMode"
      },
      {
        keys: "V",
        type: "action",
        action: "toggleVisualMode",
        actionArgs: {
          linewise: true
        }
      },
      {
        keys: "<C-v>",
        type: "action",
        action: "toggleVisualMode",
        actionArgs: {
          blockwise: true
        }
      },
      {
        keys: "<C-q>",
        type: "action",
        action: "toggleVisualMode",
        actionArgs: {
          blockwise: true
        }
      },
      {
        keys: "gv",
        type: "action",
        action: "reselectLastSelection"
      },
      {
        keys: "J",
        type: "action",
        action: "joinLines",
        isEdit: true
      },
      {
        keys: "gJ",
        type: "action",
        action: "joinLines",
        actionArgs: {
          keepSpaces: true
        },
        isEdit: true
      },
      {
        keys: "p",
        type: "action",
        action: "paste",
        isEdit: true,
        actionArgs: {
          after: true,
          isEdit: true
        }
      },
      {
        keys: "P",
        type: "action",
        action: "paste",
        isEdit: true,
        actionArgs: {
          after: false,
          isEdit: true
        }
      },
      {
        keys: "r<character>",
        type: "action",
        action: "replace",
        isEdit: true
      },
      {
        keys: "@<register>",
        type: "action",
        action: "replayMacro"
      },
      {
        keys: "q<register>",
        type: "action",
        action: "enterMacroRecordMode"
      },
      {
        keys: "R",
        type: "action",
        action: "enterInsertMode",
        isEdit: true,
        actionArgs: {
          replace: true
        },
        context: "normal"
      },
      {
        keys: "R",
        type: "operator",
        operator: "change",
        operatorArgs: {
          linewise: true,
          fullLine: true
        },
        context: "visual",
        exitVisualBlock: true
      },
      {
        keys: "u",
        type: "action",
        action: "undo",
        context: "normal"
      },
      {
        keys: "u",
        type: "operator",
        operator: "changeCase",
        operatorArgs: {
          toLower: true
        },
        context: "visual",
        isEdit: true
      },
      {
        keys: "U",
        type: "operator",
        operator: "changeCase",
        operatorArgs: {
          toLower: false
        },
        context: "visual",
        isEdit: true
      },
      {
        keys: "<C-r>",
        type: "action",
        action: "redo"
      },
      {
        keys: "m<register>",
        type: "action",
        action: "setMark"
      },
      {
        keys: '"<register>',
        type: "action",
        action: "setRegister"
      },
      {
        keys: "<C-r><register>",
        type: "action",
        action: "insertRegister",
        context: "insert",
        isEdit: true
      },
      {
        keys: "<C-o>",
        type: "action",
        action: "oneNormalCommand",
        context: "insert"
      },
      {
        keys: "zz",
        type: "action",
        action: "scrollToCursor",
        actionArgs: {
          position: "center"
        }
      },
      {
        keys: "z.",
        type: "action",
        action: "scrollToCursor",
        actionArgs: {
          position: "center"
        },
        motion: "moveToFirstNonWhiteSpaceCharacter"
      },
      {
        keys: "zt",
        type: "action",
        action: "scrollToCursor",
        actionArgs: {
          position: "top"
        }
      },
      {
        keys: "z<CR>",
        type: "action",
        action: "scrollToCursor",
        actionArgs: {
          position: "top"
        },
        motion: "moveToFirstNonWhiteSpaceCharacter"
      },
      {
        keys: "zb",
        type: "action",
        action: "scrollToCursor",
        actionArgs: {
          position: "bottom"
        }
      },
      {
        keys: "z-",
        type: "action",
        action: "scrollToCursor",
        actionArgs: {
          position: "bottom"
        },
        motion: "moveToFirstNonWhiteSpaceCharacter"
      },
      {
        keys: ".",
        type: "action",
        action: "repeatLastEdit"
      },
      {
        keys: "<C-a>",
        type: "action",
        action: "incrementNumberToken",
        isEdit: true,
        actionArgs: {
          increase: true,
          backtrack: false
        }
      },
      {
        keys: "<C-x>",
        type: "action",
        action: "incrementNumberToken",
        isEdit: true,
        actionArgs: {
          increase: false,
          backtrack: false
        }
      },
      {
        keys: "<C-t>",
        type: "action",
        action: "indent",
        actionArgs: {
          indentRight: true
        },
        context: "insert"
      },
      {
        keys: "<C-d>",
        type: "action",
        action: "indent",
        actionArgs: {
          indentRight: false
        },
        context: "insert"
      },
      {
        keys: "a<register>",
        type: "motion",
        motion: "textObjectManipulation"
      },
      {
        keys: "i<register>",
        type: "motion",
        motion: "textObjectManipulation",
        motionArgs: {
          textObjectInner: true
        }
      },
      {
        keys: "/",
        type: "search",
        searchArgs: {
          forward: true,
          querySrc: "prompt",
          toJumplist: true
        }
      },
      {
        keys: "?",
        type: "search",
        searchArgs: {
          forward: false,
          querySrc: "prompt",
          toJumplist: true
        }
      },
      {
        keys: "*",
        type: "search",
        searchArgs: {
          forward: true,
          querySrc: "wordUnderCursor",
          wholeWordOnly: true,
          toJumplist: true
        }
      },
      {
        keys: "#",
        type: "search",
        searchArgs: {
          forward: false,
          querySrc: "wordUnderCursor",
          wholeWordOnly: true,
          toJumplist: true
        }
      },
      {
        keys: "g*",
        type: "search",
        searchArgs: {
          forward: true,
          querySrc: "wordUnderCursor",
          toJumplist: true
        }
      },
      {
        keys: "g#",
        type: "search",
        searchArgs: {
          forward: false,
          querySrc: "wordUnderCursor",
          toJumplist: true
        }
      },
      {
        keys: ":",
        type: "ex"
      }
    ], i = /* @__PURE__ */ Object.create(null), o = r.length, s = [
      {
        name: "colorscheme",
        shortName: "colo"
      },
      {
        name: "map"
      },
      {
        name: "imap",
        shortName: "im"
      },
      {
        name: "nmap",
        shortName: "nm"
      },
      {
        name: "vmap",
        shortName: "vm"
      },
      {
        name: "omap",
        shortName: "om"
      },
      {
        name: "noremap",
        shortName: "no"
      },
      {
        name: "nnoremap",
        shortName: "nn"
      },
      {
        name: "vnoremap",
        shortName: "vn"
      },
      {
        name: "inoremap",
        shortName: "ino"
      },
      {
        name: "onoremap",
        shortName: "ono"
      },
      {
        name: "unmap"
      },
      {
        name: "mapclear",
        shortName: "mapc"
      },
      {
        name: "nmapclear",
        shortName: "nmapc"
      },
      {
        name: "vmapclear",
        shortName: "vmapc"
      },
      {
        name: "imapclear",
        shortName: "imapc"
      },
      {
        name: "omapclear",
        shortName: "omapc"
      },
      {
        name: "write",
        shortName: "w"
      },
      {
        name: "undo",
        shortName: "u"
      },
      {
        name: "redo",
        shortName: "red"
      },
      {
        name: "set",
        shortName: "se"
      },
      {
        name: "setlocal",
        shortName: "setl"
      },
      {
        name: "setglobal",
        shortName: "setg"
      },
      {
        name: "sort",
        shortName: "sor"
      },
      {
        name: "substitute",
        shortName: "s",
        possiblyAsync: true
      },
      {
        name: "startinsert",
        shortName: "start"
      },
      {
        name: "nohlsearch",
        shortName: "noh"
      },
      {
        name: "yank",
        shortName: "y"
      },
      {
        name: "delmarks",
        shortName: "delm"
      },
      {
        name: "marks",
        excludeFromCommandHistory: true
      },
      {
        name: "registers",
        shortName: "reg",
        excludeFromCommandHistory: true
      },
      {
        name: "vglobal",
        shortName: "v"
      },
      {
        name: "delete",
        shortName: "d"
      },
      {
        name: "join",
        shortName: "j"
      },
      {
        name: "normal",
        shortName: "norm"
      },
      {
        name: "global",
        shortName: "g"
      }
    ], a = mf("");
    function l(f) {
      f.setOption("disableInput", true), f.setOption("showCursorWhenSelecting", false), t.signal(f, "vim-mode-change", {
        mode: "normal"
      }), f.on("cursorActivity", zf), ee(f), t.on(f.getInputField(), "paste", u(f));
    }
    function c(f) {
      f.setOption("disableInput", false), f.off("cursorActivity", zf), t.off(f.getInputField(), "paste", u(f)), f.state.vim = null, us && clearTimeout(us);
    }
    function u(f) {
      var d = f.state.vim;
      return d.onPasteFn || (d.onPasteFn = function() {
        d.insertMode || (f.setCursor(ht(f.getCursor(), 0, 1)), lo.enterInsertMode(f, {}, d));
      }), d.onPasteFn;
    }
    var h = /[\d]/, p = [
      t.isWordChar,
      function(f) {
        return f && !t.isWordChar(f) && !/\s/.test(f);
      }
    ], v = [
      function(f) {
        return /\S/.test(f);
      }
    ], y = [
      "<",
      ">"
    ], S = [
      "-",
      '"',
      ".",
      ":",
      "_",
      "/",
      "+"
    ], T = /^\w$/, w = /^[A-Z]$/;
    try {
      w = new RegExp("^[\\p{Lu}]$", "u");
    } catch {
    }
    function k(f, d) {
      return d >= f.firstLine() && d <= f.lastLine();
    }
    function C(f) {
      return /^[a-z]$/.test(f);
    }
    function O(f) {
      return "()[]{}".indexOf(f) != -1;
    }
    function L(f) {
      return h.test(f);
    }
    function D(f) {
      return w.test(f);
    }
    function R(f) {
      return /^\s*$/.test(f);
    }
    function F(f) {
      return ".?!".indexOf(f) != -1;
    }
    function K(f, d) {
      for (var m = 0; m < d.length; m++)
        if (d[m] == f)
          return true;
      return false;
    }
    var Y = {};
    function te(f, d, m, g, b) {
      if (d === void 0 && !b)
        throw Error("defaultValue is required unless callback is provided");
      if (m || (m = "string"), Y[f] = {
        type: m,
        defaultValue: d,
        callback: b
      }, g)
        for (var x = 0; x < g.length; x++)
          Y[g[x]] = Y[f];
      d && ne(f, d);
    }
    function ne(f, d, m, g) {
      var b = Y[f];
      g = g || {};
      var x = g.scope;
      if (!b)
        return new Error("Unknown option: " + f);
      if (b.type == "boolean") {
        if (d && d !== true)
          return new Error("Invalid argument: " + f + "=" + d);
        d !== false && (d = true);
      }
      b.callback ? (x !== "local" && b.callback(d, void 0), x !== "global" && m && b.callback(d, m)) : (x !== "local" && (b.value = b.type == "boolean" ? !!d : d), x !== "global" && m && (m.state.vim.options[f] = {
        value: d
      }));
    }
    function ae(f, d, m) {
      var g = Y[f];
      m = m || {};
      var b = m.scope;
      if (!g)
        return new Error("Unknown option: " + f);
      if (g.callback) {
        let x = d && g.callback(void 0, d);
        return b !== "global" && x !== void 0 ? x : b !== "local" ? g.callback() : void 0;
      } else
        return (b !== "global" && d && d.state.vim.options[f] || b !== "local" && g || {}).value;
    }
    te("filetype", void 0, "string", [
      "ft"
    ], function(f, d) {
      if (d !== void 0)
        if (f === void 0) {
          let m = d.getOption("mode");
          return m == "null" ? "" : m;
        } else {
          let m = f == "" ? "null" : f;
          d.setOption("mode", m);
        }
    }), te("textwidth", 80, "number", [
      "tw"
    ], function(f, d) {
      if (d !== void 0)
        if (f === void 0) {
          var m = d.getOption("textwidth");
          return m;
        } else {
          var g = Math.round(f);
          g > 1 && d.setOption("textwidth", g);
        }
    });
    var ye = function() {
      var f = 100, d = -1, m = 0, g = 0, b = new Array(f);
      function x(E, I, _) {
        var W = d % f, H = b[W];
        function j(X) {
          var Q = ++d % f, xe = b[Q];
          xe && xe.clear(), b[Q] = E.setBookmark(X);
        }
        if (H) {
          var $ = H.find();
          $ && !qt($, I) && j(I);
        } else
          j(I);
        j(_), m = d, g = d - f + 1, g < 0 && (g = 0);
      }
      function M(E, I) {
        d += I, d > m ? d = m : d < g && (d = g);
        var _ = b[(f + d) % f];
        if (_ && !_.find()) {
          var W = I > 0 ? 1 : -1, H, j = E.getCursor();
          do
            if (d += W, _ = b[(f + d) % f], _ && (H = _.find()) && !qt(j, H))
              break;
          while (d < m && d > g);
        }
        return _;
      }
      function A(E, I) {
        var _ = d, W = M(E, I);
        return d = _, W && W.find();
      }
      return {
        cachedCursor: void 0,
        add: x,
        find: A,
        move: M
      };
    }, Ce = function(f) {
      return f ? {
        changes: f.changes,
        expectCursorActivityForChange: f.expectCursorActivityForChange
      } : {
        changes: [],
        expectCursorActivityForChange: false
      };
    };
    class Le {
      constructor() {
        this.latestRegister = void 0, this.isPlaying = false, this.isRecording = false, this.replaySearchQueries = [], this.onRecordingDone = void 0, this.lastInsertModeChanges = Ce();
      }
      exitMacroRecordMode() {
        var d = V.macroModeState;
        d.onRecordingDone && d.onRecordingDone(), d.onRecordingDone = void 0, d.isRecording = false;
      }
      enterMacroRecordMode(d, m) {
        var g = V.registerController.getRegister(m);
        if (g) {
          if (g.clear(), this.latestRegister = m, d.openDialog) {
            var b = sn("span", {
              class: "cm-vim-message"
            }, "recording @" + m);
            this.onRecordingDone = d.openDialog(b, function() {
            }, {
              bottom: true
            });
          }
          this.isRecording = true;
        }
      }
    }
    function ee(f) {
      return f.state.vim || (f.state.vim = {
        inputState: new gf(),
        lastEditInputState: void 0,
        lastEditActionCommand: void 0,
        lastHPos: -1,
        lastHSPos: -1,
        lastMotion: null,
        marks: {},
        insertMode: false,
        insertModeReturn: false,
        insertModeRepeat: void 0,
        visualMode: false,
        visualLine: false,
        visualBlock: false,
        lastSelection: null,
        lastPastedText: void 0,
        sel: {
          anchor: new e(0, 0),
          head: new e(0, 0)
        },
        options: {},
        expectLiteralNext: false,
        status: ""
      }), f.state.vim;
    }
    var V;
    function oe() {
      V = {
        searchQuery: null,
        searchIsReversed: false,
        lastSubstituteReplacePart: void 0,
        jumpList: ye(),
        macroModeState: new Le(),
        lastCharacterSearch: {
          increment: 0,
          forward: true,
          selectedCharacter: ""
        },
        registerController: new eg({}),
        searchHistoryController: new os(),
        exCommandHistoryController: new os()
      };
      for (var f in Y) {
        var d = Y[f];
        d.value = d.defaultValue;
      }
    }
    class he {
      constructor(d, m) {
        this.keyName = d, this.key = m.key, this.ctrlKey = m.ctrlKey, this.altKey = m.altKey, this.metaKey = m.metaKey, this.shiftKey = m.shiftKey;
      }
    }
    var Se, ve = {
      enterVimMode: l,
      leaveVimMode: c,
      buildKeyMap: function() {
      },
      getRegisterController: function() {
        return V.registerController;
      },
      resetVimGlobalState_: oe,
      getVimGlobalState_: function() {
        return V;
      },
      maybeInitVimState_: ee,
      suppressErrorLogging: false,
      InsertModeKey: he,
      map: function(f, d, m) {
        Ft.map(f, d, m);
      },
      unmap: function(f, d) {
        return Ft.unmap(f, d);
      },
      noremap: function(f, d, m) {
        Ft.map(f, d, m, true);
      },
      mapclear: function(f) {
        var d = r.length, m = o, g = r.slice(0, d - m);
        if (r = r.slice(d - m), f)
          for (var b = g.length - 1; b >= 0; b--) {
            var x = g[b];
            if (f !== x.context)
              if (x.context)
                this._mapCommand(x);
              else {
                var M = [
                  "normal",
                  "insert",
                  "visual"
                ];
                for (var A in M)
                  if (M[A] !== f) {
                    var E = Object.assign({}, x);
                    E.context = M[A], this._mapCommand(E);
                  }
              }
          }
      },
      langmap: Ll,
      vimKeyFromEvent: ao,
      setOption: ne,
      getOption: ae,
      defineOption: te,
      defineEx: function(f, d, m) {
        if (!d)
          d = f;
        else if (f.indexOf(d) !== 0)
          throw new Error('(Vim.defineEx) "' + d + '" is not a prefix of "' + f + '", command not registered');
        oa[f] = m, Ft.commandMap_[d] = {
          name: f,
          shortName: d,
          type: "api"
        };
      },
      handleKey: function(f, d, m) {
        var g = this.findKey(f, d, m);
        if (typeof g == "function")
          return g();
      },
      multiSelectHandleKey: pe,
      findKey: function(f, d, m) {
        var g = ee(f), b = f;
        function x() {
          var _ = V.macroModeState;
          if (_.isRecording) {
            if (d == "q")
              return _.exitMacroRecordMode(), Et(b), true;
            m != "mapping" && Cg(_, d);
          }
        }
        function M() {
          if (d == "<Esc>") {
            if (g.visualMode)
              rr(b);
            else if (g.insertMode)
              Zr(b);
            else
              return;
            return Et(b), true;
          }
        }
        function A() {
          if (M())
            return true;
          g.inputState.keyBuffer.push(d);
          var _ = g.inputState.keyBuffer.join(""), W = d.length == 1, H = Er.matchCommand(_, r, g.inputState, "insert"), j = g.inputState.changeQueue;
          if (H.type == "none")
            return Et(b), false;
          if (H.type == "partial") {
            if (H.expectLiteralNext && (g.expectLiteralNext = true), Se && window.clearTimeout(Se), Se = W && window.setTimeout(function() {
              g.insertMode && g.inputState.keyBuffer.length && Et(b);
            }, ae("insertModeEscKeysTimeout")), W) {
              var $ = b.listSelections();
              (!j || j.removed.length != $.length) && (j = g.inputState.changeQueue = new Jm()), j.inserted += d;
              for (var X = 0; X < $.length; X++) {
                var Q = zt($[X].anchor, $[X].head), xe = Jr($[X].anchor, $[X].head), fe = b.getRange(Q, b.state.overwrite ? ht(xe, 0, 1) : xe);
                j.removed[X] = (j.removed[X] || "") + fe;
              }
            }
            return !W;
          } else
            H.type == "full" && (g.inputState.keyBuffer.length = 0);
          if (g.expectLiteralNext = false, Se && window.clearTimeout(Se), H.command && j) {
            for (var $ = b.listSelections(), X = 0; X < $.length; X++) {
              var Ae = $[X].head;
              b.replaceRange(j.removed[X] || "", ht(Ae, 0, -j.inserted.length), Ae, "+input");
            }
            V.macroModeState.lastInsertModeChanges.changes.pop();
          }
          return H.command || Et(b), H.command;
        }
        function E() {
          if (x() || M())
            return true;
          g.inputState.keyBuffer.push(d);
          var _ = g.inputState.keyBuffer.join("");
          if (/^[1-9]\d*$/.test(_))
            return true;
          var W = /^(\d*)(.*)$/.exec(_);
          if (!W)
            return Et(b), false;
          var H = g.visualMode ? "visual" : "normal", j = W[2] || W[1];
          g.inputState.operatorShortcut && g.inputState.operatorShortcut.slice(-1) == j && (j = g.inputState.operatorShortcut);
          var $ = Er.matchCommand(j, r, g.inputState, H);
          return $.type == "none" ? (Et(b), false) : $.type == "partial" ? ($.expectLiteralNext && (g.expectLiteralNext = true), true) : $.type == "clear" ? (Et(b), true) : (g.expectLiteralNext = false, g.inputState.keyBuffer.length = 0, W = /^(\d*)(.*)$/.exec(_), W && W[1] && W[1] != "0" && g.inputState.pushRepeatDigit(W[1]), $.command);
        }
        var I = g.insertMode ? A() : E();
        if (I === false)
          return !g.insertMode && (d.length === 1 || t.isMac && /<A-.>/.test(d)) ? function() {
            return true;
          } : void 0;
        if (I === true)
          return function() {
            return true;
          };
        if (I)
          return function() {
            return b.operation(function() {
              b.curOp.isVimOp = true;
              try {
                if (typeof I != "object")
                  return;
                I.type == "keyToKey" ? vt(b, I.toKeys, I) : Er.processCommand(b, g, I);
              } catch (_) {
                throw b.state.vim = void 0, ee(b), console.log(_), _;
              }
              return true;
            });
          };
      },
      handleEx: function(f, d) {
        Ft.processCommand(f, d);
      },
      defineMotion: Pr,
      defineAction: ea,
      defineOperator: tg,
      mapCommand: Di,
      _mapCommand: sa,
      defineRegister: Zm,
      exitVisualMode: rr,
      exitInsertMode: Zr
    }, le = [], re = false, se;
    function De(f) {
      if (!se)
        throw new Error("No prompt to send key to");
      if (f[0] == "<") {
        var d = f.toLowerCase().slice(1, -1), m = d.split("-");
        if (d = m.pop() || "", d == "lt")
          f = "<";
        else if (d == "space")
          f = " ";
        else if (d == "cr")
          f = `
`;
        else if (Qr[d]) {
          var g = se.value || "", b = {
            key: Qr[d],
            target: {
              value: g,
              selectionEnd: g.length,
              selectionStart: g.length
            }
          };
          se.onKeyDown && se.onKeyDown(b, se.value, M), se && se.onKeyUp && se.onKeyUp(b, se.value, M);
          return;
        }
      }
      if (f == `
`) {
        var x = se;
        se = null, x.onClose && x.onClose(x.value);
      } else
        se.value = (se.value || "") + f;
      function M(A) {
        !se || (typeof A == "string" ? se.value = A : se = null);
      }
    }
    function vt(f, d, m) {
      var g = re;
      if (m) {
        if (le.indexOf(m) != -1)
          return;
        le.push(m), re = m.noremap != false;
      }
      try {
        for (var b = ee(f), x = /<(?:[CSMA]-)*\w+>|./gi, M; M = x.exec(d); ) {
          var A = M[0], E = b.insertMode;
          if (se) {
            De(A);
            continue;
          }
          var I = ve.handleKey(f, A, "mapping");
          if (!I && E && b.insertMode) {
            if (A[0] == "<") {
              var _ = A.toLowerCase().slice(1, -1), W = _.split("-");
              if (_ = W.pop() || "", _ == "lt")
                A = "<";
              else if (_ == "space")
                A = " ";
              else if (_ == "cr")
                A = `
`;
              else if (Qr.hasOwnProperty(_)) {
                A = Qr[_], P(f, A);
                continue;
              } else
                A = A[0], x.lastIndex = M.index + 1;
            }
            f.replaceSelection(A);
          }
        }
      } finally {
        if (le.pop(), re = le.length ? g : false, !le.length && se) {
          var H = se;
          se = null, ta(f, H);
        }
      }
    }
    var Mn = {
      Return: "CR",
      Backspace: "BS",
      Delete: "Del",
      Escape: "Esc",
      Insert: "Ins",
      ArrowLeft: "Left",
      ArrowRight: "Right",
      ArrowUp: "Up",
      ArrowDown: "Down",
      Enter: "CR",
      " ": "Space"
    }, so = {
      Shift: 1,
      Alt: 1,
      Command: 1,
      Control: 1,
      CapsLock: 1,
      AltGraph: 1,
      Dead: 1,
      Unidentified: 1
    }, Qr = {};
    "Left|Right|Up|Down|End|Home".split("|").concat(Object.keys(Mn)).forEach(function(f) {
      Qr[(Mn[f] || "").toLowerCase()] = Qr[f.toLowerCase()] = f;
    });
    function ao(f, d) {
      var _a3;
      var m = f.key;
      if (!so[m]) {
        m.length > 1 && m[0] == "n" && (m = m.replace("Numpad", "")), m = Mn[m] || m;
        var g = "";
        if (f.ctrlKey && (g += "C-"), f.altKey && (g += "A-"), f.metaKey && (g += "M-"), t.isMac && g == "A-" && m.length == 1 && (g = g.slice(2)), (g || m.length > 1) && f.shiftKey && (g += "S-"), d && !d.expectLiteralNext && m.length == 1) {
          if (a.keymap && m in a.keymap)
            (a.remapCtrl != false || !g) && (m = a.keymap[m]);
          else if (m.charCodeAt(0) > 128 && !i[m]) {
            var b = ((_a3 = f.code) == null ? void 0 : _a3.slice(-1)) || "";
            f.shiftKey || (b = b.toLowerCase()), b && (m = b, !g && f.altKey && (g = "A-"));
          }
        }
        return g += m, g.length > 1 && (g = "<" + g + ">"), g;
      }
    }
    function Ll(f, d) {
      a.string !== f && (a = mf(f)), a.remapCtrl = d;
    }
    function mf(f) {
      let d = {};
      if (!f)
        return {
          keymap: d,
          string: ""
        };
      function m(g) {
        return g.split(/\\?(.)/).filter(Boolean);
      }
      return f.split(/((?:[^\\,]|\\.)+),/).map((g) => {
        if (!g)
          return;
        const b = g.split(/((?:[^\\;]|\\.)+);/);
        if (b.length == 3) {
          const x = m(b[1]), M = m(b[2]);
          if (x.length !== M.length)
            return;
          for (let A = 0; A < x.length; ++A)
            d[x[A]] = M[A];
        } else if (b.length == 1) {
          const x = m(g);
          if (x.length % 2 !== 0)
            return;
          for (let M = 0; M < x.length; M += 2)
            d[x[M]] = x[M + 1];
        }
      }), {
        keymap: d,
        string: f
      };
    }
    te("langmap", void 0, "string", [
      "lmap"
    ], function(f, d) {
      if (f === void 0)
        return a.string;
      Ll(f);
    });
    class gf {
      constructor() {
        this.prefixRepeat = [], this.motionRepeat = [], this.operator = null, this.operatorArgs = null, this.motion = null, this.motionArgs = null, this.keyBuffer = [], this.registerName = void 0, this.changeQueue = null;
      }
      pushRepeatDigit(d) {
        this.operator ? this.motionRepeat = this.motionRepeat.concat(d) : this.prefixRepeat = this.prefixRepeat.concat(d);
      }
      getRepeat() {
        var d = 0;
        return (this.prefixRepeat.length > 0 || this.motionRepeat.length > 0) && (d = 1, this.prefixRepeat.length > 0 && (d *= parseInt(this.prefixRepeat.join(""), 10)), this.motionRepeat.length > 0 && (d *= parseInt(this.motionRepeat.join(""), 10))), d;
      }
    }
    function Et(f, d) {
      f.state.vim.inputState = new gf(), f.state.vim.expectLiteralNext = false, t.signal(f, "vim-command-done", d);
    }
    function Jm() {
      this.removed = [], this.inserted = "";
    }
    class tr {
      constructor(d, m, g) {
        this.clear(), this.keyBuffer = [
          d || ""
        ], this.insertModeChanges = [], this.searchQueries = [], this.linewise = !!m, this.blockwise = !!g;
      }
      setText(d, m, g) {
        this.keyBuffer = [
          d || ""
        ], this.linewise = !!m, this.blockwise = !!g;
      }
      pushText(d, m) {
        m && (this.linewise || this.keyBuffer.push(`
`), this.linewise = true), this.keyBuffer.push(d);
      }
      pushInsertModeChanges(d) {
        this.insertModeChanges.push(Ce(d));
      }
      pushSearchQuery(d) {
        this.searchQueries.push(d);
      }
      clear() {
        this.keyBuffer = [], this.insertModeChanges = [], this.searchQueries = [], this.linewise = false;
      }
      toString() {
        return this.keyBuffer.join("");
      }
    }
    function Zm(f, d) {
      var m = V.registerController.registers;
      if (!f || f.length != 1)
        throw Error("Register name must be 1 character");
      if (m[f])
        throw Error("Register already defined " + f);
      m[f] = d, S.push(f);
    }
    class eg {
      constructor(d) {
        this.registers = d, this.unnamedRegister = d['"'] = new tr(), d["."] = new tr(), d[":"] = new tr(), d["/"] = new tr(), d["+"] = new tr();
      }
      pushText(d, m, g, b, x) {
        if (d !== "_") {
          b && g.charAt(g.length - 1) !== `
` && (g += `
`);
          var M = this.isValidRegister(d) ? this.getRegister(d) : null;
          if (!M || !d) {
            switch (m) {
              case "yank":
                this.registers[0] = new tr(g, b, x);
                break;
              case "delete":
              case "change":
                g.indexOf(`
`) == -1 ? this.registers["-"] = new tr(g, b) : (this.shiftNumericRegisters_(), this.registers[1] = new tr(g, b));
                break;
            }
            this.unnamedRegister.setText(g, b, x);
            return;
          }
          var A = D(d);
          A ? M.pushText(g, b) : M.setText(g, b, x), d === "+" && navigator.clipboard.writeText(g), this.unnamedRegister.setText(M.toString(), b);
        }
      }
      getRegister(d) {
        return this.isValidRegister(d) ? (d = d.toLowerCase(), this.registers[d] || (this.registers[d] = new tr()), this.registers[d]) : this.unnamedRegister;
      }
      isValidRegister(d) {
        return d && (K(d, S) || T.test(d));
      }
      shiftNumericRegisters_() {
        for (var d = 9; d >= 2; d--)
          this.registers[d] = this.getRegister("" + (d - 1));
      }
    }
    class os {
      constructor() {
        this.historyBuffer = [], this.iterator = 0, this.initialPrefix = null;
      }
      nextMatch(d, m) {
        var g = this.historyBuffer, b = m ? -1 : 1;
        this.initialPrefix === null && (this.initialPrefix = d);
        for (var x = this.iterator + b; m ? x >= 0 : x < g.length; x += b)
          for (var M = g[x], A = 0; A <= M.length; A++)
            if (this.initialPrefix == M.substring(0, A))
              return this.iterator = x, M;
        if (x >= g.length)
          return this.iterator = g.length, this.initialPrefix;
        if (x < 0)
          return d;
      }
      pushInput(d) {
        var m = this.historyBuffer.indexOf(d);
        m > -1 && this.historyBuffer.splice(m, 1), d.length && this.historyBuffer.push(d);
      }
      reset() {
        this.initialPrefix = null, this.iterator = this.historyBuffer.length;
      }
    }
    var Er = {
      matchCommand: function(f, d, m, g) {
        var b = vf(f, d, g, m), x = b.full[0];
        if (!x)
          return b.partial.length ? {
            type: "partial",
            expectLiteralNext: b.partial.length == 1 && b.partial[0].keys.slice(-11) == "<character>"
          } : {
            type: "none"
          };
        if (x.keys.slice(-11) == "<character>" || x.keys.slice(-10) == "<register>") {
          var M = ng(f);
          if (!M || M.length > 1)
            return {
              type: "clear"
            };
          m.selectedCharacter = M;
        }
        return {
          type: "full",
          command: x
        };
      },
      processCommand: function(f, d, m) {
        switch (d.inputState.repeatOverride = m.repeatOverride, m.type) {
          case "motion":
            this.processMotion(f, d, m);
            break;
          case "operator":
            this.processOperator(f, d, m);
            break;
          case "operatorMotion":
            this.processOperatorMotion(f, d, m);
            break;
          case "action":
            this.processAction(f, d, m);
            break;
          case "search":
            this.processSearch(f, d, m);
            break;
          case "ex":
          case "keyToEx":
            this.processEx(f, d, m);
            break;
        }
      },
      processMotion: function(f, d, m) {
        d.inputState.motion = m.motion, d.inputState.motionArgs = ss(m.motionArgs), this.evalInput(f, d);
      },
      processOperator: function(f, d, m) {
        var g = d.inputState;
        if (g.operator)
          if (g.operator == m.operator) {
            g.motion = "expandToLine", g.motionArgs = {
              linewise: true,
              repeat: 1
            }, this.evalInput(f, d);
            return;
          } else
            Et(f);
        g.operator = m.operator, g.operatorArgs = ss(m.operatorArgs), m.keys.length > 1 && (g.operatorShortcut = m.keys), m.exitVisualBlock && (d.visualBlock = false, co(f)), d.visualMode && this.evalInput(f, d);
      },
      processOperatorMotion: function(f, d, m) {
        var g = d.visualMode, b = ss(m.operatorMotionArgs);
        b && g && b.visualLine && (d.visualLine = true), this.processOperator(f, d, m), g || this.processMotion(f, d, m);
      },
      processAction: function(f, d, m) {
        var g = d.inputState, b = g.getRepeat(), x = !!b, M = ss(m.actionArgs) || {
          repeat: 1
        };
        g.selectedCharacter && (M.selectedCharacter = g.selectedCharacter), m.operator && this.processOperator(f, d, m), m.motion && this.processMotion(f, d, m), (m.motion || m.operator) && this.evalInput(f, d), M.repeat = b || 1, M.repeatIsExplicit = x, M.registerName = g.registerName, Et(f), d.lastMotion = null, m.isEdit && this.recordLastEdit(d, g, m), lo[m.action](f, M, d);
      },
      processSearch: function(f, d, m) {
        if (!f.getSearchCursor)
          return;
        var g = m.searchArgs.forward, b = m.searchArgs.wholeWordOnly;
        En(f).setReversed(!g);
        var x = g ? "/" : "?", M = En(f).getQuery(), A = f.getScrollInfo(), E = "";
        function I(fe, Ae, Re) {
          V.searchHistoryController.pushInput(fe), V.searchHistoryController.reset();
          try {
            cs(f, fe, Ae, Re);
          } catch {
            Ie(f, "Invalid regex: " + fe), Et(f);
            return;
          }
          Er.processMotion(f, d, {
            keys: "",
            type: "motion",
            motion: "findNext",
            motionArgs: {
              forward: true,
              toJumplist: m.searchArgs.toJumplist
            }
          });
        }
        function _(fe) {
          f.scrollTo(A.left, A.top), I(fe, true, true);
          var Ae = V.macroModeState;
          Ae.isRecording && Tg(Ae, fe);
        }
        function W() {
          return ae("pcre") ? "(JavaScript regexp: set pcre)" : "(Vim regexp: set nopcre)";
        }
        function H(fe, Ae, Re) {
          var Pe = ao(fe), ct, dt;
          Pe == "<Up>" || Pe == "<Down>" ? (ct = Pe == "<Up>", dt = fe.target ? fe.target.selectionEnd : 0, Ae = V.searchHistoryController.nextMatch(Ae, ct) || "", Re(Ae), dt && fe.target && (fe.target.selectionEnd = fe.target.selectionStart = Math.min(dt, fe.target.value.length))) : Pe && Pe != "<Left>" && Pe != "<Right>" && V.searchHistoryController.reset(), E = Ae, j();
        }
        function j() {
          var fe;
          try {
            fe = cs(f, E, true, true);
          } catch {
          }
          fe ? f.scrollIntoView(If(f, !g, fe), 30) : (fo(f), f.scrollTo(A.left, A.top));
        }
        function $(fe, Ae, Re) {
          var Pe = ao(fe);
          Pe == "<Esc>" || Pe == "<C-c>" || Pe == "<C-[>" || Pe == "<BS>" && Ae == "" ? (V.searchHistoryController.pushInput(Ae), V.searchHistoryController.reset(), cs(f, (M == null ? void 0 : M.source) || ""), fo(f), f.scrollTo(A.left, A.top), t.e_stop(fe), Et(f), Re(), f.focus()) : Pe == "<Up>" || Pe == "<Down>" ? t.e_stop(fe) : Pe == "<C-u>" && (t.e_stop(fe), Re(""));
        }
        switch (m.searchArgs.querySrc) {
          case "prompt":
            var X = V.macroModeState;
            if (X.isPlaying) {
              let Ae = X.replaySearchQueries.shift();
              I(Ae || "", true, false);
            } else
              ta(f, {
                onClose: _,
                prefix: x,
                desc: sn("span", {
                  $cursor: "pointer",
                  onmousedown: function(Ae) {
                    Ae.preventDefault(), ne("pcre", !ae("pcre")), this.textContent = W(), j();
                  }
                }, W()),
                onKeyUp: H,
                onKeyDown: $
              });
            break;
          case "wordUnderCursor":
            var Q = Bl(f, {
              noSymbol: true
            }), xe = true;
            if (Q || (Q = Bl(f, {
              noSymbol: false
            }), xe = false), !Q) {
              Ie(f, "No word under cursor"), Et(f);
              return;
            }
            let fe = f.getLine(Q.start.line).substring(Q.start.ch, Q.end.ch);
            xe && b ? fe = "\\b" + fe + "\\b" : fe = Ri(fe), V.jumpList.cachedCursor = f.getCursor(), f.setCursor(Q.start), I(fe, true, false);
            break;
        }
      },
      processEx: function(f, d, m) {
        function g(A) {
          V.exCommandHistoryController.pushInput(A), V.exCommandHistoryController.reset(), Ft.processCommand(f, A), f.state.vim && Et(f), fo(f);
        }
        function b(A, E, I) {
          var _ = ao(A), W, H;
          (_ == "<Esc>" || _ == "<C-c>" || _ == "<C-[>" || _ == "<BS>" && E == "") && (V.exCommandHistoryController.pushInput(E), V.exCommandHistoryController.reset(), t.e_stop(A), Et(f), fo(f), I(), f.focus()), _ == "<Up>" || _ == "<Down>" ? (t.e_stop(A), W = _ == "<Up>", H = A.target ? A.target.selectionEnd : 0, E = V.exCommandHistoryController.nextMatch(E, W) || "", I(E), H && A.target && (A.target.selectionEnd = A.target.selectionStart = Math.min(H, A.target.value.length))) : _ == "<C-u>" ? (t.e_stop(A), I("")) : _ && _ != "<Left>" && _ != "<Right>" && V.exCommandHistoryController.reset();
        }
        function x(A, E) {
          var I = new t.StringStream(E), _ = {};
          try {
            if (Ft.parseInput_(f, I, _), _.commandName != "s") {
              fo(f);
              return;
            }
            var W = Ft.matchCommand_(_.commandName);
            if (!W || (Ft.parseCommandArgs_(I, _, W), !_.argString))
              return;
            var H = _f2(_.argString.slice(1), true, true);
            H && na(f, H);
          } catch {
          }
        }
        if (m.type == "keyToEx")
          Ft.processCommand(f, m.exArgs.input);
        else {
          var M = {
            onClose: g,
            onKeyDown: b,
            onKeyUp: x,
            prefix: ":"
          };
          d.visualMode && (M.value = "'<,'>", M.selectValueOnOpen = false), ta(f, M);
        }
      },
      evalInput: function(f, d) {
        var m = d.inputState, g = m.motion, b = m.motionArgs || {
          repeat: 1
        }, x = m.operator, M = m.operatorArgs || {}, A = m.registerName, E = d.sel, I = Fe(d.visualMode ? $t(f, E.head) : f.getCursor("head")), _ = Fe(d.visualMode ? $t(f, E.anchor) : f.getCursor("anchor")), W = Fe(I), H = Fe(_), j, $, X;
        if (x && this.recordLastEdit(d, m), m.repeatOverride !== void 0 ? X = m.repeatOverride : X = m.getRepeat(), X > 0 && b.explicitRepeat ? b.repeatIsExplicit = true : (b.noRepeat || !b.explicitRepeat && X === 0) && (X = 1, b.repeatIsExplicit = false), m.selectedCharacter && (b.selectedCharacter = M.selectedCharacter = m.selectedCharacter), b.repeat = X, Et(f), g) {
          var Q = gn[g](f, I, b, d, m);
          if (d.lastMotion = gn[g], !Q)
            return;
          if (b.toJumplist) {
            var xe = V.jumpList, fe = xe.cachedCursor;
            fe ? (wf(f, fe, Q), delete xe.cachedCursor) : wf(f, I, Q);
          }
          Q instanceof Array ? ($ = Q[0], j = Q[1]) : j = Q, j || (j = Fe(I)), d.visualMode ? (d.visualBlock && j.ch === 1 / 0 || (j = $t(f, j, W)), $ && ($ = $t(f, $)), $ = $ || H, E.anchor = $, E.head = j, co(f), An(f, d, "<", lt($, j) ? $ : j), An(f, d, ">", lt($, j) ? j : $)) : x || (j = $t(f, j, W), f.setCursor(j.line, j.ch));
        }
        if (x) {
          if (M.lastSel) {
            $ = H;
            var Ae = M.lastSel, Re = Math.abs(Ae.head.line - Ae.anchor.line), Pe = Math.abs(Ae.head.ch - Ae.anchor.ch);
            Ae.visualLine ? j = new e(H.line + Re, H.ch) : Ae.visualBlock ? j = new e(H.line + Re, H.ch + Pe) : Ae.head.line == Ae.anchor.line ? j = new e(H.line, H.ch + Pe) : j = new e(H.line + Re, H.ch), d.visualMode = true, d.visualLine = Ae.visualLine, d.visualBlock = Ae.visualBlock, E = d.sel = {
              anchor: $,
              head: j
            }, co(f);
          } else
            d.visualMode && (M.lastSel = {
              anchor: Fe(E.anchor),
              head: Fe(E.head),
              visualBlock: d.visualBlock,
              visualLine: d.visualLine
            });
          var ct, dt, Ve, Me, et;
          if (d.visualMode) {
            ct = zt(E.head, E.anchor), dt = Jr(E.head, E.anchor), Ve = d.visualLine || M.linewise, Me = d.visualBlock ? "block" : Ve ? "line" : "char";
            var or = n(f, ct, dt);
            if (et = Il(f, {
              anchor: or.start,
              head: or.end
            }, Me), Ve) {
              var Gt = et.ranges;
              if (Me == "block")
                for (var sr = 0; sr < Gt.length; sr++)
                  Gt[sr].head.ch = yt(f, Gt[sr].head.line);
              else
                Me == "line" && (Gt[0].head = new e(Gt[0].head.line + 1, 0));
            }
          } else {
            if (ct = Fe($ || H), dt = Fe(j || W), lt(dt, ct)) {
              var hs = ct;
              ct = dt, dt = hs;
            }
            Ve = b.linewise || M.linewise, Ve ? lg(f, ct, dt) : b.forward && uo(f, ct, dt), Me = "char";
            var o_ = !b.inclusive || Ve, or = n(f, ct, dt);
            et = Il(f, {
              anchor: or.start,
              head: or.end
            }, Me, o_);
          }
          f.setSelections(et.ranges, et.primary), d.lastMotion = null, M.repeat = X, M.registerName = A, M.linewise = Ve;
          var Mg = Zs[x](f, M, et.ranges, H, j);
          d.visualMode && rr(f, Mg != null), Mg && f.setCursor(Mg);
        }
      },
      recordLastEdit: function(f, d, m) {
        var g = V.macroModeState;
        g.isPlaying || (f.lastEditInputState = d, f.lastEditActionCommand = m, g.lastInsertModeChanges.changes = [], g.lastInsertModeChanges.expectCursorActivityForChange = false, g.lastInsertModeChanges.visualBlock = f.visualBlock ? f.sel.head.line - f.sel.anchor.line : 0);
      }
    }, gn = {
      moveToTopLine: function(f, d, m) {
        var g = zl(f).top + m.repeat - 1;
        return new e(g, ir(f.getLine(g)));
      },
      moveToMiddleLine: function(f) {
        var d = zl(f), m = Math.floor((d.top + d.bottom) * 0.5);
        return new e(m, ir(f.getLine(m)));
      },
      moveToBottomLine: function(f, d, m) {
        var g = zl(f).bottom - m.repeat + 1;
        return new e(g, ir(f.getLine(g)));
      },
      expandToLine: function(f, d, m) {
        var g = d;
        return new e(g.line + m.repeat - 1, 1 / 0);
      },
      findNext: function(f, d, m) {
        var g = En(f), b = g.getQuery();
        if (!!b) {
          var x = !m.forward;
          x = g.isReversed() ? !x : x, na(f, b);
          var M = If(f, x, b, m.repeat);
          return M || Ie(f, "No match found " + b + (ae("pcre") ? " (set nopcre to use Vim regexps)" : "")), M;
        }
      },
      findAndSelectNextInclusive: function(f, d, m, g, b) {
        var x = En(f), M = x.getQuery();
        if (!!M) {
          var A = !m.forward;
          A = x.isReversed() ? !A : A;
          var E = kg(f, A, M, m.repeat, g);
          if (!!E) {
            if (b.operator)
              return E;
            var I = E[0], _ = new e(E[1].line, E[1].ch - 1);
            if (g.visualMode) {
              (g.visualLine || g.visualBlock) && (g.visualLine = false, g.visualBlock = false, t.signal(f, "vim-mode-change", {
                mode: "visual",
                subMode: ""
              }));
              var W = g.sel.anchor;
              if (W)
                return x.isReversed() ? m.forward ? [
                  W,
                  I
                ] : [
                  W,
                  _
                ] : m.forward ? [
                  W,
                  _
                ] : [
                  W,
                  I
                ];
            } else
              g.visualMode = true, g.visualLine = false, g.visualBlock = false, t.signal(f, "vim-mode-change", {
                mode: "visual",
                subMode: ""
              });
            return A ? [
              _,
              I
            ] : [
              I,
              _
            ];
          }
        }
      },
      goToMark: function(f, d, m, g) {
        var b = ra(f, g, m.selectedCharacter || "");
        return b ? m.linewise ? {
          line: b.line,
          ch: ir(f.getLine(b.line))
        } : b : null;
      },
      moveToOtherHighlightedEnd: function(f, d, m, g) {
        var b = g.sel;
        return g.visualBlock && m.sameLine ? [
          $t(f, new e(b.anchor.line, b.head.ch)),
          $t(f, new e(b.head.line, b.anchor.ch))
        ] : [
          b.head,
          b.anchor
        ];
      },
      jumpToMark: function(f, d, m, g) {
        for (var b = d, x = 0; x < m.repeat; x++) {
          var M = b;
          for (var A in g.marks)
            if (!!C(A)) {
              var E = g.marks[A].find(), I = m.forward ? lt(E, M) : lt(M, E);
              if (!I && !(m.linewise && E.line == M.line)) {
                var _ = qt(M, b), W = m.forward ? _l2(M, E, b) : _l2(b, E, M);
                (_ || W) && (b = E);
              }
            }
        }
        return m.linewise && (b = new e(b.line, ir(f.getLine(b.line)))), b;
      },
      moveByCharacters: function(f, d, m) {
        var g = d, b = m.repeat, x = m.forward ? g.ch + b : g.ch - b;
        return new e(g.line, x);
      },
      moveByLines: function(f, d, m, g) {
        var b = d, x = b.ch;
        switch (g.lastMotion) {
          case this.moveByLines:
          case this.moveByDisplayLines:
          case this.moveByScroll:
          case this.moveToColumn:
          case this.moveToEol:
            x = g.lastHPos;
            break;
          default:
            g.lastHPos = x;
        }
        var M = m.repeat + (m.repeatOffset || 0), A = m.forward ? b.line + M : b.line - M, E = f.firstLine(), I = f.lastLine(), _ = f.findPosV(b, m.forward ? M : -M, "line", g.lastHSPos), W = m.forward ? _.line > A : _.line < A;
        return W && (A = _.line, x = _.ch), A < E && b.line == E ? this.moveToStartOfLine(f, d, m, g) : A > I && b.line == I ? Tf(f, d, m, g, true) : (m.toFirstChar && (x = ir(f.getLine(A)), g.lastHPos = x), g.lastHSPos = f.charCoords(new e(A, x), "div").left, new e(A, x));
      },
      moveByDisplayLines: function(f, d, m, g) {
        var b = d;
        switch (g.lastMotion) {
          case this.moveByDisplayLines:
          case this.moveByScroll:
          case this.moveByLines:
          case this.moveToColumn:
          case this.moveToEol:
            break;
          default:
            g.lastHSPos = f.charCoords(b, "div").left;
        }
        var x = m.repeat, M = f.findPosV(b, m.forward ? x : -x, "line", g.lastHSPos);
        if (M.hitSide)
          if (m.forward) {
            var A = f.charCoords(M, "div"), E = {
              top: A.top + 8,
              left: g.lastHSPos
            };
            M = f.coordsChar(E, "div");
          } else {
            var I = f.charCoords(new e(f.firstLine(), 0), "div");
            I.left = g.lastHSPos, M = f.coordsChar(I, "div");
          }
        return g.lastHPos = M.ch, M;
      },
      moveByPage: function(f, d, m) {
        var g = d, b = m.repeat;
        return f.findPosV(g, m.forward ? b : -b, "page");
      },
      moveByParagraph: function(f, d, m) {
        var g = m.forward ? 1 : -1;
        return Mf(f, d, m.repeat, g).start;
      },
      moveBySentence: function(f, d, m) {
        var g = m.forward ? 1 : -1;
        return Af(f, d, m.repeat, g);
      },
      moveByScroll: function(f, d, m, g) {
        var b = f.getScrollInfo(), x = null, M = m.repeat;
        M || (M = b.clientHeight / (2 * f.defaultTextHeight()));
        var A = f.charCoords(d, "local");
        if (m.repeat = M, x = gn.moveByDisplayLines(f, d, m, g), !x)
          return null;
        var E = f.charCoords(x, "local");
        return f.scrollTo(null, b.top + E.top - A.top), x;
      },
      moveByWords: function(f, d, m) {
        return hg(f, d, m.repeat, !!m.forward, !!m.wordEnd, !!m.bigWord);
      },
      moveTillCharacter: function(f, d, m) {
        var g = m.repeat, b = as(f, g, m.forward, m.selectedCharacter, d), x = m.forward ? -1 : 1;
        return _i2(x, m), b ? (b.ch += x, b) : null;
      },
      moveToCharacter: function(f, d, m) {
        var g = m.repeat;
        return _i2(0, m), as(f, g, m.forward, m.selectedCharacter, d) || d;
      },
      moveToSymbol: function(f, d, m) {
        var g = m.repeat;
        return m.selectedCharacter && fg(f, g, m.forward, m.selectedCharacter) || d;
      },
      moveToColumn: function(f, d, m, g) {
        var b = m.repeat;
        return g.lastHPos = b - 1, g.lastHSPos = f.charCoords(d, "div").left, dg(f, b);
      },
      moveToEol: function(f, d, m, g) {
        return Tf(f, d, m, g, false);
      },
      moveToFirstNonWhiteSpaceCharacter: function(f, d) {
        var m = d;
        return new e(m.line, ir(f.getLine(m.line)));
      },
      moveToMatchedSymbol: function(f, d) {
        for (var m = d, g = m.line, b = m.ch, x = f.getLine(g), M; b < x.length; b++)
          if (M = x.charAt(b), M && O(M)) {
            var A = f.getTokenTypeAt(new e(g, b + 1));
            if (A !== "string" && A !== "comment")
              break;
          }
        if (b < x.length) {
          var E = M === "<" || M === ">" ? /[(){}[\]<>]/ : /[(){}[\]]/, I = f.findMatchingBracket(new e(g, b), {
            bracketRegex: E
          });
          return I.to;
        } else
          return m;
      },
      moveToStartOfLine: function(f, d) {
        return new e(d.line, 0);
      },
      moveToLineOrEdgeOfDocument: function(f, d, m) {
        var g = m.forward ? f.lastLine() : f.firstLine();
        return m.repeatIsExplicit && (g = m.repeat - f.getOption("firstLineNumber")), new e(g, ir(f.getLine(g)));
      },
      moveToStartOfDisplayLine: function(f) {
        return f.execCommand("goLineLeft"), f.getCursor();
      },
      moveToEndOfDisplayLine: function(f) {
        f.execCommand("goLineRight");
        var d = f.getCursor();
        return d.sticky == "before" && d.ch--, d;
      },
      textObjectManipulation: function(f, d, m, g) {
        var b = {
          "(": ")",
          ")": "(",
          "{": "}",
          "}": "{",
          "[": "]",
          "]": "[",
          "<": ">",
          ">": "<"
        }, x = {
          "'": true,
          '"': true,
          "`": true
        }, M = m.selectedCharacter || "";
        M == "b" ? M = "(" : M == "B" && (M = "{");
        var A = !m.textObjectInner, E, I;
        if (b[M]) {
          if (I = true, E = Ef(f, d, M, A), !E) {
            var _ = f.getSearchCursor(new RegExp("\\" + M, "g"), d);
            _.find() && (E = Ef(f, _.from(), M, A));
          }
        } else if (x[M])
          I = true, E = pg(f, d, M, A);
        else if (M === "W" || M === "w")
          for (var W = m.repeat || 1; W-- > 0; ) {
            var H = Bl(f, {
              inclusive: A,
              innerWord: !A,
              bigWord: M === "W",
              noSymbol: M === "W",
              multiline: true
            }, E && E.end);
            H && (E || (E = H), E.end = H.end);
          }
        else if (M === "p")
          if (E = Mf(f, d, m.repeat, 0, A), m.linewise = true, g.visualMode)
            g.visualLine || (g.visualLine = true);
          else {
            var j = g.inputState.operatorArgs;
            j && (j.linewise = true), E.end.line--;
          }
        else if (M === "t")
          E = cg(f, d, A);
        else if (M === "s") {
          var $ = f.getLine(d.line);
          d.ch > 0 && F($[d.ch]) && (d.ch -= 1);
          var X = ls(f, d, m.repeat, 1, A), Q = ls(f, d, m.repeat, -1, A);
          R(f.getLine(Q.line)[Q.ch]) && R(f.getLine(X.line)[X.ch - 1]) && (Q = {
            line: Q.line,
            ch: Q.ch + 1
          }), E = {
            start: Q,
            end: X
          };
        }
        return E ? f.state.vim.visualMode ? sg(f, E.start, E.end, I) : [
          E.start,
          E.end
        ] : null;
      },
      repeatLastCharacterSearch: function(f, d, m) {
        var g = V.lastCharacterSearch, b = m.repeat, x = m.forward === g.forward, M = (g.increment ? 1 : 0) * (x ? -1 : 1);
        f.moveH(-M, "char"), m.inclusive = !!x;
        var A = as(f, b, x, g.selectedCharacter);
        return A ? (A.ch += M, A) : (f.moveH(M, "char"), d);
      }
    };
    function Pr(f, d) {
      gn[f] = d;
    }
    function Rl(f, d) {
      for (var m = [], g = 0; g < d; g++)
        m.push(f);
      return m;
    }
    var Zs = {
      change: function(f, d, m) {
        var g, b, x = f.state.vim, M = m[0].anchor, A = m[0].head;
        if (x.visualMode)
          if (d.fullLine)
            A.ch = Number.MAX_VALUE, A.line--, f.setSelection(M, A), b = f.getSelection(), f.replaceSelection(""), g = M;
          else {
            b = f.getSelection();
            var _ = Rl("", m.length);
            f.replaceSelections(_), g = zt(m[0].head, m[0].anchor);
          }
        else {
          b = f.getRange(M, A);
          var E = x.lastEditInputState;
          if ((E == null ? void 0 : E.motion) == "moveByWords" && !R(b)) {
            var I = /\s+$/.exec(b);
            I && E.motionArgs && E.motionArgs.forward && (A = ht(A, 0, -I[0].length), b = b.slice(0, -I[0].length));
          }
          d.linewise && (M = new e(M.line, ir(f.getLine(M.line))), A.line > M.line && (A = new e(A.line - 1, Number.MAX_VALUE))), f.replaceRange("", M, A), g = M;
        }
        V.registerController.pushText(d.registerName, "change", b, d.linewise, m.length > 1), lo.enterInsertMode(f, {
          head: g
        }, f.state.vim);
      },
      delete: function(f, d, m) {
        var g, b, x = f.state.vim;
        if (x.visualBlock) {
          b = f.getSelection();
          var E = Rl("", m.length);
          f.replaceSelections(E), g = zt(m[0].head, m[0].anchor);
        } else {
          var M = m[0].anchor, A = m[0].head;
          d.linewise && A.line != f.firstLine() && M.line == f.lastLine() && M.line == A.line - 1 && (M.line == f.firstLine() ? M.ch = 0 : M = new e(M.line - 1, yt(f, M.line - 1))), b = f.getRange(M, A), f.replaceRange("", M, A), g = M, d.linewise && (g = gn.moveToFirstNonWhiteSpaceCharacter(f, M));
        }
        return V.registerController.pushText(d.registerName, "delete", b, d.linewise, x.visualBlock), $t(f, g);
      },
      indent: function(f, d, m) {
        var g = f.state.vim, b = g.visualMode && d.repeat || 1;
        if (g.visualBlock) {
          for (var x = f.getOption("tabSize"), M = f.getOption("indentWithTabs") ? "	" : " ".repeat(x), A, E = m.length - 1; E >= 0; E--)
            if (A = zt(m[E].anchor, m[E].head), d.indentRight)
              f.replaceRange(M.repeat(b), A, A);
            else {
              for (var I = f.getLine(A.line), _ = 0, W = 0; W < b; W++) {
                var H = I[A.ch + _];
                if (H == "	")
                  _++;
                else if (H == " ") {
                  _++;
                  for (var j = 1; j < M.length && (H = I[A.ch + _], H === " "); j++)
                    _++;
                } else
                  break;
              }
              f.replaceRange("", A, ht(A, 0, _));
            }
          return A;
        } else if (f.indentMore)
          for (var W = 0; W < b; W++)
            d.indentRight ? f.indentMore() : f.indentLess();
        else {
          var $ = m[0].anchor.line, X = g.visualBlock ? m[m.length - 1].anchor.line : m[0].head.line;
          d.linewise && X--;
          for (var E = $; E <= X; E++)
            for (var W = 0; W < b; W++)
              f.indentLine(E, d.indentRight);
        }
        return gn.moveToFirstNonWhiteSpaceCharacter(f, m[0].anchor);
      },
      indentAuto: function(f, d, m) {
        return f.execCommand("indentAuto"), gn.moveToFirstNonWhiteSpaceCharacter(f, m[0].anchor);
      },
      hardWrap: function(f, d, m, g) {
        if (!!f.hardWrap) {
          var b = m[0].anchor.line, x = m[0].head.line;
          d.linewise && x--;
          var M = f.hardWrap({
            from: b,
            to: x
          });
          return M > b && d.linewise && M--, d.keepCursor ? g : new e(M, 0);
        }
      },
      changeCase: function(f, d, m, g, b) {
        for (var x = f.getSelections(), M = [], A = d.toLower, E = 0; E < x.length; E++) {
          var I = x[E], _ = "";
          if (A === true)
            _ = I.toLowerCase();
          else if (A === false)
            _ = I.toUpperCase();
          else
            for (var W = 0; W < I.length; W++) {
              var H = I.charAt(W);
              _ += D(H) ? H.toLowerCase() : H.toUpperCase();
            }
          M.push(_);
        }
        return f.replaceSelections(M), d.shouldMoveCursor ? b : !f.state.vim.visualMode && d.linewise && m[0].anchor.line + 1 == m[0].head.line ? gn.moveToFirstNonWhiteSpaceCharacter(f, g) : d.linewise ? g : zt(m[0].anchor, m[0].head);
      },
      yank: function(f, d, m, g) {
        var b = f.state.vim, x = f.getSelection(), M = b.visualMode ? zt(b.sel.anchor, b.sel.head, m[0].head, m[0].anchor) : g;
        return V.registerController.pushText(d.registerName, "yank", x, d.linewise, b.visualBlock), M;
      },
      rot13: function(f, d, m, g, b) {
        for (var x = f.getSelections(), M = [], A = 0; A < x.length; A++) {
          const E = x[A].split("").map((I) => {
            const _ = I.charCodeAt(0);
            return _ >= 65 && _ <= 90 ? String.fromCharCode(65 + (_ - 65 + 13) % 26) : _ >= 97 && _ <= 122 ? String.fromCharCode(97 + (_ - 97 + 13) % 26) : I;
          }).join("");
          M.push(E);
        }
        return f.replaceSelections(M), d.shouldMoveCursor ? b : !f.state.vim.visualMode && d.linewise && m[0].anchor.line + 1 == m[0].head.line ? gn.moveToFirstNonWhiteSpaceCharacter(f, g) : d.linewise ? g : zt(m[0].anchor, m[0].head);
      }
    };
    function tg(f, d) {
      Zs[f] = d;
    }
    var lo = {
      jumpListWalk: function(f, d, m) {
        if (!m.visualMode) {
          var g = d.repeat || 1, b = d.forward, x = V.jumpList, M = x.move(f, b ? g : -g), A = M ? M.find() : void 0;
          A = A || f.getCursor(), f.setCursor(A);
        }
      },
      scroll: function(f, d, m) {
        if (!m.visualMode) {
          var g = d.repeat || 1, b = f.defaultTextHeight(), x = f.getScrollInfo().top, M = b * g, A = d.forward ? x + M : x - M, E = Fe(f.getCursor()), I = f.charCoords(E, "local");
          if (d.forward)
            A > I.top ? (E.line += (A - I.top) / b, E.line = Math.ceil(E.line), f.setCursor(E), I = f.charCoords(E, "local"), f.scrollTo(null, I.top)) : f.scrollTo(null, A);
          else {
            var _ = A + f.getScrollInfo().clientHeight;
            _ < I.bottom ? (E.line -= (I.bottom - _) / b, E.line = Math.floor(E.line), f.setCursor(E), I = f.charCoords(E, "local"), f.scrollTo(null, I.bottom - f.getScrollInfo().clientHeight)) : f.scrollTo(null, A);
          }
        }
      },
      scrollToCursor: function(f, d) {
        var m = f.getCursor().line, g = f.charCoords(new e(m, 0), "local"), b = f.getScrollInfo().clientHeight, x = g.top;
        switch (d.position) {
          case "center":
            x = g.bottom - b / 2;
            break;
          case "bottom":
            var M = new e(m, f.getLine(m).length - 1), A = f.charCoords(M, "local"), E = A.bottom - x;
            x = x - b + E;
            break;
        }
        f.scrollTo(null, x);
      },
      replayMacro: function(f, d, m) {
        var g = d.selectedCharacter || "", b = d.repeat || 1, x = V.macroModeState;
        for (g == "@" ? g = x.latestRegister || "" : x.latestRegister = g; b--; )
          fs(f, m, x, g);
      },
      enterMacroRecordMode: function(f, d) {
        var m = V.macroModeState, g = d.selectedCharacter;
        V.registerController.isValidRegister(g) && m.enterMacroRecordMode(f, g);
      },
      toggleOverwrite: function(f) {
        f.state.overwrite ? (f.toggleOverwrite(false), f.setOption("keyMap", "vim-insert"), t.signal(f, "vim-mode-change", {
          mode: "insert"
        })) : (f.toggleOverwrite(true), f.setOption("keyMap", "vim-replace"), t.signal(f, "vim-mode-change", {
          mode: "replace"
        }));
      },
      enterInsertMode: function(f, d, m) {
        if (!f.getOption("readOnly")) {
          m.insertMode = true, m.insertModeRepeat = d && d.repeat || 1;
          var g = d ? d.insertAt : null, b = m.sel, x = d.head || f.getCursor("head"), M = f.listSelections().length;
          if (g == "eol")
            x = new e(x.line, yt(f, x.line));
          else if (g == "bol")
            x = new e(x.line, 0);
          else if (g == "charAfter") {
            var A = n(f, x, ht(x, 0, 1));
            x = A.end;
          } else if (g == "firstNonBlank") {
            var A = n(f, x, gn.moveToFirstNonWhiteSpaceCharacter(f, x));
            x = A.end;
          } else if (g == "startOfSelectedArea") {
            if (!m.visualMode)
              return;
            m.visualBlock ? (x = new e(Math.min(b.head.line, b.anchor.line), Math.min(b.head.ch, b.anchor.ch)), M = Math.abs(b.head.line - b.anchor.line) + 1) : b.head.line < b.anchor.line ? x = b.head : x = new e(b.anchor.line, 0);
          } else if (g == "endOfSelectedArea") {
            if (!m.visualMode)
              return;
            m.visualBlock ? (x = new e(Math.min(b.head.line, b.anchor.line), Math.max(b.head.ch, b.anchor.ch) + 1), M = Math.abs(b.head.line - b.anchor.line) + 1) : b.head.line >= b.anchor.line ? x = ht(b.head, 0, 1) : x = new e(b.anchor.line, 0);
          } else if (g == "inplace") {
            if (m.visualMode)
              return;
          } else
            g == "lastEdit" && (x = Bf(f) || x);
          f.setOption("disableInput", false), d && d.replace ? (f.toggleOverwrite(true), f.setOption("keyMap", "vim-replace"), t.signal(f, "vim-mode-change", {
            mode: "replace"
          })) : (f.toggleOverwrite(false), f.setOption("keyMap", "vim-insert"), t.signal(f, "vim-mode-change", {
            mode: "insert"
          })), V.macroModeState.isPlaying || (f.on("change", Wl), m.insertEnd && m.insertEnd.clear(), m.insertEnd = f.setBookmark(x, {
            insertLeft: true
          }), t.on(f.getInputField(), "keydown", Hl)), m.visualMode && rr(f), Sf(f, x, M);
        }
      },
      toggleVisualMode: function(f, d, m) {
        var g = d.repeat, b = f.getCursor(), x;
        if (m.visualMode)
          m.visualLine != !!d.linewise || m.visualBlock != !!d.blockwise ? (m.visualLine = !!d.linewise, m.visualBlock = !!d.blockwise, t.signal(f, "vim-mode-change", {
            mode: "visual",
            subMode: m.visualLine ? "linewise" : m.visualBlock ? "blockwise" : ""
          }), co(f)) : rr(f);
        else {
          m.visualMode = true, m.visualLine = !!d.linewise, m.visualBlock = !!d.blockwise, x = $t(f, new e(b.line, b.ch + g - 1));
          var M = n(f, b, x);
          m.sel = {
            anchor: M.start,
            head: M.end
          }, t.signal(f, "vim-mode-change", {
            mode: "visual",
            subMode: m.visualLine ? "linewise" : m.visualBlock ? "blockwise" : ""
          }), co(f), An(f, m, "<", zt(b, x)), An(f, m, ">", Jr(b, x));
        }
      },
      reselectLastSelection: function(f, d, m) {
        var g = m.lastSelection;
        if (m.visualMode && nr(f, m), g) {
          var b = g.anchorMark.find(), x = g.headMark.find();
          if (!b || !x)
            return;
          m.sel = {
            anchor: b,
            head: x
          }, m.visualMode = true, m.visualLine = g.visualLine, m.visualBlock = g.visualBlock, co(f), An(f, m, "<", zt(b, x)), An(f, m, ">", Jr(b, x)), t.signal(f, "vim-mode-change", {
            mode: "visual",
            subMode: m.visualLine ? "linewise" : m.visualBlock ? "blockwise" : ""
          });
        }
      },
      joinLines: function(f, d, m) {
        var g, b;
        if (m.visualMode) {
          if (g = f.getCursor("anchor"), b = f.getCursor("head"), lt(b, g)) {
            var x = b;
            b = g, g = x;
          }
          b.ch = yt(f, b.line) - 1;
        } else {
          var M = Math.max(d.repeat, 2);
          g = f.getCursor(), b = $t(f, new e(g.line + M - 1, 1 / 0));
        }
        for (var A = 0, E = g.line; E < b.line; E++) {
          A = yt(f, g.line);
          var I = "", _ = 0;
          if (!d.keepSpaces) {
            var W = f.getLine(g.line + 1);
            _ = W.search(/\S/), _ == -1 ? _ = W.length : I = " ";
          }
          f.replaceRange(I, new e(g.line, A), new e(g.line + 1, _));
        }
        var H = $t(f, new e(g.line, A));
        m.visualMode && rr(f, false), f.setCursor(H);
      },
      newLineAndEnterInsertMode: function(f, d, m) {
        m.insertMode = true;
        var g = Fe(f.getCursor());
        if (g.line === f.firstLine() && !d.after)
          f.replaceRange(`
`, new e(f.firstLine(), 0)), f.setCursor(f.firstLine(), 0);
        else {
          g.line = d.after ? g.line : g.line - 1, g.ch = yt(f, g.line), f.setCursor(g);
          var b = t.commands.newlineAndIndentContinueComment || t.commands.newlineAndIndent;
          b(f);
        }
        this.enterInsertMode(f, {
          repeat: d.repeat
        }, m);
      },
      paste: function(f, d, m) {
        var g = V.registerController.getRegister(d.registerName);
        if (d.registerName === "+")
          navigator.clipboard.readText().then((x) => {
            this.continuePaste(f, d, m, x, g);
          });
        else {
          var b = g.toString();
          this.continuePaste(f, d, m, b, g);
        }
      },
      continuePaste: function(f, d, m, g, b) {
        var x = Fe(f.getCursor());
        if (!!g) {
          if (d.matchIndent) {
            var M = f.getOption("tabSize"), A = function(Gt) {
              var sr = Gt.split("	").length - 1, hs = Gt.split(" ").length - 1;
              return sr * M + hs * 1;
            }, E = f.getLine(f.getCursor().line), I = A(E.match(/^\s*/)[0]), _ = g.replace(/\n$/, ""), W = g !== _, H = A(g.match(/^\s*/)[0]), g = _.replace(/^\s*/gm, function(Gt) {
              var sr = I + (A(Gt) - H);
              if (sr < 0)
                return "";
              if (f.getOption("indentWithTabs")) {
                var hs = Math.floor(sr / M);
                return Array(hs + 1).join("	");
              } else
                return Array(sr + 1).join(" ");
            });
            g += W ? `
` : "";
          }
          d.repeat > 1 && (g = Array(d.repeat + 1).join(g));
          var j = b.linewise, $ = b.blockwise, X = $ ? g.split(`
`) : void 0;
          if (X) {
            j && X.pop();
            for (var Q = 0; Q < X.length; Q++)
              X[Q] = X[Q] == "" ? " " : X[Q];
            x.ch += d.after ? 1 : 0, x.ch = Math.min(yt(f, x.line), x.ch);
          } else
            j ? m.visualMode ? g = m.visualLine ? g.slice(0, -1) : `
` + g.slice(0, g.length - 1) + `
` : d.after ? (g = `
` + g.slice(0, g.length - 1), x.ch = yt(f, x.line)) : x.ch = 0 : x.ch += d.after ? 1 : 0;
          var xe;
          if (m.visualMode) {
            m.lastPastedText = g;
            var fe, Ae = og(f), Re = Ae[0], Pe = Ae[1], ct = f.getSelection(), dt = f.listSelections(), Ve = new Array(dt.length).join("1").split("1");
            m.lastSelection && (fe = m.lastSelection.headMark.find()), V.registerController.unnamedRegister.setText(ct), $ ? (f.replaceSelections(Ve), Pe = new e(Re.line + g.length - 1, Re.ch), f.setCursor(Re), xf(f, Pe), f.replaceSelections(g), xe = Re) : m.visualBlock ? (f.replaceSelections(Ve), f.setCursor(Re), f.replaceRange(g, Re, Re), xe = Re) : (f.replaceRange(g, Re, Pe), xe = f.posFromIndex(f.indexFromPos(Re) + g.length - 1)), fe && (m.lastSelection.headMark = f.setBookmark(fe)), j && (xe.ch = 0);
          } else if ($ && X) {
            f.setCursor(x);
            for (var Q = 0; Q < X.length; Q++) {
              var Me = x.line + Q;
              Me > f.lastLine() && f.replaceRange(`
`, new e(Me, 0));
              var et = yt(f, Me);
              et < x.ch && rg(f, Me, x.ch);
            }
            f.setCursor(x), xf(f, new e(x.line + X.length - 1, x.ch)), f.replaceSelections(X), xe = x;
          } else if (f.replaceRange(g, x), j) {
            var Me = d.after ? x.line + 1 : x.line;
            xe = new e(Me, ir(f.getLine(Me)));
          } else
            xe = Fe(x), /\n/.test(g) || (xe.ch += g.length - (d.after ? 1 : 0));
          m.visualMode && rr(f, false), f.setCursor(xe);
        }
      },
      undo: function(f, d) {
        f.operation(function() {
          bf(f, t.commands.undo, d.repeat)(), f.setCursor($t(f, f.getCursor("start")));
        });
      },
      redo: function(f, d) {
        bf(f, t.commands.redo, d.repeat)();
      },
      setRegister: function(f, d, m) {
        m.inputState.registerName = d.selectedCharacter;
      },
      insertRegister: function(f, d, m) {
        var g = d.selectedCharacter, b = V.registerController.getRegister(g), x = b && b.toString();
        x && f.replaceSelection(x);
      },
      oneNormalCommand: function(f, d, m) {
        Zr(f, true), m.insertModeReturn = true, t.on(f, "vim-command-done", function g() {
          m.visualMode || (m.insertModeReturn && (m.insertModeReturn = false, m.insertMode || lo.enterInsertMode(f, {}, m)), t.off(f, "vim-command-done", g));
        });
      },
      setMark: function(f, d, m) {
        var g = d.selectedCharacter;
        g && An(f, m, g, f.getCursor());
      },
      replace: function(f, d, m) {
        var g = d.selectedCharacter || "", b = f.getCursor(), x, M, A = f.listSelections();
        if (m.visualMode)
          b = f.getCursor("start"), M = f.getCursor("end");
        else {
          var E = f.getLine(b.line);
          x = b.ch + d.repeat, x > E.length && (x = E.length), M = new e(b.line, x);
        }
        var I = n(f, b, M);
        if (b = I.start, M = I.end, g == `
`)
          m.visualMode || f.replaceRange("", b, M), (t.commands.newlineAndIndentContinueComment || t.commands.newlineAndIndent)(f);
        else {
          var _ = f.getRange(b, M);
          if (_ = _.replace(/[\uD800-\uDBFF][\uDC00-\uDFFF]/g, g), _ = _.replace(/[^\n]/g, g), m.visualBlock) {
            var W = new Array(f.getOption("tabSize") + 1).join(" ");
            _ = f.getSelection(), _ = _.replace(/[\uD800-\uDBFF][\uDC00-\uDFFF]/g, g);
            var H = _.replace(/\t/g, W).replace(/[^\n]/g, g).split(`
`);
            f.replaceSelections(H);
          } else
            f.replaceRange(_, b, M);
          m.visualMode ? (b = lt(A[0].anchor, A[0].head) ? A[0].anchor : A[0].head, f.setCursor(b), rr(f, false)) : f.setCursor(ht(M, 0, -1));
        }
      },
      incrementNumberToken: function(f, d) {
        for (var m = f.getCursor(), g = f.getLine(m.line), b = /(-?)(?:(0x)([\da-f]+)|(0b|0|)(\d+))/gi, x, M, A, E; (x = b.exec(g)) !== null && (M = x.index, A = M + x[0].length, !(m.ch < A)); )
          ;
        if (!(!d.backtrack && A <= m.ch)) {
          if (x) {
            var I = x[2] || x[4], _ = x[3] || x[5], W = d.increase ? 1 : -1, H = {
              "0b": 2,
              0: 8,
              "": 10,
              "0x": 16
            }[I.toLowerCase()], j = parseInt(x[1] + _, H) + W * d.repeat;
            E = j.toString(H);
            var $ = I ? new Array(_.length - E.length + 1 + x[1].length).join("0") : "";
            E.charAt(0) === "-" ? E = "-" + I + $ + E.substr(1) : E = I + $ + E;
            var X = new e(m.line, M), Q = new e(m.line, A);
            f.replaceRange(E, X, Q);
          } else
            return;
          f.setCursor(new e(m.line, M + E.length - 1));
        }
      },
      repeatLastEdit: function(f, d, m) {
        var g = m.lastEditInputState;
        if (!!g) {
          var b = d.repeat;
          b && d.repeatIsExplicit ? g.repeatOverride = b : b = g.repeatOverride || b, Vf(f, m, b, false);
        }
      },
      indent: function(f, d) {
        f.indentLine(f.getCursor().line, d.indentRight);
      },
      exitInsertMode: function(f, d) {
        Zr(f);
      }
    };
    function ea(f, d) {
      lo[f] = d;
    }
    function $t(f, d, m) {
      var g = f.state.vim, b = g.insertMode || g.visualMode, x = Math.min(Math.max(f.firstLine(), d.line), f.lastLine()), M = f.getLine(x), A = M.length - 1 + Number(!!b), E = Math.min(Math.max(0, d.ch), A), I = M.charCodeAt(E);
      if (56320 <= I && I <= 57343) {
        var _ = 1;
        m && m.line == x && m.ch > E && (_ = -1), E += _, E > A && (E -= 2);
      }
      return new e(x, E);
    }
    function ss(f) {
      var d = {};
      for (var m in f)
        Object.prototype.hasOwnProperty.call(f, m) && (d[m] = f[m]);
      return d;
    }
    function ht(f, d, m) {
      return typeof d == "object" && (m = d.ch, d = d.line), new e(f.line + d, f.ch + m);
    }
    function vf(f, d, m, g) {
      g.operator && (m = "operatorPending");
      for (var b, x = [], M = [], A = re ? d.length - o : 0, E = A; E < d.length; E++) {
        var I = d[E];
        m == "insert" && I.context != "insert" || I.context && I.context != m || g.operator && I.type == "action" || !(b = yf(f, I.keys)) || (b == "partial" && x.push(I), b == "full" && M.push(I));
      }
      return {
        partial: x,
        full: M
      };
    }
    function yf(f, d) {
      const m = d.slice(-11) == "<character>", g = d.slice(-10) == "<register>";
      if (m || g) {
        var b = d.length - (m ? 11 : 10), x = f.slice(0, b), M = d.slice(0, b);
        return x == M && f.length > b ? "full" : M.indexOf(x) == 0 ? "partial" : false;
      } else
        return f == d ? "full" : d.indexOf(f) == 0 ? "partial" : false;
    }
    function ng(f) {
      var d = /^.*(<[^>]+>)$/.exec(f), m = d ? d[1] : f.slice(-1);
      if (m.length > 1)
        switch (m) {
          case "<CR>":
          case "<S-CR>":
            m = `
`;
            break;
          case "<Space>":
          case "<S-Space>":
            m = " ";
            break;
          default:
            m = "";
            break;
        }
      return m;
    }
    function bf(f, d, m) {
      return function() {
        for (var g = 0; g < m; g++)
          d(f);
      };
    }
    function Fe(f) {
      return new e(f.line, f.ch);
    }
    function qt(f, d) {
      return f.ch == d.ch && f.line == d.line;
    }
    function lt(f, d) {
      return f.line < d.line || f.line == d.line && f.ch < d.ch;
    }
    function zt(f, d) {
      return arguments.length > 2 && (d = zt.apply(void 0, Array.prototype.slice.call(arguments, 1))), lt(f, d) ? f : d;
    }
    function Jr(f, d) {
      return arguments.length > 2 && (d = Jr.apply(void 0, Array.prototype.slice.call(arguments, 1))), lt(f, d) ? d : f;
    }
    function _l2(f, d, m) {
      var g = lt(f, d), b = lt(d, m);
      return g && b;
    }
    function yt(f, d) {
      return f.getLine(d).length;
    }
    function Dl(f) {
      return f.trim ? f.trim() : f.replace(/^\s+|\s+$/g, "");
    }
    function Ri(f) {
      return f.replace(/([.?*+$\[\]\/\\(){}|\-])/g, "\\$1");
    }
    function rg(f, d, m) {
      var g = yt(f, d), b = new Array(m - g + 1).join(" ");
      f.setCursor(new e(d, g)), f.replaceRange(b, f.getCursor());
    }
    function xf(f, d) {
      var m = [], g = f.listSelections(), b = Fe(f.clipPos(d)), x = !qt(d, b), M = f.getCursor("head"), A = ig(g, M), E = qt(g[A].head, g[A].anchor), I = g.length - 1, _ = I - A > A ? I : 0, W = g[_].anchor, H = Math.min(W.line, b.line), j = Math.max(W.line, b.line), $ = W.ch, X = b.ch, Q = g[_].head.ch - $, xe = X - $;
      Q > 0 && xe <= 0 ? ($++, x || X--) : Q < 0 && xe >= 0 ? ($--, E || X++) : Q < 0 && xe == -1 && ($--, X++);
      for (var fe = H; fe <= j; fe++) {
        var Ae = {
          anchor: new e(fe, $),
          head: new e(fe, X)
        };
        m.push(Ae);
      }
      return f.setSelections(m), d.ch = X, W.ch = $, W;
    }
    function Sf(f, d, m) {
      for (var g = [], b = 0; b < m; b++) {
        var x = ht(d, b, 0);
        g.push({
          anchor: x,
          head: x
        });
      }
      f.setSelections(g, 0);
    }
    function ig(f, d, m) {
      for (var g = 0; g < f.length; g++) {
        var b = qt(f[g].anchor, d), x = qt(f[g].head, d);
        if (b || x)
          return g;
      }
      return -1;
    }
    function og(f, d) {
      var m = f.listSelections(), g = m[0], b = m[m.length - 1], x = lt(g.anchor, g.head) ? g.anchor : g.head, M = lt(b.anchor, b.head) ? b.head : b.anchor;
      return [
        x,
        M
      ];
    }
    function nr(f, d) {
      var m = d.sel.anchor, g = d.sel.head;
      d.lastPastedText && (g = f.posFromIndex(f.indexFromPos(m) + d.lastPastedText.length), d.lastPastedText = void 0), d.lastSelection = {
        anchorMark: f.setBookmark(m),
        headMark: f.setBookmark(g),
        anchor: Fe(m),
        head: Fe(g),
        visualMode: d.visualMode,
        visualLine: d.visualLine,
        visualBlock: d.visualBlock
      };
    }
    function sg(f, d, m, g) {
      var b = f.state.vim.sel, x = g ? d : b.head, M = g ? d : b.anchor, A;
      return lt(m, d) && (A = m, m = d, d = A), lt(x, M) ? (x = zt(d, x), M = Jr(M, m)) : (M = zt(d, M), x = Jr(x, m), x = ht(x, 0, -1), x.ch == -1 && x.line != f.firstLine() && (x = new e(x.line - 1, yt(f, x.line - 1)))), [
        M,
        x
      ];
    }
    function co(f, d, m) {
      var g = f.state.vim;
      d = d || g.sel, m || (m = g.visualLine ? "line" : g.visualBlock ? "block" : "char");
      var b = Il(f, d, m);
      f.setSelections(b.ranges, b.primary);
    }
    function Il(f, d, m, g) {
      var b = Fe(d.head), x = Fe(d.anchor);
      if (m == "char") {
        var M = !g && !lt(d.head, d.anchor) ? 1 : 0, A = lt(d.head, d.anchor) ? 1 : 0;
        return b = ht(d.head, 0, M), x = ht(d.anchor, 0, A), {
          ranges: [
            {
              anchor: x,
              head: b
            }
          ],
          primary: 0
        };
      } else if (m == "line") {
        if (lt(d.head, d.anchor))
          b.ch = 0, x.ch = yt(f, x.line);
        else {
          x.ch = 0;
          var E = f.lastLine();
          b.line > E && (b.line = E), b.ch = yt(f, b.line);
        }
        return {
          ranges: [
            {
              anchor: x,
              head: b
            }
          ],
          primary: 0
        };
      } else if (m == "block") {
        var I = Math.min(x.line, b.line), _ = x.ch, W = Math.max(x.line, b.line), H = b.ch;
        _ < H ? H += 1 : _ += 1;
        for (var j = W - I + 1, $ = b.line == I ? 0 : j - 1, X = [], Q = 0; Q < j; Q++)
          X.push({
            anchor: new e(I + Q, _),
            head: new e(I + Q, H)
          });
        return {
          ranges: X,
          primary: $
        };
      }
      throw "never happens";
    }
    function ag(f) {
      var d = f.getCursor("head");
      return f.getSelection().length == 1 && (d = zt(d, f.getCursor("anchor"))), d;
    }
    function rr(f, d) {
      var m = f.state.vim;
      d !== false && f.setCursor($t(f, m.sel.head)), nr(f, m), m.visualMode = false, m.visualLine = false, m.visualBlock = false, m.insertMode || t.signal(f, "vim-mode-change", {
        mode: "normal"
      });
    }
    function uo(f, d, m) {
      var g = f.getRange(d, m);
      if (/\n\s*$/.test(g)) {
        var b = g.split(`
`);
        b.pop();
        for (var x = b.pop(); b.length > 0 && x && R(x); x = b.pop())
          m.line--, m.ch = 0;
        x ? (m.line--, m.ch = yt(f, m.line)) : m.ch = 0;
      }
    }
    function lg(f, d, m) {
      d.ch = 0, m.ch = 0, m.line++;
    }
    function ir(f) {
      if (!f)
        return 0;
      var d = f.search(/\S/);
      return d == -1 ? f.length : d;
    }
    function Bl(f, { inclusive: d, innerWord: m, bigWord: g, noSymbol: b, multiline: x }, M) {
      var A = M || ag(f), E = f.getLine(A.line), I = E, _ = A.line, W = _, H = A.ch, j, $ = b ? p[0] : v[0];
      if (m && /\s/.test(E.charAt(H)))
        $ = function(Re) {
          return /\s/.test(Re);
        };
      else {
        for (; !$(E.charAt(H)); )
          if (H++, H >= E.length) {
            if (!x)
              return null;
            H--, j = Cf(f, A, true, g, true);
            break;
          }
        g ? $ = v[0] : ($ = p[0], $(E.charAt(H)) || ($ = p[1]));
      }
      for (var X = H, Q = H; $(E.charAt(Q)) && Q >= 0; )
        Q--;
      if (Q++, j)
        X = j.to, W = j.line, I = f.getLine(W), !I && X == 0 && X++;
      else
        for (; $(E.charAt(X)) && X < E.length; )
          X++;
      if (d) {
        var xe = X, fe = A.ch <= Q && /\s/.test(E.charAt(A.ch));
        if (!fe)
          for (; /\s/.test(I.charAt(X)) && X < I.length; )
            X++;
        if (xe == X || fe) {
          for (var Ae = Q; /\s/.test(E.charAt(Q - 1)) && Q > 0; )
            Q--;
          !Q && !fe && (Q = Ae);
        }
      }
      return {
        start: new e(_, Q),
        end: new e(W, X)
      };
    }
    function cg(f, d, m) {
      var g = d;
      if (!t.findMatchingTag || !t.findEnclosingTag)
        return {
          start: g,
          end: g
        };
      var b = t.findMatchingTag(f, d) || t.findEnclosingTag(f, d);
      return !b || !b.open || !b.close ? {
        start: g,
        end: g
      } : m ? {
        start: b.open.from,
        end: b.close.to
      } : {
        start: b.open.to,
        end: b.close.from
      };
    }
    function wf(f, d, m) {
      qt(d, m) || V.jumpList.add(f, d, m);
    }
    function _i2(f, d) {
      V.lastCharacterSearch.increment = f, V.lastCharacterSearch.forward = d.forward, V.lastCharacterSearch.selectedCharacter = d.selectedCharacter;
    }
    var ug = {
      "(": "bracket",
      ")": "bracket",
      "{": "bracket",
      "}": "bracket",
      "[": "section",
      "]": "section",
      "*": "comment",
      "/": "comment",
      m: "method",
      M: "method",
      "#": "preprocess"
    }, kf = {
      bracket: {
        isComplete: function(f) {
          if (f.nextCh === f.symb) {
            if (f.depth++, f.depth >= 1)
              return true;
          } else
            f.nextCh === f.reverseSymb && f.depth--;
          return false;
        }
      },
      section: {
        init: function(f) {
          f.curMoveThrough = true, f.symb = (f.forward ? "]" : "[") === f.symb ? "{" : "}";
        },
        isComplete: function(f) {
          return f.index === 0 && f.nextCh === f.symb;
        }
      },
      comment: {
        isComplete: function(f) {
          var d = f.lastCh === "*" && f.nextCh === "/";
          return f.lastCh = f.nextCh, d;
        }
      },
      method: {
        init: function(f) {
          f.symb = f.symb === "m" ? "{" : "}", f.reverseSymb = f.symb === "{" ? "}" : "{";
        },
        isComplete: function(f) {
          return f.nextCh === f.symb;
        }
      },
      preprocess: {
        init: function(f) {
          f.index = 0;
        },
        isComplete: function(f) {
          var _a3;
          if (f.nextCh === "#") {
            var d = (_a3 = f.lineText.match(/^#(\w+)/)) == null ? void 0 : _a3[1];
            if (d === "endif") {
              if (f.forward && f.depth === 0)
                return true;
              f.depth++;
            } else if (d === "if") {
              if (!f.forward && f.depth === 0)
                return true;
              f.depth--;
            }
            if (d === "else" && f.depth === 0)
              return true;
          }
          return false;
        }
      }
    };
    function fg(f, d, m, g) {
      var b = Fe(f.getCursor()), x = m ? 1 : -1, M = m ? f.lineCount() : -1, A = b.ch, E = b.line, I = f.getLine(E), _ = {
        lineText: I,
        nextCh: I.charAt(A),
        lastCh: null,
        index: A,
        symb: g,
        reverseSymb: (m ? {
          ")": "(",
          "}": "{"
        } : {
          "(": ")",
          "{": "}"
        })[g],
        forward: m,
        depth: 0,
        curMoveThrough: false
      }, W = ug[g];
      if (!W)
        return b;
      var H = kf[W].init, j = kf[W].isComplete;
      for (H && H(_); E !== M && d; ) {
        if (_.index += x, _.nextCh = _.lineText.charAt(_.index), !_.nextCh) {
          if (E += x, _.lineText = f.getLine(E) || "", x > 0)
            _.index = 0;
          else {
            var $ = _.lineText.length;
            _.index = $ > 0 ? $ - 1 : 0;
          }
          _.nextCh = _.lineText.charAt(_.index);
        }
        j(_) && (b.line = E, b.ch = _.index, d--);
      }
      return _.nextCh || _.curMoveThrough ? new e(E, _.index) : b;
    }
    function Cf(f, d, m, g, b) {
      var x = d.line, M = d.ch, A = f.getLine(x), E = m ? 1 : -1, I = g ? v : p;
      if (b && A == "") {
        if (x += E, A = f.getLine(x), !k(f, x))
          return null;
        M = m ? 0 : A.length;
      }
      for (; ; ) {
        if (b && A == "")
          return {
            from: 0,
            to: 0,
            line: x
          };
        for (var _ = E > 0 ? A.length : -1, W = _, H = _; M != _; ) {
          for (var j = false, $ = 0; $ < I.length && !j; ++$)
            if (I[$](A.charAt(M))) {
              for (W = M; M != _ && I[$](A.charAt(M)); )
                M += E;
              if (H = M, j = W != H, W == d.ch && x == d.line && H == W + E)
                continue;
              return {
                from: Math.min(W, H + 1),
                to: Math.max(W, H),
                line: x
              };
            }
          j || (M += E);
        }
        if (x += E, !k(f, x))
          return null;
        A = f.getLine(x), M = E > 0 ? 0 : A.length;
      }
    }
    function hg(f, d, m, g, b, x) {
      var M = Fe(d), A = [];
      (g && !b || !g && b) && m++;
      for (var E = !(g && b), I = 0; I < m; I++) {
        var _ = Cf(f, d, g, x, E);
        if (!_) {
          var W = yt(f, f.lastLine());
          A.push(g ? {
            line: f.lastLine(),
            from: W,
            to: W
          } : {
            line: 0,
            from: 0,
            to: 0
          });
          break;
        }
        A.push(_), d = new e(_.line, g ? _.to - 1 : _.from);
      }
      var H = A.length != m, j = A[0], $ = A.pop();
      return g && !b ? (!H && (j.from != M.ch || j.line != M.line) && ($ = A.pop()), $ && new e($.line, $.from)) : g && b ? $ && new e($.line, $.to - 1) : !g && b ? (!H && (j.to != M.ch || j.line != M.line) && ($ = A.pop()), $ && new e($.line, $.to)) : $ && new e($.line, $.from);
    }
    function Tf(f, d, m, g, b) {
      var x = d, M = new e(x.line + m.repeat - 1, 1 / 0), A = f.clipPos(M);
      return A.ch--, b || (g.lastHPos = 1 / 0, g.lastHSPos = f.charCoords(A, "div").left), M;
    }
    function as(f, d, m, g, b) {
      if (!!g) {
        for (var x = b || f.getCursor(), M = x.ch, A, E = 0; E < d; E++) {
          var I = f.getLine(x.line);
          if (A = Nl(M, I, g, m), A == -1)
            return;
          M = A;
        }
        if (A != null)
          return new e(f.getCursor().line, A);
      }
    }
    function dg(f, d) {
      var m = f.getCursor().line;
      return $t(f, new e(m, d - 1));
    }
    function An(f, d, m, g) {
      !K(m, y) && !T.test(m) || (d.marks[m] && d.marks[m].clear(), d.marks[m] = f.setBookmark(g));
    }
    function Nl(f, d, m, g, b) {
      var x;
      return g ? x = d.indexOf(m, f + 1) : x = d.lastIndexOf(m, f - 1), x;
    }
    function Mf(f, d, m, g, b) {
      var x = d.line, M = f.firstLine(), A = f.lastLine(), E, I, _ = x;
      function W(Q) {
        return !f.getLine(Q);
      }
      function H(Q, xe, fe) {
        return fe ? W(Q) != W(Q + xe) : !W(Q) && W(Q + xe);
      }
      if (g) {
        for (; M <= _ && _ <= A && m > 0; )
          H(_, g) && m--, _ += g;
        return {
          start: new e(_, 0),
          end: d
        };
      }
      var j = f.state.vim;
      if (j.visualLine && H(x, 1, true)) {
        var $ = j.sel.anchor;
        H($.line, -1, true) && (!b || $.line != x) && (x += 1);
      }
      var X = W(x);
      for (_ = x; _ <= A && m; _++)
        H(_, 1, true) && (!b || W(_) != X) && m--;
      for (I = new e(_, 0), _ > A && !X ? X = true : b = false, _ = x; _ > M && !((!b || W(_) == X || _ == x) && H(_, -1, true)); _--)
        ;
      return E = new e(_, 0), {
        start: E,
        end: I
      };
    }
    function ls(f, d, m, g, b) {
      function x(I) {
        I.line !== null && (I.pos + I.dir < 0 || I.pos + I.dir >= I.line.length ? I.line = null : I.pos += I.dir);
      }
      function M(I, _, W, H) {
        var j = I.getLine(_), $ = {
          line: j,
          ln: _,
          pos: W,
          dir: H
        };
        if ($.line === "")
          return {
            ln: $.ln,
            pos: $.pos
          };
        var X = $.pos;
        for (x($); $.line !== null; ) {
          if (X = $.pos, F($.line[$.pos]))
            if (b) {
              for (x($); $.line !== null && R($.line[$.pos]); )
                X = $.pos, x($);
              return {
                ln: $.ln,
                pos: X + 1
              };
            } else
              return {
                ln: $.ln,
                pos: $.pos + 1
              };
          x($);
        }
        return {
          ln: $.ln,
          pos: X + 1
        };
      }
      function A(I, _, W, H) {
        var j = I.getLine(_), $ = {
          line: j,
          ln: _,
          pos: W,
          dir: H
        };
        if ($.line === "")
          return {
            ln: $.ln,
            pos: $.pos
          };
        var X = $.pos;
        for (x($); $.line !== null; ) {
          if (!R($.line[$.pos]) && !F($.line[$.pos]))
            X = $.pos;
          else if (F($.line[$.pos]))
            return b ? R($.line[$.pos + 1]) ? {
              ln: $.ln,
              pos: $.pos + 1
            } : {
              ln: $.ln,
              pos: X
            } : {
              ln: $.ln,
              pos: X
            };
          x($);
        }
        return $.line = j, b && R($.line[$.pos]) ? {
          ln: $.ln,
          pos: $.pos
        } : {
          ln: $.ln,
          pos: X
        };
      }
      for (var E = {
        ln: d.line,
        pos: d.ch
      }; m > 0; )
        g < 0 ? E = A(f, E.ln, E.pos, g) : E = M(f, E.ln, E.pos, g), m--;
      return new e(E.ln, E.pos);
    }
    function Af(f, d, m, g) {
      function b(E, I) {
        if (I.line !== null)
          if (I.pos + I.dir < 0 || I.pos + I.dir >= I.line.length) {
            if (I.ln += I.dir, !k(E, I.ln)) {
              I.line = null;
              return;
            }
            I.line = E.getLine(I.ln), I.pos = I.dir > 0 ? 0 : I.line.length - 1;
          } else
            I.pos += I.dir;
      }
      function x(E, I, _, W) {
        var Q = E.getLine(I), H = Q === "", j = {
          line: Q,
          ln: I,
          pos: _,
          dir: W
        }, $ = {
          ln: j.ln,
          pos: j.pos
        }, X = j.line === "";
        for (b(E, j); j.line !== null; ) {
          if ($.ln = j.ln, $.pos = j.pos, j.line === "" && !X)
            return {
              ln: j.ln,
              pos: j.pos
            };
          if (H && j.line !== "" && !R(j.line[j.pos]))
            return {
              ln: j.ln,
              pos: j.pos
            };
          F(j.line[j.pos]) && !H && (j.pos === j.line.length - 1 || R(j.line[j.pos + 1])) && (H = true), b(E, j);
        }
        var Q = E.getLine($.ln);
        $.pos = 0;
        for (var xe = Q.length - 1; xe >= 0; --xe)
          if (!R(Q[xe])) {
            $.pos = xe;
            break;
          }
        return $;
      }
      function M(E, I, _, W) {
        var Q = E.getLine(I), H = {
          line: Q,
          ln: I,
          pos: _,
          dir: W
        }, j = H.ln, $ = null, X = H.line === "";
        for (b(E, H); H.line !== null; ) {
          if (H.line === "" && !X)
            return $ !== null ? {
              ln: j,
              pos: $
            } : {
              ln: H.ln,
              pos: H.pos
            };
          if (F(H.line[H.pos]) && $ !== null && !(H.ln === j && H.pos + 1 === $))
            return {
              ln: j,
              pos: $
            };
          H.line !== "" && !R(H.line[H.pos]) && (X = false, j = H.ln, $ = H.pos), b(E, H);
        }
        var Q = E.getLine(j);
        $ = 0;
        for (var xe = 0; xe < Q.length; ++xe)
          if (!R(Q[xe])) {
            $ = xe;
            break;
          }
        return {
          ln: j,
          pos: $
        };
      }
      for (var A = {
        ln: d.line,
        pos: d.ch
      }; m > 0; )
        g < 0 ? A = M(f, A.ln, A.pos, g) : A = x(f, A.ln, A.pos, g), m--;
      return new e(A.ln, A.pos);
    }
    function Ef(f, d, m, g) {
      var b = d, x = {
        "(": /[()]/,
        ")": /[()]/,
        "[": /[[\]]/,
        "]": /[[\]]/,
        "{": /[{}]/,
        "}": /[{}]/,
        "<": /[<>]/,
        ">": /[<>]/
      }[m], M = {
        "(": "(",
        ")": "(",
        "[": "[",
        "]": "[",
        "{": "{",
        "}": "{",
        "<": "<",
        ">": "<"
      }[m], A = f.getLine(b.line).charAt(b.ch), E = A === M ? 1 : 0, I = f.scanForBracket(new e(b.line, b.ch + E), -1, void 0, {
        bracketRegex: x
      }), _ = f.scanForBracket(new e(b.line, b.ch + E), 1, void 0, {
        bracketRegex: x
      });
      if (!I || !_)
        return null;
      var W = I.pos, H = _.pos;
      if (W.line == H.line && W.ch > H.ch || W.line > H.line) {
        var j = W;
        W = H, H = j;
      }
      return g ? H.ch += 1 : W.ch += 1, {
        start: W,
        end: H
      };
    }
    function pg(f, d, m, g) {
      var b = Fe(d), x = f.getLine(b.line), M = x.split(""), A, E, I, _, W = M.indexOf(m);
      if (b.ch < W)
        b.ch = W;
      else if (W < b.ch && M[b.ch] == m) {
        var H = /string/.test(f.getTokenTypeAt(ht(d, 0, 1))), j = /string/.test(f.getTokenTypeAt(d)), $ = H && !j;
        $ || (E = b.ch, --b.ch);
      }
      if (M[b.ch] == m && !E)
        A = b.ch + 1;
      else
        for (I = b.ch; I > -1 && !A; I--)
          M[I] == m && (A = I + 1);
      if (A && !E)
        for (I = A, _ = M.length; I < _ && !E; I++)
          M[I] == m && (E = I);
      return !A || !E ? {
        start: b,
        end: b
      } : (g && (--A, ++E), {
        start: new e(b.line, A),
        end: new e(b.line, E)
      });
    }
    te("pcre", true, "boolean");
    class mg {
      constructor() {
        this.highlightTimeout;
      }
      getQuery() {
        return V.query;
      }
      setQuery(d) {
        V.query = d;
      }
      getOverlay() {
        return this.searchOverlay;
      }
      setOverlay(d) {
        this.searchOverlay = d;
      }
      isReversed() {
        return V.isReversed;
      }
      setReversed(d) {
        V.isReversed = d;
      }
      getScrollbarAnnotate() {
        return this.annotate;
      }
      setScrollbarAnnotate(d) {
        this.annotate = d;
      }
    }
    function En(f) {
      var d = f.state.vim;
      return d.searchState_ || (d.searchState_ = new mg());
    }
    function gg(f) {
      return Pf(f, "/");
    }
    function vg(f) {
      return Of(f, "/");
    }
    function Pf(f, d) {
      var m = Of(f, d) || [];
      if (!m.length)
        return [];
      var g = [];
      if (m[0] === 0) {
        for (var b = 0; b < m.length; b++)
          typeof m[b] == "number" && g.push(f.substring(m[b] + 1, m[b + 1]));
        return g;
      }
    }
    function Of(f, d) {
      d || (d = "/");
      for (var m = false, g = [], b = 0; b < f.length; b++) {
        var x = f.charAt(b);
        !m && x == d && g.push(b), m = !m && x == "\\";
      }
      return g;
    }
    function yg(f) {
      var d = {
        V: "|(){+?*.[$^",
        M: "|(){+?*.[",
        m: "|(){+?",
        v: "<>"
      }, m = {
        ">": "(?<=[\\w])(?=[^\\w]|$)",
        "<": "(?<=[^\\w]|^)(?=[\\w])"
      }, g = d.m, b = f.replace(/\\.|[\[|(){+*?.$^<>]/g, function(M) {
        if (M[0] === "\\") {
          var A = M[1];
          return A === "}" || g.indexOf(A) != -1 ? A : A in d ? (g = d[A], "") : A in m ? m[A] : M;
        } else
          return g.indexOf(M) != -1 ? m[M] || "\\" + M : M;
      }), x = b.indexOf("\\zs");
      return x != -1 && (b = "(?<=" + b.slice(0, x) + ")" + b.slice(x + 3)), x = b.indexOf("\\ze"), x != -1 && (b = b.slice(0, x) + "(?=" + b.slice(x + 3) + ")"), b;
    }
    var Lf = {
      "\\n": `
`,
      "\\r": "\r",
      "\\t": "	"
    };
    function bg(f) {
      for (var d = false, m = [], g = -1; g < f.length; g++) {
        var b = f.charAt(g) || "", x = f.charAt(g + 1) || "";
        Lf[b + x] ? (m.push(Lf[b + x]), g++) : d ? (m.push(b), d = false) : b === "\\" ? (d = true, L(x) || x === "$" ? m.push("$") : x !== "/" && x !== "\\" && m.push("\\")) : (b === "$" && m.push("$"), m.push(b), x === "/" && m.push("\\"));
      }
      return m.join("");
    }
    var Rf = {
      "\\/": "/",
      "\\\\": "\\",
      "\\n": `
`,
      "\\r": "\r",
      "\\t": "	",
      "\\&": "&"
    };
    function xg(f) {
      for (var d = new t.StringStream(f), m = []; !d.eol(); ) {
        for (; d.peek() && d.peek() != "\\"; )
          m.push(d.next());
        var g = false;
        for (var b in Rf)
          if (d.match(b, true)) {
            g = true, m.push(Rf[b]);
            break;
          }
        g || m.push(d.next());
      }
      return m.join("");
    }
    function _f2(f, d, m) {
      var g = V.registerController.getRegister("/");
      g.setText(f);
      var b = vg(f), x, M;
      if (!b.length)
        x = f;
      else {
        x = f.substring(0, b[0]);
        var A = f.substring(b[0]);
        M = A.indexOf("i") != -1;
      }
      if (!x)
        return null;
      ae("pcre") || (x = yg(x)), m && (d = /^[^A-Z]*$/.test(x));
      var E = new RegExp(x, d || M ? "im" : "m");
      return E;
    }
    function sn(f) {
      typeof f == "string" && (f = document.createElement(f));
      for (var d = 1; d < arguments.length; d++) {
        var m = arguments[d];
        if (!!m)
          if (typeof m != "object" && (m = document.createTextNode(m)), m.nodeType)
            f.appendChild(m);
          else
            for (var g in m)
              !Object.prototype.hasOwnProperty.call(m, g) || (g[0] === "$" ? f.style[g.slice(1)] = m[g] : typeof m[g] == "function" ? f[g] = m[g] : f.setAttribute(g, m[g]));
      }
      return f;
    }
    function Ie(f, d, m) {
      var g = sn("div", {
        $color: "red",
        $whiteSpace: "pre",
        class: "cm-vim-message"
      }, d);
      f.openNotification ? m ? (g = sn("div", {}, g, sn("div", {}, "Press ENTER or type command to continue")), f.state.closeVimNotification && f.state.closeVimNotification(), f.state.closeVimNotification = f.openNotification(g, {
        bottom: true,
        duration: 0
      })) : f.openNotification(g, {
        bottom: true,
        duration: 15e3
      }) : alert(g.innerText);
    }
    function Sg(f, d) {
      return sn("div", {
        $display: "flex",
        $flex: 1
      }, sn("span", {
        $fontFamily: "monospace",
        $whiteSpace: "pre",
        $flex: 1,
        $display: "flex"
      }, f, sn("input", {
        type: "text",
        autocorrect: "off",
        autocapitalize: "off",
        spellcheck: "false",
        $flex: 1
      })), d && sn("span", {
        $color: "#888"
      }, d));
    }
    function ta(f, d) {
      var _a3;
      if (le.length) {
        d.value || (d.value = ""), se = d;
        return;
      }
      var m = Sg(d.prefix, d.desc);
      if (f.openDialog)
        f.openDialog(m, d.onClose, {
          onKeyDown: d.onKeyDown,
          onKeyUp: d.onKeyUp,
          bottom: true,
          selectValueOnOpen: false,
          value: d.value
        });
      else {
        var g = "";
        typeof d.prefix != "string" && d.prefix && (g += d.prefix.textContent), d.desc && (g += " " + d.desc), (_a3 = d.onClose) == null ? void 0 : _a3.call(d, prompt(g, ""));
      }
    }
    function Df(f, d) {
      return f instanceof RegExp && d instanceof RegExp ? f.flags == d.flags && f.source == d.source : false;
    }
    function cs(f, d, m, g) {
      if (!!d) {
        var b = En(f), x = _f2(d, !!m, !!g);
        if (!!x)
          return na(f, x), Df(x, b.getQuery()) || b.setQuery(x), x;
      }
    }
    function wg(f) {
      if (f.source.charAt(0) == "^")
        var d = true;
      return {
        token: function(m) {
          if (d && !m.sol()) {
            m.skipToEnd();
            return;
          }
          var g = m.match(f, false);
          if (g)
            return g[0].length == 0 ? (m.next(), "searching") : !m.sol() && (m.backUp(1), !f.exec(m.next() + g[0])) ? (m.next(), null) : (m.match(f), "searching");
          for (; !m.eol() && (m.next(), !m.match(f, false)); )
            ;
        },
        query: f
      };
    }
    var us = 0;
    function na(f, d) {
      clearTimeout(us);
      var m = En(f);
      m.highlightTimeout = us, us = setTimeout(function() {
        if (!!f.state.vim) {
          var g = En(f);
          g.highlightTimeout = void 0;
          var b = g.getOverlay();
          (!b || d != b.query) && (b && f.removeOverlay(b), b = wg(d), f.addOverlay(b), f.showMatchesOnScrollbar && (g.getScrollbarAnnotate() && g.getScrollbarAnnotate().clear(), g.setScrollbarAnnotate(f.showMatchesOnScrollbar(d))), g.setOverlay(b));
        }
      }, 50);
    }
    function If(f, d, m, g) {
      return f.operation(function() {
        g === void 0 && (g = 1);
        for (var b = f.getCursor(), x = f.getSearchCursor(m, b), M = 0; M < g; M++) {
          var A = x.find(d);
          if (M == 0 && A && qt(x.from(), b)) {
            var E = d ? x.from() : x.to();
            A = x.find(d), A && !A[0] && qt(x.from(), E) && f.getLine(E.line).length == E.ch && (A = x.find(d));
          }
          if (!A && (x = f.getSearchCursor(m, d ? new e(f.lastLine()) : new e(f.firstLine(), 0)), !x.find(d)))
            return;
        }
        return x.from();
      });
    }
    function kg(f, d, m, g, b) {
      return f.operation(function() {
        g === void 0 && (g = 1);
        var x = f.getCursor(), M = f.getSearchCursor(m, x), A = M.find(!d);
        !b.visualMode && A && qt(M.from(), x) && M.find(!d);
        for (var E = 0; E < g; E++)
          if (A = M.find(d), !A && (M = f.getSearchCursor(m, d ? new e(f.lastLine()) : new e(f.firstLine(), 0)), !M.find(d)))
            return;
        var I = M.from(), _ = M.to();
        return I && _ && [
          I,
          _
        ];
      });
    }
    function fo(f) {
      var d = En(f);
      d.highlightTimeout && (clearTimeout(d.highlightTimeout), d.highlightTimeout = void 0), f.removeOverlay(En(f).getOverlay()), d.setOverlay(null), d.getScrollbarAnnotate() && (d.getScrollbarAnnotate().clear(), d.setScrollbarAnnotate(null));
    }
    function $l(f, d, m) {
      return typeof f != "number" && (f = f.line), d instanceof Array ? K(f, d) : typeof m == "number" ? f >= d && f <= m : f == d;
    }
    function zl(f) {
      var d = f.getScrollInfo(), m = 6, g = 10, b = f.coordsChar({
        left: 0,
        top: m + d.top
      }, "local"), x = d.clientHeight - g + d.top, M = f.coordsChar({
        left: 0,
        top: x
      }, "local");
      return {
        top: b.line,
        bottom: M.line
      };
    }
    function ra(f, d, m) {
      if (m == "'" || m == "`")
        return V.jumpList.find(f, -1) || new e(0, 0);
      if (m == ".")
        return Bf(f);
      var g = d.marks[m];
      return g && g.find();
    }
    function Bf(f) {
      if (f.getLastEditEnd)
        return f.getLastEditEnd();
      for (var d = f.doc.history.done, m = d.length; m--; )
        if (d[m].changes)
          return Fe(d[m].changes[0].to);
    }
    class ia {
      constructor() {
        this.commandMap_, this.buildCommandMap_();
      }
      processCommand(d, m, g) {
        var b = this;
        d.operation(function() {
          d.curOp && (d.curOp.isVimOp = true), b._processCommand(d, m, g);
        });
      }
      _processCommand(d, m, g) {
        var b = d.state.vim, x = V.registerController.getRegister(":"), M = x.toString(), A = new t.StringStream(m);
        x.setText(m);
        var E = g || {};
        E.input = m;
        try {
          this.parseInput_(d, A, E);
        } catch (W) {
          throw Ie(d, W + ""), W;
        }
        b.visualMode && rr(d);
        var I, _;
        if (!E.commandName)
          E.line !== void 0 && (_ = "move");
        else if (I = this.matchCommand_(E.commandName), I) {
          if (_ = I.name, I.excludeFromCommandHistory && x.setText(M), this.parseCommandArgs_(A, E, I), I.type == "exToKey") {
            vt(d, I.toKeys || "", I);
            return;
          } else if (I.type == "exToEx") {
            this.processCommand(d, I.toInput || "");
            return;
          }
        }
        if (!_) {
          Ie(d, 'Not an editor command ":' + m + '"');
          return;
        }
        try {
          oa[_](d, E), (!I || !I.possiblyAsync) && E.callback && E.callback();
        } catch (W) {
          throw Ie(d, W + ""), W;
        }
      }
      parseInput_(d, m, g) {
        var _a3, _b3;
        m.eatWhile(":"), m.eat("%") ? (g.line = d.firstLine(), g.lineEnd = d.lastLine()) : (g.line = this.parseLineSpec_(d, m), g.line !== void 0 && m.eat(",") && (g.lineEnd = this.parseLineSpec_(d, m))), g.line == null ? d.state.vim.visualMode ? (g.selectionLine = (_a3 = ra(d, d.state.vim, "<")) == null ? void 0 : _a3.line, g.selectionLineEnd = (_b3 = ra(d, d.state.vim, ">")) == null ? void 0 : _b3.line) : g.selectionLine = d.getCursor().line : (g.selectionLine = g.line, g.selectionLineEnd = g.lineEnd);
        var b = m.match(/^(\w+|!!|@@|[!#&*<=>@~])/);
        return b ? g.commandName = b[1] : g.commandName = (m.match(/.*/) || [
          ""
        ])[0], g;
      }
      parseLineSpec_(d, m) {
        var g = m.match(/^(\d+)/);
        if (g)
          return parseInt(g[1], 10) - 1;
        switch (m.next()) {
          case ".":
            return this.parseLineSpecOffset_(m, d.getCursor().line);
          case "$":
            return this.parseLineSpecOffset_(m, d.lastLine());
          case "'":
            var b = m.next() || "", x = ra(d, d.state.vim, b);
            if (!x)
              throw new Error("Mark not set");
            return this.parseLineSpecOffset_(m, x.line);
          case "-":
          case "+":
            return m.backUp(1), this.parseLineSpecOffset_(m, d.getCursor().line);
          default:
            m.backUp(1);
            return;
        }
      }
      parseLineSpecOffset_(d, m) {
        var g = d.match(/^([+-])?(\d+)/);
        if (g) {
          var b = parseInt(g[2], 10);
          g[1] == "-" ? m -= b : m += b;
        }
        return m;
      }
      parseCommandArgs_(d, m, g) {
        var _a3;
        if (!d.eol()) {
          m.argString = (_a3 = d.match(/.*/)) == null ? void 0 : _a3[0];
          var b = g.argDelimiter || /\s+/, x = Dl(m.argString || "").split(b);
          x.length && x[0] && (m.args = x);
        }
      }
      matchCommand_(d) {
        for (var m = d.length; m > 0; m--) {
          var g = d.substring(0, m);
          if (this.commandMap_[g]) {
            var b = this.commandMap_[g];
            if (b.name.indexOf(d) === 0)
              return b;
          }
        }
      }
      buildCommandMap_() {
        this.commandMap_ = {};
        for (var d = 0; d < s.length; d++) {
          var m = s[d], g = m.shortName || m.name;
          this.commandMap_[g] = m;
        }
      }
      map(d, m, g, b) {
        if (d != ":" && d.charAt(0) == ":") {
          if (g)
            throw Error("Mode not supported for ex mappings");
          var x = d.substring(1);
          m != ":" && m.charAt(0) == ":" ? this.commandMap_[x] = {
            name: x,
            type: "exToEx",
            toInput: m.substring(1),
            user: true
          } : this.commandMap_[x] = {
            name: x,
            type: "exToKey",
            toKeys: m,
            user: true
          };
        } else {
          var M = {
            keys: d,
            type: "keyToKey",
            toKeys: m,
            noremap: !!b
          };
          g && (M.context = g), sa(M);
        }
      }
      unmap(d, m) {
        if (d != ":" && d.charAt(0) == ":") {
          if (m)
            throw Error("Mode not supported for ex mappings");
          var g = d.substring(1);
          if (this.commandMap_[g] && this.commandMap_[g].user)
            return delete this.commandMap_[g], true;
        } else
          for (var b = d, x = 0; x < r.length; x++)
            if (b == r[x].keys && r[x].context === m)
              return r.splice(x, 1), Nf(b), true;
      }
    }
    var oa = {
      colorscheme: function(f, d) {
        if (!d.args || d.args.length < 1) {
          Ie(f, f.getOption("theme"));
          return;
        }
        f.setOption("theme", d.args[0]);
      },
      map: function(f, d, m, g) {
        var b = d.args;
        if (!b || b.length < 2) {
          f && Ie(f, "Invalid mapping: " + d.input);
          return;
        }
        Ft.map(b[0], b[1], m, g);
      },
      imap: function(f, d) {
        this.map(f, d, "insert");
      },
      nmap: function(f, d) {
        this.map(f, d, "normal");
      },
      vmap: function(f, d) {
        this.map(f, d, "visual");
      },
      omap: function(f, d) {
        this.map(f, d, "operatorPending");
      },
      noremap: function(f, d) {
        this.map(f, d, void 0, true);
      },
      inoremap: function(f, d) {
        this.map(f, d, "insert", true);
      },
      nnoremap: function(f, d) {
        this.map(f, d, "normal", true);
      },
      vnoremap: function(f, d) {
        this.map(f, d, "visual", true);
      },
      onoremap: function(f, d) {
        this.map(f, d, "operatorPending", true);
      },
      unmap: function(f, d, m) {
        var g = d.args;
        (!g || g.length < 1 || !Ft.unmap(g[0], m)) && f && Ie(f, "No such mapping: " + d.input);
      },
      mapclear: function(f, d) {
        ve.mapclear();
      },
      imapclear: function(f, d) {
        ve.mapclear("insert");
      },
      nmapclear: function(f, d) {
        ve.mapclear("normal");
      },
      vmapclear: function(f, d) {
        ve.mapclear("visual");
      },
      omapclear: function(f, d) {
        ve.mapclear("operatorPending");
      },
      move: function(f, d) {
        Er.processCommand(f, f.state.vim, {
          keys: "",
          type: "motion",
          motion: "moveToLineOrEdgeOfDocument",
          motionArgs: {
            forward: false,
            explicitRepeat: true,
            linewise: true
          },
          repeatOverride: d.line + 1
        });
      },
      set: function(f, d) {
        var m = d.args, g = d.setCfg || {};
        if (!m || m.length < 1) {
          f && Ie(f, "Invalid mapping: " + d.input);
          return;
        }
        var b = m[0].split("="), x = b.shift() || "", M = b.length > 0 ? b.join("=") : void 0, A = false, E = false;
        if (x.charAt(x.length - 1) == "?") {
          if (M)
            throw Error("Trailing characters: " + d.argString);
          x = x.substring(0, x.length - 1), A = true;
        } else
          x.charAt(x.length - 1) == "!" && (x = x.substring(0, x.length - 1), E = true);
        M === void 0 && x.substring(0, 2) == "no" && (x = x.substring(2), M = false);
        var I = Y[x] && Y[x].type == "boolean";
        if (I && (E ? M = !ae(x, f, g) : M == null && (M = true)), !I && M === void 0 || A) {
          var _ = ae(x, f, g);
          _ instanceof Error ? Ie(f, _.message) : _ === true || _ === false ? Ie(f, " " + (_ ? "" : "no") + x) : Ie(f, "  " + x + "=" + _);
        } else {
          var W = ne(x, M, f, g);
          W instanceof Error && Ie(f, W.message);
        }
      },
      setlocal: function(f, d) {
        d.setCfg = {
          scope: "local"
        }, this.set(f, d);
      },
      setglobal: function(f, d) {
        d.setCfg = {
          scope: "global"
        }, this.set(f, d);
      },
      registers: function(f, d) {
        var m = d.args, g = V.registerController.registers, b = `----------Registers----------

`;
        if (m)
          for (var A = m.join(""), E = 0; E < A.length; E++) {
            var x = A.charAt(E);
            if (!!V.registerController.isValidRegister(x)) {
              var I = g[x] || new tr();
              b += '"' + x + "    " + I.toString() + `
`;
            }
          }
        else
          for (var x in g) {
            var M = g[x].toString();
            M.length && (b += '"' + x + "    " + M + `
`);
          }
        Ie(f, b, true);
      },
      marks: function(f, d) {
        var m = d.args, g = f.state.vim.marks, b = `-----------Marks-----------
mark	line	col

`;
        if (m)
          for (var A = m.join(""), E = 0; E < A.length; E++) {
            var x = A.charAt(E), M = g[x] && g[x].find();
            M && (b += x + "	" + M.line + "	" + M.ch + `
`);
          }
        else
          for (var x in g) {
            var M = g[x] && g[x].find();
            M && (b += x + "	" + M.line + "	" + M.ch + `
`);
          }
        Ie(f, b, true);
      },
      sort: function(f, d) {
        var m, g, b, x, M;
        function A() {
          if (d.argString) {
            var Ve = new t.StringStream(d.argString);
            if (Ve.eat("!") && (m = true), Ve.eol())
              return;
            if (!Ve.eatSpace())
              return "Invalid arguments";
            var Me = Ve.match(/([dinuox]+)?\s*(\/.+\/)?\s*/);
            if (!Me || !Ve.eol())
              return "Invalid arguments";
            if (Me[1]) {
              g = Me[1].indexOf("i") != -1, b = Me[1].indexOf("u") != -1;
              var et = Me[1].indexOf("d") != -1 || Me[1].indexOf("n") != -1, or = Me[1].indexOf("x") != -1, Gt = Me[1].indexOf("o") != -1;
              if (Number(et) + Number(or) + Number(Gt) > 1)
                return "Invalid arguments";
              x = et && "decimal" || or && "hex" || Gt && "octal";
            }
            Me[2] && (M = new RegExp(Me[2].substr(1, Me[2].length - 2), g ? "i" : ""));
          }
        }
        var E = A();
        if (E) {
          Ie(f, E + ": " + d.argString);
          return;
        }
        var I = d.line || f.firstLine(), _ = d.lineEnd || d.line || f.lastLine();
        if (I == _)
          return;
        var W = new e(I, 0), H = new e(_, yt(f, _)), j = f.getRange(W, H).split(`
`), $ = x == "decimal" ? /(-?)([\d]+)/ : x == "hex" ? /(-?)(?:0x)?([0-9a-f]+)/i : x == "octal" ? /([0-7]+)/ : null, X = x == "decimal" ? 10 : x == "hex" ? 16 : x == "octal" ? 8 : void 0, Q = [], xe = [];
        if (x || M)
          for (var fe = 0; fe < j.length; fe++) {
            var Ae = M ? j[fe].match(M) : null;
            Ae && Ae[0] != "" ? Q.push(Ae) : $ && $.exec(j[fe]) ? Q.push(j[fe]) : xe.push(j[fe]);
          }
        else
          xe = j;
        function Re(Ve, Me) {
          if (m) {
            var et;
            et = Ve, Ve = Me, Me = et;
          }
          g && (Ve = Ve.toLowerCase(), Me = Me.toLowerCase());
          var or = $ && $.exec(Ve), Gt = $ && $.exec(Me);
          if (!or || !Gt)
            return Ve < Me ? -1 : 1;
          var sr = parseInt((or[1] + or[2]).toLowerCase(), X), hs = parseInt((Gt[1] + Gt[2]).toLowerCase(), X);
          return sr - hs;
        }
        function Pe(Ve, Me) {
          if (m) {
            var et;
            et = Ve, Ve = Me, Me = et;
          }
          return g && (Ve[0] = Ve[0].toLowerCase(), Me[0] = Me[0].toLowerCase()), Ve[0] < Me[0] ? -1 : 1;
        }
        if (Q.sort(M ? Pe : Re), M)
          for (var fe = 0; fe < Q.length; fe++)
            Q[fe] = Q[fe].input;
        else
          x || xe.sort(Re);
        if (j = m ? Q.concat(xe) : xe.concat(Q), b) {
          var ct = j, dt;
          j = [];
          for (var fe = 0; fe < ct.length; fe++)
            ct[fe] != dt && j.push(ct[fe]), dt = ct[fe];
        }
        f.replaceRange(j.join(`
`), W, H);
      },
      vglobal: function(f, d) {
        this.global(f, d);
      },
      normal: function(f, d) {
        var m = false, g = d.argString;
        if (g && g[0] == "!" && (g = g.slice(1), m = true), g = g.trimStart(), !g) {
          Ie(f, "Argument is required.");
          return;
        }
        var b = d.line;
        if (typeof b == "number")
          for (var x = isNaN(d.lineEnd) ? b : d.lineEnd, M = b; M <= x; M++)
            f.setCursor(M, 0), vt(f, d.argString.trimStart(), {
              noremap: m
            }), f.state.vim.insertMode && Zr(f, true);
        else
          vt(f, d.argString.trimStart(), {
            noremap: m
          }), f.state.vim.insertMode && Zr(f, true);
      },
      global: function(f, d) {
        var m = d.argString;
        if (!m) {
          Ie(f, "Regular Expression missing from global");
          return;
        }
        var g = d.commandName[0] === "v";
        m[0] === "!" && d.commandName[0] === "g" && (g = true, m = m.slice(1));
        var b = d.line !== void 0 ? d.line : f.firstLine(), x = d.lineEnd || d.line || f.lastLine(), M = gg(m), A = m, E = "";
        if (M && M.length && (A = M[0], E = M.slice(1, M.length).join("/")), A)
          try {
            cs(f, A, true, true);
          } catch {
            Ie(f, "Invalid regex: " + A);
            return;
          }
        for (var I = En(f).getQuery(), _ = [], W = b; W <= x; W++) {
          var H = f.getLine(W), j = I.test(H);
          j !== g && _.push(E ? f.getLineHandle(W) : H);
        }
        if (!E) {
          Ie(f, _.join(`
`));
          return;
        }
        var $ = 0, X = function() {
          if ($ < _.length) {
            var Q = _[$++], xe = f.getLineNumber(Q);
            if (xe == null) {
              X();
              return;
            }
            var fe = xe + 1 + E;
            Ft.processCommand(f, fe, {
              callback: X
            });
          } else
            f.releaseLineHandles && f.releaseLineHandles();
        };
        X();
      },
      substitute: function(f, d) {
        if (!f.getSearchCursor)
          throw new Error("Search feature not available. Requires searchcursor.js or any other getSearchCursor implementation.");
        var m = d.argString, g = m ? Pf(m, m[0]) : [], b = "", x = "", M, A, E, I = false, _ = false;
        if (g && g.length)
          b = g[0], ae("pcre") && b !== "" && (b = new RegExp(b).source), x = g[1], x !== void 0 && (ae("pcre") ? x = xg(x.replace(/([^\\])&/g, "$1$$&")) : x = bg(x), V.lastSubstituteReplacePart = x), M = g[2] ? g[2].split(" ") : [];
        else if (m && m.length) {
          Ie(f, "Substitutions should be of the form :s/pattern/replace/");
          return;
        }
        if (M && (A = M[0], E = parseInt(M[1]), A && (A.indexOf("c") != -1 && (I = true), A.indexOf("g") != -1 && (_ = true), ae("pcre") ? b = b + "/" + A : b = b.replace(/\//g, "\\/") + "/" + A)), b)
          try {
            cs(f, b, true, true);
          } catch {
            Ie(f, "Invalid regex: " + b);
            return;
          }
        if (x = x || V.lastSubstituteReplacePart, x === void 0) {
          Ie(f, "No previous substitute regular expression");
          return;
        }
        var W = En(f), H = W.getQuery(), j = d.line !== void 0 ? d.line : f.getCursor().line, $ = d.lineEnd || j;
        j == f.firstLine() && $ == f.lastLine() && ($ = 1 / 0), E && (j = $, $ = j + E - 1);
        var X = $t(f, new e(j, 0)), Q = f.getSearchCursor(H, X);
        Fl(f, I, _, j, $, Q, H, x, d.callback);
      },
      startinsert: function(f, d) {
        vt(f, d.argString == "!" ? "A" : "i", {});
      },
      redo: t.commands.redo,
      undo: t.commands.undo,
      write: function(f) {
        t.commands.save ? t.commands.save(f) : f.save && f.save();
      },
      nohlsearch: function(f) {
        fo(f);
      },
      yank: function(f) {
        var d = Fe(f.getCursor()), m = d.line, g = f.getLine(m);
        V.registerController.pushText("0", "yank", g, true, true);
      },
      delete: function(f, d) {
        var m = d.selectionLine, g = isNaN(d.selectionLineEnd) ? m : d.selectionLineEnd;
        Zs.delete(f, {
          linewise: true
        }, [
          {
            anchor: new e(m, 0),
            head: new e(g + 1, 0)
          }
        ]);
      },
      join: function(f, d) {
        var m = d.selectionLine, g = isNaN(d.selectionLineEnd) ? m : d.selectionLineEnd;
        f.setCursor(new e(m, 0)), lo.joinLines(f, {
          repeat: g - m
        }, f.state.vim);
      },
      delmarks: function(f, d) {
        if (!d.argString || !Dl(d.argString)) {
          Ie(f, "Argument required");
          return;
        }
        for (var m = f.state.vim, g = new t.StringStream(Dl(d.argString)); !g.eol(); ) {
          g.eatSpace();
          var b = g.pos;
          if (!g.match(/[a-zA-Z]/, false)) {
            Ie(f, "Invalid argument: " + d.argString.substring(b));
            return;
          }
          var x = g.next();
          if (g.match("-", true)) {
            if (!g.match(/[a-zA-Z]/, false)) {
              Ie(f, "Invalid argument: " + d.argString.substring(b));
              return;
            }
            var M = x, A = g.next();
            if (M && A && C(M) == C(A)) {
              var E = M.charCodeAt(0), I = A.charCodeAt(0);
              if (E >= I) {
                Ie(f, "Invalid argument: " + d.argString.substring(b));
                return;
              }
              for (var _ = 0; _ <= I - E; _++) {
                var W = String.fromCharCode(E + _);
                delete m.marks[W];
              }
            } else {
              Ie(f, "Invalid argument: " + M + "-");
              return;
            }
          } else
            x && delete m.marks[x];
        }
      }
    }, Ft = new ia();
    ve.defineEx("version", "ve", (f) => {
      Ie(f, "Codemirror-vim version: 6.3.0");
    });
    function Fl(f, d, m, g, b, x, M, A, E) {
      f.state.vim.exMode = true;
      var I = false, _ = 0, W, H, j;
      function $() {
        f.operation(function() {
          for (; !I; )
            X(), xe();
          fe();
        });
      }
      function X() {
        var Re = "", Pe = x.match || x.pos && x.pos.match;
        if (Pe)
          Re = A.replace(/\$(\d{1,3}|[$&])/g, function(Ve, Me) {
            if (Me == "$")
              return "$";
            if (Me == "&")
              return Pe[0];
            for (var et = Me; parseInt(et) >= Pe.length && et.length > 0; )
              et = et.slice(0, et.length - 1);
            return et ? Pe[et] + Me.slice(et.length, Me.length) : Ve;
          });
        else {
          var ct = f.getRange(x.from(), x.to());
          Re = ct.replace(M, A);
        }
        var dt = x.to().line;
        x.replace(Re), H = x.to().line, b += H - dt, j = H < dt;
      }
      function Q() {
        var Re = W && Fe(x.to()), Pe = x.findNext();
        return Pe && !Pe[0] && Re && qt(x.from(), Re) && (Pe = x.findNext()), Pe && _++, Pe;
      }
      function xe() {
        for (; Q() && $l(x.from(), g, b); )
          if (!(!m && x.from().line == H && !j)) {
            f.scrollIntoView(x.from(), 30), f.setSelection(x.from(), x.to()), W = x.from(), I = false;
            return;
          }
        I = true;
      }
      function fe(Re) {
        if (Re && Re(), f.focus(), W) {
          f.setCursor(W);
          var Pe = f.state.vim;
          Pe.exMode = false, Pe.lastHPos = Pe.lastHSPos = W.ch;
        }
        E ? E() : I && Ie(f, (_ ? "Found " + _ + " matches" : "No matches found") + " for pattern: " + M + (ae("pcre") ? " (set nopcre to use Vim regexps)" : ""));
      }
      function Ae(Re, Pe, ct) {
        t.e_stop(Re);
        var dt = ao(Re);
        switch (dt) {
          case "y":
            X(), xe();
            break;
          case "n":
            xe();
            break;
          case "a":
            var Ve = E;
            E = void 0, f.operation($), E = Ve;
            break;
          case "l":
            X();
          case "q":
          case "<Esc>":
          case "<C-c>":
          case "<C-[>":
            fe(ct);
            break;
        }
        return I && fe(ct), true;
      }
      if (xe(), I) {
        Ie(f, "No matches for " + M + (ae("pcre") ? " (set nopcre to use vim regexps)" : ""));
        return;
      }
      if (!d) {
        $(), E && E();
        return;
      }
      ta(f, {
        prefix: sn("span", "replace with ", sn("strong", A), " (y/n/a/q/l)"),
        onKeyDown: Ae
      });
    }
    function Zr(f, d) {
      var m = f.state.vim, g = V.macroModeState, b = V.registerController.getRegister("."), x = g.isPlaying, M = g.lastInsertModeChanges;
      x || (f.off("change", Wl), m.insertEnd && m.insertEnd.clear(), m.insertEnd = void 0, t.off(f.getInputField(), "keydown", Hl)), !x && m.insertModeRepeat && m.insertModeRepeat > 1 && (Vf(f, m, m.insertModeRepeat - 1, true), m.lastEditInputState.repeatOverride = m.insertModeRepeat), delete m.insertModeRepeat, m.insertMode = false, d || f.setCursor(f.getCursor().line, f.getCursor().ch - 1), f.setOption("keyMap", "vim"), f.setOption("disableInput", true), f.toggleOverwrite(false), b.setText(M.changes.join("")), t.signal(f, "vim-mode-change", {
        mode: "normal"
      }), g.isRecording && $f(g);
    }
    function sa(f) {
      r.unshift(f), f.keys && Vl(f.keys);
    }
    function Vl(f) {
      f.split(/(<(?:[CSMA]-)*\w+>|.)/i).forEach(function(d) {
        d && (i[d] || (i[d] = 0), i[d]++);
      });
    }
    function Nf(f) {
      f.split(/(<(?:[CSMA]-)*\w+>|.)/i).forEach(function(d) {
        i[d] && i[d]--;
      });
    }
    function Di(f, d, m, g, b) {
      var x = {
        keys: f,
        type: d
      };
      x[d] = m, x[d + "Args"] = g;
      for (var M in b)
        x[M] = b[M];
      sa(x);
    }
    te("insertModeEscKeysTimeout", 200, "number");
    function fs(f, d, m, g) {
      var b = V.registerController.getRegister(g);
      if (g == ":") {
        b.keyBuffer[0] && Ft.processCommand(f, b.keyBuffer[0]), m.isPlaying = false;
        return;
      }
      var x = b.keyBuffer, M = 0;
      m.isPlaying = true, m.replaySearchQueries = b.searchQueries.slice(0);
      for (var A = 0; A < x.length; A++)
        for (var E = x[A], I, _, W = /<(?:[CSMA]-)*\w+>|./gi; I = W.exec(E); )
          if (_ = I[0], ve.handleKey(f, _, "macro"), d.insertMode) {
            var H = b.insertModeChanges[M++].changes;
            V.macroModeState.lastInsertModeChanges.changes = H, B(f, H, 1), Zr(f);
          }
      m.isPlaying = false;
    }
    function Cg(f, d) {
      if (!f.isPlaying) {
        var m = f.latestRegister, g = V.registerController.getRegister(m);
        g && g.pushText(d);
      }
    }
    function $f(f) {
      if (!f.isPlaying) {
        var d = f.latestRegister, m = V.registerController.getRegister(d);
        m && m.pushInsertModeChanges && m.pushInsertModeChanges(f.lastInsertModeChanges);
      }
    }
    function Tg(f, d) {
      if (!f.isPlaying) {
        var m = f.latestRegister, g = V.registerController.getRegister(m);
        g && g.pushSearchQuery && g.pushSearchQuery(d);
      }
    }
    function Wl(f, d) {
      var m = V.macroModeState, g = m.lastInsertModeChanges;
      if (!m.isPlaying)
        for (var b = f.state.vim; d; ) {
          if (g.expectCursorActivityForChange = true, g.ignoreCount > 1)
            g.ignoreCount--;
          else if (d.origin == "+input" || d.origin == "paste" || d.origin === void 0) {
            var x = f.listSelections().length;
            x > 1 && (g.ignoreCount = x);
            var M = d.text.join(`
`);
            if (g.maybeReset && (g.changes = [], g.maybeReset = false), M)
              if (f.state.overwrite && !/\n/.test(M))
                g.changes.push([
                  M
                ]);
              else {
                if (M.length > 1) {
                  var A = b && b.insertEnd && b.insertEnd.find(), E = f.getCursor();
                  if (A && A.line == E.line) {
                    var I = A.ch - E.ch;
                    I > 0 && I < M.length && (g.changes.push([
                      M,
                      I
                    ]), M = "");
                  }
                }
                M && g.changes.push(M);
              }
          }
          d = d.next;
        }
    }
    function zf(f) {
      var _a3;
      var d = f.state.vim;
      if (d.insertMode) {
        var m = V.macroModeState;
        if (m.isPlaying)
          return;
        var g = m.lastInsertModeChanges;
        g.expectCursorActivityForChange ? g.expectCursorActivityForChange = false : (g.maybeReset = true, d.insertEnd && d.insertEnd.clear(), d.insertEnd = f.setBookmark(f.getCursor(), {
          insertLeft: true
        }));
      } else
        ((_a3 = f.curOp) == null ? void 0 : _a3.isVimOp) || Ff(f, d);
    }
    function Ff(f, d) {
      var m = f.getCursor("anchor"), g = f.getCursor("head");
      if (d.visualMode && !f.somethingSelected() ? rr(f, false) : !d.visualMode && !d.insertMode && f.somethingSelected() && (d.visualMode = true, d.visualLine = false, t.signal(f, "vim-mode-change", {
        mode: "visual"
      })), d.visualMode) {
        var b = lt(g, m) ? 0 : -1, x = lt(g, m) ? -1 : 0;
        g = ht(g, 0, b), m = ht(m, 0, x), d.sel = {
          anchor: m,
          head: g
        }, An(f, d, "<", zt(g, m)), An(f, d, ">", Jr(g, m));
      } else
        d.insertMode || (d.lastHPos = f.getCursor().ch);
    }
    function Hl(f) {
      var d = V.macroModeState, m = d.lastInsertModeChanges, g = t.keyName ? t.keyName(f) : f.key;
      !g || (g.indexOf("Delete") != -1 || g.indexOf("Backspace") != -1) && (m.maybeReset && (m.changes = [], m.maybeReset = false), m.changes.push(new he(g, f)));
    }
    function Vf(f, d, m, g) {
      var b = V.macroModeState;
      b.isPlaying = true;
      var x = d.lastEditActionCommand, M = d.inputState;
      function A() {
        x ? Er.processAction(f, d, x) : Er.evalInput(f, d);
      }
      function E(_) {
        if (b.lastInsertModeChanges.changes.length > 0) {
          _ = d.lastEditActionCommand ? _ : 1;
          var W = b.lastInsertModeChanges;
          B(f, W.changes, _);
        }
      }
      if (d.inputState = d.lastEditInputState, x && x.interlaceInsertRepeat)
        for (var I = 0; I < m; I++)
          A(), E(1);
      else
        g || A(), E(m);
      d.inputState = M, d.insertMode && !g && Zr(f), b.isPlaying = false;
    }
    function P(f, d) {
      t.lookupKey(d, "vim-insert", function(g) {
        return typeof g == "string" ? t.commands[g](f) : g(f), true;
      });
    }
    function B(f, d, m) {
      var g = f.getCursor("head"), b = V.macroModeState.lastInsertModeChanges.visualBlock;
      b && (Sf(f, g, b + 1), m = f.listSelections().length, f.setCursor(g));
      for (var x = 0; x < m; x++) {
        b && f.setCursor(ht(g, x, 0));
        for (var M = 0; M < d.length; M++) {
          var A = d[M];
          if (A instanceof he)
            P(f, A.keyName);
          else if (typeof A == "string")
            f.replaceSelection(A);
          else {
            var E = f.getCursor(), I = ht(E, 0, A[0].length - (A[1] || 0));
            f.replaceRange(A[0], E, A[1] ? E : I), f.setCursor(I);
          }
        }
      }
      b && f.setCursor(ht(g, 0, 1));
    }
    function U(f) {
      var d = new f.constructor();
      return Object.keys(f).forEach(function(m) {
        if (m != "insertEnd") {
          var g = f[m];
          Array.isArray(g) ? g = g.slice() : g && typeof g == "object" && g.constructor != Object && (g = U(g)), d[m] = g;
        }
      }), f.sel && (d.sel = {
        head: f.sel.head && Fe(f.sel.head),
        anchor: f.sel.anchor && Fe(f.sel.anchor)
      }), d;
    }
    function pe(f, d, m) {
      var x = ee(f), g = f, b = false, x = ve.maybeInitVimState_(g), M = x.visualBlock || x.wasInVisualBlock;
      if (g.state.closeVimNotification) {
        var A = g.state.closeVimNotification;
        if (g.state.closeVimNotification = null, A(), d == "<CR>")
          return Et(g), true;
      }
      var E = g.isInMultiSelectMode();
      if (x.wasInVisualBlock && !E ? x.wasInVisualBlock = false : E && x.visualBlock && (x.wasInVisualBlock = true), d == "<Esc>" && !x.insertMode && !x.visualMode && E && x.status == "<Esc>")
        Et(g);
      else if (M || !E || g.inVirtualSelectionMode)
        b = ve.handleKey(g, d, m);
      else {
        var I = U(x), _ = x.inputState.changeQueueList || [];
        g.operation(function() {
          var _a3;
          g.curOp && (g.curOp.isVimOp = true);
          var W = 0;
          g.forEachSelection(function() {
            g.state.vim.inputState.changeQueue = _[W];
            var H = g.getCursor("head"), j = g.getCursor("anchor"), $ = lt(H, j) ? 0 : -1, X = lt(H, j) ? -1 : 0;
            H = ht(H, 0, $), j = ht(j, 0, X), g.state.vim.sel.head = H, g.state.vim.sel.anchor = j, b = ve.handleKey(g, d, m), g.virtualSelection && (_[W] = g.state.vim.inputState.changeQueue, g.state.vim = U(I)), W++;
          }), ((_a3 = g.curOp) == null ? void 0 : _a3.cursorActivity) && !b && (g.curOp.cursorActivity = false), g.state.vim = x, x.inputState.changeQueueList = _, x.inputState.changeQueue = null;
        }, true);
      }
      return b && !x.visualMode && !x.insertMode && x.visualMode != g.somethingSelected() && Ff(g, x), b;
    }
    return oe(), ve;
  }
  function Wn(t, e) {
    var n = e.ch, r = e.line + 1;
    r < 1 && (r = 1, n = 0), r > t.lines && (r = t.lines, n = Number.MAX_VALUE);
    var i = t.line(r);
    return Math.min(i.from + Math.max(0, n), i.to);
  }
  function cr(t, e) {
    let n = t.lineAt(e);
    return {
      line: n.number - 1,
      ch: e - n.from
    };
  }
  class hi {
    constructor(e, n) {
      this.line = e, this.ch = n;
    }
  }
  function YR(t, e, n) {
    if (t.addEventListener)
      t.addEventListener(e, n, false);
    else {
      var r = t._handlers || (t._handlers = {});
      r[e] = (r[e] || []).concat(n);
    }
  }
  function XR(t, e, n) {
    if (t.removeEventListener)
      t.removeEventListener(e, n, false);
    else {
      var r = t._handlers, i = r && r[e];
      if (i) {
        var o = i.indexOf(n);
        o > -1 && (r[e] = i.slice(0, o).concat(i.slice(o + 1)));
      }
    }
  }
  function QR(t, e, ...n) {
    var r, i = (r = t._handlers) === null || r === void 0 ? void 0 : r[e];
    if (!!i)
      for (var o = 0; o < i.length; ++o)
        i[o](...n);
  }
  function oM(t, ...e) {
    if (!!t)
      for (var n = 0; n < t.length; ++n)
        t[n](...e);
  }
  let R1;
  try {
    R1 = new RegExp("[\\w\\p{Alphabetic}\\p{Number}_]", "u");
  } catch {
    R1 = /[\w]/;
  }
  function kc(t, e) {
    var n = t.cm6;
    if (!n.state.readOnly) {
      var r = "input.type.compose";
      if (t.curOp && (t.curOp.lastChange || (r = "input.type.compose.start")), e.annotations)
        try {
          e.annotations.some(function(i) {
            i.value == "input" && (i.value = r);
          });
        } catch (i) {
          console.error(i);
        }
      else
        e.userEvent = r;
      return n.dispatch(e);
    }
  }
  function sM(t, e) {
    var n;
    t.curOp && (t.curOp.$changeStart = void 0), (e ? Zx : Rp)(t.cm6);
    let r = (n = t.curOp) === null || n === void 0 ? void 0 : n.$changeStart;
    r != null && t.cm6.dispatch({
      selection: {
        anchor: r
      }
    });
  }
  var eQ = {
    Left: (t) => xs(t.cm6, {
      key: "Left"
    }, "editor"),
    Right: (t) => xs(t.cm6, {
      key: "Right"
    }, "editor"),
    Up: (t) => xs(t.cm6, {
      key: "Up"
    }, "editor"),
    Down: (t) => xs(t.cm6, {
      key: "Down"
    }, "editor"),
    Backspace: (t) => xs(t.cm6, {
      key: "Backspace"
    }, "editor"),
    Delete: (t) => xs(t.cm6, {
      key: "Delete"
    }, "editor")
  };
  class Oe {
    openDialog(e, n, r) {
      return nQ(this, e, n, r);
    }
    openNotification(e, n) {
      return tQ(this, e, n);
    }
    constructor(e) {
      this.state = {}, this.marks = /* @__PURE__ */ Object.create(null), this.$mid = 0, this.options = {}, this._handlers = {}, this.$lastChangeEndOffset = 0, this.virtualSelection = null, this.cm6 = e, this.onChange = this.onChange.bind(this), this.onSelectionChange = this.onSelectionChange.bind(this);
    }
    on(e, n) {
      YR(this, e, n);
    }
    off(e, n) {
      XR(this, e, n);
    }
    signal(e, n, r) {
      QR(this, e, n, r);
    }
    indexFromPos(e) {
      return Wn(this.cm6.state.doc, e);
    }
    posFromIndex(e) {
      return cr(this.cm6.state.doc, e);
    }
    foldCode(e) {
      let n = this.cm6, r = n.state.selection.ranges, i = this.cm6.state.doc, o = Wn(i, e), s = q.create([
        q.range(o, o)
      ], 0).ranges;
      n.state.selection.ranges = s, FL(n), n.state.selection.ranges = r;
    }
    firstLine() {
      return 0;
    }
    lastLine() {
      return this.cm6.state.doc.lines - 1;
    }
    lineCount() {
      return this.cm6.state.doc.lines;
    }
    setCursor(e, n) {
      typeof e == "object" && (n = e.ch, e = e.line);
      var r = Wn(this.cm6.state.doc, {
        line: e,
        ch: n || 0
      });
      this.cm6.dispatch({
        selection: {
          anchor: r
        }
      }, {
        scrollIntoView: !this.curOp
      }), this.curOp && !this.curOp.isVimOp && this.onBeforeEndOperation();
    }
    getCursor(e) {
      var n = this.cm6.state.selection.main, r = e == "head" || !e ? n.head : e == "anchor" ? n.anchor : e == "start" ? n.from : e == "end" ? n.to : null;
      if (r == null)
        throw new Error("Invalid cursor type");
      return this.posFromIndex(r);
    }
    listSelections() {
      var e = this.cm6.state.doc;
      return this.cm6.state.selection.ranges.map((n) => ({
        anchor: cr(e, n.anchor),
        head: cr(e, n.head)
      }));
    }
    setSelections(e, n) {
      var r = this.cm6.state.doc, i = e.map((o) => {
        var s = Wn(r, o.head), a = Wn(r, o.anchor);
        return s == a ? q.cursor(s, 1) : q.range(a, s);
      });
      this.cm6.dispatch({
        selection: q.create(i, n)
      });
    }
    setSelection(e, n, r) {
      this.setSelections([
        {
          anchor: e,
          head: n
        }
      ], 0), r && r.origin == "*mouse" && this.onBeforeEndOperation();
    }
    getLine(e) {
      var n = this.cm6.state.doc;
      return e < 0 || e >= n.lines ? "" : this.cm6.state.doc.line(e + 1).text;
    }
    getLineHandle(e) {
      return this.$lineHandleChanges || (this.$lineHandleChanges = []), {
        row: e,
        index: this.indexFromPos(new hi(e, 0))
      };
    }
    getLineNumber(e) {
      var n = this.$lineHandleChanges;
      if (!n)
        return null;
      for (var r = e.index, i = 0; i < n.length; i++)
        if (r = n[i].changes.mapPos(r, 1, Zt.TrackAfter), r == null)
          return null;
      var o = this.posFromIndex(r);
      return o.ch == 0 ? o.line : null;
    }
    releaseLineHandles() {
      this.$lineHandleChanges = void 0;
    }
    getRange(e, n) {
      var r = this.cm6.state.doc;
      return this.cm6.state.sliceDoc(Wn(r, e), Wn(r, n));
    }
    replaceRange(e, n, r, i) {
      r || (r = n);
      var o = this.cm6.state.doc, s = Wn(o, n), a = Wn(o, r);
      kc(this, {
        changes: {
          from: s,
          to: a,
          insert: e
        }
      });
    }
    replaceSelection(e) {
      kc(this, this.cm6.state.replaceSelection(e));
    }
    replaceSelections(e) {
      var n = this.cm6.state.selection.ranges, r = n.map((i, o) => ({
        from: i.from,
        to: i.to,
        insert: e[o] || ""
      }));
      kc(this, {
        changes: r
      });
    }
    getSelection() {
      return this.getSelections().join(`
`);
    }
    getSelections() {
      var e = this.cm6;
      return e.state.selection.ranges.map((n) => e.state.sliceDoc(n.from, n.to));
    }
    somethingSelected() {
      return this.cm6.state.selection.ranges.some((e) => !e.empty);
    }
    getInputField() {
      return this.cm6.contentDOM;
    }
    clipPos(e) {
      var n = this.cm6.state.doc, r = e.ch, i = e.line + 1;
      i < 1 && (i = 1, r = 0), i > n.lines && (i = n.lines, r = Number.MAX_VALUE);
      var o = n.line(i);
      return r = Math.min(Math.max(0, r), o.to - o.from), new hi(i - 1, r);
    }
    getValue() {
      return this.cm6.state.doc.toString();
    }
    setValue(e) {
      var n = this.cm6;
      return n.dispatch({
        changes: {
          from: 0,
          to: n.state.doc.length,
          insert: e
        },
        selection: q.range(0, 0)
      });
    }
    focus() {
      return this.cm6.focus();
    }
    blur() {
      return this.cm6.contentDOM.blur();
    }
    defaultTextHeight() {
      return this.cm6.defaultLineHeight;
    }
    findMatchingBracket(e, n) {
      var r = this.cm6.state, i = Wn(r.doc, e), o = mr(r, i + 1, -1);
      return o && o.end ? {
        to: cr(r.doc, o.end.from)
      } : (o = mr(r, i, 1), o && o.end ? {
        to: cr(r.doc, o.end.from)
      } : {
        to: void 0
      });
    }
    scanForBracket(e, n, r, i) {
      return oQ(this, e, n, r, i);
    }
    indentLine(e, n) {
      n ? this.indentMore() : this.indentLess();
    }
    indentMore() {
      rS(this.cm6);
    }
    indentLess() {
      iS(this.cm6);
    }
    execCommand(e) {
      if (e == "indentAuto")
        Oe.commands.indentAuto(this);
      else if (e == "goLineLeft")
        lR(this.cm6);
      else if (e == "goLineRight") {
        aR(this.cm6);
        let n = this.cm6.state, r = n.selection.main.head;
        r < n.doc.length && n.sliceDoc(r, r + 1) !== `
` && dG(this.cm6);
      } else
        console.log(e + " is not implemented");
    }
    setBookmark(e, n) {
      var r = (n == null ? void 0 : n.insertLeft) ? 1 : -1, i = this.indexFromPos(e), o = new lQ(this, i, r);
      return o;
    }
    addOverlay({ query: e }) {
      let n = new aS({
        regexp: true,
        search: e.source,
        caseSensitive: !/i/.test(e.flags)
      });
      if (n.valid) {
        n.forVim = true, this.cm6Query = n;
        let r = Qo.of(n);
        return this.cm6.dispatch({
          effects: r
        }), n;
      }
    }
    removeOverlay(e) {
      if (!this.cm6Query)
        return;
      this.cm6Query.forVim = false;
      let n = Qo.of(this.cm6Query);
      this.cm6.dispatch({
        effects: n
      });
    }
    getSearchCursor(e, n) {
      var r = this, i = null, o = null, s = false;
      n.ch == null && (n.ch = Number.MAX_VALUE);
      var a = Wn(r.cm6.state.doc, n), l = e.source.replace(/(\\.|{(?:\d+(?:,\d*)?|,\d+)})|[{}]/g, function(v, y) {
        return y || "\\" + v;
      });
      function c(v, y = 0, S = v.length) {
        return new sS(v, l, {
          ignoreCase: e.ignoreCase
        }, y, S);
      }
      function u(v) {
        var y = r.cm6.state.doc;
        if (v > y.length)
          return null;
        let S = c(y, v).next();
        return S.done ? null : S.value;
      }
      var h = 1e4;
      function p(v, y) {
        var S = r.cm6.state.doc;
        for (let T = 1; ; T++) {
          let w = Math.max(v, y - T * h), k = c(S, w, y), C = null;
          for (; !k.next().done; )
            C = k.value;
          if (C && (w == v || C.from > w + 10))
            return C;
          if (w == v)
            return null;
        }
      }
      return {
        findNext: function() {
          return this.find(false);
        },
        findPrevious: function() {
          return this.find(true);
        },
        find: function(v) {
          var y = r.cm6.state.doc;
          if (v) {
            let S = i ? s ? i.to - 1 : i.from : a;
            i = p(0, S);
          } else {
            let S = i ? s ? i.to + 1 : i.to : a;
            i = u(S);
          }
          return o = i && {
            from: cr(y, i.from),
            to: cr(y, i.to),
            match: i.match
          }, s = i ? i.from == i.to : false, i && i.match;
        },
        from: function() {
          return o == null ? void 0 : o.from;
        },
        to: function() {
          return o == null ? void 0 : o.to;
        },
        replace: function(v) {
          i && (kc(r, {
            changes: {
              from: i.from,
              to: i.to,
              insert: v
            }
          }), i.to = i.from + v.length, o && (o.to = cr(r.cm6.state.doc, i.to)));
        },
        get match() {
          return o && o.match;
        }
      };
    }
    findPosV(e, n, r, i) {
      let { cm6: o } = this;
      const s = o.state.doc;
      let a = r == "page" ? o.dom.clientHeight : 0;
      const l = Wn(s, e);
      let c = q.cursor(l, 1, void 0, i), u = Math.round(Math.abs(n));
      for (let p = 0; p < u; p++)
        r == "page" ? c = o.moveVertically(c, n > 0, a) : r == "line" && (c = o.moveVertically(c, n > 0));
      let h = cr(s, c.head);
      return (n < 0 && c.head == 0 && i != 0 && e.line == 0 && e.ch != 0 || n > 0 && c.head == s.length && h.ch != i && e.line == h.line) && (h.hitSide = true), h;
    }
    charCoords(e, n) {
      var r = this.cm6.contentDOM.getBoundingClientRect(), i = Wn(this.cm6.state.doc, e), o = this.cm6.coordsAtPos(i), s = -r.top;
      return {
        left: ((o == null ? void 0 : o.left) || 0) - r.left,
        top: ((o == null ? void 0 : o.top) || 0) + s,
        bottom: ((o == null ? void 0 : o.bottom) || 0) + s
      };
    }
    coordsChar(e, n) {
      var r = this.cm6.contentDOM.getBoundingClientRect(), i = this.cm6.posAtCoords({
        x: e.left + r.left,
        y: e.top + r.top
      }) || 0;
      return cr(this.cm6.state.doc, i);
    }
    getScrollInfo() {
      var e = this.cm6.scrollDOM;
      return {
        left: e.scrollLeft,
        top: e.scrollTop,
        height: e.scrollHeight,
        width: e.scrollWidth,
        clientHeight: e.clientHeight,
        clientWidth: e.clientWidth
      };
    }
    scrollTo(e, n) {
      e != null && (this.cm6.scrollDOM.scrollLeft = e), n != null && (this.cm6.scrollDOM.scrollTop = n);
    }
    scrollIntoView(e, n) {
      if (e) {
        var r = this.indexFromPos(e);
        this.cm6.dispatch({
          effects: ue.scrollIntoView(r)
        });
      } else
        this.cm6.dispatch({
          scrollIntoView: true,
          userEvent: "scroll"
        });
    }
    getWrapperElement() {
      return this.cm6.dom;
    }
    getMode() {
      return {
        name: this.getOption("mode")
      };
    }
    setSize(e, n) {
      this.cm6.dom.style.width = e + 4 + "px", this.cm6.dom.style.height = n + "px", this.refresh();
    }
    refresh() {
      this.cm6.measure();
    }
    destroy() {
      this.removeOverlay();
    }
    getLastEditEnd() {
      return this.posFromIndex(this.$lastChangeEndOffset);
    }
    onChange(e) {
      this.$lineHandleChanges && this.$lineHandleChanges.push(e);
      for (let r in this.marks)
        this.marks[r].update(e.changes);
      this.virtualSelection && (this.virtualSelection.ranges = this.virtualSelection.ranges.map((r) => r.map(e.changes)));
      var n = this.curOp = this.curOp || {};
      e.changes.iterChanges((r, i, o, s, a) => {
        (n.$changeStart == null || n.$changeStart > o) && (n.$changeStart = o), this.$lastChangeEndOffset = s;
        var l = {
          text: a.toJSON()
        };
        n.lastChange ? n.lastChange.next = n.lastChange = l : n.lastChange = n.change = l;
      }, true), n.changeHandlers || (n.changeHandlers = this._handlers.change && this._handlers.change.slice());
    }
    onSelectionChange() {
      var e = this.curOp = this.curOp || {};
      e.cursorActivityHandlers || (e.cursorActivityHandlers = this._handlers.cursorActivity && this._handlers.cursorActivity.slice()), this.curOp.cursorActivity = true;
    }
    operation(e, n) {
      this.curOp || (this.curOp = {
        $d: 0
      }), this.curOp.$d++;
      try {
        var r = e();
      } finally {
        this.curOp && (this.curOp.$d--, this.curOp.$d || this.onBeforeEndOperation());
      }
      return r;
    }
    onBeforeEndOperation() {
      var e = this.curOp, n = false;
      e && (e.change && oM(e.changeHandlers, this, e.change), e && e.cursorActivity && (oM(e.cursorActivityHandlers, this, null), e.isVimOp && (n = true)), this.curOp = null), n && this.scrollIntoView();
    }
    moveH(e, n) {
      if (n == "char") {
        var r = this.getCursor();
        this.setCursor(r.line, r.ch + e);
      }
    }
    setOption(e, n) {
      switch (e) {
        case "keyMap":
          this.state.keyMap = n;
          break;
        case "textwidth":
          this.state.textwidth = n;
          break;
      }
    }
    getOption(e) {
      switch (e) {
        case "firstLineNumber":
          return 1;
        case "tabSize":
          return this.cm6.state.tabSize || 4;
        case "readOnly":
          return this.cm6.state.readOnly;
        case "indentWithTabs":
          return this.cm6.state.facet(xl) == "	";
        case "indentUnit":
          return this.cm6.state.facet(xl).length || 2;
        case "textwidth":
          return this.state.textwidth;
        case "keyMap":
          return this.state.keyMap || "vim";
      }
    }
    toggleOverwrite(e) {
      this.state.overwrite = e;
    }
    getTokenTypeAt(e) {
      var n, r = this.indexFromPos(e), i = DL(this.cm6.state, r), o = i == null ? void 0 : i.resolve(r), s = ((n = o == null ? void 0 : o.type) === null || n === void 0 ? void 0 : n.name) || "";
      return /comment/i.test(s) ? "comment" : /string/i.test(s) ? "string" : "";
    }
    overWriteSelection(e) {
      var n = this.cm6.state.doc, r = this.cm6.state.selection, i = r.ranges.map((o) => {
        if (o.empty) {
          var s = o.to < n.length ? n.sliceString(o.from, o.to + 1) : "";
          if (s && !/\n/.test(s))
            return q.range(o.from, o.to + 1);
        }
        return o;
      });
      this.cm6.dispatch({
        selection: q.create(i, r.mainIndex)
      }), this.replaceSelection(e);
    }
    isInMultiSelectMode() {
      return this.cm6.state.selection.ranges.length > 1;
    }
    virtualSelectionMode() {
      return !!this.virtualSelection;
    }
    forEachSelection(e) {
      var n = this.cm6.state.selection;
      this.virtualSelection = q.create(n.ranges, n.mainIndex);
      for (var r = 0; r < this.virtualSelection.ranges.length; r++) {
        var i = this.virtualSelection.ranges[r];
        !i || (this.cm6.dispatch({
          selection: q.create([
            i
          ])
        }), e(), this.virtualSelection.ranges[r] = this.cm6.state.selection.ranges[0]);
      }
      this.cm6.dispatch({
        selection: this.virtualSelection
      }), this.virtualSelection = null;
    }
    hardWrap(e) {
      return cQ(this, e);
    }
  }
  Oe.isMac = typeof navigator < "u" && /Mac/.test(navigator.platform);
  Oe.Pos = hi;
  Oe.StringStream = jq;
  Oe.commands = {
    cursorCharLeft: function(t) {
      tS(t.cm6);
    },
    redo: function(t) {
      sM(t, false);
    },
    undo: function(t) {
      sM(t, true);
    },
    newlineAndIndent: function(t) {
      P1({
        state: t.cm6.state,
        dispatch: (e) => kc(t, e)
      });
    },
    indentAuto: function(t) {
      TR(t.cm6);
    },
    newlineAndIndentContinueComment: void 0,
    save: void 0
  };
  Oe.isWordChar = function(t) {
    return R1.test(t);
  };
  Oe.keys = eQ;
  Oe.addClass = function(t, e) {
  };
  Oe.rmClass = function(t, e) {
  };
  Oe.e_preventDefault = function(t) {
    t.preventDefault();
  };
  Oe.e_stop = function(t) {
    var e, n;
    (e = t == null ? void 0 : t.stopPropagation) === null || e === void 0 || e.call(t), (n = t == null ? void 0 : t.preventDefault) === null || n === void 0 || n.call(t);
  };
  Oe.lookupKey = function(e, n, r) {
    var i = Oe.keys[e];
    !i && /^Arrow/.test(e) && (i = Oe.keys[e.slice(5)]), i && r(i);
  };
  Oe.on = YR;
  Oe.off = XR;
  Oe.signal = QR;
  Oe.findMatchingTag = sQ;
  Oe.findEnclosingTag = aQ;
  Oe.keyName = void 0;
  function JR(t, e, n) {
    var r = document.createElement("div");
    return r.appendChild(e), r;
  }
  function ZR(t, e) {
    t.state.currentNotificationClose && t.state.currentNotificationClose(), t.state.currentNotificationClose = e;
  }
  function tQ(t, e, n) {
    ZR(t, a);
    var r = JR(t, e, n && n.bottom), i = false, o, s = n && typeof n.duration < "u" ? n.duration : 5e3;
    function a() {
      i || (i = true, clearTimeout(o), r.remove(), t_(t, r));
    }
    return r.onclick = function(l) {
      l.preventDefault(), a();
    }, e_(t, r), s && (o = setTimeout(a, s)), a;
  }
  function e_(t, e) {
    var n = t.state.dialog;
    t.state.dialog = e, e.style.flex = "1", e && n !== e && (n && n.contains(document.activeElement) && t.focus(), n && n.parentElement ? n.parentElement.replaceChild(e, n) : n && n.remove(), Oe.signal(t, "dialog"));
  }
  function t_(t, e) {
    t.state.dialog == e && (t.state.dialog = null, Oe.signal(t, "dialog"));
  }
  function nQ(t, e, n, r) {
    r || (r = {}), ZR(t, void 0);
    var i = JR(t, e, r.bottom), o = false;
    e_(t, i);
    function s(l) {
      if (typeof l == "string")
        a.value = l;
      else {
        if (o)
          return;
        o = true, t_(t, i), t.state.dialog || t.focus(), r.onClose && r.onClose(i);
      }
    }
    var a = i.getElementsByTagName("input")[0];
    return a && (r.value && (a.value = r.value, r.selectValueOnOpen !== false && a.select()), r.onInput && Oe.on(a, "input", function(l) {
      r.onInput(l, a.value, s);
    }), r.onKeyUp && Oe.on(a, "keyup", function(l) {
      r.onKeyUp(l, a.value, s);
    }), Oe.on(a, "keydown", function(l) {
      r && r.onKeyDown && r.onKeyDown(l, a.value, s) || (l.keyCode == 13 && n && n(a.value), (l.keyCode == 27 || r.closeOnEnter !== false && l.keyCode == 13) && (a.blur(), Oe.e_stop(l), s()));
    }), r.closeOnBlur !== false && Oe.on(a, "blur", function() {
      setTimeout(function() {
        document.activeElement !== a && s();
      });
    }), a.focus()), s;
  }
  var rQ = {
    "(": ")>",
    ")": "(<",
    "[": "]>",
    "]": "[<",
    "{": "}>",
    "}": "{<",
    "<": ">>",
    ">": "<<"
  };
  function iQ(t) {
    return t && t.bracketRegex || /[(){}[\]]/;
  }
  function oQ(t, e, n, r, i) {
    for (var o = i && i.maxScanLineLength || 1e4, s = i && i.maxScanLines || 1e3, a = [], l = iQ(i), c = n > 0 ? Math.min(e.line + s, t.lastLine() + 1) : Math.max(t.firstLine() - 1, e.line - s), u = e.line; u != c; u += n) {
      var h = t.getLine(u);
      if (!!h) {
        var p = n > 0 ? 0 : h.length - 1, v = n > 0 ? h.length : -1;
        if (!(h.length > o))
          for (u == e.line && (p = e.ch - (n < 0 ? 1 : 0)); p != v; p += n) {
            var y = h.charAt(p);
            if (l.test(y)) {
              var S = rQ[y];
              if (S && S.charAt(1) == ">" == n > 0)
                a.push(y);
              else if (a.length)
                a.pop();
              else
                return {
                  pos: new hi(u, p),
                  ch: y
                };
            }
          }
      }
    }
    return u - n == (n > 0 ? t.lastLine() : t.firstLine()) ? false : null;
  }
  function sQ(t, e) {
    return null;
  }
  function aQ(t, e) {
    var n, r, i = t.cm6.state, o = t.indexFromPos(e);
    if (o < i.doc.length) {
      var s = i.sliceDoc(o, o + 1);
      s == "<" && o++;
    }
    for (var a = DL(i, o), l = (a == null ? void 0 : a.resolve(o)) || null; l; ) {
      if (((n = l.firstChild) === null || n === void 0 ? void 0 : n.type.name) == "OpenTag" && ((r = l.lastChild) === null || r === void 0 ? void 0 : r.type.name) == "CloseTag")
        return {
          open: aM(i.doc, l.firstChild),
          close: aM(i.doc, l.lastChild)
        };
      l = l.parent;
    }
  }
  function aM(t, e) {
    return {
      from: cr(t, e.from),
      to: cr(t, e.to)
    };
  }
  class lQ {
    constructor(e, n, r) {
      this.cm = e, this.id = e.$mid++, this.offset = n, this.assoc = r, e.marks[this.id] = this;
    }
    clear() {
      delete this.cm.marks[this.id];
    }
    find() {
      return this.offset == null ? null : this.cm.posFromIndex(this.offset);
    }
    update(e) {
      this.offset != null && (this.offset = e.mapPos(this.offset, this.assoc, Zt.TrackDel));
    }
  }
  function cQ(t, e) {
    for (var n, r = e.column || t.getOption("textwidth") || 80, i = e.allowMerge != false, o = Math.min(e.from, e.to), s = Math.max(e.from, e.to); o <= s; ) {
      var a = t.getLine(o);
      if (a.length > r) {
        var l = y(a, r, 5);
        if (l) {
          var c = (n = /^\s*/.exec(a)) === null || n === void 0 ? void 0 : n[0];
          t.replaceRange(`
` + c, new hi(o, l.start), new hi(o, l.end));
        }
        s++;
      } else if (i && /\S/.test(a) && o != s) {
        var u = t.getLine(o + 1);
        if (u && /\S/.test(u)) {
          var h = a.replace(/\s+$/, ""), p = u.replace(/^\s+/, ""), v = h + " " + p, l = y(v, r, 5);
          l && l.start > h.length || v.length < r ? (t.replaceRange(" ", new hi(o, h.length), new hi(o + 1, u.length - p.length)), o--, s--) : h.length < a.length && t.replaceRange("", new hi(o, h.length), new hi(o, a.length));
        }
      }
      o++;
    }
    return o;
    function y(S, T, w) {
      if (!(S.length < T)) {
        var k = S.slice(0, T), C = S.slice(T), O = /^(?:(\s+)|(\S+)(\s+))/.exec(C), L = /(?:(\s+)|(\s+)(\S+))$/.exec(k), D = 0, R = 0;
        if (L && !L[2] && (D = T - L[1].length, R = T), O && !O[2] && (D || (D = T), R = T + O[1].length), D)
          return {
            start: D,
            end: R
          };
        if (L && L[2] && L.index > w)
          return {
            start: L.index,
            end: L.index + L[2].length
          };
        if (O && O[2])
          return D = T + O[2].length, {
            start: D,
            end: D + O[3].length
          };
      }
    }
  }
  let _1 = FU || function() {
    let t = {
      cursorBlinkRate: 1200
    };
    return function() {
      return t;
    };
  }();
  class uQ {
    constructor(e, n, r, i, o, s, a, l, c, u) {
      this.left = e, this.top = n, this.height = r, this.fontFamily = i, this.fontSize = o, this.fontWeight = s, this.color = a, this.className = l, this.letter = c, this.partial = u;
    }
    draw() {
      let e = document.createElement("div");
      return e.className = this.className, this.adjust(e), e;
    }
    adjust(e) {
      e.style.left = this.left + "px", e.style.top = this.top + "px", e.style.height = this.height + "px", e.style.lineHeight = this.height + "px", e.style.fontFamily = this.fontFamily, e.style.fontSize = this.fontSize, e.style.fontWeight = this.fontWeight, e.style.color = this.partial ? "transparent" : this.color, e.className = this.className, e.textContent = this.letter;
    }
    eq(e) {
      return this.left == e.left && this.top == e.top && this.height == e.height && this.fontFamily == e.fontFamily && this.fontSize == e.fontSize && this.fontWeight == e.fontWeight && this.color == e.color && this.className == e.className && this.letter == e.letter;
    }
  }
  class fQ {
    constructor(e, n) {
      this.view = e, this.rangePieces = [], this.cursors = [], this.cm = n, this.measureReq = {
        read: this.readPos.bind(this),
        write: this.drawSel.bind(this)
      }, this.cursorLayer = e.scrollDOM.appendChild(document.createElement("div")), this.cursorLayer.className = "cm-cursorLayer cm-vimCursorLayer", this.cursorLayer.setAttribute("aria-hidden", "true"), e.requestMeasure(this.measureReq), this.setBlinkRate();
    }
    setBlinkRate() {
      let n = _1(this.cm.cm6.state).cursorBlinkRate;
      this.cursorLayer.style.animationDuration = n + "ms";
    }
    update(e) {
      (e.selectionSet || e.geometryChanged || e.viewportChanged) && (this.view.requestMeasure(this.measureReq), this.cursorLayer.style.animationName = this.cursorLayer.style.animationName == "cm-blink" ? "cm-blink2" : "cm-blink"), hQ(e) && this.setBlinkRate();
    }
    scheduleRedraw() {
      this.view.requestMeasure(this.measureReq);
    }
    readPos() {
      let { state: e } = this.view, n = [];
      for (let r of e.selection.ranges) {
        let i = r == e.selection.main, o = gQ(this.cm, this.view, r, i);
        o && n.push(o);
      }
      return {
        cursors: n
      };
    }
    drawSel({ cursors: e }) {
      if (e.length != this.cursors.length || e.some((n, r) => !n.eq(this.cursors[r]))) {
        let n = this.cursorLayer.children;
        if (n.length !== e.length) {
          this.cursorLayer.textContent = "";
          for (const r of e)
            this.cursorLayer.appendChild(r.draw());
        } else
          e.forEach((r, i) => r.adjust(n[i]));
        this.cursors = e;
      }
    }
    destroy() {
      this.cursorLayer.remove();
    }
  }
  function hQ(t) {
    return _1(t.startState) != _1(t.state);
  }
  const dQ = {
    ".cm-vimMode .cm-line": {
      "& ::selection": {
        backgroundColor: "transparent !important"
      },
      "&::selection": {
        backgroundColor: "transparent !important"
      },
      caretColor: "transparent !important"
    },
    ".cm-fat-cursor": {
      position: "absolute",
      background: "#ff9696",
      border: "none",
      whiteSpace: "pre"
    },
    "&:not(.cm-focused) .cm-fat-cursor": {
      background: "none",
      outline: "solid 1px #ff9696",
      color: "transparent !important"
    }
  }, pQ = ns.highest(ue.theme(dQ));
  function mQ(t) {
    let e = t.scrollDOM.getBoundingClientRect();
    return {
      left: (t.textDirection == Je.LTR ? e.left : e.right - t.scrollDOM.clientWidth) - t.scrollDOM.scrollLeft * t.scaleX,
      top: e.top - t.scrollDOM.scrollTop * t.scaleY
    };
  }
  function gQ(t, e, n, r) {
    var i, o, s, a;
    let l = n.head, c = false, u = 1, h = t.state.vim;
    if (h && (!h.insertMode || t.state.overwrite)) {
      if (c = true, h.visualBlock && !r)
        return null;
      n.anchor < n.head && (l < e.state.doc.length && e.state.sliceDoc(l, l + 1)) != `
` && l--, t.state.overwrite ? u = 0.2 : h.status && (u = 0.5);
    }
    if (c) {
      let v = l < e.state.doc.length && e.state.sliceDoc(l, l + 1);
      v && /[\uDC00-\uDFFF]/.test(v) && l > 1 && (l--, v = e.state.sliceDoc(l, l + 1));
      let y = e.coordsAtPos(l, 1);
      if (!y)
        return null;
      let S = mQ(e), T = e.domAtPos(l), w = T ? T.node : e.contentDOM;
      for (w instanceof Text && T.offset >= w.data.length && !((i = w.parentElement) === null || i === void 0) && i.nextSibling && (w = (o = w.parentElement) === null || o === void 0 ? void 0 : o.nextSibling, T = {
        node: w,
        offset: 0
      }); T && T.node instanceof HTMLElement; )
        w = T.node, T = {
          node: T.node.childNodes[T.offset],
          offset: 0
        };
      if (!(w instanceof HTMLElement)) {
        if (!w.parentNode)
          return null;
        w = w.parentNode;
      }
      let k = getComputedStyle(w), C = y.left, O = (a = (s = e).coordsForChar) === null || a === void 0 ? void 0 : a.call(s, l);
      if (O && (C = O.left), !v || v == `
` || v == "\r")
        v = "\xA0";
      else if (v == "	") {
        v = "\xA0";
        var p = e.coordsAtPos(l + 1, -1);
        p && (C = p.left - (p.left - y.left) / parseInt(k.tabSize));
      } else
        /[\uD800-\uDBFF]/.test(v) && l < e.state.doc.length - 1 && (v += e.state.sliceDoc(l + 1, l + 2));
      let L = y.bottom - y.top;
      return new uQ((C - S.left) / e.scaleX, (y.top - S.top + L * (1 - u)) / e.scaleY, L * u / e.scaleY, k.fontFamily, k.fontSize, k.fontWeight, k.color, r ? "cm-fat-cursor cm-cursor-primary" : "cm-fat-cursor cm-cursor-secondary", v, u != 1);
    } else
      return null;
  }
  var vQ = typeof navigator < "u" && /linux/i.test(navigator.platform) && / Gecko\/\d+/.exec(navigator.userAgent);
  const gs = ZX(Oe), yQ = 250, bQ = ue.baseTheme({
    ".cm-vimMode .cm-cursorLayer:not(.cm-vimCursorLayer)": {
      display: "none"
    },
    ".cm-vim-panel": {
      padding: "0px 10px",
      fontFamily: "monospace",
      minHeight: "1.3em",
      display: "flex"
    },
    ".cm-vim-panel input": {
      border: "none",
      outline: "none",
      backgroundColor: "inherit"
    },
    "&light .cm-searchMatch": {
      backgroundColor: "#ffff0054"
    },
    "&dark .cm-searchMatch": {
      backgroundColor: "#00ffff8a"
    }
  }), xQ = kt.fromClass(class {
    constructor(t) {
      this.status = "", this.query = null, this.decorations = be.none, this.waitForCopy = false, this.lastKeydown = "", this.useNextTextInput = false, this.compositionText = "", this.view = t;
      const e = this.cm = new Oe(t);
      gs.enterVimMode(this.cm), this.view.cm = this.cm, this.cm.state.vimPlugin = this, this.blockCursor = new fQ(t, e), this.updateClass(), this.cm.on("vim-command-done", () => {
        e.state.vim && (e.state.vim.status = ""), this.blockCursor.scheduleRedraw(), this.updateStatus();
      }), this.cm.on("vim-mode-change", (n) => {
        !e.state.vim || (e.state.vim.mode = n.mode, n.subMode && (e.state.vim.mode += " block"), e.state.vim.status = "", this.blockCursor.scheduleRedraw(), this.updateClass(), this.updateStatus());
      }), this.cm.on("dialog", () => {
        this.cm.state.statusbar ? this.updateStatus() : t.dispatch({
          effects: n_.of(!!this.cm.state.dialog)
        });
      }), this.dom = document.createElement("span"), this.spacer = document.createElement("span"), this.spacer.style.flex = "1", this.statusButton = document.createElement("span"), this.statusButton.onclick = (n) => {
        gs.handleKey(this.cm, "<Esc>", "user"), this.cm.focus();
      }, this.statusButton.style.cssText = "cursor: pointer";
    }
    update(t) {
      var e;
      if ((t.viewportChanged || t.docChanged) && this.query && this.highlight(this.query), t.docChanged && this.cm.onChange(t), t.selectionSet && this.cm.onSelectionChange(), t.viewportChanged, this.cm.curOp && !this.cm.curOp.isVimOp && this.cm.onBeforeEndOperation(), t.transactions) {
        for (let n of t.transactions)
          for (let r of n.effects)
            if (r.is(Qo))
              if (!((e = r.value) === null || e === void 0 ? void 0 : e.forVim))
                this.highlight(null);
              else {
                let o = r.value.create();
                this.highlight(o);
              }
      }
      this.blockCursor.update(t);
    }
    updateClass() {
      const t = this.cm.state;
      !t.vim || t.vim.insertMode && !t.overwrite ? this.view.scrollDOM.classList.remove("cm-vimMode") : this.view.scrollDOM.classList.add("cm-vimMode");
    }
    updateStatus() {
      let t = this.cm.state.statusbar, e = this.cm.state.vim;
      if (!t || !e)
        return;
      let n = this.cm.state.dialog;
      if (n)
        n.parentElement != t && (t.textContent = "", t.appendChild(n));
      else {
        t.textContent = "";
        var r = (e.mode || "normal").toUpperCase();
        e.insertModeReturn && (r += "(C-O)"), this.statusButton.textContent = `--${r}--`, t.appendChild(this.statusButton), t.appendChild(this.spacer);
      }
      this.dom.textContent = e.status, t.appendChild(this.dom);
    }
    destroy() {
      gs.leaveVimMode(this.cm), this.updateClass(), this.blockCursor.destroy(), delete this.view.cm;
    }
    highlight(t) {
      if (this.query = t, !t)
        return this.decorations = be.none;
      let { view: e } = this, n = new Ai();
      for (let r = 0, i = e.visibleRanges, o = i.length; r < o; r++) {
        let { from: s, to: a } = i[r];
        for (; r < o - 1 && a > i[r + 1].from - 2 * yQ; )
          a = i[++r].to;
        t.highlight(e.state, s, a, (l, c) => {
          n.add(l, c, wQ);
        });
      }
      return this.decorations = n.finish();
    }
    handleKey(t, e) {
      const n = this.cm;
      let r = n.state.vim;
      if (!r)
        return;
      const i = gs.vimKeyFromEvent(t, r);
      if (Oe.signal(this.cm, "inputEvent", {
        type: "handleKey",
        key: i
      }), !i)
        return;
      if (i == "<Esc>" && !r.insertMode && !r.visualMode && this.query) {
        const a = r.searchState_;
        a && (n.removeOverlay(a.getOverlay()), a.setOverlay(null));
      }
      if (i === "<C-c>" && !Oe.isMac && n.somethingSelected())
        return this.waitForCopy = true, true;
      r.status = (r.status || "") + i;
      let s = gs.multiSelectHandleKey(n, i, "user");
      return r = gs.maybeInitVimState_(n), !s && r.insertMode && n.state.overwrite && (t.key && t.key.length == 1 && !/\n/.test(t.key) ? (s = true, n.overWriteSelection(t.key)) : t.key == "Backspace" && (s = true, Oe.commands.cursorCharLeft(n))), s && (Oe.signal(this.cm, "vim-keypress", i), t.preventDefault(), t.stopPropagation(), this.blockCursor.scheduleRedraw()), this.updateStatus(), !!s;
    }
  }, {
    eventHandlers: {
      copy: function(t, e) {
        !this.waitForCopy || (this.waitForCopy = false, Promise.resolve().then(() => {
          var n = this.cm, r = n.state.vim;
          !r || (r.insertMode ? n.setSelection(n.getCursor(), n.getCursor()) : n.operation(() => {
            n.curOp && (n.curOp.isVimOp = true), gs.handleKey(n, "<Esc>", "user");
          }));
        }));
      },
      compositionstart: function(t, e) {
        this.useNextTextInput = true, Oe.signal(this.cm, "inputEvent", t);
      },
      compositionupdate: function(t, e) {
        Oe.signal(this.cm, "inputEvent", t);
      },
      compositionend: function(t, e) {
        Oe.signal(this.cm, "inputEvent", t);
      },
      keypress: function(t, e) {
        Oe.signal(this.cm, "inputEvent", t), this.lastKeydown == "Dead" && this.handleKey(t, e);
      },
      keydown: function(t, e) {
        Oe.signal(this.cm, "inputEvent", t), this.lastKeydown = t.key, this.lastKeydown == "Unidentified" || this.lastKeydown == "Process" || this.lastKeydown == "Dead" ? this.useNextTextInput = true : (this.useNextTextInput = false, this.handleKey(t, e));
      }
    },
    provide: () => [
      ue.inputHandler.of((t, e, n, r) => {
        var i, o, s = AQ(t);
        if (!s)
          return false;
        var a = (i = s.state) === null || i === void 0 ? void 0 : i.vim, l = s.state.vimPlugin;
        if (a && !a.insertMode && !(!((o = s.curOp) === null || o === void 0) && o.isVimOp)) {
          if (r === "\0\0")
            return true;
          if (Oe.signal(s, "inputEvent", {
            type: "text",
            text: r,
            from: e,
            to: n
          }), r.length == 1 && l.useNextTextInput) {
            if (a.expectLiteralNext && t.composing)
              return l.compositionText = r, false;
            if (l.compositionText) {
              var c = l.compositionText;
              l.compositionText = "";
              var u = t.state.selection.main.head, h = t.state.sliceDoc(u - c.length, u);
              if (c === h) {
                var p = s.getCursor();
                s.replaceRange("", s.posFromIndex(u - c.length), p);
              }
            }
            return l.handleKey({
              key: r,
              preventDefault: () => {
              },
              stopPropagation: () => {
              }
            }), SQ(t), true;
          }
        }
        return false;
      })
    ],
    decorations: (t) => t.decorations
  });
  function SQ(t) {
    var e = t.scrollDOM.parentElement;
    if (!!e) {
      if (vQ) {
        t.contentDOM.textContent = "\0\0", t.contentDOM.dispatchEvent(new CustomEvent("compositionend"));
        return;
      }
      var n = t.scrollDOM.nextSibling, r = window.getSelection(), i = r && {
        anchorNode: r.anchorNode,
        anchorOffset: r.anchorOffset,
        focusNode: r.focusNode,
        focusOffset: r.focusOffset
      };
      t.scrollDOM.remove(), e.insertBefore(t.scrollDOM, n);
      try {
        i && r && (r.setPosition(i.anchorNode, i.anchorOffset), i.focusNode && r.extend(i.focusNode, i.focusOffset));
      } catch (o) {
        console.error(o);
      }
      t.focus(), t.contentDOM.dispatchEvent(new CustomEvent("compositionend"));
    }
  }
  const wQ = be.mark({
    class: "cm-searchMatch"
  }), n_ = Ee.define(), kQ = Kt.define({
    create: () => false,
    update(t, e) {
      for (let n of e.effects)
        n.is(n_) && (t = n.value);
      return t;
    },
    provide: (t) => Gs.from(t, (e) => e ? CQ : null)
  });
  function CQ(t) {
    let e = document.createElement("div");
    e.className = "cm-vim-panel";
    let n = t.cm;
    return n.state.dialog && e.appendChild(n.state.dialog), {
      top: false,
      dom: e
    };
  }
  function TQ(t) {
    let e = document.createElement("div");
    e.className = "cm-vim-panel";
    let n = t.cm;
    return n.state.statusbar = e, n.state.vimPlugin.updateStatus(), {
      dom: e
    };
  }
  function MQ(t = {}) {
    return [
      bQ,
      xQ,
      pQ,
      t.status ? Gs.of(TQ) : kQ
    ];
  }
  function AQ(t) {
    return t.cm || null;
  }
  function lM(t) {
    return J(GR, {
      ...t == null ? void 0 : t.extra,
      value: t == null ? void 0 : t.code,
      height: "100%",
      extensions: [
        MQ()
      ],
      onChange: t == null ? void 0 : t.onChange
    });
  }
  var EQ = "Expected a function", cM = 0 / 0, PQ = "[object Symbol]", OQ = /^\s+|\s+$/g, LQ = /^[-+]0x[0-9a-f]+$/i, RQ = /^0b[01]+$/i, _Q = /^0o[0-7]+$/i, DQ = parseInt, IQ = typeof Ao == "object" && Ao && Ao.Object === Object && Ao, BQ = typeof self == "object" && self && self.Object === Object && self, NQ = IQ || BQ || Function("return this")(), $Q = Object.prototype, zQ = $Q.toString, FQ = Math.max, VQ = Math.min, lv = function() {
    return NQ.Date.now();
  };
  function WQ(t, e, n) {
    var r, i, o, s, a, l, c = 0, u = false, h = false, p = true;
    if (typeof t != "function")
      throw new TypeError(EQ);
    e = uM(e) || 0, D1(n) && (u = !!n.leading, h = "maxWait" in n, o = h ? FQ(uM(n.maxWait) || 0, e) : o, p = "trailing" in n ? !!n.trailing : p);
    function v(D) {
      var R = r, F = i;
      return r = i = void 0, c = D, s = t.apply(F, R), s;
    }
    function y(D) {
      return c = D, a = setTimeout(w, e), u ? v(D) : s;
    }
    function S(D) {
      var R = D - l, F = D - c, K = e - R;
      return h ? VQ(K, o - F) : K;
    }
    function T(D) {
      var R = D - l, F = D - c;
      return l === void 0 || R >= e || R < 0 || h && F >= o;
    }
    function w() {
      var D = lv();
      if (T(D))
        return k(D);
      a = setTimeout(w, S(D));
    }
    function k(D) {
      return a = void 0, p && r ? v(D) : (r = i = void 0, s);
    }
    function C() {
      a !== void 0 && clearTimeout(a), c = 0, r = l = i = a = void 0;
    }
    function O() {
      return a === void 0 ? s : k(lv());
    }
    function L() {
      var D = lv(), R = T(D);
      if (r = arguments, i = this, l = D, R) {
        if (a === void 0)
          return y(l);
        if (h)
          return a = setTimeout(w, e), v(l);
      }
      return a === void 0 && (a = setTimeout(w, e)), s;
    }
    return L.cancel = C, L.flush = O, L;
  }
  function D1(t) {
    var e = typeof t;
    return !!t && (e == "object" || e == "function");
  }
  function HQ(t) {
    return !!t && typeof t == "object";
  }
  function jQ(t) {
    return typeof t == "symbol" || HQ(t) && zQ.call(t) == PQ;
  }
  function uM(t) {
    if (typeof t == "number")
      return t;
    if (jQ(t))
      return cM;
    if (D1(t)) {
      var e = typeof t.valueOf == "function" ? t.valueOf() : t;
      t = D1(e) ? e + "" : e;
    }
    if (typeof t != "string")
      return t === 0 ? t : +t;
    t = t.replace(OQ, "");
    var n = RQ.test(t);
    return n || _Q.test(t) ? DQ(t.slice(2), n ? 2 : 8) : LQ.test(t) ? cM : +t;
  }
  var UQ = WQ;
  const KQ = async (t = {}, e) => {
    let n;
    if (e.startsWith("data:")) {
      const r = e.replace(/^data:.*?base64,/, "");
      let i;
      if (typeof Buffer == "function" && typeof Buffer.from == "function")
        i = Buffer.from(r, "base64");
      else if (typeof atob == "function") {
        const o = atob(r);
        i = new Uint8Array(o.length);
        for (let s = 0; s < o.length; s++)
          i[s] = o.charCodeAt(s);
      } else
        throw new Error("Cannot decode base64-encoded data URL");
      n = await WebAssembly.instantiate(i, t);
    } else {
      const r = await fetch(e), i = r.headers.get("Content-Type") || "";
      if ("instantiateStreaming" in WebAssembly && i.startsWith("application/wasm"))
        n = await WebAssembly.instantiateStreaming(r, t);
      else {
        const o = await r.arrayBuffer();
        n = await WebAssembly.instantiate(o, t);
      }
    }
    return n.instance.exports;
  };
  let yr;
  function qQ(t) {
    yr = t;
  }
  let Hh = null;
  function Ad() {
    return (Hh === null || Hh.byteLength === 0) && (Hh = new Uint8Array(yr.memory.buffer)), Hh;
  }
  let Ed = new TextDecoder("utf-8", {
    ignoreBOM: true,
    fatal: true
  });
  Ed.decode();
  const GQ = 2146435072;
  let cv = 0;
  function YQ(t, e) {
    return cv += e, cv >= GQ && (Ed = new TextDecoder("utf-8", {
      ignoreBOM: true,
      fatal: true
    }), Ed.decode(), cv = e), Ed.decode(Ad().subarray(t, t + e));
  }
  function mS(t, e) {
    return t = t >>> 0, YQ(t, e);
  }
  let Vp = 0;
  const tu = new TextEncoder();
  "encodeInto" in tu || (tu.encodeInto = function(t, e) {
    const n = tu.encode(t);
    return e.set(n), {
      read: t.length,
      written: n.length
    };
  });
  function r_(t, e, n) {
    if (n === void 0) {
      const a = tu.encode(t), l = e(a.length, 1) >>> 0;
      return Ad().subarray(l, l + a.length).set(a), Vp = a.length, l;
    }
    let r = t.length, i = e(r, 1) >>> 0;
    const o = Ad();
    let s = 0;
    for (; s < r; s++) {
      const a = t.charCodeAt(s);
      if (a > 127)
        break;
      o[i + s] = a;
    }
    if (s !== r) {
      s !== 0 && (t = t.slice(s)), i = n(i, r, r = s + t.length * 3, 1) >>> 0;
      const a = Ad().subarray(i + s, i + r), l = tu.encodeInto(t, a);
      s += l.written, i = n(i, r, s, 1) >>> 0;
    }
    return Vp = s, i;
  }
  let ca = null;
  function fM() {
    return (ca === null || ca.buffer.detached === true || ca.buffer.detached === void 0 && ca.buffer !== yr.memory.buffer) && (ca = new DataView(yr.memory.buffer)), ca;
  }
  function XQ(t) {
    let e, n;
    try {
      const r = r_(t, yr.__wbindgen_malloc, yr.__wbindgen_realloc), i = Vp, o = yr.compile(r, i);
      return e = o[0], n = o[1], mS(o[0], o[1]);
    } finally {
      yr.__wbindgen_free(e, n, 1);
    }
  }
  function QQ(t, e) {
    let n, r;
    try {
      n = t, r = e, console.error(mS(t, e));
    } finally {
      yr.__wbindgen_free(n, r, 1);
    }
  }
  function JQ() {
    return new Error();
  }
  function ZQ(t, e) {
    const n = e.stack, r = r_(n, yr.__wbindgen_malloc, yr.__wbindgen_realloc), i = Vp;
    fM().setInt32(t + 4 * 1, i, true), fM().setInt32(t + 4 * 0, r, true);
  }
  function eJ(t, e) {
    throw new Error(mS(t, e));
  }
  function tJ() {
    const t = yr.__wbindgen_export_3, e = t.grow(4);
    t.set(0, void 0), t.set(e + 0, void 0), t.set(e + 1, null), t.set(e + 2, true), t.set(e + 3, false);
  }
  const is = await KQ({
    "./monkey_wasm_bg.js": {
      __wbg_new_8a6f238a6ece86ea: JQ,
      __wbg_stack_0ed75d68575b0f3c: ZQ,
      __wbg_error_7534b8e9a36f1ab4: QQ,
      __wbg_wbindgenthrow_451ec1a8469d7eb6: eJ,
      __wbindgen_init_externref_table: tJ
    }
  }, "/monkey-rust/assets/monkey_wasm_bg.0089b01d.wasm?init"), nJ = is.memory, rJ = is.compile, iJ = is.parse, oJ = is.__wbindgen_free, sJ = is.__wbindgen_malloc, aJ = is.__wbindgen_realloc, lJ = is.__wbindgen_export_3, i_ = is.__wbindgen_start, cJ = Object.freeze(Object.defineProperty({
    __proto__: null,
    memory: nJ,
    compile: rJ,
    parse: iJ,
    __wbindgen_free: oJ,
    __wbindgen_malloc: sJ,
    __wbindgen_realloc: aJ,
    __wbindgen_export_3: lJ,
    __wbindgen_start: i_
  }, Symbol.toStringTag, {
    value: "Module"
  }));
  qQ(cJ);
  i_();
  const uJ = `
1 + 1;
if (true) { 10 }; 3333;
let a = [1, 2, 3];
`;
  function fJ() {
    let t = uJ.trimStart(), [e] = z.exports.useState(t);
    const n = (a) => {
      console.log(a), e = a, s(), console.log("change finished");
    };
    let [r, i] = z.exports.useState("");
    const o = () => {
      try {
        const a = XQ(e);
        i(a);
      } catch (a) {
        i(a.toString());
      }
    }, s = z.exports.useMemo(() => UQ(o, 200), [
      o
    ]);
    return z.exports.useEffect(() => {
      o();
    }, []), Yn(eO, {
      templateColumns: "repeat(2, 1fr)",
      height: "100vh",
      gap: 6,
      children: [
        J(lM, {
          onChange: n,
          code: e
        }),
        Yn(rO, {
          size: "md",
          variant: "enclosed",
          children: [
            J(oO, {
              children: J(iO, {
                children: "Bytecode"
              })
            }),
            Yn(sO, {
              children: [
                J($y, {
                  padding: 0,
                  children: J(lM, {
                    code: r,
                    extra: {
                      readOnly: true,
                      editable: false
                    }
                  })
                }),
                J($y, {
                  children: J("p", {
                    children: "two!"
                  })
                })
              ]
            })
          ]
        })
      ]
    });
  }
  uv.createRoot(document.getElementById("root")).render(J(Wp.StrictMode, {
    children: J(sj, {
      children: J(fJ, {})
    })
  }));
})();
