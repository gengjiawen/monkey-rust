{
  "!name": "jscodeshift",
  "!define": {
    "file": {
      "source": {
        "!type": "string",
        "!doc": "The source code of the current file."
      },
      "path": {
        "!type": "string",
        "!doc": "The absolute path to the current file"
      }
    },
    "apiObject": {
      "stats": {
        "!type": "fn(value: string)",
        "!doc": "Helper function to collect data during --dry runs. This function keeps a counter for how often it was called with a specific argument. The result is shown in the console. Useful for finding out how many files match a criterion."
      },
      "jscodeshift": {
        "!type": "fn(source: string|+NodePath) -> +Collection",
        "template": {
          "expression": {
            "!type": "fn(strings: [string], value: ?, value: ?) -> Expression",
            "!doc": "Tagged template function. Parses the string as source and returns an Expression AST node."
          },
          "statement": {
            "!type": "fn(strings: [string], value: ?, value: ?) -> Statement",
            "!doc": "Tagged template function. Parses the string as source and returns an Statement AST node."
          },
          "statements": {
            "!type": "fn(strings: [string], value: ?, value: ?) -> [Statement]",
            "!doc": "Tagged template function. Parses the string as source and returns an array of Statement AST nodes."
          }
        },
        "match": {
          "!type": "fn(node: ASTNode, pattern: object) -> bool",
          "!doc": "Returns true if node matches the pattern, else false"
        },
        "ModuleSpecifier": "TypeDefinition",
        "ConditionalExpression": "TypeDefinition",
        "Node": "TypeDefinition",
        "MixedTypeAnnotation": "TypeDefinition",
        "XMLAttributeSelector": "TypeDefinition",
        "JSXNamespacedName": "TypeDefinition",
        "GenericTypeAnnotation": "TypeDefinition",
        "XMLFunctionQualifiedIdentifier": "TypeDefinition",
        "ClassPropertyDefinition": "TypeDefinition",
        "NullableTypeAnnotation": "TypeDefinition",
        "ForInStatement": "TypeDefinition",
        "YieldExpression": "TypeDefinition",
        "ClassProperty": "TypeDefinition",
        "XMLDefaultDeclaration": "TypeDefinition",
        "TemplateElement": "TypeDefinition",
        "ExportDefaultDeclaration": "TypeDefinition",
        "TupleTypeAnnotation": "TypeDefinition",
        "GraphExpression": "TypeDefinition",
        "MemberExpression": "TypeDefinition",
        "ImportDeclaration": "TypeDefinition",
        "File": "TypeDefinition",
        "JSXSpreadAttribute": "TypeDefinition",
        "XMLName": "TypeDefinition",
        "ClassExpression": "TypeDefinition",
        "TemplateLiteral": "TypeDefinition",
        "ClassImplements": "TypeDefinition",
        "TypeAlias": "TypeDefinition",
        "StringLiteralTypeAnnotation": "TypeDefinition",
        "TaggedTemplateExpression": "TypeDefinition",
        "Identifier": "TypeDefinition",
        "JSXElement": "TypeDefinition",
        "BooleanLiteralTypeAnnotation": "TypeDefinition",
        "MethodDefinition": "TypeDefinition",
        "Line": "TypeDefinition",
        "GeneratorExpression": "TypeDefinition",
        "LetStatement": "TypeDefinition",
        "Literal": "TypeDefinition",
        "BooleanTypeAnnotation": "TypeDefinition",
        "JSXAttribute": "TypeDefinition",
        "ExportNamespaceSpecifier": "TypeDefinition",
        "ArrayTypeAnnotation": "TypeDefinition",
        "BlockStatement": "TypeDefinition",
        "WithStatement": "TypeDefinition",
        "XMLProcessingInstruction": "TypeDefinition",
        "SpreadPropertyPattern": "TypeDefinition",
        "WhileStatement": "TypeDefinition",
        "ThrowStatement": "TypeDefinition",
        "InterfaceDeclaration": "TypeDefinition",
        "TypeofTypeAnnotation": "TypeDefinition",
        "LetExpression": "TypeDefinition",
        "ExportSpecifier": "TypeDefinition",
        "ContinueStatement": "TypeDefinition",
        "Printable": "TypeDefinition",
        "ThisExpression": "TypeDefinition",
        "IntersectionTypeAnnotation": "TypeDefinition",
        "JSXClosingElement": "TypeDefinition",
        "DeclareFunction": "TypeDefinition",
        "VariableDeclaration": "TypeDefinition",
        "BreakStatement": "TypeDefinition",
        "ImportSpecifier": "TypeDefinition",
        "ParenthesizedExpression": "TypeDefinition",
        "RestElement": "TypeDefinition",
        "Specifier": "TypeDefinition",
        "ArrayExpression": "TypeDefinition",
        "XMLAnyName": "TypeDefinition",
        "ExportDeclaration": "TypeDefinition",
        "ObjectTypeAnnotation": "TypeDefinition",
        "ExportAllDeclaration": "TypeDefinition",
        "SourceLocation": "TypeDefinition",
        "TypeAnnotation": "TypeDefinition",
        "Statement": "TypeDefinition",
        "Position": "TypeDefinition",
        "ObjectExpression": "TypeDefinition",
        "Program": "TypeDefinition",
        "Comment": "TypeDefinition",
        "AssignmentPattern": "TypeDefinition",
        "ObjectTypeIndexer": "TypeDefinition",
        "ArrowFunctionExpression": "TypeDefinition",
        "XMLAttribute": "TypeDefinition",
        "Noop": "TypeDefinition",
        "DeclareClass": "TypeDefinition",
        "XMLEndTag": "TypeDefinition",
        "JSXIdentifier": "TypeDefinition",
        "VoidTypeAnnotation": "TypeDefinition",
        "ComprehensionBlock": "TypeDefinition",
        "FunctionTypeAnnotation": "TypeDefinition",
        "ComprehensionExpression": "TypeDefinition",
        "MetaProperty": "TypeDefinition",
        "XMLQualifiedIdentifier": "TypeDefinition",
        "DoWhileStatement": "TypeDefinition",
        "EmptyStatement": "TypeDefinition",
        "VariableDeclarator": "TypeDefinition",
        "ObjectPattern": "TypeDefinition",
        "AssignmentExpression": "TypeDefinition",
        "Declaration": "TypeDefinition",
        "DoExpression": "TypeDefinition",
        "GraphIndexExpression": "TypeDefinition",
        "DeclareVariable": "TypeDefinition",
        "ObjectTypeProperty": "TypeDefinition",
        "IfStatement": "TypeDefinition",
        "BindExpression": "TypeDefinition",
        "LogicalExpression": "TypeDefinition",
        "CommentLine": "TypeDefinition",
        "ObjectTypeCallProperty": "TypeDefinition",
        "FunctionDeclaration": "TypeDefinition",
        "NewExpression": "TypeDefinition",
        "TypeCastExpression": "TypeDefinition",
        "XMLStartTag": "TypeDefinition",
        "XMLPointTag": "TypeDefinition",
        "Pattern": "TypeDefinition",
        "ImportDefaultSpecifier": "TypeDefinition",
        "XMLFilterExpression": "TypeDefinition",
        "XMLEscape": "TypeDefinition",
        "JSXEmptyExpression": "TypeDefinition",
        "SequenceExpression": "TypeDefinition",
        "InterfaceExtends": "TypeDefinition",
        "PropertyPattern": "TypeDefinition",
        "CatchClause": "TypeDefinition",
        "SpreadElement": "TypeDefinition",
        "FunctionTypeParam": "TypeDefinition",
        "Property": "TypeDefinition",
        "JSXOpeningElement": "TypeDefinition",
        "StringTypeAnnotation": "TypeDefinition",
        "ForStatement": "TypeDefinition",
        "Decorator": "TypeDefinition",
        "SpreadElementPattern": "TypeDefinition",
        "JSXMemberExpression": "TypeDefinition",
        "FunctionExpression": "TypeDefinition",
        "BinaryExpression": "TypeDefinition",
        "TryStatement": "TypeDefinition",
        "Expression": "TypeDefinition",
        "ExportNamedDeclaration": "TypeDefinition",
        "SwitchStatement": "TypeDefinition",
        "Block": "TypeDefinition",
        "ExportBatchSpecifier": "TypeDefinition",
        "ExpressionStatement": "TypeDefinition",
        "ArrayPattern": "TypeDefinition",
        "XMLList": "TypeDefinition",
        "ReturnStatement": "TypeDefinition",
        "CallExpression": "TypeDefinition",
        "DeclareModule": "TypeDefinition",
        "NumberLiteralTypeAnnotation": "TypeDefinition",
        "Type": "TypeDefinition",
        "TypeParameterDeclaration": "TypeDefinition",
        "XMLText": "TypeDefinition",
        "Function": "TypeDefinition",
        "UnaryExpression": "TypeDefinition",
        "XML": "TypeDefinition",
        "Super": "TypeDefinition",
        "TypeParameterInstantiation": "TypeDefinition",
        "XMLComment": "TypeDefinition",
        "MemberTypeAnnotation": "TypeDefinition",
        "SwitchCase": "TypeDefinition",
        "AwaitExpression": "TypeDefinition",
        "ExportDefaultSpecifier": "TypeDefinition",
        "XMLElement": "TypeDefinition",
        "AnyTypeAnnotation": "TypeDefinition",
        "CommentBlock": "TypeDefinition",
        "ClassBody": "TypeDefinition",
        "ImportNamespaceSpecifier": "TypeDefinition",
        "JSXExpressionContainer": "TypeDefinition",
        "DeclareExportDeclaration": "TypeDefinition",
        "UnionTypeAnnotation": "TypeDefinition",
        "XMLCdata": "TypeDefinition",
        "JSXText": "TypeDefinition",
        "QualifiedTypeIdentifier": "TypeDefinition",
        "DebuggerStatement": "TypeDefinition",
        "ForOfStatement": "TypeDefinition",
        "LabeledStatement": "TypeDefinition",
        "SpreadProperty": "TypeDefinition",
        "UpdateExpression": "TypeDefinition",
        "ClassDeclaration": "TypeDefinition",
        "NumberTypeAnnotation": "TypeDefinition",
        "switchStatement": {
          "!type": "fn(discriminant: Expression, cases: [SwitchCase], lexical: boolean) -> SwitchStatement",
          "!doc": "Builds an AST node of type 'SwitchStatement'.\nSuper types: Statement, Node, Printable"
        },
        "identifier": {
          "!type": "fn(name: string) -> Identifier",
          "!doc": "Builds an AST node of type 'Identifier'.\nSuper types: Expression, Pattern, Node, Printable"
        },
        "classPropertyDefinition": {
          "!type": "fn(definition: MethodDefinition|VariableDeclarator|ClassPropertyDefinition|ClassProperty) -> ClassPropertyDefinition",
          "!doc": "Builds an AST node of type 'ClassPropertyDefinition'.\nSuper types: Declaration, Statement, Node, Printable"
        },
        "jsxMemberExpression": {
          "!type": "fn(object: JSXIdentifier|JSXMemberExpression, property: JSXIdentifier) -> JSXMemberExpression",
          "!doc": "Builds an AST node of type 'JSXMemberExpression'.\nSuper types: MemberExpression, Expression, Pattern, Node, Printable"
        },
        "exportNamespaceSpecifier": {
          "!type": "fn(exported: Identifier) -> ExportNamespaceSpecifier",
          "!doc": "Builds an AST node of type 'ExportNamespaceSpecifier'.\nSuper types: Specifier, Node, Printable"
        },
        "conditionalExpression": {
          "!type": "fn(test: Expression, consequent: Expression, alternate: Expression) -> ConditionalExpression",
          "!doc": "Builds an AST node of type 'ConditionalExpression'.\nSuper types: Expression, Pattern, Node, Printable"
        },
        "parenthesizedExpression": {
          "!type": "fn(expression: Expression) -> ParenthesizedExpression",
          "!doc": "Builds an AST node of type 'ParenthesizedExpression'.\nSuper types: Expression, Pattern, Node, Printable"
        },
        "yieldExpression": {
          "!type": "fn(argument: Expression|null, delegate: boolean) -> YieldExpression",
          "!doc": "Builds an AST node of type 'YieldExpression'.\nSuper types: Expression, Pattern, Node, Printable"
        },
        "typeParameterInstantiation": {
          "!type": "fn(params: [Type]) -> TypeParameterInstantiation",
          "!doc": "Builds an AST node of type 'TypeParameterInstantiation'.\nSuper types: Node, Printable"
        },
        "bindExpression": {
          "!type": "fn(object: Expression|null, callee: Expression) -> BindExpression",
          "!doc": "Builds an AST node of type 'BindExpression'.\nSuper types: Expression, Pattern, Node, Printable"
        },
        "expressionStatement": {
          "!type": "fn(expression: Expression) -> ExpressionStatement",
          "!doc": "Builds an AST node of type 'ExpressionStatement'.\nSuper types: Statement, Node, Printable"
        },
        "spreadElement": {
          "!type": "fn(argument: Expression) -> SpreadElement",
          "!doc": "Builds an AST node of type 'SpreadElement'.\nSuper types: Node, Printable"
        },
        "program": {
          "!type": "fn(body: [Statement]) -> Program",
          "!doc": "Builds an AST node of type 'Program'.\nSuper types: Node, Printable"
        },
        "jsxElement": {
          "!type": "fn(openingElement: JSXOpeningElement, closingElement: JSXClosingElement|null, children: [JSXElement|JSXExpressionContainer|JSXText|Literal]) -> JSXElement",
          "!doc": "Builds an AST node of type 'JSXElement'.\nSuper types: Expression, Pattern, Node, Printable"
        },
        "memberTypeAnnotation": {
          "!type": "fn(object: Identifier, property: MemberTypeAnnotation|GenericTypeAnnotation) -> MemberTypeAnnotation",
          "!doc": "Builds an AST node of type 'MemberTypeAnnotation'.\nSuper types: Type, Node, Printable"
        },
        "importNamespaceSpecifier": {
          "!type": "fn(local: Identifier|null) -> ImportNamespaceSpecifier",
          "!doc": "Builds an AST node of type 'ImportNamespaceSpecifier'.\nSuper types: ModuleSpecifier, Specifier, Node, Printable"
        },
        "numberLiteralTypeAnnotation": {
          "!type": "fn(value: number, raw: string) -> NumberLiteralTypeAnnotation",
          "!doc": "Builds an AST node of type 'NumberLiteralTypeAnnotation'.\nSuper types: Type, Node, Printable"
        },
        "typeofTypeAnnotation": {
          "!type": "fn(argument: Type) -> TypeofTypeAnnotation",
          "!doc": "Builds an AST node of type 'TypeofTypeAnnotation'.\nSuper types: Type, Node, Printable"
        },
        "declareClass": {
          "!type": "fn(id: Identifier) -> DeclareClass",
          "!doc": "Builds an AST node of type 'DeclareClass'.\nSuper types: InterfaceDeclaration, Statement, Node, Printable"
        },
        "declareFunction": {
          "!type": "fn(id: Identifier) -> DeclareFunction",
          "!doc": "Builds an AST node of type 'DeclareFunction'.\nSuper types: Statement, Node, Printable"
        },
        "logicalExpression": {
          "!type": "fn(operator: string, left: Expression, right: Expression) -> LogicalExpression",
          "!doc": "Builds an AST node of type 'LogicalExpression'.\nSuper types: Expression, Pattern, Node, Printable\n\n operator (string) one of: |||&&\n"
        },
        "jsxNamespacedName": {
          "!type": "fn(namespace: JSXIdentifier, name: JSXIdentifier) -> JSXNamespacedName",
          "!doc": "Builds an AST node of type 'JSXNamespacedName'.\nSuper types: Node, Printable"
        },
        "debuggerStatement": {
          "!type": "fn() -> DebuggerStatement",
          "!doc": "Builds an AST node of type 'DebuggerStatement'.\nSuper types: Statement, Node, Printable"
        },
        "methodDefinition": {
          "!type": "fn(kind: string, key: Literal|Identifier|Expression, value: Function, static: boolean) -> MethodDefinition",
          "!doc": "Builds an AST node of type 'MethodDefinition'.\nSuper types: Declaration, Statement, Node, Printable\n\n kind (string) one of: constructor|method|get|set\n"
        },
        "functionTypeAnnotation": {
          "!type": "fn(params: [FunctionTypeParam], returnType: Type, rest: FunctionTypeParam|null, typeParameters: TypeParameterDeclaration|null) -> FunctionTypeAnnotation",
          "!doc": "Builds an AST node of type 'FunctionTypeAnnotation'.\nSuper types: Type, Node, Printable"
        },
        "objectPattern": {
          "!type": "fn(properties: [Property|PropertyPattern|SpreadPropertyPattern|SpreadProperty]) -> ObjectPattern",
          "!doc": "Builds an AST node of type 'ObjectPattern'.\nSuper types: Pattern, Node, Printable"
        },
        "unionTypeAnnotation": {
          "!type": "fn(types: [Type]) -> UnionTypeAnnotation",
          "!doc": "Builds an AST node of type 'UnionTypeAnnotation'.\nSuper types: Type, Node, Printable"
        },
        "ifStatement": {
          "!type": "fn(test: Expression, consequent: Statement, alternate: Statement|null) -> IfStatement",
          "!doc": "Builds an AST node of type 'IfStatement'.\nSuper types: Statement, Node, Printable"
        },
        "forInStatement": {
          "!type": "fn(left: VariableDeclaration|Expression, right: Expression, body: Statement, each: boolean) -> ForInStatement",
          "!doc": "Builds an AST node of type 'ForInStatement'.\nSuper types: Statement, Node, Printable"
        },
        "letStatement": {
          "!type": "fn(head: [VariableDeclarator], body: Statement) -> LetStatement",
          "!doc": "Builds an AST node of type 'LetStatement'.\nSuper types: Statement, Node, Printable"
        },
        "jsxEmptyExpression": {
          "!type": "fn() -> JSXEmptyExpression",
          "!doc": "Builds an AST node of type 'JSXEmptyExpression'.\nSuper types: Expression, Pattern, Node, Printable"
        },
        "qualifiedTypeIdentifier": {
          "!type": "fn(qualification: Identifier|QualifiedTypeIdentifier, id: Identifier) -> QualifiedTypeIdentifier",
          "!doc": "Builds an AST node of type 'QualifiedTypeIdentifier'.\nSuper types: Node, Printable"
        },
        "metaProperty": {
          "!type": "fn(meta: Identifier, property: Identifier) -> MetaProperty",
          "!doc": "Builds an AST node of type 'MetaProperty'.\nSuper types: Expression, Pattern, Node, Printable"
        },
        "tryStatement": {
          "!type": "fn(block: BlockStatement, handler: CatchClause|null, finalizer: BlockStatement|null) -> TryStatement",
          "!doc": "Builds an AST node of type 'TryStatement'.\nSuper types: Statement, Node, Printable"
        },
        "arrayTypeAnnotation": {
          "!type": "fn(elementType: Type) -> ArrayTypeAnnotation",
          "!doc": "Builds an AST node of type 'ArrayTypeAnnotation'.\nSuper types: Type, Node, Printable"
        },
        "taggedTemplateExpression": {
          "!type": "fn(tag: Expression, quasi: TemplateLiteral) -> TaggedTemplateExpression",
          "!doc": "Builds an AST node of type 'TaggedTemplateExpression'.\nSuper types: Expression, Pattern, Node, Printable"
        },
        "spreadPropertyPattern": {
          "!type": "fn(argument: Pattern) -> SpreadPropertyPattern",
          "!doc": "Builds an AST node of type 'SpreadPropertyPattern'.\nSuper types: Pattern, Node, Printable"
        },
        "stringTypeAnnotation": {
          "!type": "fn() -> StringTypeAnnotation",
          "!doc": "Builds an AST node of type 'StringTypeAnnotation'.\nSuper types: Type, Node, Printable"
        },
        "objectTypeProperty": {
          "!type": "fn(key: Literal|Identifier, value: Type, optional: boolean) -> ObjectTypeProperty",
          "!doc": "Builds an AST node of type 'ObjectTypeProperty'.\nSuper types: Node, Printable"
        },
        "labeledStatement": {
          "!type": "fn(label: Identifier, body: Statement) -> LabeledStatement",
          "!doc": "Builds an AST node of type 'LabeledStatement'.\nSuper types: Statement, Node, Printable"
        },
        "typeAlias": {
          "!type": "fn(id: Identifier, typeParameters: TypeParameterDeclaration|null, right: Type) -> TypeAlias",
          "!doc": "Builds an AST node of type 'TypeAlias'.\nSuper types: Declaration, Statement, Node, Printable"
        },
        "exportSpecifier": {
          "!type": "fn(local: Identifier|null, exported: Identifier) -> ExportSpecifier",
          "!doc": "Builds an AST node of type 'ExportSpecifier'.\nSuper types: ModuleSpecifier, Specifier, Node, Printable"
        },
        "whileStatement": {
          "!type": "fn(test: Expression, body: Statement) -> WhileStatement",
          "!doc": "Builds an AST node of type 'WhileStatement'.\nSuper types: Statement, Node, Printable"
        },
        "functionDeclaration": {
          "!type": "fn(id: Identifier, params: [Pattern], body: BlockStatement|Expression, generator: boolean, expression: boolean) -> FunctionDeclaration",
          "!doc": "Builds an AST node of type 'FunctionDeclaration'.\nSuper types: Function, Declaration, Statement, Node, Printable"
        },
        "stringLiteralTypeAnnotation": {
          "!type": "fn(value: string, raw: string) -> StringLiteralTypeAnnotation",
          "!doc": "Builds an AST node of type 'StringLiteralTypeAnnotation'.\nSuper types: Type, Node, Printable"
        },
        "callExpression": {
          "!type": "fn(callee: Expression, arguments: [Expression|SpreadElement]) -> CallExpression",
          "!doc": "Builds an AST node of type 'CallExpression'.\nSuper types: Expression, Pattern, Node, Printable"
        },
        "assignmentPattern": {
          "!type": "fn(left: Pattern, right: Expression) -> AssignmentPattern",
          "!doc": "Builds an AST node of type 'AssignmentPattern'.\nSuper types: Pattern, Node, Printable"
        },
        "declareVariable": {
          "!type": "fn(id: Identifier) -> DeclareVariable",
          "!doc": "Builds an AST node of type 'DeclareVariable'.\nSuper types: Statement, Node, Printable"
        },
        "assignmentExpression": {
          "!type": "fn(operator: string, left: Pattern, right: Expression) -> AssignmentExpression",
          "!doc": "Builds an AST node of type 'AssignmentExpression'.\nSuper types: Expression, Pattern, Node, Printable\n\n operator (string) one of: =|+=|-=|*=|/=|%=|<<=|>>=|>>>=||=|^=|&=\n"
        },
        "arrayPattern": {
          "!type": "fn(elements: [Pattern|SpreadElement|null]) -> ArrayPattern",
          "!doc": "Builds an AST node of type 'ArrayPattern'.\nSuper types: Pattern, Node, Printable"
        },
        "generatorExpression": {
          "!type": "fn(body: Expression, blocks: [ComprehensionBlock], filter: Expression|null) -> GeneratorExpression",
          "!doc": "Builds an AST node of type 'GeneratorExpression'.\nSuper types: Expression, Pattern, Node, Printable"
        },
        "forStatement": {
          "!type": "fn(init: VariableDeclaration|Expression|null, test: Expression|null, update: Expression|null, body: Statement) -> ForStatement",
          "!doc": "Builds an AST node of type 'ForStatement'.\nSuper types: Statement, Node, Printable"
        },
        "graphExpression": {
          "!type": "fn(index: number, expression: Literal) -> GraphExpression",
          "!doc": "Builds an AST node of type 'GraphExpression'.\nSuper types: Expression, Pattern, Node, Printable\n\n ${name} (number) must be >= 0"
        },
        "commentLine": {
          "!type": "fn(value: string, leading: boolean, trailing: boolean) -> CommentLine",
          "!doc": "Builds an AST node of type 'CommentLine'.\nSuper types: Comment, Printable"
        },
        "functionExpression": {
          "!type": "fn(id: Identifier|null, params: [Pattern], body: BlockStatement|Expression, generator: boolean, expression: boolean) -> FunctionExpression",
          "!doc": "Builds an AST node of type 'FunctionExpression'.\nSuper types: Function, Expression, Pattern, Node, Printable"
        },
        "thisExpression": {
          "!type": "fn() -> ThisExpression",
          "!doc": "Builds an AST node of type 'ThisExpression'.\nSuper types: Expression, Pattern, Node, Printable"
        },
        "jsxOpeningElement": {
          "!type": "fn(name: JSXIdentifier|JSXNamespacedName|JSXMemberExpression, attributes: [JSXAttribute|JSXSpreadAttribute], selfClosing: boolean) -> JSXOpeningElement",
          "!doc": "Builds an AST node of type 'JSXOpeningElement'.\nSuper types: Node, Printable"
        },
        "exportNamedDeclaration": {
          "!type": "fn(declaration: Declaration|null, specifiers: [ExportSpecifier], source: Literal|null) -> ExportNamedDeclaration",
          "!doc": "Builds an AST node of type 'ExportNamedDeclaration'.\nSuper types: Declaration, Statement, Node, Printable"
        },
        "mixedTypeAnnotation": {
          "!type": "fn() -> MixedTypeAnnotation",
          "!doc": "Builds an AST node of type 'MixedTypeAnnotation'.\nSuper types: Type, Node, Printable"
        },
        "objectTypeCallProperty": {
          "!type": "fn(value: FunctionTypeAnnotation) -> ObjectTypeCallProperty",
          "!doc": "Builds an AST node of type 'ObjectTypeCallProperty'.\nSuper types: Node, Printable"
        },
        "classBody": {
          "!type": "fn(body: [MethodDefinition|VariableDeclarator|ClassPropertyDefinition|ClassProperty]) -> ClassBody",
          "!doc": "Builds an AST node of type 'ClassBody'.\nSuper types: Declaration, Statement, Node, Printable"
        },
        "position": {
          "!type": "fn(line: number, column: number) -> Position",
          "!doc": "Builds an AST node of type 'Position'.\n\n ${name} (number) must be >= 1${name} (number) must be >= 0"
        },
        "importSpecifier": {
          "!type": "fn(imported: Identifier, local: Identifier|null) -> ImportSpecifier",
          "!doc": "Builds an AST node of type 'ImportSpecifier'.\nSuper types: ModuleSpecifier, Specifier, Node, Printable"
        },
        "jsxExpressionContainer": {
          "!type": "fn(expression: Expression) -> JSXExpressionContainer",
          "!doc": "Builds an AST node of type 'JSXExpressionContainer'.\nSuper types: Expression, Pattern, Node, Printable"
        },
        "booleanTypeAnnotation": {
          "!type": "fn() -> BooleanTypeAnnotation",
          "!doc": "Builds an AST node of type 'BooleanTypeAnnotation'.\nSuper types: Type, Node, Printable"
        },
        "classProperty": {
          "!type": "fn(key: Literal|Identifier|Expression, value: Expression|null, typeAnnotation: TypeAnnotation|null, static: boolean) -> ClassProperty",
          "!doc": "Builds an AST node of type 'ClassProperty'.\nSuper types: Declaration, Statement, Node, Printable"
        },
        "withStatement": {
          "!type": "fn(object: Expression, body: Statement) -> WithStatement",
          "!doc": "Builds an AST node of type 'WithStatement'.\nSuper types: Statement, Node, Printable"
        },
        "typeAnnotation": {
          "!type": "fn(typeAnnotation: Type) -> TypeAnnotation",
          "!doc": "Builds an AST node of type 'TypeAnnotation'.\nSuper types: Node, Printable"
        },
        "variableDeclarator": {
          "!type": "fn(id: Pattern, init: Expression|null) -> VariableDeclarator",
          "!doc": "Builds an AST node of type 'VariableDeclarator'.\nSuper types: Node, Printable"
        },
        "exportDeclaration": {
          "!type": "fn(default: boolean, declaration: Declaration|Expression|null, specifiers: [ExportSpecifier|ExportBatchSpecifier], source: Literal|null) -> ExportDeclaration",
          "!doc": "Builds an AST node of type 'ExportDeclaration'.\nSuper types: Declaration, Statement, Node, Printable"
        },
        "jsxAttribute": {
          "!type": "fn(name: JSXIdentifier|JSXNamespacedName, value: Literal|JSXExpressionContainer|null) -> JSXAttribute",
          "!doc": "Builds an AST node of type 'JSXAttribute'.\nSuper types: Node, Printable"
        },
        "spreadElementPattern": {
          "!type": "fn(argument: Pattern) -> SpreadElementPattern",
          "!doc": "Builds an AST node of type 'SpreadElementPattern'.\nSuper types: Pattern, Node, Printable"
        },
        "jsxIdentifier": {
          "!type": "fn(name: string) -> JSXIdentifier",
          "!doc": "Builds an AST node of type 'JSXIdentifier'.\nSuper types: Identifier, Expression, Pattern, Node, Printable"
        },
        "objectTypeIndexer": {
          "!type": "fn(id: Identifier, key: Type, value: Type) -> ObjectTypeIndexer",
          "!doc": "Builds an AST node of type 'ObjectTypeIndexer'.\nSuper types: Node, Printable"
        },
        "block": {
          "!type": "fn(value: string, leading: boolean, trailing: boolean) -> Block",
          "!doc": "Builds an AST node of type 'Block'.\nSuper types: Comment, Printable"
        },
        "declareModule": {
          "!type": "fn(id: Identifier|Literal, body: BlockStatement) -> DeclareModule",
          "!doc": "Builds an AST node of type 'DeclareModule'.\nSuper types: Statement, Node, Printable"
        },
        "exportDefaultDeclaration": {
          "!type": "fn(declaration: Declaration|Expression) -> ExportDefaultDeclaration",
          "!doc": "Builds an AST node of type 'ExportDefaultDeclaration'.\nSuper types: Declaration, Statement, Node, Printable"
        },
        "emptyStatement": {
          "!type": "fn() -> EmptyStatement",
          "!doc": "Builds an AST node of type 'EmptyStatement'.\nSuper types: Statement, Node, Printable"
        },
        "sequenceExpression": {
          "!type": "fn(expressions: [Expression]) -> SequenceExpression",
          "!doc": "Builds an AST node of type 'SequenceExpression'.\nSuper types: Expression, Pattern, Node, Printable"
        },
        "spreadProperty": {
          "!type": "fn(argument: Expression) -> SpreadProperty",
          "!doc": "Builds an AST node of type 'SpreadProperty'.\nSuper types: Node, Printable"
        },
        "awaitExpression": {
          "!type": "fn(argument: Expression|null, all: boolean) -> AwaitExpression",
          "!doc": "Builds an AST node of type 'AwaitExpression'.\nSuper types: Expression, Pattern, Node, Printable"
        },
        "classDeclaration": {
          "!type": "fn(id: Identifier|null, body: ClassBody, superClass: Expression|null) -> ClassDeclaration",
          "!doc": "Builds an AST node of type 'ClassDeclaration'.\nSuper types: Declaration, Statement, Node, Printable"
        },
        "literal": {
          "!type": "fn(value: string|boolean|null|number|RegExp) -> Literal",
          "!doc": "Builds an AST node of type 'Literal'.\nSuper types: Expression, Pattern, Node, Printable"
        },
        "letExpression": {
          "!type": "fn(head: [VariableDeclarator], body: Expression) -> LetExpression",
          "!doc": "Builds an AST node of type 'LetExpression'.\nSuper types: Expression, Pattern, Node, Printable"
        },
        "exportAllDeclaration": {
          "!type": "fn(exported: Identifier|null, source: Literal) -> ExportAllDeclaration",
          "!doc": "Builds an AST node of type 'ExportAllDeclaration'.\nSuper types: Declaration, Statement, Node, Printable"
        },
        "forOfStatement": {
          "!type": "fn(left: VariableDeclaration|Expression, right: Expression, body: Statement) -> ForOfStatement",
          "!doc": "Builds an AST node of type 'ForOfStatement'.\nSuper types: Statement, Node, Printable"
        },
        "doWhileStatement": {
          "!type": "fn(body: Statement, test: Expression) -> DoWhileStatement",
          "!doc": "Builds an AST node of type 'DoWhileStatement'.\nSuper types: Statement, Node, Printable"
        },
        "booleanLiteralTypeAnnotation": {
          "!type": "fn(value: boolean, raw: string) -> BooleanLiteralTypeAnnotation",
          "!doc": "Builds an AST node of type 'BooleanLiteralTypeAnnotation'.\nSuper types: Type, Node, Printable"
        },
        "genericTypeAnnotation": {
          "!type": "fn(id: Identifier|QualifiedTypeIdentifier, typeParameters: TypeParameterInstantiation|null) -> GenericTypeAnnotation",
          "!doc": "Builds an AST node of type 'GenericTypeAnnotation'.\nSuper types: Type, Node, Printable"
        },
        "declareExportDeclaration": {
          "!type": "fn(default: boolean, declaration: DeclareVariable|DeclareFunction|DeclareClass|Type|null, specifiers: [ExportSpecifier|ExportBatchSpecifier], source: Literal|null) -> DeclareExportDeclaration",
          "!doc": "Builds an AST node of type 'DeclareExportDeclaration'.\nSuper types: Declaration, Statement, Node, Printable"
        },
        "classExpression": {
          "!type": "fn(id: Identifier|null, body: ClassBody, superClass: Expression|null) -> ClassExpression",
          "!doc": "Builds an AST node of type 'ClassExpression'.\nSuper types: Expression, Pattern, Node, Printable"
        },
        "templateElement": {
          "!type": "fn(value: TemplateElementValue, tail: boolean) -> TemplateElement",
          "!doc": "Builds an AST node of type 'TemplateElement'.\nSuper types: Node, Printable\n\n value (object) has form {cooked: string, raw: string}"
        },
        "intersectionTypeAnnotation": {
          "!type": "fn(types: [Type]) -> IntersectionTypeAnnotation",
          "!doc": "Builds an AST node of type 'IntersectionTypeAnnotation'.\nSuper types: Type, Node, Printable"
        },
        "noop": {
          "!type": "fn() -> Noop",
          "!doc": "Builds an AST node of type 'Noop'.\nSuper types: Node, Printable"
        },
        "jsxSpreadAttribute": {
          "!type": "fn(argument: Expression) -> JSXSpreadAttribute",
          "!doc": "Builds an AST node of type 'JSXSpreadAttribute'.\nSuper types: Node, Printable"
        },
        "line": {
          "!type": "fn(value: string, leading: boolean, trailing: boolean) -> Line",
          "!doc": "Builds an AST node of type 'Line'.\nSuper types: Comment, Printable"
        },
        "jsxText": {
          "!type": "fn(value: string) -> JSXText",
          "!doc": "Builds an AST node of type 'JSXText'.\nSuper types: Literal, Expression, Pattern, Node, Printable"
        },
        "voidTypeAnnotation": {
          "!type": "fn() -> VoidTypeAnnotation",
          "!doc": "Builds an AST node of type 'VoidTypeAnnotation'.\nSuper types: Type, Node, Printable"
        },
        "comprehensionExpression": {
          "!type": "fn(body: Expression, blocks: [ComprehensionBlock], filter: Expression|null) -> ComprehensionExpression",
          "!doc": "Builds an AST node of type 'ComprehensionExpression'.\nSuper types: Expression, Pattern, Node, Printable"
        },
        "jsxClosingElement": {
          "!type": "fn(name: JSXIdentifier|JSXNamespacedName|JSXMemberExpression) -> JSXClosingElement",
          "!doc": "Builds an AST node of type 'JSXClosingElement'.\nSuper types: Node, Printable"
        },
        "typeParameterDeclaration": {
          "!type": "fn(params: [Identifier]) -> TypeParameterDeclaration",
          "!doc": "Builds an AST node of type 'TypeParameterDeclaration'.\nSuper types: Node, Printable"
        },
        "super": {
          "!type": "fn() -> Super",
          "!doc": "Builds an AST node of type 'Super'.\nSuper types: Expression, Pattern, Node, Printable"
        },
        "numberTypeAnnotation": {
          "!type": "fn() -> NumberTypeAnnotation",
          "!doc": "Builds an AST node of type 'NumberTypeAnnotation'.\nSuper types: Type, Node, Printable"
        },
        "throwStatement": {
          "!type": "fn(argument: Expression) -> ThrowStatement",
          "!doc": "Builds an AST node of type 'ThrowStatement'.\nSuper types: Statement, Node, Printable"
        },
        "catchClause": {
          "!type": "fn(param: Pattern, guard: Expression|null, body: BlockStatement) -> CatchClause",
          "!doc": "Builds an AST node of type 'CatchClause'.\nSuper types: Node, Printable"
        },
        "variableDeclaration": {
          "!type": "fn(kind: string, declarations: [VariableDeclarator|Identifier]) -> VariableDeclaration",
          "!doc": "Builds an AST node of type 'VariableDeclaration'.\nSuper types: Declaration, Statement, Node, Printable\n\n kind (string) one of: var|let|const\n"
        },
        "exportDefaultSpecifier": {
          "!type": "fn(exported: Identifier) -> ExportDefaultSpecifier",
          "!doc": "Builds an AST node of type 'ExportDefaultSpecifier'.\nSuper types: Specifier, Node, Printable"
        },
        "newExpression": {
          "!type": "fn(callee: Expression, arguments: [Expression|SpreadElement]) -> NewExpression",
          "!doc": "Builds an AST node of type 'NewExpression'.\nSuper types: Expression, Pattern, Node, Printable"
        },
        "graphIndexExpression": {
          "!type": "fn(index: number) -> GraphIndexExpression",
          "!doc": "Builds an AST node of type 'GraphIndexExpression'.\nSuper types: Expression, Pattern, Node, Printable\n\n ${name} (number) must be >= 0"
        },
        "updateExpression": {
          "!type": "fn(operator: string, argument: Expression, prefix: boolean) -> UpdateExpression",
          "!doc": "Builds an AST node of type 'UpdateExpression'.\nSuper types: Expression, Pattern, Node, Printable\n\n operator (string) one of: ++|--\n"
        },
        "commentBlock": {
          "!type": "fn(value: string, leading: boolean, trailing: boolean) -> CommentBlock",
          "!doc": "Builds an AST node of type 'CommentBlock'.\nSuper types: Comment, Printable"
        },
        "typeCastExpression": {
          "!type": "fn(expression: Expression, typeAnnotation: TypeAnnotation) -> TypeCastExpression",
          "!doc": "Builds an AST node of type 'TypeCastExpression'.\nSuper types: Expression, Pattern, Node, Printable"
        },
        "property": {
          "!type": "fn(kind: string, key: Literal|Identifier|Expression, value: Expression|Pattern) -> Property",
          "!doc": "Builds an AST node of type 'Property'.\nSuper types: Node, Printable\n\n kind (string) one of: init|get|set\n"
        },
        "interfaceDeclaration": {
          "!type": "fn(id: Identifier, body: ObjectTypeAnnotation, extends: [InterfaceExtends]) -> InterfaceDeclaration",
          "!doc": "Builds an AST node of type 'InterfaceDeclaration'.\nSuper types: Statement, Node, Printable"
        },
        "functionTypeParam": {
          "!type": "fn(name: Identifier, typeAnnotation: Type, optional: boolean) -> FunctionTypeParam",
          "!doc": "Builds an AST node of type 'FunctionTypeParam'.\nSuper types: Node, Printable"
        },
        "returnStatement": {
          "!type": "fn(argument: Expression|null) -> ReturnStatement",
          "!doc": "Builds an AST node of type 'ReturnStatement'.\nSuper types: Statement, Node, Printable"
        },
        "exportBatchSpecifier": {
          "!type": "fn() -> ExportBatchSpecifier",
          "!doc": "Builds an AST node of type 'ExportBatchSpecifier'.\nSuper types: Specifier, Node, Printable"
        },
        "decorator": {
          "!type": "fn(expression: Expression) -> Decorator",
          "!doc": "Builds an AST node of type 'Decorator'.\nSuper types: Node, Printable"
        },
        "sourceLocation": {
          "!type": "fn(start: Position, end: Position, source: string|null) -> SourceLocation",
          "!doc": "Builds an AST node of type 'SourceLocation'."
        },
        "file": {
          "!type": "fn(program: Program) -> File",
          "!doc": "Builds an AST node of type 'File'.\nSuper types: Node, Printable"
        },
        "binaryExpression": {
          "!type": "fn(operator: string, left: Expression, right: Expression) -> BinaryExpression",
          "!doc": "Builds an AST node of type 'BinaryExpression'.\nSuper types: Expression, Pattern, Node, Printable\n\n operator (string) one of: ==|!=|===|!==|<|<=|>|>=|<<|>>|>>>|+|-|*|/|%|&|||^|in|instanceof|..\n"
        },
        "propertyPattern": {
          "!type": "fn(key: Literal|Identifier|Expression, pattern: Pattern) -> PropertyPattern",
          "!doc": "Builds an AST node of type 'PropertyPattern'.\nSuper types: Pattern, Node, Printable"
        },
        "importDeclaration": {
          "!type": "fn(specifiers: [ImportSpecifier|ImportNamespaceSpecifier|ImportDefaultSpecifier], source: Literal) -> ImportDeclaration",
          "!doc": "Builds an AST node of type 'ImportDeclaration'.\nSuper types: Declaration, Statement, Node, Printable"
        },
        "doExpression": {
          "!type": "fn(body: [Statement]) -> DoExpression",
          "!doc": "Builds an AST node of type 'DoExpression'.\nSuper types: Expression, Pattern, Node, Printable"
        },
        "restElement": {
          "!type": "fn(argument: Pattern) -> RestElement",
          "!doc": "Builds an AST node of type 'RestElement'.\nSuper types: Pattern, Node, Printable"
        },
        "anyTypeAnnotation": {
          "!type": "fn() -> AnyTypeAnnotation",
          "!doc": "Builds an AST node of type 'AnyTypeAnnotation'.\nSuper types: Type, Node, Printable"
        },
        "templateLiteral": {
          "!type": "fn(quasis: [TemplateElement], expressions: [Expression]) -> TemplateLiteral",
          "!doc": "Builds an AST node of type 'TemplateLiteral'.\nSuper types: Expression, Pattern, Node, Printable"
        },
        "nullableTypeAnnotation": {
          "!type": "fn(typeAnnotation: Type) -> NullableTypeAnnotation",
          "!doc": "Builds an AST node of type 'NullableTypeAnnotation'.\nSuper types: Type, Node, Printable"
        },
        "continueStatement": {
          "!type": "fn(label: Identifier|null) -> ContinueStatement",
          "!doc": "Builds an AST node of type 'ContinueStatement'.\nSuper types: Statement, Node, Printable"
        },
        "arrayExpression": {
          "!type": "fn(elements: [Expression|SpreadElement|RestElement|null]) -> ArrayExpression",
          "!doc": "Builds an AST node of type 'ArrayExpression'.\nSuper types: Expression, Pattern, Node, Printable"
        },
        "classImplements": {
          "!type": "fn(id: Identifier) -> ClassImplements",
          "!doc": "Builds an AST node of type 'ClassImplements'.\nSuper types: Node, Printable"
        },
        "objectTypeAnnotation": {
          "!type": "fn(properties: [ObjectTypeProperty]) -> ObjectTypeAnnotation",
          "!doc": "Builds an AST node of type 'ObjectTypeAnnotation'.\nSuper types: Type, Node, Printable"
        },
        "memberExpression": {
          "!type": "fn(object: Expression, property: Identifier|Expression, computed: boolean) -> MemberExpression",
          "!doc": "Builds an AST node of type 'MemberExpression'.\nSuper types: Expression, Pattern, Node, Printable"
        },
        "comprehensionBlock": {
          "!type": "fn(left: Pattern, right: Expression, each: boolean) -> ComprehensionBlock",
          "!doc": "Builds an AST node of type 'ComprehensionBlock'.\nSuper types: Node, Printable"
        },
        "breakStatement": {
          "!type": "fn(label: Identifier|null) -> BreakStatement",
          "!doc": "Builds an AST node of type 'BreakStatement'.\nSuper types: Statement, Node, Printable"
        },
        "arrowFunctionExpression": {
          "!type": "fn(params: [Pattern], body: BlockStatement|Expression, expression: boolean) -> ArrowFunctionExpression",
          "!doc": "Builds an AST node of type 'ArrowFunctionExpression'.\nSuper types: Function, Expression, Pattern, Node, Printable"
        },
        "switchCase": {
          "!type": "fn(test: Expression|null, consequent: [Statement]) -> SwitchCase",
          "!doc": "Builds an AST node of type 'SwitchCase'.\nSuper types: Node, Printable"
        },
        "blockStatement": {
          "!type": "fn(body: [Statement]) -> BlockStatement",
          "!doc": "Builds an AST node of type 'BlockStatement'.\nSuper types: Statement, Node, Printable"
        },
        "unaryExpression": {
          "!type": "fn(operator: string, argument: Expression, prefix: boolean) -> UnaryExpression",
          "!doc": "Builds an AST node of type 'UnaryExpression'.\nSuper types: Expression, Pattern, Node, Printable\n\n operator (string) one of: -|+|!|~|typeof|void|delete\n"
        },
        "objectExpression": {
          "!type": "fn(properties: [Property|SpreadProperty]) -> ObjectExpression",
          "!doc": "Builds an AST node of type 'ObjectExpression'.\nSuper types: Expression, Pattern, Node, Printable"
        },
        "tupleTypeAnnotation": {
          "!type": "fn(types: [Type]) -> TupleTypeAnnotation",
          "!doc": "Builds an AST node of type 'TupleTypeAnnotation'.\nSuper types: Type, Node, Printable"
        },
        "interfaceExtends": {
          "!type": "fn(id: Identifier) -> InterfaceExtends",
          "!doc": "Builds an AST node of type 'InterfaceExtends'.\nSuper types: Node, Printable"
        },
        "importDefaultSpecifier": {
          "!type": "fn(local: Identifier|null) -> ImportDefaultSpecifier",
          "!doc": "Builds an AST node of type 'ImportDefaultSpecifier'.\nSuper types: ModuleSpecifier, Specifier, Node, Printable"
        }
      }
    },
    "Collection": {
      "!type:": "fn(source: [+NodePath], parent: +Collection)",
      "prototype": {
        "filter": {
          "!type": "fn(callback: fn(path: +NodePath) -> bool) -> +Collection",
          "!doc": "Returns a new collection containing the nodes for which the callback returns true.",
          "!effects": [
            "call !0 this=+NodePath +NodePath"
          ]
        },
        "forEach": {
          "!type": "fn(callback: fn(path: +NodePath)) -> !this",
          "!doc": "Executes callback for each NodePath in the collection.",
          "!effects": [
            "call !0 this=+NodePath +NodePath"
          ]
        },
        "map": {
          "!type": "fn(callback: fn(path: +NodePath) -> +NodePath|[+NodePath]) -> +Collection",
          "!doc": "Executes the callback for every path in the collection and returns a\nnew collection from the return values (which must be paths).\n\nThe callback can return null to remove the element from the new collection.\n\nIf an array is returned, it will be flattened into the result colletion.\n",
          "!effects": [
            "call !0 this=+NodePath +NodePath"
          ]
        },
        "size": {
          "!type": "fn() -> number",
          "!doc": "Returns the number of elements in this collection."
        },
        "nodes": {
          "!type": "fn() -> [ASTNode]",
          "!doc": "Returns an array of AST nodes in this collection."
        },
        "paths": {
          "!type": "fn() -> [NodePath]",
          "!doc": "Returns an array of NodePaths in this this collection."
        },
        "toSource": {
          "!type": "fn(options?: object) -> string",
          "!doc": "Converts the AST back to a string, using recast. The options are directly passed to recast's printer."
        },
        "at": {
          "!type": "fn(index: number) -> +Collection",
          "!doc": "Returns a new collection containing only the element at the position\n`index`. In case of a negative index, the element is taken from the end.\n"
        },
        "get": {
          "!type": "fn(name: string|number) -> +NodePath",
          "!doc": "Calls \"get\" on the first path (same as \"collection.paths(0).get(...)\")."
        },
        "find": {
          "!type": "fn(type: TypeDefinition, filter?: object) -> +Collection",
          "!doc": "Finds descendants of a specific type within the Nodes of this collection."
        },
        "closestScope": {
          "!type": "fn() -> +Collection",
          "!doc": "Returns a collection containing the Paths that create the scope which contains the selected Nodes."
        },
        "closest": {
          "!type": "fn(type: TypeDefinition, filter?: object) -> +Collection",
          "!doc": "For each node in the collection, traverses the AST up and finds the closest node that matches the type and filter."
        },
        "replaceWith": {
          "!type": "fn(nodes: ASTNode|fn(path: +NodePath, index: number) -> ASTNode|[ASTNode]) -> !this",
          "!doc": "Replaces the selected nodes with the provided node(s). If a function is\nprovided, it is executed for every node and the node is replaced with\nthe return value of the function.\n",
          "!effects": [
            "call !0 this=+NodePath +NodePath number"
          ]
        },
        "insertBefore": {
          "!type": "fn(nodes: ASTNode|[ASTNode]|fn(path: +NodePath, index: number) -> ASTNode|[ASTNode]) -> !this",
          "!doc": "Inserts the new node(s) before each of the selected nodes. If a function\nis provided, it is executed for every node and return value is inserted\nbefore that node.\n",
          "!effects": [
            "call !0 this=+NodePath +NodePath"
          ]
        },
        "insertAfter": {
          "!type": "fn(nodes: ASTNode|[ASTNode]|fn(path: +NodePath, index: number) -> ASTNode|[ASTNode]) -> !this",
          "!doc": "Inserts the new node(s) after each of the selected nodes. If a function\nis provided, it is executed for every node and return value is inserted\nafter that node.\n",
          "!effects": [
            "call !0 this=+NodePath +NodePath"
          ]
        },
        "remove": {
          "!type": "fn() -> !this",
          "!doc": "Calls \"prune\" on every selected NodePath."
        }
      }
    },
    "NodePath": {
      "!type": "fn(value: ASTNode|[ASTNode], parentPath: +NodePath, name: string)",
      "!effects": [
        "propagate !0 !this.value"
      ],
      "prototype": {
        "parentPath": "+NodePath",
        "name": "string",
        "node": {
          "!type": "ASTNode",
          "!doc": "The value of the first ancestor NodePath whose value is a Node."
        },
        "parent": {
          "!type": "+NodePath",
          "!doc": "The first ancestor Path whose value is a Node distinct from this.node."
        },
        "scope": {
          "!type": "+Scope",
          "!doc": "The closest enclosing scope that governs this node."
        },
        "replace": {
          "!type": "fn(newNode?: ASTNode|[ASTNode])",
          "!doc": "Replaces the Node(s) represented by this Path, or removes it if no argument is passed."
        },
        "prune": {
          "!type": "fn()",
          "!doc": "Removes this Node and any ancestor that would become \"empty\"."
        },
        "getValueProperty": {
          "!type": "fn(name: string) -> ?",
          "!doc": "Returns the value of of that property. This is different from 'path.node.value' because\nit will return the default value for that field as defined in the Node definition.\n"
        },
        "each": {
          "!type": "fn(callback: fn(childPath: +NodePath), context?: ?)",
          "!doc": "If the Path represents an array of nodes, applies the provided function to each\nNode in the array.\n",
          "!effects": [
            "call !0 this=!1 !this.value.<i> !this"
          ]
        },
        "map": {
          "!type": "fn(callback: fn(childPath: +NodePath) -> ?, context?: ?) -> [?]",
          "!doc": "If the Path represents an array of nodes, applies the provided function to each\nNode in the array and returns an array of the results.\n",
          "!effects": [
            "call !0 this=!1 !this.value.<i> !this"
          ]
        },
        "filter": {
          "!type": "fn(callback: fn(childPath: +NodePath) -> bool, context?: ?) -> [+NodePath]",
          "!doc": "If the Path represents an array of nodes, applies the provided function to each\nNode in the array and returns an array of Paths for which the callback returned true.\n",
          "!effects": [
            "call !0 this=!1 !this.value.<i> !this"
          ]
        },
        "shift": {
          "!type": "fn() -> +NodePath",
          "!doc": "If the Path represents an array of nodes, removes the first Node in that array and returns it.\n"
        },
        "unshift": {
          "!type": "fn(newNode: ASTNode)"
        },
        "push": {
          "!type": "fn(newNode: ASTNode)"
        },
        "pop": {
          "!type": "fn() -> NodePath"
        },
        "insertAt": {
          "!type": "fn(index: number, node: ASTNode)"
        },
        "insertBefore": {
          "!type": "fn(node: ASTNode)"
        },
        "insertAfter": {
          "!type": "fn(node: ASTNode)"
        }
      }
    },
    "ASTNode": {
      "type": {
        "!type": "string",
        "!doc": "The type of this AST node."
      }
    },
    "Scope": {
      "!type": "fn(path: +NodePath, parentScope: +Scope)",
      "isEstablishedBy": "fn(node: ASTNode) -> bool",
      "prototype": {
        "declares": "fn(name: string) -> bool",
        "declaresType": "fn(name: string) -> bool",
        "declareTemporary": "fn(prefix: string) -> Identifier",
        "injectTemporary": "fn(prefix: string, init?: ASTNode) -> Identifier",
        "getBindings": "fn() -> [ASTNode]",
        "getTypes": "fn() -> [ASTNode]",
        "lookup": "fn(name: string) -> +Scope",
        "lookupType": "fn(name: string) -> +Scope"
      },
      "getGlobalScope": "fn() -> +Scope"
    },
    "ModuleSpecifier": {
      "!proto": "ASTNode"
    },
    "ConditionalExpression": {
      "!proto": "ASTNode"
    },
    "Node": {
      "!proto": "ASTNode"
    },
    "MixedTypeAnnotation": {
      "!proto": "ASTNode"
    },
    "XMLAttributeSelector": {
      "!proto": "ASTNode"
    },
    "JSXNamespacedName": {
      "!proto": "ASTNode"
    },
    "GenericTypeAnnotation": {
      "!proto": "ASTNode"
    },
    "XMLFunctionQualifiedIdentifier": {
      "!proto": "ASTNode"
    },
    "ClassPropertyDefinition": {
      "!proto": "ASTNode"
    },
    "NullableTypeAnnotation": {
      "!proto": "ASTNode"
    },
    "ForInStatement": {
      "!proto": "ASTNode"
    },
    "YieldExpression": {
      "!proto": "ASTNode"
    },
    "ClassProperty": {
      "!proto": "ASTNode"
    },
    "XMLDefaultDeclaration": {
      "!proto": "ASTNode"
    },
    "TemplateElement": {
      "!proto": "ASTNode"
    },
    "ExportDefaultDeclaration": {
      "!proto": "ASTNode"
    },
    "TupleTypeAnnotation": {
      "!proto": "ASTNode"
    },
    "GraphExpression": {
      "!proto": "ASTNode"
    },
    "MemberExpression": {
      "!proto": "ASTNode"
    },
    "ImportDeclaration": {
      "!proto": "ASTNode"
    },
    "File": {
      "!proto": "ASTNode"
    },
    "JSXSpreadAttribute": {
      "!proto": "ASTNode"
    },
    "XMLName": {
      "!proto": "ASTNode"
    },
    "ClassExpression": {
      "!proto": "ASTNode"
    },
    "TemplateLiteral": {
      "!proto": "ASTNode"
    },
    "ClassImplements": {
      "!proto": "ASTNode"
    },
    "TypeAlias": {
      "!proto": "ASTNode"
    },
    "StringLiteralTypeAnnotation": {
      "!proto": "ASTNode"
    },
    "TaggedTemplateExpression": {
      "!proto": "ASTNode"
    },
    "Identifier": {
      "!proto": "ASTNode"
    },
    "JSXElement": {
      "!proto": "ASTNode"
    },
    "BooleanLiteralTypeAnnotation": {
      "!proto": "ASTNode"
    },
    "MethodDefinition": {
      "!proto": "ASTNode"
    },
    "Line": {
      "!proto": "ASTNode"
    },
    "GeneratorExpression": {
      "!proto": "ASTNode"
    },
    "LetStatement": {
      "!proto": "ASTNode"
    },
    "Literal": {
      "!proto": "ASTNode"
    },
    "BooleanTypeAnnotation": {
      "!proto": "ASTNode"
    },
    "JSXAttribute": {
      "!proto": "ASTNode"
    },
    "ExportNamespaceSpecifier": {
      "!proto": "ASTNode"
    },
    "ArrayTypeAnnotation": {
      "!proto": "ASTNode"
    },
    "BlockStatement": {
      "!proto": "ASTNode"
    },
    "WithStatement": {
      "!proto": "ASTNode"
    },
    "XMLProcessingInstruction": {
      "!proto": "ASTNode"
    },
    "SpreadPropertyPattern": {
      "!proto": "ASTNode"
    },
    "WhileStatement": {
      "!proto": "ASTNode"
    },
    "ThrowStatement": {
      "!proto": "ASTNode"
    },
    "InterfaceDeclaration": {
      "!proto": "ASTNode"
    },
    "TypeofTypeAnnotation": {
      "!proto": "ASTNode"
    },
    "LetExpression": {
      "!proto": "ASTNode"
    },
    "ExportSpecifier": {
      "!proto": "ASTNode"
    },
    "ContinueStatement": {
      "!proto": "ASTNode"
    },
    "Printable": {
      "!proto": "ASTNode"
    },
    "ThisExpression": {
      "!proto": "ASTNode"
    },
    "IntersectionTypeAnnotation": {
      "!proto": "ASTNode"
    },
    "JSXClosingElement": {
      "!proto": "ASTNode"
    },
    "DeclareFunction": {
      "!proto": "ASTNode"
    },
    "VariableDeclaration": {
      "!proto": "ASTNode"
    },
    "BreakStatement": {
      "!proto": "ASTNode"
    },
    "ImportSpecifier": {
      "!proto": "ASTNode"
    },
    "ParenthesizedExpression": {
      "!proto": "ASTNode"
    },
    "RestElement": {
      "!proto": "ASTNode"
    },
    "Specifier": {
      "!proto": "ASTNode"
    },
    "ArrayExpression": {
      "!proto": "ASTNode"
    },
    "XMLAnyName": {
      "!proto": "ASTNode"
    },
    "ExportDeclaration": {
      "!proto": "ASTNode"
    },
    "ObjectTypeAnnotation": {
      "!proto": "ASTNode"
    },
    "ExportAllDeclaration": {
      "!proto": "ASTNode"
    },
    "SourceLocation": {
      "!proto": "ASTNode"
    },
    "TypeAnnotation": {
      "!proto": "ASTNode"
    },
    "Statement": {
      "!proto": "ASTNode"
    },
    "Position": {
      "!proto": "ASTNode"
    },
    "ObjectExpression": {
      "!proto": "ASTNode"
    },
    "Program": {
      "!proto": "ASTNode"
    },
    "Comment": {
      "!proto": "ASTNode"
    },
    "AssignmentPattern": {
      "!proto": "ASTNode"
    },
    "ObjectTypeIndexer": {
      "!proto": "ASTNode"
    },
    "ArrowFunctionExpression": {
      "!proto": "ASTNode"
    },
    "XMLAttribute": {
      "!proto": "ASTNode"
    },
    "Noop": {
      "!proto": "ASTNode"
    },
    "DeclareClass": {
      "!proto": "ASTNode"
    },
    "XMLEndTag": {
      "!proto": "ASTNode"
    },
    "JSXIdentifier": {
      "!proto": "ASTNode"
    },
    "VoidTypeAnnotation": {
      "!proto": "ASTNode"
    },
    "ComprehensionBlock": {
      "!proto": "ASTNode"
    },
    "FunctionTypeAnnotation": {
      "!proto": "ASTNode"
    },
    "ComprehensionExpression": {
      "!proto": "ASTNode"
    },
    "MetaProperty": {
      "!proto": "ASTNode"
    },
    "XMLQualifiedIdentifier": {
      "!proto": "ASTNode"
    },
    "DoWhileStatement": {
      "!proto": "ASTNode"
    },
    "EmptyStatement": {
      "!proto": "ASTNode"
    },
    "VariableDeclarator": {
      "!proto": "ASTNode"
    },
    "ObjectPattern": {
      "!proto": "ASTNode"
    },
    "AssignmentExpression": {
      "!proto": "ASTNode"
    },
    "Declaration": {
      "!proto": "ASTNode"
    },
    "DoExpression": {
      "!proto": "ASTNode"
    },
    "GraphIndexExpression": {
      "!proto": "ASTNode"
    },
    "DeclareVariable": {
      "!proto": "ASTNode"
    },
    "ObjectTypeProperty": {
      "!proto": "ASTNode"
    },
    "IfStatement": {
      "!proto": "ASTNode"
    },
    "BindExpression": {
      "!proto": "ASTNode"
    },
    "LogicalExpression": {
      "!proto": "ASTNode"
    },
    "CommentLine": {
      "!proto": "ASTNode"
    },
    "ObjectTypeCallProperty": {
      "!proto": "ASTNode"
    },
    "FunctionDeclaration": {
      "!proto": "ASTNode"
    },
    "NewExpression": {
      "!proto": "ASTNode"
    },
    "TypeCastExpression": {
      "!proto": "ASTNode"
    },
    "XMLStartTag": {
      "!proto": "ASTNode"
    },
    "XMLPointTag": {
      "!proto": "ASTNode"
    },
    "Pattern": {
      "!proto": "ASTNode"
    },
    "ImportDefaultSpecifier": {
      "!proto": "ASTNode"
    },
    "XMLFilterExpression": {
      "!proto": "ASTNode"
    },
    "XMLEscape": {
      "!proto": "ASTNode"
    },
    "JSXEmptyExpression": {
      "!proto": "ASTNode"
    },
    "SequenceExpression": {
      "!proto": "ASTNode"
    },
    "InterfaceExtends": {
      "!proto": "ASTNode"
    },
    "PropertyPattern": {
      "!proto": "ASTNode"
    },
    "CatchClause": {
      "!proto": "ASTNode"
    },
    "SpreadElement": {
      "!proto": "ASTNode"
    },
    "FunctionTypeParam": {
      "!proto": "ASTNode"
    },
    "Property": {
      "!proto": "ASTNode"
    },
    "JSXOpeningElement": {
      "!proto": "ASTNode"
    },
    "StringTypeAnnotation": {
      "!proto": "ASTNode"
    },
    "ForStatement": {
      "!proto": "ASTNode"
    },
    "Decorator": {
      "!proto": "ASTNode"
    },
    "SpreadElementPattern": {
      "!proto": "ASTNode"
    },
    "JSXMemberExpression": {
      "!proto": "ASTNode"
    },
    "FunctionExpression": {
      "!proto": "ASTNode"
    },
    "BinaryExpression": {
      "!proto": "ASTNode"
    },
    "TryStatement": {
      "!proto": "ASTNode"
    },
    "Expression": {
      "!proto": "ASTNode"
    },
    "ExportNamedDeclaration": {
      "!proto": "ASTNode"
    },
    "SwitchStatement": {
      "!proto": "ASTNode"
    },
    "Block": {
      "!proto": "ASTNode"
    },
    "ExportBatchSpecifier": {
      "!proto": "ASTNode"
    },
    "ExpressionStatement": {
      "!proto": "ASTNode"
    },
    "ArrayPattern": {
      "!proto": "ASTNode"
    },
    "XMLList": {
      "!proto": "ASTNode"
    },
    "ReturnStatement": {
      "!proto": "ASTNode"
    },
    "CallExpression": {
      "!proto": "ASTNode"
    },
    "DeclareModule": {
      "!proto": "ASTNode"
    },
    "NumberLiteralTypeAnnotation": {
      "!proto": "ASTNode"
    },
    "Type": {
      "!proto": "ASTNode"
    },
    "TypeParameterDeclaration": {
      "!proto": "ASTNode"
    },
    "XMLText": {
      "!proto": "ASTNode"
    },
    "Function": {
      "!proto": "ASTNode"
    },
    "UnaryExpression": {
      "!proto": "ASTNode"
    },
    "XML": {
      "!proto": "ASTNode"
    },
    "Super": {
      "!proto": "ASTNode"
    },
    "TypeParameterInstantiation": {
      "!proto": "ASTNode"
    },
    "XMLComment": {
      "!proto": "ASTNode"
    },
    "MemberTypeAnnotation": {
      "!proto": "ASTNode"
    },
    "SwitchCase": {
      "!proto": "ASTNode"
    },
    "AwaitExpression": {
      "!proto": "ASTNode"
    },
    "ExportDefaultSpecifier": {
      "!proto": "ASTNode"
    },
    "XMLElement": {
      "!proto": "ASTNode"
    },
    "AnyTypeAnnotation": {
      "!proto": "ASTNode"
    },
    "CommentBlock": {
      "!proto": "ASTNode"
    },
    "ClassBody": {
      "!proto": "ASTNode"
    },
    "ImportNamespaceSpecifier": {
      "!proto": "ASTNode"
    },
    "JSXExpressionContainer": {
      "!proto": "ASTNode"
    },
    "DeclareExportDeclaration": {
      "!proto": "ASTNode"
    },
    "UnionTypeAnnotation": {
      "!proto": "ASTNode"
    },
    "XMLCdata": {
      "!proto": "ASTNode"
    },
    "JSXText": {
      "!proto": "ASTNode"
    },
    "QualifiedTypeIdentifier": {
      "!proto": "ASTNode"
    },
    "DebuggerStatement": {
      "!proto": "ASTNode"
    },
    "ForOfStatement": {
      "!proto": "ASTNode"
    },
    "LabeledStatement": {
      "!proto": "ASTNode"
    },
    "SpreadProperty": {
      "!proto": "ASTNode"
    },
    "UpdateExpression": {
      "!proto": "ASTNode"
    },
    "ClassDeclaration": {
      "!proto": "ASTNode"
    },
    "NumberTypeAnnotation": {
      "!proto": "ASTNode"
    },
    "TemplateElementValue": {
      "cooked": "string",
      "raw": "string"
    },
    "TypeDefinition": {
      "name": "string",
      "check": "fn(node: Node, deep: ?) -> bool"
    }
  }
}
